(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[87],{

/***/ "./node_modules/tenko/build/tenko.prod.mjs":
/*!*************************************************!*\
  !*** ./node_modules/tenko/build/tenko.prod.mjs ***!
  \*************************************************/
/*! exports provided: default, Tenko, Lexer, COLLECT_TOKENS_NONE, COLLECT_TOKENS_SOLID, COLLECT_TOKENS_ALL, COLLECT_TOKENS_TYPES, GOAL_MODULE, GOAL_SCRIPT, WEB_COMPAT_OFF, WEB_COMPAT_ON, VERSION_EXPONENTIATION, VERSION_WHATEVER, isWhiteToken, isNewlineToken, isCommentToken, isIdentToken, isNumberToken, isBigintToken, isStringToken, isPunctuatorToken, isRegexToken, isTickToken, isBadTickToken, isNumberStringToken, isNumberStringRegex, toktypeToString */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tenko\", function() { return Tenko; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_NONE\", function() { return COLLECT_TOKENS_NONE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_SOLID\", function() { return COLLECT_TOKENS_SOLID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_ALL\", function() { return COLLECT_TOKENS_ALL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COLLECT_TOKENS_TYPES\", function() { return COLLECT_TOKENS_TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GOAL_MODULE\", function() { return GOAL_MODULE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GOAL_SCRIPT\", function() { return GOAL_SCRIPT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WEB_COMPAT_OFF\", function() { return WEB_COMPAT_OFF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WEB_COMPAT_ON\", function() { return WEB_COMPAT_ON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION_EXPONENTIATION\", function() { return VERSION_EXPONENTIATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION_WHATEVER\", function() { return VERSION_WHATEVER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWhiteToken\", function() { return isWhiteToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNewlineToken\", function() { return isNewlineToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCommentToken\", function() { return isCommentToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentToken\", function() { return isIdentToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberToken\", function() { return isNumberToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBigintToken\", function() { return isBigintToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStringToken\", function() { return isStringToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPunctuatorToken\", function() { return isPunctuatorToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRegexToken\", function() { return isRegexToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTickToken\", function() { return isTickToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBadTickToken\", function() { return isBadTickToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberStringToken\", function() { return isNumberStringToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberStringRegex\", function() { return isNumberStringRegex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toktypeToString\", function() { return toktypeToString; });\n\n\n\n\n// <perf>\nlet IGNORE = {};\n// </perf>\n\n// <charcodes>\n\n// </charcodes>\n\n// <utils>\nfunction inspect(...args) {\nconsole.dir(((args.length === 1)? args[0] : args), {depth:null});\n}\nfunction THROW(str, ...rest) {\nthrow new Error(`Parser error! ${str} ${(rest.length? rest : '')}`);\n}\n// </utils>\n\n// <tokentype>\nlet __$flag_leaf = 0;\nlet __$flag_group = 7;\nlet ALL_GEES;\nlet KEYWORD_TRIE_OBJLIT = {0:{17:{6:{20:{12:{4:{13:{19:{18:{hit:2072, canon:'arguments'}}}}}}}}, 18:{24:{13:{2:{hit:2074, canon:'async'}}}, hit:2073, canon:'as'}, 22:{0:{8:{19:{hit:2075, canon:'await'}}}}}, 1:{17:{4:{0:{10:{hit:2076, canon:'break'}}}}}, 2:{0:{18:{4:{hit:2077, canon:'case'}}, 19:{2:{7:{hit:2078, canon:'catch'}}}}, 11:{0:{18:{18:{hit:2079, canon:'class'}}}}, 14:{13:{18:{19:{hit:2080, canon:'const'}}, 19:{8:{13:{20:{4:{hit:2081, canon:'continue'}}}}}}}}, 3:{4:{1:{20:{6:{6:{4:{17:{hit:2082, canon:'debugger'}}}}}}, 5:{0:{20:{11:{19:{hit:2083, canon:'default'}}}}}, 11:{4:{19:{4:{hit:2084, canon:'delete'}}}}}, 14:{hit:2085, canon:'do'}}, 4:{11:{18:{4:{hit:2086, canon:'else'}}}, 13:{20:{12:{hit:2087, canon:'enum'}}}, 21:{0:{11:{hit:2088, canon:'eval'}}}, 23:{15:{14:{17:{19:{hit:2089, canon:'export'}}}}, 19:{4:{13:{3:{18:{hit:2090, canon:'extends'}}}}}}}, 5:{0:{11:{18:{4:{hit:2091, canon:'false'}}}}, 8:{13:{0:{11:{11:{24:{hit:2092, canon:'finally'}}}}}}, 14:{17:{hit:2093, canon:'for'}}, 17:{14:{12:{hit:2094, canon:'from'}}}, 20:{13:{2:{19:{8:{14:{13:{hit:2095, canon:'function'}}}}}}}}, 6:{4:{19:{hit:2096, canon:'get'}}}, 8:{5:{hit:2097, canon:'if'}, 12:{15:{11:{4:{12:{4:{13:{19:{18:{hit:2098, canon:'implements'}}}}}}}, 14:{17:{19:{hit:2099, canon:'import'}}}}}, 13:{18:{19:{0:{13:{2:{4:{14:{5:{hit:67637, canon:'instanceof'}}}}}}}}, 19:{4:{17:{5:{0:{2:{4:{hit:2102, canon:'interface'}}}}}}}, hit:67636, canon:'in'}}, 11:{4:{19:{hit:2103, canon:'let'}}}, 13:{4:{22:{hit:2104, canon:'new'}}, 20:{11:{11:{hit:2105, canon:'null'}}}}, 14:{5:{hit:2106, canon:'of'}}, 15:{0:{2:{10:{0:{6:{4:{hit:2107, canon:'package'}}}}}}, 17:{8:{21:{0:{19:{4:{hit:2108, canon:'private'}}}}}, 14:{19:{4:{2:{19:{4:{3:{hit:2109, canon:'protected'}}}}}}}}, 20:{1:{11:{8:{2:{hit:2110, canon:'public'}}}}}}, 17:{4:{19:{20:{17:{13:{hit:2111, canon:'return'}}}}}}, 18:{4:{19:{hit:2112, canon:'set'}}, 19:{0:{19:{8:{2:{hit:2113, canon:'static'}}}}}, 20:{15:{4:{17:{hit:2114, canon:'super'}}}}, 22:{8:{19:{2:{7:{hit:2115, canon:'switch'}}}}}}, 19:{0:{17:{6:{4:{19:{hit:2116, canon:'target'}}}}}, 7:{8:{18:{hit:2117, canon:'this'}}, 17:{14:{22:{hit:2118, canon:'throw'}}}}, 17:{20:{4:{hit:2119, canon:'true'}}, 24:{hit:2120, canon:'try'}}, 24:{15:{4:{14:{5:{hit:2121, canon:'typeof'}}}}}}, 21:{0:{17:{hit:2122, canon:'var'}}, 14:{8:{3:{hit:2123, canon:'void'}}}}, 22:{7:{8:{11:{4:{hit:2124, canon:'while'}}}}, 8:{19:{7:{hit:2125, canon:'with'}}}}, 24:{8:{4:{11:{3:{hit:2126, canon:'yield'}}}}}};\nfunction isWhiteToken(type) {\nreturn (type & 256) === 256;\n}\nfunction isNewlineToken(type) {\nreturn (type & 512) === 512;\n}\nfunction isCommentToken(type) {\nreturn (type & 1024) === 1024;\n}\nfunction isIdentToken(type) {\nreturn (type & 2048) === 2048;\n}\nfunction isNumberToken(type) {\nreturn (type & 4096) === 4096;\n}\nfunction isBigintToken(type) {\nreturn (type & 8192) === 8192;\n}\nfunction isStringToken(type) {\nreturn (type & 131072) === 131072;\n}\nfunction isPunctuatorToken(type) {\nreturn (type & 16384) === 16384;\n}\nfunction isRegexToken(type) {\nreturn (type & 262144) === 262144;\n}\nfunction isTickToken(type) {\nreturn (type & 524288) === 524288;\n}\nfunction isBadTickToken(type) {\nreturn (type & 1048576) === 1048576;\n}\nfunction isNumberStringToken(type) {\nreturn (type & 135168) !== 0;\n}\nfunction isNumberStringRegex(type) {\nreturn (type & 397312) !== 0;\n}\nfunction toktypeToString(type, token, ignoreUnknown) {\nswitch ((((typeof type) === 'object')? type.type : type)) {\ncase 0:\nreturn 'UNTYPED';\ncase 257:\nreturn 'SPACE';\ncase 258:\nreturn 'TAB';\ncase 771:\nreturn 'NL_SOLO';\ncase 772:\nreturn 'NL_CRLF';\ncase 1285:\nreturn 'COMMENT_SINGLE';\ncase 1286:\nreturn 'COMMENT_MULTI';\ncase 1287:\nreturn 'COMMENT_HTML';\ncase 2048:\nreturn 'IDENT';\ncase 2072:\nreturn 'ID_arguments';\ncase 2073:\nreturn 'ID_as';\ncase 2074:\nreturn 'ID_async';\ncase 2075:\nreturn 'ID_await';\ncase 2076:\nreturn 'ID_break';\ncase 2077:\nreturn 'ID_case';\ncase 2078:\nreturn 'ID_catch';\ncase 2079:\nreturn 'ID_class';\ncase 2080:\nreturn 'ID_const';\ncase 2081:\nreturn 'ID_continue';\ncase 2082:\nreturn 'ID_debugger';\ncase 2083:\nreturn 'ID_default';\ncase 2084:\nreturn 'ID_delete';\ncase 2085:\nreturn 'ID_do';\ncase 2086:\nreturn 'ID_else';\ncase 2087:\nreturn 'ID_enum';\ncase 2088:\nreturn 'ID_eval';\ncase 2089:\nreturn 'ID_export';\ncase 2090:\nreturn 'ID_extends';\ncase 2091:\nreturn 'ID_false';\ncase 2092:\nreturn 'ID_finally';\ncase 2093:\nreturn 'ID_for';\ncase 2094:\nreturn 'ID_from';\ncase 2095:\nreturn 'ID_function';\ncase 2096:\nreturn 'ID_get';\ncase 2097:\nreturn 'ID_if';\ncase 2098:\nreturn 'ID_implements';\ncase 2099:\nreturn 'ID_import';\ncase 67636:\nreturn 'ID_in';\ncase 67637:\nreturn 'ID_instanceof';\ncase 2102:\nreturn 'ID_interface';\ncase 2103:\nreturn 'ID_let';\ncase 2104:\nreturn 'ID_new';\ncase 2105:\nreturn 'ID_null';\ncase 2106:\nreturn 'ID_of';\ncase 2107:\nreturn 'ID_package';\ncase 2108:\nreturn 'ID_private';\ncase 2109:\nreturn 'ID_protected';\ncase 2110:\nreturn 'ID_public';\ncase 2111:\nreturn 'ID_return';\ncase 2112:\nreturn 'ID_set';\ncase 2113:\nreturn 'ID_static';\ncase 2114:\nreturn 'ID_super';\ncase 2115:\nreturn 'ID_switch';\ncase 2116:\nreturn 'ID_target';\ncase 2117:\nreturn 'ID_this';\ncase 2118:\nreturn 'ID_throw';\ncase 2119:\nreturn 'ID_true';\ncase 2120:\nreturn 'ID_try';\ncase 2121:\nreturn 'ID_typeof';\ncase 2122:\nreturn 'ID_var';\ncase 2123:\nreturn 'ID_void';\ncase 2124:\nreturn 'ID_while';\ncase 2125:\nreturn 'ID_with';\ncase 2126:\nreturn 'ID_yield';\ncase 4104:\nreturn 'NUMBER_HEX';\ncase 4105:\nreturn 'NUMBER_DEC';\ncase 4106:\nreturn 'NUMBER_BIN';\ncase 4107:\nreturn 'NUMBER_OCT';\ncase 4108:\nreturn 'NUMBER_OLD';\ncase 12296:\nreturn 'NUMBER_BIG_HEX';\ncase 12297:\nreturn 'NUMBER_BIG_DEC';\ncase 12298:\nreturn 'NUMBER_BIG_BIN';\ncase 12299:\nreturn 'NUMBER_BIG_OCT';\ncase 16463:\nreturn 'PUNC_EXCL';\ncase 82000:\nreturn 'PUNC_EXCL_EQ';\ncase 82001:\nreturn 'PUNC_EXCL_EQ_EQ';\ncase 82002:\nreturn 'PUNC_PERCENT';\ncase 49235:\nreturn 'PUNC_PERCENT_EQ';\ncase 82004:\nreturn 'PUNC_AND';\ncase 82005:\nreturn 'PUNC_AND_AND';\ncase 49238:\nreturn 'PUNC_AND_EQ';\ncase 16471:\nreturn 'PUNC_PAREN_OPEN';\ncase 16472:\nreturn 'PUNC_PAREN_CLOSE';\ncase 82009:\nreturn 'PUNC_STAR';\ncase 82010:\nreturn 'PUNC_STAR_STAR';\ncase 49243:\nreturn 'PUNC_STAR_EQ';\ncase 49244:\nreturn 'PUNC_STAR_STAR_EQ';\ncase 82013:\nreturn 'PUNC_PLUS';\ncase 16478:\nreturn 'PUNC_PLUS_PLUS';\ncase 49247:\nreturn 'PUNC_PLUS_EQ';\ncase 16480:\nreturn 'PUNC_COMMA';\ncase 82017:\nreturn 'PUNC_MIN';\ncase 16482:\nreturn 'PUNC_MIN_MIN';\ncase 49251:\nreturn 'PUNC_MIN_EQ';\ncase 16484:\nreturn 'PUNC_MIN_MIN_GT';\ncase 16485:\nreturn 'PUNC_DOT';\ncase 16486:\nreturn 'PUNC_DOT_DOT_DOT';\ncase 82023:\nreturn 'PUNC_DIV';\ncase 49256:\nreturn 'PUNC_DIV_EQ';\ncase 16489:\nreturn 'PUNC_COLON';\ncase 16490:\nreturn 'PUNC_SEMI';\ncase 82027:\nreturn 'PUNC_LT';\ncase 82028:\nreturn 'PUNC_LT_LT';\ncase 82029:\nreturn 'PUNC_LT_EQ';\ncase 49262:\nreturn 'PUNC_LT_LT_EQ';\ncase 16495:\nreturn 'PUNC_LT_EXCL_MIN_MIN';\ncase 49264:\nreturn 'PUNC_EQ';\ncase 82033:\nreturn 'PUNC_EQ_EQ';\ncase 82034:\nreturn 'PUNC_EQ_EQ_EQ';\ncase 16499:\nreturn 'PUNC_EQ_GT';\ncase 82036:\nreturn 'PUNC_GT';\ncase 82037:\nreturn 'PUNC_GT_GT';\ncase 82038:\nreturn 'PUNC_GT_GT_GT';\ncase 82039:\nreturn 'PUNC_GT_EQ';\ncase 49272:\nreturn 'PUNC_GT_GT_EQ';\ncase 49273:\nreturn 'PUNC_GT_GT_GT_EQ';\ncase 16506:\nreturn 'PUNC_QMARK';\ncase 82043:\nreturn 'QMARK_DOT';\ncase 82044:\nreturn 'QMARK_QMARK';\ncase 16509:\nreturn 'PUNC_BRACKET_OPEN';\ncase 16510:\nreturn 'PUNC_BRACKET_CLOSE';\ncase 82047:\nreturn 'PUNC_CARET';\ncase 49280:\nreturn 'PUNC_CARET_EQ';\ncase 16513:\nreturn 'PUNC_CURLY_OPEN';\ncase 82050:\nreturn 'PUNC_OR';\ncase 82051:\nreturn 'PUNC_OR_OR';\ncase 49284:\nreturn 'PUNC_OR_EQ';\ncase 16517:\nreturn 'PUNC_CURLY_CLOSE';\ncase 16518:\nreturn 'PUNC_TILDE';\ncase 262157:\nreturn 'REGEXN';\ncase 262158:\nreturn 'REGEXU';\ncase 131087:\nreturn 'STRING_SINGLE';\ncase 131088:\nreturn 'STRING_DOUBLE';\ncase 524305:\nreturn 'TICK_HEAD';\ncase 524306:\nreturn 'TICK_BODY';\ncase 524307:\nreturn 'TICK_TAIL';\ncase 524308:\nreturn 'TICK_PURE';\ncase 1572881:\nreturn 'TICK_BAD_HEAD';\ncase 1572882:\nreturn 'TICK_BAD_BODY';\ncase 1572883:\nreturn 'TICK_BAD_TAIL';\ncase 1572884:\nreturn 'TICK_BAD_PURE';\ncase 2097173:\nreturn 'EOF';\ncase 2097174:\nreturn 'ASI';\ncase 2097175:\nreturn 'ERROR';\n}\nif (ignoreUnknown) return ('UNKNOWN[' + ((((typeof type) === 'object')? type.type : type))) + ']';\nthrow new Error(('toktypeToString: UNKNOWN[' + JSON.stringify(type)) + ']');\n}\nlet MAX_START_VALUE = 26;\nlet __$flag_start = 0;\nlet tokenStartJumpTable = [26, 26, 26, 26, 26, 26, 26, 26, 26, 1, 4, 1, 1, 5, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 1, 16, 6, 26, 2, 17, 18, 6, 16471, 16472, 19, 12, 16480, 13, 8, 11, 14, 7, 7, 7, 7, 7, 7, 7, 7, 7, 16489, 16490, 21, 10, 22, 25, 26, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 16509, 24, 16510, 20, 2, 15, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 2, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 2, 3, 2, 16513, 23, 9, 16518];\nlet stringScanTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nlet identScanTable = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1];\nlet regexAtomEscapeStartJumpTable = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 0, 1, 11, 11, 11, 0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 6, 11, 11, 0, 11, 11, 11, 0, 11, 11, 11, 0, 0, 0, 0, 11, 1, 11, 11, 5, 0, 11, 0, 11, 11, 11, 11, 9, 11, 11, 0, 11, 6, 11, 0, 0, 0, 2, 0, 0, 3, 11, 11, 0, 0, 0, 1];\nlet regexClassEscapeStartJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 18, 18, 18, 18, 0, 19, 18, 18, 15, 16, 16, 16, 16, 16, 16, 16, 17, 17, 0, 0, 0, 0, 0, 18, 0, 0, 7, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 13, 0, 0, 0, 13, 0, 0, 0, 18, 18, 18, 18, 0, 0, 0, 6, 4, 13, 0, 8, 0, 0, 0, 0, 5, 0, 0, 9, 0, 14, 0, 10, 13, 11, 2, 12, 13, 3, 0, 0, 18, 18, 18, 0];\nlet hexValueJumpTable = [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 16, 16, 16, 16, 16, 16, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 10, 11, 12, 13, 14, 15];\nlet regexAtomJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 3, 4, 2, 2, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 6, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 14, 13, 0];\nlet stringEscapeStartJumpTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 7, 4, 15, 0, 5, 0, 0, 0, 0, 0, 0];\nfunction getTokenStart(c) {\nlet s = tokenStartJumpTable[c];\nreturn s;\n}\nfunction getStringPart(c) {\nif (c > 0x7e) return 3;\nlet s = stringScanTable[c];\nreturn s;\n}\nfunction getIdentPart(c) {\nif (c > 0x7e) return 3;\nlet s = identScanTable[c];\nreturn s;\n}\nfunction getHexValue(c) {\nif (c > 0x66) return 16;\nlet v = hexValueJumpTable[c];\nreturn v;\n}\nfunction T(type) {\nreturn ('T<' + toktypeToString(type)) + '>';\n}\n// </tokentype>\n\n// <lexerflags>\nlet __$flag_lf = 0;\nfunction L(flags) {\nlet bak = flags;\nlet s = [];\nif (!flags) {\ns.push('LF_NO_FLAGS');\n}\nif (flags & 8192) {\nflags ^= 8192;\ns.push('LF_STRICT_MODE');\n}\nif (flags & 4) {\nflags ^= 4;\ns.push('LF_FOR_REGEX');\n}\nif (flags & 2048) {\nflags ^= 2048;\ns.push('LF_IN_TEMPLATE');\n}\nif (flags & 8) {\nflags ^= 8;\ns.push('LF_IN_ASYNC');\n}\nif (flags & 128) {\nflags ^= 128;\ns.push('LF_IN_GENERATOR');\n}\nif (flags & 16) {\nflags ^= 16;\ns.push('LF_IN_CONSTRUCTOR');\n}\nif (flags & 64) {\nflags ^= 64;\ns.push('LF_IN_FUNC_ARGS');\n}\nif (flags & 256) {\nflags ^= 256;\ns.push('LF_IN_GLOBAL');\n}\nif (flags & 512) {\nflags ^= 512;\ns.push('LF_IN_ITERATION');\n}\nif (flags & 1024) {\nflags ^= 1024;\ns.push('LF_IN_SWITCH');\n}\nif (flags & 2) {\nflags ^= 2;\ns.push('LF_CAN_NEW_DOT_TARGET');\n}\nif (flags & 32) {\nflags ^= 32;\ns.push('LF_IN_FOR_LHS');\n}\nif (flags & 4096) {\nflags ^= 4096;\ns.push('LF_NO_ASI');\n}\nif (flags & 16384) {\nflags ^= 16384;\ns.push('LF_SUPER_CALL');\n}\nif (flags & 32768) {\nflags ^= 32768;\ns.push('LF_SUPER_PROP');\n}\nif (flags & 65536) {\nflags ^= 65536;\ns.push('LF_NOT_KEYWORD');\n}\nif (flags) {\nthrow new Error(((((('UNKNOWN_FLAGS: ' + flags.toString(2)) + ' (was: ') + bak.toString(2)) + '), so far: [') + s.join('|')) + ']');\n}\nreturn 'L:' + s.join('|');\n}\n// </lexerflags>\n\n// <enum_lexer>\nconst GOAL_MODULE = true;\nconst GOAL_SCRIPT = false;\nconst COLLECT_TOKENS_NONE = 0;\nconst COLLECT_TOKENS_SOLID = 1;\nconst COLLECT_TOKENS_ALL = 2;\nconst COLLECT_TOKENS_TYPES = 3;\nconst WEB_COMPAT_OFF = false;\nconst WEB_COMPAT_ON = true;\n// </enum_lexer>\n\n// <enum_parser>\nconst VERSION_EXPONENTIATION = 7;\nconst VERSION_WHATEVER = Infinity;\nfunction DEVONLY() {\nlet dev = false;\nreturn dev;\n}\nfunction copyPiggies(output, input) {\nreturn output | (input & 1984);\n}\nfunction P(f, arr) {\nif (f & 256) {\narr.push('PIGGY_BACK_WAS_CONSTRUCTOR');\nf ^= 256;\n}\nif (f & 512) {\narr.push('PIGGY_BACK_WAS_PROTO');\nf ^= 512;\n}\nif (f & 64) {\narr.push('PIGGY_BACK_SAW_AWAIT');\nf ^= 64;\n}\nif (f & 128) {\narr.push('PIGGY_BACK_SAW_YIELD');\nf ^= 128;\n}\nif (f & 1024) {\narr.push('PIGGY_BACK_WAS_ARROW');\nf ^= 1024;\n}\nreturn f;\n}\n// </enum_parser>\n\n// <lexer>\nconst TABLE_NONBIN_UNI_PROPS = ',General_Category,gc,Script,sc,Script_Extensions,scx,';\nconst TABLE_BIN_UNI_PROPS = ',ASCII,ASCII_Hex_Digit,AHex,Alphabetic,Alpha,Any,Assigned,Bidi_Control,Bidi_C,Bidi_Mirrored,Bidi_M,Case_Ignorable,CI,Cased,Changes_When_Casefolded,CWCF,Changes_When_Casemapped,CWCM,Changes_When_Lowercased,CWL,Changes_When_NFKC_Casefolded,CWKCF,Changes_When_Titlecased,CWT,Changes_When_Uppercased,CWU,Dash,Default_Ignorable_Code_Point,DI,Deprecated,Dep,Diacritic,Dia,Emoji,Emoji_Component,Emoji_Modifier,Emoji_Modifier_Base,Emoji_Presentation,Extended_Pictographic,Extender,Ext,Grapheme_Base,Gr_Base,Grapheme_Extend,Gr_Ext,Hex_Digit,Hex,IDS_Binary_Operator,IDSB,IDS_Trinary_Operator,IDST,ID_Continue,IDC,ID_Start,IDS,Ideographic,Ideo,Join_Control,Join_C,Logical_Order_Exception,LOE,Lowercase,Lower,Math,Noncharacter_Code_Point,NChar,Pattern_Syntax,Pat_Syn,Pattern_White_Space,Pat_WS,Quotation_Mark,QMark,Radical,Regional_Indicator,RI,Sentence_Terminal,STerm,Soft_Dotted,SD,Terminal_Punctuation,Term,Unified_Ideograph,UIdeo,Uppercase,Upper,Variation_Selector,VS,White_Space,space,XID_Continue,XIDC,XID_Start,XIDS,';\nconst TABLE_GEN_CAT_VALUES = ',Cased_Letter,LC,Close_Punctuation,Pe,Connector_Punctuation,Pc,Control,Cc,cntrl,Currency_Symbol,Sc,Dash_Punctuation,Pd,Decimal_Number,Nd,digit,Enclosing_Mark,Me,Final_Punctuation,Pf,Format,Cf,Initial_Punctuation,Pi,Letter,L,Letter_Number,Nl,Line_Separator,Zl,Lowercase_Letter,Ll,Mark,M,Combining_Mark,Math_Symbol,Sm,Modifier_Letter,Lm,Modifier_Symbol,Sk,Nonspacing_Mark,Mn,Number,N,Open_Punctuation,Ps,Other,C,Other_Letter,Lo,Other_Number,No,Other_Punctuation,Po,Other_Symbol,So,Paragraph_Separator,Zp,Private_Use,Co,Punctuation,P,punct,Separator,Z,Space_Separator,Zs,Spacing_Mark,Mc,Surrogate,Cs,Symbol,S,Titlecase_Letter,Lt,Unassigned,Cn,Uppercase_Letter,Lu,';\nconst TABLE_SCRIPT_VALUES = ',Adlam,Adlm,Ahom,Anatolian_Hieroglyphs,Hluw,Arabic,Arab,Armenian,Armn,Avestan,Avst,Balinese,Bali,Bamum,Bamu,Bassa_Vah,Bass,Batak,Batk,Bengali,Beng,Bhaiksuki,Bhks,Bopomofo,Bopo,Brahmi,Brah,Braille,Brai,Buginese,Bugi,Buhid,Buhd,Canadian_Aboriginal,Cans,Carian,Cari,Caucasian_Albanian,Aghb,Chakma,Cakm,Cham,Cherokee,Cher,Common,Zyyy,Coptic,Copt,Qaac,Cuneiform,Xsux,Cypriot,Cprt,Cyrillic,Cyrl,Deseret,Dsrt,Devanagari,Deva,Dogra,Dogr,Duployan,Dupl,Egyptian_Hieroglyphs,Egyp,Elbasan,Elba,Elymaic,Elym,Ethiopic,Ethi,Georgian,Geor,Glagolitic,Glag,Gothic,Goth,Grantha,Gran,Greek,Grek,Gujarati,Gujr,Gunjala_Gondi,Gong,Gurmukhi,Guru,Han,Hani,Hangul,Hang,Hanifi_Rohingya,Rohg,Hanunoo,Hano,Hatran,Hatr,Hebrew,Hebr,Hiragana,Hira,Imperial_Aramaic,Armi,Inherited,Zinh,Qaai,Inscriptional_Pahlavi,Phli,Inscriptional_Parthian,Prti,Javanese,Java,Kaithi,Kthi,Kannada,Knda,Katakana,Kana,Kayah_Li,Kali,Kharoshthi,Khar,Khmer,Khmr,Khojki,Khoj,Khudawadi,Sind,Lao,Laoo,Latin,Latn,Lepcha,Lepc,Limbu,Limb,Linear_A,Lina,Linear_B,Linb,Lisu,Lycian,Lyci,Lydian,Lydi,Mahajani,Mahj,Makasar,Maka,Malayalam,Mlym,Mandaic,Mand,Manichaean,Mani,Marchen,Marc,Medefaidrin,Medf,Masaram_Gondi,Gonm,Meetei_Mayek,Mtei,Mende_Kikakui,Mend,Meroitic_Cursive,Merc,Meroitic_Hieroglyphs,Mero,Miao,Plrd,Modi,Mongolian,Mong,Mro,Mroo,Multani,Mult,Myanmar,Mymr,Nabataean,Nbat,Nandinagari,Nand,New_Tai_Lue,Talu,Newa,Nko,Nkoo,Nushu,Nshu,Nyiakeng_Puachue_Hmong,Hmnp,Ogham,Ogam,Ol_Chiki,Olck,Old_Hungarian,Hung,Old_Italic,Ital,Old_North_Arabian,Narb,Old_Permic,Perm,Old_Persian,Xpeo,Old_Sogdian,Sogo,Old_South_Arabian,Sarb,Old_Turkic,Orkh,Oriya,Orya,Osage,Osge,Osmanya,Osma,Pahawh_Hmong,Hmng,Palmyrene,Palm,Pau_Cin_Hau,Pauc,Phags_Pa,Phag,Phoenician,Phnx,Psalter_Pahlavi,Phlp,Rejang,Rjng,Runic,Runr,Samaritan,Samr,Saurashtra,Saur,Sharada,Shrd,Shavian,Shaw,Siddham,Sidd,SignWriting,Sgnw,Sinhala,Sinh,Sogdian,Sogd,Sora_Sompeng,Sora,Soyombo,Soyo,Sundanese,Sund,Syloti_Nagri,Sylo,Syriac,Syrc,Tagalog,Tglg,Tagbanwa,Tagb,Tai_Le,Tale,Tai_Tham,Lana,Tai_Viet,Tavt,Takri,Takr,Tamil,Taml,Tangut,Tang,Telugu,Telu,Thaana,Thaa,Thai,Tibetan,Tibt,Tifinagh,Tfng,Tirhuta,Tirh,Ugaritic,Ugar,Vai,Vaii,Wancho,Wcho,Warang_Citi,Wara,Yi,Yiii,Zanabazar_Square,Zanb,';\nlet ID_START_REGEX = undefined;\nfunction getIdStartRegexSuperSlow() {\nif (ID_START_REGEX) return ID_START_REGEX;\nreturn ID_START_REGEX = createUnicodeRegex('^\\\\p{ID_Start}$');\n}\nlet ID_CONTINUE_REGEX = undefined;\nfunction getIdRestRegexSuperSlow() {\nif (ID_CONTINUE_REGEX) return ID_CONTINUE_REGEX;\nreturn ID_CONTINUE_REGEX = createUnicodeRegex('^\\\\p{ID_Continue}$');\n}\nfunction createUnicodeRegex(pattern) {\ntry {\nreturn new RegExp(pattern, 'u');\n} catch (e) {\nconsole.warn(('Tenko: Current nodejs version does not suppport unicode regexes or regex property escapes; Input contains unicode that requires it so Tenko is unable to properly parse input (' + e.message) + ')');\nreturn /|/;\n}\n}\nfunction Lexer(input, options) {\nconst {targetEsVersion = Infinity, parsingGoal = true, collectTokens = 0, returnTokens = 3, webCompat = true, gracefulErrors = false, tokenStorageExternal, babelTokenCompat = false, errorCodeFrame = true, truncCodeFrame = false, $log = console.log, $warn = console.warn, $error = console.error} = options;\nconst tokenStorage = (tokenStorageExternal || (((collectTokens !== 0)? [] : undefined)));\nconst supportRegexPropertyEscapes = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexLookbehinds = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexDotallFlag = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportRegexNamedGroups = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nconst supportBigInt = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nconst supportNullishCoalescing = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nconst supportOptionalChaining = ((targetEsVersion === 11) || (targetEsVersion === Infinity));\nlet pointer = 0;\nlet len = input.length;\nlet consumedNewlinesBeforeSolid = false;\nlet nlwas = false;\nlet finished = false;\nlet lastOffset = pointer;\nlet startForError = 0;\nlet lastType = 0;\nlet lastStart = 0;\nlet lastStop = 0;\nlet lastLine = 0;\nlet lastColumn = 0;\nlet lastCanonizedInput = '';\nlet lastCanonizedInputLen = 0;\nlet lastPotentialRegexError = '';\nlet lastReportableLexerError = '';\nlet currentLine = 1;\nlet currentColOffset = 0;\nlet prevTokenEndColumn = 0;\nlet prevTokenEndLine = 0;\nlet prevTokenEndPointer = 0;\nlet prevTokenSolid = true;\nlet stale = false;\nlet cache = input.charCodeAt(0);\nlet anyTokenCount = 0;\nlet solidTokenCount = 0;\nfunction peek() {\nreturn cache;\n}\nfunction _readCache() {\nreturn cache;\n}\nfunction peekd(delta) {\nreturn input.charCodeAt(pointer + delta);\n}\nfunction peeky(ord) {\nreturn cache === ord;\n}\nfunction slice(from, to) {\nreturn input.slice(from, to);\n}\nfunction skipPeek() {\nreturn cache = input.charCodeAt(++pointer);\n}\nfunction skip() {\nlet p = ++pointer;\nif (pointer >= len) {\ncache = 0;\nreturn;\n}\ncache = input.charCodeAt(p);\n}\nfunction skipFastWithoutUpdatingCache() {\n++pointer;\n}\nfunction eof() {\nreturn pointer >= len;\n}\nfunction eofd(d) {\nreturn pointer >= (len - d);\n}\nfunction neof() {\nreturn pointer < len;\n}\nfunction neofd(d) {\nreturn pointer <= (len - d);\n}\nfunction nextToken(lexerFlags) {\nif (prevTokenSolid) {\nprevTokenEndColumn = pointer - currentColOffset;\nprevTokenEndLine = currentLine;\nprevTokenEndPointer = pointer;\nprevTokenSolid = false;\n}\nlastPotentialRegexError = '';\nlastReportableLexerError = '';\ndo {\n++anyTokenCount;\nlet startCol = pointer - currentColOffset;\nlet startRow = currentLine;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nnlwas = consumedNewlinesBeforeSolid;\nif (pointer >= len) {\ncreateToken(2097173, pointer, pointer, startCol, startRow);\nfinished = true;\nreturn returnSolidToken(2097173, pointer, pointer, startCol, startRow);\n}\nlet start = startForError = pointer;\nlet consumedTokenType = jumpTableLexer(lexerFlags);\nif (!isWhiteToken(consumedTokenType)) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\nreturn returnSolidToken(consumedTokenType, start, pointer, startCol, startRow);\n}\nif (isCommentToken(consumedTokenType)) {\nif (returnTokens === 2) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\nreturn returnCommentToken(consumedTokenType, start, pointer, startCol, startRow);\n}\n}\nif (((collectTokens === 2) || (collectTokens === 3))) {\ncreateToken(consumedTokenType, start, pointer, startCol, startRow);\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, false)));\n}\nif (returnTokens === 1) {\nreturn createToken(consumedTokenType, start, pointer, startCol, startRow);\n}\nif (consumedTokenType === 1285) {\nif (((collectTokens !== 2) && (collectTokens !== 3))) skipNewlinesWithoutTokens();\n}\nif (nlwas === true) {\nif (((collectTokens !== 2) && (collectTokens !== 3))) skipSpacesWithoutTokens();\n}\n} while (true);\n}\nfunction returnCommentToken(consumedTokenType, start, pointer, startCol, startRow) {\nif (((collectTokens === 2) || (collectTokens === 3))) {\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, false)));\n}\n}\nfunction returnSolidToken(consumedTokenType, start, pointer, startCol, startRow) {\n++solidTokenCount;\nif (collectTokens !== 0) {\ntokenStorage.push(((collectTokens === 3)? consumedTokenType : createBaseToken(consumedTokenType, start, pointer, startCol, startRow, consumedNewlinesBeforeSolid)));\n}\nconsumedNewlinesBeforeSolid = false;\nprevTokenSolid = true;\n}\nfunction skipSpacesWithoutTokens() {\nwhile (pointer < len) {\nlet c = cache;\nif (((c !== 0x20) && (c !== 0x09))) return;\nskip();\n}\n}\nfunction skipNewlinesWithoutTokens() {\nwhile (pointer < len) {\nlet c = cache;\nif (c === 0x0A) {\nskip();\nincrementLine();\n} else if (c === 0x0D) {\nskip();\nparseCR();\n} else {\nreturn;\n}\n}\n}\nfunction jumpTableLexer(lexerFlags) {\nlet c = cache;\nskip();\nif (c > 0x7e) {\nreturn parseOtherUnicode(c);\n}\nlet s = getTokenStart(c);\nif (s > MAX_START_VALUE) {\nreturn s;\n}\nswitch (s) {\ncase 1:\nreturn parseSpace();\ncase 2:\nreturn parseIdentifierRest(String.fromCharCode(c), 1);\ncase 3:\nif ((lexerFlags & 65536) === 65536) return parseIdentifierRest(String.fromCharCode(c), 1);\nreturn parsePotentialKeywordTrieMap(c);\ncase 4:\nreturn parseNewlineSolo();\ncase 5:\nreturn parseCR();\ncase 6:\nreturn parseAnyString(c, lexerFlags);\ncase 7:\nreturn parseDecimal();\ncase 8:\nreturn parseLeadingDot();\ncase 9:\nif ((lexerFlags & 2048) === 2048) return parseTemplateString(lexerFlags, false);\nreturn 16517;\ncase 10:\nreturn parseEqual();\ncase 11:\nreturn parseFwdSlash(lexerFlags);\ncase 12:\nreturn parseSameOrCompound(0x2b);\ncase 13:\nreturn parseDash();\ncase 14:\nreturn parseLeadingZero(lexerFlags);\ncase 15:\nreturn parseTemplateString(lexerFlags, true);\ncase 16:\nreturn parseExcl();\ncase 17:\nreturn parseCompoundAssignment(0x25);\ncase 18:\nreturn parseSameOrCompound(0x26);\ncase 19:\nreturn parseStar();\ncase 20:\nreturn parseCompoundAssignment(0x5e);\ncase 21:\nreturn parseLt();\ncase 22:\nreturn parseGtPunctuator();\ncase 23:\nreturn parseSameOrCompound(0x7c);\ncase 24:\nreturn parseBackslash();\ncase 25:\nreturn parseQmark();\n}\nTHROW('Unknown input', pointer - 1, pointer);\n}\nfunction incrementLine() {\nconsumedNewlinesBeforeSolid = true;\n++currentLine;\ncurrentColOffset = pointer;\n}\nfunction addAsi() {\nif (collectTokens !== 0) {\ntokenStorage.push(((collectTokens === 3)? 2097174 : createBaseToken(2097174, pointer, pointer, pointer - currentColOffset, currentLine, false)), tokenStorage.pop());\n}\n++anyTokenCount;\n++solidTokenCount;\nprevTokenSolid = true;\n}\nfunction createToken(type, start, stop, column, line) {\nlastType = type;\nlastStart = start;\nlastStop = stop;\nlastLine = line;\nlastColumn = column;\n}\nfunction createBaseToken(type, start, stop, column, line, nl) {\nif (babelTokenCompat) {\nreturn {type, start, stop, loc:{start:{line:line, column:column}, end:{line:currentLine, column:currentColOffset}}, column, line};\n}\nreturn {type, start, stop, column, line, nl};\n}\nfunction parseLeadingDot() {\nif (pointer >= len) return 16485;\nlet c = cache;\nif (c === 0x2e) {\nreturn parseTripleDot();\n}\nif (isAsciiNumber(c)) {\nreturn parseNumberFromDot(c);\n}\nreturn 16485;\n}\nfunction parseTripleDot() {\nif (peekd(1) === 0x2e) {\nskip();\nskip();\nreturn 16486;\n}\nreturn 16486;\n}\nfunction parseNumberFromDot(c) {\nskip();\nif (pointer < len) {\nlet d = skipDigits();\nparseExponentMaybe(d);\n}\nverifyCharAfterNumber();\nreturn 4105;\n}\nfunction parseSpace() {\nreturn 257;\n}\nfunction parseCR() {\nif ((pointer < len && (cache === 0x0A))) {\nskip();\nincrementLine();\nreturn 772;\n}\nincrementLine();\nreturn 771;\n}\nfunction parseAnyString(marker, lexerFlags) {\nlet pointerOffset = pointer;\nlet badEscape = false;\nlet hadNewline = false;\nwhile (pointer < len) {\nlet c = cache;\nlet s = getStringPart(c);\nif (s <= MAX_START_VALUE) {\nswitch (s) {\ncase 0:\nskip();\nbreak;\ncase 1:\nskip();\nif (c === marker) {\nif (badEscape) {\nif (!lastReportableLexerError) lastReportableLexerError = 'String had an illegal escape';\nreturn 2097175;\n}\nif (hadNewline) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Encountered newline in string which is not allowed';\nreturn 2097175;\n}\nlastCanonizedInput += slice(pointerOffset, pointer - 1);\nlastCanonizedInputLen += (pointer - 1) - pointerOffset;\nreturn ((marker === 0x22)? 131088 : 131087);\n}\nbreak;\ncase 2:\nlastCanonizedInput += slice(pointerOffset, pointer);\nlastCanonizedInputLen += pointer - pointerOffset;\nbadEscape = ((parseStringOrTemplateEscape(lexerFlags, false) === true) || badEscape);\npointerOffset = pointer;\nbreak;\ncase 3:\nskip();\nif (((c <= 0x2029) && (c >= 0x2028))) {\nincrementLine();\n}\nbreak;\ncase 4:\nskip();\nhadNewline = true;\nbreak;\n;\n}\n}\n}\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed string at EOF';\nreturn 2097175;\n}\nfunction parseStringOrTemplateEscape(lexerFlags, forTemplate) {\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Backslash at end of input';\nreturn true;\n}\nlet c = cache;\nskip();\nlet s = ((c > 0x7e)? 6 : stringEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nlastCanonizedInput += String.fromCharCode(c);\n++lastCanonizedInputLen;\nreturn false;\ncase 1:\nlastCanonizedInput += '\\n';\n++lastCanonizedInputLen;\nreturn false;\ncase 2:\nlastCanonizedInput += '\\'';\n++lastCanonizedInputLen;\nreturn false;\ncase 3:\nlastCanonizedInput += '\"';\n++lastCanonizedInputLen;\nreturn false;\ncase 4:\n{\nif (pointer >= len) return true;\nlet r = parseUnicodeEscapeForNonRegex();\nif (r === 0x110000) return true;\nlastCanonizedInput += ((r > 0xffff)? String.fromCodePoint(r) : String.fromCharCode(r));\nlastCanonizedInputLen += ((r > 0xffff)? 2 : 1);\nreturn false;\n}\ncase 5:\nreturn parseStringEscapeHex();\ncase 6:\nif (((c === 0x2028) || (c === 0x2029))) {\nincrementLine();\nreturn false;\n}\nlastCanonizedInput += String.fromCharCode(c);\n++lastCanonizedInputLen;\nreturn false;\ncase 7:\nlastCanonizedInput += '\\t';\n++lastCanonizedInputLen;\nreturn false;\ncase 8:\nlastCanonizedInput += '\\r';\n++lastCanonizedInputLen;\nreturn false;\ncase 9:\nif ((pointer < len && (cache === 0x0A))) skip();\nincrementLine();\nreturn false;\ncase 10:\nincrementLine();\nreturn false;\ncase 11:\n\ncase 12:\nreturn parseStringEscapeOctalOrDigit(c, forTemplate, lexerFlags);\ncase 13:\nlastCanonizedInput += '\\b';\n++lastCanonizedInputLen;\nreturn false;\ncase 14:\nlastCanonizedInput += '\\f';\n++lastCanonizedInputLen;\nreturn false;\ncase 15:\nlastCanonizedInput += '\\v';\n++lastCanonizedInputLen;\nreturn false;\n;\n}\n}\nfunction skipZeroes() {\nlet c = cache;\nwhile (c === 0x30) {\nskip();\nif (pointer >= len) return 0;\nc = cache;\n}\nreturn c;\n}\nfunction parseStringEscapeHex() {\nif (eofd(1)) {\nif (pointer >= len) return false;\nif (!lastReportableLexerError) lastReportableLexerError = 'Not enough of input left to create valid hex escape';\nreturn true;\n}\nlet a = cache;\nlet b = peekd(1);\nlet va = getHexValue(a);\nlet vb = getHexValue(b);\nif ((va | vb) >= 16) {\nlastCanonizedInput += 'x';\n++lastCanonizedInputLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'At least one of the two hex characters were not hex character (0-9a-f)';\nreturn true;\n}\nskip();\nskip();\nlastCanonizedInput += String.fromCharCode((va << 4) | vb);\n++lastCanonizedInputLen;\nreturn false;\n}\nfunction parseStringEscapeOctalOrDigit(a, forTemplate, lexerFlags) {\nif (((a === 0x38) || (a === 0x39))) {\nif (!lastReportableLexerError) lastReportableLexerError = 'The grammar does not allow to escape the 8 or the 9 character';\nreturn true;\n}\nif (pointer >= len) return false;\nlet b = cache;\nif (((((webCompat === false) || forTemplate)) || ((lexerFlags & 8192) === 8192))) {\nif (((a === 0x30) && (((b < 0x30) || (b > 0x39))))) {\nlastCanonizedInput += '\\0';\n++lastCanonizedInputLen;\nreturn false;\n}\nif (forTemplate) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Illegal legacy octal escape in template, where octal escapes are never allowed';\n} else if ((lexerFlags & 8192) === 8192) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Illegal legacy octal escape in strict mode';\n} else {\nif (!lastReportableLexerError) lastReportableLexerError = 'Octal escapes are only allowed in sloppy mode with web compat enabled';\n}\nreturn true;\n}\nif (((a === 0x30) && (((b < 0x30) || (b > 0x37))))) {\nlastCanonizedInput += '\\0';\n++lastCanonizedInputLen;\nreturn false;\n}\nif (((b < 0x30) || (b > 0x37))) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nskip();\nif (pointer >= len) return false;\nif (a > 0x33) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nlet c = cache;\nif (((c < 0x30) || (c > 0x37))) {\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nskip();\nlastCanonizedInput += String.fromCharCode(parseInt(String.fromCharCode(a, b, c), 8));\n++lastCanonizedInputLen;\nreturn false;\n}\nfunction parseDash() {\nif (((((((((parsingGoal === false) && (webCompat === true))) && (!eofd(1)))) && (cache === 0x2d))) && (peekd(1) === 0x3e))) {\nif (consumedNewlinesBeforeSolid === true) {\nreturn parseCommentHtmlClose();\n} else {\n\n}\n}\nreturn parseSameOrCompound(0x2d);\n}\nfunction parseSameOrCompound(c) {\nif (pointer < len) {\nlet d = cache;\nif (d === c) {\nskip();\nswitch (c) {\ncase 0x2b:\nreturn 16478;\ncase 0x2d:\nreturn 16482;\ncase 0x26:\nreturn 82005;\ncase 0x7c:\nreturn 82051;\n;\n}\n}\nif (d === 0x3d) {\nskip();\nswitch (c) {\ncase 0x2b:\nreturn 49247;\ncase 0x2d:\nreturn 49251;\ncase 0x26:\nreturn 49238;\ncase 0x7c:\nreturn 49284;\n;\n}\n}\n}\nswitch (c) {\ncase 0x2b:\nreturn 82013;\ncase 0x2d:\nreturn 82017;\ncase 0x26:\nreturn 82004;\ncase 0x7c:\nreturn 82050;\n;\n}\n}\nfunction parseTemplateString(lexerFlags, fromTick) {\nlastOffset = pointer;\nlet badEscapes = false;\nwhile (pointer < len) {\nlet c = cache;\nwhile (c === 0x24) {\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed template string';\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nreturn 2097175;\n}\nc = cache;\nif (c === 0x7b) {\nlastCanonizedInput += slice(lastOffset, pointer - 1);\nlastCanonizedInputLen += (pointer - 1) - lastOffset;\nskip();\nreturn (badEscapes? ((fromTick? 1572881 : 1572882)) : ((fromTick? 524305 : 524306)));\n}\n}\nif (c === 0x60) {\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nskip();\nreturn (badEscapes? ((fromTick? 1572884 : 1572883)) : ((fromTick? 524308 : 524307)));\n}\nif (c === 0x0D) {\nskip();\nif ((pointer < len && (cache === 0x0A))) {\nskip();\n}\nincrementLine();\n} else if (isLfPsLs(c)) {\nskip();\nincrementLine();\n} else if (c === 0x5c) {\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nbadEscapes = ((parseStringOrTemplateEscape(lexerFlags, true) === true) || badEscapes);\nlastOffset = pointer;\n} else {\nskip();\n}\n}\nlastCanonizedInput += slice(lastOffset, pointer);\nlastCanonizedInputLen += pointer - lastOffset;\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed template literal';\nreturn 2097175;\n}\nfunction verifyCharAfterNumber() {\nif (pointer >= len) return;\nlet c = cache;\nif (((isIdentStart(c, 0) !== (-1)) || (((c >= 0x30) && (c <= 0x39))))) {\nreturn THROW(('Found `' + String.fromCharCode(c)) + '`. It is not legal for an ident or number token to start after a number token without some form of separation', pointer, pointer);\n}\n}\nfunction parseLeadingZero(lexerFlags) {\nlet r = _parseLeadingZero(lexerFlags);\nif (r !== 2097175) verifyCharAfterNumber();\nreturn r;\n}\nfunction _parseLeadingZero(lexerFlags) {\nif (pointer >= len) return 4105;\nlet c = cache;\nif (isAsciiNumber(c)) {\nskip();\nif (pointer < len) skipDigits();\nif ((lexerFlags & 8192) === 8192) {\nif (!lastReportableLexerError) lastReportableLexerError = '\"Illegal\" octal escape in strict mode';\nreturn 2097175;\n}\nif (pointer < len) {\nlet e = cache;\nif (((e === 0x45) || (e === 0x65))) {\nif (!lastReportableLexerError) lastReportableLexerError = 'An exponent is not allowed after a legacy octal number and an ident after number must be separated by some whitespace so this is an error';\nreturn 2097175;\n}\nif (e === 0x6E) {\nif (!supportBigInt) {\nreturn THROW('BigInt suffix is not supported on legacy octals; use the `0o` prefix notation for that', startForError, pointer + 1);\n}\n}\n}\nreturn 4108;\n}\nif (c === 0x2e) {\nparseFromFractionDot();\nreturn 4105;\n}\nif (((c === 0x78) || (c === 0x58))) {\nskip();\nreturn parseHex();\n}\nif (((c === 0x6F) || (c === 0x4F))) {\nskip();\nreturn parseOctal();\n}\nif (((c === 0x62) || (c === 0x42))) {\nskip();\nreturn parseBinary();\n}\nif (((c === 0x65) || (c === 0x45))) {\nparseExponentMaybe(c);\nreturn 4105;\n}\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12297;\n}\nreturn 4105;\n}\nfunction parseDecimal() {\nif (pointer >= len) {\nreturn 4105;\n}\nlet c = skipDigits();\nif (pointer >= len) {\nreturn 4105;\n}\nif (c === 0x2e) {\nparseFromFractionDot();\nverifyCharAfterNumber();\nreturn 4105;\n}\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer);\n}\nskip();\nverifyCharAfterNumber();\nreturn 12297;\n}\nparseExponentMaybe(c);\nverifyCharAfterNumber();\nreturn 4105;\n}\nfunction skipDigits() {\nlet c = cache;\nwhile (isAsciiNumber(c)) {\nskip();\nif (pointer >= len) return 0;\nc = cache;\n}\nreturn c;\n}\nfunction parseExponentMaybe(c) {\nif (((c !== 0x65) && (c !== 0x45))) return;\nif (eofd(1)) return;\nlet d = peekd(1);\nif (((d === 0x2d) || (d === 0x2b))) {\nif (eofd(2)) return;\nlet e = peekd(2);\nif (!isAsciiNumber(e)) return;\nskipFastWithoutUpdatingCache();\nskipFastWithoutUpdatingCache();\nskip();\nif (pointer >= len) return;\nskipDigits();\nreturn;\n}\nif (!isAsciiNumber(d)) return;\nskipFastWithoutUpdatingCache();\nskip();\nif (pointer >= len) return;\nskipDigits();\n}\nfunction parseFromFractionDot() {\nskip();\nif (pointer >= len) return;\nlet c = skipDigits();\nparseExponentMaybe(c);\n}\nfunction parseHex() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0x` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nlet cv = getHexValue(c);\nif (cv === 16) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0x` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4104;\nc = cache;\ncv = getHexValue(c);\nif (cv === 16) {\nbreak;\n}\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12296;\n}\nreturn 4104;\n}\nfunction parseOctal() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0o` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nif (!isOctal(c)) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0o` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4107;\nc = cache;\nif (!isOctal(c)) break;\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12299;\n}\nreturn 4107;\n}\nfunction parseBinary() {\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0b` is illegal without a digit';\nreturn 2097175;\n}\nlet c = cache;\nif (!isBinary(c)) {\nif (!lastReportableLexerError) lastReportableLexerError = '`0b` is illegal without a digit';\nreturn 2097175;\n}\nskip();\ndo {\nif (pointer >= len) return 4106;\nc = cache;\nif (!isBinary(c)) break;\nskip();\n} while (true);\nif (c === 0x6E) {\nif (!supportBigInt) {\nreturn THROW(('The BigInt syntax is supported in ES11+ / ES2020 (currently parsing ES' + targetEsVersion) + ')', startForError, pointer + 1);\n}\nskip();\nreturn 12297;\n}\nreturn 4106;\n}\nfunction isBinary(ord) {\nreturn ((ord === 0x30) || (ord === 0x31));\n}\nfunction parseExcl() {\nif (pointer >= len) return 16463;\nif ((cache === 0x3d)) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 82001;\n}\nreturn 82000;\n}\nreturn 16463;\n}\nfunction parseStar() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x2a) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49244;\n}\nreturn 82010;\n} else if (c === 0x3d) {\nskip();\nreturn 49243;\n}\n}\nreturn 82009;\n}\nfunction parseIdentRestNotKeywordObjTrie(d, n, start) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nfunction parsePotentialKeywordTrieMap(c) {\nlet trieObjlit = KEYWORD_TRIE_OBJLIT[c - 0x61];\nlet start = pointer - 1;\nlet n = start + 1;\ndo {\nif (n >= len) return eofAfterPotentialKeywordTrieMap(trieObjlit, n, start);\nlet d = input.charCodeAt(n++);\nif (((d < 0x61) || (d > 0x7a))) {\nreturn endOfPotentialKeywordTrieMap(trieObjlit, d, n, start);\n}\ntrieObjlit = trieObjlit[d - 0x61];\nif (trieObjlit === undefined) return parseIdentRestNotKeywordObjTrie(d, n, start);\n} while (true);\n}\nfunction endOfPotentialKeywordTrieMap(trieObjlit, d, n, start) {\nlet hit = trieObjlit.hit;\nif (d > 0x7e) {\npointer = n - 1;\ncache = d;\nlet wide = isIdentRestChr(d, n - 1);\nif (wide === (-1)) {\nlastCanonizedInputLen = (n - 1) - start;\nif (hit === undefined) {\nlastCanonizedInput = slice(start, n - 1);\nreturn 2048;\n}\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nlet s = getTokenStart(d);\nif (((((s === 2) || (s === 7))) || (s === 14))) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nif (s === 24) {\npointer = n - 1;\ncache = d;\nreturn parseIdentifierRest(slice(start, n - 1), (n - 1) - start);\n}\nif (hit !== undefined) {\npointer = n - 1;\ncache = d;\nlastCanonizedInputLen = (n - 1) - start;\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nlastCanonizedInput = slice(start, n - 1);\nlastCanonizedInputLen = (n - 1) - start;\npointer = n - 1;\ncache = d;\nreturn 2048;\n}\nfunction eofAfterPotentialKeywordTrieMap(trieObjlit, n, start) {\npointer = n - 1;\nskip();\nlastCanonizedInputLen = n - start;\nlet hit = trieObjlit.hit;\nif (hit !== undefined) {\nlet canon = trieObjlit.canon;\nlastCanonizedInput = canon;\nreturn hit;\n}\nlastCanonizedInput = slice(start, n);\nreturn 2048;\n}\nfunction parseIdentifierRest(prevStr, prevLen) {\nlet start = pointer;\nwhile (pointer < len) {\nlet c = cache;\nlet s = getIdentPart(c);\nswitch (s) {\ncase 0:\nskip();\nbreak;\ncase 1:\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\ncase 2:\nlet x = prevStr + slice(start, pointer);\nlet xlen = prevLen + (pointer - start);\nskip();\nreturn parseIdentFromUnicodeEscape(false, x, xlen);\ncase 3:\nlet wide = isIdentRestChrUnicode(c, pointer);\nif (wide === (-1)) {\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\n}\nif (wide === (-3)) {\nskipFastWithoutUpdatingCache();\n}\nskip();\nbreak;\n;\n}\n}\nlastCanonizedInput = prevStr + slice(start, pointer);\nlastCanonizedInputLen = prevLen + (pointer - start);\nreturn 2048;\n}\nfunction parseIdentFromUnicodeEscape(fromStart, prevStr, prevLen) {\nif (pointer >= len) {\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Encountered a backslash at end of input';\nreturn 2097175;\n}\nif (!(cache === 0x75)) {\nreturn THROW('Only unicode escapes are supported in identifier escapes', startForError, pointer + 1);\n}\nskip();\nif (pointer >= len) {\nif (!lastReportableLexerError) lastReportableLexerError = 'Reached end of input before closing the current ident escape';\nreturn 2097175;\n}\nlet r = parseUnicodeEscapeForNonRegex();\nif (r === 0x110000) {\nparseIdentifierRest(prevStr, prevLen);\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Only _unicode_ escapes are supported in identifiers';\nreturn 2097175;\n}\nif (r > 0xffff) {\nprevStr += String.fromCodePoint(r);\nprevLen += 2;\n} else {\nprevStr += String.fromCharCode(r);\n++prevLen;\n}\nif (((fromStart === true) && (isIdentStart(r, -1) !== (-1)))) {\nreturn parseIdentifierRest(prevStr, prevLen);\n}\nif (((fromStart === false) && (isIdentRestChr(r, -1) !== (-1)))) {\nreturn parseIdentifierRest(prevStr, prevLen);\n}\nlastCanonizedInput = prevStr;\nlastCanonizedInputLen = prevLen;\nif (!lastReportableLexerError) lastReportableLexerError = 'Identifier escape did not yield a valid identifier character';\nreturn 2097175;\n}\nfunction toStringExpensive(c) {\nreturn String.fromCodePoint(c);\n}\nfunction isIdentStart(c, offsetOfC) {\nif (c > 0x7e) {\nreturn veryExpensiveUnicodeCheck(c, offsetOfC, getIdStartRegexSuperSlow());\n}\nlet s = getTokenStart(c);\nif (((s === 2) || (s === 3))) return -2;\nreturn -1;\n}\nfunction isIdentRestChr(c, offsetOfC) {\nif (c > 0x7e) {\nreturn isIdentRestChrUnicode(c, offsetOfC);\n}\nlet s = getTokenStart(c);\nif (((s === 2) || (s === 3))) return -2;\nif (s === 7) return -2;\nif (s === 14) return -2;\nreturn -1;\n}\nfunction isIdentRestChrUnicode(c, offsetOfC) {\nif (((c === 0x200C) || (c === 0x200D))) return -2;\nreturn veryExpensiveUnicodeCheck(c, offsetOfC, getIdRestRegexSuperSlow());\n}\nfunction veryExpensiveUnicodeCheck(c, offset, regexScanner) {\nif (offset !== (-1)) {\nc = input.codePointAt(offset);\n}\nlet s = String.fromCodePoint(c);\nif (regexScanner.test(s)) {\nreturn ((s.length === 1)? (-2) : (-3));\n}\nreturn -1;\n}\nfunction isAsciiLetter(c) {\nlet d = c | 32;\nreturn ((d >= 0x61) && (d <= 0x7a));\n}\nfunction isAsciiNumber(c) {\nreturn ((c >= 0x30) && (c <= 0x39));\n}\nfunction parseCompoundAssignment(c) {\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nif (c === 0x5e) return 49280;\nreturn 49235;\n}\nif (c === 0x5e) return 82047;\nreturn 82002;\n}\nfunction parseFwdSlash(lexerFlags) {\nif (pointer >= len) return 82023;\nlet c = cache;\nif (c === 0x2f) {\nskip();\nreturn parseCommentSingle();\n}\nif (c === 0x2a) {\nreturn parseCommentMulti();\n}\nif ((lexerFlags & 4) === 4) {\nreturn parseRegex(c);\n}\nif (c === 0x3d) {\nskip();\nreturn 49256;\n}\nreturn 82023;\n}\nfunction parseCommentSingle() {\nwhile (pointer < len) {\nlet c = cache;\nif (((c === 0x0D) || isLfPsLs(c))) {\nreturn 1285;\n}\nskip();\n}\nreturn 1285;\n}\nfunction parseCommentMulti() {\nskip();\nlet c = 0;\nwhile (pointer < len) {\nc = cache;\nskip();\nwhile (c === 0x2a) {\nif (pointer >= len) break;\nc = cache;\nskip();\nif (c === 0x2f) {\nreturn 1286;\n}\n}\nif (c === 0x0D) {\nif ((pointer < len && (cache === 0x0A))) skip();\nincrementLine();\n} else if (isLfPsLs(c)) {\nincrementLine();\n}\n}\nif (!lastReportableLexerError) lastReportableLexerError = 'Unclosed multi line comment, early eof';\nreturn 2097175;\n}\nfunction parseCommentHtmlOpen() {\nparseCommentSingle();\nreturn 1287;\n}\nfunction parseCommentHtmlClose() {\nparseCommentSingle();\nreturn 1287;\n}\nfunction parseEqual() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 82034;\n}\nreturn 82033;\n} else if (c === 0x3e) {\nskip();\nreturn 16499;\n}\n}\nreturn 49264;\n}\nfunction parseLt() {\nif (((((((((((parsingGoal === false) && (webCompat === true))) && (!eofd(3)))) && (cache === 0x21))) && (peekd(1) === 0x2d))) && (peekd(2) === 0x2d))) {\nreturn parseCommentHtmlOpen();\n}\nreturn parseLtPunctuator();\n}\nfunction parseLtPunctuator() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nreturn 82029;\n}\nif (c === 0x3c) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49262;\n}\nreturn 82028;\n}\n}\nreturn 82027;\n}\nfunction parseGtPunctuator() {\nif (pointer < len) {\nlet c = cache;\nif (c === 0x3d) {\nskip();\nreturn 82039;\n}\nif (c === 0x3e) {\nskip();\nif (pointer < len) {\nc = cache;\nif (c === 0x3d) {\nskip();\nreturn 49272;\n}\nif (c === 0x3e) {\nskip();\nif ((pointer < len && (cache === 0x3d))) {\nskip();\nreturn 49273;\n}\nreturn 82038;\n}\n}\nreturn 82037;\n}\n}\nreturn 82036;\n}\nfunction parseNewlineSolo() {\nincrementLine();\nreturn 771;\n}\nfunction parseBackslash() {\nreturn parseIdentFromUnicodeEscape(true, '', 0);\n}\nfunction parseQmark() {\nif (pointer >= len) return 16506;\nif ((cache === 0x3f)) {\nskip();\nif (supportNullishCoalescing) {\nreturn 82044;\n}\nreturn THROW('The nullish coalescing operator (`??`) is only supported since ES2020, currently targeting a lower version', pointer - 2, pointer);\n}\nif ((cache === 0x2e)) {\nif (neofd(1)) {\nlet c = peekd(1);\nif (((c >= 0x30) && (c <= 0x39))) {\nreturn 16506;\n}\n}\nskip();\nif (supportOptionalChaining) {\nreturn 82043;\n}\nreturn THROW('The optional chaining operator (`?.`) is only supported since ES2020, currently targeting a lower version', pointer, pointer + 2);\n}\nreturn 16506;\n}\nfunction regexSyntaxError(desc, ...rest) {\nif (lastReportableLexerError) {\nreturn 4;\n}\nupdateRegexPotentialError(desc + ((rest.length? (': [' + rest.join(', ')) + ']' : '')));\nlastReportableLexerError = 'Regex: ' + lastPotentialRegexError;\nreturn 4;\n}\nfunction updateRegexPotentialError(msg) {\nif (!lastPotentialRegexError.includes(msg)) {\nif (lastPotentialRegexError) lastPotentialRegexError += '; ';\nlastPotentialRegexError += msg;\n}\n}\nfunction updateRegexUflagIsIllegal(state, reason) {\nreturn updateRegexUflagState(state, 2, reason);\n}\nfunction updateRegexUflagIsMandatory(state, reason) {\nreturn updateRegexUflagState(state, 1, reason);\n}\nfunction updateRegexUflagState(currentState, newState, error) {\nif (lastReportableLexerError) return 4;\nif (currentState === (((newState === 1)? 2 : 1))) {\nreturn regexSyntaxError(error);\n}\nif (currentState === 0) {\nupdateRegexPotentialError(error);\ncurrentState = newState;\n} else {\n\n}\nreturn currentState;\n}\nlet nCapturingParens = 0;\nlet largestBackReference = 0;\nlet declaredGroupNames = ',';\nlet reffedGroupNames = ',';\nlet kCharClassEscaped = false;\nlet foundInvalidGroupName = false;\nfunction parseRegex(c) {\nnCapturingParens = 0;\nlargestBackReference = 0;\nlastPotentialRegexError = '';\ndeclaredGroupNames = ',';\nreffedGroupNames = ',';\nkCharClassEscaped = false;\nfoundInvalidGroupName = false;\nlet ustatusBody = parseRegexBody(c);\nif (ustatusBody === 4) {\nreturn 2097175;\n}\nlet ustatusFlags = parseRegexFlags();\nif (nCapturingParens < largestBackReference) {\nlet errmsg = 'Largest back reference index exceeded the number of capturing groups (only valid without u-flag in webcompat mode)';\nif (webCompat === false) {\nregexSyntaxError(errmsg);\nreturn 2097175;\n}\nustatusBody = updateRegexUflagIsIllegal(ustatusBody, errmsg);\n}\nif (ustatusFlags === 4) {\nreturn 2097175;\n}\nif (kCharClassEscaped) {\nif (declaredGroupNames !== ',') {\nregexSyntaxError('Found `\\\\k` in a char class but the regex also had a group name so this is illegal');\nreturn 2097175;\n}\nif (((webCompat === false) || (ustatusFlags === 1))) {\nregexSyntaxError('Found `\\\\k` in a char class but this is only allowed in webcompat mode and without u-flag');\nreturn 2097175;\n}\n}\nif (((reffedGroupNames !== ',') && (((webCompat === false) || (declaredGroupNames !== ','))))) {\nlet bad = false;\nreffedGroupNames.split(',').filter(Boolean).forEach(name => {\nif (!declaredGroupNames.includes((',' + name) + ',')) {\nregexSyntaxError(('Found a `\\\\k` that referenced `' + name) + '` but no capturing group had this name');\nbad = true;\n}\n});\nif (bad) {\nreturn 2097175;\n}\n}\nif (ustatusBody === 1) {\nif (ustatusFlags === 1) return 262158;\nregexSyntaxError('Regex contained syntax that is only valid with the u-flag but the u-flag was not present');\nreturn 2097175;\n}\nif (ustatusBody === 2) {\nif (ustatusFlags !== 1) return 262157;\nregexSyntaxError('Regex contained syntax that is invalid with the u-flag but the u-flag was present');\nreturn 2097175;\n}\nif (ustatusFlags === 1) return 262158;\nreturn 262157;\n}\nfunction parseRegexBody(c) {\nreturn _parseRegexBody(c, 0, 0);\n}\nfunction cannotBeQuantifier(c, uflagStatus, webcompatException, msg) {\nlet badStart = ((((((c === 0x2a) || (c === 0x2b))) || (c === 0x3f))) || (c === 0x7b));\nif (badStart) {\nmsg += (' (by a `' + String.fromCharCode(c)) + '`)';\nif ((webcompatException && (webCompat === true))) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, msg);\n} else {\nuflagStatus = regexSyntaxError(msg);\n}\n}\nreturn uflagStatus;\n}\nfunction _parseRegexBody(c, groupLevel, uflagStatus) {\nlet afterAtom = false;\nuflagStatus = cannotBeQuantifier(c, uflagStatus, c === 0x7b, 'Started with a quantifier but that is not allowed');\nlet groupNames = {};\ndo {\nlet s = ((c > 0x7e)? 11 : regexAtomJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\nafterAtom = true;\nbreak;\ncase 1:\nskip();\nafterAtom = true;\nbreak;\ncase 2:\nskip();\nif (afterAtom) {\nafterAtom = false;\nif (pointer < len) {\nif ((cache === 0x3f)) {\nskip();\n}\n}\n} else {\nuflagStatus = regexSyntaxError(('Encountered unescaped quantifier (ord=' + c) + ') without a value to quantify');\n}\nbreak;\ncase 3:\nlet wasFixableAssertion = false;\nlet wasUnfixableAssertion = false;\nskip();\nafterAtom = false;\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (c === 0x3f) {\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (((((((c === 0x3a) || (c === 0x3d))) || (c === 0x21))) || (c === 0x3c))) {\nif (c === 0x3c) {\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif (((c === 0x3d) || (c === 0x21))) {\nif (!supportRegexLookbehinds) {\nreturn THROW('Lookbehinds in regular expressions are not supported in the currently targeted language version', startForError, pointer + 1);\n}\nskip();\nwasUnfixableAssertion = true;\n} else if (!supportRegexNamedGroups) {\nskip();\nreturn regexSyntaxError(('The lookbehind group `(?<` must be `(?<=` or `(?<!` because named groups are not supported in the currently targeted ES version, next char after `<` is `' + String.fromCharCode(c)) + '`');\n} else {\nuflagStatus = parseRegexGroupName(c, uflagStatus, true);\n++nCapturingParens;\n}\n} else if (((c === 0x3d) || (c === 0x21))) {\nskip();\nwasFixableAssertion = true;\n}\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\n} else {\nreturn regexSyntaxError(('Illegal character after pseudo group marker `(?` [ord=' + c) + ']');\n}\n} else {\n++nCapturingParens;\n}\nlet subbad = _parseRegexBody(c, groupLevel + 1, 0);\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nc = cache;\nif ((wasFixableAssertion || wasUnfixableAssertion)) {\nuflagStatus = cannotBeQuantifier(c, uflagStatus, !wasUnfixableAssertion, 'Regex A-ssertion \"atoms\" can not be quantified (so things like `^`, `$`, and `(?=` can not have `*`, `+`, `?`, or `{` following it)');\n}\nafterAtom = true;\nif (subbad === 4) {\nuflagStatus = 4;\n} else if (subbad === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (subbad === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n}\nbreak;\ncase 4:\nskip();\nif (groupLevel > 0) return uflagStatus;\nreturn regexSyntaxError('Found unescaped closing paren `)` without a group being open');\ncase 5:\nlet charClassEscapeStatus = parseRegexCharClass();\nif (charClassEscapeStatus === 4) {\nuflagStatus = 4;\n} else if (charClassEscapeStatus === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (charClassEscapeStatus === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n}\nafterAtom = true;\nbreak;\ncase 6:\n{\nskip();\nlet reason = 'Encountered unescaped closing square bracket `]` while not parsing a character class, which is only valid without u-flag';\nif (webCompat === false) {\nreturn regexSyntaxError(reason);\n}\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, reason);\nafterAtom = true;\nbreak;\n}\ncase 7:\n{\nskip();\nafterAtom = true;\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF');\n}\nlet d = cache;\nif (((d === 0x62) || (d === 0x42))) {\nskip();\nafterAtom = false;\n} else {\nlet escapeStatus = parseEscapeForRegexAtom(d);\nif (escapeStatus === 4) {\nuflagStatus = 4;\n} else if (escapeStatus === 2) {\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, lastPotentialRegexError);\n} else if (escapeStatus === 1) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, lastPotentialRegexError);\n} else if (escapeStatus === 8) {\nafterAtom = false;\n}\n}\n}\nbreak;\ncase 8:\nif (groupLevel !== 0) {\nreturn regexSyntaxError('Unclosed group');\n}\nskip();\nreturn uflagStatus;\ncase 9:\nskip();\nafterAtom = false;\nbreak;\ncase 10:\nskip();\nif (pointer < len) {\nc = cache;\nuflagStatus = cannotBeQuantifier(c, uflagStatus, c === 0x7b, 'Regex `A-ssertion` \"atoms\" can not be quantified but this `$` was quantified anyways');\n}\nafterAtom = false;\nbreak;\ncase 11:\nif (((c === 0x2028) || (c === 0x2029))) {\nreturn regexSyntaxError('Encountered early EOF');\n}\nskip();\nafterAtom = true;\nbreak;\ncase 12:\n{\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF at the start of a regex quantifier');\n}\nlet c = cache;\nlet validBrace = (isAsciiNumber(c)? parseRegexCurlyQuantifier(c) : 3);\nif (validBrace === 1) {\nif (afterAtom) {\nafterAtom = false;\nif ((pointer < len && (cache === 0x3f))) {\nskip();\n}\nbreak;\n}\nreturn regexSyntaxError('A valid bracket quantifier requires an unqualified atom, but that was not the case');\n}\nif (validBrace === 2) {\nreturn regexSyntaxError('Parsed a braced quantifier that contained an illegal range (left>right)');\n}\nif (pointer >= len) return regexSyntaxError('Encountered EOF while parsing curly quantifier');\nif (webCompat === false) {\nif ((cache === 0x2c)) {\nreturn regexSyntaxError('The first digit of a regex curly quantifier is mandatory');\n}\nif ((cache === 0x7d)) {\nreturn regexSyntaxError('A regex curly quantifier had no content');\n}\nreturn regexSyntaxError('Found an unescaped `{` that was not the start of a valid quantifier');\n}\nafterAtom = true;\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, 'Found an unescaped `{` that was not the start of a valid quantifier');\nbreak;\n}\ncase 13:\n{\nskip();\nlet reason = 'Encountered unescaped closing curly `}` while not parsing a quantifier';\nif (webCompat === false) {\nreturn regexSyntaxError(reason);\n}\nuflagStatus = updateRegexUflagIsIllegal(uflagStatus, reason);\nafterAtom = true;\nbreak;\n}\ncase 14:\nskip();\nafterAtom = false;\nbreak;\ncase 15:\nreturn regexSyntaxError('Encountered early EOF');\n;\n}\nif (pointer >= len) break;\nc = cache;\n} while (true);\nreturn regexSyntaxError('Found EOF before regex was closed');\n}\nfunction parseRegexGroupName(c, uflagStatus, forCapturing) {\nlet r = _parseRegexGroupName(c, uflagStatus, forCapturing);\nif (!foundInvalidGroupName) return r;\nif (forCapturing === true) {\nreturn regexSyntaxError('An invalid name for a capturing group can never lead to a valid regex');\n}\nkCharClassEscaped = true;\nreturn r;\n}\nfunction _parseRegexGroupName(c, uflagStatus, forCapturing) {\nif (c === 0x3e) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nif (webCompat === true) {\nreffedGroupNames += '<>,';\nreturn updateRegexUflagIsIllegal(uflagStatus, 'Group name is not optional without webcompat, found empty `<>`');\n}\nreturn regexSyntaxError('Group name is not optional, found empty `<>`');\n}\nlet pointerStart = pointer;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nlet first = true;\nlet lastPointer = 0;\nwhile (((((c !== 0x3e) && (uflagStatus !== 4))) && (lastPointer !== pointer))) {\nlastPointer = pointer;\nif (c === 0x5c) {\nuflagStatus = _parseRegexGroupNameEscape(first, uflagStatus, forCapturing);\n} else {\nuflagStatus = _parseRegexGroupNameChar(first, c, uflagStatus, forCapturing);\n}\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn regexSyntaxError('Missing closing angle bracket of name of capturing group');\n}\nc = cache;\nfirst = false;\n}\nif (uflagStatus === 4) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn 4;\n}\nif (lastPointer === pointer) {\nfoundInvalidGroupName = true;\nlastCanonizedInput = '';\nlastCanonizedInputLen = 0;\nreturn 2;\n}\nlastCanonizedInputLen = lastCanonizedInput.length;\nskip();\nif (lastCanonizedInputLen > 0) {\nlet next = lastCanonizedInput + ',';\nif (forCapturing === true) {\nif (declaredGroupNames.includes(',' + next)) {\nTHROW(('This group name (`' + lastCanonizedInput) + '`) was already used before', pointerStart, pointer - 1);\n}\ndeclaredGroupNames += next;\n} else {\nreffedGroupNames += next;\n}\n}\nreturn uflagStatus;\n}\nfunction _parseRegexGroupNameChar(start, c, uflagStatus, forCapturing) {\nlet wide = (start? isIdentStart(c, pointer) : isIdentRestChr(c, pointer));\nif (wide === (-2)) {\nskip();\nlastCanonizedInput += String.fromCharCode(c);\nreturn uflagStatus;\n}\nif (wide === (-1)) {\nfoundInvalidGroupName = true;\nif (((webCompat === false) || (forCapturing === true))) {\nreturn regexSyntaxError(('Tried to parse the name for a capturing group but it contained at least one invalid ident char (`' + String.fromCharCode(c)) + '`)');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, ('Tried to parse the name for a capturing group but it contained at least one invalid ident char (`' + String.fromCharCode(c)) + '`)');\n}\nskipFastWithoutUpdatingCache();\nskip();\nlastCanonizedInput += String.fromCodePoint(c);\nif (forCapturing === true) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'The start of the name of a capturing group had a surrogate pair and is therefor only valid with u-flag');\n}\nif (webCompat === false) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'The start of a `\\\\k` group name had a surrogate pair and is therefor only valid with u-flag');\n}\nreturn uflagStatus;\n}\nfunction _parseRegexGroupNameEscape(start, uflagStatus, forCapturing) {\nskip();\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Found EOF at start of a group name identifier');\n}\nif (!(cache === 0x75)) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Found invalid escape character at the start of a group name identifier');\n}\nskip();\nif (pointer >= len) {\nreturn updateRegexUflagIsIllegal(0, 'Unexpected EOF while parsing unicode escape');\n}\nlet c = cache;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nuflagStatus = updateRegexUflagIsMandatory(0, 'Found a unicode ruby escape which is only valid with u-flag');\n} else {\nc = parseUnicodeQuadEscape(c, false);\nif (((c > 0xffff) && (forCapturing === true))) {\nuflagStatus = updateRegexUflagIsMandatory(uflagStatus, 'The name of a capturing group contained a double unicode quad escape which is valid as a surrogate pair which requires u-flag and which cannot be made valid without u-flag');\n}\n}\nif (pointer >= len) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Early EOF while parsing a group name');\n}\nif (c === 0x110000) {\nfoundInvalidGroupName = true;\nif (((webCompat === false) || (forCapturing === true))) {\nreturn regexSyntaxError('Regex contained a group name with invalid unicode escape');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, 'The name of a `\\\\k` escape contained a broken unicode ruby escape and this can not lead to a valid regex with u-flag');\n}\nlet firstCharStr = toStringExpensive(c);\nlastCanonizedInput += firstCharStr;\nlet wide = (start? isIdentStart(c, -1) : isIdentRestChr(c, -1));\nif (wide === (-2)) {\nreturn uflagStatus;\n}\nif (wide === (-3)) {\nif (forCapturing === true) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'Found a codepoint in a capturing group name that requires the u-flag to be considered valid');\n}\nif (webCompat === false) {\nreturn updateRegexUflagIsMandatory(uflagStatus, 'Found a codepoint in a `\\\\k` escape group name that requires the u-flag to be considered valid');\n}\nreturn uflagStatus;\n}\nif (forCapturing === true) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Encountered invalid unicode escape inside the group name of a capturing group, this cannot be valid');\n}\nif (webCompat === false) {\nfoundInvalidGroupName = true;\nreturn regexSyntaxError('Encountered invalid unicode escape inside the group name of a `\\\\k` escape, this can not become valid without web compat mode');\n}\nreturn updateRegexUflagIsIllegal(uflagStatus, 'Encountered invalid unicode escape inside the group name of a `\\\\k` escape, this is invalid with u-flag');\n}\nfunction parseEscapeForRegexAtom(c) {\nlet s = ((c > 0x7e)? 4 : regexAtomEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\nreturn 0;\ncase 2:\nskip();\nreturn parseUnicodeEscapeForRegexAtom();\ncase 3:\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing hex escape');\n}\nlet a = cache;\nlet va = getHexValue(a);\nif (va === 16) {\nlet reason = 'First char of hex escape not a valid digit';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\n}\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing hex escape');\n}\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) {\nlet reason = 'Second char of hex escape not a valid digit';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\n}\nskip();\nreturn 0;\ncase 1:\nskip();\nreturn updateRegexUflagIsIllegal(0, 'Atoms can only escape certain non-special chars without u-flag');\ncase 4:\nlet wide = isIdentRestChr(c, pointer);\nif (wide === (-3)) {\nc = input.codePointAt(pointer);\nskipFastWithoutUpdatingCache();\nskip();\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot use a surrogate pair as atom escape (' + c) + ', `') + String.fromCodePoint(c)) + '`)');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\n}\nif (wide === (-2)) {\nskip();\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot escape this regular identifier character [ord=' + c) + '][') + String.fromCharCode(c)) + ']');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\n}\n;\nskip();\nif (((c === 0x2028) || (c === 0x2029))) {\nreturn regexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\n}\nif (webCompat === false) {\nreturn regexSyntaxError(((('Cannot escape this non-identifier character [ord=' + c) + '][') + String.fromCharCode(c)) + ']');\n}\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain syntax chars with u-flag');\ncase 5:\nskip();\nif (pointer >= len) {\nreturn regexSyntaxError('Encountered early EOF while parsing char escape');\n}\nlet d = cache;\nif (isAsciiLetter(d)) {\nskip();\nreturn 0;\n}\nlet reason = ('Illegal char escape char (ord=' + d) + ')';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nreturn regexSyntaxError(reason);\ncase 6:\nconst FROM_ATOM = false;\nreturn parseRegexPropertyEscape(c, FROM_ATOM);\ncase 7:\nskip();\nif (pointer >= len) return 0;\nif (isAsciiNumber(cache)) {\nlet reason = 'Back references can not have more two or more consecutive numbers';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n} else {\nreturn regexSyntaxError(reason);\n}\n}\nreturn 0;\ncase 8:\nreturn parseRegexDecimalEscape(c);\ncase 9:\n{\nlet uflagStatus = 0;\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing `\\\\k` escape in regex character class');\nc = cache;\nif (c !== 0x3c) {\nkCharClassEscaped = true;\nlet reason = 'Named back reference \\\\k; missing group name';\nif (webCompat === false) {\nreturn regexSyntaxError(reason, c);\n}\nreturn updateRegexUflagIsIllegal(0, reason);\n}\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing `\\\\k` escape in regex character class');\nc = cache;\nuflagStatus = parseRegexGroupName(c, uflagStatus, false);\nreturn uflagStatus;\n}\ncase 10:\nskip();\nreturn regexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\ncase 11:\nskip();\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Atom escape can only escape certain letters without u-flag');\n}\nreturn regexSyntaxError(('Cannot escape this letter [' + String.fromCharCode(c)) + ']');\n;\n}\n}\nfunction parseRegexDecimalEscape(c) {\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF while parsing decimal escape in regex');\nlet d = cache;\nif (((d >= 0x30) && (d <= 0x39))) {\nskip();\nlet e = cache;\nif (((e >= 0x30) && (e <= 0x39))) {\nlet reason = 'Parsed too many digits';\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, reason);\n} else {\nreturn regexSyntaxError(reason);\n}\n} else {\nlargestBackReference = Math.max(((c - 0x30) * 10) + (d - 0x30));\n}\n} else {\nlargestBackReference = Math.max(largestBackReference, c - 0x30);\n}\nreturn 0;\n}\nfunction parseRegexCharClass() {\nskip();\nlet prev = 0;\nlet surrogate = 0;\nlet isSurrogate = false;\nlet isSurrogateHead = false;\nlet wasSurrogate = true;\nlet wasSurrogateHead = false;\nlet urangeOpen = false;\nlet urangeLeft = -1;\nlet nrangeOpen = false;\nlet nrangeLeft = -1;\nlet flagState = 0;\nif (pointer >= len) return regexSyntaxError('Encountered early EOF while parsing char class (1)');\nlet c = cache;\nif (c === 0x5e) {\nskip();\nif (pointer >= len) return regexSyntaxError('Encountered early EOF while parsing char class (2)');\nc = cache;\n}\nwhile (c !== 0x5d) {\nlet wasEscape = false;\nlet wasDoubleQuad = false;\nlet wasBadUniEscape = false;\nlet wasPropEscape = false;\nlet wasPropOnly = false;\nlet wasBadPropEscape = false;\nlet wasRubyWebEscape = false;\nlet escapeCharUP = 0;\nif (c === 0x5c) {\nskip();\nwasEscape = true;\nif (pointer >= len) {\nregexSyntaxError('Early EOF after backslash in char class');\nreturn 0x110000;\n}\nc = cache;\nescapeCharUP = c;\nlet escapePointer = pointer;\nc = parseRegexCharClassEscape(c);\nif (escapeCharUP === 0x75) {\nif (c === 0x110000) {\nif (pointer >= len) return 0x110000;\nif (webCompat === false) return 0x110000;\nwasBadUniEscape = true;\nflagState = updateRegexUflagIsIllegal(flagState, 'A broken `\\\\u` escape can never be valid with u-flag');\nwasPropOnly = (pointer - escapePointer) === 1;\n} else if ((c & 67108864) > 0) {\nc ^= 67108864;\nwasRubyWebEscape = webCompat === true;\n} else if (c > 0xffff) {\nwasDoubleQuad = true;\n}\n} else if (((escapeCharUP === 0x70) || (escapeCharUP === 0x50))) {\nif (webCompat === true) {\nif (((((c === 0x110000) || (c === 34668544))) || ((c & 16777216) === 16777216))) {\nwasBadPropEscape = true;\n} else {\nwasPropEscape = true;\nwasPropOnly = (pointer - escapePointer) === 1;\n}\n}\n}\nif (c === 0x110000) {\nif (!wasBadUniEscape) {\nflagState = regexSyntaxError(lastPotentialRegexError);\n}\n} else if (c === 34668544) {\nflagState = regexSyntaxError(lastPotentialRegexError);\nc = 33554432;\n} else if (c === 33554432) {\n\n} else if (c === 0x110001) {\nif (webCompat === true) {\nflagState = updateRegexUflagIsIllegal(0, 'Char class can not contain `\\\\B`');\n} else {\nflagState = regexSyntaxError('Char class can not contain `\\\\B`');\n}\nc = 0x42;\n} else if (c === 0x110002) {\nflagState = updateRegexUflagIsIllegal(flagState, lastPotentialRegexError);\nc = 0x5c;\n} else {\nif (c & 16777216) {\nc = c ^ 16777216;\nflagState = updateRegexUflagIsIllegal(flagState, lastPotentialRegexError);\n}\nif (c & 8388608) {\nc = c ^ 8388608;\nflagState = updateRegexUflagIsMandatory(flagState, lastPotentialRegexError);\n}\n}\n} else if (((((((c === 0x0D) || (c === 0x0A))) || (c === 0x2028))) || (c === 0x2029))) {\nreturn regexSyntaxError('Encountered newline');\n} else {\nskip();\n}\nif (wasBadUniEscape) {\n\n} else if (wasEscape) {\nisSurrogate = c > 0xffff;\nif (isSurrogate) surrogate = c;\nisSurrogateHead = false;\n} else if ((wasSurrogateHead && isSurrogateTail(c))) {\nisSurrogate = true;\nisSurrogateHead = false;\nsurrogate = getSurrogate(prev, c);\n} else {\nisSurrogate = false;\nisSurrogateHead = isSurrogateLead(c);\n}\nif (urangeOpen) {\nlet urangeRight = (isSurrogate? surrogate : ((wasSurrogateHead? prev : c)));\nif (((urangeLeft === 33554432) || (urangeRight === 33554432))) {\nflagState = updateRegexUflagIsIllegal(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` not allowed in ranges with u');\n} else if (((!isSurrogateHead) || wasSurrogateHead)) {\nurangeOpen = false;\nif (urangeLeft > urangeRight) {\nflagState = updateRegexUflagIsIllegal(flagState, ((((((('Encountered incorrect range (left>right, ' + urangeLeft) + ' > ') + urangeRight) + ', 0x') + urangeLeft.toString(16)) + ' > 0x') + urangeRight.toString(16)) + ') which is illegal with u-flag');\n}\nurangeLeft = -1;\n} else {\n\n}\n} else if (((((c === 0x2d) && (!wasEscape))) && (urangeLeft !== (-1)))) {\nurangeOpen = true;\n} else {\nurangeLeft = (isSurrogate? surrogate : c);\n}\nlet cTmp = (((wasRubyWebEscape || wasPropEscape))? escapeCharUP : c);\nlet cTail = c;\nlet stillDataLeft = true;\nlet rubyHackLhs = (((wasRubyWebEscape || wasBadUniEscape)) || wasPropEscape);\nlet rubyHackRhsPeek = (wasBadUniEscape || ((wasBadPropEscape && (!wasPropOnly))));\nlet rubyHackRhsCurly = (wasRubyWebEscape || ((wasPropEscape && (!wasPropOnly))));\nwhile (stillDataLeft) {\nif (wasDoubleQuad) {\nwasDoubleQuad = false;\ncTail = codePointToSurrogateTail(cTmp);\ncTmp = codePointToSurrogateHead(cTmp);\n} else if (rubyHackLhs) {\nrubyHackLhs = false;\ncTmp = escapeCharUP;\nif (wasPropOnly) stillDataLeft = false;\n} else if (rubyHackRhsCurly) {\nrubyHackRhsCurly = false;\ncTmp = 0x7d;\nstillDataLeft = false;\n} else if (rubyHackRhsPeek) {\ncTmp = peekd(-1);\nrubyHackRhsPeek = false;\nstillDataLeft = false;\n} else {\nstillDataLeft = false;\ncTmp = cTail;\n}\nif (nrangeOpen) {\nconst nrangeRight = cTmp;\nif (((nrangeLeft === 33554432) || (nrangeRight === 33554432))) {\nif (webCompat === false) {\nflagState = updateRegexUflagIsMandatory(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` not allowed in ranges');\n}\n} else {\nif (nrangeLeft > nrangeRight) {\nflagState = updateRegexUflagIsMandatory(flagState, ((((((('Encountered incorrect range (left>right, ' + nrangeLeft) + ' > ') + nrangeRight) + ', 0x') + nrangeLeft.toString(16)) + ' > 0x') + nrangeRight.toString(16)) + ') when parsing as if without u-flag');\n}\n}\nnrangeLeft = -1;\nnrangeOpen = false;\n} else if (((((cTmp === 0x2d) && (!wasEscape))) && (nrangeLeft !== (-1)))) {\nnrangeOpen = true;\n} else {\nnrangeLeft = cTmp;\n}\n}\nwasSurrogate = isSurrogate;\nwasSurrogateHead = isSurrogateHead;\nprev = c;\nif (pointer >= len) {\nreturn regexSyntaxError('Unexpected early EOF while parsing character class');\n}\nc = cache;\n}\nskip();\nif ((urangeOpen && wasSurrogateHead)) {\nif (((urangeLeft === 33554432) || (prev === 33554432))) {\nreturn updateRegexUflagIsIllegal(flagState, 'Character class escapes `\\\\d \\\\D \\\\s \\\\S \\\\w \\\\W \\\\p \\\\P` are only ok as a range with webcompat, without uflag');\n}\nif (urangeLeft > prev) {\nreturn updateRegexUflagIsIllegal(flagState, ((((((('Encountered incorrect range end (left>right, ' + urangeLeft) + ' > ') + prev) + ', 0x') + urangeLeft.toString(16)) + ' > 0x') + prev.toString(16)) + ') which is illegal with u-flag');\n}\nreturn flagState;\n}\nreturn flagState;\n}\nfunction surrogateToCodepoint(head, tail) {\nreturn (((head & 0x3ff) << 10) | (tail & 0x3ff)) + 0x10000;\n}\nfunction codePointToSurrogateTail(codepoint) {\nreturn ((codepoint - 0x10000) & 0b1111111111) + 0xDC00;\n}\nfunction codePointToSurrogateHead(codepoint) {\nreturn ((codepoint - 0x10000) >> 10) + 0xD800;\n}\nfunction parseRegexCharClassEscape(c) {\nlet s = ((c >= 0x7f)? 1 : regexClassEscapeStartJumpTable[c]);\nswitch (s) {\ncase 0:\nskip();\n;\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class with the u-flag');\nreturn c | 16777216;\n}\nif (isIdentRestChr(c, pointer) === (-1)) {\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class with the u-flag');\nreturn c | 16777216;\n}\n;\nregexSyntaxError(('Cannot escape `' + String.fromCharCode(c)) + '` in a regex char class');\nreturn 0x110000;\ncase 1:\n{\nupdateRegexUflagIsIllegal(0, ('Cannot escape `' + String.fromCharCode(c)) + '` in a char class with the u-flag');\nif (webCompat === true) {\nskip();\nreturn c | 16777216;\n}\nlet wide = isIdentRestChr(c, -1);\nif (wide === (-2)) {\nregexSyntaxError(('Cannot escape `' + String.fromCodePoint(c)) + '` in a char class');\nreturn 0x110000;\n}\nif (((c === 0x2028) || (c === 0x2029))) {\nskip();\nregexSyntaxError('Regular expressions do not support line continuations (escaped x2028 x2029)');\nreturn 0x110000;\n}\nskip();\nreturn c | 16777216;\n}\ncase 2:\nskip();\nreturn parseUnicodeEscapeForRegexCharClass();\ncase 3:\nskip();\nif (eofd(1)) {\nregexSyntaxError('Found EOF before completely parsing a hex escape (in a char class of a regex)');\nreturn 0x110000;\n}\nlet a = cache;\nlet va = getHexValue(a);\nif (va === 16) {\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, 'First character of hex escape was invalid');\nreturn 16777336;\n}\nregexSyntaxError('First character of hex escape was invalid');\nreturn 0x110000;\n}\nskip();\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) {\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, 'Second character of hex escape was invalid');\nreturn 16777336;\n}\nregexSyntaxError('Second character of hex escape was invalid');\nreturn 0x110000;\n}\nskip();\nreturn (va << 4) | vb;\ncase 4:\n{\nskip();\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing `\\\\c` in a character class');\nreturn 0x110000;\n}\nlet d = cache;\nif (isAsciiLetter(d)) {\nskip();\nreturn d % 32;\n}\nlet reason = 'The `\\\\c` escape is only legal in a char class without u-flag and in webcompat mode';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn 0x110002;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\ncase 5:\nskip();\nif (webCompat === true) {\nkCharClassEscaped = true;\nupdateRegexUflagIsIllegal(0, 'Can only have `\\\\k` in a char class without u-flag and in webcompat mode');\nreturn 16777323;\n}\nregexSyntaxError('A character class is not allowed to have `\\\\k` back-reference');\nreturn 0x110000;\ncase 6:\nskip();\nreturn 8;\ncase 7:\n{\nskip();\nreturn 0x110001;\n}\ncase 8:\nskip();\nreturn 0x000C;\ncase 9:\nskip();\nreturn 0x000A;\ncase 10:\nskip();\nreturn 0x000D;\ncase 11:\nskip();\nreturn 0x0009;\ncase 12:\nskip();\nreturn 0x000B;\ncase 13:\nskip();\nreturn 33554432;\ncase 14:\nconst FROM_CHARCLASS = true;\nlet regexPropState = parseRegexPropertyEscape(c, FROM_CHARCLASS);\nif (regexPropState === 4) {\nreturn 34668544;\n}\nif (regexPropState === 2) {\nreturn 50331648;\n}\nif (regexPropState === 1) {\nreturn 41943040;\n}\n;\n;\nreturn 33554432;\ncase 15:\n{\nskip();\nif ((pointer < len && isAsciiNumber(cache))) {\nlet reason = 'An escaped zero cannot be followed by another number because that would be an octal escape';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn parseOctalFromSecondDigit(c) | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\nreturn 0;\n}\ncase 16:\n{\nskip();\nlet reason = 'A character class is not allowed to have numeric back-reference';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn parseOctalFromSecondDigit(c) | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\ncase 17:\nskip();\nreturn parseDecimalEscape(c);\ncase 18:\nskip();\nreturn c;\ncase 19:\n{\nskip();\nif (webCompat === true) {\nreturn 0x2d;\n}\nupdateRegexUflagIsMandatory(0, 'Escaping a dash in a char class is not allowed');\nreturn 8388653;\n}\ncase 20:\nskip();\nregexSyntaxError('Regular expressions do not support line continuations (escaped newline)');\nreturn 0x110000;\n;\n}\n}\nfunction parseRegexPropertyEscape(c, fromCharClass) {\nif (!supportRegexPropertyEscapes) {\nlet uflagState = updateRegexUflagIsIllegal(0, 'Property escapes are not supported by the currently targeted language version');\nif (webCompat === true) return uflagState;\nreturn updateRegexUflagIsMandatory(uflagState, 'Cannot escape `\\\\p` without u-flag');\n}\nskip();\nif (pointer >= len) return regexSyntaxError('Early EOF after a regex `\\\\p`');\nif (cache !== 0x7b) {\nif (webCompat === true) return updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` must start with a curly bracket');\nreturn regexSyntaxError('Property escape `\\\\p` must start with a curly bracket');\n}\nc = skipPeek();\nlet pointerOffset = pointer;\nlet name = '';\nlet sawCommas = 0;\nlet hasEq = false;\nlet value = '';\ndo {\nif (((((((c >= 0x61) && (c <= 0x7a))) || (((c >= 0x41) && (c <= 0x5a))))) || (c === 0x5f))) {\n\n} else if (c === 0x7d) {\nbreak;\n} else if (c === 0x3d) {\nif (pointerOffset === pointer) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn regexSyntaxError('Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nif (hasEq) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` contained double equal sign, which is not valid');\n}\nreturn regexSyntaxError('Property escape `\\\\p` contained double equal sign, which is not valid');\n}\nhasEq = true;\nname = slice(pointerOffset, pointer);\npointerOffset = pointer + 1;\n} else {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nreturn regexSyntaxError(('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nc = skipPeek();\nif (pointer >= len) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Encountered early EOF while parsing `\\\\p` property escape');\n}\nreturn regexSyntaxError('Encountered early EOF while parsing `\\\\p` property escape');\n}\n} while (true);\nif (pointerOffset === pointer) {\nif (webCompat === true) {\nif (hasEq) {\nreturn updateRegexUflagIsIllegal(0, 'Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn updateRegexUflagIsIllegal(0, ('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nif (hasEq) {\nreturn regexSyntaxError('Property escape `\\\\p` had no value after the `=` which is illegal');\n}\nreturn regexSyntaxError(('Property escape `\\\\p` contained illegal character `' + slice(pointer, pointer + 1)) + '`');\n}\nif (hasEq) value = slice(pointerOffset, pointer); else name = slice(pointerOffset, pointer);\nlet nc = (',' + name) + ',';\nif (hasEq) {\nif (!TABLE_NONBIN_UNI_PROPS.includes(nc)) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The `\\\\p` escaped binary property name `' + name) + '` is not valid (does not appear in \"table-nonbinary-unicode-properties\")');\n}\nreturn regexSyntaxError(('The `\\\\p` escaped binary property name `' + name) + '` is not valid (does not appear in \"table-nonbinary-unicode-properties\")');\n}\nlet vc = (',' + value) + ',';\nif (((!TABLE_GEN_CAT_VALUES.includes(vc)) && (!TABLE_SCRIPT_VALUES.includes(vc)))) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The escaped property value `' + value) + '` is not valid (does not appear in \"table-unicode-general-category-values\" nor \"table-unicode-script-values\")');\n}\nreturn regexSyntaxError(('The escaped property value `' + value) + '` is not valid (does not appear in \"table-unicode-general-category-values\" nor \"table-unicode-script-values\")');\n}\nskip();\nif (webCompat === true) {\nreturn 0;\n}\nreturn updateRegexUflagIsMandatory(0, 'The `\\\\p` property escape is only legal with a u-flag, or as a webcompat edge case');\n}\nif (((!TABLE_BIN_UNI_PROPS.includes(nc)) && (!TABLE_GEN_CAT_VALUES.includes(nc)))) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, ('The escaped lone property name `' + name) + '` is not valid (does not appear in \"table-binary-unicode-properties\" nor \"table-unicode-general-category-values\")');\n}\nreturn regexSyntaxError(('The escaped lone property name `' + name) + '` is not valid (does not appear in \"table-binary-unicode-properties\" nor \"table-unicode-general-category-values\") with u-flag, and `\\\\p` is not valid without u-flag and without webcompat');\n}\nskip();\nif (webCompat === true) {\nreturn 0;\n}\nreturn updateRegexUflagIsMandatory(0, 'The `\\\\p` property escape is only legal with a u-flag, or as a webcompat edge case');\n}\nfunction parseRegexFlags() {\nlet g = 0;\nlet i = 0;\nlet m = 0;\nlet u = 0;\nlet y = 0;\nlet s = 0;\nwhile (pointer < len) {\nlet c = cache;\nswitch (c) {\ncase 0x67:\n++g;\nbreak;\ncase 0x69:\n++i;\nbreak;\ncase 0x6D:\n++m;\nbreak;\ncase 0x75:\n++u;\nbreak;\ncase 0x79:\n++y;\nbreak;\ncase 0x73:\nif (!supportRegexDotallFlag) {\nreturn THROW('The dotall flag `s` is not supported in the currently targeted language version', pointer, pointer);\n}\n++s;\nbreak;\ndefault:\nif ((isAsciiLetter(c) || (c === 0x5c))) {\nreturn regexSyntaxError(((('Unknown regex flag [ord=' + c) + ', `') + String.fromCharCode(c)) + '`)]');\n}\nif ((((((g | i) | m) | u) | y) | s) > 1) {\nreturn regexSyntaxError('Encountered at least one regex flag twice');\n}\nreturn ((u > 0)? 1 : 2);\n}\nskip();\n}\nif ((((((g | i) | m) | u) | y) | s) > 1) {\nreturn regexSyntaxError('Encountered at least one regex flag twice');\n}\nreturn ((u > 0)? 1 : 2);\n}\nfunction parseRegexCurlyQuantifier(c) {\nlet min = 0;\nwhile (isAsciiNumber(c)) {\nmin = (min * 10) + (c - 0x30);\nskip();\nif (pointer >= len) return 3;\nc = cache;\n}\nif (c !== 0x2c) {\nif (c !== 0x7d) return 3;\nskip();\nreturn 1;\n}\nskip();\nif (pointer >= len) return 3;\nc = cache;\nif (!isAsciiNumber(c)) {\nif (c !== 0x7d) return 3;\nskip();\nreturn 1;\n}\nlet max = 0;\ndo {\nmax = (max * 10) + (c - 0x30);\nskip();\nif (pointer >= len) return 3;\nc = cache;\n} while (isAsciiNumber(c));\nif (c !== 0x7d) return 3;\nskip();\nif (min <= max) return 1;\nreturn 2;\n}\nfunction isSurrogateLead(c) {\nreturn ((c >= 0xD800) && (c <= 0xDBFF));\n}\nfunction isSurrogateTail(c) {\nreturn ((c >= 0xDC00) && (c <= 0xDFFF));\n}\nfunction getSurrogate(c1, c2) {\nreturn (((c1 - 0xD800) * 0x400) + (c2 - 0xDC00)) + 0x10000;\n}\nfunction parseDecimalEscape(c) {\nlet reason = 'Cannot escape \\\\8 or \\\\9 in a regex char class with u-flag';\nif (webCompat === true) {\nupdateRegexUflagIsIllegal(0, reason);\nreturn c | 16777216;\n}\nregexSyntaxError(reason);\nreturn 0x110000;\n}\nfunction parseOctalFromSecondDigit(firstChar) {\nif (pointer >= len) return firstChar - 0x30;\nlet secondChar = cache;\nif (isLowerOctal(firstChar)) {\nif (isOctal(secondChar)) {\nskip();\nif (pointer >= len) return ((firstChar - 0x30) * 8) + (secondChar - 0x30);\nlet thirdChar = cache;\nif (isOctal(thirdChar)) {\nskip();\nreturn ((((firstChar - 0x30) * 8) * 8) + ((secondChar - 0x30) * 8)) + (thirdChar - 0x30);\n}\nreturn ((firstChar - 0x30) * 8) + (secondChar - 0x30);\n}\nreturn firstChar - 0x30;\n}\nif (isOctal(secondChar)) {\nskip();\nif (pointer >= len) return ((firstChar - 0x30) * 8) + (secondChar - 0x30);\nlet thirdChar = cache;\nif (isLowerOctal(thirdChar)) {\nskip();\nreturn ((((firstChar - 0x30) * 8) * 8) + ((secondChar - 0x30) * 8)) + (thirdChar - 0x30);\n}\nreturn ((firstChar - 0x30) * 8) + (secondChar - 0x30);\n}\nreturn firstChar - 0x30;\n}\nfunction isOctal(c) {\nreturn ((c >= 0x30) && (c <= 0x37));\n}\nfunction isLowerOctal(c) {\nreturn ((c >= 0x30) && (c <= 0x33));\n}\nfunction isUpperOctal(c) {\nreturn ((c >= 0x34) && (c <= 0x37));\n}\nfunction parseUnicodeEscapeForNonRegex() {\nlet c = cache;\nif (c !== 0x7b) {\nreturn parseUnicodeQuadEscape(c, true);\n}\nreturn parseUnicodeRubyEscape();\n}\nfunction parseUnicodeEscapeForRegexAtom() {\nif (pointer >= len) {\nreturn regexSyntaxError('Early EOF while trying to parse unicode escape');\n}\nlet c = cache;\nlet wasRuby = false;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nwasRuby = true;\n} else {\nc = parseUnicodeQuadEscape(c, false);\n}\nif (pointer >= len) {\nreturn regexSyntaxError('EOF while trying to parse regex atom unicode escape');\n}\nif (c === 0x110000) {\nif (webCompat === true) {\nreturn updateRegexUflagIsIllegal(0, 'Error while trying to parse regex atom unicode escape');\n}\nreturn regexSyntaxError('Error while trying to parse regex atom unicode escape');\n}\nif ((wasRuby && (webCompat === false))) {\nreturn updateRegexUflagIsMandatory(0, 'A regex atom that is an unicode ruby escape is only legal with u-flag');\n}\nif ((((wasRuby && (webCompat === true))) && (!c.toString(16).match(/[a-z]/i)))) {\nif ((pointer < len && (cache === 0x3f))) {\nskip();\n}\nreturn 8;\n}\nreturn 0;\n}\nfunction parseUnicodeEscapeForRegexCharClass() {\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing a unicode escape in a regex char class');\nreturn 0x110000;\n}\nlet c = cache;\nlet wasQuad = true;\nif (c === 0x7b) {\nc = parseUnicodeRubyEscape();\nwasQuad = false;\n} else {\nc = parseUnicodeQuadEscape(c, false);\n}\nif (pointer >= len) {\nregexSyntaxError('Early EOF while parsing a unicode escape in a regex char class');\nreturn 0x110000;\n}\nif (c === 0x110000) {\nreturn 0x110000;\n}\nlet rubyWebException = false;\nif (!wasQuad) {\nif (webCompat === false) {\nupdateRegexUflagIsMandatory(0, 'Found a unicode ruby escape which is only valid with u-flag');\nrubyWebException = true;\n}\nc |= 67108864;\n}\nif (rubyWebException) return c | 8388608;\nreturn c;\n}\nfunction parseUnicodeQuadEscape(a, noDouble) {\nif (eofd(3)) {\nupdateRegexUflagIsIllegal(0, 'Unexpected EOF while parsing unicode quad escape');\nreturn 0x110000;\n}\nlet b = peekd(1);\nlet c = peekd(2);\nlet d = peekd(3);\nlet va = getHexValue(a);\nlet vb = getHexValue(b);\nlet vc = getHexValue(c);\nlet vd = getHexValue(d);\nif ((((va | vb) | vc) | vd) > 15) {\nupdateRegexPotentialError('Attempted to parse a unicode quad escape but at least one digit was not a hex');\nreturn 0x110000;\n}\nskip();\nskip();\nskip();\nskip();\nlet firstPart = (((va << 12) | (vb << 8)) | (vc << 4)) | vd;\nif ((((((((((noDouble || (firstPart < 0xD800))) || (firstPart > 0xDBFF))) || eofd(5))) || (cache !== 0x5c))) || (peekd(1) !== 0x75))) {\nreturn firstPart;\n}\nlet e = peekd(2);\nlet f = peekd(3);\nlet g = peekd(4);\nlet h = peekd(5);\nlet ve = getHexValue(e);\nlet vf = getHexValue(f);\nlet vg = getHexValue(g);\nlet vh = getHexValue(h);\nif ((((ve | vf) | vg) | vh) > 15) {\nreturn firstPart;\n}\nlet secondPart = (((ve << 12) | (vf << 8)) | (vg << 4)) | vh;\nif (((secondPart < 0xDC00) || (secondPart > 0xDFFF))) {\nreturn firstPart;\n}\nskip();\nskip();\nskip();\nskip();\nskip();\nskip();\nlet codepoint = surrogateToCodepoint(firstPart, secondPart);\nupdateRegexPotentialError('A double unicode quad escape that represents a surrogate pair in char class or group name is only valid with u-flag');\nreturn codepoint;\n}\nfunction parseUnicodeRubyEscape() {\nskip();\nlet c = parseUnicodeRubyEscapeBody();\nif (((((c === 0x110000) || pointer >= len)) || (!(cache === 0x7d)))) {\nreturn 0x110000;\n}\nskip();\nreturn c;\n}\nfunction parseUnicodeRubyEscapeBody() {\nif (pointer >= len) return 0x110000;\nlet a = cache;\nlet v = getHexValue(a);\nif (v === 16) return 0x110000;\nskip();\nreturn parseUnicodeRubyEscapeBody2(v);\n}\nfunction parseUnicodeRubyEscapeBody2(v) {\nif (v === 0) {\nif (pointer >= len) return 0x110000;\nlet c = skipZeroes();\nv = getHexValue(c);\nif (v === 16) {\nreturn 0;\n}\nskip();\n}\nreturn parseUnicodeRubyEscapeBody3(v);\n}\nfunction parseUnicodeRubyEscapeBody3(v) {\nif (pointer >= len) return 0x110000;\nlet b = cache;\nlet vb = getHexValue(b);\nif (vb === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody4((v << 4) + vb);\n}\nfunction parseUnicodeRubyEscapeBody4(v) {\nif (pointer >= len) return 0x110000;\nlet c = cache;\nlet vc = getHexValue(c);\nif (vc === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody5((v << 4) + vc);\n}\nfunction parseUnicodeRubyEscapeBody5(v) {\nif (pointer >= len) return 0x110000;\nlet d = cache;\nlet vd = getHexValue(d);\nif (vd === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody6((v << 4) + vd);\n}\nfunction parseUnicodeRubyEscapeBody6(v) {\nif (pointer >= len) return 0x110000;\nlet e = cache;\nlet ve = getHexValue(e);\nif (ve === 16) return v;\nskip();\nreturn parseUnicodeRubyEscapeBody7((v << 4) + ve);\n}\nfunction parseUnicodeRubyEscapeBody7(v) {\nif (pointer >= len) return 0x110000;\nlet f = cache;\nlet vf = getHexValue(f);\nif (vf === 16) return v;\nskip();\nlet r = (v << 4) + vf;\nif (r >= 0x110000) return 0x110000;\nreturn r;\n}\nfunction parseOtherUnicode(c) {\nswitch (c) {\ncase 0xA0:\nreturn parseSpace();\ncase 0xFEFF:\nreturn parseSpace();\ncase 0x2028:\nreturn parseNewlineSolo();\ncase 0x2029:\nreturn parseNewlineSolo();\ndefault:\nlet t = parseIdentUnicodeOrError(c);\nif (t !== 2097175) return t;\nreturn parseWhitespaceUnicodeOrError(c);\n}\n}\nfunction parseIdentUnicodeOrError(c) {\nlet cu = input.codePointAt(pointer - 1);\nlet wide = isIdentStart(cu, pointer - 1);\nif (wide !== (-1)) {\nif (wide === (-3)) skip();\nreturn parseIdentifierRest(String.fromCodePoint(cu), ((wide === (-3))? 2 : 1));\n}\nif (!lastReportableLexerError) lastReportableLexerError = ((('Unexpected unicode character: ' + c) + ' (') + String.fromCharCode(c)) + ')';\nreturn 2097175;\n}\nfunction parseWhitespaceUnicodeOrError(c) {\nreturn ([0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202F, 0x205F, 0x3000].includes(c)? 257 : 2097175);\n}\nfunction THROW(str, tokenStart, tokenStop) {\n$error('Throwing this error:', str);\n_THROW('Lexer error! ' + str, tokenStart, tokenStop);\n}\nfunction _THROW(str, tokenStart, tokenStop, msg = '', withCodeFrame = errorCodeFrame, fullCodeFrameLocal = truncCodeFrame) {\nlet ectxt = (withCodeFrame? getErrorContext(tokenStart, tokenStop, msg, fullCodeFrameLocal) : '');\nlet context = (('\\n`````\\n' + (((ectxt[ectxt.length - 1] !== '\\n')? '\\n' : ''))) + ectxt) + '`````\\n';\n$log('Error at:' + context);\nif (gracefulErrors === false) throw new Error(((str + '\\n') + ((withCodeFrame? '\\n' : ''))) + ectxt); else $error(str);\n}\nfunction getErrorContext(tokenStart, tokenStop, msg, truncCodeFrame = false) {\nlet inputOffset = 0;\nif ((truncCodeFrame && (tokenStart > 100))) inputOffset = tokenStart - 100;\nlet inputLen = input.length - inputOffset;\nif ((truncCodeFrame && ((tokenStop + 100) < input.length))) inputLen = (tokenStop + 100) - inputOffset;\nlet isPointerIncluded = true;\nif ((inputOffset + inputLen) < pointer) {\nlet len = pointer - inputOffset;\nif (len < 1024) {\ninputLen = len;\n} else {\nisPointerIncluded = false;\n}\n}\nlet usedInput = input.slice(inputOffset, inputOffset + inputLen);\nlet tokenOffset = tokenStart - inputOffset;\nlet nl1 = usedInput.lastIndexOf('\\n', tokenOffset);\nlet nl2 = usedInput.indexOf('\\n', nl1 + 1);\nif (nl2 < 0) nl2 = usedInput.length;\nlet arrowCount = ((tokenStop - tokenStart) || 1);\nlet indentCount = tokenOffset - (nl1 + 1);\nlet pointerLine = currentLine;\nlet errorLine = currentLine;\nlet errorColumn = ((((inputOffset > 0) && (nl1 < 0)))? (-1) : ((tokenStart - inputOffset) - (((nl1 >= 0)? nl1 + 1 : 0))));\nif (isPointerIncluded) {\nlet relativePointer = pointer - inputOffset;\nlet searchPointer = relativePointer;\nwhile (searchPointer > 0) {\nsearchPointer = usedInput.lastIndexOf('\\n', searchPointer - 1);\n--pointerLine;\nif (searchPointer > nl1) --errorLine;\n}\nif (searchPointer !== 0) pointerLine += 1;\n}\nlet maxPointerlineLen = ('' + currentLine).length;\nlet gutterWidth = maxPointerlineLen + 4;\nlet pre = usedInput.slice(0, nl2).split('\\n');\nlet post = usedInput.slice(nl2 + 1, inputLen).split('\\n');\nwhile (((pre.length > 1) && (pre[0].length === 0))) {\npre.shift();\n++pointerLine;\n}\nwhile (((post.length > 0) && (post[post.length - 1].length === 0))) {\npost.pop();\n}\nlet lc = pointerLine;\nlet pre2 = pre.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + ' ║ ') + s.trimRight())).join('\\n');\nlet post2 = post.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + ' ║ ') + s.trimRight())).join('\\n');\nif (('' + lc).length > maxPointerlineLen) {\nmaxPointerlineLen = ('' + lc).length;\ngutterWidth = maxPointerlineLen + 4;\nlc = pointerLine;\npre2 = pre.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + ' ║ ') + s.trimRight())).join('\\n');\npost2 = post.map(s => (((' ' + ('' + (lc++)).padStart(maxPointerlineLen, ' ')) + ' ║ ') + s.trimRight())).join('\\n');\n}\nlet col = ((pointerLine === 1)? inputOffset : usedInput.lastIndexOf(inputOffset));\nlet top = ((((((('start@' + pointerLine) + ':') + (((col < 0)? '?' : col))) + ', error@') + errorLine) + ':') + (((errorColumn < 0)? '?' : errorColumn))) + '\\n';\nlet bar = '═'.repeat(top.length - gutterWidth) + '\\n';\nlet header = ('╔' + '═'.repeat(maxPointerlineLen)) + '═╦';\nlet footer = ('╚' + '═'.repeat(maxPointerlineLen)) + '═╩';\nlet returnValue = ((((((((((((((((top + header) + bar) + pre2) + '\\n') + ' '.repeat(Math.max(0, maxPointerlineLen + 1))) + ' ║ ') + ' '.repeat(Math.max(0, indentCount))) + '^'.repeat(Math.max(0, arrowCount))) + '------- error') + ((msg? ': ' + msg : ''))) + (((tokenOffset >= usedInput.length)? ' at EOF' : ''))) + ((post2? '\\n' : ''))) + post2) + '\\n') + footer) + bar) + '';\nreturn returnValue.split('\\n').map(s => (s.trimRight())).join('\\n');\n}\nreturn {tokens:tokenStorage, nextToken:nextToken, asi:addAsi, throw:_THROW, lexError:function() {\nTHROW(lastReportableLexerError, startForError, pointer);\n}, getTokenCountAny:function() {\nreturn anyTokenCount;\n}, getTokenCountSolid:function() {\nreturn solidTokenCount;\n}, prevEndColumn:function() {\nreturn prevTokenEndColumn;\n}, prevEndLine:function() {\nreturn prevTokenEndLine;\n}, prevEndPointer:function() {\nreturn prevTokenEndPointer;\n}, currColumn:function() {\nreturn pointer - currentColOffset;\n}, currLine:function() {\nreturn currentLine;\n}, currPointer:function() {\nreturn pointer;\n}, getNlwas:function() {\nreturn nlwas;\n}, getCanoN:function() {\nreturn lastCanonizedInput;\n}, getType:function() {\nreturn lastType;\n}, getStart:function() {\nreturn lastStart;\n}, getStop:function() {\nreturn lastStop;\n}, getLine:function() {\nreturn lastLine;\n}, getColumn:function() {\nreturn lastColumn;\n}, sliceInput:slice};\n}\nfunction isLfPsLs(c) {\nreturn ((c === 0x0A) || isPsLs(c));\n}\nfunction isPsLs(c) {\nreturn ((c === 0x2028) || (c === 0x2029));\n}\nfunction START(type) {\nswitch (type) {\ncase 1:\nreturn 'START_SPACE';\ncase 2:\nreturn 'START_ID';\ncase 3:\nreturn 'START_KEY';\ncase 4:\nreturn 'START_NL_SOLO';\ncase 5:\nreturn 'START_CR';\ncase 6:\nreturn 'START_STRING';\ncase 7:\nreturn 'START_DECIMAL';\ncase 8:\nreturn 'START_DOT';\ncase 9:\nreturn 'START_CURLY_CLOSE';\ncase 10:\nreturn 'START_EQ';\ncase 11:\nreturn 'START_DIV';\ncase 12:\nreturn 'START_PLUS';\ncase 13:\nreturn 'START_MIN';\ncase 14:\nreturn 'START_ZERO';\ncase 15:\nreturn 'START_TEMPLATE';\ncase 16:\nreturn 'START_EXCL';\ncase 17:\nreturn 'START_PERCENT';\ncase 18:\nreturn 'START_AND';\ncase 19:\nreturn 'START_STAR';\ncase 20:\nreturn 'START_CARET';\ncase 21:\nreturn 'START_LT';\ncase 22:\nreturn 'START_GT';\ncase 23:\nreturn 'START_OR';\ncase 24:\nreturn 'START_BSLASH';\ncase 26:\nreturn 'START_ERROR';\n}\nreturn ('S<' + T(type)) + '>';\n}\n// </lexer>\n\n// <parser>\nlet ASSERT_ASI_REGEX_NEXT = false;\nfunction sansFlag(flags, flag) {\nreturn (flags | flag) ^ flag;\n}\nfunction hasAllFlags(flags1, flags2) {\nreturn (flags1 & flags2) === flags2;\n}\nfunction hasAnyFlag(flags1, flags2) {\nreturn (flags1 & flags2) !== 0;\n}\nfunction hasNoFlag(flags, flag) {\nreturn (flags & flag) === 0;\n}\nfunction Parser(code, options = {}) {\nlet {goalMode:options_goalMode = false, collectTokens:options_collectTokens = 0, webCompat:options_webCompat = true, strictMode:options_strictMode = false, astRoot:options_astRoot = null, tokenStorage:options_tokenStorage, getLexer = null, allowGlobalReturn = false, targetEsVersion = Infinity, exposeScopes:options_exposeScopes = false, astUids = false, ranges:options_ranges = false, templateNewlineNormalization = true, errorCodeFrame = true, truncCodeFrame = true, $log = console.log, $warn = console.warn, $error = console.error, sourceField = '', babelCompat = false, babelTokenCompat = false, acornCompat = false, AST_directiveNodes = false} = options;\nlet goalMode = false;\nif ((typeof options_goalMode) === 'string') {\nif (options_goalMode === 'module') goalMode = true; else if (options_goalMode === 'script') goalMode = false; else return THROW_RANGE(('Unknown goal symbol value: `' + options_goalMode) + '`', tok_getStart(), tok_getStop());\n} else {\ngoalMode = options_goalMode;\n}\nlet collectTokens = 0;\nif ((typeof options_collectTokens) === 'string') {\nif (options_collectTokens === 'all') collectTokens = 2; else if (options_collectTokens === 'solid') collectTokens = 1; else if (options_collectTokens === 'none') collectTokens = 0; else if (options_collectTokens === 'types') collectTokens = 3; else return THROW_RANGE(('Unknown collectTokens value: `' + options_collectTokens) + '`', tok_getStart(), tok_getStop());\n} else {\ncollectTokens = options_collectTokens;\n}\nlet NODE_NAME_PROPERTY = (babelCompat? 'ObjectProperty' : 'Property');\nlet NODE_NAME_METHOD_OBJECT = (babelCompat? 'ObjectMethod' : 'Property');\nlet NODE_NAME_METHOD_CLASS = (babelCompat? 'ClassMethod' : 'MethodDefinition');\nlet tok = Lexer(code, {targetEsVersion, parsingGoal:goalMode, collectTokens, returnTokens:(babelCompat? 2 : 3), webCompat:options_webCompat, gracefulErrors:false, tokenStorage:options_tokenStorage, babelTokenCompat, errorCodeFrame, truncCodeFrame, $log, $warn, $error});\nlet tok_throw = tok.throw;\nlet tok_lexError = tok.lexError;\nlet tok_asi = tok.asi;\nlet tok_prevEndColumn = tok.prevEndColumn;\nlet tok_prevEndLine = tok.prevEndLine;\nlet tok_prevEndPointer = tok.prevEndPointer;\nlet tok_currColumn = tok.currColumn;\nlet tok_currLine = tok.currLine;\nlet tok_currPointer = tok.currPointer;\nlet tok_nextToken = tok.nextToken;\nlet tok_getNlwas = tok.getNlwas;\nlet tok_getCanoN = tok.getCanoN;\nlet tok_getType = tok.getType;\nlet tok_getStart = tok.getStart;\nlet tok_getStop = tok.getStop;\nlet tok_getLine = tok.getLine;\nlet tok_getColumn = tok.getColumn;\nlet tok_sliceInput = tok.sliceInput;\nlet assertExpectedFail = '';\nlet $tp_assertExpected_start = tok_getStart();\nlet $tp_assertExpected_stop = tok_getStop();\nlet allowExponentiation = ((targetEsVersion >= 7) || (targetEsVersion === Infinity));\nlet allowTrailingFunctionComma = ((targetEsVersion >= 8) || (targetEsVersion === Infinity));\nlet allowAsyncFunctions = ((targetEsVersion >= 8) || (targetEsVersion === Infinity));\nlet allowAsyncGenerators = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nlet allowBadEscapesInTaggedTemplates = ((targetEsVersion >= 9) || (targetEsVersion === Infinity));\nlet allowOptionalCatchBinding = ((targetEsVersion >= 10) || (targetEsVersion === Infinity));\nlet allowDynamicImport = ((targetEsVersion >= 11) || (targetEsVersion === Infinity));\nlet allowExportStarAs = ((targetEsVersion >= 11) || (targetEsVersion === Infinity));\nif (getLexer) getLexer(tok);\nfunction THROW_RANGE(desc, tokenStart, tokenStop, ...args) {\nif (arguments.length < 3) throw new Error('Expecting 3 args for THROW_RANGE, received ' + arguments.length);\nif (tokenStart > tokenStop) throw new Error(((('range should be >=0, was [' + tokenStart) + ', ') + tokenStop) + ']');\n$log('\\n');\n$log('Error in parser:', desc, 'remaining throw args;', args);\nlet fullErrmsg = ('Parser error! ' + desc) + (((tok_getType() === 2097173)? ' (at EOF)' : ''));\ntok_throw(fullErrmsg, tokenStart, tokenStop, '');\n}\nlet uid_counter = 0;\nlet _tree = {type:'Program', loc:undefined, body:[]};\nif (babelCompat) {\n_tree = {type:'Program', loc:undefined, body:[], sourceType:((goalMode === false)? 'script' : 'module'), interpreter:null};\n}\nif (acornCompat) {\n_tree = {type:'Program', loc:undefined, body:[], sourceType:((goalMode === false)? 'script' : 'module')};\n}\nlet _path = [_tree];\nlet _pnames;\nif (options_astRoot) {\noptions_astRoot.root = _tree;\noptions_astRoot.path = _path;\n}\nfunction AST_getClosedLoc($tp_first_start, $tp_first_line, $tp_first_column) {\nreturn AST_getCloseLoc($tp_first_start, $tp_first_line, $tp_first_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn());\n}\nfunction AST_getCloseLoc(startIndex, startLine, startColumn, endIndex, endLine, endColumn) {\nif (options_ranges) {\nreturn {start:{line:startLine | 0, column:startColumn | 0}, end:{line:endLine | 0, column:endColumn | 0}, range:{start:startIndex | 0, end:endIndex | 0}, source:sourceField};\n}\nreturn {start:{line:startLine, column:startColumn}, end:{line:endLine, column:endColumn}, source:sourceField};\n}\nfunction AST_open(prop, newNode) {\nAST_setNode(prop, newNode);\n_path[_path.length] = newNode;\n}\nfunction AST_close($tp_open_start, $tp_open_line, $tp_open_column) {\nAST_set('loc', AST_getCloseLoc($tp_open_start, $tp_open_line, $tp_open_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()));\n_path.pop();\n}\nfunction AST_closeTemplateElement(isTemplateDouble, $tp_tick_start, $tp_tick_line, $tp_tick_column) {\nlet colEnd = tok_prevEndColumn() - 1;\nlet pointerEnd = tok_prevEndPointer();\nif (isTemplateDouble) {\n--colEnd;\n--pointerEnd;\n}\nAST_set('loc', AST_getCloseLoc($tp_tick_start, $tp_tick_line, $tp_tick_column, pointerEnd, tok_prevEndLine(), colEnd));\n_path.pop();\n}\nfunction AST_set(prop, value) {\n_path[_path.length - 1][prop] = value;\n}\nfunction AST_setNode(astProp, node) {\nif (astUids) node.$uid = uid_counter++;\nlet parentNode = _path[_path.length - 1];\nlet p = parentNode[astProp];\nif (Array.isArray(p)) {\np[p.length] = node;\n} else {\nparentNode[astProp] = node;\n}\n}\nfunction AST_setNodeDangerously(astProp, node) {\nif (astUids) node.$uid = uid_counter++;\nlet parentNode = _path[_path.length - 1];\nlet p = parentNode[astProp];\nif (Array.isArray(p)) {\np[p.length] = node;\n} else {\nparentNode[astProp] = node;\n}\n}\nfunction AST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon) {\nlet identNode = AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nAST_setNode(astProp, identNode);\n}\nfunction AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon) {\nlet col = $tp_ident_column;\nlet line = $tp_ident_line;\nlet len = $tp_ident_stop - $tp_ident_start;\nlet colEnd = col + len;\nlet identNode = {type:'Identifier', loc:AST_getCloseLoc($tp_ident_start, line, col, $tp_ident_stop, line, colEnd), name:$tp_ident_canon};\nif (babelCompat) identNode.loc.identifierName = $tp_ident_canon;\nreturn identNode;\n}\nfunction AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon) {\n_AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, false);\n}\nfunction _AST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, fromDirective) {\nif (isStringToken($tp_lit_type)) {\nAST_setStringLiteral(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon, fromDirective);\n} else if (isNumberToken($tp_lit_type)) {\nif (isBigintToken($tp_lit_type)) {\nAST_setBigInt(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n} else {\nAST_setNumberLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n}\n} else {\nAST_setRegexLiteral(astProp, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column);\n}\n}\nfunction AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nif (babelCompat) return AST_babelGetStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective);\nlet node = {type:'Literal', loc:AST_getCloseLoc($tp_string_start, $tp_string_line, $tp_string_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()), value:$tp_string_canon, raw:tok_sliceInput($tp_string_start, $tp_string_stop)};\nreturn node;\n}\nfunction AST_setStringLiteral(astProp, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nlet stringNode = AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective);\nAST_setNode(astProp, stringNode);\n}\nfunction AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nif (isBigintToken($tp_number_type)) return AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nif (babelCompat) return AST_babelGetNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet value = (($tp_number_type === 4105)? parseFloat(str) : ((($tp_number_type === 4104)? parseInt(str.slice(2), 16) : ((($tp_number_type === 4106)? parseInt(str.slice(2), 2) : ((($tp_number_type === 4107)? parseInt(str.slice(2), 8) : ((((str.includes('8') || str.includes('9')))? parseFloat(str.slice(1)) : parseInt(str.slice(1), 8))))))))));\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:value, raw:str};\n}\nfunction AST_setNumberLiteral(astProp, $tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet numberNode = AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nAST_setNode(astProp, numberNode);\n}\nfunction AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nif (acornCompat) return AST_acornGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nif (babelCompat) return AST_babelGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nreturn {type:'BigIntLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:null, bigint:tok_sliceInput($tp_number_start, $tp_number_stop - 1)};\n}\nfunction AST_setBigInt(astProp, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet bigintNode = AST_getBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column);\nAST_setNode(astProp, bigintNode);\n}\nfunction AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nif (acornCompat) return AST_acornGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nif (babelCompat) return AST_babelGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), value:null, regex:{pattern:body, flags:tail}, raw:str};\n}\nfunction AST_setRegexLiteral(astProp, $tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet regexNode = AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column);\nAST_setNode(astProp, regexNode);\n}\nfunction AST_add(prop, value) {\nlet arr = _path[_path.length - 1][prop];\narr[arr.length] = value;\n}\nfunction AST_popNode(prop) {\nlet parent = _path[_path.length - 1];\nlet p = parent[prop];\nif (Array.isArray(p)) {\nreturn p.pop();\n} else {\nreturn p;\n}\n}\nfunction AST_wrapClosedCustom(prop, newNode, newProp) {\nlet child = AST_popNode(prop);\nAST_open(prop, newNode);\nAST_set(newProp, child);\n}\nfunction AST_wrapClosedIntoArrayCustom(prop, newNode, newProp) {\nlet child = AST_popNode(prop);\nAST_open(prop, newNode);\nAST_set(newProp, [child]);\n}\nfunction AST_destruct(prop) {\nlet parent = _path[_path.length - 1];\nlet node = parent[prop];\nif (Array.isArray(node)) {\nlet last = node.length - 1;\nAST__destruct(node[last], node, last);\nreturn;\n}\nAST__destruct(node, parent, prop);\n}\nfunction AST__destruct(node, parent, astProp) {\nswitch (node.type) {\ncase 'ArrayExpression':\nnode.type = 'ArrayPattern';\nlet elements = node.elements;\nlet e = elements.length;\nfor (let i = 0;i < e;++i) {\nlet element = elements[i];\nif (element) AST__destruct(element, elements, i);\n}\nreturn;\ncase 'ObjectExpression':\nnode.type = 'ObjectPattern';\nlet properties = node.properties;\nlet n = properties.length;\nfor (let i = 0;i < n;++i) {\nif (properties[i].type === NODE_NAME_PROPERTY) {\n\n} else {\n\n}\nAST__destruct(properties[i], properties, i);\n}\nreturn;\ncase 'AssignmentExpression':\nAST__destruct(node.left, node, 'left');\nAST_destructReplaceAssignment(parent, astProp);\nreturn;\ncase NODE_NAME_PROPERTY:\nAST__destruct(node.value, node, 'value');\nreturn;\ncase 'SpreadElement':\nnode.type = 'RestElement';\nAST__destruct(node.argument, node, 'argument');\nreturn;\n}\n}\nfunction AST_destructReplaceAssignment(parentNode, prop) {\nlet oldNode = parentNode[prop];\nif (oldNode.operator !== '=') {\nreturn THROW_RANGE('The destructuring assignment should be a regular assignment', tok_getStart(), tok_getStop());\n}\nlet newNode = {type:'AssignmentPattern', loc:oldNode.loc, left:oldNode.left, right:oldNode.right};\nparentNode[prop] = newNode;\n}\nfunction AST_convertArrayToPattern($tp_eq_type, astProp) {\nif ($tp_eq_type === 49264) {\nlet node = _path[_path.length - 1][astProp];\nif (Array.isArray(node)) {\nnode = node[node.length - 1];\n}\nif (((node.type === 'ArrayExpression') || (node.type === 'ObjectExpression'))) {\nAST_destruct(astProp);\n}\n}\n}\nfunction AST_throwIfIllegalUpdateArg(astProp) {\nlet head = _path[_path.length - 1];\nlet prev = (head && head[astProp]);\nif (((!prev) || (((prev instanceof Array)? (((!prev.length) || (((prev[prev.length - 1].type !== 'Identifier') && (prev[prev.length - 1].type !== 'MemberExpression'))))) : (((prev.type !== 'Identifier') && (prev.type !== 'MemberExpression'))))))) {\nreturn THROW_RANGE('Can only increment or decrement an identifier or member expression', tok_getStart(), tok_getStop());\n}\n}\nfunction AST_patchAsyncCall($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, astProp) {\nlet node = _path[_path.length - 1];\nlet args = node[astProp];\nif (args instanceof Array) args = args[0];\nif (args.type === 'SequenceExpression') args = args.expressions; else args = [args];\nif (node[astProp] instanceof Array) node[astProp] = []; else node[astProp] = undefined;\nAST_setNode(astProp, {type:'CallExpression', loc:AST_getClosedLoc($tp_async_start, $tp_async_line, $tp_async_column), callee:AST_getIdentNode($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon), arguments:args});\n}\nfunction AST_babelDirectives() {\nlet node = _path[_path.length - 1];\nlet dirs = [];\nAST_set('directives', dirs);\nwhile ((node.body.length && (node.body[0].directive !== undefined))) {\nlet dir = node.body.shift();\ndirs[dirs.length] = {type:'Directive', loc:dir.loc, value:dir.expression};\ndir.expression.type = 'DirectiveLiteral';\n}\n}\nfunction AST_babelParenthesizesClosed($tp_parenOpen_start, astProp) {\nlet parent = _path[_path.length - 1];\nlet child = parent[astProp];\nif (Array.isArray(child)) {\nchild = child[child.length - 1];\n}\nif (child.extra) {\nchild.extra.parenthesized = true;\nchild.extra.parenStart = $tp_parenOpen_start;\n} else {\nchild.extra = {parenthesized:true, parenStart:$tp_parenOpen_start};\n}\n}\nfunction AST_babelAddComment($tp_comment_start, $tp_comment_stop, $tp_comment_line, $tp_comment_column, $tp_comment_type) {\nif (!_path[_path.length - 1].innerComments) _path[_path.length - 1].innerComments = [];\nlet str = tok_sliceInput($tp_comment_start, $tp_comment_stop);\nlet typeName = 'CommentLine';\nlet value = '';\nif ($tp_comment_type === 1285) {\nvalue = tok_sliceInput($tp_comment_start + 2, $tp_comment_stop);\n} else if ($tp_comment_type === 1286) {\ntypeName = 'CommentBlock';\nvalue = tok_sliceInput($tp_comment_start + 2, $tp_comment_stop - 2);\n} else {\nvalue = ((str.slice(0, 3) === '-->')? tok_sliceInput($tp_comment_start + 3, $tp_comment_stop) : tok_sliceInput($tp_comment_start + 4, $tp_comment_stop));\n}\nlet commentNode = {type:typeName, loc:AST_getCloseLoc($tp_comment_start, $tp_comment_line, $tp_comment_column, tok_currPointer(), tok_currLine(), tok_currColumn()), value:value};\nAST_setNode('innerComments', commentNode);\nreturn commentNode;\n}\nfunction AST_babelGetStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, fromDirective) {\nlet str = tok_sliceInput($tp_string_start, $tp_string_stop);\nlet value = (fromDirective? str.slice(1, -1) : $tp_string_canon);\nreturn {type:'StringLiteral', loc:AST_getCloseLoc($tp_string_start, $tp_string_line, $tp_string_column, tok_prevEndPointer(), tok_prevEndLine(), tok_prevEndColumn()), value:value, extra:{rawValue:value, raw:str}};\n}\nfunction AST_babelGetNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet value = (($tp_number_type === 4105)? parseFloat(str) : ((($tp_number_type === 4104)? parseInt(str.slice(2), 16) : ((($tp_number_type === 4106)? parseInt(str.slice(2), 2) : ((($tp_number_type === 4107)? parseInt(str.slice(2), 8) : ((((str.includes('8') || str.includes('9')))? parseFloat(str.slice(1)) : parseInt(str.slice(1), 8))))))))));\nreturn {type:'NumericLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:value, extra:{rawValue:value, raw:str}};\n}\nfunction AST_babelGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet str = tok_sliceInput($tp_number_start, $tp_number_stop - 1);\nreturn {type:'BigIntLiteral', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), value:str, extra:{rawValue:str, raw:str + 'n'}};\n}\nfunction AST_babelGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'RegExpLiteral', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), pattern:body, flags:tail, extra:{rawValue:undefined, raw:str}, value:undefined};\n}\nfunction AST_acornGetBigIntNode($tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column) {\nlet strn = tok_sliceInput($tp_number_start, $tp_number_stop);\nlet str = strn.slice(0, -1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_number_start, $tp_number_line, $tp_number_column, $tp_number_stop, $tp_number_line, $tp_number_column + ($tp_number_stop - $tp_number_start)), raw:strn, bigint:str, value:BigInt(str)};\n}\nfunction AST_acornGetRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column) {\nlet str = tok_sliceInput($tp_regex_start, $tp_regex_stop);\nlet pos = str.lastIndexOf('/');\nlet body = str.slice(1, pos);\nlet tail = str.slice(pos + 1);\nreturn {type:'Literal', loc:AST_getCloseLoc($tp_regex_start, $tp_regex_line, $tp_regex_column, $tp_regex_stop, $tp_regex_line, $tp_regex_column + ($tp_regex_stop - $tp_regex_start)), value:new RegExp(body, tail), regex:{pattern:body, flags:tail}, raw:str};\n}\nfunction initLexer(lexerFlags) {\nskipToStatementStart(lexerFlags);\n}\nfunction skipRex(lexerFlags) {\n_skip(lexerFlags | 4);\n}\nfunction skipDiv(lexerFlags) {\n_skip(lexerFlags);\n}\nfunction skipAny(lexerFlags) {\n_skip(lexerFlags);\n}\nfunction _skip(lexerFlags) {\ntok_nextToken(lexerFlags);\nif (tok_getType() === 2097175) {\nreturn tok_lexError();\n}\nif (!babelCompat) return;\nlet $tp_maybeComment_type = tok_getType();\nlet $tp_maybeComment_line = tok_getLine();\nlet $tp_maybeComment_column = tok_getColumn();\nlet $tp_maybeComment_start = tok_getStart();\nlet $tp_maybeComment_stop = tok_getStop();\nwhile (isCommentToken($tp_maybeComment_type)) {\ntok_nextToken(lexerFlags);\nif (tok_getType() === 2097175) {\nreturn tok_lexError();\n}\nAST_babelAddComment($tp_maybeComment_start, $tp_maybeComment_stop, $tp_maybeComment_line, $tp_maybeComment_column, $tp_maybeComment_type);\n$tp_maybeComment_type = tok_getType();\n$tp_maybeComment_line = tok_getLine();\n$tp_maybeComment_column = tok_getColumn();\n$tp_maybeComment_start = tok_getStart();\n$tp_maybeComment_stop = tok_getStop();\n}\n}\nfunction skipToParenOpenOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToCurlyOpenOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Expected to parse an opening curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToFromOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Next token should be the ident `from` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToStringOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (!isStringToken(tok_getType())) {\nreturn THROW_RANGE(('Next token should be a string but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToIdentOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (!isIdentToken(tok_getType())) {\nreturn THROW_RANGE(('Next token should be an ident but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToArrowOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16499) {\nreturn THROW_RANGE(('Next token should be `=>` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToAsCommaCurlyClose(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToAsCommaFrom(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToColonOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 16489) {\nreturn THROW_RANGE(('Next token should be `:` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToTargetOrDie(lexerFlags) {\nskipAny(lexerFlags);\nif (tok_getType() !== 2116) {\nreturn THROW_RANGE(('Next token should be `target` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\n}\nfunction skipToStatementStart(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStart(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartGrouped(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartSemi(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToExpressionStartSquareCloseComma(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToAfterNew(lexerFlags) {\nskipRex(lexerFlags);\n}\nfunction skipToSwitchBody(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToBindingStart(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToBindingStartGrouped(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToColonParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarCurlyOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentCurlyOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentCurlyClose(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStarCurlyOpenParenOpenString(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToAwaitParenOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipToIdentStringNumberSquareOpen(lexerFlags) {\nskipAny(lexerFlags);\n}\nfunction skipIdentSafeSlowAndExpensive(lexerFlags, leftHandSideExpression) {\nswitch (tok_getType()) {\ncase 2084:\n\ncase 2121:\n\ncase 2123:\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('A unary expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nreturn;\ncase 2104:\nskipToAfterNew(lexerFlags);\nreturn;\ncase 2075:\nif (((goalMode === true) || ((lexerFlags & 8) !== 0))) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An `await` expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\nreturn 0;\ncase 2126:\nif ((lexerFlags & 8320) !== 0) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('A `yield` expression is not allowed here', tok_getStart(), tok_getStop());\n}\nskipRex(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\nreturn;\n}\nskipDiv(lexerFlags);\n}\nfunction parseTopLevels(lexerFlags) {\nlet scoop = SCOPE_createGlobal('_parseTopLevels');\nif (options_exposeScopes) AST_set('$scope', scoop);\nlet exportedNames = new Set();\nlet exportedBindings = new Set();\nlet len;\nlet bak;\nparseBodyPartsWithDirectives(lexerFlags, scoop, exportedNames, exportedBindings, 1, 0, 0, 0, 0, 0, '', true, 'body');\nif (goalMode === true) {\nlet globalNames = scoop.names;\nexportedBindings.forEach(name => {\nif (((name !== 'default') && (((globalNames === null) || (!globalNames.has(name)))))) {\nreturn THROW_RANGE(('Exporting a name that was not bound in global: `' + name) + '`', tok_getStart(), tok_getStop());\n}\n});\n}\n}\nfunction SCOPE_createGlobal(desc) {\nlet scoop = {parent:null, type:0, names:null, dupeParamErrorStart:0, dupeParamErrorStop:0};\nif (astUids) scoop.$uid = uid_counter++;\nreturn scoop;\n}\nfunction SCOPE_addLayer(scoop, scopeType, desc) {\nlet scoopNew = {parent:scoop, type:scopeType, names:null, dupeParamErrorStart:0, dupeParamErrorStop:0};\nreturn scoopNew;\n}\nfunction SCOPE_addFuncDeclName(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState) {\nif (bindingType === 3) {\nSCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType);\n} else {\nSCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState);\n}\n}\nfunction SCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType) {\nif (bindingType === 2) {\nSCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType);\n} else {\nSCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, 1);\n}\n}\nfunction SCOPE_addVarBinding(lexerFlags, scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType) {\nlet currScoop = scoop;\ndo {\nif (currScoop.names === null) {\ncurrScoop.names = new Map();\n} else if (currScoop.names.has($tp_bindingIdent_canon)) {\nlet bindingType = currScoop.names.get($tp_bindingIdent_canon);\nverifyDuplicateVarBinding(lexerFlags, bindingType, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon);\n}\ncurrScoop.names.set($tp_bindingIdent_canon, bindingType);\ncurrScoop = currScoop.parent;\n} while ((currScoop && (currScoop.type !== 9)));\n}\nfunction verifyDuplicateVarBinding(lexerFlags, value, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon) {\nswitch (value) {\ncase 0:\n\ncase 1:\n\ncase 2:\n\ncase 3:\n\ncase 4:\nreturn;\ncase 5:\n\ncase 6:\n\ncase 7:\n\ncase 8:\nreturn THROW_RANGE('Found a var binding that is duplicate of a lexical binding on the same or lower statement level', $tp_bindingIdent_start, $tp_bindingIdent_stop);\ncase 10:\nreturn THROW_RANGE(('Can not create a binding for `' + $tp_bindingIdent_canon) + '` because was already bound as a catch clause pattern binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\ncase 9:\nif (options_webCompat === false) {\nreturn THROW_RANGE(('Can not create a binding for `' + $tp_bindingIdent_canon) + '` because was already bound as a catch clause binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\nreturn;\n}\n}\nfunction SCOPE_addLexBinding(scoop, $tp_bindingIdent_start, $tp_bindingIdent_stop, $tp_bindingIdent_canon, bindingType, fdState) {\nif (scoop === null) {\nreturn;\n}\nlet value = ((((scoop.names === null) || (!scoop.names.has($tp_bindingIdent_canon))))? 0 : scoop.names.get($tp_bindingIdent_canon));\nif (value !== 0) {\nif (bindingType === 1) {\nscoop.dupeParamErrorStart = $tp_bindingIdent_start + 1;\nscoop.dupeParamErrorStop = $tp_bindingIdent_stop;\n} else if (((((options_webCompat !== true) || (value !== 5))) || (fdState !== 3))) {\nreturn THROW_RANGE(('Attempted to create a lexical binding for `' + $tp_bindingIdent_canon) + '` but another binding already existed on the same level', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n} else {\n\n}\n}\nif (((((scoop.type === 10) && (scoop.parent.names !== null))) && scoop.parent.names.has($tp_bindingIdent_canon))) {\nreturn THROW_RANGE(('Cannot create lexical binding for `' + $tp_bindingIdent_canon) + '` because it shadows a function parameter', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\nif (((((scoop.type === 11) && (value !== 0))) && (bindingType === 1))) {\nscoop.dupeParamErrorStart = $tp_bindingIdent_start + 1;\nscoop.dupeParamErrorStop = $tp_bindingIdent_stop;\n}\nif (scoop.type === 6) {\nlet parentValue = ((((scoop.parent.names === null) || (!scoop.parent.names.has($tp_bindingIdent_canon))))? 0 : scoop.parent.names.get($tp_bindingIdent_canon));\nif (((parentValue === 9) || (parentValue === 10))) {\nreturn THROW_RANGE(('Can not create a lexical binding for `' + $tp_bindingIdent_canon) + '` because it shadows a catch clause binding', $tp_bindingIdent_start, $tp_bindingIdent_stop);\n}\n}\nif (scoop.names === null) scoop.names = new Map();\nscoop.names.set($tp_bindingIdent_canon, bindingType);\n}\nfunction parseDirectivePrologues(lexerFlags, astProp) {\nlet hadUseStrict = false;\nlet isStrict = (lexerFlags & 8192) === 8192;\nlet hadOctal = false;\nwhile (isStringToken(tok_getType())) {\nlet $tp_string_type = tok_getType();\nlet $tp_string_line = tok_getLine();\nlet $tp_string_column = tok_getColumn();\nlet $tp_string_start = tok_getStart();\nlet $tp_string_stop = tok_getStop();\nlet $tp_string_canon = tok_getCanoN();\nskipDiv(lexerFlags);\n_AST_setLiteral(astProp, $tp_string_type, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, true);\nlet $tp_next_start = tok_getStart();\nif (tok_getType() !== 16490) {\nparseExpressionAfterLiteral(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, astProp);\nif (tok_getType() !== 16490) {\nparseExpressionFromOp(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, 16, astProp);\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_string_start, $tp_string_line, $tp_string_column, 16, astProp);\n}\n}\n}\nif (tok_getStart() === $tp_next_start) {\nlet dir = tok_sliceInput($tp_string_start + 1, $tp_string_stop - 1);\nif (((!isStrict) && /(^|[^\\\\])(\\\\\\\\)*\\\\(?:0\\d|[1-9])/.test(dir))) {\nhadOctal = true;\n}\nif (dir === 'use strict') {\nhadUseStrict = true;\nlexerFlags = lexerFlags | 8192;\nif (!isStrict) {\nif (tok_getType() === 4108) {\nreturn THROW_RANGE('Illegal legacy octal literal in strict mode', tok_getStart(), tok_getStop());\n}\nif (((!hadOctal) && /(^|[^\\\\])(\\\\\\\\)*\\\\(?:0\\d|[1-9])/.test(tok_sliceInput(tok_getStart(), tok_getStop())))) {\nreturn THROW_RANGE('Octal in directive with strict mode directive or in strict mode is always illegal', tok_getStart(), tok_getStop());\n}\n}\nisStrict = true;\n}\nif ((AST_directiveNodes && (!babelCompat))) {\nAST_setNodeDangerously(astProp, {type:'Directive', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), directive:dir});\nparseSemiOrAsi(lexerFlags);\n} else {\nparseSemiOrAsi(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'ExpressionStatement', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), expression:AST_popNode(astProp), directive:dir});\n}\n} else {\nparseSemiOrAsi(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'ExpressionStatement', loc:AST_getClosedLoc($tp_string_start, $tp_string_line, $tp_string_column), expression:AST_popNode(astProp)});\nbreak;\n}\n}\nif ((hadOctal && isStrict)) {\nreturn THROW_RANGE('Octal in directive with strict mode directive or in strict mode is always illegal', tok_getStart(), tok_getStop());\n}\nreturn hadUseStrict;\n}\nfunction parseBodyPartsWithDirectives(lexerFlags, scoop, exportedNames, exportedBindings, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isGlobalToplevel, astProp) {\nlet wasStrict = (lexerFlags & 8192) === 8192;\nlet isStrict = wasStrict;\nlet hasUseStrict = parseDirectivePrologues(lexerFlags, 'body');\nif (hasUseStrict) {\nisStrict = true;\nif (((paramsSimple === 2) || (paramsSimple === 3))) {\nreturn THROW_RANGE('Can only declare use strict if func params are \"simple\"', tok_getStart(), tok_getStop());\n}\nif (((((!wasStrict) && ($tp_functionNameToVerify_start !== 0))) && isStrictOnlyKeyword($tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon))) {\nreturn THROW_RANGE(('Can not use reserved keyword `' + $tp_functionNameToVerify_canon) + '` in strict mode as id for function that has a use strict directive', $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop);\n}\nlexerFlags |= 8192;\n}\nif (((dupeParamErrorStart !== 0) && (((paramsSimple === 3) || isStrict)))) {\nreturn THROW_RANGE('Function had duplicate params', dupeParamErrorStart - 1, dupeParamErrorStop);\n}\nwhile (((tok_getType() !== 2097173) && (tok_getType() !== 16517))) {\nparseBodyPart(lexerFlags, scoop, null, exportedNames, exportedBindings, isGlobalToplevel, false, 4, null, astProp);\n}\nif (babelCompat) AST_babelDirectives();\n}\nfunction wrapLabelSet(labelSet, desc) {\nlet set = {parentLabels:labelSet, statementLabels:new Set(), iterationLabels:null};\nreturn set;\n}\nfunction parseStatementHeader(lexerFlags, headProp) {\nlet $tp_openParan_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nparseExpressions(((lexerFlags | 4096) | 1792) ^ 1792, headProp);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren of statement header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', $tp_openParan_start, tok_getStop());\n}\nskipToStatementStart(lexerFlags);\n}\nfunction parseSemiOrAsi(lexerFlags) {\nif (tok_getType() === 16490) {\nskipToStatementStart(lexerFlags);\nreturn;\n}\nif (((((tok_getType() === 16517) || (tok_getNlwas() === true))) || (tok_getType() === 2097173))) {\ntok_asi();\n} else {\n$log('parse error at curent token');\nreturn THROW_RANGE('Unable to ASI', tok_getStart(), tok_getStop());\n}\n}\nfunction parseNestedBodyPart(lexerFlags, scoop, labelSet, isLabelled, fdState, nestedLabels, astProp) {\nparseBodyPart(lexerFlags, scoop, labelSet, undefined, undefined, false, isLabelled, fdState, nestedLabels, astProp);\n}\nfunction parseBodyPart(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp) {\nif (isIdentToken(tok_getType())) {\nparseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp);\nreturn;\n}\nif (isPunctuatorToken(tok_getType())) {\nparsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\n}\nif (isNumberToken(tok_getType())) {\nparseFromNumberStatement(lexerFlags, astProp);\nreturn;\n}\nif (isStringToken(tok_getType())) {\nparseFromStringStatement(lexerFlags, astProp);\nreturn;\n}\nif (isTickToken(tok_getType())) {\nparseTickStatement(lexerFlags, astProp);\nreturn;\n}\nif (isRegexToken(tok_getType())) {\nparseFromRegexStatement(lexerFlags, astProp);\nreturn;\n}\nTHROW_RANGE('Unexpected EOF', tok_getStart(), tok_getStop());\n}\nfunction parseFunctionDeclaration(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, $tp_async_type, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, $tp_funcHead_start, $tp_funcHead_stop, optionalIdent, isLabelled, fdState, astProp) {\nskipToIdentStarParenOpen(lexerFlags);\nlet $tp_star_type = 0;\nif (tok_getType() === 82009) {\n$tp_star_type = 82009;\n$tp_funcHead_stop = tok_getStop();\nskipToIdentParenOpen(lexerFlags);\nif ((($tp_async_type === 2074) && (!allowAsyncGenerators))) {\nreturn THROW_RANGE('Async generators are not supported by the currently targeted language version, they were introduced in ES9/ES2018', $tp_funcHead_start, $tp_funcHead_stop);\n}\n}\nif (isLabelled === true) {\nif (fdState === 1) {\nreturn THROW_RANGE('A \"labelled function declaration\" is not allowed in this situation', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('A \"labelled function declaration\" can not be async', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('A \"labelled function declaration\" can not be a generator', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif (((options_webCompat === false) || ((lexerFlags & 8192) === 8192))) {\nreturn THROW_RANGE('A \"labelled function declaration\" is only allowed in sloppy web compat mode', $tp_funcHead_start, $tp_funcHead_stop);\n}\n} else if (fdState === 2) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('An async function declaration in web compat mode is still not allowed as `if-else` child, only plain func decls are allowed there', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('A generator function declaration in web compat mode is still not allowed as `if-else` child, only plain func decls are allowed there', $tp_funcHead_start, $tp_funcHead_stop);\n}\nif (((options_webCompat === false) || ((lexerFlags & 8192) === 8192))) {\nreturn THROW_RANGE('A function declaration can only be the child of an `if`/`else` in sloppy web compat mode', $tp_funcHead_start, $tp_funcHead_stop);\n}\nscoop = SCOPE_addLayer(scoop, 12, 'special \"fake-block\" function statement for label');\n} else if (((isFuncDecl === true) && (fdState === 1))) {\nreturn THROW_RANGE('Cannot parse a function declaration here, only expecting statements here', $tp_funcHead_start, $tp_funcHead_stop);\n}\nreturn parseFunctionAfterKeyword(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, optionalIdent, false, false, $tp_async_type, $tp_star_type, 0, 0, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, fdState, astProp);\n}\nfunction parseFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp) {\nif (tok_getType() === 82009) {\nreturn parseGeneratorFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp);\n}\nparseFunctionAfterKeyword(lexerFlags, null, false, true, false, false, false, 0, 0, 0, 0, $tp_function_start, $tp_function_line, $tp_function_column, 1, astProp);\n}\nfunction parseGeneratorFunctionExpression(lexerFlags, $tp_function_start, $tp_function_line, $tp_function_column, astProp) {\nskipToIdentParenOpen(lexerFlags);\nparseFunctionAfterKeyword(lexerFlags, null, false, true, false, false, false, 0, 82009, 0, 0, $tp_function_start, $tp_function_line, $tp_function_column, 1, astProp);\n}\nfunction parseAsyncFunctionDecl(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, fromStmtOrExpr, scoop, isExport, exportedBindings, isLabelled, fdState, astProp) {\nlet $tp_function_stop = tok_getStop();\nlet canonName = parseFunctionDeclaration(lexerFlags, scoop, ((fromStmtOrExpr === 1)? false : true), ((fromStmtOrExpr === 1)? true : false), 2074, $tp_async_start, $tp_async_line, $tp_async_column, $tp_async_start, $tp_function_stop, ((((isExport === true) || (fromStmtOrExpr === 1)))? true : false), isLabelled, fdState, astProp);\nif (isExport === true) {\naddBindingToExports(exportedBindings, canonName);\n}\nreturn 16;\n}\nfunction parseFunctionAfterKeyword(lexerFlags, outerScoop, isFuncDecl, isRealFuncExpr, optionalIdent, isClassConstructor, isMethod, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_astRange_start, $tp_astRange_line, $tp_astRange_column, fdState, astProp) {\nif ((babelCompat && (isMethod !== false))) {\nAST_set('generator', $tp_star_type === 82009);\nAST_set('async', $tp_async_type === 2074);\n} else if (acornCompat) {\nif (allowAsyncFunctions) {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, async:$tp_async_type === 2074, expression:false, id:undefined, params:[], body:undefined});\n} else {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, expression:false, id:undefined, params:[], body:undefined});\n}\n} else {\nAST_open(astProp, {type:((isFuncDecl === true)? 'FunctionDeclaration' : 'FunctionExpression'), loc:undefined, generator:$tp_star_type === 82009, async:$tp_async_type === 2074, id:undefined, params:[], body:undefined});\n}\nlet innerScoop = SCOPE_createGlobal('parseFunctionAfterKeyword_main_func_scope');\nlet $tp_functionNameToVerify_type = 0;\nlet $tp_functionNameToVerify_line = 0;\nlet $tp_functionNameToVerify_column = 0;\nlet $tp_functionNameToVerify_start = 0;\nlet $tp_functionNameToVerify_stop = 0;\nlet $tp_functionNameToVerify_canon = '';\nlet canonName = '';\nif (isIdentToken(tok_getType())) {\n$tp_functionNameToVerify_type = tok_getType();\n$tp_functionNameToVerify_line = tok_getLine();\n$tp_functionNameToVerify_column = tok_getColumn();\n$tp_functionNameToVerify_start = tok_getStart();\n$tp_functionNameToVerify_stop = tok_getStop();\n$tp_functionNameToVerify_canon = tok_getCanoN();\nlet bindingFlags = ((lexerFlags | 136) ^ 136) | getFuncIdentAsyncGenState(isRealFuncExpr, lexerFlags, $tp_star_type, $tp_async_type);\nlet nameBindingType = ((((((isFuncDecl === true) && (fdState === 4))) && ((((lexerFlags & 256) === 0) || (goalMode === false)))))? 3 : 5);\ncanonName = $tp_functionNameToVerify_canon;\nfatalBindingIdentCheck($tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, nameBindingType, bindingFlags);\nif (isFuncDecl === true) {\nSCOPE_addFuncDeclName(lexerFlags, outerScoop, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, canonName, nameBindingType, fdState);\n}\ninnerScoop = SCOPE_addLayer(innerScoop, 9, 'parseFunctionAfterKeyword_hide_func_name');\nskipToParenOpenOrDie(lexerFlags);\nAST_setIdent('id', $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_line, $tp_functionNameToVerify_column, $tp_functionNameToVerify_canon);\n} else if (((isFuncDecl === true) && (optionalIdent === false))) {\nreturn THROW_RANGE('Function decl missing required ident', tok_getStart(), tok_getStop());\n} else {\nAST_set('id', null);\n}\nlexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, $tp_star_type, $tp_async_type, false);\nif (isClassConstructor === true) {\nlexerFlags |= 16;\n} else {\nlexerFlags = (lexerFlags | 16400) ^ 16400;\n}\nif (isMethod === true) lexerFlags |= 32768; else lexerFlags = (lexerFlags | 32768) ^ 32768;\nparseFunctionFromParams(lexerFlags, innerScoop, (($tp_async_type === 0)? 6 : 5), ((isFuncDecl === true)? 2 : 1), $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isMethod, $tp_get_type, $tp_set_type);\nif (((!babelCompat) || (isMethod === false))) {\nAST_close($tp_astRange_start, $tp_astRange_line, $tp_astRange_column);\n}\nreturn canonName;\n}\nfunction getFuncIdentGeneratorState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type) {\nif ((enclosingScopeFlags & 8192) === 8192) return 128;\nif (isRealFuncExpr === true) return (($tp_star_type === 82009)? 128 : 0);\nreturn (((enclosingScopeFlags & 128) !== 0)? 128 : 0);\n}\nfunction getFuncIdentAsyncState(isRealFuncExpr, enclosingScopeFlags, $tp_async_type) {\nif (goalMode === true) return 8;\nif (isRealFuncExpr === true) return (($tp_async_type === 2074)? 8 : 0);\nreturn (((enclosingScopeFlags & 8) !== 0)? 8 : 0);\n}\nfunction getFuncIdentAsyncGenState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type, $tp_async_type) {\nreturn getFuncIdentGeneratorState(isRealFuncExpr, enclosingScopeFlags, $tp_star_type) | getFuncIdentAsyncState(isRealFuncExpr, enclosingScopeFlags, $tp_async_type);\n}\nfunction resetLexerFlagsForFuncAndArrow(lexerFlags, $tp_star_type, $tp_async_type, funcType) {\nlexerFlags = lexerFlags & 59392;\nif ($tp_async_type === 2074) {\nlexerFlags |= 8;\n}\nif ($tp_star_type === 82009) {\nlexerFlags |= 128;\n}\nif (funcType === false) lexerFlags = lexerFlags | 2;\nreturn lexerFlags;\n}\nfunction parseFunctionFromParams(lexerFlags, scoop, bindingFrom, expressionState, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isMethod, $tp_get_type, $tp_set_type) {\nlet paramScoop = SCOPE_addLayer(scoop, 3, 'parseFunctionFromParams(arg)');\nlet paramsSimple = parseFuncArguments(lexerFlags | 4096, paramScoop, bindingFrom, $tp_get_type, $tp_set_type);\nlet dupeParamErrorStart = paramScoop.dupeParamErrorStart;\nlet dupeParamErrorStop = paramScoop.dupeParamErrorStop;\nif (((isMethod === true) && (dupeParamErrorStart !== 0))) {\nreturn THROW_RANGE('Method had duplicate params', dupeParamErrorStart - 1, dupeParamErrorStop);\n}\nlet finalFuncScope = SCOPE_addLayer(paramScoop, 10, 'parseFunctionFromParams(body)');\nif (options_exposeScopes) AST_set('$scope', finalFuncScope);\nparseFunctionBody(lexerFlags, finalFuncScope, expressionState, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, false);\n}\nfunction parseFuncArguments(lexerFlags, scoop, bindingFrom, $tp_get_type, $tp_set_type) {\nlexerFlags = lexerFlags | 64;\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE('Must have func arguments next but did not find `(`', tok_getStart(), tok_getStop());\n}\nskipToBindingStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Setters must have exactly one parameter', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\nreturn 1;\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Getters can not have any parameters', tok_getStart(), tok_getStop());\n}\nlet paramsSimple = parseBindings(lexerFlags, scoop, 1, bindingFrom, false, $tp_set_type, undefined, undefined, 'params');\nAST_destruct('params');\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing function param definition closing parenthesis, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\nreturn paramsSimple;\n}\nfunction parseFunctionBody(lexerFlags, scoop, blockType, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, isArrow) {\nlet lexerFlagsNoTemplate = (lexerFlags | 7936) ^ 7936;\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nskipToStatementStart(lexerFlagsNoTemplate);\nAST_open('body', {type:'BlockStatement', loc:undefined, body:[]});\nif (options_exposeScopes) AST_set('$scope', scoop);\nparseBodyPartsWithDirectives(lexerFlagsNoTemplate, scoop, undefined, undefined, paramsSimple, dupeParamErrorStart, dupeParamErrorStop, $tp_functionNameToVerify_type, $tp_functionNameToVerify_start, $tp_functionNameToVerify_stop, $tp_functionNameToVerify_canon, false, 'body');\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Missing function body closing curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nif (isArrow) {\nskipRex(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nASSERT_ASI_REGEX_NEXT = true;\n}\n} else if (blockType === 1) {\nskipDiv(lexerFlags);\n} else {\nskipToStatementStart(lexerFlags);\n}\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (tok_getType() === 49264) {\nreturn THROW_RANGE('Object destructuring is not allowed at the start of statement or arrow body, must wrap the object in parenthesis for that to work', tok_getStart(), tok_getStop());\n}\n}\nfunction parseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, isGlobalToplevel, isLabelled, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nswitch ($tp_ident_type) {\ncase 2074:\nskipDiv(lexerFlags);\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, 2074, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nparseAsyncStatement(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, false, undefined, isLabelled, fdState, astProp);\nreturn;\ncase 2076:\nparseBreakStatement(lexerFlags, labelSet, astProp);\nreturn;\ncase 2079:\nparseClassDeclaration(lexerFlags, scoop, false, isLabelled, fdState, astProp);\nreturn;\ncase 2080:\nparseConstStatement(lexerFlags, scoop, isLabelled, fdState, astProp);\nreturn;\ncase 2081:\nparseContinueStatement(lexerFlags, labelSet, astProp);\nreturn;\ncase 2082:\nparseDebuggerStatement(lexerFlags, astProp);\nreturn;\ncase 2085:\nparseDoStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2089:\nparseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, isGlobalToplevel, astProp);\nreturn;\ncase 2093:\nparseForStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2095:\n;\nparseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_start, $tp_ident_stop, false, isLabelled, fdState, astProp);\nreturn;\ncase 2097:\nparseIfStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2099:\nparseImportDeclaration(lexerFlags, scoop, isGlobalToplevel, astProp);\nreturn;\ncase 2103:\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nparseLetExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp);\n} else {\nparseLetDeclaration(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, scoop, labelSet, fdState, nestedLabels, astProp);\n}\nreturn;\ncase 2111:\nparseReturnStatement(lexerFlags, astProp);\nreturn;\ncase 2115:\nparseSwitchStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2118:\nparseThrowStatement(lexerFlags, astProp);\nreturn;\ncase 2120:\nparseTryStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2122:\nparseVarStatement(lexerFlags, scoop, astProp);\nreturn;\ncase 2124:\nparseWhileStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\ncase 2125:\nparseWithStatement(lexerFlags, scoop, labelSet, astProp);\nreturn;\n}\nparseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp);\n}\nfunction parseFromNumberStatement(lexerFlags, astProp) {\nlet $tp_number_type = tok_getType();\nlet $tp_number_line = tok_getLine();\nlet $tp_number_column = tok_getColumn();\nlet $tp_number_start = tok_getStart();\nlet $tp_number_stop = tok_getStop();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getNumberNode($tp_number_type, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column)});\nparseExpressionAfterLiteral(lexerFlags, $tp_number_start, $tp_number_stop, $tp_number_line, $tp_number_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_number_start, $tp_number_line, $tp_number_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_number_start, $tp_number_line, $tp_number_column);\n}\nfunction parseFromStringStatement(lexerFlags, astProp) {\nlet $tp_string_line = tok_getLine();\nlet $tp_string_column = tok_getColumn();\nlet $tp_string_start = tok_getStart();\nlet $tp_string_stop = tok_getStop();\nlet $tp_string_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getStringNode($tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, $tp_string_canon, false)});\nparseExpressionAfterLiteral(lexerFlags, $tp_string_start, $tp_string_stop, $tp_string_line, $tp_string_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_string_start, $tp_string_line, $tp_string_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_string_start, $tp_string_line, $tp_string_column);\n}\nfunction parseFromRegexStatement(lexerFlags, astProp) {\nlet $tp_regex_line = tok_getLine();\nlet $tp_regex_column = tok_getColumn();\nlet $tp_regex_start = tok_getStart();\nlet $tp_regex_stop = tok_getStop();\nskipDiv(lexerFlags);\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:AST_getRegexNode($tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column)});\nparseExpressionAfterLiteral(lexerFlags, $tp_regex_start, $tp_regex_stop, $tp_regex_line, $tp_regex_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_regex_start, $tp_regex_line, $tp_regex_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_regex_start, $tp_regex_line, $tp_regex_column);\n}\nfunction parseTickStatement(lexerFlags, astProp) {\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, 'expression');\nparseExpressionAfterLiteral(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_tick_start, $tp_tick_line, $tp_tick_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\n}\nfunction parseAsyncStatement(lexerFlags, scoop, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isExport, exportedBindings, isLabelled, fdState, astProp) {\n_parseAsync(lexerFlags, scoop, 2, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 4, isExport, true, exportedBindings, isLabelled, fdState, false, astProp);\n}\nfunction parseAsyncExpression(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, leftHandSideExpression, astProp) {\nreturn _parseAsync(lexerFlags, null, 1, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, undefined, false, 1, leftHandSideExpression, astProp);\n}\nfunction _parseAsync(lexerFlags, scoop, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, isExport, allowAssignment, exportedBindings, isLabelled, fdState, leftHandSideExpression, astProp) {\nif (!allowAsyncFunctions) {\nif (((tok_getType() === 2095) && (!tok_getNlwas()))) {\nreturn THROW_RANGE('Async functions are not supported in the currently targeted version, they are >= ES8 / ES2017', $tp_async_start, tok_getStop());\n}\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nlet newlineAfterAsync = tok_getNlwas() === true;\nlet $tp_afterAsync_type = tok_getType();\nif (isIdentToken($tp_afterAsync_type)) {\nlet $tp_ident_stop = tok_getStop();\nif (newlineAfterAsync) {\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nif ($tp_afterAsync_type === 2095) {\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An async function expression is not allowed here', $tp_async_start, $tp_ident_stop);\n}\nreturn parseAsyncFunctionDecl(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, fromStmtOrExpr, scoop, isExport, exportedBindings, isLabelled, fdState, astProp);\n}\nif ((($tp_afterAsync_type === 67636) || ($tp_afterAsync_type === 67637))) {\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot apply `new` to an (async) arrow', $tp_async_start, $tp_ident_stop);\n}\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('An async function expression is not allowed here', $tp_async_start, $tp_ident_stop);\n}\nparseParenlessArrowAfterAsync(lexerFlags, fromStmtOrExpr, allowAssignment, $tp_async_start, $tp_async_line, $tp_async_column, astProp);\nreturn 16;\n}\nif ($tp_afterAsync_type === 16471) {\nif (isNewArg === 3) {\nAST_setIdent('callee', $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon);\nreturn 32;\n}\nif (fromStmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nlet r = parseGroupToplevels(lexerFlags, fromStmtOrExpr, allowAssignment, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, (newlineAfterAsync? true : false), leftHandSideExpression, astProp);\nif (fromStmtOrExpr === 2) {\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\nreturn r;\n}\nreturn parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp);\n}\nfunction isAssignable(state) {\nreturn (state & 32) === 32;\n}\nfunction notAssignable(state) {\nreturn (state & 16) === 16;\n}\nfunction setAssignable(state) {\nreturn ((state | 32) | 16) ^ 16;\n}\nfunction setNotAssignable(state) {\nreturn ((state | 32) | 16) ^ 32;\n}\nfunction mergeAssignable(override, state) {\nreturn override | (((state | 16) | 32) ^ 48);\n}\nfunction parseAwait(lexerFlags, $tp_await_type, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_canon, isNewArg, allowAssignment, astProp) {\nif ((lexerFlags & 8) !== 0) {\nreturn parseAwaitKeyword(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, isNewArg, astProp);\n}\nif (goalMode === false) {\nreturn parseAwaitVar(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_type, $tp_await_canon, isNewArg, allowAssignment, astProp);\n}\nreturn THROW_RANGE('Cannot use `await` as var when goal=module but found `await` outside an async function', tok_getStart(), tok_getStart() + 1);\n}\nfunction parseAwaitKeyword(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, isNewArg, astProp) {\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot `await` as the arg of `new`', $tp_await_start, $tp_await_stop);\n}\nif ((lexerFlags & 64) === 64) {\nreturn THROW_RANGE('Await is illegal as default arg value', $tp_await_start, $tp_await_stop);\n}\nAST_open(astProp, {type:'AwaitExpression', loc:undefined, argument:undefined});\nparseValue(lexerFlags, false, 4, false, 'argument');\nif (tok_getType() === 82010) {\nreturn THROW_RANGE('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)', tok_getStart(), tok_getStop());\n}\nAST_close($tp_await_start, $tp_await_line, $tp_await_column);\nreturn 80;\n}\nfunction parseAwaitVar(lexerFlags, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_type, $tp_await_canon, isNewArg, allowAssignment, astProp) {\nlet assignable = parseIdentOrParenlessArrow(lexerFlags, $tp_await_type, $tp_await_start, $tp_await_stop, $tp_await_line, $tp_await_column, $tp_await_canon, 32, allowAssignment, astProp);\nassignable = parseValueTail(lexerFlags, $tp_await_start, $tp_await_line, $tp_await_column, assignable, isNewArg, false, astProp);\nreturn assignable | 64;\n}\nfunction parseBlockStatement(lexerFlags, scoop, labelSet, astProp) {\nlet lexerFlagsNoTemplate = (lexerFlags | 6144) ^ 6144;\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nskipToStatementStart(lexerFlagsNoTemplate);\nif (babelCompat) {\nAST_open(astProp, {type:'BlockStatement', loc:undefined, directives:[], body:[]});\n} else {\nAST_open(astProp, {type:'BlockStatement', loc:undefined, body:[]});\n}\nif (options_exposeScopes) AST_set('$scope', scoop);\nwhile (tok_getType() !== 16517) {\nparseNestedBodyPart(lexerFlagsNoTemplate, scoop, labelSet, false, 3, null, 'body');\n}\nskipToStatementStart(lexerFlags);\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (tok_getType() === 49264) {\nreturn THROW_RANGE('A statement can not start with object destructuring assignment (because block)', tok_getStart(), tok_getStop());\n}\n}\nfunction parseBreakStatement(lexerFlags, labelSet, astProp) {\nlet $tp_break_line = tok_getLine();\nlet $tp_break_column = tok_getColumn();\nlet $tp_break_start = tok_getStart();\nlet $tp_break_stop = tok_getStop();\nskipToStatementStart(lexerFlags);\nlet $tp_afterBreak_type = tok_getType();\nif ((isIdentToken($tp_afterBreak_type) && (tok_getNlwas() === false))) {\nlet $tp_label_line = tok_getLine();\nlet $tp_label_column = tok_getColumn();\nlet $tp_label_start = tok_getStart();\nlet $tp_label_stop = tok_getStop();\nlet $tp_label_canon = tok_getCanoN();\nfindLabelForBreak(labelSet, $tp_label_start, $tp_label_stop, $tp_label_canon);\nskipToStatementStart(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'BreakStatement', loc:AST_getClosedLoc($tp_break_start, $tp_break_line, $tp_break_column), label:AST_getIdentNode($tp_label_start, $tp_label_stop, $tp_label_line, $tp_label_column, $tp_label_canon)});\n} else if ((lexerFlags & 1536) === 0) {\nreturn THROW_RANGE('Can only `break` without label inside a `switch` or loop', $tp_break_start, $tp_break_stop);\n} else {\nif (((tok_getNlwas() === true) && isRegexToken($tp_afterBreak_type))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'BreakStatement', loc:AST_getClosedLoc($tp_break_start, $tp_break_line, $tp_break_column), label:null});\n}\n}\nfunction findLabelForBreak(inputLabelSet, $tp_label_start, $tp_label_stop, $tp_labelName_canon) {\nif (inputLabelSet === null) {\nreturn THROW_RANGE(`The label (\\`${tok_sliceInput($tp_label_start, $tp_label_stop)}\\`) for this \\`break\\` was not defined in the current label set, which is illegal`, $tp_label_start, $tp_label_stop);\n}\nlet labelSet = inputLabelSet;\nlet id = $tp_labelName_canon;\ndo {\nif (labelSet.statementLabels.has(id)) {\nreturn;\n}\n} while (labelSet = labelSet.parentLabels);\nTHROW_RANGE(('The label (`' + $tp_labelName_canon) + '`) for this `break` was not defined in the current label set, which is illegal', $tp_label_start, $tp_label_stop);\n}\nfunction validateLabelForContinue(labelSet, $tp_label_canon, $tp_label_start, $tp_label_stop) {\nif (labelSet === null) {\nreturn THROW_RANGE(('This `continue` had a label (`' + $tp_label_canon) + '`) that was not defined in the current label set as the direct parent of a loop, which would be required', $tp_label_start, $tp_label_stop);\n}\nlet set = labelSet;\ndo {\nif ((set.iterationLabels && set.iterationLabels.has($tp_label_canon))) {\nreturn;\n}\n} while (set = set.parentLabels);\nreturn THROW_RANGE(('This `continue` had a label (`' + $tp_label_canon) + '`) that was not defined in the current label set as the direct parent of a loop, which would be required', $tp_label_start, $tp_label_stop);\n}\nfunction parseConstStatement(lexerFlags, scoop, isLabelled, fdState, astProp) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nlet $tp_const_stop = tok_getStop();\nskipToBindingStart(lexerFlags);\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nreturn THROW_RANGE('Cannot parse a labelled const declaration, only expecting statements here', $tp_const_start, $tp_const_stop);\n}\nparseAnyVarDeclaration(lexerFlags, $tp_const_start, $tp_const_line, $tp_const_column, scoop, 7, 1, undefined, undefined, astProp);\n}\nfunction parseContinueStatement(lexerFlags, labelSet, astProp) {\nlet $tp_continue_line = tok_getLine();\nlet $tp_continue_column = tok_getColumn();\nlet $tp_continue_start = tok_getStart();\nif ((lexerFlags & 512) === 0) {\nreturn THROW_RANGE('Can only `continue` inside a loop', $tp_continue_start, $tp_continue_start + 1);\n}\nskipToStatementStart(lexerFlags);\nif ((isIdentToken(tok_getType()) && (tok_getNlwas() === false))) {\nlet $tp_label_line = tok_getLine();\nlet $tp_label_column = tok_getColumn();\nlet $tp_label_start = tok_getStart();\nlet $tp_label_stop = tok_getStop();\nlet $tp_label_canon = tok_getCanoN();\nvalidateLabelForContinue(labelSet, $tp_label_canon, $tp_label_start, $tp_label_stop);\nskipToStatementStart(lexerFlags);\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'ContinueStatement', loc:AST_getClosedLoc($tp_continue_start, $tp_continue_line, $tp_continue_column), label:AST_getIdentNode($tp_label_start, $tp_label_stop, $tp_label_line, $tp_label_column, $tp_label_canon)});\n} else {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'ContinueStatement', loc:AST_getClosedLoc($tp_continue_start, $tp_continue_line, $tp_continue_column), label:null});\n}\n}\nfunction parseDebuggerStatement(lexerFlags, astProp) {\nlet $tp_debugger_line = tok_getLine();\nlet $tp_debugger_column = tok_getColumn();\nlet $tp_debugger_start = tok_getStart();\nlet $tp_debugger_stop = tok_getStop();\nskipToStatementStart(lexerFlags);\nif (isRegexToken(tok_getType())) {\nif (tok_getNlwas() === false) {\nreturn THROW_RANGE('Missing semi-colon after debugger keyword', $tp_debugger_stop, $tp_debugger_stop);\n}\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_setNode(astProp, {type:'DebuggerStatement', loc:AST_getClosedLoc($tp_debugger_start, $tp_debugger_line, $tp_debugger_column)});\n}\nfunction parseDoStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_do_line = tok_getLine();\nlet $tp_do_column = tok_getColumn();\nlet $tp_do_start = tok_getStart();\nskipToStatementStart(lexerFlags);\nAST_open(astProp, {type:'DoWhileStatement', loc:undefined, body:undefined, test:undefined});\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nif (tok_getType() !== 2124) {\nreturn THROW_RANGE(('A `do` must be followed by a `while`, but found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToParenOpenOrDie(lexerFlags);\nparseStatementHeader(lexerFlags, 'test');\nif (tok_getType() !== 16490) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_do_start, $tp_do_line, $tp_do_column);\n}\nfunction parseExportDefaultAsync(lexerFlags, scoop, exportedBindings) {\nlet $tp_async_line = tok_getLine();\nlet $tp_async_column = tok_getColumn();\nlet $tp_async_start = tok_getStart();\nlet $tp_async_stop = tok_getStop();\nlet $tp_async_canon = tok_getCanoN();\nskipRex(lexerFlags);\nif (tok_getType() === 2095) {\nreturn parseAsyncStatement(lexerFlags, scoop, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, true, exportedBindings, false, 4, 'declaration');\n}\nparseAsyncExpression(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 4, true, true, false, 'declaration');\nparseSemiOrAsi(lexerFlags);\n}\nfunction parseExportDefault(lexerFlags, scoop, $tp_export_start, $tp_export_line, $tp_export_column, $tp_default_start, $tp_default_stop, exportedNames, exportedBindings, astProp) {\nAST_open(astProp, {type:'ExportDefaultDeclaration', loc:undefined, declaration:undefined});\nskipToExpressionStart(lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_default_start, $tp_default_stop, '*default*', 6, 4);\naddNameToExports(exportedNames, $tp_default_start, $tp_default_stop, 'default');\naddBindingToExports(exportedBindings, '*default*');\nif (tok_getType() === 2079) {\nlet $tp_exportedName_canon = parseClassDeclaration(lexerFlags, scoop, true, false, 3, 'declaration');\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\n} else if (tok_getType() === 2095) {\nlet $tp_function_line = tok_getLine();\nlet $tp_function_column = tok_getColumn();\nlet $tp_function_start = tok_getStart();\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_function_start, $tp_function_line, $tp_function_column, $tp_export_start, $tp_function_stop, true, false, 4, 'declaration');\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\n} else if (tok_getType() === 2074) {\nparseExportDefaultAsync(lexerFlags, scoop, exportedBindings);\n} else {\nparseExpression(lexerFlags, 'declaration');\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_export_start, $tp_export_line, $tp_export_column);\n}\nfunction parseExportStar(lexerFlags, $tp_export_start, $tp_export_line, $tp_export_column, exportedNames, astProp) {\nlet $tp_star_line = tok_getLine();\nlet $tp_star_column = tok_getColumn();\nlet $tp_star_start = tok_getStart();\nskipAny(lexerFlags);\nif (tok_getType() === 2073) {\nif (!allowExportStarAs) {\nreturn THROW_RANGE('The `export * as x from src`, syntax was introduced in ES2020 but currently targeted version is lower', $tp_export_start, tok_getStop());\n}\nskipToIdentOrDie(lexerFlags);\nlet $tp_exportedName_line = tok_getLine();\nlet $tp_exportedName_column = tok_getColumn();\nlet $tp_exportedName_start = tok_getStart();\nlet $tp_exportedName_stop = tok_getStop();\nlet $tp_exportedName_canon = tok_getCanoN();\naddNameToExports(exportedNames, $tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_canon);\nskipAny(lexerFlags);\nlet specifiers = [{type:'ExportNamespaceSpecifier', loc:AST_getClosedLoc($tp_star_start, $tp_star_line, $tp_star_column), exported:AST_getIdentNode($tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_line, $tp_exportedName_column, $tp_exportedName_canon)}];\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Expected to find `as` or `from`, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStringOrDie(lexerFlags);\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nlet source = AST_getStringNode($tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nif (babelCompat) {\nAST_setNode(astProp, {type:'ExportNamedDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), specifiers, source});\n} else {\nAST_setNode(astProp, {type:'ExportNamedDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), specifiers, declaration:null, source});\n}\nreturn;\n}\nif (tok_getType() !== 2094) {\nreturn THROW_RANGE(('Expected to find `as` or `from`, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStringOrDie(lexerFlags);\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nlet source = AST_getStringNode($tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nAST_setNode(astProp, {type:'ExportAllDeclaration', loc:AST_getClosedLoc($tp_export_start, $tp_export_line, $tp_export_column), source});\n}\nfunction parseExportNamed(lexerFlags, scoop, $tp_export_start, $tp_export_stop, $tp_export_line, $tp_export_column, exportedNames, exportedBindings, astProp) {\nAST_open(astProp, {type:'ExportNamedDeclaration', loc:undefined, specifiers:[], declaration:undefined, source:undefined});\nlet needsSemi = true;\nlet $tp_exportValueStart_line = tok_getLine();\nlet $tp_exportValueStart_column = tok_getColumn();\nlet $tp_exportValueStart_start = tok_getStart();\nlet $tp_exportValueStart_stop = tok_getStop();\nif (tok_getType() === 16513) {\nAST_set('declaration', null);\nlet tmpExportedNames = new Set();\nlet tmpExportedBindings = new Set();\nparseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings);\nif (tok_getType() === 2094) {\nskipToStringOrDie(lexerFlags);\nlet $tp_from_line = tok_getLine();\nlet $tp_from_column = tok_getColumn();\nlet $tp_from_start = tok_getStart();\nlet $tp_from_stop = tok_getStop();\nlet $tp_from_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nAST_setStringLiteral('source', $tp_from_start, $tp_from_stop, $tp_from_line, $tp_from_column, $tp_from_canon, false);\n} else {\nAST_set('source', null);\ntmpExportedNames.forEach(name => (addNameToExports(exportedNames, $tp_export_start, $tp_export_stop, name)));\ntmpExportedBindings.forEach(name => (addBindingToExports(exportedBindings, name)));\n}\n} else if (tok_getType() === 2122) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_var_start, $tp_var_line, $tp_var_column, scoop, 2, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2103) {\nlet $tp_let_line = tok_getLine();\nlet $tp_let_column = tok_getColumn();\nlet $tp_let_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, 6, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2080) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_const_start, $tp_const_line, $tp_const_column, scoop, 7, 3, exportedNames, exportedBindings, 'declaration');\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2079) {\nlet $tp_exportedName_canon = parseClassDeclaration(lexerFlags, scoop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_exportValueStart_start, $tp_exportValueStart_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nneedsSemi = false;\nAST_set('source', null);\n} else if (tok_getType() === 2095) {\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 0, $tp_exportValueStart_start, $tp_exportValueStart_line, $tp_exportValueStart_column, $tp_export_start, $tp_function_stop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_exportValueStart_start, $tp_exportValueStart_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nAST_set('source', null);\nneedsSemi = false;\n} else if (tok_getType() === 2074) {\nlet $tp_async_line = tok_getLine();\nlet $tp_async_column = tok_getColumn();\nlet $tp_async_start = tok_getStart();\nlet $tp_async_stop = tok_getStop();\nskipDiv(lexerFlags);\nif (tok_getType() !== 2095) {\nreturn THROW_RANGE('Can only export async functions (not arrows), did not find a function', $tp_export_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async can not be followed by a newline as it results in `export async;`, which is not valid (and probably not what you wanted)', $tp_export_start, $tp_async_stop);\n}\nlet $tp_function_start = tok_getStart();\nlet $tp_function_stop = tok_getStop();\nlet $tp_exportedName_canon = parseFunctionDeclaration(lexerFlags, scoop, true, false, 2074, $tp_async_start, $tp_async_line, $tp_async_column, $tp_export_start, $tp_function_stop, false, false, 3, 'declaration');\naddNameToExports(exportedNames, $tp_function_start, $tp_function_stop, $tp_exportedName_canon);\naddBindingToExports(exportedBindings, $tp_exportedName_canon);\nAST_set('source', null);\nneedsSemi = false;\n} else {\nreturn THROW_RANGE(('Unknown export type `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` (note: you can only export individual vars through `export {foo};`)', tok_getStart(), tok_getStop());\n}\nif (needsSemi) {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\n} else {\nparseSemiOrAsi(lexerFlags);\n}\n}\nAST_close($tp_export_start, $tp_export_line, $tp_export_column);\n}\nfunction parseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, isGlobalToplevel, astProp) {\nlet $tp_export_line = tok_getLine();\nlet $tp_export_column = tok_getColumn();\nlet $tp_export_start = tok_getStart();\nlet $tp_export_stop = tok_getStop();\nif (goalMode !== true) {\nreturn THROW_RANGE('The `export` keyword can only be used with the module goal', $tp_export_start, $tp_export_stop);\n}\nif (isGlobalToplevel === false) {\nreturn THROW_RANGE('The `export` keyword is only supported at the top level', $tp_export_start, $tp_export_stop);\n}\nskipToIdentStarCurlyOpen(lexerFlags);\nif (tok_getType() === 2083) {\nlet $tp_default_start = tok_getStart();\nlet $tp_default_stop = tok_getStop();\nreturn parseExportDefault(lexerFlags, scoop, $tp_export_start, $tp_export_line, $tp_export_column, $tp_default_start, $tp_default_stop, exportedNames, exportedBindings, astProp);\n}\nif (tok_getType() === 82009) {\nreturn parseExportStar(lexerFlags, $tp_export_start, $tp_export_line, $tp_export_column, exportedNames, astProp);\n}\nreturn parseExportNamed(lexerFlags, scoop, $tp_export_start, $tp_export_stop, $tp_export_line, $tp_export_column, exportedNames, exportedBindings, astProp);\n}\nfunction addNameToExports(exportedNames, $tp_exportedName_start, $tp_exportedName_stop, exportedName) {\nif (((exportedNames !== undefined) && (exportedName !== ''))) {\nif (exportedNames.has(exportedName)) {\nreturn THROW_RANGE(('Tried to export the name `' + exportedName) + '` twice', $tp_exportedName_start, $tp_exportedName_stop);\n}\nexportedNames.add(exportedName);\n}\n}\nfunction addBindingToExports(exportedBindings, exportedTokenCanonName) {\nif (((exportedBindings !== undefined) && (exportedTokenCanonName !== ''))) {\nexportedBindings.add(exportedTokenCanonName);\n}\n}\nfunction parseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings) {\nskipToIdentCurlyClose(lexerFlags);\nwhile (isIdentToken(tok_getType())) {\nparseExportSpecifier(lexerFlags, tmpExportedNames, tmpExportedBindings);\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n}\nif (tok_getType() !== 16517) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Export object cannot have spread', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16489) {\nreturn THROW_RANGE('Export object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Export object can only have \"shorthand\" `{x}` or \"as\" `{x as y}', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\n}\nfunction parseExportSpecifier(lexerFlags, tmpExportedNames, tmpExportedBindings) {\nlet $tp_name_line = tok_getLine();\nlet $tp_name_column = tok_getColumn();\nlet $tp_name_start = tok_getStart();\nlet $tp_name_stop = tok_getStop();\nlet $tp_name_canon = tok_getCanoN();\nlet $tp_exportedName_line = tok_getLine();\nlet $tp_exportedName_column = tok_getColumn();\nlet $tp_exportedName_start = tok_getStart();\nlet $tp_exportedName_stop = tok_getStop();\nlet $tp_exportedName_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 2073) {\nskipToIdentOrDie(lexerFlags);\n$tp_exportedName_line = tok_getLine();\n$tp_exportedName_column = tok_getColumn();\n$tp_exportedName_start = tok_getStart();\n$tp_exportedName_stop = tok_getStop();\n$tp_exportedName_canon = tok_getCanoN();\nskipAny(lexerFlags);\n}\naddNameToExports(tmpExportedNames, $tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_canon);\naddBindingToExports(tmpExportedBindings, $tp_name_canon);\nAST_setNode('specifiers', {type:'ExportSpecifier', loc:AST_getClosedLoc($tp_name_start, $tp_name_line, $tp_name_column), local:AST_getIdentNode($tp_name_start, $tp_name_stop, $tp_name_line, $tp_name_column, $tp_name_canon), exported:AST_getIdentNode($tp_exportedName_start, $tp_exportedName_stop, $tp_exportedName_line, $tp_exportedName_column, $tp_exportedName_canon)});\n}\nfunction parseForStatement(lexerFlags, scoop, labelSet, astProp) {\nscoop = SCOPE_addLayer(scoop, 1, 'parseForStatement(header)');\nlet $tp_for_line = tok_getLine();\nlet $tp_for_column = tok_getColumn();\nlet $tp_for_start = tok_getStart();\nlet $tp_for_stop = tok_getStop();\nskipToAwaitParenOpen(lexerFlags);\nlet awaitable = tok_getType() === 2075;\nif (awaitable) {\nlet $tp_await_stop = tok_getStop();\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('`for await` is not supported by the current targeted language version, they were introduced in ES9/ES2018', $tp_for_start, $tp_await_stop);\n}\nif ((lexerFlags & 8) === 0) {\nreturn THROW_RANGE('Can only use `for-await` inside an async function', $tp_for_start, $tp_await_stop);\n}\nskipToParenOpenOrDie(lexerFlags);\n} else if (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Missing opening paren of the `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', $tp_for_start, $tp_for_stop);\n}\nskipToExpressionStartSemi(lexerFlags);\nparseForHeader(((lexerFlags | 4096) | 1792) ^ 1792, $tp_for_start, scoop, awaitable, astProp);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren of the `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_for_start, $tp_for_line, $tp_for_column);\n}\nfunction parseForHeaderVar(lexerFlags, scoop, astProp) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nlet $tp_var_stop = tok_getStop();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags | 32, $tp_var_start, $tp_var_line, $tp_var_column, scoop, 2, 2, undefined, undefined, astProp);\nreturn 32;\n}\nfunction parseForHeaderLet(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp) {\nlet $tp_letIdent_type = tok_getType();\nlet $tp_letIdent_line = tok_getLine();\nlet $tp_letIdent_column = tok_getColumn();\nlet $tp_letIdent_start = tok_getStart();\nlet $tp_letIdent_stop = tok_getStop();\nlet $tp_letIdent_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nlet $tp_letArg_type = tok_getType();\nlet $tp_letArg_stop = tok_getStop();\nif (isIdentToken($tp_letArg_type)) {\nif ($tp_letArg_type === 67636) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let binding missing binding names as `let` cannot be a var name in strict mode', $tp_letIdent_start, $tp_letArg_stop);\n}\nAST_setIdent(astProp, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon);\nreturn 32;\n}\nif ($tp_letArg_type === 2106) {\nreturn THROW_RANGE('A `for (let of ...)` is always illegal', $tp_for_start, $tp_letArg_stop);\n}\nparseAnyVarDeclaration(lexerFlags | 32, $tp_letIdent_start, $tp_letIdent_line, $tp_letIdent_column, scoop, 6, 2, undefined, undefined, astProp);\nreturn 32;\n}\nif ((($tp_letArg_type === 16509) || ($tp_letArg_type === 16513))) {\nparseAnyVarDeclaration(lexerFlags | 32, $tp_letIdent_start, $tp_letIdent_line, $tp_letIdent_column, scoop, 6, 2, undefined, undefined, astProp);\nreturn 32;\n}\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let binding missing binding names in strict mode', $tp_letIdent_start, $tp_letIdent_stop);\n}\nif ($tp_letArg_type === 16490) {\nAST_setIdent(astProp, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon);\nreturn 16;\n}\nlet assignable = parseValueAfterIdent(lexerFlags, $tp_letIdent_type, $tp_letIdent_start, $tp_letIdent_stop, $tp_letIdent_line, $tp_letIdent_column, $tp_letIdent_canon, 0, true, astProp);\nassignable = parseExpressionFromOp(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, assignable, astProp);\nif (tok_getType() === 2106) {\nreturn THROW_RANGE('Cannot use `let` as a var name on the left side in a `for-of` header', $tp_for_start, tok_getStop());\n}\nreturn assignable;\n}\nfunction parseForHeaderConst(lexerFlags, scoop, astProp) {\nlet $tp_const_line = tok_getLine();\nlet $tp_const_column = tok_getColumn();\nlet $tp_const_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags | 32, $tp_const_start, $tp_const_line, $tp_const_column, scoop, 7, 2, undefined, undefined, astProp);\nreturn 32;\n}\nfunction parseForHeaderCurly(lexerFlags, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nlet $tp_curly_stop = tok_getStop();\nlet destructible = parseObjectOuter(lexerFlags | 32, null, 0, false, undefined, undefined, astProp);\nlet $tp_curlyClose_type = tok_getType();\nlet $tp_curlyClose_stop = tok_getStart();\nif ((destructible & 4) === 4) {\nif ((((($tp_curlyClose_type !== 49264) && ($tp_curlyClose_type !== 2106))) && ($tp_curlyClose_type !== 67636))) {\nreturn THROW_RANGE('Cannot use lhs as regular for-loop because it must destruct', $tp_curly_start, $tp_curlyClose_stop);\n}\ndestructible = (destructible | 4) ^ 4;\n}\nreturn parsePatternTailInForHeader(lexerFlags, $tp_curly_start, $tp_curly_stop, $tp_curly_line, $tp_curly_column, 16517, destructible, astProp);\n}\nfunction parseForHeaderBracket(lexerFlags, astProp) {\nlet $tp_square_line = tok_getLine();\nlet $tp_square_column = tok_getColumn();\nlet $tp_square_start = tok_getStart();\nlet $tp_square_stop = tok_getStop();\nlet destructible = parseArrayOuter(lexerFlags | 32, null, 0, false, undefined, undefined, astProp);\nlet $tp_bracketClose_type = tok_getType();\nlet $tp_bracketClose_stop = tok_getStart();\nif ((destructible & 4) === 4) {\nif ((((($tp_bracketClose_type !== 49264) && ($tp_bracketClose_type !== 2106))) && ($tp_bracketClose_type !== 67636))) {\nreturn THROW_RANGE('Cannot use lhs as regular for-loop because it must destruct', $tp_square_start, $tp_bracketClose_stop);\n}\ndestructible = (destructible | 4) ^ 4;\n}\nlet assignable = parsePatternTailInForHeader(lexerFlags, $tp_square_start, $tp_square_stop, $tp_square_line, $tp_square_column, 16510, destructible, astProp);\nreturn assignable;\n}\nfunction parseForHeaderOther(lexerFlags, astProp) {\nreturn parseValue(lexerFlags | 32, true, 4, false, astProp);\n}\nfunction parseForHeader(lexerFlags, $tp_for_start, scoop, awaitable, astProp) {\nlet $tp_startOfForHeader_line = tok_getLine();\nlet $tp_startOfForHeader_column = tok_getColumn();\nlet $tp_startOfForHeader_start = tok_getStart();\nlet $tp_startOfForHeader_stop = tok_getStop();\nlet assignable = parseForHeaderLhs(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp);\nreturn parseForHeaderRest(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, awaitable, assignable, astProp);\n}\nfunction parseForHeaderLhs(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp) {\nswitch (tok_getType()) {\ncase 2122:\nreturn parseForHeaderVar(lexerFlags, scoop, astProp);\ncase 2103:\nreturn parseForHeaderLet(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, scoop, astProp);\ncase 2080:\nreturn parseForHeaderConst(lexerFlags, scoop, astProp);\ncase 16490:\nAST_setNodeDangerously(astProp, null);\nreturn 16;\ncase 16513:\nreturn parseForHeaderCurly(lexerFlags, astProp);\ncase 16509:\nreturn parseForHeaderBracket(lexerFlags, astProp);\n}\nlet assignable = parseForHeaderOther(lexerFlags, astProp);\nreturn parseExpressionFromOp(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, assignable, astProp);\n}\nfunction parseForHeaderRest(lexerFlags, $tp_for_start, $tp_startOfForHeader_start, $tp_startOfForHeader_stop, $tp_startOfForHeader_line, $tp_startOfForHeader_column, awaitable, assignable, astProp) {\nif (tok_getType() === 2106) {\nreturn parseForFromOf(lexerFlags, $tp_for_start, awaitable, assignable, astProp);\n}\nif (awaitable) {\nreturn THROW_RANGE('`for await` only accepts the `for-of` type', $tp_for_start, tok_getStop());\n}\nif (tok_getType() === 67636) {\nreturn parseForFromIn(lexerFlags, $tp_for_start, assignable, astProp);\n}\nAST_wrapClosedCustom(astProp, {type:'ForStatement', loc:undefined, init:undefined, test:undefined, update:undefined, body:undefined}, 'init');\nreturn parseForFromSemi(lexerFlags, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column);\n}\nfunction parseForFromOf(lexerFlags, $tp_for_start, awaitable, assignable, astProp) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Left part of for-of must be assignable', $tp_for_start, tok_getStop());\n}\nAST_wrapClosedCustom(astProp, {type:'ForOfStatement', loc:undefined, left:undefined, right:undefined, await:awaitable, body:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nparseExpression(lexerFlags, 'right');\n}\nfunction parseForFromIn(lexerFlags, $tp_for_start, assignable, astProp) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Left part of for-in must be assignable', $tp_for_start, tok_getStop());\n}\nAST_wrapClosedCustom(astProp, {type:'ForInStatement', loc:undefined, left:undefined, right:undefined, body:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nparseExpressions(lexerFlags, 'right');\n}\nfunction parseForFromSemi(lexerFlags, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column) {\nlet hadComma = tok_getType() === 16480;\nlet potentialCommaStart = tok_getStart();\nif (hadComma) {\n_parseExpressions(lexerFlags | 32, $tp_startOfForHeader_start, $tp_startOfForHeader_line, $tp_startOfForHeader_column, 16, 'init');\n}\nif (tok_getType() !== 16490) {\nif ((hadComma && (((tok_getType() === 2106) || (tok_getType() === 67636))))) {\nreturn THROW_RANGE('Comma not allowed in left side of `for-in`/`for-of` header', potentialCommaStart, potentialCommaStart + 1);\n}\nreturn THROW_RANGE(('Missing first semi in `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nreturn _parseForFromSemi(lexerFlags);\n}\nfunction _parseForFromSemi(lexerFlags) {\nskipToExpressionStartSemi(lexerFlags);\nif (tok_getType() === 16490) {\nAST_set('test', null);\n} else {\nparseExpressions(lexerFlags, 'test');\nif (tok_getType() !== 16490) {\nreturn THROW_RANGE(('Missing second semi in `for` header, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\n}\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nAST_set('update', null);\n} else {\nparseExpressions(lexerFlags, 'update');\n}\n}\nfunction parsePatternTailInForHeader(lexerFlags, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, closingPuncType, destructible, astProp) {\nlet assignable = (((destructible & 1) !== 0)? 16 : 32);\nlet $tp_patternTailStart_type = tok_getType();\nif ((($tp_patternTailStart_type !== 49264) && isAnyAssignmentOp())) {\nreturn THROW_RANGE('Cannot compound assign to an object or array pattern', tok_getStart(), tok_getStop());\n}\nassignable = parseValueTail(lexerFlags | 32, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, assignable, 4, false, astProp);\nlet $tp_afteLhs_type = tok_getType();\nif ((($tp_afteLhs_type === 2106) || ($tp_afteLhs_type === 67636))) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('The for-header lhs binding pattern is not destructible', tok_getStart(), tok_getStop());\n}\nAST_destruct(astProp);\nreturn assignable;\n}\nif ($tp_afteLhs_type === 16490) {\nreturn assignable;\n}\nif ($tp_afteLhs_type === 49264) {\nlet $tp_eq_start = tok_getStart();\nlet $tp_eq_stop = tok_getStop();\nparseExpressionFromOp(lexerFlags | 32, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, assignable, astProp);\nif (tok_getType() === 16490) {\nreturn 16;\n}\nif (((tok_getType() === 67636) || (tok_getType() === 2106))) {\nreturn THROW_RANGE('The left side of a `for-of` and `for-in` can not be an assignment, even if it is a BindingPattern', $tp_eq_start, $tp_eq_stop);\n}\nreturn THROW_RANGE('Unknown input followed the left side of a for loop header after assignment', tok_getStart(), tok_getStop());\n}\nparseOptionalDestructibleRestOfExpression(lexerFlags, $tp_patternStart_start, $tp_patternStart_stop, $tp_patternStart_line, $tp_patternStart_column, assignable, destructible, closingPuncType, astProp);\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, 16, astProp);\n}\nif (tok_getType() === 16490) {\nreturn assignable;\n}\nreturn THROW_RANGE('Unknown input followed the left side of a for loop header', tok_getStart(), tok_getStop());\n}\nfunction parseIfStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_if_line = tok_getLine();\nlet $tp_if_column = tok_getColumn();\nlet $tp_if_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'IfStatement', loc:undefined, test:undefined, consequent:undefined, alternate:undefined});\nparseStatementHeader(lexerFlags, 'test');\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 2, null, 'consequent');\nif (tok_getType() === 2086) {\nskipToStatementStart(lexerFlags);\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 2, null, 'alternate');\n} else {\nAST_set('alternate', null);\n}\nAST_close($tp_if_start, $tp_if_line, $tp_if_column);\n}\nfunction parseImportDeclaration(lexerFlags, scoop, isGlobalToplevel, astProp) {\nlet $tp_import_line = tok_getLine();\nlet $tp_import_column = tok_getColumn();\nlet $tp_import_start = tok_getStart();\nlet $tp_import_stop = tok_getStop();\nskipToIdentStarCurlyOpenParenOpenString(lexerFlags);\nif (tok_getType() === 16471) {\nreturn parseDynamicImportStatement(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp);\n}\nif (goalMode !== true) {\nreturn THROW_RANGE('The `import` keyword can only be used with the module goal', $tp_import_start, $tp_import_stop);\n}\nif (isGlobalToplevel === false) {\nreturn THROW_RANGE('The `import` keyword is only supported at the top level', $tp_import_start, $tp_import_stop);\n}\nAST_open(astProp, {type:'ImportDeclaration', loc:undefined, specifiers:[], source:undefined});\nif (isIdentToken(tok_getType())) {\nparseImportDefault(lexerFlags, scoop);\nif (tok_getType() === 16480) {\nskipToIdentStarCurlyOpen(lexerFlags);\nif (tok_getType() === 82009) {\nparseImportNamespace(lexerFlags, scoop);\n} else if (tok_getType() === 16513) {\nparseImportObject(lexerFlags, scoop);\n} else {\nreturn THROW_RANGE('A default import can only be followed by a star or object specifier', tok_getStart(), tok_getStop());\n}\n} else if (tok_getType() === 2094) {\nskipToStringOrDie(lexerFlags);\n} else {\nreturn THROW_RANGE('The default `import` should be followed by another specifier or `from`', $tp_import_start, tok_getStop());\n}\n} else if (tok_getType() === 82009) {\nparseImportNamespace(lexerFlags, scoop);\n} else if (tok_getType() === 16513) {\nparseImportObject(lexerFlags, scoop);\n} else {\nif (!isStringToken(tok_getType())) {\nreturn THROW_RANGE(('Expected a valid token after the `import` keyword, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\n}\nlet $tp_source_line = tok_getLine();\nlet $tp_source_column = tok_getColumn();\nlet $tp_source_start = tok_getStart();\nlet $tp_source_stop = tok_getStop();\nlet $tp_source_canon = tok_getCanoN();\nskipToStatementStart(lexerFlags);\nAST_setStringLiteral('source', $tp_source_start, $tp_source_stop, $tp_source_line, $tp_source_column, $tp_source_canon, false);\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\n}\nfunction parseImportDefault(lexerFlags, scoop) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 7, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 6, 3);\nskipToAsCommaFrom(lexerFlags);\nAST_setNode('specifiers', {type:'ImportDefaultSpecifier', loc:AST_getClosedLoc($tp_ident_start, $tp_ident_line, $tp_ident_column), local:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\n}\nfunction parseImportObject(lexerFlags, scoop) {\nskipToIdentCurlyClose(lexerFlags);\nwhile (isIdentToken(tok_getType())) {\nparseImportSpecifier(lexerFlags, scoop);\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n}\nif (tok_getType() !== 16517) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Import object cannot have spread', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16489) {\nreturn THROW_RANGE('Import object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE(('Missing import definition closing curly, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToFromOrDie(lexerFlags);\nskipToStringOrDie(lexerFlags);\n}\nfunction parseImportSpecifier(lexerFlags, scoop) {\nlet $tp_name_line = tok_getLine();\nlet $tp_name_column = tok_getColumn();\nlet $tp_name_start = tok_getStart();\nlet $tp_name_stop = tok_getStop();\nlet $tp_name_canon = tok_getCanoN();\nlet $tp_local_type = tok_getType();\nlet $tp_local_line = tok_getLine();\nlet $tp_local_column = tok_getColumn();\nlet $tp_local_start = tok_getStart();\nlet $tp_local_stop = tok_getStop();\nlet $tp_local_canon = tok_getCanoN();\nskipToAsCommaCurlyClose(lexerFlags);\nif (tok_getType() === 2073) {\nskipToIdentOrDie(lexerFlags);\n$tp_local_type = tok_getType();\n$tp_local_line = tok_getLine();\n$tp_local_column = tok_getColumn();\n$tp_local_start = tok_getStart();\n$tp_local_stop = tok_getStop();\n$tp_local_canon = tok_getCanoN();\nskipAny(lexerFlags);\n}\nfatalBindingIdentCheck($tp_local_type, $tp_local_start, $tp_local_stop, $tp_local_canon, 7, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_local_start, $tp_local_stop, $tp_local_canon, 6, 1);\nAST_setNode('specifiers', {type:'ImportSpecifier', loc:AST_getClosedLoc($tp_name_start, $tp_name_line, $tp_name_column), imported:AST_getIdentNode($tp_name_start, $tp_name_stop, $tp_name_line, $tp_name_column, $tp_name_canon), local:AST_getIdentNode($tp_local_start, $tp_local_stop, $tp_local_line, $tp_local_column, $tp_local_canon)});\n}\nfunction parseImportNamespace(lexerFlags, scoop) {\nlet $tp_star_line = tok_getLine();\nlet $tp_star_column = tok_getColumn();\nlet $tp_star_start = tok_getStart();\nskipAny(lexerFlags);\nif (tok_getType() !== 2073) {\nreturn THROW_RANGE(('Next token should be `as` but was `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nskipToIdentOrDie(lexerFlags);\nlet $tp_local_type = tok_getType();\nlet $tp_local_line = tok_getLine();\nlet $tp_local_column = tok_getColumn();\nlet $tp_local_start = tok_getStart();\nlet $tp_local_stop = tok_getStop();\nlet $tp_local_canon = tok_getCanoN();\nskipToFromOrDie(lexerFlags);\nfatalBindingIdentCheck($tp_local_type, $tp_local_start, $tp_local_stop, $tp_local_canon, 7, lexerFlags);\nSCOPE_addLexBinding(scoop, $tp_local_start, $tp_local_stop, $tp_local_canon, 6, 1);\nAST_setNode('specifiers', {type:'ImportNamespaceSpecifier', loc:AST_getClosedLoc($tp_star_start, $tp_star_line, $tp_star_column), local:AST_getIdentNode($tp_local_start, $tp_local_stop, $tp_local_line, $tp_local_column, $tp_local_canon)});\nskipToStringOrDie(lexerFlags);\n}\nfunction parseLetDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nif (isIdentToken(tok_getType())) {\nlet $tp_binding_type = tok_getType();\nlet $tp_binding_start = tok_getStart();\nlet $tp_binding_stop = tok_getStop();\nlet $tp_binding_canon = tok_getCanoN();\nlet identBindingErrorMsg = ((tok_getNlwas() === true)? nonFatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, 6, lexerFlags) : '');\nif (identBindingErrorMsg !== '') {\nif ([2075, 2126, 2072, 2088, 2098, 2102, 2103, 2107, 2108, 2109, 2110, 2113].includes(tok_getType())) {\nreturn THROW_RANGE((('Attempted to create a `let` binding on special reserved keyword `' + tok_sliceInput($tp_binding_start, $tp_binding_stop)) + '` but: ') + identBindingErrorMsg, $tp_binding_start, $tp_binding_stop);\n}\nreturn THROW_RANGE(('`let` must be a declaration in strict mode but the next ident is a reserved keyword (`' + tok_sliceInput($tp_binding_start, $tp_binding_stop)) + '`)', $tp_binding_start, $tp_binding_stop);\n}\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, 6, 1, undefined, undefined, astProp);\n} else if (((tok_getType() === 16509) || (tok_getType() === 16513))) {\nparseAnyVarDeclaration(lexerFlags, $tp_let_start, $tp_let_line, $tp_let_column, scoop, 6, 1, undefined, undefined, astProp);\n} else if ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Let declaration missing binding names and `let` cannot be a regular var or label name in strict mode', $tp_ident_start, $tp_ident_stop);\n} else {\n_parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\n}\nfunction parseLetExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('`let` declaration not allowed here and `let` cannot be a regular var or label name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nif (tok_getType() === 16509) {\nreturn THROW_RANGE('It is never valid for an expression statement to begin with `let[`, and a `let` declaration would not be valid here', $tp_ident_start, tok_getStop());\n}\n_parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nfunction _parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp) {\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nlet $tp_next_type = tok_getType();\nif ((($tp_next_type === 67636) || ($tp_next_type === 67636))) {\nreturn THROW_RANGE('Cannot use `let` as a regular var name as the lhs of `in` or `instanceof` in a toplevel expression statement', tok_getStart(), tok_getStop());\n}\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nlet assignable = parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, true, 'expression');\nassignable = parseValueTail(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignable, 4, false, 'expression');\nparseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, assignable, 'expression');\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, 16, 'expression');\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseReturnStatement(lexerFlags, astProp) {\nlet $tp_return_line = tok_getLine();\nlet $tp_return_column = tok_getColumn();\nlet $tp_return_start = tok_getStart();\nif (((!allowGlobalReturn) && ((lexerFlags & 256) === 256))) {\nreturn THROW_RANGE('Not configured to parse `return` statement in global, bailing', $tp_return_start, $tp_return_start + 1);\n}\nskipToStatementStart(lexerFlags);\nAST_open(astProp, {type:'ReturnStatement', loc:undefined, argument:undefined});\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\ntok_asi();\nAST_set('argument', null);\n} else {\nif (((((((tok_getNlwas() === false) && (tok_getType() !== 2097173))) && (tok_getType() !== 16490))) && (tok_getType() !== 16517))) {\nparseExpressions(lexerFlags, 'argument');\n} else {\nAST_set('argument', null);\n}\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_return_start, $tp_return_line, $tp_return_column);\n}\nfunction parseSwitchStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_switch_line = tok_getLine();\nlet $tp_switch_column = tok_getColumn();\nlet $tp_switch_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'SwitchStatement', loc:undefined, discriminant:undefined, cases:[]});\nlet lexerFlagsForSwitch = (lexerFlags | 6400) ^ 6400;\nparseStatementHeader(lexerFlagsForSwitch, 'discriminant');\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Missing opening curly of `switch` body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToSwitchBody(lexerFlagsForSwitch);\nlet casesScoop = SCOPE_addLayer(scoop, 8, 'parseSwitchStatement');\nparseSwitchCases(lexerFlagsForSwitch | 1024, casesScoop, labelSet, 'cases');\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Missing the closing curly of the switch body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToStatementStart(lexerFlags);\nAST_close($tp_switch_start, $tp_switch_line, $tp_switch_column);\n}\nfunction parseSwitchCases(lexerFlags, scoop, labelSet, astProp) {\nlet hadDefault = false;\nwhile (true) {\nlet $tp_caseDefault_line = tok_getLine();\nlet $tp_caseDefault_column = tok_getColumn();\nlet $tp_caseDefault_start = tok_getStart();\nif (tok_getType() === 2077) {\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'SwitchCase', loc:undefined, test:undefined, consequent:[]});\nparseExpressions(lexerFlags, 'test');\nif (tok_getType() !== 16489) {\nreturn THROW_RANGE('Missing colon after case expr', tok_getStart(), tok_getStop());\n}\n} else if (tok_getType() === 2083) {\nif (hadDefault) {\nreturn THROW_RANGE('Found second `default` in same switch', tok_getStart(), tok_getStop());\n}\nhadDefault = true;\nskipToColonOrDie(lexerFlags);\nAST_open(astProp, {type:'SwitchCase', loc:undefined, test:null, consequent:[]});\n} else {\nbreak;\n}\nskipToStatementStart(lexerFlags);\nwhile (((((tok_getType() !== 16517) && (tok_getType() !== 2077))) && (tok_getType() !== 2083))) {\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 3, null, 'consequent');\n}\nAST_close($tp_caseDefault_start, $tp_caseDefault_line, $tp_caseDefault_column);\n}\n}\nfunction parseThrowStatement(lexerFlags, astProp) {\nlet $tp_throw_line = tok_getLine();\nlet $tp_throw_column = tok_getColumn();\nlet $tp_throw_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'ThrowStatement', loc:undefined, argument:undefined});\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Found a newline between `throw` and its argument but that is not allowed', $tp_throw_start, tok_getStart());\n}\nlet tmpLexerFlags = (lexerFlags | 1824) ^ 1824;\nparseExpressions(tmpLexerFlags, 'argument');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_throw_start, $tp_throw_line, $tp_throw_column);\n}\nfunction parseTryStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_try_line = tok_getLine();\nlet $tp_try_column = tok_getColumn();\nlet $tp_try_start = tok_getStart();\nlet $tp_try_stop = tok_getStop();\nskipToCurlyOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'TryStatement', loc:undefined, block:undefined, handler:undefined, finalizer:undefined});\nlet tryScoop = SCOPE_addLayer(scoop, 4, 'parseTryStatement(try)');\nparseBlockStatement(lexerFlags, tryScoop, labelSet, 'block');\nlet hasEither = false;\nif (tok_getType() === 2078) {\nhasEither = true;\nlet $tp_catch_line = tok_getLine();\nlet $tp_catch_column = tok_getColumn();\nlet $tp_catch_start = tok_getStart();\nskipAny(lexerFlags);\nAST_open('handler', {type:'CatchClause', loc:undefined, param:undefined, body:undefined});\nlet catchHeadScoop = SCOPE_addLayer(scoop, 5, 'parseTryStatement(catch-var)');\nlet catchBodyScoop = SCOPE_addLayer(catchHeadScoop, 6, 'parseTryStatement(catch-body)');\nif (tok_getType() === 16513) {\nif (!allowOptionalCatchBinding) {\nreturn THROW_RANGE('Missing the `catch` clause. Optional catch clause is only supported since ES10  ES2019', tok_getStart(), tok_getStop());\n}\nAST_set('param', null);\n} else if (tok_getType() === 16471) {\nskipToBindingStart(lexerFlags);\nif (tok_getType() === 16472) {\nreturn THROW_RANGE('The catch clause must have a binding', tok_getStart(), tok_getStop());\n}\nlet $tp_binding_line = tok_getLine();\nlet $tp_binding_column = tok_getColumn();\nlet $tp_binding_start = tok_getStart();\nparseBinding(lexerFlags | 4096, $tp_binding_start, $tp_binding_line, $tp_binding_column, catchHeadScoop, 10, 4, false, undefined, undefined, 'param');\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Catch clause requires exactly one parameter, not more (and no trailing comma)', tok_getStart(), tok_getStop());\n}\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing right paren for the catch clause, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToCurlyOpenOrDie(lexerFlags);\n} else {\nreturn THROW_RANGE(('Missing start of catch clause (`(`) or start of catch body (`{`), found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nparseBlockStatement(lexerFlags, catchBodyScoop, labelSet, 'body');\nAST_close($tp_catch_start, $tp_catch_line, $tp_catch_column);\n} else {\nAST_set('handler', null);\n}\nif (tok_getType() === 2092) {\nhasEither = true;\nskipToCurlyOpenOrDie(lexerFlags);\nlet finallyScoop = SCOPE_addLayer(scoop, 7, 'parseTryStatement(finally)');\nparseBlockStatement(lexerFlags, finallyScoop, labelSet, 'finalizer');\n} else {\nAST_set('finalizer', null);\n}\nAST_close($tp_try_start, $tp_try_line, $tp_try_column);\nif (!hasEither) {\nreturn THROW_RANGE('Try must have catch or finally', $tp_try_start, $tp_try_stop);\n}\n}\nfunction parseVarStatement(lexerFlags, scoop, astProp) {\nlet $tp_var_line = tok_getLine();\nlet $tp_var_column = tok_getColumn();\nlet $tp_var_start = tok_getStart();\nskipToBindingStart(lexerFlags);\nparseAnyVarDeclaration(lexerFlags, $tp_var_start, $tp_var_line, $tp_var_column, scoop, 2, 1, undefined, undefined, astProp);\n}\nfunction parseWhileStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_while_line = tok_getLine();\nlet $tp_while_column = tok_getColumn();\nlet $tp_while_start = tok_getStart();\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'WhileStatement', loc:undefined, test:undefined, body:undefined});\nparseStatementHeader(lexerFlags, 'test');\nparseNestedBodyPart(lexerFlags | 512, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_while_start, $tp_while_line, $tp_while_column);\n}\nfunction parseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, fdState, nestedLabels, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nif (tok_getType() === 16489) {\nreturn parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp);\n}\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseExpressionsAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseLabeledStatementInstead(lexerFlags, scoop, labelSet, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, fdState, nestedLabels, astProp) {\nif ((($tp_ident_type !== 2088) && ($tp_ident_type !== 2072))) {\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 0, lexerFlags);\n}\nlet set = labelSet;\nwhile (set) {\nif (set.statementLabels.has($tp_ident_canon)) {\nreturn THROW_RANGE('Saw the same label twice which is not allowed', $tp_ident_start, $tp_ident_stop);\n}\nset = set.parentLabels;\n}\nlabelSet = wrapLabelSet(labelSet, 'labelled statement');\nlabelSet.statementLabels.add($tp_ident_canon);\nskipToStatementStart(lexerFlags);\nif (fdState === 2) {\nfdState = 1;\n}\nif (nestedLabels === null) {\nnestedLabels = new Set();\n}\nnestedLabels.add($tp_ident_canon);\nif ((isIdentToken(tok_getType()) && (((((tok_getType() === 2093) || (tok_getType() === 2124))) || (tok_getType() === 2085))))) {\nlabelSet.iterationLabels = nestedLabels;\n}\nAST_open(astProp, {type:'LabeledStatement', loc:undefined, label:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon), body:undefined});\nparseNestedBodyPart(lexerFlags, scoop, labelSet, true, fdState, nestedLabels, 'body');\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp) {\nif (tok_getType() === 16513) {\nlet blockScoop = SCOPE_addLayer(scoop, 2, 'parsePunctuatorStatement.block');\nparseBlockStatement(lexerFlags, blockScoop, labelSet, astProp);\nreturn;\n}\nif (tok_getType() === 16490) {\nparseEmptyStatement(lexerFlags, astProp);\nreturn;\n}\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseExpressions(lexerFlags, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\n}\nfunction parseEmptyStatement(lexerFlags, astProp) {\nlet $tp_semi_line = tok_getLine();\nlet $tp_semi_column = tok_getColumn();\nlet $tp_semi_start = tok_getStart();\nskipToStatementStart(lexerFlags);\nAST_setNode(astProp, {type:'EmptyStatement', loc:AST_getClosedLoc($tp_semi_start, $tp_semi_line, $tp_semi_column)});\n}\nfunction parseWithStatement(lexerFlags, scoop, labelSet, astProp) {\nlet $tp_with_line = tok_getLine();\nlet $tp_with_column = tok_getColumn();\nlet $tp_with_start = tok_getStart();\nlet $tp_with_stop = tok_getStop();\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('The `with` statement is not allowed in strict mode', $tp_with_start, $tp_with_stop);\n}\nskipToParenOpenOrDie(lexerFlags);\nAST_open(astProp, {type:'WithStatement', loc:undefined, object:undefined, body:undefined});\nparseStatementHeader(lexerFlags, 'object');\nparseNestedBodyPart(lexerFlags, scoop, labelSet, false, 1, null, 'body');\nAST_close($tp_with_start, $tp_with_line, $tp_with_column);\n}\nfunction parseAnyVarDeclaration(lexerFlags, $tp_binding_start, $tp_binding_line, $tp_binding_column, scoop, bindingType, bindingOrigin, exportedNames, exportedBindings, astProp) {\nif (((((!isIdentToken(tok_getType())) && (tok_getType() !== 16509))) && (tok_getType() !== 16513))) {\nreturn THROW_RANGE('Expected identifier, or array/object destructuring', tok_getStart(), tok_getStop());\n}\nlet keyword = ((bindingType === 2)? 'var' : (((bindingType === 6)? 'let' : 'const')));\nAST_open(astProp, {type:'VariableDeclaration', loc:undefined, kind:keyword, declarations:[]});\nparseBindings(lexerFlags, scoop, bindingType, bindingOrigin, true, 0, exportedNames, exportedBindings, 'declarations');\nif (((bindingOrigin === 1) || (bindingOrigin === 3))) {\nparseSemiOrAsi(lexerFlags);\n}\nAST_close($tp_binding_start, $tp_binding_line, $tp_binding_column);\n}\nfunction parseBindings(lexerFlags, scoop, bindingType, bindingOrigin, defaultOptions, $tp_set_type, exportedNames, exportedBindings, astProp) {\nlet many = 0;\nlet inited = false;\nlet startWasObjectOrArray = ((tok_getType() === 16509) || (tok_getType() === 16513));\nlet paramsSimple = 1;\ndo {\n++many;\nlet $tp_bindingStart_type = tok_getType();\nlet $tp_bindingStart_line = tok_getLine();\nlet $tp_bindingStart_column = tok_getColumn();\nlet $tp_bindingStart_start = tok_getStart();\nlet wasRest = $tp_bindingStart_type === 16486;\nlet paramSimple = parseBinding(lexerFlags, $tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column, scoop, bindingType, bindingOrigin, defaultOptions, exportedNames, exportedBindings, astProp);\nif ((wasRest && ($tp_set_type === 2112))) {\nreturn THROW_RANGE('A setter can not have a rest arg (unless inside a pattern)', $tp_bindingStart_start, tok_getStart());\n}\nif (paramSimple === 4) {\ninited = true;\nparamsSimple = 3;\n} else if (paramSimple === 3) {\nparamsSimple = 3;\n} else if (paramSimple === 2) {\nif (paramsSimple === 1) {\nparamsSimple = 2;\n}\n}\nif (wasRest) {\nbreak;\n}\nif (tok_getType() !== 16480) break;\nskipToBindingStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif (bindingType === 1) {\nif (allowTrailingFunctionComma) {\nreturn paramsSimple;\n}\nreturn THROW_RANGE('Targeted language version does not support trailing function arg comma', tok_getStart(), tok_getStop());\n}\n}\n} while (true);\nif (((many !== 1) && ($tp_set_type === 2112))) {\nreturn THROW_RANGE('Setters require exactly one parameter', tok_getStart(), tok_getStop());\n}\nif (((bindingOrigin === 2) && (((tok_getType() === 67636) || (tok_getType() === 2106))))) {\nif (many !== 1) {\nreturn THROW_RANGE('For-in and for-of can only have one binding, found ' + many, tok_getStart(), tok_getStop());\n}\nif ((inited && ((((((((startWasObjectOrArray || (options_webCompat === false))) || (bindingType !== 2))) || (tok_getType() === 2106))) || ((lexerFlags & 8192) === 8192))))) {\nreturn THROW_RANGE('For-in and for-of binding can not have an init', tok_getStart(), tok_getStop());\n}\n}\nreturn paramsSimple;\n}\nfunction parseBinding(lexerFlags, $tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column, scoop, bindingType, bindingOrigin, defaultsOption, exportedNames, exportedBindings, astProp) {\nlet mustHaveInit = false;\nlet paramSimple = 0;\nif (isIdentToken(tok_getType())) {\nlet $tp_binding_type = tok_getType();\nlet $tp_binding_start = tok_getStart();\nlet $tp_binding_stop = tok_getStop();\nlet $tp_binding_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType, lexerFlags);\nif (bindingType === 10) {\nbindingType = 9;\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType);\naddNameToExports(exportedNames, $tp_binding_start, $tp_binding_stop, $tp_binding_canon);\naddBindingToExports(exportedBindings, $tp_binding_canon);\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipRex(lexerFlags);\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nif ((((lexerFlags & 8192) === 0) && (nonFatalBindingIdentCheck($tp_binding_type, $tp_binding_start, $tp_binding_stop, $tp_binding_canon, bindingType, lexerFlags | 8192) !== ''))) {\nparamSimple = 2;\n} else {\nparamSimple = 1;\n}\n} else if (tok_getType() === 16513) {\nlet destructible = parseObjectOuter(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(destructible, bindingType);\nAST_destruct(astProp);\nparamSimple = 3;\nif (((((bindingOrigin !== 4) && (((bindingOrigin !== 2) || (((tok_getType() !== 67636) && (tok_getType() !== 2106))))))) && (((((bindingType === 7) || (bindingType === 6))) || (bindingType === 2))))) {\nmustHaveInit = true;\n}\n} else if (tok_getType() === 16509) {\nlet destructible = parseArrayOuter(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(destructible, bindingType);\nAST_destruct(astProp);\nparamSimple = 3;\nif (((((bindingOrigin !== 4) && (((bindingOrigin !== 2) || (((tok_getType() !== 67636) && (tok_getType() !== 2106))))))) && (((((bindingType === 7) || (bindingType === 6))) || (bindingType === 2))))) {\nmustHaveInit = true;\n}\n} else if (tok_getType() === 16486) {\nif (bindingType !== 1) {\nreturn THROW_RANGE('Rest is not allowed as toplevel for var/let/const declaration binding', tok_getStart(), tok_getStop());\n}\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, 16472, bindingType, 0, exportedNames, exportedBindings, astProp);\nverifyDestructibleForBinding(subDestruct, bindingType);\nparamSimple = 3;\n} else if (tok_getType() !== 16472) {\nreturn THROW_RANGE('Expected to parse a(nother) binding but none was found', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 49264) {\nif (bindingOrigin === 4) {\nreturn THROW_RANGE('Catch clause can not have init / default', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nparamSimple = 4;\nif (defaultsOption === false) {\nAST_wrapClosedCustom(astProp, {type:'AssignmentPattern', loc:undefined, left:undefined, right:undefined}, 'left');\nparseExpression(lexerFlags, 'right');\nAST_close($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column);\n} else {\nAST_wrapClosedCustom('declarations', {type:'VariableDeclarator', loc:undefined, id:undefined, init:undefined}, 'id');\nparseExpression(lexerFlags, 'init');\nAST_close($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column);\n}\n} else if (mustHaveInit) {\nreturn THROW_RANGE('Declaration destructuring must have init', tok_getStart(), tok_getStop());\n} else if (((bindingType === 7) && (((bindingOrigin !== 2) || (((tok_getType() === 16490) || (tok_getType() === 16480))))))) {\nreturn THROW_RANGE('Constants must be initialized', tok_getStart(), tok_getStop());\n} else if (defaultsOption === true) {\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nif (bindingOrigin === 2) {\nreturn THROW_RANGE('Illegal regex after binding declaration in `for` header', tok_getStart(), tok_getStop());\n}\nASSERT_ASI_REGEX_NEXT = true;\n}\nAST_setNodeDangerously('declarations', {type:'VariableDeclarator', loc:AST_getClosedLoc($tp_bindingStart_start, $tp_bindingStart_line, $tp_bindingStart_column), id:AST_popNode('declarations'), init:null});\n} else {\n\n}\nreturn paramSimple;\n}\nfunction fatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags) {\nlet str = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (str !== '') THROW_RANGE(`Cannot use this name (\\`${tok_sliceInput($tp_ident_start, $tp_ident_stop)}\\`) as a variable name because: ${str}`, $tp_ident_start, $tp_ident_stop);\n}\nfunction nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags) {\nif (($tp_ident_stop - $tp_ident_start) === $tp_ident_canon.length) {\nif ($tp_ident_type === 2048) return '';\nreturn nonFatalBindingIdentCheckByEnum(lexerFlags, $tp_ident_type, $tp_ident_canon, bindingType);\n}\nreturn nonFatalBindingIdentCheckByString(lexerFlags, $tp_ident_canon, bindingType);\n}\nfunction nonFatalBindingIdentCheckByEnum(lexerFlags, $tp_ident_type, $tp_ident_canon, bindingType) {\nswitch ($tp_ident_type) {\ncase 2076:\n\ncase 2077:\n\ncase 2078:\n\ncase 2079:\n\ncase 2080:\n\ncase 2081:\n\ncase 2082:\n\ncase 2083:\n\ncase 2084:\n\ncase 2085:\n\ncase 2086:\n\ncase 2089:\n\ncase 2090:\n\ncase 2092:\n\ncase 2093:\n\ncase 2095:\n\ncase 2097:\n\ncase 2099:\n\ncase 67636:\n\ncase 67637:\n\ncase 2104:\n\ncase 2111:\n\ncase 2114:\n\ncase 2115:\n\ncase 2117:\n\ncase 2118:\n\ncase 2120:\n\ncase 2121:\n\ncase 2122:\n\ncase 2123:\n\ncase 2124:\n\ncase 2125:\n\ncase 2105:\n\ncase 2119:\n\ncase 2091:\n\ncase 2087:\nreturn 'Cannot never use this reserved word as a variable name';\ncase 2103:\nif (bindingType === 8) return 'Can not use `let` as a class name';\nif (((bindingType === 6) || (bindingType === 7))) return 'Can not use `let` when binding through `let` or `const`';\nif ((lexerFlags & 8192) === 8192) return 'Can not use `let` as variable name in strict mode';\nreturn '';\ncase 2113:\nif ((lexerFlags & 8192) === 8192) return '`static` is a reserved word in strict mode';\nreturn '';\ncase 2088:\n\ncase 2072:\nif ((lexerFlags & 8192) === 8192) return ('Cannot create a binding named `' + $tp_ident_canon) + '` in strict mode';\nreturn '';\ncase 2098:\n\ncase 2107:\n\ncase 2109:\n\ncase 2102:\n\ncase 2108:\n\ncase 2110:\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nreturn '';\ncase 2075:\nif (allowAsyncFunctions) {\nif (goalMode === true) return 'Await is illegal as var name with module goal';\nif ((lexerFlags & 8) !== 0) return 'Await not allowed here';\n}\nreturn '';\ncase 2126:\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nif ((lexerFlags & 128) !== 0) return 'Cannot use this reserved word as a variable name inside a generator';\nreturn '';\n}\nreturn '';\n}\nfunction nonFatalBindingIdentCheckByString(lexerFlags, $tp_ident_canon, bindingType) {\nswitch ($tp_ident_canon) {\ncase 'break':\n\ncase 'case':\n\ncase 'catch':\n\ncase 'class':\n\ncase 'const':\n\ncase 'continue':\n\ncase 'debugger':\n\ncase 'default':\n\ncase 'delete':\n\ncase 'do':\n\ncase 'else':\n\ncase 'export':\n\ncase 'extends':\n\ncase 'finally':\n\ncase 'for':\n\ncase 'function':\n\ncase 'if':\n\ncase 'import':\n\ncase 'in':\n\ncase 'instanceof':\n\ncase 'new':\n\ncase 'return':\n\ncase 'super':\n\ncase 'switch':\n\ncase 'this':\n\ncase 'throw':\n\ncase 'try':\n\ncase 'typeof':\n\ncase 'var':\n\ncase 'void':\n\ncase 'while':\n\ncase 'with':\n\ncase 'null':\n\ncase 'true':\n\ncase 'false':\n\ncase 'enum':\nreturn ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\ncase 'let':\nif (bindingType === 8) return 'Can not use `let` as a class name';\nif (((bindingType === 6) || (bindingType === 7))) return 'Can not use `let` when binding through `let` or `const`';\nif ((lexerFlags & 8192) === 8192) return 'Can not use `let` as variable name in strict mode';\nreturn '';\ncase 'static':\nif ((lexerFlags & 8192) === 8192) return ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\nreturn '';\ncase 'eval':\n\ncase 'arguments':\nif ((lexerFlags & 8192) === 8192) return ('Cannot create a binding named `' + $tp_ident_canon) + '` in strict mode';\nreturn '';\ncase 'implements':\n\ncase 'package':\n\ncase 'protected':\n\ncase 'interface':\n\ncase 'private':\n\ncase 'public':\nif ((lexerFlags & 8192) === 8192) return ('Keywords may not have escapes in their name and this resolves to `' + $tp_ident_canon) + '`';\nreturn '';\ncase 'await':\nif (allowAsyncFunctions) {\nif (goalMode === true) return 'Await is illegal as var name with module goal';\nif ((lexerFlags & 8) !== 0) return 'Await not allowed here';\n}\nreturn '';\ncase 'yield':\nif ((lexerFlags & 8192) === 8192) return 'Cannot use this reserved word as a variable name in strict mode';\nif ((lexerFlags & 128) !== 0) return 'Cannot use this reserved word as a variable name inside a generator';\nreturn '';\n}\nreturn '';\n}\nfunction parseExpression(lexerFlags, astProp) {\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet $tp_start_stop = tok_getStop();\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nreturn parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, assignable, astProp);\n}\nfunction parseExpressionAfterLiteral(lexerFlags, $tp_literal_start, $tp_literal_stop, $tp_literal_line, $tp_literal_column, astProp) {\nlet assignable = parseValueTail(lexerFlags, $tp_literal_start, $tp_literal_line, $tp_literal_column, 16, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_literal_start, $tp_literal_stop, $tp_literal_line, $tp_literal_column, assignable, astProp);\n}\nfunction parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, astProp) {\nlet assignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, astProp);\nassignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, assignable, astProp);\nreturn assignable;\n}\nfunction parseExpressionAfterAsyncAsVarName(lexerFlags, stmtOrExpr, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, isNewArg, allowAssignment, astProp) {\nif (stmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nlet assignable = 16;\nif (tok_getType() === 16499) {\nassignable = parseArrowParenlessFromPunc(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, allowAssignment, 1, 0, astProp);\n} else {\nassignable = parseIdentOrParenlessArrow(lexerFlags, 2074, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 32, allowAssignment, astProp);\nassignable = parseValueTail(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, assignable, isNewArg, false, astProp);\nif (stmtOrExpr === 2) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, assignable, astProp);\n}\n}\nif (stmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\nreturn assignable;\n}\nfunction parseParenlessArrowAfterAsync(lexerFlags, fromStmtOrExpr, allowAssignment, $tp_async_start, $tp_async_line, $tp_async_column, astProp) {\nif (fromStmtOrExpr === 2) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nastProp = 'expression';\n}\nif (tok_getType() === 2075) {\nreturn THROW_RANGE('Cannot use `await` as an arg name with async arrows', tok_getStart(), tok_getStop());\n}\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nlet isSimple = 1;\nif (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nisSimple = 2;\n}\nskipToArrowOrDie(lexerFlags);\nparseArrowParenlessFromPunc(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, isSimple, 2074, astProp);\nif (fromStmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\n}\n}\nfunction isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon) {\nif ($tp_ident_canon.length === ($tp_ident_stop - $tp_ident_start)) {\nreturn isStrictOnlyKeywordByEnum($tp_ident_type);\n}\nreturn isStrictOnlyKeywordByString($tp_ident_canon);\n}\nfunction isStrictOnlyKeywordByEnum($tp_ident_type) {\nswitch ($tp_ident_type) {\ncase 2088:\n\ncase 2072:\n\ncase 2098:\n\ncase 2102:\n\ncase 2103:\n\ncase 2107:\n\ncase 2108:\n\ncase 2109:\n\ncase 2110:\n\ncase 2113:\n\ncase 2126:\nreturn true;\n}\nreturn false;\n}\nfunction isStrictOnlyKeywordByString($tp_ident_canon) {\nswitch ($tp_ident_canon) {\ncase 'eval':\n\ncase 'arguments':\n\ncase 'implements':\n\ncase 'interface':\n\ncase 'let':\n\ncase 'package':\n\ncase 'private':\n\ncase 'protected':\n\ncase 'public':\n\ncase 'static':\n\ncase 'yield':\nreturn true;\n}\nreturn false;\n}\nfunction parseExpressionFromOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_stop, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp) {\nif (isAnyAssignmentOp()) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE(('Cannot assign to lhs (starting with `' + tok_sliceInput($tp_firstExpr_start, $tp_firstExpr_stop)) + '`) because it is not a valid assignment target', tok_getStart(), tok_getStop());\n}\nreturn parseExpressionFromAssignmentOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp);\n}\nreturn parseExpressionFromBinaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp);\n}\nfunction parseExpressionFromAssignmentOp(lexerFlags, $tp_firstAssignment_start, $tp_firstAssignment_line, $tp_firstAssignment_column, lhsAssignable, astProp) {\nlet $tp_eq_type = tok_getType();\nAST_convertArrayToPattern($tp_eq_type, astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:tok_sliceInput(tok_getStart(), tok_getStop()), right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet rhsAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_firstAssignment_start, $tp_firstAssignment_line, $tp_firstAssignment_column);\nreturn setNotAssignable(mergeAssignable(rhsAssignable, lhsAssignable));\n}\nfunction parseExpressionFromBinaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, assignable, astProp) {\nif ((assignable & 1024) === 1024) return assignable;\nlet $tp_next_type = tok_getType();\nlet repeat = false;\ndo {\nrepeat = false;\nif ($tp_next_type === 16506) {\nlet nowAssignable = parseExpressionFromTernaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, astProp);\nassignable = setNotAssignable(nowAssignable | assignable);\nrepeat = true;\n} else if (isNonAssignBinOp($tp_next_type, lexerFlags)) {\nlet nowAssignable = parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, 0, astProp);\nassignable = setNotAssignable(nowAssignable | assignable);\nrepeat = true;\n}\n$tp_next_type = tok_getType();\n} while (repeat);\nif (isAnyAssignmentOp()) {\nreturn THROW_RANGE('Can not have an assignment after a non-assignment operator', tok_getStart(), tok_getStop());\n}\nreturn assignable;\n}\nfunction preventNullishWithLogic($tp_op_type, $tp_op_start, $tp_op_stop, coalSeen) {\nif ((($tp_op_type === 82005) || ($tp_op_type === 82051))) {\nif (coalSeen === 1) {\nreturn THROW_RANGE('Cannot use `??` and `&&`/`||` in the same expression without some grouping', $tp_op_start, $tp_op_stop);\n}\nreturn 2;\n}\nif ($tp_op_type === 82044) {\nif (coalSeen === 2) {\nreturn THROW_RANGE('Cannot use `??` and `&&`/`||` in the same expression without some grouping', $tp_op_start, $tp_op_stop);\n}\nreturn 1;\n}\nreturn coalSeen;\n}\nfunction parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, coalSeen, astProp) {\nlet $tp_op_type = tok_getType();\nlet $tp_op_start = tok_getStart();\nlet $tp_op_stop = tok_getStop();\ncoalSeen = preventNullishWithLogic($tp_op_type, $tp_op_start, $tp_op_stop, coalSeen);\nlet AST_nodeName = (((((($tp_op_type === 82005) || ($tp_op_type === 82051))) || ($tp_op_type === 82044)))? 'LogicalExpression' : 'BinaryExpression');\nAST_wrapClosedCustom(astProp, {type:AST_nodeName, loc:undefined, left:undefined, operator:tok_sliceInput($tp_op_start, $tp_op_stop), right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet $tp_rightExprStart_line = tok_getLine();\nlet $tp_rightExprStart_column = tok_getColumn();\nlet $tp_rightExprStart_start = tok_getStart();\nlet assignable = parseValue(lexerFlags, false, 4, false, 'right');\nlet otherStrength = getStrength($tp_op_type, $tp_op_start, $tp_op_stop);\nwhile (continueParsingBinOp(lexerFlags, otherStrength)) {\nassignable |= parseExpressionFromBinaryOpOnlyStronger(lexerFlags, $tp_rightExprStart_start, $tp_rightExprStart_line, $tp_rightExprStart_column, coalSeen, 'right');\n}\npreventNullishWithLogic(tok_getType(), tok_getStart(), tok_getStop(), coalSeen);\nAST_close($tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column);\nreturn setNotAssignable(assignable);\n}\nfunction parseExpressionFromTernaryOp(lexerFlags, $tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column, astProp) {\nAST_wrapClosedCustom(astProp, {type:'ConditionalExpression', loc:undefined, test:undefined, consequent:undefined, alternate:undefined}, 'test');\nskipToExpressionStart(lexerFlags);\nlet midAssignable = parseExpression(((lexerFlags | 32) ^ 32) | 4096, 'consequent');\nif (tok_getType() !== 16489) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Can not use comma inside ternary expressions', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Unexpected character inside ternary', tok_getStart(), tok_getStop());\n}\nskipToExpressionStart(lexerFlags);\nlet rhsAssignable = parseExpression(lexerFlags, 'alternate');\nAST_close($tp_firstExpr_start, $tp_firstExpr_line, $tp_firstExpr_column);\nreturn setNotAssignable(midAssignable | rhsAssignable);\n}\nfunction parseExpressionsAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp) {\nlet assignableForPiggies = parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 0, astProp);\nif (tok_getType() === 16480) {\nassignableForPiggies = _parseExpressions(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignableForPiggies, astProp);\n}\nreturn assignableForPiggies;\n}\nfunction parseExpressions(lexerFlags, astProp) {\nlet $tp_startOfFirstExpr_line = tok_getLine();\nlet $tp_startOfFirstExpr_column = tok_getColumn();\nlet $tp_startOfFirstExpr_start = tok_getStart();\nlet assignableForPiggies = parseExpression(lexerFlags, astProp);\nif (tok_getType() === 16480) {\nassignableForPiggies = _parseExpressions(lexerFlags, $tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_column, assignableForPiggies, astProp);\n}\nreturn assignableForPiggies;\n}\nfunction _parseExpressions(lexerFlags, $tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_colun, assignableForPiggies, astProp) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nassignableForPiggies = __parseExpressions(lexerFlags, assignableForPiggies, 'expressions');\nAST_close($tp_startOfFirstExpr_start, $tp_startOfFirstExpr_line, $tp_startOfFirstExpr_colun);\nreturn assignableForPiggies;\n}\nfunction __parseExpressions(lexerFlags, assignableForPiggies, astProp) {\ndo {\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, astProp);\nassignableForPiggies |= nowAssignable;\n} while (tok_getType() === 16480);\nreturn setNotAssignable(assignableForPiggies);\n}\nfunction isAnyAssignmentOp() {\nif (!((tok_getType() & 32768) === 32768)) return false;\nif (tok_getType() !== 49244) return true;\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nfunction isNonAssignBinOp(type, lexerFlags) {\nif (!((type & 65536) === 65536)) return false;\nif (type === 82010) {\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nif (type === 67636) {\nreturn (lexerFlags & 32) === 0;\n}\nreturn true;\n}\nfunction getStrength(type, $tp_tokenStart, $tp_tokenStop) {\nswitch (type) {\ncase 82010:\nreturn 16;\ncase 82009:\nreturn 15;\ncase 82023:\nreturn 15;\ncase 82002:\nreturn 15;\ncase 82013:\nreturn 14;\ncase 82017:\nreturn 14;\ncase 82028:\nreturn 13;\ncase 82037:\nreturn 13;\ncase 82038:\nreturn 13;\ncase 82027:\nreturn 12;\ncase 82029:\nreturn 12;\ncase 82036:\nreturn 12;\ncase 82039:\nreturn 12;\ncase 67636:\nreturn 12;\ncase 67637:\nreturn 12;\ncase 82033:\nreturn 11;\ncase 82000:\nreturn 11;\ncase 82034:\nreturn 11;\ncase 82001:\nreturn 11;\ncase 82004:\nreturn 10;\ncase 82047:\nreturn 9;\ncase 82050:\nreturn 8;\ncase 82044:\nreturn 7;\ncase 82005:\nreturn 6;\ncase 82051:\nreturn 5;\n}\nTHROW_RANGE('Unknown operator', $tp_tokenStart, $tp_tokenStop);\n}\nfunction continueParsingBinOp(lexerFlags, otherStrength) {\nswitch (tok_getType()) {\ncase 82033:\nreturn 11 > otherStrength;\ncase 82000:\nreturn 11 > otherStrength;\ncase 82034:\nreturn 11 > otherStrength;\ncase 82001:\nreturn 11 > otherStrength;\ncase 82005:\nreturn 6 > otherStrength;\ncase 82051:\nreturn 5 > otherStrength;\ncase 82013:\nreturn 14 > otherStrength;\ncase 82017:\nreturn 14 > otherStrength;\ncase 82027:\nreturn 12 > otherStrength;\ncase 82036:\nreturn 12 > otherStrength;\ncase 82029:\nreturn 12 > otherStrength;\ncase 82039:\nreturn 12 > otherStrength;\ncase 82009:\nreturn 15 > otherStrength;\ncase 82023:\nreturn 15 > otherStrength;\ncase 82002:\nreturn 15 > otherStrength;\ncase 82028:\nreturn 13 > otherStrength;\ncase 82037:\nreturn 13 > otherStrength;\ncase 82038:\nreturn 13 > otherStrength;\ncase 67636:\nif ((lexerFlags & 32) === 32) {\nreturn false;\n}\nreturn 12 > otherStrength;\ncase 67637:\nreturn 12 > otherStrength;\ncase 82004:\nreturn 10 > otherStrength;\ncase 82047:\nreturn 9 > otherStrength;\ncase 82050:\nreturn 8 > otherStrength;\ncase 82044:\nreturn 7 > otherStrength;\ncase 82010:\nif (!allowExponentiation) {\nreturn THROW_RANGE('`**` was introduced in ES7', tok_getStart(), tok_getStop());\n}\nreturn true;\n}\nreturn false;\n}\nfunction parseValue(lexerFlags, allowAssignment, isNewArg, leftHandSideExpression, astProp) {\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet assignable = parseValueHeadBody(lexerFlags, false, isNewArg, allowAssignment, leftHandSideExpression, astProp);\nreturn parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, assignable, isNewArg, leftHandSideExpression, astProp);\n}\nfunction parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, allowAssignment, astProp) {\nlet assignable = parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, 4, allowAssignment, false, astProp);\nreturn parseValueTail(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, assignable, 4, false, astProp);\n}\nfunction parseValueHeadBody(lexerFlags, maybe, isNewArg, allowAssignment, leftHandSideExpression, astProp) {\nlet start_for_assert;\nif (isIdentToken(tok_getType())) {\nreturn parseValueHeadBodyIdent(lexerFlags, isNewArg, 0, allowAssignment, leftHandSideExpression, astProp);\n}\nif (isNumberStringRegex(tok_getType())) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nreturn 16;\n}\nif (isTemplateStart(tok_getType())) {\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nparseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, astProp);\nreturn 16;\n}\nif (isPunctuatorToken(tok_getType())) {\nif (tok_getType() === 16513) {\nlet skipInit = ((((((allowAssignment === true) && (leftHandSideExpression === false))) && (isNewArg === 4)))? true : false);\nlet wasDestruct = parseObjectOuter(lexerFlags, null, 0, skipInit, undefined, undefined, astProp);\nreturn _parseValueHeadBodyAfterObjArr(wasDestruct);\n}\nif (tok_getType() === 16509) {\nlet skipInit = ((((((allowAssignment === true) && (leftHandSideExpression === false))) && (isNewArg === 4)))? true : false);\nlet wasDestruct = parseArrayOuter(lexerFlags, null, 0, skipInit, undefined, undefined, astProp);\nreturn _parseValueHeadBodyAfterObjArr(wasDestruct);\n}\nif (tok_getType() === 16471) {\nreturn parseGroupToplevels(lexerFlags, 2, allowAssignment, 0, 0, 0, 0, 0, '', false, leftHandSideExpression, astProp);\n}\nif (tok_getType() === 16478) {\nreturn parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, '++', astProp);\n}\nif (tok_getType() === 16482) {\nreturn parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, '--', astProp);\n}\nif (tok_getType() === 82013) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '+', astProp);\n}\nif (tok_getType() === 82017) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '-', astProp);\n}\nif (tok_getType() === 16463) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '!', astProp);\n}\nif (tok_getType() === 16518) {\nreturn parseUnary(lexerFlags, isNewArg, leftHandSideExpression, '~', astProp);\n}\n}\nif (maybe === false) {\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Unexpected spread/rest dots', tok_getStart(), tok_getStart() + 1);\n}\nif (tok_getType() === 16485) {\nreturn THROW_RANGE('Unexpected dot', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('Expected to parse a value', tok_getStart(), tok_getStop());\n}\nreturn 16;\n}\nfunction _parseValueHeadBodyAfterObjArr(wasDestruct) {\nif ((wasDestruct & 4) === 4) {\nreturn THROW_RANGE('Found a struct that must be destructured but was not', tok_getStart(), tok_getStop());\n}\nlet assignable = copyPiggies(0, wasDestruct);\nif ((wasDestruct & 1) === 0) {\nreturn setAssignable(assignable);\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseValueHeadBodyIdent(lexerFlags, isNewArg, bindingType, allowAssignment, leftHandSideExpression, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, leftHandSideExpression);\nreturn parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, isNewArg, allowAssignment, leftHandSideExpression, astProp);\n}\nfunction parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, isNewArg, allowAssignment, leftHandSideExpression, astProp) {\nswitch ($tp_ident_type) {\ncase 2072:\n{\nif (tok_getType() === 16499) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `arguments` as arg name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, true, 3, 0, astProp);\n}\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn verifyEvalArgumentsVar(lexerFlags);\n}\ncase 2074:\nreturn parseAsyncExpression(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, isNewArg, false, allowAssignment, leftHandSideExpression, astProp);\ncase 2075:\nreturn parseAwait(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, isNewArg, allowAssignment, astProp);\ncase 2079:\nreturn parseClassExpression(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2084:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'delete', isNewArg, astProp);\ncase 2088:\n{\nif (tok_getType() === 16499) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `eval` as arg name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, true, 3, 0, astProp);\n}\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn verifyEvalArgumentsVar(lexerFlags);\n}\ncase 2091:\nreturn parseFalseKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2095:\nparseFunctionExpression(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\nreturn 16;\ncase 2099:\nif (tok_getType() === 16471) {\nreturn parseDynamicImport(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, astProp);\n}\nreturn THROW_RANGE('Import keyword only allowed on toplevel or in a dynamic import', $tp_ident_start, $tp_ident_stop);\ncase 2103:\n;\nif (((bindingType === 6) || (bindingType === 7))) {\nreturn THROW_RANGE('Can not use `let` when binding through `let` or `const`', $tp_ident_start, $tp_ident_stop);\n}\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Can not use `let` as variable name in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nreturn parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\ncase 2104:\nlet newAssignable = parseNewKeyword(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp);\nreturn setNotAssignable(newAssignable);\ncase 2105:\nreturn parseNullKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2114:\nreturn parseSuperKeyword(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, astProp);\ncase 2119:\nreturn parseTrueKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2117:\nreturn parseThisKeyword($tp_ident_start, $tp_ident_line, $tp_ident_column, astProp);\ncase 2121:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'typeof', isNewArg, astProp);\ncase 2123:\n;\nreturn _parseUnary(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 'void', isNewArg, astProp);\ncase 2126:\nreturn parseYield(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, astProp);\n}\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nreturn parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\n}\nfunction verifyEvalArgumentsVar(lexerFlags) {\nif ((lexerFlags & 8192) === 0) return 32;\nif (isAnyAssignmentOp()) {\nreturn THROW_RANGE('Cannot assign to `eval` and `arguments` in strict mode', tok_getStart(), tok_getStop());\n}\nif (((tok_getType() === 16478) || (tok_getType() === 16482))) {\nreturn THROW_RANGE('Cannot assign to `eval` and `arguments` in strict mode', tok_getStart(), tok_getStop());\n}\nreturn 16;\n}\nfunction parseTrueKeyword($tp_true_start, $tp_true_line, $tp_true_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'BooleanLiteral', loc:AST_getClosedLoc($tp_true_start, $tp_true_line, $tp_true_column), value:true});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_true_start, $tp_true_line, $tp_true_column), value:true, raw:'true'});\n}\nreturn 16;\n}\nfunction parseFalseKeyword($tp_false_start, $tp_false_line, $tp_false_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'BooleanLiteral', loc:AST_getClosedLoc($tp_false_start, $tp_false_line, $tp_false_column), value:false});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_false_start, $tp_false_line, $tp_false_column), value:false, raw:'false'});\n}\nreturn 16;\n}\nfunction parseNullKeyword($tp_null_start, $tp_null_line, $tp_null_column, astProp) {\nif (babelCompat) {\nAST_setNode(astProp, {type:'NullLiteral', loc:AST_getClosedLoc($tp_null_start, $tp_null_line, $tp_null_column)});\n} else {\nAST_setNode(astProp, {type:'Literal', loc:AST_getClosedLoc($tp_null_start, $tp_null_line, $tp_null_column), value:null, raw:'null'});\n}\nreturn 16;\n}\nfunction parseSuperKeyword(lexerFlags, $tp_super_start, $tp_super_stop, $tp_super_line, $tp_super_column, astProp) {\nAST_setNode(astProp, {type:'Super', loc:AST_getClosedLoc($tp_super_start, $tp_super_line, $tp_super_column)});\nif (tok_getType() === 16471) {\nif ((lexerFlags & 16384) === 0) {\nreturn THROW_RANGE('Can only use `super()` in constructors of classes that extend another class', $tp_super_start, tok_getStop());\n}\nreturn 16;\n}\nif (((tok_getType() === 16509) || (tok_getType() === 16485))) {\nif ((lexerFlags & 32768) === 0) {\nif (tok_getType() === 16509) {\nreturn THROW_RANGE('Can only use `super[foo]` in class or object methods or in arrows nested in those methods/arrows', $tp_super_start, tok_getStop());\n} else {\nreturn THROW_RANGE('Can only use `super.foo` in class or object methods or in arrows nested in those methods/arrows', $tp_super_start, tok_getStop());\n}\n}\nreturn 16;\n}\nreturn THROW_RANGE('The `super` keyword can only be used as call or member expression', $tp_super_start, $tp_super_stop);\n}\nfunction parseNewKeyword(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp) {\nif (tok_getType() === 16485) return parseNewDotTarget(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp);\nreturn parseNewExpression(lexerFlags, $tp_new_start, $tp_new_line, $tp_new_column, astProp);\n}\nfunction parseNewDotTarget(lexerFlags, $tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon, astProp) {\nif ((lexerFlags & 2) === 0) {\nreturn THROW_RANGE('Must be inside/nested a regular function to use `new.target`', $tp_new_start, tok_getStop());\n}\nskipToTargetOrDie(lexerFlags);\nlet $tp_property_line = tok_getLine();\nlet $tp_property_column = tok_getColumn();\nlet $tp_property_start = tok_getStart();\nlet $tp_property_stop = tok_getStop();\nlet $tp_property_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'MetaProperty', loc:AST_getClosedLoc($tp_new_start, $tp_new_line, $tp_new_column), meta:AST_getIdentNode($tp_new_start, $tp_new_stop, $tp_new_line, $tp_new_column, $tp_new_canon), property:AST_getIdentNode($tp_property_start, $tp_property_stop, $tp_property_line, $tp_property_column, $tp_property_canon)});\nreturn 16;\n}\nfunction parseNewExpression(lexerFlags, $tp_new_start, $tp_new_line, $tp_new_column, astProp) {\nAST_open(astProp, {type:'NewExpression', loc:undefined, arguments:[], callee:undefined});\nif ((isIdentToken(tok_getType()) && (tok_getType() === 2099))) {\nreturn THROW_RANGE('Cannot use dynamic import as an argument to `new`, the spec simply does not allow it', $tp_new_start, tok_getStop());\n}\nlet assignableForPiggies = parseValue(lexerFlags, false, 3, false, 'callee');\nAST_close($tp_new_start, $tp_new_line, $tp_new_column);\nreturn setNotAssignable(assignableForPiggies);\n}\nfunction parseThisKeyword($tp_this_start, $tp_this_line, $tp_this_column, astProp) {\nAST_setNode(astProp, {type:'ThisExpression', loc:AST_getClosedLoc($tp_this_start, $tp_this_line, $tp_this_column)});\nreturn 16;\n}\nfunction parseUnary(lexerFlags, isNewArg, leftHandSideExpression, opName, astProp) {\nlet $tp_unary_line = tok_getLine();\nlet $tp_unary_column = tok_getColumn();\nlet $tp_unary_start = tok_getStart();\nlet $tp_unary_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('The unary expression `' + opName) + '` is not allowed here', $tp_unary_start, $tp_unary_stop);\n}\nskipToExpressionStart(lexerFlags);\nreturn _parseUnary(lexerFlags, $tp_unary_start, $tp_unary_stop, $tp_unary_line, $tp_unary_column, opName, isNewArg, astProp);\n}\nfunction _parseUnary(lexerFlags, $tp_unary_start, $tp_unary_stop, $tp_unary_line, $tp_unary_column, opName, isNewArg, astProp) {\nif (isNewArg === 3) {\nreturn THROW_RANGE(('Cannot `' + opName) + '` inside `new`', $tp_unary_start, $tp_unary_stop);\n}\nAST_open(astProp, {type:'UnaryExpression', loc:undefined, operator:opName, prefix:true, argument:undefined});\nlet assignable = parseValue(lexerFlags, false, 4, false, 'argument');\nif ((lexerFlags & 8192) === 8192) {\nif (((opName === 'delete') && (_path[_path.length - 1].argument.type === 'Identifier'))) {\nreturn THROW_RANGE('Cannot delete an identifier without tail, in strict mode', $tp_unary_start, $tp_unary_stop);\n}\n}\nAST_close($tp_unary_start, $tp_unary_line, $tp_unary_column);\nif (tok_getType() === 82010) {\nreturn THROW_RANGE('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)', tok_getStart(), tok_getStop());\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseUpdatePrefix(lexerFlags, isNewArg, leftHandSideExpression, opName, astProp) {\nlet $tp_punc_line = tok_getLine();\nlet $tp_punc_column = tok_getColumn();\nlet $tp_punc_start = tok_getStart();\nlet $tp_punc_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('An update expression `' + opName) + '` is not allowed here', $tp_punc_start, $tp_punc_stop);\n}\nif (isNewArg === 3) {\nreturn THROW_RANGE(('Cannot `new` on a `' + opName) + '` expr', $tp_punc_start, $tp_punc_stop);\n}\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'UpdateExpression', loc:undefined, argument:undefined, operator:opName, prefix:true});\nlet assignable = parseValue(lexerFlags, false, 4, false, 'argument');\nAST_throwIfIllegalUpdateArg('argument');\nAST_close($tp_punc_start, $tp_punc_line, $tp_punc_column);\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Cannot inc/dec a non-assignable value as prefix', $tp_punc_start, $tp_punc_stop);\n}\nreturn setNotAssignable(assignable);\n}\nfunction parseYield(lexerFlags, $tp_yieldIdent_type, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, $tp_yieldIdent_canon, allowAssignment, astProp) {\nif ((lexerFlags & 128) !== 0) {\nreturn parseYieldKeyword(lexerFlags, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, allowAssignment, astProp);\n}\nreturn parseYieldVarname(lexerFlags, $tp_yieldIdent_type, $tp_yieldIdent_start, $tp_yieldIdent_stop, $tp_yieldIdent_line, $tp_yieldIdent_column, $tp_yieldIdent_canon, allowAssignment, astProp);\n}\nfunction parseYieldKeyword(lexerFlags, $tp_yield_start, $tp_yield_stop, $tp_yield_line, $tp_yield_column, allowAssignment, astProp) {\nif ((lexerFlags & 64) === 64) {\nreturn THROW_RANGE('The `yield` keyword in arg default must be a var name but that is not allowed inside a generator', $tp_yield_start, $tp_yield_stop);\n}\nif (allowAssignment === false) {\nreturn THROW_RANGE('Did not expect to parse an AssignmentExpression but found `yield`', $tp_yield_start, $tp_yield_stop);\n}\nAST_open(astProp, {type:'YieldExpression', loc:undefined, delegate:undefined, argument:undefined});\nif (((tok_getNlwas() === true) && isRegexToken(tok_getType()))) {\nAST_set('delegate', false);\nAST_set('argument', null);\n} else if (tok_getType() === 82009) {\nAST_set('delegate', true);\nparseYieldStarArgument(lexerFlags, $tp_yield_start, 'argument');\n} else if (tok_getType() === 82010) {\nreturn THROW_RANGE('Cannot use `yield` to the left of the `**` operator', $tp_yield_start, $tp_yield_stop);\n} else {\nAST_set('delegate', false);\nparseYieldArgument(lexerFlags, 'argument');\n}\nAST_close($tp_yield_start, $tp_yield_line, $tp_yield_column);\nif (tok_getType() === 16506) {\nreturn THROW_RANGE('Can not have a `yield` expression on the left side of a ternary', $tp_yield_start, $tp_yield_stop);\n}\nreturn 144;\n}\nfunction parseYieldStarArgument(lexerFlags, $tp_yield_start, astProp) {\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('A newline after `yield` is illegal for `yield *`', $tp_yield_start, tok_getStart());\n}\nskipToExpressionStart(lexerFlags);\nlet $tp_valueStart_line = tok_getLine();\nlet $tp_valueStart_column = tok_getColumn();\nlet $tp_valueStart_start = tok_getStart();\nlet $tp_valueStart_stop = tok_getStop();\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, astProp);\n}\nfunction parseYieldVarname(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, astProp) {\nif ((lexerFlags & 8192) === 8192) {\nreturn THROW_RANGE('Cannot use `yield` outside of generator functions when in strict mode', $tp_ident_start, $tp_ident_stop);\n}\nlet assignableFlags = parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 32, allowAssignment, astProp);\nreturn copyPiggies(32, assignableFlags);\n}\nfunction parseYieldArgument(lexerFlags, astProp) {\nlet $tp_yieldArgStart_line = tok_getLine();\nlet $tp_yieldArgStart_column = tok_getColumn();\nlet $tp_yieldArgStart_start = tok_getStart();\nlet $tp_yieldArgStart_stop = tok_getStop();\nif (tok_getNlwas() === true) {\nAST_set(astProp, null);\nreturn;\n}\nlet assignable = parseValueHeadBody(lexerFlags, true, 4, true, false, astProp);\nif (tok_getStart() === $tp_yieldArgStart_start) {\nAST_set(astProp, null);\nreturn;\n}\nassignable = parseValueTail(lexerFlags, $tp_yieldArgStart_start, $tp_yieldArgStart_line, $tp_yieldArgStart_column, assignable, 4, false, astProp);\nparseExpressionFromOp(lexerFlags, $tp_yieldArgStart_start, $tp_yieldArgStart_stop, $tp_yieldArgStart_line, $tp_yieldArgStart_column, assignable, astProp);\n}\nfunction parseIdentOrParenlessArrow(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, assignable, allowAssignment, astProp) {\nif (tok_getType() === 16499) {\nreturn parseArrowParenlessFromPunc(lexerFlags, $tp_ident_start, $tp_ident_line, $tp_ident_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, 1, 0, astProp);\n} else {\nAST_setIdent(astProp, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nreturn assignable;\n}\n}\nfunction parseArrowParenlessFromPunc(lexerFlags, $tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, allowAssignment, wasSimple, $tp_async_type, astProp) {\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif ((((lexerFlags & 128) === 128) && ($tp_ident_type === 2126))) {\nreturn THROW_RANGE('Arrows cannot be generators and parenless `yield` param in a generator would be parsing a yield expression and fail at the arrow', $tp_arrow_start, $tp_arrow_stop);\n}\nfatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 1, lexerFlags);\nif (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nwasSimple = 3;\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow is a restricted production and there can not be a newline before `=>` token', $tp_arrow_start, $tp_arrow_stop);\n}\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, async:$tp_async_type === 2074, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)], id:null, generator:false, async:$tp_async_type === 2074, expression:undefined, body:undefined});\n}\nlet arrowScoop = SCOPE_createGlobal('parseArrowParenlessFromPunc');\nlet paramScoop = SCOPE_addLayer(arrowScoop, 11, 'parseArrowParenlessFromPunc(arg)');\nSCOPE_addLexBinding(paramScoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 1, 1);\nparseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, wasSimple);\nAST_close($tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column);\nreturn 1040;\n}\nfunction parseTickExpression(lexerFlags, $tp_tick_start, $tp_tick_stop, $tp_tick_line, $tp_tick_column, astProp) {\nAST_open(astProp, {type:'TemplateLiteral', loc:undefined, expressions:[], quasis:[]});\nlet awaitYieldFlagsFromAssignable = 8;\nif (tok_getType() === 524308) {\nparseQuasiPart(lexerFlags, true, false);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\nreturn awaitYieldFlagsFromAssignable;\n}\nif (tok_getType() === 524305) {\nparseQuasiPart(lexerFlags, false, false);\nlet tmpLexerFlags = (((lexerFlags | 2048) | 4096) | 1824) ^ 1824;\nlet wasTail = true;\ndo {\nawaitYieldFlagsFromAssignable |= parseExpressions(tmpLexerFlags, 'expressions');\nwasTail = ((((tok_getType() === 524307) || (tok_getType() === 1572883)))? true : false);\nparseQuasiPart(lexerFlags, wasTail, false);\n} while (wasTail === false);\nAST_close($tp_tick_start, $tp_tick_line, $tp_tick_column);\nreturn awaitYieldFlagsFromAssignable;\n}\nreturn THROW_RANGE('Template contained bad escape, which is only valid in _tagged_ templates (and only since ES9/ES2018)', $tp_tick_start, $tp_tick_stop);\n}\nfunction parseQuasiPart(lexerFlags, wasTail, allowBadEscapes) {\nlet $tp_tick_type = tok_getType();\nlet $tp_tick_line = tok_getLine();\nlet $tp_tick_column = tok_getColumn();\nlet $tp_tick_start = tok_getStart();\nlet $tp_tick_stop = tok_getStop();\nlet $tp_tick_canon = tok_getCanoN();\nlet hasDoubleStart = false;\nlet noCooked = false;\nif (isBadTickToken(tok_getType())) {\nif (!allowBadEscapes) {\nreturn THROW_RANGE('Template contained an illegal escape, these are only allowed in _tagged_ templates in >=ES2018', $tp_tick_start, $tp_tick_stop);\n}\nnoCooked = true;\n}\nif (((((((tok_getType() === 524308) || (tok_getType() === 524307))) || (tok_getType() === 1572884))) || (tok_getType() === 1572883))) {\nskipDiv(lexerFlags);\n} else if (((((((tok_getType() === 524305) || (tok_getType() === 524306))) || (tok_getType() === 1572881))) || (tok_getType() === 1572882))) {\nskipToExpressionStart(lexerFlags);\nhasDoubleStart = true;\n} else {\nreturn THROW_RANGE('The first token after the template expression should be a continuation of the template', $tp_tick_start, $tp_tick_stop);\n}\nlet closeWrapperLen = (((((((($tp_tick_type === 524305) || ($tp_tick_type === 524306))) || ($tp_tick_type === 1572881))) || ($tp_tick_type === 1572882)))? 2 : 1);\nlet quasiValue = tok_sliceInput($tp_tick_start + 1, $tp_tick_stop - closeWrapperLen);\nif ((((acornCompat || babelCompat)) || templateNewlineNormalization)) {\nquasiValue = quasiValue.replace(/\\r\\n?/g, '\\n');\n}\nlet cookedValue = (noCooked? null : $tp_tick_canon);\nAST_open('quasis', {type:'TemplateElement', loc:undefined, tail:wasTail === true, value:{raw:quasiValue, cooked:cookedValue}});\nAST_closeTemplateElement(hasDoubleStart, $tp_tick_start, $tp_tick_line, $tp_tick_column + 1);\n}\nfunction parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, leftHandSideExpression, astProp) {\nif ((assignable & 1024) === 1024) return assignable;\nswitch (tok_getType()) {\ncase 16485:\nreturn _parseValueTailDotProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16509:\nreturn _parseValueTailDynamicProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16471:\nreturn _parseValueTailCall(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 82043:\nif (isNewArg === 3) {\nreturn THROW_RANGE('Cannot use `?.` in the arg of `new`', tok_getStart(), tok_getStop());\n}\nreturn parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, astProp);\ncase 524308:\n\ncase 524305:\n\ncase 1572884:\n\ncase 1572881:\nreturn _parseValueTailTemplate(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp);\ncase 16478:\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn parseValueTailUpdateExpression(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, leftHandSideExpression, '++', astProp);\ncase 16482:\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn parseValueTailUpdateExpression(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, leftHandSideExpression, '--', astProp);\n}\nif (isNewArg === 3) return _parseValueTailNewArg(assignable);\nreturn assignable;\n}\nfunction parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, astProp) {\ndo {\nlet $tp_next_type = tok_getType();\nswitch ($tp_next_type) {\ncase 82043:\nskipAny(lexerFlags);\nlet $tp_q_type = tok_getType();\nif (isIdentToken($tp_q_type)) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nif (!isIdentToken($tp_ident_type)) THROW_RANGE('Expected ident after dot', $tp_ident_start, $tp_ident_stop);\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'OptionalMemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), optional:true, computed:false, object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\n} else if ($tp_q_type === 16509) {\nskipAny(lexerFlags);\nAST_wrapClosedCustom(astProp, {type:'OptionalMemberExpression', loc:undefined, optional:true, computed:true, object:undefined, property:undefined}, 'object');\nparseExpression(lexerFlags, 'property');\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing `]` char of a dynamic property, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\n} else if ($tp_q_type === 16471) {\nAST_wrapClosedCustom(astProp, {type:'OptionalCallExpression', loc:undefined, optional:true, callee:undefined, arguments:[]}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\n} else if (isTemplateStart($tp_q_type)) {\nreturn THROW_RANGE('An value containing the optional chaining operator cannot be followed by a template', tok_getStart(), tok_getStop());\n} else if ($tp_q_type === 82043) {\nreturn THROW_RANGE('Cannot cannot `?.?.`, must have something in between', tok_getStart(), tok_getStop());\n}\nbreak;\ncase 16485:\nskipAny(lexerFlags);\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nif (!isIdentToken($tp_ident_type)) THROW_RANGE('Expected ident after dot', $tp_ident_start, $tp_ident_stop);\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'OptionalMemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), optional:false, computed:false, object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon)});\nbreak;\ncase 16471:\nAST_wrapClosedCustom(astProp, {type:'OptionalCallExpression', loc:undefined, optional:false, callee:undefined, arguments:undefined}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nbreak;\ncase 16509:\nskipAny(lexerFlags);\nAST_wrapClosedCustom(astProp, {type:'OptionalMemberExpression', loc:undefined, optional:false, computed:true, object:undefined, property:undefined}, 'object');\nparseExpression(lexerFlags, 'property');\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing `]` char of a dynamic property, found`' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nassignable = parseOptionalValueTailOuter(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, 'property');\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nbreak;\ndefault:\nif (isTemplateStart($tp_next_type)) {\nreturn THROW_RANGE('An value containing the optional chaining operator cannot be followed by a template', tok_getStart(), tok_getStop());\n}\nreturn setNotAssignable(assignable);\n}\n} while (true);\n}\nfunction _parseValueTailDotProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nskipToIdentOrDie(lexerFlags | 65536);\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipDiv(lexerFlags);\nAST_setNode(astProp, {type:'MemberExpression', loc:AST_getClosedLoc($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column), object:AST_popNode(astProp), property:AST_getIdentNode($tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon), computed:false});\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailDynamicProperty(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nAST_wrapClosedCustom(astProp, {type:'MemberExpression', loc:undefined, object:undefined, property:undefined, computed:true}, 'object');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpressions(((lexerFlags | 4096) | 1824) ^ 1824, 'property');\nassignable = mergeAssignable(nowAssignable, assignable);\nassignable = (assignable | 1024) ^ 1024;\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing bracket `]` for a dynamic property, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailCall(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nif (isNewArg === 3) {\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nif (tok_getType() === 16499) {\nreturn THROW_RANGE('The `new` keyword can not be applied to an arrow', tok_getStart(), tok_getStop());\n}\nassignable = mergeAssignable(nowAssignable, assignable);\nassignable = setNotAssignable(assignable);\nreturn assignable;\n}\nAST_wrapClosedCustom(astProp, {type:'CallExpression', loc:undefined, callee:undefined, arguments:[]}, 'callee');\nlet nowAssignable = parseCallArgs(lexerFlags, 'arguments');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setNotAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailTemplate(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, assignable, isNewArg, astProp) {\nAST_wrapClosedCustom(astProp, {type:'TaggedTemplateExpression', loc:undefined, tag:undefined, quasi:undefined}, 'tag');\nlet $tp_Quasi_line = tok_getLine();\nlet $tp_Quasi_column = tok_getColumn();\nlet $tp_Quasi_start = tok_getStart();\nAST_open('quasi', {type:'TemplateLiteral', loc:undefined, expressions:[], quasis:[]});\n_parseValueTailTemplateRest(lexerFlags);\nAST_close($tp_Quasi_start, $tp_Quasi_line, $tp_Quasi_column);\nAST_close($tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column);\nreturn parseValueTail(lexerFlags, $tp_valueFirst_start, $tp_valueFirst_line, $tp_valueFirst_column, setNotAssignable(assignable), isNewArg, false, astProp);\n}\nfunction _parseValueTailTemplateRest(lexerFlags) {\nlet awaitYieldFlagsFromAssignable = 8;\nif (((tok_getType() === 524308) || (tok_getType() === 1572884))) {\nparseQuasiPart(lexerFlags, true, allowBadEscapesInTaggedTemplates);\nreturn;\n}\nparseQuasiPart(lexerFlags, false, allowBadEscapesInTaggedTemplates);\nlet tmpLexerFlags = (((lexerFlags | 2048) | 4096) | 1824) ^ 1824;\nlet wasTail = true;\ndo {\nawaitYieldFlagsFromAssignable |= parseExpressions(tmpLexerFlags, 'expressions');\nwasTail = ((((tok_getType() === 524307) || (tok_getType() === 1572883)))? true : false);\nparseQuasiPart(lexerFlags, wasTail, allowBadEscapesInTaggedTemplates);\n} while (wasTail === false);\n}\nfunction _parseValueTailNewArg(assignable) {\nreturn setNotAssignable(assignable);\n}\nfunction parseValueTailUpdateExpression(lexerFlags, $tp_argStart_start, $tp_argStart_line, $tp_argStart_column, assignable, leftHandSideExpression, opName, astProp) {\nlet $tp_op_start = tok_getStart();\nlet $tp_op_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE(('A `' + opName) + '` update expression is not allowed here', $tp_op_start, $tp_op_stop);\n}\nif (tok_getNlwas() === true) {\nif ((lexerFlags & 4096) === 4096) {\nreturn THROW_RANGE(('The postfix `' + opName) + '` is a restricted production so ASI must apply but that is not valid in this context', $tp_op_start, $tp_op_stop);\n}\nreturn assignable;\n}\nif (notAssignable(assignable)) {\nreturn THROW_RANGE(('Cannot postfix `' + opName) + '` a non-assignable value', $tp_op_start, $tp_op_stop);\n}\nAST_throwIfIllegalUpdateArg(astProp);\nskipDiv(lexerFlags);\nAST_setNodeDangerously(astProp, {type:'UpdateExpression', loc:AST_getClosedLoc($tp_argStart_start, $tp_argStart_line, $tp_argStart_column), argument:AST_popNode(astProp), operator:opName, prefix:false});\nreturn 16;\n}\nfunction parseCallArgs(lexerFlags, astProp) {\nskipToExpressionStartGrouped(lexerFlags);\nlexerFlags = ((lexerFlags | 4096) | 32) ^ 32;\nlet assignable = 8;\nif (tok_getType() === 16472) {\nskipDiv(lexerFlags);\n} else {\ndo {\nif (tok_getType() === 16486) {\nlet $tp_spread_line = tok_getLine();\nlet $tp_spread_column = tok_getColumn();\nlet $tp_spread_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nAST_open(astProp, {type:'SpreadElement', loc:undefined, argument:undefined});\nlet nowAssignable = parseExpression(lexerFlags, 'argument');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_spread_start, $tp_spread_line, $tp_spread_column);\n} else {\nlet nowAssignable = parseExpression(lexerFlags, astProp);\nassignable = mergeAssignable(nowAssignable, assignable);\n}\nif (tok_getType() !== 16480) break;\nlet $tp_comma_start = tok_getStart();\nlet $tp_comma_stop = tok_getStop();\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif (allowTrailingFunctionComma) break;\nreturn THROW_RANGE('Targeted language version does not support trailing call arg comma', $tp_comma_start, $tp_comma_stop);\n}\n} while (true);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Expecting closing paren `)` for the call, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nfunction parseDynamicImportStatement(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp) {\nAST_open(astProp, {type:'ExpressionStatement', loc:undefined, expression:undefined});\nparseDynamicImport(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, 'expression');\nlet assignable = parseValueTail(lexerFlags, $tp_import_start, $tp_import_line, $tp_import_column, 16, 4, false, 'expression');\nparseExpressionFromOp(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, assignable, 'expression');\nparseSemiOrAsi(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\n}\nfunction parseDynamicImport(lexerFlags, $tp_import_start, $tp_import_stop, $tp_import_line, $tp_import_column, astProp) {\nif (!allowDynamicImport) {\nreturn THROW_RANGE('Dynamic import syntax not supported. Requires version ES2020+ / ES11+.', $tp_import_start, $tp_import_stop);\n}\nif (acornCompat) {\nAST_open(astProp, {type:'ImportExpression', loc:undefined, source:undefined});\n} else {\nAST_open(astProp, {type:'CallExpression', loc:undefined, callee:undefined, arguments:[]});\nAST_setNode('callee', {type:'Import', loc:AST_getClosedLoc($tp_import_start, $tp_import_line, $tp_import_column)});\n}\nskipToExpressionStart(lexerFlags);\nlet assignable = parseExpression(lexerFlags, (acornCompat? 'source' : 'arguments'));\nif (tok_getType() !== 16472) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Dynamic `import` only expected exactly one argument and does not allow for a trailing comma', $tp_import_start, tok_getStop());\n}\nif (tok_getType() === 67636) {\nreturn THROW_RANGE('The dynamic import syntax explicitly forbids the `in` operator', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE('The dynamic `import` argument was followed by unknown content', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_import_start, $tp_import_line, $tp_import_column);\nreturn assignable;\n}\nfunction parseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, paramsSimple) {\nskipToExpressionStart(lexerFlags);\nif (allowAssignment === false) {\nreturn THROW_RANGE('Was parsing a value that could not be AssignmentExpression but found an arrow', tok_getStart(), tok_getStop());\n}\nif (options_exposeScopes) AST_set('$scope', paramScoop);\nif (paramScoop.dupeParamErrorStart !== 0) {\nreturn THROW_RANGE('Arrow had duplicate params', paramScoop.dupeParamErrorStart - 1, paramScoop.dupeParamErrorStop);\n}\nlet insideForLhs = (lexerFlags & 32) === 32;\nlet arrowInheritedFlags = lexerFlags & 18;\nlexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, 0, $tp_async_type, true);\nlexerFlags |= arrowInheritedFlags;\nif (tok_getType() === 16513) {\nif (!babelCompat) AST_set('expression', false);\nlet arrowScoop = SCOPE_addLayer(paramScoop, 10, 'parseArrowFromPunc');\nparseFunctionBody(lexerFlags, arrowScoop, 1, paramsSimple, 0, 0, 0, 0, 0, '', true);\nif ((isRegexToken(tok_getType()) && (!tok_getNlwas()))) {\nTHROW_RANGE('Found a regex or division after an arrow, that is illegal', tok_getStart(), tok_getStop());\n}\n} else {\nif (insideForLhs) lexerFlags |= 32;\nif (!babelCompat) AST_set('expression', true);\nparseExpression(lexerFlags, 'body');\n}\n{\nlet $tp_error_type = tok_getType();\nlet $tp_error_start = tok_getStart();\nlet $tp_error_stop = tok_getStop();\nlet $tp_error_nl = tok_getNlwas();\nif ((insideForLhs && ($tp_error_type === 67636))) {\nreturn THROW_RANGE('Arrows cannot be lhs to for-in', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_type === 16485) {\nreturn THROW_RANGE('Block body arrows can not be immediately accessed without a group', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_nl) {\nif ($tp_error_type === 82023) {\nreturn THROW_RANGE('An arrow function can not be part of an operator to the right', $tp_error_start, $tp_error_stop);\n}\nreturn 1040;\n}\nif ($tp_error_type === 16471) {\nreturn THROW_RANGE('Block body arrows can not be immediately invoked without a group', $tp_error_start, $tp_error_stop);\n}\nif ($tp_error_type === 16509) {\nreturn THROW_RANGE('Block body arrows can not be immediately accessed without a group', $tp_error_start, $tp_error_stop);\n}\nif (isTemplateStart($tp_error_type)) {\nreturn THROW_RANGE('Block body arrows can not be immediately tagged without a group', $tp_error_start, $tp_error_stop);\n}\nif ((isAnyAssignmentOp() || (($tp_error_type & 65536) === 65536))) {\nreturn THROW_RANGE('An arrow function can not be part of an operator to the right', $tp_error_start, $tp_error_stop);\n}\nif ((($tp_error_type === 16478) || ($tp_error_type === 16482))) {\nreturn THROW_RANGE('An arrow function can not have a postfix update operator', $tp_error_start, $tp_error_stop);\n}\n}\nreturn 1040;\n}\nfunction parseGroupToplevels(lexerFlagsBeforeParen, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, $tp_async_type, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, newlineAfterAsync, leftHandSideExpression, astProp) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nskipToExpressionStartGrouped(lexerFlagsBeforeParen);\nlet $tp_firstTokenAfterParen_line = tok_getLine();\nlet $tp_firstTokenAfterParen_column = tok_getColumn();\nlet $tp_firstTokenAfterParen_start = tok_getStart();\nlet lexerFlags = ((lexerFlagsBeforeParen | 4096) | 1824) ^ 1824;\nlet arrowScoop = SCOPE_createGlobal('_parseGroupToplevels');\nlet paramScoop = SCOPE_addLayer(arrowScoop, 11, '_parseGroupToplevels(arg)');\nif (tok_getType() === 16472) {\nif ($tp_async_type === 2074) {\nskipDiv(lexerFlags);\nreturn parseAfterAsyncGroup(lexerFlagsBeforeParen, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, 1, false, newlineAfterAsync, true, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, 8, astProp);\n}\nskipToArrowOrDie(lexerFlags);\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nreturn THROW_RANGE('Arrow not allowed in this position', $tp_paren_start, $tp_arrow_stop);\n}\nlexerFlags = lexerFlagsBeforeParen;\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow token `=>` is a restricted production and cannot have a newline preceding it', $tp_arrow_start, $tp_arrow_stop);\n}\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:false, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:false, expression:undefined, body:undefined});\n}\nlet assignable = parseArrowFromPunc(lexerFlags, paramScoop, 0, allowAssignmentForGroupToBeArrow, 1);\nAST_close($tp_paren_start, $tp_paren_line, $tp_paren_column);\nreturn assignable;\n}\nlet foundSingleIdentWrap = false;\nlet rootAstProp = astProp;\nlet destructible = 0;\nlet assignable = 8;\nlet toplevelComma = false;\nlet wasSimple = 1;\nlet mustBeArrow = false;\nwhile (tok_getType() !== 16472) {\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet wasAssignment = tok_getType() === 49264;\nlet wasCommaOrEnd = ((tok_getType() === 16480) || (tok_getType() === 16472));\nlet exprAssignable = parseExpressionAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, 1, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nSCOPE_addLexBinding(paramScoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, 1, 1);\nif (wasAssignment) {\nwasSimple = 3;\n} else if (wasCommaOrEnd) {\nif (((!toplevelComma) && (tok_getType() === 16472))) {\nfoundSingleIdentWrap = true;\n}\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else if (isStrictOnlyKeyword($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon)) {\nwasSimple = 3;\n} else {\n\n}\n} else {\ndestructible |= 1;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_startOfPattern_line = tok_getLine();\nlet $tp_startOfPattern_column = tok_getColumn();\nlet $tp_startOfPattern_start = tok_getStart();\nlet $tp_startOfPattern_stop = tok_getStop();\ndestructible |= parseObjectOuter(lexerFlags, paramScoop, 1, true, undefined, undefined, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\ndestructible |= 1;\n}\nassignable = parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp);\nwasSimple = 3;\n} else if (tok_getType() === 16509) {\nlet $tp_startOfPattern_line = tok_getLine();\nlet $tp_startOfPattern_column = tok_getColumn();\nlet $tp_startOfPattern_start = tok_getStart();\nlet $tp_startOfPattern_stop = tok_getStop();\ndestructible |= parseArrayOuter(lexerFlags, paramScoop, 1, true, undefined, undefined, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\ndestructible |= 1;\n}\nassignable = parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp);\nwasSimple = 3;\n} else if (tok_getType() === 16486) {\nwasSimple = 3;\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, paramScoop, 16472, 1, $tp_async_type, undefined, undefined, astProp);\ndestructible |= subDestruct;\nif ($tp_async_type === 2074) {\nif (tok_getType() !== 16472) {\ndestructible |= 1;\n} else {\n\n}\n} else {\nif ((((subDestruct & 1) === 1) || (tok_getType() === 16480))) {\nreturn THROW_RANGE('The ... argument must be destructible in an arrow header, found something that was not destructible', tok_getStart(), tok_getStop());\n}\nmustBeArrow = true;\nbreak;\n}\n} else {\ndestructible |= 1;\nlet exprAssignable = parseExpression(lexerFlags, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nif (tok_getType() === 16480) {\nif (!toplevelComma) {\ntoplevelComma = true;\nAST_wrapClosedIntoArrayCustom(rootAstProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nastProp = 'expressions';\n}\nassignable = __parseExpressions(lexerFlags, assignable, astProp);\n}\nif (toplevelComma) {\nif (babelCompat) AST_set('extra', {parenthesized:true, parenStart:$tp_paren_start});\nAST_close($tp_firstTokenAfterParen_start, $tp_firstTokenAfterParen_line, $tp_firstTokenAfterParen_column);\nassignable = setNotAssignable(assignable);\n}\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Expected the closing paren `)` for the group, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nif ($tp_async_type === 2074) {\nif (tok_getType() === 16499) {\nreturn THROW_RANGE('The header of this async arrow contained something that is not valid a param', tok_getStart(), tok_getStop());\n}\nreturn parseAfterAsyncGroup(lexerFlagsBeforeParen, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, wasSimple, toplevelComma, newlineAfterAsync, false, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, rootAstProp);\n}\nif ((babelCompat && (!toplevelComma))) {\nAST_babelParenthesizesClosed($tp_paren_start, astProp);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nif (tok_getType() !== 16480) break;\nskipToExpressionStartGrouped(lexerFlags);\nif (tok_getType() === 16472) {\nif ($tp_async_type === 0) {\nif (allowTrailingFunctionComma) {\nmustBeArrow = true;\nbreak;\n}\nreturn THROW_RANGE('Encountered trailing comma in the toplevel of a group, this could be valid in arrows but not with the currently targeted language version', tok_getStart(), tok_getStop());\n}\n}\nif (!toplevelComma) {\ntoplevelComma = true;\nAST_wrapClosedIntoArrayCustom(rootAstProp, {type:'SequenceExpression', loc:undefined, expressions:undefined}, 'expressions');\nastProp = 'expressions';\n}\n}\nif (toplevelComma) {\nassignable = setNotAssignable(assignable);\nif (babelCompat) AST_set('extra', {parenthesized:true, parenStart:$tp_paren_start});\nAST_close($tp_firstTokenAfterParen_start, $tp_firstTokenAfterParen_line, $tp_firstTokenAfterParen_column);\n}\ndestructible = copyPiggies(destructible, assignable);\nif (tok_getType() !== 16472) {\nreturn THROW_RANGE(('Missing closing paren `)` for group, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nlexerFlags = lexerFlagsBeforeParen;\nverifyDestructible(destructible);\nlet isArrow = tok_getType() === 16499;\nif (isArrow) {\ndestructible |= 1024;\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (leftHandSideExpression === true) {\nlet $tp_errorOffset_start = (($tp_async_type === 2074)? $tp_async_start : $tp_paren_start);\nreturn THROW_RANGE('Arrow not allowed in this position', $tp_errorOffset_start, $tp_arrow_stop);\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Arrow is restricted production; cannot have newline before the arrow token', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 1) === 1) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('The left hand side of the async arrow is not destructible so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nreturn THROW_RANGE('The left hand side of the arrow is not destructible so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 2) === 2) {\nreturn THROW_RANGE('The left hand side of the arrow can only be destructed through assignment so arrow is illegal', $tp_arrow_start, $tp_arrow_stop);\n}\nif ((destructible & 64) !== 0) {\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('The parameter header of an async arrow cannot contain `await` as varname nor as a keyword', $tp_async_start, $tp_async_stop);\n}\nif ((lexerFlags & 8) !== 0) {\nreturn THROW_RANGE('The parameter header of an arrow inside an async function cannot contain `await` as varname nor as a keyword', tok_getStart(), tok_getStop());\n}\n}\nif ((destructible & 128) === 128) {\nreturn THROW_RANGE('The arguments of an arrow cannot contain a yield expression in their defaults', $tp_arrow_start, $tp_arrow_stop);\n}\n} else if ((((destructible & 4) === 4) || mustBeArrow)) {\nreturn THROW_RANGE('Group contained a value that must destruct but this was not an arrow so it is invalid', $tp_paren_start, tok_getStop());\n}\nif ($tp_async_type === 2074) {\ndestructible = copyPiggies(destructible, assignable);\nreturn parseAfterAsyncGroup(lexerFlags, paramScoop, asyncStmtOrExpr, allowAssignmentForGroupToBeArrow, wasSimple, toplevelComma, newlineAfterAsync, false, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, rootAstProp);\n}\nif (isArrow) {\nparseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, 0, $tp_paren_start, $tp_paren_line, $tp_paren_column, allowAssignmentForGroupToBeArrow, rootAstProp);\nassignable = copyPiggies(assignable, destructible);\nreturn 1040 | (assignable & 64);\n}\nif ((babelCompat && (!toplevelComma))) {\nAST_babelParenthesizesClosed($tp_paren_start, astProp);\n}\nreturn (assignable | 1024) ^ 1024;\n}\nfunction parseAfterPatternInGroup(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, destructible, astProp) {\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\nif ((destructible & 4) === 4) {\nreturn THROW_RANGE('Pattern can not have a tail but did not find a comma or closing paren of the arrow header', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_line, $tp_startOfPattern_column, 16, 4, false, astProp);\nassignable = mergeAssignable(exprAssignable, assignable);\nif (((tok_getType() !== 16480) && (tok_getType() !== 16472))) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_startOfPattern_start, $tp_startOfPattern_stop, $tp_startOfPattern_line, $tp_startOfPattern_column, assignable, astProp);\n}\n} else {\nassignable = setNotAssignable(assignable);\n}\nreturn assignable;\n}\nfunction parseAfterAsyncGroup(lexerFlags, paramScoop, fromStmtOrExpr, allowAssignment, wasSimple, toplevelComma, newlineAfterAsync, zeroArgs, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, assignable, astProp) {\nif (tok_getType() === 16499) {\nlet $tp_arrow_start = tok_getStart();\nlet $tp_arrow_stop = tok_getStop();\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('The arrow is a restricted production an there can not be a newline before `=>` token', $tp_arrow_start, $tp_arrow_stop);\n}\nif (newlineAfterAsync === true) {\nreturn THROW_RANGE('A newline after async is always a syntax error if the rhs turns to be an arrow function', $tp_arrow_start, $tp_arrow_stop);\n}\nif (zeroArgs) {\nparseArrowAfterAsyncNoArgGroup(lexerFlags, paramScoop, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp);\n} else {\nparseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, 2074, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp);\n}\n} else {\nif (zeroArgs) {\nAST_setNode(astProp, {type:'CallExpression', loc:AST_getClosedLoc($tp_async_start, $tp_async_line, $tp_async_column), callee:AST_getIdentNode($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon), arguments:[]});\n} else {\nAST_patchAsyncCall($tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, $tp_async_canon, astProp);\n}\nlet assignable = parseValueTail(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, 4, false, astProp);\nif (fromStmtOrExpr === 2) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_async_start, $tp_async_stop, $tp_async_line, $tp_async_column, assignable, astProp);\nif (tok_getType() === 16480) {\nassignable = _parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, assignable, astProp);\n}\nparseSemiOrAsi(lexerFlags);\n}\nreturn assignable;\n}\nif (fromStmtOrExpr === 2) {\nif (tok_getType() === 16480) {\n_parseExpressions(lexerFlags, $tp_async_start, $tp_async_line, $tp_async_column, 16, astProp);\n}\nparseSemiOrAsi(lexerFlags);\n}\nreturn 1040 | (assignable & 64);\n}\nfunction parseArrowAfterAsyncNoArgGroup(lexerFlags, paramScoop, $tp_async_start, $tp_async_line, $tp_async_column, allowAssignment, astProp) {\nif (babelCompat) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:true, body:undefined});\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, expression:undefined, body:undefined});\n} else {\nAST_open(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:[], id:null, generator:false, async:true, expression:undefined, body:undefined});\n}\nlet assignable = parseArrowFromPunc(lexerFlags, paramScoop, 2074, allowAssignment, 1);\nAST_close($tp_async_start, $tp_async_line, $tp_async_column);\nreturn assignable;\n}\nfunction parseArrowAfterGroup(lexerFlags, paramScoop, wasSimple, toplevelComma, $tp_async_type, $tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column, allowAssignment, astProp) {\nif (babelCompat) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, async:$tp_async_type === 2074, body:undefined}, 'params');\n} else if ((acornCompat && (!allowAsyncFunctions))) {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, expression:undefined, body:undefined}, 'params');\n} else {\nAST_wrapClosedIntoArrayCustom(astProp, {type:'ArrowFunctionExpression', loc:undefined, params:undefined, id:null, generator:false, async:$tp_async_type === 2074, expression:undefined, body:undefined}, 'params');\n}\nlet top = _path[_path.length - 1];\nif (toplevelComma) {\nlet params = top.params[top.params.length - 1];\ntop.params = params.expressions;\n}\nlet params = top.params;\nfor (let i = 0;i < params.length;++i) {\nAST__destruct(params[i], params, i);\n}\nparseArrowFromPunc(lexerFlags, paramScoop, $tp_async_type, allowAssignment, wasSimple);\nAST_close($tp_arrowStart_start, $tp_arrowStart_line, $tp_arrowStart_column);\n}\nfunction parseArrayOuter(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nlet destructible = parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp);\nreturn destructible;\n}\nfunction parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, _astProp) {\nlet lexerFlags = (lexerFlagsBeforeParen | 32) ^ 32;\nlet $tp_arrayOpen_line = tok_getLine();\nlet $tp_arrayOpen_column = tok_getColumn();\nlet $tp_arrayOpen_start = tok_getStart();\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_open(_astProp, {type:'ArrayExpression', loc:undefined, elements:[]});\nlet astProp = 'elements';\nlet destructible = 0;\nwhile (tok_getType() === 16480) {\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_add(astProp, null);\n}\nlet spreadStage = 0;\nlet assignableYieldAwaitState = 8;\nwhile (tok_getType() !== 16510) {\nlet $tp_elementStart_line = tok_getLine();\nlet $tp_elementStart_column = tok_getColumn();\nlet $tp_elementStart_start = tok_getStart();\nlet $tp_elementStart_stop = tok_getStop();\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet nextIsAssignment = tok_getType() === 49264;\nlet nextIsCommaOrEnd = ((tok_getType() === 16480) || (tok_getType() === 16510));\nlet leftAssignable = parseValueHeadBodyAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, 4, true, false, astProp);\nassignableYieldAwaitState |= leftAssignable;\nif (nextIsAssignment) {\nif (notAssignable(leftAssignable)) {\nreturn THROW_RANGE(('Cannot assign or destruct to keyword `' + tok_sliceInput($tp_ident_start, $tp_ident_stop)) + '`', $tp_ident_start, $tp_ident_stop);\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet rightAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_ident_start, $tp_ident_line, $tp_ident_column);\nassignableYieldAwaitState |= rightAssignable;\n} else if (nextIsCommaOrEnd) {\nif (notAssignable(leftAssignable)) {\ndestructible |= 1;\n} else {\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\n}\n} else {\nif (bindingType === 1) {\ndestructible |= 2;\n} else if (bindingType !== 0) {\ndestructible |= 1;\n}\nlet nowDestruct = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, leftAssignable, 1, 16510, astProp);\ndestructible |= nowDestruct;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_objOpen_line = tok_getLine();\nlet $tp_objOpen_column = tok_getColumn();\nlet $tp_objOpen_start = tok_getStart();\nlet $tp_objOpen_stop = tok_getStop();\nlet objDestructible = parseObjectAndAssign(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, astProp);\ndestructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_objOpen_start, $tp_objOpen_stop, $tp_objOpen_line, $tp_objOpen_column, (((objDestructible & 1) === 1)? 16 : 32), objDestructible, 16510, astProp);\n} else if (tok_getType() === 16509) {\nlet $tp_arrOpen_line = tok_getLine();\nlet $tp_arrOpen_column = tok_getColumn();\nlet $tp_arrOpen_start = tok_getStart();\nlet $tp_arrOpen_stop = tok_getStop();\nlet arrDestructible = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, astProp);\ndestructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_arrOpen_start, $tp_arrOpen_stop, $tp_arrOpen_line, $tp_arrOpen_column, (((arrDestructible & 1) === 1)? 16 : 32), arrDestructible, 16510, astProp);\n} else if (tok_getType() === 16486) {\nlet subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, 16510, bindingType, 0, exportedNames, exportedBindings, astProp);\ndestructible |= subDestruct;\nif (spreadStage === 0) spreadStage = 1;\n} else {\nlet $tp_exprStart_line = tok_getLine();\nlet $tp_exprStart_column = tok_getColumn();\nlet $tp_exprStart_start = tok_getStart();\nlet $tp_exprStart_stop = tok_getStop();\nlet wasParen = tok_getType() === 16471;\nlet assignable = parseValue(lexerFlags, true, 4, false, astProp);\nif (tok_getType() === 49264) {\nif (isAssignable(assignable)) {\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\ndestructible |= parseExpression(lexerFlags, 'right');\nAST_close($tp_elementStart_start, $tp_elementStart_line, $tp_elementStart_column);\n} else {\nreturn THROW_RANGE(('Cannot assign to lhs (starting with `' + tok_sliceInput($tp_elementStart_start, $tp_elementStart_stop)) + '`)', $tp_elementStart_start, $tp_elementStart_stop);\n}\n}\nif (((tok_getType() !== 16480) && (tok_getType() !== 16510))) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\nassignable = setNotAssignable(assignable);\ndestructible |= 1;\n} else if ((((wasParen && isAssignable(assignable))) && (((bindingType === 0) || (bindingType === 1))))) {\ndestructible |= 2;\n} else if ((wasParen || notAssignable(assignable))) {\ndestructible |= 1;\n} else {\n\n}\n}\nif (tok_getType() !== 16480) break;\nskipToExpressionStartSquareCloseComma(lexerFlags);\nwhile (tok_getType() === 16480) {\nskipToExpressionStartSquareCloseComma(lexerFlags);\nAST_add(astProp, null);\n}\nif (spreadStage === 1) {\nspreadStage = 2;\ndestructible |= 1;\n}\n}\nlexerFlags = lexerFlagsBeforeParen;\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Expected the closing bracket `]` for the array, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nAST_close($tp_arrayOpen_start, $tp_arrayOpen_line, $tp_arrayOpen_column);\nif (skipInit === true) {\ndestructible = parsePatternAssignMaybe(lexerFlags, $tp_arrayOpen_start, $tp_arrayOpen_line, $tp_arrayOpen_column, destructible, _astProp);\n}\nreturn (copyPiggies(destructible, assignableYieldAwaitState) | 1024) ^ 1024;\n}\nfunction parseObjectOuter(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nreturn parseObjectAndAssign(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp);\n}\nfunction parseObjectAndAssign(lexerFlags, scoop, bindingType, skipInit, exportedNames, exportedBindings, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nAST_open(astProp, {type:'ObjectExpression', loc:undefined, properties:[]});\nlet destructible = parseObjectSansAssign(lexerFlags | 4096, scoop, bindingType, exportedNames, exportedBindings, 'properties');\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nif (skipInit === true) {\ndestructible = parsePatternAssignMaybe(lexerFlags, $tp_curly_start, $tp_curly_line, $tp_curly_column, destructible, astProp);\n}\nreturn destructible;\n}\nfunction parseObjectSansAssign(outerLexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet lexerFlags = (outerLexerFlags | 2080) ^ 2080;\nskipAny(lexerFlags);\nlet destructible = 0;\nlet hasThunderProto = false;\ndo {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('Objects cant have comma without something preceding it', tok_getStart(), tok_getStop());\n}\nlet currentDestruct = parseObjectPart(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp);\nif ((currentDestruct & 512) !== 0) {\ncurrentDestruct ^= 512;\nif (hasThunderProto) {\ndestructible |= 4;\n}\nhasThunderProto = true;\n}\ndestructible |= currentDestruct;\nif (tok_getType() !== 16480) break;\nskipAny(lexerFlags);\n} while (tok_getType() !== 16517);\nlexerFlags = outerLexerFlags;\nif (tok_getType() !== 16517) {\nreturn THROW_RANGE(('Expected the closing curly `}` for an object, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipDiv(lexerFlags);\nreturn destructible;\n}\nfunction parseObjectPart(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet $tp_startOfKey_type = tok_getType();\nlet $tp_startOfKey_line = tok_getLine();\nlet $tp_startOfKey_column = tok_getColumn();\nlet $tp_startOfKey_start = tok_getStart();\nif (isIdentToken($tp_startOfKey_type)) {\nreturn parseObjectPartFromIdent(lexerFlags, $tp_startOfKey_type, scoop, bindingType, exportedNames, exportedBindings, astProp);\n}\nif ($tp_startOfKey_type === 16517) {\nreturn 0;\n}\nif (isNumberStringToken($tp_startOfKey_type)) {\nreturn parseObjectPartFromLiteral(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp);\n}\nif ($tp_startOfKey_type === 16509) {\nreturn parseObjectPartFromComputed(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp);\n}\nif ($tp_startOfKey_type === 16486) {\nreturn parseObjectRestSpread(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp);\n}\nif ($tp_startOfKey_type === 82009) {\nskipAny(lexerFlags);\nreturn parseObjectMethodFromKey(lexerFlags, $tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column, 'init', true, 0, 82009, 0, 0, astProp);\n}\nreturn THROW_RANGE(('Unexpected token, wanted to parse a start of a property in an object literal/pattern, got `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nfunction parseObjectMethodFromKey(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp) {\nlet $tp_keyStart_type = tok_getType();\nlet $tp_keyStart_line = tok_getLine();\nlet $tp_keyStart_column = tok_getColumn();\nlet $tp_keyStart_start = tok_getStart();\nlet $tp_keyStart_stop = tok_getStop();\nlet $tp_keyStart_canon = tok_getCanoN();\nif (isIdentToken($tp_keyStart_type)) {\nskipAny(lexerFlags);\nAST_setIdent(astProp, $tp_keyStart_start, $tp_keyStart_stop, $tp_keyStart_line, $tp_keyStart_column, $tp_keyStart_canon);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, false, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nif (isNumberStringToken($tp_keyStart_type)) {\nskipAny(lexerFlags);\nAST_setLiteral(astProp, $tp_keyStart_type, $tp_keyStart_start, $tp_keyStart_stop, $tp_keyStart_line, $tp_keyStart_column, $tp_keyStart_canon);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, false, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nif ($tp_keyStart_type === 16509) {\nskipRex(lexerFlags);\nparseExpression(lexerFlags, astProp);\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Missing closing square bracket for computed property name, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipAny(lexerFlags);\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE(('Expected to parse an opening paren, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '`', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_startOfProp_start, $tp_startOfProp_line, $tp_startOfProp_column, kind, true, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp);\n}\nTHROW_RANGE(('Expected to parse an object method key, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nfunction parseObjectPartFromIdent(lexerFlags, $tp_propLeadingIdent_type, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nlet $tp_propLeadingIdent_line = tok_getLine();\nlet $tp_propLeadingIdent_column = tok_getColumn();\nlet $tp_propLeadingIdent_start = tok_getStart();\nlet $tp_propLeadingIdent_stop = tok_getStop();\nlet $tp_propLeadingIdent_canon = tok_getCanoN();\nskipAny(lexerFlags);\nlet $tp_afterIdent_type = tok_getType();\nif ($tp_afterIdent_type === 16489) {\nAST_setIdent(astProp, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon);\nlet destructible = 0;\nif (((options_webCompat === true) && ($tp_propLeadingIdent_canon === '__proto__'))) {\ndestructible = 512;\n}\nreturn destructible | parseObjectPropertyFromColon(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, scoop, exportedNames, exportedBindings, bindingType, false, astProp);\n}\nif ($tp_afterIdent_type === 16471) {\nAST_setIdent(astProp, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon);\nreturn parseObjectMethod(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', false, true, 0, 0, 0, 0, astProp);\n}\nif ((($tp_afterIdent_type === 16480) || ($tp_afterIdent_type === 16517))) {\nreturn parseObjectShorthand(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp);\n}\nif ($tp_afterIdent_type === 49264) {\nreturn parseObjectShorthandWithInit(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp);\n}\nif ($tp_propLeadingIdent_type === 2074) {\nif (!allowAsyncFunctions) {\nreturn THROW_RANGE('Async functions are not supported in the currently targeted language version', $tp_propLeadingIdent_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async methods are a restricted production and cannot have a newline following it', $tp_propLeadingIdent_start, tok_getStart());\n}\nif (tok_getType() === 82009) {\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('Async generator methods are not supported in the currently targeted language version', $tp_propLeadingIdent_start, tok_getStop());\n}\nskipAny(lexerFlags);\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', true, 2074, 82009, 0, 0, astProp);\n}\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'init', true, 2074, 0, 0, 0, astProp);\n}\nif ($tp_propLeadingIdent_type === 2096) {\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'get', false, 0, 0, 2096, 0, astProp);\n}\nif ($tp_propLeadingIdent_type === 2112) {\nreturn parseObjectMethodFromKey(lexerFlags, $tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, 'set', false, 0, 0, 0, 2112, astProp);\n}\nif ($tp_propLeadingIdent_type === 2113) {\nreturn THROW_RANGE('Object members can not be \"static\"', $tp_propLeadingIdent_start, tok_getStop());\n}\nreturn THROW_RANGE(((('Unexpected token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` after start of property `') + $tp_propLeadingIdent_canon) + '` while trying to parse an object property/method', $tp_propLeadingIdent_start, tok_getStop());\n}\nfunction parseObjectPropertyFromColon(lexerFlags, $tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column, scoop, exportedNames, exportedBindings, bindingType, isComputed, astProp) {\nskipRex(lexerFlags);\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:undefined, method:false, computed:isComputed, value:undefined, shorthand:false}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:undefined, kind:'init', method:false, computed:isComputed, value:undefined, shorthand:false}, 'key');\n}\nlet destructible = _parseObjectPropertyFromColon(lexerFlags, scoop, exportedNames, exportedBindings, bindingType);\nAST_close($tp_startOfKey_start, $tp_startOfKey_line, $tp_startOfKey_column);\nreturn destructible;\n}\nfunction _parseObjectPropertyFromColon(lexerFlags, scoop, exportedNames, exportedBindings, bindingType) {\nif (isIdentToken(tok_getType())) {\nreturn parseObjectPropertyValueFromIdent(lexerFlags, scoop, exportedNames, exportedBindings, bindingType);\n}\nlet $tp_start_line = tok_getLine();\nlet $tp_start_column = tok_getColumn();\nlet $tp_start_start = tok_getStart();\nlet $tp_start_stop = tok_getStop();\nif (tok_getType() === 16513) {\nlet destructible = parseObjectOuter(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, 'value');\nlet objAssignable = ((destructible & 1)? 16 : 32);\nif (((tok_getType() === 16480) || (tok_getType() === 16517))) {\nreturn destructible;\n}\nif (4 & destructible) {\nreturn THROW_RANGE(('Object pattern contained parts cause it not to be valid as a regular object literal so the next token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` is illegal', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, objAssignable, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nexprAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, exprAssignable, 'value');\nif ((wasAssignment || isAssignable(exprAssignable))) {\nreturn copyPiggies(2, exprAssignable);\n}\nreturn copyPiggies(1, exprAssignable);\n}\nif (tok_getType() === 16509) {\nlet destructible = parseArrayOuter(lexerFlags, scoop, bindingType, true, exportedNames, exportedBindings, 'value');\nlet objAssignable = ((destructible & 1)? 16 : 32);\nif (((tok_getType() === 16480) || (tok_getType() === 16517))) {\nreturn destructible;\n}\nif (4 & destructible) {\nreturn THROW_RANGE(('Object pattern contained parts cause it not to be valid as a regular object literal so the next token `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` is illegal', tok_getStart(), tok_getStop());\n}\nlet exprAssignable = parseValueTail(lexerFlags, $tp_start_start, $tp_start_line, $tp_start_column, objAssignable, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nexprAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, exprAssignable, 'value');\nif ((wasAssignment || isAssignable(exprAssignable))) {\nreturn copyPiggies(2, exprAssignable);\n}\nreturn copyPiggies(1, exprAssignable);\n}\nlet valueAssignable = parseValue(lexerFlags, true, 4, false, 'value');\nlet wasAssignment = tok_getType() === 49264;\nvalueAssignable = parseExpressionFromOp(lexerFlags, $tp_start_start, $tp_start_stop, $tp_start_line, $tp_start_column, valueAssignable, 'value');\nif ((wasAssignment || isAssignable(valueAssignable))) {\nreturn copyPiggies(2, valueAssignable);\n}\nreturn copyPiggies(1, valueAssignable);\n}\nfunction parseObjectPropertyValueFromIdent(lexerFlags, scoop, exportedNames, exportedBindings, bindingType) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet $tp_afterExpr_type = tok_getType();\nif ((($tp_afterExpr_type === 16480) || ($tp_afterExpr_type === 16517))) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\nlet valueAssignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, 'value');\nreturn copyPiggies(1, valueAssignable);\n}\nAST_setIdent('value', $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nreturn 0;\n}\nif ($tp_afterExpr_type === 49264) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\nreturn THROW_RANGE('The lhs was not assignable so this is an error', $tp_ident_start, tok_getStop());\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\nAST_setIdent('value', $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon);\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, 32, 'value');\nreturn copyPiggies(0, rhsAssignable);\n}\nlet valueAssignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, 'value');\nif (notAssignable(valueAssignable)) {\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, valueAssignable, 'value');\nreturn copyPiggies(1, rhsAssignable);\n}\nlet wasAssign = tok_getType() === 49264;\nlet rhsAssignable = parseExpressionFromOp(lexerFlags, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, valueAssignable, 'value');\nif ((wasAssign || isAssignable(rhsAssignable))) {\nreturn copyPiggies(2, rhsAssignable);\n}\nreturn copyPiggies(1, rhsAssignable);\n}\nfunction parseObjectShorthand(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp) {\nlet report = nonFatalBindingIdentCheck($tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType, lexerFlags);\nif (((((report.length > 0) && ($tp_propLeadingIdent_type !== 2088))) && ($tp_propLeadingIdent_type !== 2072))) {\nreturn THROW_RANGE(report, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop);\n}\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType);\naddNameToExports(exportedNames, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon);\naddBindingToExports(exportedBindings, $tp_propLeadingIdent_canon);\nif (babelCompat) {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true, extra:{shorthand:true}});\n} else {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), kind:'init', method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true});\n}\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nif ($tp_propLeadingIdent_type === 2075) {\nreturn 64;\n}\nreturn ((report.length > 0)? 1 : 0);\n}\nfunction parseObjectShorthandWithInit(lexerFlags, $tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon, bindingType, scoop, exportedNames, exportedBindings, astProp) {\nfatalBindingIdentCheck($tp_propLeadingIdent_type, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType, lexerFlags);\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon, bindingType);\naddNameToExports(exportedNames, $tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_canon);\naddBindingToExports(exportedBindings, $tp_propLeadingIdent_canon);\nif (babelCompat) {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true, extra:{shorthand:true}});\n} else {\nAST_open(astProp, {type:NODE_NAME_PROPERTY, loc:undefined, key:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), kind:'init', method:false, computed:false, value:AST_getIdentNode($tp_propLeadingIdent_start, $tp_propLeadingIdent_stop, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column, $tp_propLeadingIdent_canon), shorthand:true});\n}\nAST_wrapClosedCustom('value', {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, 'right');\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nAST_close($tp_propLeadingIdent_start, $tp_propLeadingIdent_line, $tp_propLeadingIdent_column);\nif ($tp_propLeadingIdent_type === 2075) {\nreturn copyPiggies(68, nowAssignable);\n}\nreturn copyPiggies(4, nowAssignable);\n}\nfunction parseObjectPartFromLiteral(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nskipToColonParenOpen(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nif (tok_getType() === 16489) {\nlet destructible_forPiggies = 0;\nif (((options_webCompat === true) && ($tp_lit_canon === '__proto__'))) {\ndestructible_forPiggies |= 512;\n}\nreturn destructible_forPiggies | parseObjectPropertyFromColon(lexerFlags, $tp_lit_start, $tp_lit_line, $tp_lit_column, scoop, exportedNames, exportedBindings, bindingType, false, astProp);\n}\nif (tok_getType() !== 16471) {\nreturn THROW_RANGE('Object literal keys that are strings or numbers must be a method or have a colon', tok_getStart(), tok_getStop());\n}\nreturn parseObjectMethod(lexerFlags, $tp_lit_start, $tp_lit_line, $tp_lit_column, 'init', false, true, 0, 0, 0, 0, astProp);\n}\nfunction parseObjectPartFromComputed(lexerFlags, scoop, exportedNames, exportedBindings, bindingType, astProp) {\nlet $tp_keyStart_line = tok_getLine();\nlet $tp_keyStart_column = tok_getColumn();\nlet $tp_keyStart_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nlet assignable_forPiggies = parseExpression(lexerFlags, astProp);\nif (tok_getType() !== 16510) {\nif (tok_getType() === 16480) {\nreturn THROW_RANGE('The expression of a computed property key can not be a comma expression', tok_getStart(), tok_getStop());\n}\nreturn THROW_RANGE(('Missing closing square bracket for computed property name, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToColonParenOpen(lexerFlags);\nlet $tp_afterKey_type = tok_getType();\nif ($tp_afterKey_type === 16489) {\nlet assignable = parseObjectPropertyFromColon(lexerFlags, $tp_keyStart_start, $tp_keyStart_line, $tp_keyStart_column, scoop, exportedNames, exportedBindings, bindingType, true, astProp);\nreturn copyPiggies(assignable, assignable_forPiggies);\n}\nif ($tp_afterKey_type === 16471) {\nlet assignable = parseObjectMethod(lexerFlags, $tp_keyStart_start, $tp_keyStart_line, $tp_keyStart_column, 'init', true, true, 0, 0, 0, 0, astProp);\nreturn copyPiggies(assignable, assignable_forPiggies);\n}\nTHROW_RANGE(('Object literal; computed property must be followed by a colon (property) paren (method), found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + `' instead'`, tok_getStart(), tok_getStop());\n}\nfunction parseObjectRestSpread(lexerFlags, scoop, bindingType, exportedNames, exportedBindings, astProp) {\nif (((targetEsVersion < 9) && (targetEsVersion !== Infinity))) {\nreturn THROW_RANGE('Object spread/rest requires the requested version to be ES9+', tok_getStart(), tok_getStop());\n}\nreturn parseArrowableSpreadOrRest(lexerFlags, scoop, 16517, bindingType, 0, exportedNames, exportedBindings, astProp);\n}\nfunction parseObjectMethod(lexerFlags, $tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column, kind, isComputed, isRealMethod, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, astProp) {\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_OBJECT, loc:undefined, key:undefined, method:isRealMethod, generator:undefined, async:undefined, id:undefined, params:[], kind:((kind === 'init')? 'method' : kind), computed:isComputed, body:undefined}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_OBJECT, loc:undefined, key:undefined, kind:kind, method:isRealMethod, computed:isComputed, value:undefined, shorthand:false}, 'key');\n}\nif (acornCompat) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, false, true, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, $tp_paren_start, $tp_paren_line, $tp_paren_column, 1, 'value');\n} else {\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, false, true, $tp_async_type, $tp_star_type, $tf_getToken_type, $tf_setToken_type, $tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column, 1, 'value');\n}\nAST_close($tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column);\nreturn 1;\n}\nfunction parsePatternAssignMaybe(lexerFlags, $tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column, destructible, astProp) {\nverifyDestructible(destructible);\nif (!isAnyAssignmentOp()) {\nreturn destructible;\n}\nif (tok_getType() !== 49264) {\nreturn THROW_RANGE('Cannot compound-assign to an array literal', tok_getStart(), tok_getStop());\n}\nif ((destructible & 1) === 1) {\nreturn THROW_RANGE('Tried to destructure something that is not destructible', tok_getStart(), tok_getStop());\n}\ndestructible = (destructible | 4) ^ 4;\nAST_destruct(astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\ndestructible |= parseExpression(lexerFlags, 'right');\nAST_close($tp_patternStart_start, $tp_patternStart_line, $tp_patternStart_column);\nreturn destructible;\n}\nfunction parseClassDeclaration(lexerFlags, scoop, optionalIdent, isLabelled, fdState, astProp) {\nlet originalOuterLexerFlags = lexerFlags;\nlet $tp_class_line = tok_getLine();\nlet $tp_class_column = tok_getColumn();\nlet $tp_class_start = tok_getStart();\nlet $tp_class_stop = tok_getStop();\nif (((((isLabelled === true) || (fdState === 1))) || (fdState === 2))) {\nreturn THROW_RANGE('Cannot parse a class declaration here, only expecting statements here', $tp_class_start, $tp_class_stop);\n}\nlexerFlags = ((lexerFlags | 8192) | 6176) ^ 6176;\nskipToIdentCurlyOpen(lexerFlags);\nAST_open(astProp, {type:'ClassDeclaration', loc:undefined, id:undefined, superClass:undefined, body:undefined});\nlet $tp_name_canon = parseClassId(lexerFlags, optionalIdent, scoop);\n_parseClass(lexerFlags, originalOuterLexerFlags, 2);\nAST_close($tp_class_start, $tp_class_line, $tp_class_column);\nreturn $tp_name_canon;\n}\nfunction parseClassExpression(lexerFlags, $tp_class_start, $tp_class_line, $tp_class_column, astProp) {\nlet originalOuterLexerFlags = lexerFlags;\nlexerFlags = ((lexerFlags | 8192) | 6176) ^ 6176;\nAST_open(astProp, {type:'ClassExpression', loc:undefined, id:undefined, superClass:undefined, body:undefined});\nparseClassId(lexerFlags, true, null);\nlet assignable = _parseClass(lexerFlags, originalOuterLexerFlags, 1);\nAST_close($tp_class_start, $tp_class_line, $tp_class_column);\nreturn setNotAssignable(assignable);\n}\nfunction parseClassId(lexerFlags, optionalIdent, scoop) {\nlet $tp_bindingName_canon = '';\nif ((isIdentToken(tok_getType()) && (tok_getType() !== 2090))) {\nlet $tp_className_type = tok_getType();\nlet $tp_className_start = tok_getStart();\nlet $tp_className_stop = tok_getStop();\nlet $tp_className_canon = tok_getCanoN();\nfatalBindingIdentCheck($tp_className_type, $tp_className_start, $tp_className_stop, $tp_className_canon, 8, lexerFlags);\n$tp_bindingName_canon = $tp_className_canon;\nSCOPE_addLexBinding(scoop, $tp_className_start, $tp_className_stop, $tp_bindingName_canon, 8, 1);\nlet $tp_id_line = tok_getLine();\nlet $tp_id_column = tok_getColumn();\nlet $tp_id_start = tok_getStart();\nlet $tp_id_stop = tok_getStop();\nlet $tp_id_canon = tok_getCanoN();\nskipToIdentCurlyOpen(lexerFlags);\nAST_setIdent('id', $tp_id_start, $tp_id_stop, $tp_id_line, $tp_id_column, $tp_id_canon);\n} else if (optionalIdent === false) {\nreturn THROW_RANGE('Class decl missing required ident, `extends` is not a valid variable name', tok_getStart(), tok_getStop());\n} else {\nAST_set('id', null);\n}\nreturn $tp_bindingName_canon;\n}\nfunction _parseClass(outerLexerFlags, originalOuterLexerFlags, isExpression) {\nlet assignable = 8;\nlet innerLexerFlags = (outerLexerFlags | 16) ^ 16;\nif ((isIdentToken(tok_getType()) && (tok_getType() === 2090))) {\nskipToExpressionStart(outerLexerFlags);\nassignable = parseValue(outerLexerFlags, false, 4, true, 'superClass');\ninnerLexerFlags |= 16384;\n} else {\nAST_set('superClass', null);\ninnerLexerFlags = (innerLexerFlags | 16384) ^ 16384;\n}\nif (tok_getType() !== 16513) {\nreturn THROW_RANGE(('Expected the opening curly `{` of a class body, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\ninnerLexerFlags |= 32768;\nassignable |= parseClassBody(innerLexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, 'body');\nreturn assignable;\n}\nfunction parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, astProp) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nAST_open(astProp, {type:'ClassBody', loc:undefined, body:[]});\nlet assignable = _parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, 'body');\nAST_close($tp_curly_start, $tp_curly_line, $tp_curly_column);\nreturn assignable;\n}\nfunction _parseClassBody(lexerFlags, outerLexerFlags, originalOuterLexerFlags, isExpression, astProp) {\nlet destructibleForPiggies = 1;\nskipAny(lexerFlags);\nwhile (tok_getType() === 16490) {\nskipAny(lexerFlags);\n}\nlet hasConstructor = false;\nwhile (tok_getType() !== 16517) {\nlet $tp_memberStart_start = tok_getStart();\nlet $tp_memberStart_stop = tok_getStop();\nlet destructNow = parseClassMethod(lexerFlags, outerLexerFlags, astProp);\nif ((destructNow & 256) !== 0) {\nif (hasConstructor) {\nreturn THROW_RANGE('Classes may only have one constructor', $tp_memberStart_start, $tp_memberStart_stop);\n}\nhasConstructor = true;\ndestructNow = (destructNow | 256) ^ 256;\n}\ndestructibleForPiggies |= destructNow;\nwhile (tok_getType() === 16490) {\nskipAny(lexerFlags);\n}\n}\nif (isExpression === 1) {\nskipDiv(originalOuterLexerFlags);\n} else {\nskipToStatementStart(originalOuterLexerFlags);\n}\nreturn destructibleForPiggies;\n}\nfunction parseClassMethod(lexerFlags, outerLexerFlags, astProp) {\nlet $tp_methodStart_line = tok_getLine();\nlet $tp_methodStart_column = tok_getColumn();\nlet $tp_methodStart_start = tok_getStart();\nlet isStatic = false;\nif (tok_getType() === 2113) {\nisStatic = true;\nlet $tp_static_line = tok_getLine();\nlet $tp_static_column = tok_getColumn();\nlet $tp_static_start = tok_getStart();\nlet $tp_static_stop = tok_getStop();\nlet $tp_static_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 16471) {\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, false, 0, 0, 0, 0, $tp_static_start, $tp_static_stop, $tp_static_line, $tp_static_column, $tp_static_canon, astProp);\n}\n}\nlet $tp_afterStaticMaybe_type = tok_getType();\nif (isIdentToken($tp_afterStaticMaybe_type)) {\nreturn parseClassMethodFromIdent(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, astProp);\n}\nif (isNumberStringToken($tp_afterStaticMaybe_type)) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, astProp);\n}\nif ($tp_afterStaticMaybe_type === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, astProp);\n}\nif ($tp_afterStaticMaybe_type === 82009) {\nskipToIdentStringNumberSquareOpen(lexerFlags);\nif (isIdentToken(tok_getType())) {\nreturn parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nif (isNumberStringToken(tok_getType())) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nif (tok_getType() === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 82009, 0, 0, astProp);\n}\nreturn THROW_RANGE('Invalid objlit key character after generator star', $tp_methodStart_line, tok_getStop());\n}\nreturn THROW_RANGE('Unexpected token, wanted to parse a start of a property in an class literal/pattern', $tp_methodStart_line, tok_getStop());\n}\nfunction parseClassMethodFromIdent(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, astProp) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipAny(lexerFlags);\nif (tok_getType() === 16471) {\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, 0, 0, 0, 0, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, astProp);\n}\nlet $tp_async_type = 0;\nlet $tp_star_type = 0;\nlet $tp_get_type = 0;\nlet $tp_set_type = 0;\nswitch ($tp_ident_type) {\ncase 2096:\n$tp_get_type = 2096;\nbreak;\ncase 2112:\n$tp_set_type = 2112;\nbreak;\ncase 2074:\nif (!allowAsyncFunctions) {\nreturn THROW_RANGE('Async methods are not supported in the currently targeted language version', $tp_methodStart_start, tok_getStop());\n}\nif (tok_getNlwas() === true) {\nreturn THROW_RANGE('Async methods are a restricted production and cannot have a newline following it', $tp_methodStart_line, tok_getStart());\n}\n$tp_async_type = 2074;\nif (tok_getType() === 82009) {\nif (!allowAsyncGenerators) {\nreturn THROW_RANGE('Async generator methods are not supported in the currently targeted language version', $tp_methodStart_start, tok_getStop());\n}\n$tp_star_type = 82009;\nskipToIdentStringNumberSquareOpen(lexerFlags);\n}\nbreak;\ndefault:\nreturn THROW_RANGE('Either the current modifier is unknown or the input that followed was unexpected', tok_getStart(), tok_getStop());\n}\nif (tok_getType() === 16509) {\nreturn parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nif (isNumberStringToken(tok_getType())) {\nreturn parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nif (isIdentToken(tok_getType())) {\nreturn parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nreturn THROW_RANGE('Expected to parse the modified key of a class method but could not parse one', tok_getStart(), tok_getStop());\n}\nfunction parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_key_line = tok_getLine();\nlet $tp_key_column = tok_getColumn();\nlet $tp_key_start = tok_getStart();\nlet $tp_key_stop = tok_getStop();\nlet $tp_key_canon = tok_getCanoN();\nskipToParenOpenOrDie(lexerFlags);\nreturn _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon, astProp);\n}\nfunction _parseClassMethodIdentKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon, astProp) {\nAST_setIdent(astProp, $tp_key_start, $tp_key_stop, $tp_key_line, $tp_key_column, $tp_key_canon);\nif ((isStatic && ($tp_key_canon === 'prototype'))) {\nreturn THROW_RANGE('Static class methods can not be called `prototype`', $tp_methodStart_line, tok_getStop());\n}\nlet kind = 'method';\nlet isClassConstructor = false;\nif (((!isStatic) && ($tp_key_canon === 'constructor'))) {\nisClassConstructor = true;\nkind = 'constructor';\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('Class constructors can not be async', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('Class constructors can not be generators', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Class constructors can not be getters', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Class constructors can not be setters', $tp_methodStart_line, tok_getStop());\n}\n} else if ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nreturn parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, false, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nfunction parseClassMethodLiteralKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_lit_type = tok_getType();\nlet $tp_lit_line = tok_getLine();\nlet $tp_lit_column = tok_getColumn();\nlet $tp_lit_start = tok_getStart();\nlet $tp_lit_stop = tok_getStop();\nlet $tp_lit_canon = tok_getCanoN();\nif ((isStatic && ($tp_lit_canon === 'prototype'))) {\nreturn THROW_RANGE('Static class methods can not be called `prototype`', $tp_methodStart_line, tok_getStop());\n}\nlet kind = 'method';\nlet isClassConstructor = false;\nif (((!isStatic) && ($tp_lit_canon === 'constructor'))) {\nisClassConstructor = true;\nkind = 'constructor';\nif ($tp_async_type === 2074) {\nreturn THROW_RANGE('Class constructors can not be async', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_star_type === 82009) {\nreturn THROW_RANGE('Class constructors can not be generators', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_get_type === 2096) {\nreturn THROW_RANGE('Class constructors can not be getters', $tp_methodStart_line, tok_getStop());\n}\nif ($tp_set_type === 2112) {\nreturn THROW_RANGE('Class constructors can not be setters', $tp_methodStart_line, tok_getStop());\n}\n} else if ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nskipToParenOpenOrDie(lexerFlags);\nAST_setLiteral(astProp, $tp_lit_type, $tp_lit_start, $tp_lit_stop, $tp_lit_line, $tp_lit_column, $tp_lit_canon);\nreturn parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, false, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\n}\nfunction parseClassMethodComputedKey(lexerFlags, outerLexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nskipToExpressionStart(lexerFlags);\nlet assignable_forPiggies = parseExpression(outerLexerFlags, astProp);\nif (tok_getType() !== 16510) {\nreturn THROW_RANGE(('Missing right square bracket for computed member, found `' + tok_sliceInput(tok_getStart(), tok_getStop())) + '` instead', tok_getStart(), tok_getStop());\n}\nskipToParenOpenOrDie(lexerFlags);\nlet kind = 'method';\nif ($tp_get_type === 2096) {\nkind = 'get';\n} else if ($tp_set_type === 2112) {\nkind = 'set';\n} else {\n\n}\nparseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, false, true, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp);\nreturn assignable_forPiggies;\n}\nfunction parseClassMethodAfterKey(lexerFlags, $tp_methodStart_line, $tp_methodStart_column, $tp_methodStart_start, kind, isClassConstructor, isComputedKey, isStatic, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, astProp) {\nlet $tp_paren_line = tok_getLine();\nlet $tp_paren_column = tok_getColumn();\nlet $tp_paren_start = tok_getStart();\nif (babelCompat) {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_CLASS, loc:undefined, key:undefined, static:isStatic, computed:isComputedKey, async:undefined, generator:undefined, id:undefined, params:[], kind:kind}, 'key');\n} else {\nAST_wrapClosedCustom(astProp, {type:NODE_NAME_METHOD_CLASS, loc:undefined, key:undefined, static:isStatic, computed:isComputedKey, kind:kind, value:undefined}, 'key');\n}\nparseFunctionAfterKeyword(lexerFlags, null, false, false, true, isClassConstructor, true, $tp_async_type, $tp_star_type, $tp_get_type, $tp_set_type, (acornCompat? $tp_paren_start : $tp_methodStart_start), (acornCompat? $tp_paren_line : $tp_methodStart_line), (acornCompat? $tp_paren_column : $tp_methodStart_column), 1, 'value');\nAST_close($tp_methodStart_start, $tp_methodStart_line, $tp_methodStart_column);\nif (isClassConstructor === true) {\nreturn 256;\n}\nreturn 1;\n}\nfunction verifyDestructible(destructible) {\nif ((((destructible & 1) === 1) && ((destructible & 4) === 4))) {\nreturn THROW_RANGE('Found a part that cant destruct and a part that must destruct so it is not destructible', tok_getStart(), tok_getStop());\n}\n}\nfunction verifyDestructibleForBinding(destructible, bindingType) {\nif ((destructible & 1) !== 0) {\nreturn THROW_RANGE('The binding pattern is not destructible', tok_getStart(), tok_getStop());\n}\nif (((bindingType !== 0) && ((destructible & 2) !== 0))) {\nreturn THROW_RANGE('This binding can not be used in function parameters because it is not destructible', tok_getStart(), tok_getStop());\n}\n}\nfunction parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, destructible, closingPuncType, astProp) {\nif (((tok_getType() === 16480) || (tok_getType() === closingPuncType))) {\nif (notAssignable(assignable)) destructible |= 1;\n} else if ((destructible & 4) === 4) {\nreturn THROW_RANGE('Found something that had to be a Pattern but had to parse more, which is an error', $tp_valueStart_start, tok_getStart());\n} else {\nassignable = parseValueTail(lexerFlags, $tp_valueStart_start, $tp_valueStart_line, $tp_valueStart_column, assignable, 4, false, astProp);\nif (isAssignable(assignable)) {\ndestructible = (destructible | 7) ^ 7;\n} else {\ndestructible |= 1;\n}\nlet firstOpNotAssign = tok_getType() !== 49264;\nif (((tok_getType() !== 16480) && (tok_getType() !== closingPuncType))) {\nassignable |= parseExpressionFromOp(lexerFlags, $tp_valueStart_start, $tp_valueStart_stop, $tp_valueStart_line, $tp_valueStart_column, assignable, astProp);\nif (firstOpNotAssign) {\ndestructible |= 1;\n} else {\n\n}\n} else if (firstOpNotAssign) {\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else {\ndestructible |= 2;\n}\n}\n}\nreturn copyPiggies(destructible, assignable);\n}\nfunction parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, exportedNames, exportedBindings, astProp) {\nlet $tp_spread_line = tok_getLine();\nlet $tp_spread_column = tok_getColumn();\nlet $tp_spread_start = tok_getStart();\nskipToExpressionStart(lexerFlags);\nif (tok_getType() === 16486) {\nreturn THROW_RANGE('Can not rest twice', $tp_spread_start, tok_getStop());\n}\nAST_open(astProp, {type:'SpreadElement', loc:undefined, argument:undefined});\nlet destructible = _parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, $tp_spread_start, exportedNames, exportedBindings, 'argument');\nAST_close($tp_spread_start, $tp_spread_line, $tp_spread_column);\nif (((tok_getType() !== closingPuncType) && (tok_getType() !== 16480))) {\nreturn THROW_RANGE('Encountered invalid input after spread/rest argument', tok_getStart(), tok_getStop());\n}\nreturn destructible;\n}\nfunction _parseArrowableSpreadOrRest(lexerFlags, scoop, closingPuncType, bindingType, $tp_async_type, $tt_spreadToken_start, exportedNames, exportedBindings, astProp) {\nlet $tp_argStart_line = tok_getLine();\nlet $tp_argStart_column = tok_getColumn();\nlet $tp_argStart_start = tok_getStart();\nlet $tp_argStart_stop = tok_getStop();\nlet destructible = 0;\nlet assignable = 32;\nif (isIdentToken(tok_getType())) {\nlet $tp_ident_type = tok_getType();\nlet $tp_ident_line = tok_getLine();\nlet $tp_ident_column = tok_getColumn();\nlet $tp_ident_start = tok_getStart();\nlet $tp_ident_stop = tok_getStop();\nlet $tp_ident_canon = tok_getCanoN();\nskipIdentSafeSlowAndExpensive(lexerFlags, false);\nlet assignBefore = tok_getType() === 49264;\nlet willBeSimple = ((((tok_getType() === closingPuncType) || (tok_getType() === 16480))) || assignBefore);\nif (willBeSimple) {\nlet assignableOrErrorMsg = nonFatalBindingIdentCheck($tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType, lexerFlags);\nif (assignableOrErrorMsg.length !== 0) {\ndestructible |= 1;\n}\n} else {\ndestructible |= 2;\n}\nassignable = parseValueAfterIdent(lexerFlags, $tp_ident_type, $tp_ident_start, $tp_ident_stop, $tp_ident_line, $tp_ident_column, $tp_ident_canon, bindingType, true, astProp);\nif (((tok_getType() !== 16480) && (tok_getType() !== closingPuncType))) {\nif (tok_getType() === 49264) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('Tried to assign to a value that was not assignable in arr/obj lit/patt', tok_getStart(), tok_getStop());\n}\n}\ndestructible |= 1;\nassignable = parseExpressionFromOp(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, astProp);\n}\nif (notAssignable(assignable)) {\ndestructible |= 1;\n} else if (willBeSimple) {\nSCOPE_actuallyAddBinding(lexerFlags, scoop, $tp_ident_start, $tp_ident_stop, $tp_ident_canon, bindingType);\naddNameToExports(exportedNames, $tp_ident_start, $tp_ident_stop, $tp_ident_canon);\naddBindingToExports(exportedBindings, $tp_ident_canon);\n} else {\ndestructible |= 2;\n}\n} else if (tok_getType() === 16509) {\nlet nowDestruct = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nif (((((tok_getType() !== 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\ndestructible = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, nowDestruct, closingPuncType, astProp);\n} else {\nif (((closingPuncType === 16517) && (tok_getType() !== 49264))) {\ndestructible |= nowDestruct | 1;\n} else {\ndestructible |= nowDestruct;\n}\n}\nassignable = (((destructible & 1) === 1)? 16 : 32);\nif (((closingPuncType === 16517) && notAssignable(assignable))) {\ndestructible |= 1;\n}\n} else if (tok_getType() === 16513) {\nlet $tp_curly_line = tok_getLine();\nlet $tp_curly_column = tok_getColumn();\nlet $tp_curly_start = tok_getStart();\nlet $tp_curly_stop = tok_getStop();\nlet nowDestruct = parseObjectAndAssign(lexerFlags, scoop, bindingType, false, exportedNames, exportedBindings, astProp);\nif (((((tok_getType() !== 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\ndestructible = parseOptionalDestructibleRestOfExpression(lexerFlags, $tp_curly_start, $tp_curly_stop, $tp_curly_line, $tp_curly_column, assignable, nowDestruct, closingPuncType, astProp);\n} else {\ndestructible |= nowDestruct;\nif (((closingPuncType === 16517) && (tok_getType() !== 49264))) {\ndestructible |= 1;\n}\n}\nassignable = (((destructible & 1) === 1)? 16 : 32);\nif (((closingPuncType === 16517) && notAssignable(assignable))) {\ndestructible |= 1;\n}\n} else if (tok_getType() === closingPuncType) {\nreturn THROW_RANGE('The rest/spread operator is missing an argument', $tt_spreadToken_start, tok_getStop());\n} else {\ndestructible |= 2;\nlet $tp_exprStart_line = tok_getLine();\nlet $tp_exprStart_column = tok_getColumn();\nlet $tp_exprStart_start = tok_getStart();\nlet $tp_exprStart_stop = tok_getStop();\nlet nowAssignable = parseValue(lexerFlags, true, 4, false, astProp);\nif (notAssignable(nowAssignable)) {\ndestructible = 1;\n}\nassignable = mergeAssignable(nowAssignable, assignable);\nif (((((tok_getType() === 49264) && (tok_getType() !== closingPuncType))) && (tok_getType() !== 16480))) {\nif (notAssignable(assignable)) {\nreturn THROW_RANGE('This `...` arg is invalid; rest only accepts idents, arrays, and objects and as spread the assignment is illegal because the lhs is not assignable', $tt_spreadToken_start, tok_getStop());\n}\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\ndestructible |= 1;\n} else {\nif (tok_getType() === 16480) {\ndestructible |= 1;\n} else if (tok_getType() !== closingPuncType) {\nassignable = parseExpressionFromOp(lexerFlags, $tp_exprStart_start, $tp_exprStart_stop, $tp_exprStart_line, $tp_exprStart_column, assignable, astProp);\n} else {\n\n}\nif (isAssignable(assignable)) {\ndestructible |= 2;\n} else {\ndestructible |= 1;\n}\n}\nif (((closingPuncType === 16517) && (!isAssignable(assignable)))) destructible |= 1;\nreturn copyPiggies(destructible, assignable);\n}\nif (tok_getType() !== closingPuncType) {\nif (bindingType === 1) {\nif ($tp_async_type === 2074) {\ndestructible |= 1;\n} else {\ndestructible |= 2;\n}\n}\nif (tok_getType() === 49264) {\nverifyDestructible(destructible | 4);\ndestructible = 1;\nAST_destruct(astProp);\nAST_wrapClosedCustom(astProp, {type:'AssignmentExpression', loc:undefined, left:undefined, operator:'=', right:undefined}, 'left');\nskipToExpressionStart(lexerFlags);\nlet nowAssignable = parseExpression(lexerFlags, 'right');\nassignable = mergeAssignable(nowAssignable, assignable);\nAST_close($tp_argStart_start, $tp_argStart_line, $tp_argStart_column);\n} else {\nassignable = parseValueTail(lexerFlags, $tp_argStart_start, $tp_argStart_line, $tp_argStart_column, assignable, 4, false, astProp);\nassignable = parseExpressionFromOp(lexerFlags, $tp_argStart_start, $tp_argStart_stop, $tp_argStart_line, $tp_argStart_column, assignable, astProp);\n}\ndestructible |= 1;\n}\nreturn copyPiggies(destructible, assignable);\n}\nlet initialLexerFlags = ((260 | ((((options_strictMode || (goalMode === true)))? 8192 : 0))) | 4) ^ 4;\ninitLexer(initialLexerFlags);\nparseTopLevels(initialLexerFlags);\nif (tok_getType() !== 2097173) {\nreturn THROW_RANGE('Unexpected further input', tok_getStart(), tok_getStop());\n}\n_tree.loc = AST_getCloseLoc(0, 1, 0, tok_prevEndPointer(), tok_getLine(), tok_getColumn());\nreturn {ast:_tree, tokens:tok.tokens, tokenCountSolid:tok.getTokenCountSolid(), tokenCountAny:tok.getTokenCountAny()};\n}\nfunction isTemplateStart(type) {\nreturn ((((((type === 524308) || (type === 524305))) || (type === 1572884))) || (type === 1572881));\n}\nfunction D(d) {\nif (d === 0) {\nreturn 'D=MIGHT_DESTRUCT';\n}\nlet arr = [];\nif (d & 1) {\narr.push('CANT_DESTRUCT');\nd ^= 1;\n}\nif (d & 4) {\narr.push('MUST_DESTRUCT');\nd ^= 4;\n}\nif (d & 2) {\narr.push('DESTRUCT_ASSIGN_ONLY');\nd ^= 2;\n}\nif (d & 8) {\narr.push('(ASSIGNABLE_UNDETERMINED)');\nd ^= 8;\n}\nif (d & 16) {\narr.push('(NOT_ASSIGNABLE)');\nd ^= 16;\n}\nif (d & 32) {\narr.push('(IS_ASSIGNABLE)');\nd ^= 32;\n}\nd = P(d, arr);\nif (d !== 0) {\nconsole.log('Gathered flags so far:', arr.join(', '));\n}\nreturn 'D=' + arr.join(', ');\n}\nfunction A(a) {\nif (a === 0) {\nreturn 'A=ASSIGNABLE_UNDETERMINED';\n}\nlet arr = [];\nif (a & 8) {\narr.push('ASSIGNABLE_UNDETERMINED');\na ^= 8;\n}\nif (a & 16) {\narr.push('NOT_ASSIGNABLE');\na ^= 16;\n}\nif (a & 32) {\narr.push('IS_ASSIGNABLE');\na ^= 32;\n}\nif (a & 1) {\narr.push('(CANT_DESTRUCT)');\na ^= 1;\n}\nif (a & 4) {\narr.push('(MUST_DESTRUCT)');\na ^= 4;\n}\nif (a & 2) {\narr.push('(DESTRUCT_ASSIGN_ONLY)');\na ^= 2;\n}\na = P(a, arr);\nif (a !== 0) {\nconsole.log('Gathered flags so far:', arr.join(', '));\n}\nreturn 'A=' + arr.join(', ');\n}\nfunction B(b) {\nif (b === 0) return 'B=BINDING_TYPE_NONE';\nif (b === 1) return 'B=BINDING_TYPE_ARG';\nif (b === 2) return 'B=BINDING_TYPE_VAR';\nif (b === 6) return 'B=BINDING_TYPE_LET';\nif (b === 7) return 'B=BINDING_TYPE_CONST';\nif (b === 8) return 'B=BINDING_TYPE_CLASS';\nif (b === 9) return 'B=BINDING_TYPE_CATCH_IDENT';\nif (b === 10) return 'B=BINDING_TYPE_CATCH_OTHER';\nif (b === 3) return 'B=BINDING_TYPE_FUNC_VAR';\nif (b === 5) return 'B=BINDING_TYPE_FUNC_LEX';\nif (b === 4) return 'B=BINDING_TYPE_FUNC_STMT';\n}\nfunction S(s) {\nif (s === 0) return 'SCOPE_LAYER_GLOBAL';\nif (s === 1) return 'SCOPE_LAYER_FOR_HEADER';\nif (s === 2) return 'SCOPE_LAYER_BLOCK';\nif (s === 3) return 'SCOPE_LAYER_FUNC_PARAMS';\nif (s === 4) return 'SCOPE_LAYER_TRY';\nif (s === 5) return 'SCOPE_LAYER_CATCH_HEAD';\nif (s === 6) return 'SCOPE_LAYER_CATCH_BODY';\nif (s === 7) return 'SCOPE_LAYER_FINALLY';\nif (s === 8) return 'SCOPE_LAYER_SWITCH';\nif (s === 9) return 'SCOPE_LAYER_FUNC_ROOT';\nif (s === 10) return 'SCOPE_LAYER_FUNC_BODY';\nif (s === 11) return 'SCOPE_LAYER_ARROW_PARAMS';\nif (s === 12) return 'SCOPE_LAYER_FAKE_BLOCK';\n}\nfunction F(fdState) {\nif (fdState === 1) return 'F=FDS_ILLEGAL'; else if (fdState === 2) return 'F=FDS_IFELSE'; else if (fdState === 3) return 'F=FDS_LEX'; else if (fdState === 4) return 'F=FDS_VAR'; else ;\n}\n// </parser>\n\n\nlet Tenko = Parser;\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Tenko); // Does dual export make sense? Default and as member. To each their own, eh\n\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVua28vYnVpbGQvdGVua28ucHJvZC5tanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVua28vYnVpbGQvdGVua28ucHJvZC5tanM/ZmMyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuXG5cbi8vIDxwZXJmPlxubGV0IElHTk9SRSA9IHt9O1xuLy8gPC9wZXJmPlxuXG4vLyA8Y2hhcmNvZGVzPlxuXG4vLyA8L2NoYXJjb2Rlcz5cblxuLy8gPHV0aWxzPlxuZnVuY3Rpb24gaW5zcGVjdCguLi5hcmdzKSB7XG5jb25zb2xlLmRpcigoKGFyZ3MubGVuZ3RoID09PSAxKT8gYXJnc1swXSA6IGFyZ3MpLCB7ZGVwdGg6bnVsbH0pO1xufVxuZnVuY3Rpb24gVEhST1coc3RyLCAuLi5yZXN0KSB7XG50aHJvdyBuZXcgRXJyb3IoYFBhcnNlciBlcnJvciEgJHtzdHJ9ICR7KHJlc3QubGVuZ3RoPyByZXN0IDogJycpfWApO1xufVxuLy8gPC91dGlscz5cblxuLy8gPHRva2VudHlwZT5cbmxldCBfXyRmbGFnX2xlYWYgPSAwO1xubGV0IF9fJGZsYWdfZ3JvdXAgPSA3O1xubGV0IEFMTF9HRUVTO1xubGV0IEtFWVdPUkRfVFJJRV9PQkpMSVQgPSB7MDp7MTc6ezY6ezIwOnsxMjp7NDp7MTM6ezE5OnsxODp7aGl0OjIwNzIsIGNhbm9uOidhcmd1bWVudHMnfX19fX19fX0sIDE4OnsyNDp7MTM6ezI6e2hpdDoyMDc0LCBjYW5vbjonYXN5bmMnfX19LCBoaXQ6MjA3MywgY2Fub246J2FzJ30sIDIyOnswOns4OnsxOTp7aGl0OjIwNzUsIGNhbm9uOidhd2FpdCd9fX19fSwgMTp7MTc6ezQ6ezA6ezEwOntoaXQ6MjA3NiwgY2Fub246J2JyZWFrJ319fX19LCAyOnswOnsxODp7NDp7aGl0OjIwNzcsIGNhbm9uOidjYXNlJ319LCAxOTp7Mjp7Nzp7aGl0OjIwNzgsIGNhbm9uOidjYXRjaCd9fX19LCAxMTp7MDp7MTg6ezE4OntoaXQ6MjA3OSwgY2Fub246J2NsYXNzJ319fX0sIDE0OnsxMzp7MTg6ezE5OntoaXQ6MjA4MCwgY2Fub246J2NvbnN0J319LCAxOTp7ODp7MTM6ezIwOns0OntoaXQ6MjA4MSwgY2Fub246J2NvbnRpbnVlJ319fX19fX19LCAzOns0OnsxOnsyMDp7Njp7Njp7NDp7MTc6e2hpdDoyMDgyLCBjYW5vbjonZGVidWdnZXInfX19fX19LCA1OnswOnsyMDp7MTE6ezE5OntoaXQ6MjA4MywgY2Fub246J2RlZmF1bHQnfX19fX0sIDExOns0OnsxOTp7NDp7aGl0OjIwODQsIGNhbm9uOidkZWxldGUnfX19fX0sIDE0OntoaXQ6MjA4NSwgY2Fub246J2RvJ319LCA0OnsxMTp7MTg6ezQ6e2hpdDoyMDg2LCBjYW5vbjonZWxzZSd9fX0sIDEzOnsyMDp7MTI6e2hpdDoyMDg3LCBjYW5vbjonZW51bSd9fX0sIDIxOnswOnsxMTp7aGl0OjIwODgsIGNhbm9uOidldmFsJ319fSwgMjM6ezE1OnsxNDp7MTc6ezE5OntoaXQ6MjA4OSwgY2Fub246J2V4cG9ydCd9fX19LCAxOTp7NDp7MTM6ezM6ezE4OntoaXQ6MjA5MCwgY2Fub246J2V4dGVuZHMnfX19fX19fSwgNTp7MDp7MTE6ezE4Ons0OntoaXQ6MjA5MSwgY2Fub246J2ZhbHNlJ319fX0sIDg6ezEzOnswOnsxMTp7MTE6ezI0OntoaXQ6MjA5MiwgY2Fub246J2ZpbmFsbHknfX19fX19LCAxNDp7MTc6e2hpdDoyMDkzLCBjYW5vbjonZm9yJ319LCAxNzp7MTQ6ezEyOntoaXQ6MjA5NCwgY2Fub246J2Zyb20nfX19LCAyMDp7MTM6ezI6ezE5Ons4OnsxNDp7MTM6e2hpdDoyMDk1LCBjYW5vbjonZnVuY3Rpb24nfX19fX19fX0sIDY6ezQ6ezE5OntoaXQ6MjA5NiwgY2Fub246J2dldCd9fX0sIDg6ezU6e2hpdDoyMDk3LCBjYW5vbjonaWYnfSwgMTI6ezE1OnsxMTp7NDp7MTI6ezQ6ezEzOnsxOTp7MTg6e2hpdDoyMDk4LCBjYW5vbjonaW1wbGVtZW50cyd9fX19fX19LCAxNDp7MTc6ezE5OntoaXQ6MjA5OSwgY2Fub246J2ltcG9ydCd9fX19fSwgMTM6ezE4OnsxOTp7MDp7MTM6ezI6ezQ6ezE0Ons1OntoaXQ6Njc2MzcsIGNhbm9uOidpbnN0YW5jZW9mJ319fX19fX19LCAxOTp7NDp7MTc6ezU6ezA6ezI6ezQ6e2hpdDoyMTAyLCBjYW5vbjonaW50ZXJmYWNlJ319fX19fX0sIGhpdDo2NzYzNiwgY2Fub246J2luJ319LCAxMTp7NDp7MTk6e2hpdDoyMTAzLCBjYW5vbjonbGV0J319fSwgMTM6ezQ6ezIyOntoaXQ6MjEwNCwgY2Fub246J25ldyd9fSwgMjA6ezExOnsxMTp7aGl0OjIxMDUsIGNhbm9uOidudWxsJ319fX0sIDE0Ons1OntoaXQ6MjEwNiwgY2Fub246J29mJ319LCAxNTp7MDp7Mjp7MTA6ezA6ezY6ezQ6e2hpdDoyMTA3LCBjYW5vbjoncGFja2FnZSd9fX19fX0sIDE3Ons4OnsyMTp7MDp7MTk6ezQ6e2hpdDoyMTA4LCBjYW5vbjoncHJpdmF0ZSd9fX19fSwgMTQ6ezE5Ons0OnsyOnsxOTp7NDp7Mzp7aGl0OjIxMDksIGNhbm9uOidwcm90ZWN0ZWQnfX19fX19fX0sIDIwOnsxOnsxMTp7ODp7Mjp7aGl0OjIxMTAsIGNhbm9uOidwdWJsaWMnfX19fX19LCAxNzp7NDp7MTk6ezIwOnsxNzp7MTM6e2hpdDoyMTExLCBjYW5vbjoncmV0dXJuJ319fX19fSwgMTg6ezQ6ezE5OntoaXQ6MjExMiwgY2Fub246J3NldCd9fSwgMTk6ezA6ezE5Ons4OnsyOntoaXQ6MjExMywgY2Fub246J3N0YXRpYyd9fX19fSwgMjA6ezE1Ons0OnsxNzp7aGl0OjIxMTQsIGNhbm9uOidzdXBlcid9fX19LCAyMjp7ODp7MTk6ezI6ezc6e2hpdDoyMTE1LCBjYW5vbjonc3dpdGNoJ319fX19fSwgMTk6ezA6ezE3Ons2Ons0OnsxOTp7aGl0OjIxMTYsIGNhbm9uOid0YXJnZXQnfX19fX0sIDc6ezg6ezE4OntoaXQ6MjExNywgY2Fub246J3RoaXMnfX0sIDE3OnsxNDp7MjI6e2hpdDoyMTE4LCBjYW5vbjondGhyb3cnfX19fSwgMTc6ezIwOns0OntoaXQ6MjExOSwgY2Fub246J3RydWUnfX0sIDI0OntoaXQ6MjEyMCwgY2Fub246J3RyeSd9fSwgMjQ6ezE1Ons0OnsxNDp7NTp7aGl0OjIxMjEsIGNhbm9uOid0eXBlb2YnfX19fX19LCAyMTp7MDp7MTc6e2hpdDoyMTIyLCBjYW5vbjondmFyJ319LCAxNDp7ODp7Mzp7aGl0OjIxMjMsIGNhbm9uOid2b2lkJ319fX0sIDIyOns3Ons4OnsxMTp7NDp7aGl0OjIxMjQsIGNhbm9uOid3aGlsZSd9fX19LCA4OnsxOTp7Nzp7aGl0OjIxMjUsIGNhbm9uOid3aXRoJ319fX0sIDI0Ons4Ons0OnsxMTp7Mzp7aGl0OjIxMjYsIGNhbm9uOid5aWVsZCd9fX19fX07XG5mdW5jdGlvbiBpc1doaXRlVG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgMjU2KSA9PT0gMjU2O1xufVxuZnVuY3Rpb24gaXNOZXdsaW5lVG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgNTEyKSA9PT0gNTEyO1xufVxuZnVuY3Rpb24gaXNDb21tZW50VG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgMTAyNCkgPT09IDEwMjQ7XG59XG5mdW5jdGlvbiBpc0lkZW50VG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgMjA0OCkgPT09IDIwNDg7XG59XG5mdW5jdGlvbiBpc051bWJlclRva2VuKHR5cGUpIHtcbnJldHVybiAodHlwZSAmIDQwOTYpID09PSA0MDk2O1xufVxuZnVuY3Rpb24gaXNCaWdpbnRUb2tlbih0eXBlKSB7XG5yZXR1cm4gKHR5cGUgJiA4MTkyKSA9PT0gODE5Mjtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nVG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgMTMxMDcyKSA9PT0gMTMxMDcyO1xufVxuZnVuY3Rpb24gaXNQdW5jdHVhdG9yVG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgMTYzODQpID09PSAxNjM4NDtcbn1cbmZ1bmN0aW9uIGlzUmVnZXhUb2tlbih0eXBlKSB7XG5yZXR1cm4gKHR5cGUgJiAyNjIxNDQpID09PSAyNjIxNDQ7XG59XG5mdW5jdGlvbiBpc1RpY2tUb2tlbih0eXBlKSB7XG5yZXR1cm4gKHR5cGUgJiA1MjQyODgpID09PSA1MjQyODg7XG59XG5mdW5jdGlvbiBpc0JhZFRpY2tUb2tlbih0eXBlKSB7XG5yZXR1cm4gKHR5cGUgJiAxMDQ4NTc2KSA9PT0gMTA0ODU3Njtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyU3RyaW5nVG9rZW4odHlwZSkge1xucmV0dXJuICh0eXBlICYgMTM1MTY4KSAhPT0gMDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyU3RyaW5nUmVnZXgodHlwZSkge1xucmV0dXJuICh0eXBlICYgMzk3MzEyKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHRva3R5cGVUb1N0cmluZyh0eXBlLCB0b2tlbiwgaWdub3JlVW5rbm93bikge1xuc3dpdGNoICgoKCh0eXBlb2YgdHlwZSkgPT09ICdvYmplY3QnKT8gdHlwZS50eXBlIDogdHlwZSkpIHtcbmNhc2UgMDpcbnJldHVybiAnVU5UWVBFRCc7XG5jYXNlIDI1NzpcbnJldHVybiAnU1BBQ0UnO1xuY2FzZSAyNTg6XG5yZXR1cm4gJ1RBQic7XG5jYXNlIDc3MTpcbnJldHVybiAnTkxfU09MTyc7XG5jYXNlIDc3MjpcbnJldHVybiAnTkxfQ1JMRic7XG5jYXNlIDEyODU6XG5yZXR1cm4gJ0NPTU1FTlRfU0lOR0xFJztcbmNhc2UgMTI4NjpcbnJldHVybiAnQ09NTUVOVF9NVUxUSSc7XG5jYXNlIDEyODc6XG5yZXR1cm4gJ0NPTU1FTlRfSFRNTCc7XG5jYXNlIDIwNDg6XG5yZXR1cm4gJ0lERU5UJztcbmNhc2UgMjA3MjpcbnJldHVybiAnSURfYXJndW1lbnRzJztcbmNhc2UgMjA3MzpcbnJldHVybiAnSURfYXMnO1xuY2FzZSAyMDc0OlxucmV0dXJuICdJRF9hc3luYyc7XG5jYXNlIDIwNzU6XG5yZXR1cm4gJ0lEX2F3YWl0JztcbmNhc2UgMjA3NjpcbnJldHVybiAnSURfYnJlYWsnO1xuY2FzZSAyMDc3OlxucmV0dXJuICdJRF9jYXNlJztcbmNhc2UgMjA3ODpcbnJldHVybiAnSURfY2F0Y2gnO1xuY2FzZSAyMDc5OlxucmV0dXJuICdJRF9jbGFzcyc7XG5jYXNlIDIwODA6XG5yZXR1cm4gJ0lEX2NvbnN0JztcbmNhc2UgMjA4MTpcbnJldHVybiAnSURfY29udGludWUnO1xuY2FzZSAyMDgyOlxucmV0dXJuICdJRF9kZWJ1Z2dlcic7XG5jYXNlIDIwODM6XG5yZXR1cm4gJ0lEX2RlZmF1bHQnO1xuY2FzZSAyMDg0OlxucmV0dXJuICdJRF9kZWxldGUnO1xuY2FzZSAyMDg1OlxucmV0dXJuICdJRF9kbyc7XG5jYXNlIDIwODY6XG5yZXR1cm4gJ0lEX2Vsc2UnO1xuY2FzZSAyMDg3OlxucmV0dXJuICdJRF9lbnVtJztcbmNhc2UgMjA4ODpcbnJldHVybiAnSURfZXZhbCc7XG5jYXNlIDIwODk6XG5yZXR1cm4gJ0lEX2V4cG9ydCc7XG5jYXNlIDIwOTA6XG5yZXR1cm4gJ0lEX2V4dGVuZHMnO1xuY2FzZSAyMDkxOlxucmV0dXJuICdJRF9mYWxzZSc7XG5jYXNlIDIwOTI6XG5yZXR1cm4gJ0lEX2ZpbmFsbHknO1xuY2FzZSAyMDkzOlxucmV0dXJuICdJRF9mb3InO1xuY2FzZSAyMDk0OlxucmV0dXJuICdJRF9mcm9tJztcbmNhc2UgMjA5NTpcbnJldHVybiAnSURfZnVuY3Rpb24nO1xuY2FzZSAyMDk2OlxucmV0dXJuICdJRF9nZXQnO1xuY2FzZSAyMDk3OlxucmV0dXJuICdJRF9pZic7XG5jYXNlIDIwOTg6XG5yZXR1cm4gJ0lEX2ltcGxlbWVudHMnO1xuY2FzZSAyMDk5OlxucmV0dXJuICdJRF9pbXBvcnQnO1xuY2FzZSA2NzYzNjpcbnJldHVybiAnSURfaW4nO1xuY2FzZSA2NzYzNzpcbnJldHVybiAnSURfaW5zdGFuY2VvZic7XG5jYXNlIDIxMDI6XG5yZXR1cm4gJ0lEX2ludGVyZmFjZSc7XG5jYXNlIDIxMDM6XG5yZXR1cm4gJ0lEX2xldCc7XG5jYXNlIDIxMDQ6XG5yZXR1cm4gJ0lEX25ldyc7XG5jYXNlIDIxMDU6XG5yZXR1cm4gJ0lEX251bGwnO1xuY2FzZSAyMTA2OlxucmV0dXJuICdJRF9vZic7XG5jYXNlIDIxMDc6XG5yZXR1cm4gJ0lEX3BhY2thZ2UnO1xuY2FzZSAyMTA4OlxucmV0dXJuICdJRF9wcml2YXRlJztcbmNhc2UgMjEwOTpcbnJldHVybiAnSURfcHJvdGVjdGVkJztcbmNhc2UgMjExMDpcbnJldHVybiAnSURfcHVibGljJztcbmNhc2UgMjExMTpcbnJldHVybiAnSURfcmV0dXJuJztcbmNhc2UgMjExMjpcbnJldHVybiAnSURfc2V0JztcbmNhc2UgMjExMzpcbnJldHVybiAnSURfc3RhdGljJztcbmNhc2UgMjExNDpcbnJldHVybiAnSURfc3VwZXInO1xuY2FzZSAyMTE1OlxucmV0dXJuICdJRF9zd2l0Y2gnO1xuY2FzZSAyMTE2OlxucmV0dXJuICdJRF90YXJnZXQnO1xuY2FzZSAyMTE3OlxucmV0dXJuICdJRF90aGlzJztcbmNhc2UgMjExODpcbnJldHVybiAnSURfdGhyb3cnO1xuY2FzZSAyMTE5OlxucmV0dXJuICdJRF90cnVlJztcbmNhc2UgMjEyMDpcbnJldHVybiAnSURfdHJ5JztcbmNhc2UgMjEyMTpcbnJldHVybiAnSURfdHlwZW9mJztcbmNhc2UgMjEyMjpcbnJldHVybiAnSURfdmFyJztcbmNhc2UgMjEyMzpcbnJldHVybiAnSURfdm9pZCc7XG5jYXNlIDIxMjQ6XG5yZXR1cm4gJ0lEX3doaWxlJztcbmNhc2UgMjEyNTpcbnJldHVybiAnSURfd2l0aCc7XG5jYXNlIDIxMjY6XG5yZXR1cm4gJ0lEX3lpZWxkJztcbmNhc2UgNDEwNDpcbnJldHVybiAnTlVNQkVSX0hFWCc7XG5jYXNlIDQxMDU6XG5yZXR1cm4gJ05VTUJFUl9ERUMnO1xuY2FzZSA0MTA2OlxucmV0dXJuICdOVU1CRVJfQklOJztcbmNhc2UgNDEwNzpcbnJldHVybiAnTlVNQkVSX09DVCc7XG5jYXNlIDQxMDg6XG5yZXR1cm4gJ05VTUJFUl9PTEQnO1xuY2FzZSAxMjI5NjpcbnJldHVybiAnTlVNQkVSX0JJR19IRVgnO1xuY2FzZSAxMjI5NzpcbnJldHVybiAnTlVNQkVSX0JJR19ERUMnO1xuY2FzZSAxMjI5ODpcbnJldHVybiAnTlVNQkVSX0JJR19CSU4nO1xuY2FzZSAxMjI5OTpcbnJldHVybiAnTlVNQkVSX0JJR19PQ1QnO1xuY2FzZSAxNjQ2MzpcbnJldHVybiAnUFVOQ19FWENMJztcbmNhc2UgODIwMDA6XG5yZXR1cm4gJ1BVTkNfRVhDTF9FUSc7XG5jYXNlIDgyMDAxOlxucmV0dXJuICdQVU5DX0VYQ0xfRVFfRVEnO1xuY2FzZSA4MjAwMjpcbnJldHVybiAnUFVOQ19QRVJDRU5UJztcbmNhc2UgNDkyMzU6XG5yZXR1cm4gJ1BVTkNfUEVSQ0VOVF9FUSc7XG5jYXNlIDgyMDA0OlxucmV0dXJuICdQVU5DX0FORCc7XG5jYXNlIDgyMDA1OlxucmV0dXJuICdQVU5DX0FORF9BTkQnO1xuY2FzZSA0OTIzODpcbnJldHVybiAnUFVOQ19BTkRfRVEnO1xuY2FzZSAxNjQ3MTpcbnJldHVybiAnUFVOQ19QQVJFTl9PUEVOJztcbmNhc2UgMTY0NzI6XG5yZXR1cm4gJ1BVTkNfUEFSRU5fQ0xPU0UnO1xuY2FzZSA4MjAwOTpcbnJldHVybiAnUFVOQ19TVEFSJztcbmNhc2UgODIwMTA6XG5yZXR1cm4gJ1BVTkNfU1RBUl9TVEFSJztcbmNhc2UgNDkyNDM6XG5yZXR1cm4gJ1BVTkNfU1RBUl9FUSc7XG5jYXNlIDQ5MjQ0OlxucmV0dXJuICdQVU5DX1NUQVJfU1RBUl9FUSc7XG5jYXNlIDgyMDEzOlxucmV0dXJuICdQVU5DX1BMVVMnO1xuY2FzZSAxNjQ3ODpcbnJldHVybiAnUFVOQ19QTFVTX1BMVVMnO1xuY2FzZSA0OTI0NzpcbnJldHVybiAnUFVOQ19QTFVTX0VRJztcbmNhc2UgMTY0ODA6XG5yZXR1cm4gJ1BVTkNfQ09NTUEnO1xuY2FzZSA4MjAxNzpcbnJldHVybiAnUFVOQ19NSU4nO1xuY2FzZSAxNjQ4MjpcbnJldHVybiAnUFVOQ19NSU5fTUlOJztcbmNhc2UgNDkyNTE6XG5yZXR1cm4gJ1BVTkNfTUlOX0VRJztcbmNhc2UgMTY0ODQ6XG5yZXR1cm4gJ1BVTkNfTUlOX01JTl9HVCc7XG5jYXNlIDE2NDg1OlxucmV0dXJuICdQVU5DX0RPVCc7XG5jYXNlIDE2NDg2OlxucmV0dXJuICdQVU5DX0RPVF9ET1RfRE9UJztcbmNhc2UgODIwMjM6XG5yZXR1cm4gJ1BVTkNfRElWJztcbmNhc2UgNDkyNTY6XG5yZXR1cm4gJ1BVTkNfRElWX0VRJztcbmNhc2UgMTY0ODk6XG5yZXR1cm4gJ1BVTkNfQ09MT04nO1xuY2FzZSAxNjQ5MDpcbnJldHVybiAnUFVOQ19TRU1JJztcbmNhc2UgODIwMjc6XG5yZXR1cm4gJ1BVTkNfTFQnO1xuY2FzZSA4MjAyODpcbnJldHVybiAnUFVOQ19MVF9MVCc7XG5jYXNlIDgyMDI5OlxucmV0dXJuICdQVU5DX0xUX0VRJztcbmNhc2UgNDkyNjI6XG5yZXR1cm4gJ1BVTkNfTFRfTFRfRVEnO1xuY2FzZSAxNjQ5NTpcbnJldHVybiAnUFVOQ19MVF9FWENMX01JTl9NSU4nO1xuY2FzZSA0OTI2NDpcbnJldHVybiAnUFVOQ19FUSc7XG5jYXNlIDgyMDMzOlxucmV0dXJuICdQVU5DX0VRX0VRJztcbmNhc2UgODIwMzQ6XG5yZXR1cm4gJ1BVTkNfRVFfRVFfRVEnO1xuY2FzZSAxNjQ5OTpcbnJldHVybiAnUFVOQ19FUV9HVCc7XG5jYXNlIDgyMDM2OlxucmV0dXJuICdQVU5DX0dUJztcbmNhc2UgODIwMzc6XG5yZXR1cm4gJ1BVTkNfR1RfR1QnO1xuY2FzZSA4MjAzODpcbnJldHVybiAnUFVOQ19HVF9HVF9HVCc7XG5jYXNlIDgyMDM5OlxucmV0dXJuICdQVU5DX0dUX0VRJztcbmNhc2UgNDkyNzI6XG5yZXR1cm4gJ1BVTkNfR1RfR1RfRVEnO1xuY2FzZSA0OTI3MzpcbnJldHVybiAnUFVOQ19HVF9HVF9HVF9FUSc7XG5jYXNlIDE2NTA2OlxucmV0dXJuICdQVU5DX1FNQVJLJztcbmNhc2UgODIwNDM6XG5yZXR1cm4gJ1FNQVJLX0RPVCc7XG5jYXNlIDgyMDQ0OlxucmV0dXJuICdRTUFSS19RTUFSSyc7XG5jYXNlIDE2NTA5OlxucmV0dXJuICdQVU5DX0JSQUNLRVRfT1BFTic7XG5jYXNlIDE2NTEwOlxucmV0dXJuICdQVU5DX0JSQUNLRVRfQ0xPU0UnO1xuY2FzZSA4MjA0NzpcbnJldHVybiAnUFVOQ19DQVJFVCc7XG5jYXNlIDQ5MjgwOlxucmV0dXJuICdQVU5DX0NBUkVUX0VRJztcbmNhc2UgMTY1MTM6XG5yZXR1cm4gJ1BVTkNfQ1VSTFlfT1BFTic7XG5jYXNlIDgyMDUwOlxucmV0dXJuICdQVU5DX09SJztcbmNhc2UgODIwNTE6XG5yZXR1cm4gJ1BVTkNfT1JfT1InO1xuY2FzZSA0OTI4NDpcbnJldHVybiAnUFVOQ19PUl9FUSc7XG5jYXNlIDE2NTE3OlxucmV0dXJuICdQVU5DX0NVUkxZX0NMT1NFJztcbmNhc2UgMTY1MTg6XG5yZXR1cm4gJ1BVTkNfVElMREUnO1xuY2FzZSAyNjIxNTc6XG5yZXR1cm4gJ1JFR0VYTic7XG5jYXNlIDI2MjE1ODpcbnJldHVybiAnUkVHRVhVJztcbmNhc2UgMTMxMDg3OlxucmV0dXJuICdTVFJJTkdfU0lOR0xFJztcbmNhc2UgMTMxMDg4OlxucmV0dXJuICdTVFJJTkdfRE9VQkxFJztcbmNhc2UgNTI0MzA1OlxucmV0dXJuICdUSUNLX0hFQUQnO1xuY2FzZSA1MjQzMDY6XG5yZXR1cm4gJ1RJQ0tfQk9EWSc7XG5jYXNlIDUyNDMwNzpcbnJldHVybiAnVElDS19UQUlMJztcbmNhc2UgNTI0MzA4OlxucmV0dXJuICdUSUNLX1BVUkUnO1xuY2FzZSAxNTcyODgxOlxucmV0dXJuICdUSUNLX0JBRF9IRUFEJztcbmNhc2UgMTU3Mjg4MjpcbnJldHVybiAnVElDS19CQURfQk9EWSc7XG5jYXNlIDE1NzI4ODM6XG5yZXR1cm4gJ1RJQ0tfQkFEX1RBSUwnO1xuY2FzZSAxNTcyODg0OlxucmV0dXJuICdUSUNLX0JBRF9QVVJFJztcbmNhc2UgMjA5NzE3MzpcbnJldHVybiAnRU9GJztcbmNhc2UgMjA5NzE3NDpcbnJldHVybiAnQVNJJztcbmNhc2UgMjA5NzE3NTpcbnJldHVybiAnRVJST1InO1xufVxuaWYgKGlnbm9yZVVua25vd24pIHJldHVybiAoJ1VOS05PV05bJyArICgoKCh0eXBlb2YgdHlwZSkgPT09ICdvYmplY3QnKT8gdHlwZS50eXBlIDogdHlwZSkpKSArICddJztcbnRocm93IG5ldyBFcnJvcigoJ3Rva3R5cGVUb1N0cmluZzogVU5LTk9XTlsnICsgSlNPTi5zdHJpbmdpZnkodHlwZSkpICsgJ10nKTtcbn1cbmxldCBNQVhfU1RBUlRfVkFMVUUgPSAyNjtcbmxldCBfXyRmbGFnX3N0YXJ0ID0gMDtcbmxldCB0b2tlblN0YXJ0SnVtcFRhYmxlID0gWzI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDEsIDQsIDEsIDEsIDUsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDI2LCAyNiwgMjYsIDEsIDE2LCA2LCAyNiwgMiwgMTcsIDE4LCA2LCAxNjQ3MSwgMTY0NzIsIDE5LCAxMiwgMTY0ODAsIDEzLCA4LCAxMSwgMTQsIDcsIDcsIDcsIDcsIDcsIDcsIDcsIDcsIDcsIDE2NDg5LCAxNjQ5MCwgMjEsIDEwLCAyMiwgMjUsIDI2LCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAyLCAxNjUwOSwgMjQsIDE2NTEwLCAyMCwgMiwgMTUsIDMsIDMsIDMsIDMsIDMsIDMsIDMsIDIsIDMsIDIsIDIsIDMsIDIsIDMsIDMsIDMsIDIsIDMsIDMsIDMsIDIsIDMsIDMsIDIsIDMsIDIsIDE2NTEzLCAyMywgOSwgMTY1MThdO1xubGV0IHN0cmluZ1NjYW5UYWJsZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCA0LCAwLCAwLCA0LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbmxldCBpZGVudFNjYW5UYWJsZSA9IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAyLCAxLCAxLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxXTtcbmxldCByZWdleEF0b21Fc2NhcGVTdGFydEp1bXBUYWJsZSA9IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxMCwgMSwgMSwgMTAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsIDEsIDAsIDAsIDcsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDgsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDExLCAxMSwgMTEsIDAsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgMTEsIDExLCAxMSwgNiwgMTEsIDExLCAwLCAxMSwgMTEsIDExLCAwLCAxMSwgMTEsIDExLCAwLCAwLCAwLCAwLCAxMSwgMSwgMTEsIDExLCA1LCAwLCAxMSwgMCwgMTEsIDExLCAxMSwgMTEsIDksIDExLCAxMSwgMCwgMTEsIDYsIDExLCAwLCAwLCAwLCAyLCAwLCAwLCAzLCAxMSwgMTEsIDAsIDAsIDAsIDFdO1xubGV0IHJlZ2V4Q2xhc3NFc2NhcGVTdGFydEp1bXBUYWJsZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDE4LCAwLCAwLCAwLCAxOCwgMTgsIDE4LCAxOCwgMCwgMTksIDE4LCAxOCwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDAsIDAsIDAsIDAsIDAsIDE4LCAwLCAwLCA3LCAwLCAxMywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTQsIDAsIDAsIDEzLCAwLCAwLCAwLCAxMywgMCwgMCwgMCwgMTgsIDE4LCAxOCwgMTgsIDAsIDAsIDAsIDYsIDQsIDEzLCAwLCA4LCAwLCAwLCAwLCAwLCA1LCAwLCAwLCA5LCAwLCAxNCwgMCwgMTAsIDEzLCAxMSwgMiwgMTIsIDEzLCAzLCAwLCAwLCAxOCwgMTgsIDE4LCAwXTtcbmxldCBoZXhWYWx1ZUp1bXBUYWJsZSA9IFsxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1XTtcbmxldCByZWdleEF0b21KdW1wVGFibGUgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTUsIDAsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxMCwgMCwgMCwgMCwgMywgNCwgMiwgMiwgMCwgMCwgMSwgOCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgNSwgNywgNiwgOSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTIsIDE0LCAxMywgMF07XG5sZXQgc3RyaW5nRXNjYXBlU3RhcnRKdW1wVGFibGUgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTAsIDAsIDAsIDksIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDMsIDAsIDAsIDAsIDAsIDIsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDExLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDEyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxMywgMCwgMCwgMCwgMTQsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDgsIDAsIDcsIDQsIDE1LCAwLCA1LCAwLCAwLCAwLCAwLCAwLCAwXTtcbmZ1bmN0aW9uIGdldFRva2VuU3RhcnQoYykge1xubGV0IHMgPSB0b2tlblN0YXJ0SnVtcFRhYmxlW2NdO1xucmV0dXJuIHM7XG59XG5mdW5jdGlvbiBnZXRTdHJpbmdQYXJ0KGMpIHtcbmlmIChjID4gMHg3ZSkgcmV0dXJuIDM7XG5sZXQgcyA9IHN0cmluZ1NjYW5UYWJsZVtjXTtcbnJldHVybiBzO1xufVxuZnVuY3Rpb24gZ2V0SWRlbnRQYXJ0KGMpIHtcbmlmIChjID4gMHg3ZSkgcmV0dXJuIDM7XG5sZXQgcyA9IGlkZW50U2NhblRhYmxlW2NdO1xucmV0dXJuIHM7XG59XG5mdW5jdGlvbiBnZXRIZXhWYWx1ZShjKSB7XG5pZiAoYyA+IDB4NjYpIHJldHVybiAxNjtcbmxldCB2ID0gaGV4VmFsdWVKdW1wVGFibGVbY107XG5yZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFQodHlwZSkge1xucmV0dXJuICgnVDwnICsgdG9rdHlwZVRvU3RyaW5nKHR5cGUpKSArICc+Jztcbn1cbi8vIDwvdG9rZW50eXBlPlxuXG4vLyA8bGV4ZXJmbGFncz5cbmxldCBfXyRmbGFnX2xmID0gMDtcbmZ1bmN0aW9uIEwoZmxhZ3MpIHtcbmxldCBiYWsgPSBmbGFncztcbmxldCBzID0gW107XG5pZiAoIWZsYWdzKSB7XG5zLnB1c2goJ0xGX05PX0ZMQUdTJyk7XG59XG5pZiAoZmxhZ3MgJiA4MTkyKSB7XG5mbGFncyBePSA4MTkyO1xucy5wdXNoKCdMRl9TVFJJQ1RfTU9ERScpO1xufVxuaWYgKGZsYWdzICYgNCkge1xuZmxhZ3MgXj0gNDtcbnMucHVzaCgnTEZfRk9SX1JFR0VYJyk7XG59XG5pZiAoZmxhZ3MgJiAyMDQ4KSB7XG5mbGFncyBePSAyMDQ4O1xucy5wdXNoKCdMRl9JTl9URU1QTEFURScpO1xufVxuaWYgKGZsYWdzICYgOCkge1xuZmxhZ3MgXj0gODtcbnMucHVzaCgnTEZfSU5fQVNZTkMnKTtcbn1cbmlmIChmbGFncyAmIDEyOCkge1xuZmxhZ3MgXj0gMTI4O1xucy5wdXNoKCdMRl9JTl9HRU5FUkFUT1InKTtcbn1cbmlmIChmbGFncyAmIDE2KSB7XG5mbGFncyBePSAxNjtcbnMucHVzaCgnTEZfSU5fQ09OU1RSVUNUT1InKTtcbn1cbmlmIChmbGFncyAmIDY0KSB7XG5mbGFncyBePSA2NDtcbnMucHVzaCgnTEZfSU5fRlVOQ19BUkdTJyk7XG59XG5pZiAoZmxhZ3MgJiAyNTYpIHtcbmZsYWdzIF49IDI1NjtcbnMucHVzaCgnTEZfSU5fR0xPQkFMJyk7XG59XG5pZiAoZmxhZ3MgJiA1MTIpIHtcbmZsYWdzIF49IDUxMjtcbnMucHVzaCgnTEZfSU5fSVRFUkFUSU9OJyk7XG59XG5pZiAoZmxhZ3MgJiAxMDI0KSB7XG5mbGFncyBePSAxMDI0O1xucy5wdXNoKCdMRl9JTl9TV0lUQ0gnKTtcbn1cbmlmIChmbGFncyAmIDIpIHtcbmZsYWdzIF49IDI7XG5zLnB1c2goJ0xGX0NBTl9ORVdfRE9UX1RBUkdFVCcpO1xufVxuaWYgKGZsYWdzICYgMzIpIHtcbmZsYWdzIF49IDMyO1xucy5wdXNoKCdMRl9JTl9GT1JfTEhTJyk7XG59XG5pZiAoZmxhZ3MgJiA0MDk2KSB7XG5mbGFncyBePSA0MDk2O1xucy5wdXNoKCdMRl9OT19BU0knKTtcbn1cbmlmIChmbGFncyAmIDE2Mzg0KSB7XG5mbGFncyBePSAxNjM4NDtcbnMucHVzaCgnTEZfU1VQRVJfQ0FMTCcpO1xufVxuaWYgKGZsYWdzICYgMzI3NjgpIHtcbmZsYWdzIF49IDMyNzY4O1xucy5wdXNoKCdMRl9TVVBFUl9QUk9QJyk7XG59XG5pZiAoZmxhZ3MgJiA2NTUzNikge1xuZmxhZ3MgXj0gNjU1MzY7XG5zLnB1c2goJ0xGX05PVF9LRVlXT1JEJyk7XG59XG5pZiAoZmxhZ3MpIHtcbnRocm93IG5ldyBFcnJvcigoKCgoKCdVTktOT1dOX0ZMQUdTOiAnICsgZmxhZ3MudG9TdHJpbmcoMikpICsgJyAod2FzOiAnKSArIGJhay50b1N0cmluZygyKSkgKyAnKSwgc28gZmFyOiBbJykgKyBzLmpvaW4oJ3wnKSkgKyAnXScpO1xufVxucmV0dXJuICdMOicgKyBzLmpvaW4oJ3wnKTtcbn1cbi8vIDwvbGV4ZXJmbGFncz5cblxuLy8gPGVudW1fbGV4ZXI+XG5jb25zdCBHT0FMX01PRFVMRSA9IHRydWU7XG5jb25zdCBHT0FMX1NDUklQVCA9IGZhbHNlO1xuY29uc3QgQ09MTEVDVF9UT0tFTlNfTk9ORSA9IDA7XG5jb25zdCBDT0xMRUNUX1RPS0VOU19TT0xJRCA9IDE7XG5jb25zdCBDT0xMRUNUX1RPS0VOU19BTEwgPSAyO1xuY29uc3QgQ09MTEVDVF9UT0tFTlNfVFlQRVMgPSAzO1xuY29uc3QgV0VCX0NPTVBBVF9PRkYgPSBmYWxzZTtcbmNvbnN0IFdFQl9DT01QQVRfT04gPSB0cnVlO1xuLy8gPC9lbnVtX2xleGVyPlxuXG4vLyA8ZW51bV9wYXJzZXI+XG5jb25zdCBWRVJTSU9OX0VYUE9ORU5USUFUSU9OID0gNztcbmNvbnN0IFZFUlNJT05fV0hBVEVWRVIgPSBJbmZpbml0eTtcbmZ1bmN0aW9uIERFVk9OTFkoKSB7XG5sZXQgZGV2ID0gZmFsc2U7XG5yZXR1cm4gZGV2O1xufVxuZnVuY3Rpb24gY29weVBpZ2dpZXMob3V0cHV0LCBpbnB1dCkge1xucmV0dXJuIG91dHB1dCB8IChpbnB1dCAmIDE5ODQpO1xufVxuZnVuY3Rpb24gUChmLCBhcnIpIHtcbmlmIChmICYgMjU2KSB7XG5hcnIucHVzaCgnUElHR1lfQkFDS19XQVNfQ09OU1RSVUNUT1InKTtcbmYgXj0gMjU2O1xufVxuaWYgKGYgJiA1MTIpIHtcbmFyci5wdXNoKCdQSUdHWV9CQUNLX1dBU19QUk9UTycpO1xuZiBePSA1MTI7XG59XG5pZiAoZiAmIDY0KSB7XG5hcnIucHVzaCgnUElHR1lfQkFDS19TQVdfQVdBSVQnKTtcbmYgXj0gNjQ7XG59XG5pZiAoZiAmIDEyOCkge1xuYXJyLnB1c2goJ1BJR0dZX0JBQ0tfU0FXX1lJRUxEJyk7XG5mIF49IDEyODtcbn1cbmlmIChmICYgMTAyNCkge1xuYXJyLnB1c2goJ1BJR0dZX0JBQ0tfV0FTX0FSUk9XJyk7XG5mIF49IDEwMjQ7XG59XG5yZXR1cm4gZjtcbn1cbi8vIDwvZW51bV9wYXJzZXI+XG5cbi8vIDxsZXhlcj5cbmNvbnN0IFRBQkxFX05PTkJJTl9VTklfUFJPUFMgPSAnLEdlbmVyYWxfQ2F0ZWdvcnksZ2MsU2NyaXB0LHNjLFNjcmlwdF9FeHRlbnNpb25zLHNjeCwnO1xuY29uc3QgVEFCTEVfQklOX1VOSV9QUk9QUyA9ICcsQVNDSUksQVNDSUlfSGV4X0RpZ2l0LEFIZXgsQWxwaGFiZXRpYyxBbHBoYSxBbnksQXNzaWduZWQsQmlkaV9Db250cm9sLEJpZGlfQyxCaWRpX01pcnJvcmVkLEJpZGlfTSxDYXNlX0lnbm9yYWJsZSxDSSxDYXNlZCxDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCxDV0NGLENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkLENXQ00sQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQsQ1dMLENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQsQ1dLQ0YsQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQsQ1dULENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkLENXVSxEYXNoLERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQsREksRGVwcmVjYXRlZCxEZXAsRGlhY3JpdGljLERpYSxFbW9qaSxFbW9qaV9Db21wb25lbnQsRW1vamlfTW9kaWZpZXIsRW1vamlfTW9kaWZpZXJfQmFzZSxFbW9qaV9QcmVzZW50YXRpb24sRXh0ZW5kZWRfUGljdG9ncmFwaGljLEV4dGVuZGVyLEV4dCxHcmFwaGVtZV9CYXNlLEdyX0Jhc2UsR3JhcGhlbWVfRXh0ZW5kLEdyX0V4dCxIZXhfRGlnaXQsSGV4LElEU19CaW5hcnlfT3BlcmF0b3IsSURTQixJRFNfVHJpbmFyeV9PcGVyYXRvcixJRFNULElEX0NvbnRpbnVlLElEQyxJRF9TdGFydCxJRFMsSWRlb2dyYXBoaWMsSWRlbyxKb2luX0NvbnRyb2wsSm9pbl9DLExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uLExPRSxMb3dlcmNhc2UsTG93ZXIsTWF0aCxOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCxOQ2hhcixQYXR0ZXJuX1N5bnRheCxQYXRfU3luLFBhdHRlcm5fV2hpdGVfU3BhY2UsUGF0X1dTLFF1b3RhdGlvbl9NYXJrLFFNYXJrLFJhZGljYWwsUmVnaW9uYWxfSW5kaWNhdG9yLFJJLFNlbnRlbmNlX1Rlcm1pbmFsLFNUZXJtLFNvZnRfRG90dGVkLFNELFRlcm1pbmFsX1B1bmN0dWF0aW9uLFRlcm0sVW5pZmllZF9JZGVvZ3JhcGgsVUlkZW8sVXBwZXJjYXNlLFVwcGVyLFZhcmlhdGlvbl9TZWxlY3RvcixWUyxXaGl0ZV9TcGFjZSxzcGFjZSxYSURfQ29udGludWUsWElEQyxYSURfU3RhcnQsWElEUywnO1xuY29uc3QgVEFCTEVfR0VOX0NBVF9WQUxVRVMgPSAnLENhc2VkX0xldHRlcixMQyxDbG9zZV9QdW5jdHVhdGlvbixQZSxDb25uZWN0b3JfUHVuY3R1YXRpb24sUGMsQ29udHJvbCxDYyxjbnRybCxDdXJyZW5jeV9TeW1ib2wsU2MsRGFzaF9QdW5jdHVhdGlvbixQZCxEZWNpbWFsX051bWJlcixOZCxkaWdpdCxFbmNsb3NpbmdfTWFyayxNZSxGaW5hbF9QdW5jdHVhdGlvbixQZixGb3JtYXQsQ2YsSW5pdGlhbF9QdW5jdHVhdGlvbixQaSxMZXR0ZXIsTCxMZXR0ZXJfTnVtYmVyLE5sLExpbmVfU2VwYXJhdG9yLFpsLExvd2VyY2FzZV9MZXR0ZXIsTGwsTWFyayxNLENvbWJpbmluZ19NYXJrLE1hdGhfU3ltYm9sLFNtLE1vZGlmaWVyX0xldHRlcixMbSxNb2RpZmllcl9TeW1ib2wsU2ssTm9uc3BhY2luZ19NYXJrLE1uLE51bWJlcixOLE9wZW5fUHVuY3R1YXRpb24sUHMsT3RoZXIsQyxPdGhlcl9MZXR0ZXIsTG8sT3RoZXJfTnVtYmVyLE5vLE90aGVyX1B1bmN0dWF0aW9uLFBvLE90aGVyX1N5bWJvbCxTbyxQYXJhZ3JhcGhfU2VwYXJhdG9yLFpwLFByaXZhdGVfVXNlLENvLFB1bmN0dWF0aW9uLFAscHVuY3QsU2VwYXJhdG9yLFosU3BhY2VfU2VwYXJhdG9yLFpzLFNwYWNpbmdfTWFyayxNYyxTdXJyb2dhdGUsQ3MsU3ltYm9sLFMsVGl0bGVjYXNlX0xldHRlcixMdCxVbmFzc2lnbmVkLENuLFVwcGVyY2FzZV9MZXR0ZXIsTHUsJztcbmNvbnN0IFRBQkxFX1NDUklQVF9WQUxVRVMgPSAnLEFkbGFtLEFkbG0sQWhvbSxBbmF0b2xpYW5fSGllcm9nbHlwaHMsSGx1dyxBcmFiaWMsQXJhYixBcm1lbmlhbixBcm1uLEF2ZXN0YW4sQXZzdCxCYWxpbmVzZSxCYWxpLEJhbXVtLEJhbXUsQmFzc2FfVmFoLEJhc3MsQmF0YWssQmF0ayxCZW5nYWxpLEJlbmcsQmhhaWtzdWtpLEJoa3MsQm9wb21vZm8sQm9wbyxCcmFobWksQnJhaCxCcmFpbGxlLEJyYWksQnVnaW5lc2UsQnVnaSxCdWhpZCxCdWhkLENhbmFkaWFuX0Fib3JpZ2luYWwsQ2FucyxDYXJpYW4sQ2FyaSxDYXVjYXNpYW5fQWxiYW5pYW4sQWdoYixDaGFrbWEsQ2FrbSxDaGFtLENoZXJva2VlLENoZXIsQ29tbW9uLFp5eXksQ29wdGljLENvcHQsUWFhYyxDdW5laWZvcm0sWHN1eCxDeXByaW90LENwcnQsQ3lyaWxsaWMsQ3lybCxEZXNlcmV0LERzcnQsRGV2YW5hZ2FyaSxEZXZhLERvZ3JhLERvZ3IsRHVwbG95YW4sRHVwbCxFZ3lwdGlhbl9IaWVyb2dseXBocyxFZ3lwLEVsYmFzYW4sRWxiYSxFbHltYWljLEVseW0sRXRoaW9waWMsRXRoaSxHZW9yZ2lhbixHZW9yLEdsYWdvbGl0aWMsR2xhZyxHb3RoaWMsR290aCxHcmFudGhhLEdyYW4sR3JlZWssR3JlayxHdWphcmF0aSxHdWpyLEd1bmphbGFfR29uZGksR29uZyxHdXJtdWtoaSxHdXJ1LEhhbixIYW5pLEhhbmd1bCxIYW5nLEhhbmlmaV9Sb2hpbmd5YSxSb2hnLEhhbnVub28sSGFubyxIYXRyYW4sSGF0cixIZWJyZXcsSGVicixIaXJhZ2FuYSxIaXJhLEltcGVyaWFsX0FyYW1haWMsQXJtaSxJbmhlcml0ZWQsWmluaCxRYWFpLEluc2NyaXB0aW9uYWxfUGFobGF2aSxQaGxpLEluc2NyaXB0aW9uYWxfUGFydGhpYW4sUHJ0aSxKYXZhbmVzZSxKYXZhLEthaXRoaSxLdGhpLEthbm5hZGEsS25kYSxLYXRha2FuYSxLYW5hLEtheWFoX0xpLEthbGksS2hhcm9zaHRoaSxLaGFyLEtobWVyLEtobXIsS2hvamtpLEtob2osS2h1ZGF3YWRpLFNpbmQsTGFvLExhb28sTGF0aW4sTGF0bixMZXBjaGEsTGVwYyxMaW1idSxMaW1iLExpbmVhcl9BLExpbmEsTGluZWFyX0IsTGluYixMaXN1LEx5Y2lhbixMeWNpLEx5ZGlhbixMeWRpLE1haGFqYW5pLE1haGosTWFrYXNhcixNYWthLE1hbGF5YWxhbSxNbHltLE1hbmRhaWMsTWFuZCxNYW5pY2hhZWFuLE1hbmksTWFyY2hlbixNYXJjLE1lZGVmYWlkcmluLE1lZGYsTWFzYXJhbV9Hb25kaSxHb25tLE1lZXRlaV9NYXllayxNdGVpLE1lbmRlX0tpa2FrdWksTWVuZCxNZXJvaXRpY19DdXJzaXZlLE1lcmMsTWVyb2l0aWNfSGllcm9nbHlwaHMsTWVybyxNaWFvLFBscmQsTW9kaSxNb25nb2xpYW4sTW9uZyxNcm8sTXJvbyxNdWx0YW5pLE11bHQsTXlhbm1hcixNeW1yLE5hYmF0YWVhbixOYmF0LE5hbmRpbmFnYXJpLE5hbmQsTmV3X1RhaV9MdWUsVGFsdSxOZXdhLE5rbyxOa29vLE51c2h1LE5zaHUsTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyxIbW5wLE9naGFtLE9nYW0sT2xfQ2hpa2ksT2xjayxPbGRfSHVuZ2FyaWFuLEh1bmcsT2xkX0l0YWxpYyxJdGFsLE9sZF9Ob3J0aF9BcmFiaWFuLE5hcmIsT2xkX1Blcm1pYyxQZXJtLE9sZF9QZXJzaWFuLFhwZW8sT2xkX1NvZ2RpYW4sU29nbyxPbGRfU291dGhfQXJhYmlhbixTYXJiLE9sZF9UdXJraWMsT3JraCxPcml5YSxPcnlhLE9zYWdlLE9zZ2UsT3NtYW55YSxPc21hLFBhaGF3aF9IbW9uZyxIbW5nLFBhbG15cmVuZSxQYWxtLFBhdV9DaW5fSGF1LFBhdWMsUGhhZ3NfUGEsUGhhZyxQaG9lbmljaWFuLFBobngsUHNhbHRlcl9QYWhsYXZpLFBobHAsUmVqYW5nLFJqbmcsUnVuaWMsUnVucixTYW1hcml0YW4sU2FtcixTYXVyYXNodHJhLFNhdXIsU2hhcmFkYSxTaHJkLFNoYXZpYW4sU2hhdyxTaWRkaGFtLFNpZGQsU2lnbldyaXRpbmcsU2dudyxTaW5oYWxhLFNpbmgsU29nZGlhbixTb2dkLFNvcmFfU29tcGVuZyxTb3JhLFNveW9tYm8sU295byxTdW5kYW5lc2UsU3VuZCxTeWxvdGlfTmFncmksU3lsbyxTeXJpYWMsU3lyYyxUYWdhbG9nLFRnbGcsVGFnYmFud2EsVGFnYixUYWlfTGUsVGFsZSxUYWlfVGhhbSxMYW5hLFRhaV9WaWV0LFRhdnQsVGFrcmksVGFrcixUYW1pbCxUYW1sLFRhbmd1dCxUYW5nLFRlbHVndSxUZWx1LFRoYWFuYSxUaGFhLFRoYWksVGliZXRhbixUaWJ0LFRpZmluYWdoLFRmbmcsVGlyaHV0YSxUaXJoLFVnYXJpdGljLFVnYXIsVmFpLFZhaWksV2FuY2hvLFdjaG8sV2FyYW5nX0NpdGksV2FyYSxZaSxZaWlpLFphbmFiYXphcl9TcXVhcmUsWmFuYiwnO1xubGV0IElEX1NUQVJUX1JFR0VYID0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gZ2V0SWRTdGFydFJlZ2V4U3VwZXJTbG93KCkge1xuaWYgKElEX1NUQVJUX1JFR0VYKSByZXR1cm4gSURfU1RBUlRfUkVHRVg7XG5yZXR1cm4gSURfU1RBUlRfUkVHRVggPSBjcmVhdGVVbmljb2RlUmVnZXgoJ15cXFxccHtJRF9TdGFydH0kJyk7XG59XG5sZXQgSURfQ09OVElOVUVfUkVHRVggPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRJZFJlc3RSZWdleFN1cGVyU2xvdygpIHtcbmlmIChJRF9DT05USU5VRV9SRUdFWCkgcmV0dXJuIElEX0NPTlRJTlVFX1JFR0VYO1xucmV0dXJuIElEX0NPTlRJTlVFX1JFR0VYID0gY3JlYXRlVW5pY29kZVJlZ2V4KCdeXFxcXHB7SURfQ29udGludWV9JCcpO1xufVxuZnVuY3Rpb24gY3JlYXRlVW5pY29kZVJlZ2V4KHBhdHRlcm4pIHtcbnRyeSB7XG5yZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAndScpO1xufSBjYXRjaCAoZSkge1xuY29uc29sZS53YXJuKCgnVGVua286IEN1cnJlbnQgbm9kZWpzIHZlcnNpb24gZG9lcyBub3Qgc3VwcHBvcnQgdW5pY29kZSByZWdleGVzIG9yIHJlZ2V4IHByb3BlcnR5IGVzY2FwZXM7IElucHV0IGNvbnRhaW5zIHVuaWNvZGUgdGhhdCByZXF1aXJlcyBpdCBzbyBUZW5rbyBpcyB1bmFibGUgdG8gcHJvcGVybHkgcGFyc2UgaW5wdXQgKCcgKyBlLm1lc3NhZ2UpICsgJyknKTtcbnJldHVybiAvfC87XG59XG59XG5mdW5jdGlvbiBMZXhlcihpbnB1dCwgb3B0aW9ucykge1xuY29uc3Qge3RhcmdldEVzVmVyc2lvbiA9IEluZmluaXR5LCBwYXJzaW5nR29hbCA9IHRydWUsIGNvbGxlY3RUb2tlbnMgPSAwLCByZXR1cm5Ub2tlbnMgPSAzLCB3ZWJDb21wYXQgPSB0cnVlLCBncmFjZWZ1bEVycm9ycyA9IGZhbHNlLCB0b2tlblN0b3JhZ2VFeHRlcm5hbCwgYmFiZWxUb2tlbkNvbXBhdCA9IGZhbHNlLCBlcnJvckNvZGVGcmFtZSA9IHRydWUsIHRydW5jQ29kZUZyYW1lID0gZmFsc2UsICRsb2cgPSBjb25zb2xlLmxvZywgJHdhcm4gPSBjb25zb2xlLndhcm4sICRlcnJvciA9IGNvbnNvbGUuZXJyb3J9ID0gb3B0aW9ucztcbmNvbnN0IHRva2VuU3RvcmFnZSA9ICh0b2tlblN0b3JhZ2VFeHRlcm5hbCB8fCAoKChjb2xsZWN0VG9rZW5zICE9PSAwKT8gW10gOiB1bmRlZmluZWQpKSk7XG5jb25zdCBzdXBwb3J0UmVnZXhQcm9wZXJ0eUVzY2FwZXMgPSAoKHRhcmdldEVzVmVyc2lvbiA+PSA5KSB8fCAodGFyZ2V0RXNWZXJzaW9uID09PSBJbmZpbml0eSkpO1xuY29uc3Qgc3VwcG9ydFJlZ2V4TG9va2JlaGluZHMgPSAoKHRhcmdldEVzVmVyc2lvbiA+PSA5KSB8fCAodGFyZ2V0RXNWZXJzaW9uID09PSBJbmZpbml0eSkpO1xuY29uc3Qgc3VwcG9ydFJlZ2V4RG90YWxsRmxhZyA9ICgodGFyZ2V0RXNWZXJzaW9uID49IDkpIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5jb25zdCBzdXBwb3J0UmVnZXhOYW1lZEdyb3VwcyA9ICgodGFyZ2V0RXNWZXJzaW9uID49IDkpIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5jb25zdCBzdXBwb3J0QmlnSW50ID0gKCh0YXJnZXRFc1ZlcnNpb24gPT09IDExKSB8fCAodGFyZ2V0RXNWZXJzaW9uID09PSBJbmZpbml0eSkpO1xuY29uc3Qgc3VwcG9ydE51bGxpc2hDb2FsZXNjaW5nID0gKCh0YXJnZXRFc1ZlcnNpb24gPT09IDExKSB8fCAodGFyZ2V0RXNWZXJzaW9uID09PSBJbmZpbml0eSkpO1xuY29uc3Qgc3VwcG9ydE9wdGlvbmFsQ2hhaW5pbmcgPSAoKHRhcmdldEVzVmVyc2lvbiA9PT0gMTEpIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5sZXQgcG9pbnRlciA9IDA7XG5sZXQgbGVuID0gaW5wdXQubGVuZ3RoO1xubGV0IGNvbnN1bWVkTmV3bGluZXNCZWZvcmVTb2xpZCA9IGZhbHNlO1xubGV0IG5sd2FzID0gZmFsc2U7XG5sZXQgZmluaXNoZWQgPSBmYWxzZTtcbmxldCBsYXN0T2Zmc2V0ID0gcG9pbnRlcjtcbmxldCBzdGFydEZvckVycm9yID0gMDtcbmxldCBsYXN0VHlwZSA9IDA7XG5sZXQgbGFzdFN0YXJ0ID0gMDtcbmxldCBsYXN0U3RvcCA9IDA7XG5sZXQgbGFzdExpbmUgPSAwO1xubGV0IGxhc3RDb2x1bW4gPSAwO1xubGV0IGxhc3RDYW5vbml6ZWRJbnB1dCA9ICcnO1xubGV0IGxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IDA7XG5sZXQgbGFzdFBvdGVudGlhbFJlZ2V4RXJyb3IgPSAnJztcbmxldCBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnJztcbmxldCBjdXJyZW50TGluZSA9IDE7XG5sZXQgY3VycmVudENvbE9mZnNldCA9IDA7XG5sZXQgcHJldlRva2VuRW5kQ29sdW1uID0gMDtcbmxldCBwcmV2VG9rZW5FbmRMaW5lID0gMDtcbmxldCBwcmV2VG9rZW5FbmRQb2ludGVyID0gMDtcbmxldCBwcmV2VG9rZW5Tb2xpZCA9IHRydWU7XG5sZXQgc3RhbGUgPSBmYWxzZTtcbmxldCBjYWNoZSA9IGlucHV0LmNoYXJDb2RlQXQoMCk7XG5sZXQgYW55VG9rZW5Db3VudCA9IDA7XG5sZXQgc29saWRUb2tlbkNvdW50ID0gMDtcbmZ1bmN0aW9uIHBlZWsoKSB7XG5yZXR1cm4gY2FjaGU7XG59XG5mdW5jdGlvbiBfcmVhZENhY2hlKCkge1xucmV0dXJuIGNhY2hlO1xufVxuZnVuY3Rpb24gcGVla2QoZGVsdGEpIHtcbnJldHVybiBpbnB1dC5jaGFyQ29kZUF0KHBvaW50ZXIgKyBkZWx0YSk7XG59XG5mdW5jdGlvbiBwZWVreShvcmQpIHtcbnJldHVybiBjYWNoZSA9PT0gb3JkO1xufVxuZnVuY3Rpb24gc2xpY2UoZnJvbSwgdG8pIHtcbnJldHVybiBpbnB1dC5zbGljZShmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBza2lwUGVlaygpIHtcbnJldHVybiBjYWNoZSA9IGlucHV0LmNoYXJDb2RlQXQoKytwb2ludGVyKTtcbn1cbmZ1bmN0aW9uIHNraXAoKSB7XG5sZXQgcCA9ICsrcG9pbnRlcjtcbmlmIChwb2ludGVyID49IGxlbikge1xuY2FjaGUgPSAwO1xucmV0dXJuO1xufVxuY2FjaGUgPSBpbnB1dC5jaGFyQ29kZUF0KHApO1xufVxuZnVuY3Rpb24gc2tpcEZhc3RXaXRob3V0VXBkYXRpbmdDYWNoZSgpIHtcbisrcG9pbnRlcjtcbn1cbmZ1bmN0aW9uIGVvZigpIHtcbnJldHVybiBwb2ludGVyID49IGxlbjtcbn1cbmZ1bmN0aW9uIGVvZmQoZCkge1xucmV0dXJuIHBvaW50ZXIgPj0gKGxlbiAtIGQpO1xufVxuZnVuY3Rpb24gbmVvZigpIHtcbnJldHVybiBwb2ludGVyIDwgbGVuO1xufVxuZnVuY3Rpb24gbmVvZmQoZCkge1xucmV0dXJuIHBvaW50ZXIgPD0gKGxlbiAtIGQpO1xufVxuZnVuY3Rpb24gbmV4dFRva2VuKGxleGVyRmxhZ3MpIHtcbmlmIChwcmV2VG9rZW5Tb2xpZCkge1xucHJldlRva2VuRW5kQ29sdW1uID0gcG9pbnRlciAtIGN1cnJlbnRDb2xPZmZzZXQ7XG5wcmV2VG9rZW5FbmRMaW5lID0gY3VycmVudExpbmU7XG5wcmV2VG9rZW5FbmRQb2ludGVyID0gcG9pbnRlcjtcbnByZXZUb2tlblNvbGlkID0gZmFsc2U7XG59XG5sYXN0UG90ZW50aWFsUmVnZXhFcnJvciA9ICcnO1xubGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJyc7XG5kbyB7XG4rK2FueVRva2VuQ291bnQ7XG5sZXQgc3RhcnRDb2wgPSBwb2ludGVyIC0gY3VycmVudENvbE9mZnNldDtcbmxldCBzdGFydFJvdyA9IGN1cnJlbnRMaW5lO1xubGFzdENhbm9uaXplZElucHV0ID0gJyc7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSAwO1xubmx3YXMgPSBjb25zdW1lZE5ld2xpbmVzQmVmb3JlU29saWQ7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbmNyZWF0ZVRva2VuKDIwOTcxNzMsIHBvaW50ZXIsIHBvaW50ZXIsIHN0YXJ0Q29sLCBzdGFydFJvdyk7XG5maW5pc2hlZCA9IHRydWU7XG5yZXR1cm4gcmV0dXJuU29saWRUb2tlbigyMDk3MTczLCBwb2ludGVyLCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3cpO1xufVxubGV0IHN0YXJ0ID0gc3RhcnRGb3JFcnJvciA9IHBvaW50ZXI7XG5sZXQgY29uc3VtZWRUb2tlblR5cGUgPSBqdW1wVGFibGVMZXhlcihsZXhlckZsYWdzKTtcbmlmICghaXNXaGl0ZVRva2VuKGNvbnN1bWVkVG9rZW5UeXBlKSkge1xuY3JlYXRlVG9rZW4oY29uc3VtZWRUb2tlblR5cGUsIHN0YXJ0LCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3cpO1xucmV0dXJuIHJldHVyblNvbGlkVG9rZW4oY29uc3VtZWRUb2tlblR5cGUsIHN0YXJ0LCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3cpO1xufVxuaWYgKGlzQ29tbWVudFRva2VuKGNvbnN1bWVkVG9rZW5UeXBlKSkge1xuaWYgKHJldHVyblRva2VucyA9PT0gMikge1xuY3JlYXRlVG9rZW4oY29uc3VtZWRUb2tlblR5cGUsIHN0YXJ0LCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3cpO1xucmV0dXJuIHJldHVybkNvbW1lbnRUb2tlbihjb25zdW1lZFRva2VuVHlwZSwgc3RhcnQsIHBvaW50ZXIsIHN0YXJ0Q29sLCBzdGFydFJvdyk7XG59XG59XG5pZiAoKChjb2xsZWN0VG9rZW5zID09PSAyKSB8fCAoY29sbGVjdFRva2VucyA9PT0gMykpKSB7XG5jcmVhdGVUb2tlbihjb25zdW1lZFRva2VuVHlwZSwgc3RhcnQsIHBvaW50ZXIsIHN0YXJ0Q29sLCBzdGFydFJvdyk7XG50b2tlblN0b3JhZ2UucHVzaCgoKGNvbGxlY3RUb2tlbnMgPT09IDMpPyBjb25zdW1lZFRva2VuVHlwZSA6IGNyZWF0ZUJhc2VUb2tlbihjb25zdW1lZFRva2VuVHlwZSwgc3RhcnQsIHBvaW50ZXIsIHN0YXJ0Q29sLCBzdGFydFJvdywgZmFsc2UpKSk7XG59XG5pZiAocmV0dXJuVG9rZW5zID09PSAxKSB7XG5yZXR1cm4gY3JlYXRlVG9rZW4oY29uc3VtZWRUb2tlblR5cGUsIHN0YXJ0LCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3cpO1xufVxuaWYgKGNvbnN1bWVkVG9rZW5UeXBlID09PSAxMjg1KSB7XG5pZiAoKChjb2xsZWN0VG9rZW5zICE9PSAyKSAmJiAoY29sbGVjdFRva2VucyAhPT0gMykpKSBza2lwTmV3bGluZXNXaXRob3V0VG9rZW5zKCk7XG59XG5pZiAobmx3YXMgPT09IHRydWUpIHtcbmlmICgoKGNvbGxlY3RUb2tlbnMgIT09IDIpICYmIChjb2xsZWN0VG9rZW5zICE9PSAzKSkpIHNraXBTcGFjZXNXaXRob3V0VG9rZW5zKCk7XG59XG59IHdoaWxlICh0cnVlKTtcbn1cbmZ1bmN0aW9uIHJldHVybkNvbW1lbnRUb2tlbihjb25zdW1lZFRva2VuVHlwZSwgc3RhcnQsIHBvaW50ZXIsIHN0YXJ0Q29sLCBzdGFydFJvdykge1xuaWYgKCgoY29sbGVjdFRva2VucyA9PT0gMikgfHwgKGNvbGxlY3RUb2tlbnMgPT09IDMpKSkge1xudG9rZW5TdG9yYWdlLnB1c2goKChjb2xsZWN0VG9rZW5zID09PSAzKT8gY29uc3VtZWRUb2tlblR5cGUgOiBjcmVhdGVCYXNlVG9rZW4oY29uc3VtZWRUb2tlblR5cGUsIHN0YXJ0LCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3csIGZhbHNlKSkpO1xufVxufVxuZnVuY3Rpb24gcmV0dXJuU29saWRUb2tlbihjb25zdW1lZFRva2VuVHlwZSwgc3RhcnQsIHBvaW50ZXIsIHN0YXJ0Q29sLCBzdGFydFJvdykge1xuKytzb2xpZFRva2VuQ291bnQ7XG5pZiAoY29sbGVjdFRva2VucyAhPT0gMCkge1xudG9rZW5TdG9yYWdlLnB1c2goKChjb2xsZWN0VG9rZW5zID09PSAzKT8gY29uc3VtZWRUb2tlblR5cGUgOiBjcmVhdGVCYXNlVG9rZW4oY29uc3VtZWRUb2tlblR5cGUsIHN0YXJ0LCBwb2ludGVyLCBzdGFydENvbCwgc3RhcnRSb3csIGNvbnN1bWVkTmV3bGluZXNCZWZvcmVTb2xpZCkpKTtcbn1cbmNvbnN1bWVkTmV3bGluZXNCZWZvcmVTb2xpZCA9IGZhbHNlO1xucHJldlRva2VuU29saWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gc2tpcFNwYWNlc1dpdGhvdXRUb2tlbnMoKSB7XG53aGlsZSAocG9pbnRlciA8IGxlbikge1xubGV0IGMgPSBjYWNoZTtcbmlmICgoKGMgIT09IDB4MjApICYmIChjICE9PSAweDA5KSkpIHJldHVybjtcbnNraXAoKTtcbn1cbn1cbmZ1bmN0aW9uIHNraXBOZXdsaW5lc1dpdGhvdXRUb2tlbnMoKSB7XG53aGlsZSAocG9pbnRlciA8IGxlbikge1xubGV0IGMgPSBjYWNoZTtcbmlmIChjID09PSAweDBBKSB7XG5za2lwKCk7XG5pbmNyZW1lbnRMaW5lKCk7XG59IGVsc2UgaWYgKGMgPT09IDB4MEQpIHtcbnNraXAoKTtcbnBhcnNlQ1IoKTtcbn0gZWxzZSB7XG5yZXR1cm47XG59XG59XG59XG5mdW5jdGlvbiBqdW1wVGFibGVMZXhlcihsZXhlckZsYWdzKSB7XG5sZXQgYyA9IGNhY2hlO1xuc2tpcCgpO1xuaWYgKGMgPiAweDdlKSB7XG5yZXR1cm4gcGFyc2VPdGhlclVuaWNvZGUoYyk7XG59XG5sZXQgcyA9IGdldFRva2VuU3RhcnQoYyk7XG5pZiAocyA+IE1BWF9TVEFSVF9WQUxVRSkge1xucmV0dXJuIHM7XG59XG5zd2l0Y2ggKHMpIHtcbmNhc2UgMTpcbnJldHVybiBwYXJzZVNwYWNlKCk7XG5jYXNlIDI6XG5yZXR1cm4gcGFyc2VJZGVudGlmaWVyUmVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpLCAxKTtcbmNhc2UgMzpcbmlmICgobGV4ZXJGbGFncyAmIDY1NTM2KSA9PT0gNjU1MzYpIHJldHVybiBwYXJzZUlkZW50aWZpZXJSZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoYyksIDEpO1xucmV0dXJuIHBhcnNlUG90ZW50aWFsS2V5d29yZFRyaWVNYXAoYyk7XG5jYXNlIDQ6XG5yZXR1cm4gcGFyc2VOZXdsaW5lU29sbygpO1xuY2FzZSA1OlxucmV0dXJuIHBhcnNlQ1IoKTtcbmNhc2UgNjpcbnJldHVybiBwYXJzZUFueVN0cmluZyhjLCBsZXhlckZsYWdzKTtcbmNhc2UgNzpcbnJldHVybiBwYXJzZURlY2ltYWwoKTtcbmNhc2UgODpcbnJldHVybiBwYXJzZUxlYWRpbmdEb3QoKTtcbmNhc2UgOTpcbmlmICgobGV4ZXJGbGFncyAmIDIwNDgpID09PSAyMDQ4KSByZXR1cm4gcGFyc2VUZW1wbGF0ZVN0cmluZyhsZXhlckZsYWdzLCBmYWxzZSk7XG5yZXR1cm4gMTY1MTc7XG5jYXNlIDEwOlxucmV0dXJuIHBhcnNlRXF1YWwoKTtcbmNhc2UgMTE6XG5yZXR1cm4gcGFyc2VGd2RTbGFzaChsZXhlckZsYWdzKTtcbmNhc2UgMTI6XG5yZXR1cm4gcGFyc2VTYW1lT3JDb21wb3VuZCgweDJiKTtcbmNhc2UgMTM6XG5yZXR1cm4gcGFyc2VEYXNoKCk7XG5jYXNlIDE0OlxucmV0dXJuIHBhcnNlTGVhZGluZ1plcm8obGV4ZXJGbGFncyk7XG5jYXNlIDE1OlxucmV0dXJuIHBhcnNlVGVtcGxhdGVTdHJpbmcobGV4ZXJGbGFncywgdHJ1ZSk7XG5jYXNlIDE2OlxucmV0dXJuIHBhcnNlRXhjbCgpO1xuY2FzZSAxNzpcbnJldHVybiBwYXJzZUNvbXBvdW5kQXNzaWdubWVudCgweDI1KTtcbmNhc2UgMTg6XG5yZXR1cm4gcGFyc2VTYW1lT3JDb21wb3VuZCgweDI2KTtcbmNhc2UgMTk6XG5yZXR1cm4gcGFyc2VTdGFyKCk7XG5jYXNlIDIwOlxucmV0dXJuIHBhcnNlQ29tcG91bmRBc3NpZ25tZW50KDB4NWUpO1xuY2FzZSAyMTpcbnJldHVybiBwYXJzZUx0KCk7XG5jYXNlIDIyOlxucmV0dXJuIHBhcnNlR3RQdW5jdHVhdG9yKCk7XG5jYXNlIDIzOlxucmV0dXJuIHBhcnNlU2FtZU9yQ29tcG91bmQoMHg3Yyk7XG5jYXNlIDI0OlxucmV0dXJuIHBhcnNlQmFja3NsYXNoKCk7XG5jYXNlIDI1OlxucmV0dXJuIHBhcnNlUW1hcmsoKTtcbn1cblRIUk9XKCdVbmtub3duIGlucHV0JywgcG9pbnRlciAtIDEsIHBvaW50ZXIpO1xufVxuZnVuY3Rpb24gaW5jcmVtZW50TGluZSgpIHtcbmNvbnN1bWVkTmV3bGluZXNCZWZvcmVTb2xpZCA9IHRydWU7XG4rK2N1cnJlbnRMaW5lO1xuY3VycmVudENvbE9mZnNldCA9IHBvaW50ZXI7XG59XG5mdW5jdGlvbiBhZGRBc2koKSB7XG5pZiAoY29sbGVjdFRva2VucyAhPT0gMCkge1xudG9rZW5TdG9yYWdlLnB1c2goKChjb2xsZWN0VG9rZW5zID09PSAzKT8gMjA5NzE3NCA6IGNyZWF0ZUJhc2VUb2tlbigyMDk3MTc0LCBwb2ludGVyLCBwb2ludGVyLCBwb2ludGVyIC0gY3VycmVudENvbE9mZnNldCwgY3VycmVudExpbmUsIGZhbHNlKSksIHRva2VuU3RvcmFnZS5wb3AoKSk7XG59XG4rK2FueVRva2VuQ291bnQ7XG4rK3NvbGlkVG9rZW5Db3VudDtcbnByZXZUb2tlblNvbGlkID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuKHR5cGUsIHN0YXJ0LCBzdG9wLCBjb2x1bW4sIGxpbmUpIHtcbmxhc3RUeXBlID0gdHlwZTtcbmxhc3RTdGFydCA9IHN0YXJ0O1xubGFzdFN0b3AgPSBzdG9wO1xubGFzdExpbmUgPSBsaW5lO1xubGFzdENvbHVtbiA9IGNvbHVtbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUb2tlbih0eXBlLCBzdGFydCwgc3RvcCwgY29sdW1uLCBsaW5lLCBubCkge1xuaWYgKGJhYmVsVG9rZW5Db21wYXQpIHtcbnJldHVybiB7dHlwZSwgc3RhcnQsIHN0b3AsIGxvYzp7c3RhcnQ6e2xpbmU6bGluZSwgY29sdW1uOmNvbHVtbn0sIGVuZDp7bGluZTpjdXJyZW50TGluZSwgY29sdW1uOmN1cnJlbnRDb2xPZmZzZXR9fSwgY29sdW1uLCBsaW5lfTtcbn1cbnJldHVybiB7dHlwZSwgc3RhcnQsIHN0b3AsIGNvbHVtbiwgbGluZSwgbmx9O1xufVxuZnVuY3Rpb24gcGFyc2VMZWFkaW5nRG90KCkge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMTY0ODU7XG5sZXQgYyA9IGNhY2hlO1xuaWYgKGMgPT09IDB4MmUpIHtcbnJldHVybiBwYXJzZVRyaXBsZURvdCgpO1xufVxuaWYgKGlzQXNjaWlOdW1iZXIoYykpIHtcbnJldHVybiBwYXJzZU51bWJlckZyb21Eb3QoYyk7XG59XG5yZXR1cm4gMTY0ODU7XG59XG5mdW5jdGlvbiBwYXJzZVRyaXBsZURvdCgpIHtcbmlmIChwZWVrZCgxKSA9PT0gMHgyZSkge1xuc2tpcCgpO1xuc2tpcCgpO1xucmV0dXJuIDE2NDg2O1xufVxucmV0dXJuIDE2NDg2O1xufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXJGcm9tRG90KGMpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyIDwgbGVuKSB7XG5sZXQgZCA9IHNraXBEaWdpdHMoKTtcbnBhcnNlRXhwb25lbnRNYXliZShkKTtcbn1cbnZlcmlmeUNoYXJBZnRlck51bWJlcigpO1xucmV0dXJuIDQxMDU7XG59XG5mdW5jdGlvbiBwYXJzZVNwYWNlKCkge1xucmV0dXJuIDI1Nztcbn1cbmZ1bmN0aW9uIHBhcnNlQ1IoKSB7XG5pZiAoKHBvaW50ZXIgPCBsZW4gJiYgKGNhY2hlID09PSAweDBBKSkpIHtcbnNraXAoKTtcbmluY3JlbWVudExpbmUoKTtcbnJldHVybiA3NzI7XG59XG5pbmNyZW1lbnRMaW5lKCk7XG5yZXR1cm4gNzcxO1xufVxuZnVuY3Rpb24gcGFyc2VBbnlTdHJpbmcobWFya2VyLCBsZXhlckZsYWdzKSB7XG5sZXQgcG9pbnRlck9mZnNldCA9IHBvaW50ZXI7XG5sZXQgYmFkRXNjYXBlID0gZmFsc2U7XG5sZXQgaGFkTmV3bGluZSA9IGZhbHNlO1xud2hpbGUgKHBvaW50ZXIgPCBsZW4pIHtcbmxldCBjID0gY2FjaGU7XG5sZXQgcyA9IGdldFN0cmluZ1BhcnQoYyk7XG5pZiAocyA8PSBNQVhfU1RBUlRfVkFMVUUpIHtcbnN3aXRjaCAocykge1xuY2FzZSAwOlxuc2tpcCgpO1xuYnJlYWs7XG5jYXNlIDE6XG5za2lwKCk7XG5pZiAoYyA9PT0gbWFya2VyKSB7XG5pZiAoYmFkRXNjYXBlKSB7XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ1N0cmluZyBoYWQgYW4gaWxsZWdhbCBlc2NhcGUnO1xucmV0dXJuIDIwOTcxNzU7XG59XG5pZiAoaGFkTmV3bGluZSkge1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdFbmNvdW50ZXJlZCBuZXdsaW5lIGluIHN0cmluZyB3aGljaCBpcyBub3QgYWxsb3dlZCc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmxhc3RDYW5vbml6ZWRJbnB1dCArPSBzbGljZShwb2ludGVyT2Zmc2V0LCBwb2ludGVyIC0gMSk7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gKz0gKHBvaW50ZXIgLSAxKSAtIHBvaW50ZXJPZmZzZXQ7XG5yZXR1cm4gKChtYXJrZXIgPT09IDB4MjIpPyAxMzEwODggOiAxMzEwODcpO1xufVxuYnJlYWs7XG5jYXNlIDI6XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gc2xpY2UocG9pbnRlck9mZnNldCwgcG9pbnRlcik7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gKz0gcG9pbnRlciAtIHBvaW50ZXJPZmZzZXQ7XG5iYWRFc2NhcGUgPSAoKHBhcnNlU3RyaW5nT3JUZW1wbGF0ZUVzY2FwZShsZXhlckZsYWdzLCBmYWxzZSkgPT09IHRydWUpIHx8IGJhZEVzY2FwZSk7XG5wb2ludGVyT2Zmc2V0ID0gcG9pbnRlcjtcbmJyZWFrO1xuY2FzZSAzOlxuc2tpcCgpO1xuaWYgKCgoYyA8PSAweDIwMjkpICYmIChjID49IDB4MjAyOCkpKSB7XG5pbmNyZW1lbnRMaW5lKCk7XG59XG5icmVhaztcbmNhc2UgNDpcbnNraXAoKTtcbmhhZE5ld2xpbmUgPSB0cnVlO1xuYnJlYWs7XG47XG59XG59XG59XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ1VuY2xvc2VkIHN0cmluZyBhdCBFT0YnO1xucmV0dXJuIDIwOTcxNzU7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZ09yVGVtcGxhdGVFc2NhcGUobGV4ZXJGbGFncywgZm9yVGVtcGxhdGUpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikge1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdCYWNrc2xhc2ggYXQgZW5kIG9mIGlucHV0JztcbnJldHVybiB0cnVlO1xufVxubGV0IGMgPSBjYWNoZTtcbnNraXAoKTtcbmxldCBzID0gKChjID4gMHg3ZSk/IDYgOiBzdHJpbmdFc2NhcGVTdGFydEp1bXBUYWJsZVtjXSk7XG5zd2l0Y2ggKHMpIHtcbmNhc2UgMDpcbmxhc3RDYW5vbml6ZWRJbnB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuKytsYXN0Q2Fub25pemVkSW5wdXRMZW47XG5yZXR1cm4gZmFsc2U7XG5jYXNlIDE6XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gJ1xcbic7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbmNhc2UgMjpcbmxhc3RDYW5vbml6ZWRJbnB1dCArPSAnXFwnJztcbisrbGFzdENhbm9uaXplZElucHV0TGVuO1xucmV0dXJuIGZhbHNlO1xuY2FzZSAzOlxubGFzdENhbm9uaXplZElucHV0ICs9ICdcIic7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbmNhc2UgNDpcbntcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIHRydWU7XG5sZXQgciA9IHBhcnNlVW5pY29kZUVzY2FwZUZvck5vblJlZ2V4KCk7XG5pZiAociA9PT0gMHgxMTAwMDApIHJldHVybiB0cnVlO1xubGFzdENhbm9uaXplZElucHV0ICs9ICgociA+IDB4ZmZmZik/IFN0cmluZy5mcm9tQ29kZVBvaW50KHIpIDogU3RyaW5nLmZyb21DaGFyQ29kZShyKSk7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gKz0gKChyID4gMHhmZmZmKT8gMiA6IDEpO1xucmV0dXJuIGZhbHNlO1xufVxuY2FzZSA1OlxucmV0dXJuIHBhcnNlU3RyaW5nRXNjYXBlSGV4KCk7XG5jYXNlIDY6XG5pZiAoKChjID09PSAweDIwMjgpIHx8IChjID09PSAweDIwMjkpKSkge1xuaW5jcmVtZW50TGluZSgpO1xucmV0dXJuIGZhbHNlO1xufVxubGFzdENhbm9uaXplZElucHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbmNhc2UgNzpcbmxhc3RDYW5vbml6ZWRJbnB1dCArPSAnXFx0JztcbisrbGFzdENhbm9uaXplZElucHV0TGVuO1xucmV0dXJuIGZhbHNlO1xuY2FzZSA4OlxubGFzdENhbm9uaXplZElucHV0ICs9ICdcXHInO1xuKytsYXN0Q2Fub25pemVkSW5wdXRMZW47XG5yZXR1cm4gZmFsc2U7XG5jYXNlIDk6XG5pZiAoKHBvaW50ZXIgPCBsZW4gJiYgKGNhY2hlID09PSAweDBBKSkpIHNraXAoKTtcbmluY3JlbWVudExpbmUoKTtcbnJldHVybiBmYWxzZTtcbmNhc2UgMTA6XG5pbmNyZW1lbnRMaW5lKCk7XG5yZXR1cm4gZmFsc2U7XG5jYXNlIDExOlxuXG5jYXNlIDEyOlxucmV0dXJuIHBhcnNlU3RyaW5nRXNjYXBlT2N0YWxPckRpZ2l0KGMsIGZvclRlbXBsYXRlLCBsZXhlckZsYWdzKTtcbmNhc2UgMTM6XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gJ1xcYic7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbmNhc2UgMTQ6XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gJ1xcZic7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbmNhc2UgMTU6XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gJ1xcdic7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbjtcbn1cbn1cbmZ1bmN0aW9uIHNraXBaZXJvZXMoKSB7XG5sZXQgYyA9IGNhY2hlO1xud2hpbGUgKGMgPT09IDB4MzApIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDA7XG5jID0gY2FjaGU7XG59XG5yZXR1cm4gYztcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nRXNjYXBlSGV4KCkge1xuaWYgKGVvZmQoMSkpIHtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIGZhbHNlO1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdOb3QgZW5vdWdoIG9mIGlucHV0IGxlZnQgdG8gY3JlYXRlIHZhbGlkIGhleCBlc2NhcGUnO1xucmV0dXJuIHRydWU7XG59XG5sZXQgYSA9IGNhY2hlO1xubGV0IGIgPSBwZWVrZCgxKTtcbmxldCB2YSA9IGdldEhleFZhbHVlKGEpO1xubGV0IHZiID0gZ2V0SGV4VmFsdWUoYik7XG5pZiAoKHZhIHwgdmIpID49IDE2KSB7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gJ3gnO1xuKytsYXN0Q2Fub25pemVkSW5wdXRMZW47XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ0F0IGxlYXN0IG9uZSBvZiB0aGUgdHdvIGhleCBjaGFyYWN0ZXJzIHdlcmUgbm90IGhleCBjaGFyYWN0ZXIgKDAtOWEtZiknO1xucmV0dXJuIHRydWU7XG59XG5za2lwKCk7XG5za2lwKCk7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodmEgPDwgNCkgfCB2Yik7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nRXNjYXBlT2N0YWxPckRpZ2l0KGEsIGZvclRlbXBsYXRlLCBsZXhlckZsYWdzKSB7XG5pZiAoKChhID09PSAweDM4KSB8fCAoYSA9PT0gMHgzOSkpKSB7XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ1RoZSBncmFtbWFyIGRvZXMgbm90IGFsbG93IHRvIGVzY2FwZSB0aGUgOCBvciB0aGUgOSBjaGFyYWN0ZXInO1xucmV0dXJuIHRydWU7XG59XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiBmYWxzZTtcbmxldCBiID0gY2FjaGU7XG5pZiAoKCgoKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHx8IGZvclRlbXBsYXRlKSkgfHwgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpKSkge1xuaWYgKCgoYSA9PT0gMHgzMCkgJiYgKCgoYiA8IDB4MzApIHx8IChiID4gMHgzOSkpKSkpIHtcbmxhc3RDYW5vbml6ZWRJbnB1dCArPSAnXFwwJztcbisrbGFzdENhbm9uaXplZElucHV0TGVuO1xucmV0dXJuIGZhbHNlO1xufVxuaWYgKGZvclRlbXBsYXRlKSB7XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ0lsbGVnYWwgbGVnYWN5IG9jdGFsIGVzY2FwZSBpbiB0ZW1wbGF0ZSwgd2hlcmUgb2N0YWwgZXNjYXBlcyBhcmUgbmV2ZXIgYWxsb3dlZCc7XG59IGVsc2UgaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnSWxsZWdhbCBsZWdhY3kgb2N0YWwgZXNjYXBlIGluIHN0cmljdCBtb2RlJztcbn0gZWxzZSB7XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ09jdGFsIGVzY2FwZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBzbG9wcHkgbW9kZSB3aXRoIHdlYiBjb21wYXQgZW5hYmxlZCc7XG59XG5yZXR1cm4gdHJ1ZTtcbn1cbmlmICgoKGEgPT09IDB4MzApICYmICgoKGIgPCAweDMwKSB8fCAoYiA+IDB4MzcpKSkpKSB7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gJ1xcMCc7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbn1cbmlmICgoKGIgPCAweDMwKSB8fCAoYiA+IDB4MzcpKSkge1xubGFzdENhbm9uaXplZElucHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoU3RyaW5nLmZyb21DaGFyQ29kZShhKSwgOCkpO1xuKytsYXN0Q2Fub25pemVkSW5wdXRMZW47XG5yZXR1cm4gZmFsc2U7XG59XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiBmYWxzZTtcbmlmIChhID4gMHgzMykge1xubGFzdENhbm9uaXplZElucHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoU3RyaW5nLmZyb21DaGFyQ29kZShhLCBiKSwgOCkpO1xuKytsYXN0Q2Fub25pemVkSW5wdXRMZW47XG5yZXR1cm4gZmFsc2U7XG59XG5sZXQgYyA9IGNhY2hlO1xuaWYgKCgoYyA8IDB4MzApIHx8IChjID4gMHgzNykpKSB7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChTdHJpbmcuZnJvbUNoYXJDb2RlKGEsIGIpLCA4KSk7XG4rK2xhc3RDYW5vbml6ZWRJbnB1dExlbjtcbnJldHVybiBmYWxzZTtcbn1cbnNraXAoKTtcbmxhc3RDYW5vbml6ZWRJbnB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KFN0cmluZy5mcm9tQ2hhckNvZGUoYSwgYiwgYyksIDgpKTtcbisrbGFzdENhbm9uaXplZElucHV0TGVuO1xucmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VEYXNoKCkge1xuaWYgKCgoKCgoKCgocGFyc2luZ0dvYWwgPT09IGZhbHNlKSAmJiAod2ViQ29tcGF0ID09PSB0cnVlKSkpICYmICghZW9mZCgxKSkpKSAmJiAoY2FjaGUgPT09IDB4MmQpKSkgJiYgKHBlZWtkKDEpID09PSAweDNlKSkpIHtcbmlmIChjb25zdW1lZE5ld2xpbmVzQmVmb3JlU29saWQgPT09IHRydWUpIHtcbnJldHVybiBwYXJzZUNvbW1lbnRIdG1sQ2xvc2UoKTtcbn0gZWxzZSB7XG5cbn1cbn1cbnJldHVybiBwYXJzZVNhbWVPckNvbXBvdW5kKDB4MmQpO1xufVxuZnVuY3Rpb24gcGFyc2VTYW1lT3JDb21wb3VuZChjKSB7XG5pZiAocG9pbnRlciA8IGxlbikge1xubGV0IGQgPSBjYWNoZTtcbmlmIChkID09PSBjKSB7XG5za2lwKCk7XG5zd2l0Y2ggKGMpIHtcbmNhc2UgMHgyYjpcbnJldHVybiAxNjQ3ODtcbmNhc2UgMHgyZDpcbnJldHVybiAxNjQ4MjtcbmNhc2UgMHgyNjpcbnJldHVybiA4MjAwNTtcbmNhc2UgMHg3YzpcbnJldHVybiA4MjA1MTtcbjtcbn1cbn1cbmlmIChkID09PSAweDNkKSB7XG5za2lwKCk7XG5zd2l0Y2ggKGMpIHtcbmNhc2UgMHgyYjpcbnJldHVybiA0OTI0NztcbmNhc2UgMHgyZDpcbnJldHVybiA0OTI1MTtcbmNhc2UgMHgyNjpcbnJldHVybiA0OTIzODtcbmNhc2UgMHg3YzpcbnJldHVybiA0OTI4NDtcbjtcbn1cbn1cbn1cbnN3aXRjaCAoYykge1xuY2FzZSAweDJiOlxucmV0dXJuIDgyMDEzO1xuY2FzZSAweDJkOlxucmV0dXJuIDgyMDE3O1xuY2FzZSAweDI2OlxucmV0dXJuIDgyMDA0O1xuY2FzZSAweDdjOlxucmV0dXJuIDgyMDUwO1xuO1xufVxufVxuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZVN0cmluZyhsZXhlckZsYWdzLCBmcm9tVGljaykge1xubGFzdE9mZnNldCA9IHBvaW50ZXI7XG5sZXQgYmFkRXNjYXBlcyA9IGZhbHNlO1xud2hpbGUgKHBvaW50ZXIgPCBsZW4pIHtcbmxldCBjID0gY2FjaGU7XG53aGlsZSAoYyA9PT0gMHgyNCkge1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ1VuY2xvc2VkIHRlbXBsYXRlIHN0cmluZyc7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gc2xpY2UobGFzdE9mZnNldCwgcG9pbnRlcik7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gKz0gcG9pbnRlciAtIGxhc3RPZmZzZXQ7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmMgPSBjYWNoZTtcbmlmIChjID09PSAweDdiKSB7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gc2xpY2UobGFzdE9mZnNldCwgcG9pbnRlciAtIDEpO1xubGFzdENhbm9uaXplZElucHV0TGVuICs9IChwb2ludGVyIC0gMSkgLSBsYXN0T2Zmc2V0O1xuc2tpcCgpO1xucmV0dXJuIChiYWRFc2NhcGVzPyAoKGZyb21UaWNrPyAxNTcyODgxIDogMTU3Mjg4MikpIDogKChmcm9tVGljaz8gNTI0MzA1IDogNTI0MzA2KSkpO1xufVxufVxuaWYgKGMgPT09IDB4NjApIHtcbmxhc3RDYW5vbml6ZWRJbnB1dCArPSBzbGljZShsYXN0T2Zmc2V0LCBwb2ludGVyKTtcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiArPSBwb2ludGVyIC0gbGFzdE9mZnNldDtcbnNraXAoKTtcbnJldHVybiAoYmFkRXNjYXBlcz8gKChmcm9tVGljaz8gMTU3Mjg4NCA6IDE1NzI4ODMpKSA6ICgoZnJvbVRpY2s/IDUyNDMwOCA6IDUyNDMwNykpKTtcbn1cbmlmIChjID09PSAweDBEKSB7XG5za2lwKCk7XG5pZiAoKHBvaW50ZXIgPCBsZW4gJiYgKGNhY2hlID09PSAweDBBKSkpIHtcbnNraXAoKTtcbn1cbmluY3JlbWVudExpbmUoKTtcbn0gZWxzZSBpZiAoaXNMZlBzTHMoYykpIHtcbnNraXAoKTtcbmluY3JlbWVudExpbmUoKTtcbn0gZWxzZSBpZiAoYyA9PT0gMHg1Yykge1xubGFzdENhbm9uaXplZElucHV0ICs9IHNsaWNlKGxhc3RPZmZzZXQsIHBvaW50ZXIpO1xubGFzdENhbm9uaXplZElucHV0TGVuICs9IHBvaW50ZXIgLSBsYXN0T2Zmc2V0O1xuYmFkRXNjYXBlcyA9ICgocGFyc2VTdHJpbmdPclRlbXBsYXRlRXNjYXBlKGxleGVyRmxhZ3MsIHRydWUpID09PSB0cnVlKSB8fCBiYWRFc2NhcGVzKTtcbmxhc3RPZmZzZXQgPSBwb2ludGVyO1xufSBlbHNlIHtcbnNraXAoKTtcbn1cbn1cbmxhc3RDYW5vbml6ZWRJbnB1dCArPSBzbGljZShsYXN0T2Zmc2V0LCBwb2ludGVyKTtcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiArPSBwb2ludGVyIC0gbGFzdE9mZnNldDtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnVW5jbG9zZWQgdGVtcGxhdGUgbGl0ZXJhbCc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUNoYXJBZnRlck51bWJlcigpIHtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuO1xubGV0IGMgPSBjYWNoZTtcbmlmICgoKGlzSWRlbnRTdGFydChjLCAwKSAhPT0gKC0xKSkgfHwgKCgoYyA+PSAweDMwKSAmJiAoYyA8PSAweDM5KSkpKSkge1xucmV0dXJuIFRIUk9XKCgnRm91bmQgYCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKSArICdgLiBJdCBpcyBub3QgbGVnYWwgZm9yIGFuIGlkZW50IG9yIG51bWJlciB0b2tlbiB0byBzdGFydCBhZnRlciBhIG51bWJlciB0b2tlbiB3aXRob3V0IHNvbWUgZm9ybSBvZiBzZXBhcmF0aW9uJywgcG9pbnRlciwgcG9pbnRlcik7XG59XG59XG5mdW5jdGlvbiBwYXJzZUxlYWRpbmdaZXJvKGxleGVyRmxhZ3MpIHtcbmxldCByID0gX3BhcnNlTGVhZGluZ1plcm8obGV4ZXJGbGFncyk7XG5pZiAociAhPT0gMjA5NzE3NSkgdmVyaWZ5Q2hhckFmdGVyTnVtYmVyKCk7XG5yZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9wYXJzZUxlYWRpbmdaZXJvKGxleGVyRmxhZ3MpIHtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDQxMDU7XG5sZXQgYyA9IGNhY2hlO1xuaWYgKGlzQXNjaWlOdW1iZXIoYykpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyIDwgbGVuKSBza2lwRGlnaXRzKCk7XG5pZiAoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gODE5Mikge1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdcIklsbGVnYWxcIiBvY3RhbCBlc2NhcGUgaW4gc3RyaWN0IG1vZGUnO1xucmV0dXJuIDIwOTcxNzU7XG59XG5pZiAocG9pbnRlciA8IGxlbikge1xubGV0IGUgPSBjYWNoZTtcbmlmICgoKGUgPT09IDB4NDUpIHx8IChlID09PSAweDY1KSkpIHtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnQW4gZXhwb25lbnQgaXMgbm90IGFsbG93ZWQgYWZ0ZXIgYSBsZWdhY3kgb2N0YWwgbnVtYmVyIGFuZCBhbiBpZGVudCBhZnRlciBudW1iZXIgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgc29tZSB3aGl0ZXNwYWNlIHNvIHRoaXMgaXMgYW4gZXJyb3InO1xucmV0dXJuIDIwOTcxNzU7XG59XG5pZiAoZSA9PT0gMHg2RSkge1xuaWYgKCFzdXBwb3J0QmlnSW50KSB7XG5yZXR1cm4gVEhST1coJ0JpZ0ludCBzdWZmaXggaXMgbm90IHN1cHBvcnRlZCBvbiBsZWdhY3kgb2N0YWxzOyB1c2UgdGhlIGAwb2AgcHJlZml4IG5vdGF0aW9uIGZvciB0aGF0Jywgc3RhcnRGb3JFcnJvciwgcG9pbnRlciArIDEpO1xufVxufVxufVxucmV0dXJuIDQxMDg7XG59XG5pZiAoYyA9PT0gMHgyZSkge1xucGFyc2VGcm9tRnJhY3Rpb25Eb3QoKTtcbnJldHVybiA0MTA1O1xufVxuaWYgKCgoYyA9PT0gMHg3OCkgfHwgKGMgPT09IDB4NTgpKSkge1xuc2tpcCgpO1xucmV0dXJuIHBhcnNlSGV4KCk7XG59XG5pZiAoKChjID09PSAweDZGKSB8fCAoYyA9PT0gMHg0RikpKSB7XG5za2lwKCk7XG5yZXR1cm4gcGFyc2VPY3RhbCgpO1xufVxuaWYgKCgoYyA9PT0gMHg2MikgfHwgKGMgPT09IDB4NDIpKSkge1xuc2tpcCgpO1xucmV0dXJuIHBhcnNlQmluYXJ5KCk7XG59XG5pZiAoKChjID09PSAweDY1KSB8fCAoYyA9PT0gMHg0NSkpKSB7XG5wYXJzZUV4cG9uZW50TWF5YmUoYyk7XG5yZXR1cm4gNDEwNTtcbn1cbmlmIChjID09PSAweDZFKSB7XG5pZiAoIXN1cHBvcnRCaWdJbnQpIHtcbnJldHVybiBUSFJPVygoJ1RoZSBCaWdJbnQgc3ludGF4IGlzIHN1cHBvcnRlZCBpbiBFUzExKyAvIEVTMjAyMCAoY3VycmVudGx5IHBhcnNpbmcgRVMnICsgdGFyZ2V0RXNWZXJzaW9uKSArICcpJywgc3RhcnRGb3JFcnJvciwgcG9pbnRlciArIDEpO1xufVxuc2tpcCgpO1xucmV0dXJuIDEyMjk3O1xufVxucmV0dXJuIDQxMDU7XG59XG5mdW5jdGlvbiBwYXJzZURlY2ltYWwoKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiA0MTA1O1xufVxubGV0IGMgPSBza2lwRGlnaXRzKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiA0MTA1O1xufVxuaWYgKGMgPT09IDB4MmUpIHtcbnBhcnNlRnJvbUZyYWN0aW9uRG90KCk7XG52ZXJpZnlDaGFyQWZ0ZXJOdW1iZXIoKTtcbnJldHVybiA0MTA1O1xufVxuaWYgKGMgPT09IDB4NkUpIHtcbmlmICghc3VwcG9ydEJpZ0ludCkge1xucmV0dXJuIFRIUk9XKCgnVGhlIEJpZ0ludCBzeW50YXggaXMgc3VwcG9ydGVkIGluIEVTMTErIC8gRVMyMDIwIChjdXJyZW50bHkgcGFyc2luZyBFUycgKyB0YXJnZXRFc1ZlcnNpb24pICsgJyknLCBzdGFydEZvckVycm9yLCBwb2ludGVyKTtcbn1cbnNraXAoKTtcbnZlcmlmeUNoYXJBZnRlck51bWJlcigpO1xucmV0dXJuIDEyMjk3O1xufVxucGFyc2VFeHBvbmVudE1heWJlKGMpO1xudmVyaWZ5Q2hhckFmdGVyTnVtYmVyKCk7XG5yZXR1cm4gNDEwNTtcbn1cbmZ1bmN0aW9uIHNraXBEaWdpdHMoKSB7XG5sZXQgYyA9IGNhY2hlO1xud2hpbGUgKGlzQXNjaWlOdW1iZXIoYykpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDA7XG5jID0gY2FjaGU7XG59XG5yZXR1cm4gYztcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwb25lbnRNYXliZShjKSB7XG5pZiAoKChjICE9PSAweDY1KSAmJiAoYyAhPT0gMHg0NSkpKSByZXR1cm47XG5pZiAoZW9mZCgxKSkgcmV0dXJuO1xubGV0IGQgPSBwZWVrZCgxKTtcbmlmICgoKGQgPT09IDB4MmQpIHx8IChkID09PSAweDJiKSkpIHtcbmlmIChlb2ZkKDIpKSByZXR1cm47XG5sZXQgZSA9IHBlZWtkKDIpO1xuaWYgKCFpc0FzY2lpTnVtYmVyKGUpKSByZXR1cm47XG5za2lwRmFzdFdpdGhvdXRVcGRhdGluZ0NhY2hlKCk7XG5za2lwRmFzdFdpdGhvdXRVcGRhdGluZ0NhY2hlKCk7XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybjtcbnNraXBEaWdpdHMoKTtcbnJldHVybjtcbn1cbmlmICghaXNBc2NpaU51bWJlcihkKSkgcmV0dXJuO1xuc2tpcEZhc3RXaXRob3V0VXBkYXRpbmdDYWNoZSgpO1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm47XG5za2lwRGlnaXRzKCk7XG59XG5mdW5jdGlvbiBwYXJzZUZyb21GcmFjdGlvbkRvdCgpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuO1xubGV0IGMgPSBza2lwRGlnaXRzKCk7XG5wYXJzZUV4cG9uZW50TWF5YmUoYyk7XG59XG5mdW5jdGlvbiBwYXJzZUhleCgpIHtcbmlmIChwb2ludGVyID49IGxlbikge1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdgMHhgIGlzIGlsbGVnYWwgd2l0aG91dCBhIGRpZ2l0JztcbnJldHVybiAyMDk3MTc1O1xufVxubGV0IGMgPSBjYWNoZTtcbmxldCBjdiA9IGdldEhleFZhbHVlKGMpO1xuaWYgKGN2ID09PSAxNikge1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdgMHhgIGlzIGlsbGVnYWwgd2l0aG91dCBhIGRpZ2l0JztcbnJldHVybiAyMDk3MTc1O1xufVxuc2tpcCgpO1xuZG8ge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gNDEwNDtcbmMgPSBjYWNoZTtcbmN2ID0gZ2V0SGV4VmFsdWUoYyk7XG5pZiAoY3YgPT09IDE2KSB7XG5icmVhaztcbn1cbnNraXAoKTtcbn0gd2hpbGUgKHRydWUpO1xuaWYgKGMgPT09IDB4NkUpIHtcbmlmICghc3VwcG9ydEJpZ0ludCkge1xucmV0dXJuIFRIUk9XKCgnVGhlIEJpZ0ludCBzeW50YXggaXMgc3VwcG9ydGVkIGluIEVTMTErIC8gRVMyMDIwIChjdXJyZW50bHkgcGFyc2luZyBFUycgKyB0YXJnZXRFc1ZlcnNpb24pICsgJyknLCBzdGFydEZvckVycm9yLCBwb2ludGVyICsgMSk7XG59XG5za2lwKCk7XG5yZXR1cm4gMTIyOTY7XG59XG5yZXR1cm4gNDEwNDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2N0YWwoKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnYDBvYCBpcyBpbGxlZ2FsIHdpdGhvdXQgYSBkaWdpdCc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmxldCBjID0gY2FjaGU7XG5pZiAoIWlzT2N0YWwoYykpIHtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnYDBvYCBpcyBpbGxlZ2FsIHdpdGhvdXQgYSBkaWdpdCc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbnNraXAoKTtcbmRvIHtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDQxMDc7XG5jID0gY2FjaGU7XG5pZiAoIWlzT2N0YWwoYykpIGJyZWFrO1xuc2tpcCgpO1xufSB3aGlsZSAodHJ1ZSk7XG5pZiAoYyA9PT0gMHg2RSkge1xuaWYgKCFzdXBwb3J0QmlnSW50KSB7XG5yZXR1cm4gVEhST1coKCdUaGUgQmlnSW50IHN5bnRheCBpcyBzdXBwb3J0ZWQgaW4gRVMxMSsgLyBFUzIwMjAgKGN1cnJlbnRseSBwYXJzaW5nIEVTJyArIHRhcmdldEVzVmVyc2lvbikgKyAnKScsIHN0YXJ0Rm9yRXJyb3IsIHBvaW50ZXIgKyAxKTtcbn1cbnNraXAoKTtcbnJldHVybiAxMjI5OTtcbn1cbnJldHVybiA0MTA3O1xufVxuZnVuY3Rpb24gcGFyc2VCaW5hcnkoKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnYDBiYCBpcyBpbGxlZ2FsIHdpdGhvdXQgYSBkaWdpdCc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmxldCBjID0gY2FjaGU7XG5pZiAoIWlzQmluYXJ5KGMpKSB7XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ2AwYmAgaXMgaWxsZWdhbCB3aXRob3V0IGEgZGlnaXQnO1xucmV0dXJuIDIwOTcxNzU7XG59XG5za2lwKCk7XG5kbyB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiA0MTA2O1xuYyA9IGNhY2hlO1xuaWYgKCFpc0JpbmFyeShjKSkgYnJlYWs7XG5za2lwKCk7XG59IHdoaWxlICh0cnVlKTtcbmlmIChjID09PSAweDZFKSB7XG5pZiAoIXN1cHBvcnRCaWdJbnQpIHtcbnJldHVybiBUSFJPVygoJ1RoZSBCaWdJbnQgc3ludGF4IGlzIHN1cHBvcnRlZCBpbiBFUzExKyAvIEVTMjAyMCAoY3VycmVudGx5IHBhcnNpbmcgRVMnICsgdGFyZ2V0RXNWZXJzaW9uKSArICcpJywgc3RhcnRGb3JFcnJvciwgcG9pbnRlciArIDEpO1xufVxuc2tpcCgpO1xucmV0dXJuIDEyMjk3O1xufVxucmV0dXJuIDQxMDY7XG59XG5mdW5jdGlvbiBpc0JpbmFyeShvcmQpIHtcbnJldHVybiAoKG9yZCA9PT0gMHgzMCkgfHwgKG9yZCA9PT0gMHgzMSkpO1xufVxuZnVuY3Rpb24gcGFyc2VFeGNsKCkge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMTY0NjM7XG5pZiAoKGNhY2hlID09PSAweDNkKSkge1xuc2tpcCgpO1xuaWYgKChwb2ludGVyIDwgbGVuICYmIChjYWNoZSA9PT0gMHgzZCkpKSB7XG5za2lwKCk7XG5yZXR1cm4gODIwMDE7XG59XG5yZXR1cm4gODIwMDA7XG59XG5yZXR1cm4gMTY0NjM7XG59XG5mdW5jdGlvbiBwYXJzZVN0YXIoKSB7XG5pZiAocG9pbnRlciA8IGxlbikge1xubGV0IGMgPSBjYWNoZTtcbmlmIChjID09PSAweDJhKSB7XG5za2lwKCk7XG5pZiAoKHBvaW50ZXIgPCBsZW4gJiYgKGNhY2hlID09PSAweDNkKSkpIHtcbnNraXAoKTtcbnJldHVybiA0OTI0NDtcbn1cbnJldHVybiA4MjAxMDtcbn0gZWxzZSBpZiAoYyA9PT0gMHgzZCkge1xuc2tpcCgpO1xucmV0dXJuIDQ5MjQzO1xufVxufVxucmV0dXJuIDgyMDA5O1xufVxuZnVuY3Rpb24gcGFyc2VJZGVudFJlc3ROb3RLZXl3b3JkT2JqVHJpZShkLCBuLCBzdGFydCkge1xucG9pbnRlciA9IG4gLSAxO1xuY2FjaGUgPSBkO1xucmV0dXJuIHBhcnNlSWRlbnRpZmllclJlc3Qoc2xpY2Uoc3RhcnQsIG4gLSAxKSwgKG4gLSAxKSAtIHN0YXJ0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUG90ZW50aWFsS2V5d29yZFRyaWVNYXAoYykge1xubGV0IHRyaWVPYmpsaXQgPSBLRVlXT1JEX1RSSUVfT0JKTElUW2MgLSAweDYxXTtcbmxldCBzdGFydCA9IHBvaW50ZXIgLSAxO1xubGV0IG4gPSBzdGFydCArIDE7XG5kbyB7XG5pZiAobiA+PSBsZW4pIHJldHVybiBlb2ZBZnRlclBvdGVudGlhbEtleXdvcmRUcmllTWFwKHRyaWVPYmpsaXQsIG4sIHN0YXJ0KTtcbmxldCBkID0gaW5wdXQuY2hhckNvZGVBdChuKyspO1xuaWYgKCgoZCA8IDB4NjEpIHx8IChkID4gMHg3YSkpKSB7XG5yZXR1cm4gZW5kT2ZQb3RlbnRpYWxLZXl3b3JkVHJpZU1hcCh0cmllT2JqbGl0LCBkLCBuLCBzdGFydCk7XG59XG50cmllT2JqbGl0ID0gdHJpZU9iamxpdFtkIC0gMHg2MV07XG5pZiAodHJpZU9iamxpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGFyc2VJZGVudFJlc3ROb3RLZXl3b3JkT2JqVHJpZShkLCBuLCBzdGFydCk7XG59IHdoaWxlICh0cnVlKTtcbn1cbmZ1bmN0aW9uIGVuZE9mUG90ZW50aWFsS2V5d29yZFRyaWVNYXAodHJpZU9iamxpdCwgZCwgbiwgc3RhcnQpIHtcbmxldCBoaXQgPSB0cmllT2JqbGl0LmhpdDtcbmlmIChkID4gMHg3ZSkge1xucG9pbnRlciA9IG4gLSAxO1xuY2FjaGUgPSBkO1xubGV0IHdpZGUgPSBpc0lkZW50UmVzdENocihkLCBuIC0gMSk7XG5pZiAod2lkZSA9PT0gKC0xKSkge1xubGFzdENhbm9uaXplZElucHV0TGVuID0gKG4gLSAxKSAtIHN0YXJ0O1xuaWYgKGhpdCA9PT0gdW5kZWZpbmVkKSB7XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBzbGljZShzdGFydCwgbiAtIDEpO1xucmV0dXJuIDIwNDg7XG59XG5sZXQgY2Fub24gPSB0cmllT2JqbGl0LmNhbm9uO1xubGFzdENhbm9uaXplZElucHV0ID0gY2Fub247XG5yZXR1cm4gaGl0O1xufVxucmV0dXJuIHBhcnNlSWRlbnRpZmllclJlc3Qoc2xpY2Uoc3RhcnQsIG4gLSAxKSwgKG4gLSAxKSAtIHN0YXJ0KTtcbn1cbmxldCBzID0gZ2V0VG9rZW5TdGFydChkKTtcbmlmICgoKCgocyA9PT0gMikgfHwgKHMgPT09IDcpKSkgfHwgKHMgPT09IDE0KSkpIHtcbnBvaW50ZXIgPSBuIC0gMTtcbmNhY2hlID0gZDtcbnJldHVybiBwYXJzZUlkZW50aWZpZXJSZXN0KHNsaWNlKHN0YXJ0LCBuIC0gMSksIChuIC0gMSkgLSBzdGFydCk7XG59XG5pZiAocyA9PT0gMjQpIHtcbnBvaW50ZXIgPSBuIC0gMTtcbmNhY2hlID0gZDtcbnJldHVybiBwYXJzZUlkZW50aWZpZXJSZXN0KHNsaWNlKHN0YXJ0LCBuIC0gMSksIChuIC0gMSkgLSBzdGFydCk7XG59XG5pZiAoaGl0ICE9PSB1bmRlZmluZWQpIHtcbnBvaW50ZXIgPSBuIC0gMTtcbmNhY2hlID0gZDtcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IChuIC0gMSkgLSBzdGFydDtcbmxldCBjYW5vbiA9IHRyaWVPYmpsaXQuY2Fub247XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBjYW5vbjtcbnJldHVybiBoaXQ7XG59XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBzbGljZShzdGFydCwgbiAtIDEpO1xubGFzdENhbm9uaXplZElucHV0TGVuID0gKG4gLSAxKSAtIHN0YXJ0O1xucG9pbnRlciA9IG4gLSAxO1xuY2FjaGUgPSBkO1xucmV0dXJuIDIwNDg7XG59XG5mdW5jdGlvbiBlb2ZBZnRlclBvdGVudGlhbEtleXdvcmRUcmllTWFwKHRyaWVPYmpsaXQsIG4sIHN0YXJ0KSB7XG5wb2ludGVyID0gbiAtIDE7XG5za2lwKCk7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSBuIC0gc3RhcnQ7XG5sZXQgaGl0ID0gdHJpZU9iamxpdC5oaXQ7XG5pZiAoaGl0ICE9PSB1bmRlZmluZWQpIHtcbmxldCBjYW5vbiA9IHRyaWVPYmpsaXQuY2Fub247XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBjYW5vbjtcbnJldHVybiBoaXQ7XG59XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBzbGljZShzdGFydCwgbik7XG5yZXR1cm4gMjA0ODtcbn1cbmZ1bmN0aW9uIHBhcnNlSWRlbnRpZmllclJlc3QocHJldlN0ciwgcHJldkxlbikge1xubGV0IHN0YXJ0ID0gcG9pbnRlcjtcbndoaWxlIChwb2ludGVyIDwgbGVuKSB7XG5sZXQgYyA9IGNhY2hlO1xubGV0IHMgPSBnZXRJZGVudFBhcnQoYyk7XG5zd2l0Y2ggKHMpIHtcbmNhc2UgMDpcbnNraXAoKTtcbmJyZWFrO1xuY2FzZSAxOlxubGFzdENhbm9uaXplZElucHV0ID0gcHJldlN0ciArIHNsaWNlKHN0YXJ0LCBwb2ludGVyKTtcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IHByZXZMZW4gKyAocG9pbnRlciAtIHN0YXJ0KTtcbnJldHVybiAyMDQ4O1xuY2FzZSAyOlxubGV0IHggPSBwcmV2U3RyICsgc2xpY2Uoc3RhcnQsIHBvaW50ZXIpO1xubGV0IHhsZW4gPSBwcmV2TGVuICsgKHBvaW50ZXIgLSBzdGFydCk7XG5za2lwKCk7XG5yZXR1cm4gcGFyc2VJZGVudEZyb21Vbmljb2RlRXNjYXBlKGZhbHNlLCB4LCB4bGVuKTtcbmNhc2UgMzpcbmxldCB3aWRlID0gaXNJZGVudFJlc3RDaHJVbmljb2RlKGMsIHBvaW50ZXIpO1xuaWYgKHdpZGUgPT09ICgtMSkpIHtcbmxhc3RDYW5vbml6ZWRJbnB1dCA9IHByZXZTdHIgKyBzbGljZShzdGFydCwgcG9pbnRlcik7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSBwcmV2TGVuICsgKHBvaW50ZXIgLSBzdGFydCk7XG5yZXR1cm4gMjA0ODtcbn1cbmlmICh3aWRlID09PSAoLTMpKSB7XG5za2lwRmFzdFdpdGhvdXRVcGRhdGluZ0NhY2hlKCk7XG59XG5za2lwKCk7XG5icmVhaztcbjtcbn1cbn1cbmxhc3RDYW5vbml6ZWRJbnB1dCA9IHByZXZTdHIgKyBzbGljZShzdGFydCwgcG9pbnRlcik7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSBwcmV2TGVuICsgKHBvaW50ZXIgLSBzdGFydCk7XG5yZXR1cm4gMjA0ODtcbn1cbmZ1bmN0aW9uIHBhcnNlSWRlbnRGcm9tVW5pY29kZUVzY2FwZShmcm9tU3RhcnQsIHByZXZTdHIsIHByZXZMZW4pIHtcbmlmIChwb2ludGVyID49IGxlbikge1xubGFzdENhbm9uaXplZElucHV0ID0gcHJldlN0cjtcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IHByZXZMZW47XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gJ0VuY291bnRlcmVkIGEgYmFja3NsYXNoIGF0IGVuZCBvZiBpbnB1dCc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmlmICghKGNhY2hlID09PSAweDc1KSkge1xucmV0dXJuIFRIUk9XKCdPbmx5IHVuaWNvZGUgZXNjYXBlcyBhcmUgc3VwcG9ydGVkIGluIGlkZW50aWZpZXIgZXNjYXBlcycsIHN0YXJ0Rm9yRXJyb3IsIHBvaW50ZXIgKyAxKTtcbn1cbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikge1xuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdSZWFjaGVkIGVuZCBvZiBpbnB1dCBiZWZvcmUgY2xvc2luZyB0aGUgY3VycmVudCBpZGVudCBlc2NhcGUnO1xucmV0dXJuIDIwOTcxNzU7XG59XG5sZXQgciA9IHBhcnNlVW5pY29kZUVzY2FwZUZvck5vblJlZ2V4KCk7XG5pZiAociA9PT0gMHgxMTAwMDApIHtcbnBhcnNlSWRlbnRpZmllclJlc3QocHJldlN0ciwgcHJldkxlbik7XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBwcmV2U3RyO1xubGFzdENhbm9uaXplZElucHV0TGVuID0gcHJldkxlbjtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnT25seSBfdW5pY29kZV8gZXNjYXBlcyBhcmUgc3VwcG9ydGVkIGluIGlkZW50aWZpZXJzJztcbnJldHVybiAyMDk3MTc1O1xufVxuaWYgKHIgPiAweGZmZmYpIHtcbnByZXZTdHIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocik7XG5wcmV2TGVuICs9IDI7XG59IGVsc2Uge1xucHJldlN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHIpO1xuKytwcmV2TGVuO1xufVxuaWYgKCgoZnJvbVN0YXJ0ID09PSB0cnVlKSAmJiAoaXNJZGVudFN0YXJ0KHIsIC0xKSAhPT0gKC0xKSkpKSB7XG5yZXR1cm4gcGFyc2VJZGVudGlmaWVyUmVzdChwcmV2U3RyLCBwcmV2TGVuKTtcbn1cbmlmICgoKGZyb21TdGFydCA9PT0gZmFsc2UpICYmIChpc0lkZW50UmVzdENocihyLCAtMSkgIT09ICgtMSkpKSkge1xucmV0dXJuIHBhcnNlSWRlbnRpZmllclJlc3QocHJldlN0ciwgcHJldkxlbik7XG59XG5sYXN0Q2Fub25pemVkSW5wdXQgPSBwcmV2U3RyO1xubGFzdENhbm9uaXplZElucHV0TGVuID0gcHJldkxlbjtcbmlmICghbGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSBsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IgPSAnSWRlbnRpZmllciBlc2NhcGUgZGlkIG5vdCB5aWVsZCBhIHZhbGlkIGlkZW50aWZpZXIgY2hhcmFjdGVyJztcbnJldHVybiAyMDk3MTc1O1xufVxuZnVuY3Rpb24gdG9TdHJpbmdFeHBlbnNpdmUoYykge1xucmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGMpO1xufVxuZnVuY3Rpb24gaXNJZGVudFN0YXJ0KGMsIG9mZnNldE9mQykge1xuaWYgKGMgPiAweDdlKSB7XG5yZXR1cm4gdmVyeUV4cGVuc2l2ZVVuaWNvZGVDaGVjayhjLCBvZmZzZXRPZkMsIGdldElkU3RhcnRSZWdleFN1cGVyU2xvdygpKTtcbn1cbmxldCBzID0gZ2V0VG9rZW5TdGFydChjKTtcbmlmICgoKHMgPT09IDIpIHx8IChzID09PSAzKSkpIHJldHVybiAtMjtcbnJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGlzSWRlbnRSZXN0Q2hyKGMsIG9mZnNldE9mQykge1xuaWYgKGMgPiAweDdlKSB7XG5yZXR1cm4gaXNJZGVudFJlc3RDaHJVbmljb2RlKGMsIG9mZnNldE9mQyk7XG59XG5sZXQgcyA9IGdldFRva2VuU3RhcnQoYyk7XG5pZiAoKChzID09PSAyKSB8fCAocyA9PT0gMykpKSByZXR1cm4gLTI7XG5pZiAocyA9PT0gNykgcmV0dXJuIC0yO1xuaWYgKHMgPT09IDE0KSByZXR1cm4gLTI7XG5yZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBpc0lkZW50UmVzdENoclVuaWNvZGUoYywgb2Zmc2V0T2ZDKSB7XG5pZiAoKChjID09PSAweDIwMEMpIHx8IChjID09PSAweDIwMEQpKSkgcmV0dXJuIC0yO1xucmV0dXJuIHZlcnlFeHBlbnNpdmVVbmljb2RlQ2hlY2soYywgb2Zmc2V0T2ZDLCBnZXRJZFJlc3RSZWdleFN1cGVyU2xvdygpKTtcbn1cbmZ1bmN0aW9uIHZlcnlFeHBlbnNpdmVVbmljb2RlQ2hlY2soYywgb2Zmc2V0LCByZWdleFNjYW5uZXIpIHtcbmlmIChvZmZzZXQgIT09ICgtMSkpIHtcbmMgPSBpbnB1dC5jb2RlUG9pbnRBdChvZmZzZXQpO1xufVxubGV0IHMgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjKTtcbmlmIChyZWdleFNjYW5uZXIudGVzdChzKSkge1xucmV0dXJuICgocy5sZW5ndGggPT09IDEpPyAoLTIpIDogKC0zKSk7XG59XG5yZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBpc0FzY2lpTGV0dGVyKGMpIHtcbmxldCBkID0gYyB8IDMyO1xucmV0dXJuICgoZCA+PSAweDYxKSAmJiAoZCA8PSAweDdhKSk7XG59XG5mdW5jdGlvbiBpc0FzY2lpTnVtYmVyKGMpIHtcbnJldHVybiAoKGMgPj0gMHgzMCkgJiYgKGMgPD0gMHgzOSkpO1xufVxuZnVuY3Rpb24gcGFyc2VDb21wb3VuZEFzc2lnbm1lbnQoYykge1xuaWYgKChwb2ludGVyIDwgbGVuICYmIChjYWNoZSA9PT0gMHgzZCkpKSB7XG5za2lwKCk7XG5pZiAoYyA9PT0gMHg1ZSkgcmV0dXJuIDQ5MjgwO1xucmV0dXJuIDQ5MjM1O1xufVxuaWYgKGMgPT09IDB4NWUpIHJldHVybiA4MjA0NztcbnJldHVybiA4MjAwMjtcbn1cbmZ1bmN0aW9uIHBhcnNlRndkU2xhc2gobGV4ZXJGbGFncykge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gODIwMjM7XG5sZXQgYyA9IGNhY2hlO1xuaWYgKGMgPT09IDB4MmYpIHtcbnNraXAoKTtcbnJldHVybiBwYXJzZUNvbW1lbnRTaW5nbGUoKTtcbn1cbmlmIChjID09PSAweDJhKSB7XG5yZXR1cm4gcGFyc2VDb21tZW50TXVsdGkoKTtcbn1cbmlmICgobGV4ZXJGbGFncyAmIDQpID09PSA0KSB7XG5yZXR1cm4gcGFyc2VSZWdleChjKTtcbn1cbmlmIChjID09PSAweDNkKSB7XG5za2lwKCk7XG5yZXR1cm4gNDkyNTY7XG59XG5yZXR1cm4gODIwMjM7XG59XG5mdW5jdGlvbiBwYXJzZUNvbW1lbnRTaW5nbGUoKSB7XG53aGlsZSAocG9pbnRlciA8IGxlbikge1xubGV0IGMgPSBjYWNoZTtcbmlmICgoKGMgPT09IDB4MEQpIHx8IGlzTGZQc0xzKGMpKSkge1xucmV0dXJuIDEyODU7XG59XG5za2lwKCk7XG59XG5yZXR1cm4gMTI4NTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tbWVudE11bHRpKCkge1xuc2tpcCgpO1xubGV0IGMgPSAwO1xud2hpbGUgKHBvaW50ZXIgPCBsZW4pIHtcbmMgPSBjYWNoZTtcbnNraXAoKTtcbndoaWxlIChjID09PSAweDJhKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIGJyZWFrO1xuYyA9IGNhY2hlO1xuc2tpcCgpO1xuaWYgKGMgPT09IDB4MmYpIHtcbnJldHVybiAxMjg2O1xufVxufVxuaWYgKGMgPT09IDB4MEQpIHtcbmlmICgocG9pbnRlciA8IGxlbiAmJiAoY2FjaGUgPT09IDB4MEEpKSkgc2tpcCgpO1xuaW5jcmVtZW50TGluZSgpO1xufSBlbHNlIGlmIChpc0xmUHNMcyhjKSkge1xuaW5jcmVtZW50TGluZSgpO1xufVxufVxuaWYgKCFsYXN0UmVwb3J0YWJsZUxleGVyRXJyb3IpIGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdVbmNsb3NlZCBtdWx0aSBsaW5lIGNvbW1lbnQsIGVhcmx5IGVvZic7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tbWVudEh0bWxPcGVuKCkge1xucGFyc2VDb21tZW50U2luZ2xlKCk7XG5yZXR1cm4gMTI4Nztcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tbWVudEh0bWxDbG9zZSgpIHtcbnBhcnNlQ29tbWVudFNpbmdsZSgpO1xucmV0dXJuIDEyODc7XG59XG5mdW5jdGlvbiBwYXJzZUVxdWFsKCkge1xuaWYgKHBvaW50ZXIgPCBsZW4pIHtcbmxldCBjID0gY2FjaGU7XG5pZiAoYyA9PT0gMHgzZCkge1xuc2tpcCgpO1xuaWYgKChwb2ludGVyIDwgbGVuICYmIChjYWNoZSA9PT0gMHgzZCkpKSB7XG5za2lwKCk7XG5yZXR1cm4gODIwMzQ7XG59XG5yZXR1cm4gODIwMzM7XG59IGVsc2UgaWYgKGMgPT09IDB4M2UpIHtcbnNraXAoKTtcbnJldHVybiAxNjQ5OTtcbn1cbn1cbnJldHVybiA0OTI2NDtcbn1cbmZ1bmN0aW9uIHBhcnNlTHQoKSB7XG5pZiAoKCgoKCgoKCgoKHBhcnNpbmdHb2FsID09PSBmYWxzZSkgJiYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkpKSAmJiAoIWVvZmQoMykpKSkgJiYgKGNhY2hlID09PSAweDIxKSkpICYmIChwZWVrZCgxKSA9PT0gMHgyZCkpKSAmJiAocGVla2QoMikgPT09IDB4MmQpKSkge1xucmV0dXJuIHBhcnNlQ29tbWVudEh0bWxPcGVuKCk7XG59XG5yZXR1cm4gcGFyc2VMdFB1bmN0dWF0b3IoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTHRQdW5jdHVhdG9yKCkge1xuaWYgKHBvaW50ZXIgPCBsZW4pIHtcbmxldCBjID0gY2FjaGU7XG5pZiAoYyA9PT0gMHgzZCkge1xuc2tpcCgpO1xucmV0dXJuIDgyMDI5O1xufVxuaWYgKGMgPT09IDB4M2MpIHtcbnNraXAoKTtcbmlmICgocG9pbnRlciA8IGxlbiAmJiAoY2FjaGUgPT09IDB4M2QpKSkge1xuc2tpcCgpO1xucmV0dXJuIDQ5MjYyO1xufVxucmV0dXJuIDgyMDI4O1xufVxufVxucmV0dXJuIDgyMDI3O1xufVxuZnVuY3Rpb24gcGFyc2VHdFB1bmN0dWF0b3IoKSB7XG5pZiAocG9pbnRlciA8IGxlbikge1xubGV0IGMgPSBjYWNoZTtcbmlmIChjID09PSAweDNkKSB7XG5za2lwKCk7XG5yZXR1cm4gODIwMzk7XG59XG5pZiAoYyA9PT0gMHgzZSkge1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPCBsZW4pIHtcbmMgPSBjYWNoZTtcbmlmIChjID09PSAweDNkKSB7XG5za2lwKCk7XG5yZXR1cm4gNDkyNzI7XG59XG5pZiAoYyA9PT0gMHgzZSkge1xuc2tpcCgpO1xuaWYgKChwb2ludGVyIDwgbGVuICYmIChjYWNoZSA9PT0gMHgzZCkpKSB7XG5za2lwKCk7XG5yZXR1cm4gNDkyNzM7XG59XG5yZXR1cm4gODIwMzg7XG59XG59XG5yZXR1cm4gODIwMzc7XG59XG59XG5yZXR1cm4gODIwMzY7XG59XG5mdW5jdGlvbiBwYXJzZU5ld2xpbmVTb2xvKCkge1xuaW5jcmVtZW50TGluZSgpO1xucmV0dXJuIDc3MTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmFja3NsYXNoKCkge1xucmV0dXJuIHBhcnNlSWRlbnRGcm9tVW5pY29kZUVzY2FwZSh0cnVlLCAnJywgMCk7XG59XG5mdW5jdGlvbiBwYXJzZVFtYXJrKCkge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMTY1MDY7XG5pZiAoKGNhY2hlID09PSAweDNmKSkge1xuc2tpcCgpO1xuaWYgKHN1cHBvcnROdWxsaXNoQ29hbGVzY2luZykge1xucmV0dXJuIDgyMDQ0O1xufVxucmV0dXJuIFRIUk9XKCdUaGUgbnVsbGlzaCBjb2FsZXNjaW5nIG9wZXJhdG9yIChgPz9gKSBpcyBvbmx5IHN1cHBvcnRlZCBzaW5jZSBFUzIwMjAsIGN1cnJlbnRseSB0YXJnZXRpbmcgYSBsb3dlciB2ZXJzaW9uJywgcG9pbnRlciAtIDIsIHBvaW50ZXIpO1xufVxuaWYgKChjYWNoZSA9PT0gMHgyZSkpIHtcbmlmIChuZW9mZCgxKSkge1xubGV0IGMgPSBwZWVrZCgxKTtcbmlmICgoKGMgPj0gMHgzMCkgJiYgKGMgPD0gMHgzOSkpKSB7XG5yZXR1cm4gMTY1MDY7XG59XG59XG5za2lwKCk7XG5pZiAoc3VwcG9ydE9wdGlvbmFsQ2hhaW5pbmcpIHtcbnJldHVybiA4MjA0Mztcbn1cbnJldHVybiBUSFJPVygnVGhlIG9wdGlvbmFsIGNoYWluaW5nIG9wZXJhdG9yIChgPy5gKSBpcyBvbmx5IHN1cHBvcnRlZCBzaW5jZSBFUzIwMjAsIGN1cnJlbnRseSB0YXJnZXRpbmcgYSBsb3dlciB2ZXJzaW9uJywgcG9pbnRlciwgcG9pbnRlciArIDIpO1xufVxucmV0dXJuIDE2NTA2O1xufVxuZnVuY3Rpb24gcmVnZXhTeW50YXhFcnJvcihkZXNjLCAuLi5yZXN0KSB7XG5pZiAobGFzdFJlcG9ydGFibGVMZXhlckVycm9yKSB7XG5yZXR1cm4gNDtcbn1cbnVwZGF0ZVJlZ2V4UG90ZW50aWFsRXJyb3IoZGVzYyArICgocmVzdC5sZW5ndGg/ICgnOiBbJyArIHJlc3Quam9pbignLCAnKSkgKyAnXScgOiAnJykpKTtcbmxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvciA9ICdSZWdleDogJyArIGxhc3RQb3RlbnRpYWxSZWdleEVycm9yO1xucmV0dXJuIDQ7XG59XG5mdW5jdGlvbiB1cGRhdGVSZWdleFBvdGVudGlhbEVycm9yKG1zZykge1xuaWYgKCFsYXN0UG90ZW50aWFsUmVnZXhFcnJvci5pbmNsdWRlcyhtc2cpKSB7XG5pZiAobGFzdFBvdGVudGlhbFJlZ2V4RXJyb3IpIGxhc3RQb3RlbnRpYWxSZWdleEVycm9yICs9ICc7ICc7XG5sYXN0UG90ZW50aWFsUmVnZXhFcnJvciArPSBtc2c7XG59XG59XG5mdW5jdGlvbiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKHN0YXRlLCByZWFzb24pIHtcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnU3RhdGUoc3RhdGUsIDIsIHJlYXNvbik7XG59XG5mdW5jdGlvbiB1cGRhdGVSZWdleFVmbGFnSXNNYW5kYXRvcnkoc3RhdGUsIHJlYXNvbikge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdTdGF0ZShzdGF0ZSwgMSwgcmVhc29uKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlZ2V4VWZsYWdTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBlcnJvcikge1xuaWYgKGxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgcmV0dXJuIDQ7XG5pZiAoY3VycmVudFN0YXRlID09PSAoKChuZXdTdGF0ZSA9PT0gMSk/IDIgOiAxKSkpIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKGVycm9yKTtcbn1cbmlmIChjdXJyZW50U3RhdGUgPT09IDApIHtcbnVwZGF0ZVJlZ2V4UG90ZW50aWFsRXJyb3IoZXJyb3IpO1xuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG59IGVsc2Uge1xuXG59XG5yZXR1cm4gY3VycmVudFN0YXRlO1xufVxubGV0IG5DYXB0dXJpbmdQYXJlbnMgPSAwO1xubGV0IGxhcmdlc3RCYWNrUmVmZXJlbmNlID0gMDtcbmxldCBkZWNsYXJlZEdyb3VwTmFtZXMgPSAnLCc7XG5sZXQgcmVmZmVkR3JvdXBOYW1lcyA9ICcsJztcbmxldCBrQ2hhckNsYXNzRXNjYXBlZCA9IGZhbHNlO1xubGV0IGZvdW5kSW52YWxpZEdyb3VwTmFtZSA9IGZhbHNlO1xuZnVuY3Rpb24gcGFyc2VSZWdleChjKSB7XG5uQ2FwdHVyaW5nUGFyZW5zID0gMDtcbmxhcmdlc3RCYWNrUmVmZXJlbmNlID0gMDtcbmxhc3RQb3RlbnRpYWxSZWdleEVycm9yID0gJyc7XG5kZWNsYXJlZEdyb3VwTmFtZXMgPSAnLCc7XG5yZWZmZWRHcm91cE5hbWVzID0gJywnO1xua0NoYXJDbGFzc0VzY2FwZWQgPSBmYWxzZTtcbmZvdW5kSW52YWxpZEdyb3VwTmFtZSA9IGZhbHNlO1xubGV0IHVzdGF0dXNCb2R5ID0gcGFyc2VSZWdleEJvZHkoYyk7XG5pZiAodXN0YXR1c0JvZHkgPT09IDQpIHtcbnJldHVybiAyMDk3MTc1O1xufVxubGV0IHVzdGF0dXNGbGFncyA9IHBhcnNlUmVnZXhGbGFncygpO1xuaWYgKG5DYXB0dXJpbmdQYXJlbnMgPCBsYXJnZXN0QmFja1JlZmVyZW5jZSkge1xubGV0IGVycm1zZyA9ICdMYXJnZXN0IGJhY2sgcmVmZXJlbmNlIGluZGV4IGV4Y2VlZGVkIHRoZSBudW1iZXIgb2YgY2FwdHVyaW5nIGdyb3VwcyAob25seSB2YWxpZCB3aXRob3V0IHUtZmxhZyBpbiB3ZWJjb21wYXQgbW9kZSknO1xuaWYgKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHtcbnJlZ2V4U3ludGF4RXJyb3IoZXJybXNnKTtcbnJldHVybiAyMDk3MTc1O1xufVxudXN0YXR1c0JvZHkgPSB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKHVzdGF0dXNCb2R5LCBlcnJtc2cpO1xufVxuaWYgKHVzdGF0dXNGbGFncyA9PT0gNCkge1xucmV0dXJuIDIwOTcxNzU7XG59XG5pZiAoa0NoYXJDbGFzc0VzY2FwZWQpIHtcbmlmIChkZWNsYXJlZEdyb3VwTmFtZXMgIT09ICcsJykge1xucmVnZXhTeW50YXhFcnJvcignRm91bmQgYFxcXFxrYCBpbiBhIGNoYXIgY2xhc3MgYnV0IHRoZSByZWdleCBhbHNvIGhhZCBhIGdyb3VwIG5hbWUgc28gdGhpcyBpcyBpbGxlZ2FsJyk7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmlmICgoKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHx8ICh1c3RhdHVzRmxhZ3MgPT09IDEpKSkge1xucmVnZXhTeW50YXhFcnJvcignRm91bmQgYFxcXFxrYCBpbiBhIGNoYXIgY2xhc3MgYnV0IHRoaXMgaXMgb25seSBhbGxvd2VkIGluIHdlYmNvbXBhdCBtb2RlIGFuZCB3aXRob3V0IHUtZmxhZycpO1xucmV0dXJuIDIwOTcxNzU7XG59XG59XG5pZiAoKChyZWZmZWRHcm91cE5hbWVzICE9PSAnLCcpICYmICgoKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHx8IChkZWNsYXJlZEdyb3VwTmFtZXMgIT09ICcsJykpKSkpIHtcbmxldCBiYWQgPSBmYWxzZTtcbnJlZmZlZEdyb3VwTmFtZXMuc3BsaXQoJywnKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChuYW1lID0+IHtcbmlmICghZGVjbGFyZWRHcm91cE5hbWVzLmluY2x1ZGVzKCgnLCcgKyBuYW1lKSArICcsJykpIHtcbnJlZ2V4U3ludGF4RXJyb3IoKCdGb3VuZCBhIGBcXFxca2AgdGhhdCByZWZlcmVuY2VkIGAnICsgbmFtZSkgKyAnYCBidXQgbm8gY2FwdHVyaW5nIGdyb3VwIGhhZCB0aGlzIG5hbWUnKTtcbmJhZCA9IHRydWU7XG59XG59KTtcbmlmIChiYWQpIHtcbnJldHVybiAyMDk3MTc1O1xufVxufVxuaWYgKHVzdGF0dXNCb2R5ID09PSAxKSB7XG5pZiAodXN0YXR1c0ZsYWdzID09PSAxKSByZXR1cm4gMjYyMTU4O1xucmVnZXhTeW50YXhFcnJvcignUmVnZXggY29udGFpbmVkIHN5bnRheCB0aGF0IGlzIG9ubHkgdmFsaWQgd2l0aCB0aGUgdS1mbGFnIGJ1dCB0aGUgdS1mbGFnIHdhcyBub3QgcHJlc2VudCcpO1xucmV0dXJuIDIwOTcxNzU7XG59XG5pZiAodXN0YXR1c0JvZHkgPT09IDIpIHtcbmlmICh1c3RhdHVzRmxhZ3MgIT09IDEpIHJldHVybiAyNjIxNTc7XG5yZWdleFN5bnRheEVycm9yKCdSZWdleCBjb250YWluZWQgc3ludGF4IHRoYXQgaXMgaW52YWxpZCB3aXRoIHRoZSB1LWZsYWcgYnV0IHRoZSB1LWZsYWcgd2FzIHByZXNlbnQnKTtcbnJldHVybiAyMDk3MTc1O1xufVxuaWYgKHVzdGF0dXNGbGFncyA9PT0gMSkgcmV0dXJuIDI2MjE1ODtcbnJldHVybiAyNjIxNTc7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4Qm9keShjKSB7XG5yZXR1cm4gX3BhcnNlUmVnZXhCb2R5KGMsIDAsIDApO1xufVxuZnVuY3Rpb24gY2Fubm90QmVRdWFudGlmaWVyKGMsIHVmbGFnU3RhdHVzLCB3ZWJjb21wYXRFeGNlcHRpb24sIG1zZykge1xubGV0IGJhZFN0YXJ0ID0gKCgoKCgoYyA9PT0gMHgyYSkgfHwgKGMgPT09IDB4MmIpKSkgfHwgKGMgPT09IDB4M2YpKSkgfHwgKGMgPT09IDB4N2IpKTtcbmlmIChiYWRTdGFydCkge1xubXNnICs9ICgnIChieSBhIGAnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSkgKyAnYCknO1xuaWYgKCh3ZWJjb21wYXRFeGNlcHRpb24gJiYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkpKSB7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwodWZsYWdTdGF0dXMsIG1zZyk7XG59IGVsc2Uge1xudWZsYWdTdGF0dXMgPSByZWdleFN5bnRheEVycm9yKG1zZyk7XG59XG59XG5yZXR1cm4gdWZsYWdTdGF0dXM7XG59XG5mdW5jdGlvbiBfcGFyc2VSZWdleEJvZHkoYywgZ3JvdXBMZXZlbCwgdWZsYWdTdGF0dXMpIHtcbmxldCBhZnRlckF0b20gPSBmYWxzZTtcbnVmbGFnU3RhdHVzID0gY2Fubm90QmVRdWFudGlmaWVyKGMsIHVmbGFnU3RhdHVzLCBjID09PSAweDdiLCAnU3RhcnRlZCB3aXRoIGEgcXVhbnRpZmllciBidXQgdGhhdCBpcyBub3QgYWxsb3dlZCcpO1xubGV0IGdyb3VwTmFtZXMgPSB7fTtcbmRvIHtcbmxldCBzID0gKChjID4gMHg3ZSk/IDExIDogcmVnZXhBdG9tSnVtcFRhYmxlW2NdKTtcbnN3aXRjaCAocykge1xuY2FzZSAwOlxuc2tpcCgpO1xuYWZ0ZXJBdG9tID0gdHJ1ZTtcbmJyZWFrO1xuY2FzZSAxOlxuc2tpcCgpO1xuYWZ0ZXJBdG9tID0gdHJ1ZTtcbmJyZWFrO1xuY2FzZSAyOlxuc2tpcCgpO1xuaWYgKGFmdGVyQXRvbSkge1xuYWZ0ZXJBdG9tID0gZmFsc2U7XG5pZiAocG9pbnRlciA8IGxlbikge1xuaWYgKChjYWNoZSA9PT0gMHgzZikpIHtcbnNraXAoKTtcbn1cbn1cbn0gZWxzZSB7XG51ZmxhZ1N0YXR1cyA9IHJlZ2V4U3ludGF4RXJyb3IoKCdFbmNvdW50ZXJlZCB1bmVzY2FwZWQgcXVhbnRpZmllciAob3JkPScgKyBjKSArICcpIHdpdGhvdXQgYSB2YWx1ZSB0byBxdWFudGlmeScpO1xufVxuYnJlYWs7XG5jYXNlIDM6XG5sZXQgd2FzRml4YWJsZUFzc2VydGlvbiA9IGZhbHNlO1xubGV0IHdhc1VuZml4YWJsZUFzc2VydGlvbiA9IGZhbHNlO1xuc2tpcCgpO1xuYWZ0ZXJBdG9tID0gZmFsc2U7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdFbmNvdW50ZXJlZCBlYXJseSBFT0YnKTtcbn1cbmMgPSBjYWNoZTtcbmlmIChjID09PSAweDNmKSB7XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdFbmNvdW50ZXJlZCBlYXJseSBFT0YnKTtcbn1cbmMgPSBjYWNoZTtcbmlmICgoKCgoKChjID09PSAweDNhKSB8fCAoYyA9PT0gMHgzZCkpKSB8fCAoYyA9PT0gMHgyMSkpKSB8fCAoYyA9PT0gMHgzYykpKSB7XG5pZiAoYyA9PT0gMHgzYykge1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgZWFybHkgRU9GJyk7XG59XG5jID0gY2FjaGU7XG5pZiAoKChjID09PSAweDNkKSB8fCAoYyA9PT0gMHgyMSkpKSB7XG5pZiAoIXN1cHBvcnRSZWdleExvb2tiZWhpbmRzKSB7XG5yZXR1cm4gVEhST1coJ0xvb2tiZWhpbmRzIGluIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnRseSB0YXJnZXRlZCBsYW5ndWFnZSB2ZXJzaW9uJywgc3RhcnRGb3JFcnJvciwgcG9pbnRlciArIDEpO1xufVxuc2tpcCgpO1xud2FzVW5maXhhYmxlQXNzZXJ0aW9uID0gdHJ1ZTtcbn0gZWxzZSBpZiAoIXN1cHBvcnRSZWdleE5hbWVkR3JvdXBzKSB7XG5za2lwKCk7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcigoJ1RoZSBsb29rYmVoaW5kIGdyb3VwIGAoPzxgIG11c3QgYmUgYCg/PD1gIG9yIGAoPzwhYCBiZWNhdXNlIG5hbWVkIGdyb3VwcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudGx5IHRhcmdldGVkIEVTIHZlcnNpb24sIG5leHQgY2hhciBhZnRlciBgPGAgaXMgYCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKSArICdgJyk7XG59IGVsc2Uge1xudWZsYWdTdGF0dXMgPSBwYXJzZVJlZ2V4R3JvdXBOYW1lKGMsIHVmbGFnU3RhdHVzLCB0cnVlKTtcbisrbkNhcHR1cmluZ1BhcmVucztcbn1cbn0gZWxzZSBpZiAoKChjID09PSAweDNkKSB8fCAoYyA9PT0gMHgyMSkpKSB7XG5za2lwKCk7XG53YXNGaXhhYmxlQXNzZXJ0aW9uID0gdHJ1ZTtcbn1cbmlmIChwb2ludGVyID49IGxlbikge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIGVhcmx5IEVPRicpO1xufVxuYyA9IGNhY2hlO1xufSBlbHNlIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCgnSWxsZWdhbCBjaGFyYWN0ZXIgYWZ0ZXIgcHNldWRvIGdyb3VwIG1hcmtlciBgKD9gIFtvcmQ9JyArIGMpICsgJ10nKTtcbn1cbn0gZWxzZSB7XG4rK25DYXB0dXJpbmdQYXJlbnM7XG59XG5sZXQgc3ViYmFkID0gX3BhcnNlUmVnZXhCb2R5KGMsIGdyb3VwTGV2ZWwgKyAxLCAwKTtcbmlmIChwb2ludGVyID49IGxlbikge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIGVhcmx5IEVPRicpO1xufVxuYyA9IGNhY2hlO1xuaWYgKCh3YXNGaXhhYmxlQXNzZXJ0aW9uIHx8IHdhc1VuZml4YWJsZUFzc2VydGlvbikpIHtcbnVmbGFnU3RhdHVzID0gY2Fubm90QmVRdWFudGlmaWVyKGMsIHVmbGFnU3RhdHVzLCAhd2FzVW5maXhhYmxlQXNzZXJ0aW9uLCAnUmVnZXggQS1zc2VydGlvbiBcImF0b21zXCIgY2FuIG5vdCBiZSBxdWFudGlmaWVkIChzbyB0aGluZ3MgbGlrZSBgXmAsIGAkYCwgYW5kIGAoPz1gIGNhbiBub3QgaGF2ZSBgKmAsIGArYCwgYD9gLCBvciBge2AgZm9sbG93aW5nIGl0KScpO1xufVxuYWZ0ZXJBdG9tID0gdHJ1ZTtcbmlmIChzdWJiYWQgPT09IDQpIHtcbnVmbGFnU3RhdHVzID0gNDtcbn0gZWxzZSBpZiAoc3ViYmFkID09PSAyKSB7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwodWZsYWdTdGF0dXMsIGxhc3RQb3RlbnRpYWxSZWdleEVycm9yKTtcbn0gZWxzZSBpZiAoc3ViYmFkID09PSAxKSB7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeSh1ZmxhZ1N0YXR1cywgbGFzdFBvdGVudGlhbFJlZ2V4RXJyb3IpO1xufVxuYnJlYWs7XG5jYXNlIDQ6XG5za2lwKCk7XG5pZiAoZ3JvdXBMZXZlbCA+IDApIHJldHVybiB1ZmxhZ1N0YXR1cztcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdGb3VuZCB1bmVzY2FwZWQgY2xvc2luZyBwYXJlbiBgKWAgd2l0aG91dCBhIGdyb3VwIGJlaW5nIG9wZW4nKTtcbmNhc2UgNTpcbmxldCBjaGFyQ2xhc3NFc2NhcGVTdGF0dXMgPSBwYXJzZVJlZ2V4Q2hhckNsYXNzKCk7XG5pZiAoY2hhckNsYXNzRXNjYXBlU3RhdHVzID09PSA0KSB7XG51ZmxhZ1N0YXR1cyA9IDQ7XG59IGVsc2UgaWYgKGNoYXJDbGFzc0VzY2FwZVN0YXR1cyA9PT0gMikge1xudWZsYWdTdGF0dXMgPSB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKHVmbGFnU3RhdHVzLCBsYXN0UG90ZW50aWFsUmVnZXhFcnJvcik7XG59IGVsc2UgaWYgKGNoYXJDbGFzc0VzY2FwZVN0YXR1cyA9PT0gMSkge1xudWZsYWdTdGF0dXMgPSB1cGRhdGVSZWdleFVmbGFnSXNNYW5kYXRvcnkodWZsYWdTdGF0dXMsIGxhc3RQb3RlbnRpYWxSZWdleEVycm9yKTtcbn1cbmFmdGVyQXRvbSA9IHRydWU7XG5icmVhaztcbmNhc2UgNjpcbntcbnNraXAoKTtcbmxldCByZWFzb24gPSAnRW5jb3VudGVyZWQgdW5lc2NhcGVkIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgYF1gIHdoaWxlIG5vdCBwYXJzaW5nIGEgY2hhcmFjdGVyIGNsYXNzLCB3aGljaCBpcyBvbmx5IHZhbGlkIHdpdGhvdXQgdS1mbGFnJztcbmlmICh3ZWJDb21wYXQgPT09IGZhbHNlKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcihyZWFzb24pO1xufVxudWZsYWdTdGF0dXMgPSB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKHVmbGFnU3RhdHVzLCByZWFzb24pO1xuYWZ0ZXJBdG9tID0gdHJ1ZTtcbmJyZWFrO1xufVxuY2FzZSA3Olxue1xuc2tpcCgpO1xuYWZ0ZXJBdG9tID0gdHJ1ZTtcbmlmIChwb2ludGVyID49IGxlbikge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0Vhcmx5IEVPRicpO1xufVxubGV0IGQgPSBjYWNoZTtcbmlmICgoKGQgPT09IDB4NjIpIHx8IChkID09PSAweDQyKSkpIHtcbnNraXAoKTtcbmFmdGVyQXRvbSA9IGZhbHNlO1xufSBlbHNlIHtcbmxldCBlc2NhcGVTdGF0dXMgPSBwYXJzZUVzY2FwZUZvclJlZ2V4QXRvbShkKTtcbmlmIChlc2NhcGVTdGF0dXMgPT09IDQpIHtcbnVmbGFnU3RhdHVzID0gNDtcbn0gZWxzZSBpZiAoZXNjYXBlU3RhdHVzID09PSAyKSB7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwodWZsYWdTdGF0dXMsIGxhc3RQb3RlbnRpYWxSZWdleEVycm9yKTtcbn0gZWxzZSBpZiAoZXNjYXBlU3RhdHVzID09PSAxKSB7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeSh1ZmxhZ1N0YXR1cywgbGFzdFBvdGVudGlhbFJlZ2V4RXJyb3IpO1xufSBlbHNlIGlmIChlc2NhcGVTdGF0dXMgPT09IDgpIHtcbmFmdGVyQXRvbSA9IGZhbHNlO1xufVxufVxufVxuYnJlYWs7XG5jYXNlIDg6XG5pZiAoZ3JvdXBMZXZlbCAhPT0gMCkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ1VuY2xvc2VkIGdyb3VwJyk7XG59XG5za2lwKCk7XG5yZXR1cm4gdWZsYWdTdGF0dXM7XG5jYXNlIDk6XG5za2lwKCk7XG5hZnRlckF0b20gPSBmYWxzZTtcbmJyZWFrO1xuY2FzZSAxMDpcbnNraXAoKTtcbmlmIChwb2ludGVyIDwgbGVuKSB7XG5jID0gY2FjaGU7XG51ZmxhZ1N0YXR1cyA9IGNhbm5vdEJlUXVhbnRpZmllcihjLCB1ZmxhZ1N0YXR1cywgYyA9PT0gMHg3YiwgJ1JlZ2V4IGBBLXNzZXJ0aW9uYCBcImF0b21zXCIgY2FuIG5vdCBiZSBxdWFudGlmaWVkIGJ1dCB0aGlzIGAkYCB3YXMgcXVhbnRpZmllZCBhbnl3YXlzJyk7XG59XG5hZnRlckF0b20gPSBmYWxzZTtcbmJyZWFrO1xuY2FzZSAxMTpcbmlmICgoKGMgPT09IDB4MjAyOCkgfHwgKGMgPT09IDB4MjAyOSkpKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgZWFybHkgRU9GJyk7XG59XG5za2lwKCk7XG5hZnRlckF0b20gPSB0cnVlO1xuYnJlYWs7XG5jYXNlIDEyOlxue1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRWFybHkgRU9GIGF0IHRoZSBzdGFydCBvZiBhIHJlZ2V4IHF1YW50aWZpZXInKTtcbn1cbmxldCBjID0gY2FjaGU7XG5sZXQgdmFsaWRCcmFjZSA9IChpc0FzY2lpTnVtYmVyKGMpPyBwYXJzZVJlZ2V4Q3VybHlRdWFudGlmaWVyKGMpIDogMyk7XG5pZiAodmFsaWRCcmFjZSA9PT0gMSkge1xuaWYgKGFmdGVyQXRvbSkge1xuYWZ0ZXJBdG9tID0gZmFsc2U7XG5pZiAoKHBvaW50ZXIgPCBsZW4gJiYgKGNhY2hlID09PSAweDNmKSkpIHtcbnNraXAoKTtcbn1cbmJyZWFrO1xufVxucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0EgdmFsaWQgYnJhY2tldCBxdWFudGlmaWVyIHJlcXVpcmVzIGFuIHVucXVhbGlmaWVkIGF0b20sIGJ1dCB0aGF0IHdhcyBub3QgdGhlIGNhc2UnKTtcbn1cbmlmICh2YWxpZEJyYWNlID09PSAyKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignUGFyc2VkIGEgYnJhY2VkIHF1YW50aWZpZXIgdGhhdCBjb250YWluZWQgYW4gaWxsZWdhbCByYW5nZSAobGVmdD5yaWdodCknKTtcbn1cbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIEVPRiB3aGlsZSBwYXJzaW5nIGN1cmx5IHF1YW50aWZpZXInKTtcbmlmICh3ZWJDb21wYXQgPT09IGZhbHNlKSB7XG5pZiAoKGNhY2hlID09PSAweDJjKSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ1RoZSBmaXJzdCBkaWdpdCBvZiBhIHJlZ2V4IGN1cmx5IHF1YW50aWZpZXIgaXMgbWFuZGF0b3J5Jyk7XG59XG5pZiAoKGNhY2hlID09PSAweDdkKSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0EgcmVnZXggY3VybHkgcXVhbnRpZmllciBoYWQgbm8gY29udGVudCcpO1xufVxucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0ZvdW5kIGFuIHVuZXNjYXBlZCBge2AgdGhhdCB3YXMgbm90IHRoZSBzdGFydCBvZiBhIHZhbGlkIHF1YW50aWZpZXInKTtcbn1cbmFmdGVyQXRvbSA9IHRydWU7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwodWZsYWdTdGF0dXMsICdGb3VuZCBhbiB1bmVzY2FwZWQgYHtgIHRoYXQgd2FzIG5vdCB0aGUgc3RhcnQgb2YgYSB2YWxpZCBxdWFudGlmaWVyJyk7XG5icmVhaztcbn1cbmNhc2UgMTM6XG57XG5za2lwKCk7XG5sZXQgcmVhc29uID0gJ0VuY291bnRlcmVkIHVuZXNjYXBlZCBjbG9zaW5nIGN1cmx5IGB9YCB3aGlsZSBub3QgcGFyc2luZyBhIHF1YW50aWZpZXInO1xuaWYgKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKHJlYXNvbik7XG59XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwodWZsYWdTdGF0dXMsIHJlYXNvbik7XG5hZnRlckF0b20gPSB0cnVlO1xuYnJlYWs7XG59XG5jYXNlIDE0Olxuc2tpcCgpO1xuYWZ0ZXJBdG9tID0gZmFsc2U7XG5icmVhaztcbmNhc2UgMTU6XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgZWFybHkgRU9GJyk7XG47XG59XG5pZiAocG9pbnRlciA+PSBsZW4pIGJyZWFrO1xuYyA9IGNhY2hlO1xufSB3aGlsZSAodHJ1ZSk7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRm91bmQgRU9GIGJlZm9yZSByZWdleCB3YXMgY2xvc2VkJyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4R3JvdXBOYW1lKGMsIHVmbGFnU3RhdHVzLCBmb3JDYXB0dXJpbmcpIHtcbmxldCByID0gX3BhcnNlUmVnZXhHcm91cE5hbWUoYywgdWZsYWdTdGF0dXMsIGZvckNhcHR1cmluZyk7XG5pZiAoIWZvdW5kSW52YWxpZEdyb3VwTmFtZSkgcmV0dXJuIHI7XG5pZiAoZm9yQ2FwdHVyaW5nID09PSB0cnVlKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignQW4gaW52YWxpZCBuYW1lIGZvciBhIGNhcHR1cmluZyBncm91cCBjYW4gbmV2ZXIgbGVhZCB0byBhIHZhbGlkIHJlZ2V4Jyk7XG59XG5rQ2hhckNsYXNzRXNjYXBlZCA9IHRydWU7XG5yZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9wYXJzZVJlZ2V4R3JvdXBOYW1lKGMsIHVmbGFnU3RhdHVzLCBmb3JDYXB0dXJpbmcpIHtcbmlmIChjID09PSAweDNlKSB7XG5mb3VuZEludmFsaWRHcm91cE5hbWUgPSB0cnVlO1xubGFzdENhbm9uaXplZElucHV0ID0gJyc7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSAwO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmVmZmVkR3JvdXBOYW1lcyArPSAnPD4sJztcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKHVmbGFnU3RhdHVzLCAnR3JvdXAgbmFtZSBpcyBub3Qgb3B0aW9uYWwgd2l0aG91dCB3ZWJjb21wYXQsIGZvdW5kIGVtcHR5IGA8PmAnKTtcbn1cbnJldHVybiByZWdleFN5bnRheEVycm9yKCdHcm91cCBuYW1lIGlzIG5vdCBvcHRpb25hbCwgZm91bmQgZW1wdHkgYDw+YCcpO1xufVxubGV0IHBvaW50ZXJTdGFydCA9IHBvaW50ZXI7XG5sYXN0Q2Fub25pemVkSW5wdXQgPSAnJztcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IDA7XG5sZXQgZmlyc3QgPSB0cnVlO1xubGV0IGxhc3RQb2ludGVyID0gMDtcbndoaWxlICgoKCgoYyAhPT0gMHgzZSkgJiYgKHVmbGFnU3RhdHVzICE9PSA0KSkpICYmIChsYXN0UG9pbnRlciAhPT0gcG9pbnRlcikpKSB7XG5sYXN0UG9pbnRlciA9IHBvaW50ZXI7XG5pZiAoYyA9PT0gMHg1Yykge1xudWZsYWdTdGF0dXMgPSBfcGFyc2VSZWdleEdyb3VwTmFtZUVzY2FwZShmaXJzdCwgdWZsYWdTdGF0dXMsIGZvckNhcHR1cmluZyk7XG59IGVsc2Uge1xudWZsYWdTdGF0dXMgPSBfcGFyc2VSZWdleEdyb3VwTmFtZUNoYXIoZmlyc3QsIGMsIHVmbGFnU3RhdHVzLCBmb3JDYXB0dXJpbmcpO1xufVxuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5mb3VuZEludmFsaWRHcm91cE5hbWUgPSB0cnVlO1xubGFzdENhbm9uaXplZElucHV0ID0gJyc7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSAwO1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ01pc3NpbmcgY2xvc2luZyBhbmdsZSBicmFja2V0IG9mIG5hbWUgb2YgY2FwdHVyaW5nIGdyb3VwJyk7XG59XG5jID0gY2FjaGU7XG5maXJzdCA9IGZhbHNlO1xufVxuaWYgKHVmbGFnU3RhdHVzID09PSA0KSB7XG5mb3VuZEludmFsaWRHcm91cE5hbWUgPSB0cnVlO1xubGFzdENhbm9uaXplZElucHV0ID0gJyc7XG5sYXN0Q2Fub25pemVkSW5wdXRMZW4gPSAwO1xucmV0dXJuIDQ7XG59XG5pZiAobGFzdFBvaW50ZXIgPT09IHBvaW50ZXIpIHtcbmZvdW5kSW52YWxpZEdyb3VwTmFtZSA9IHRydWU7XG5sYXN0Q2Fub25pemVkSW5wdXQgPSAnJztcbmxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IDA7XG5yZXR1cm4gMjtcbn1cbmxhc3RDYW5vbml6ZWRJbnB1dExlbiA9IGxhc3RDYW5vbml6ZWRJbnB1dC5sZW5ndGg7XG5za2lwKCk7XG5pZiAobGFzdENhbm9uaXplZElucHV0TGVuID4gMCkge1xubGV0IG5leHQgPSBsYXN0Q2Fub25pemVkSW5wdXQgKyAnLCc7XG5pZiAoZm9yQ2FwdHVyaW5nID09PSB0cnVlKSB7XG5pZiAoZGVjbGFyZWRHcm91cE5hbWVzLmluY2x1ZGVzKCcsJyArIG5leHQpKSB7XG5USFJPVygoJ1RoaXMgZ3JvdXAgbmFtZSAoYCcgKyBsYXN0Q2Fub25pemVkSW5wdXQpICsgJ2ApIHdhcyBhbHJlYWR5IHVzZWQgYmVmb3JlJywgcG9pbnRlclN0YXJ0LCBwb2ludGVyIC0gMSk7XG59XG5kZWNsYXJlZEdyb3VwTmFtZXMgKz0gbmV4dDtcbn0gZWxzZSB7XG5yZWZmZWRHcm91cE5hbWVzICs9IG5leHQ7XG59XG59XG5yZXR1cm4gdWZsYWdTdGF0dXM7XG59XG5mdW5jdGlvbiBfcGFyc2VSZWdleEdyb3VwTmFtZUNoYXIoc3RhcnQsIGMsIHVmbGFnU3RhdHVzLCBmb3JDYXB0dXJpbmcpIHtcbmxldCB3aWRlID0gKHN0YXJ0PyBpc0lkZW50U3RhcnQoYywgcG9pbnRlcikgOiBpc0lkZW50UmVzdENocihjLCBwb2ludGVyKSk7XG5pZiAod2lkZSA9PT0gKC0yKSkge1xuc2tpcCgpO1xubGFzdENhbm9uaXplZElucHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG5yZXR1cm4gdWZsYWdTdGF0dXM7XG59XG5pZiAod2lkZSA9PT0gKC0xKSkge1xuZm91bmRJbnZhbGlkR3JvdXBOYW1lID0gdHJ1ZTtcbmlmICgoKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHx8IChmb3JDYXB0dXJpbmcgPT09IHRydWUpKSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoKCdUcmllZCB0byBwYXJzZSB0aGUgbmFtZSBmb3IgYSBjYXB0dXJpbmcgZ3JvdXAgYnV0IGl0IGNvbnRhaW5lZCBhdCBsZWFzdCBvbmUgaW52YWxpZCBpZGVudCBjaGFyIChgJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpICsgJ2ApJyk7XG59XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCh1ZmxhZ1N0YXR1cywgKCdUcmllZCB0byBwYXJzZSB0aGUgbmFtZSBmb3IgYSBjYXB0dXJpbmcgZ3JvdXAgYnV0IGl0IGNvbnRhaW5lZCBhdCBsZWFzdCBvbmUgaW52YWxpZCBpZGVudCBjaGFyIChgJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpICsgJ2ApJyk7XG59XG5za2lwRmFzdFdpdGhvdXRVcGRhdGluZ0NhY2hlKCk7XG5za2lwKCk7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYyk7XG5pZiAoZm9yQ2FwdHVyaW5nID09PSB0cnVlKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzTWFuZGF0b3J5KHVmbGFnU3RhdHVzLCAnVGhlIHN0YXJ0IG9mIHRoZSBuYW1lIG9mIGEgY2FwdHVyaW5nIGdyb3VwIGhhZCBhIHN1cnJvZ2F0ZSBwYWlyIGFuZCBpcyB0aGVyZWZvciBvbmx5IHZhbGlkIHdpdGggdS1mbGFnJyk7XG59XG5pZiAod2ViQ29tcGF0ID09PSBmYWxzZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeSh1ZmxhZ1N0YXR1cywgJ1RoZSBzdGFydCBvZiBhIGBcXFxca2AgZ3JvdXAgbmFtZSBoYWQgYSBzdXJyb2dhdGUgcGFpciBhbmQgaXMgdGhlcmVmb3Igb25seSB2YWxpZCB3aXRoIHUtZmxhZycpO1xufVxucmV0dXJuIHVmbGFnU3RhdHVzO1xufVxuZnVuY3Rpb24gX3BhcnNlUmVnZXhHcm91cE5hbWVFc2NhcGUoc3RhcnQsIHVmbGFnU3RhdHVzLCBmb3JDYXB0dXJpbmcpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikge1xuZm91bmRJbnZhbGlkR3JvdXBOYW1lID0gdHJ1ZTtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdGb3VuZCBFT0YgYXQgc3RhcnQgb2YgYSBncm91cCBuYW1lIGlkZW50aWZpZXInKTtcbn1cbmlmICghKGNhY2hlID09PSAweDc1KSkge1xuZm91bmRJbnZhbGlkR3JvdXBOYW1lID0gdHJ1ZTtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdGb3VuZCBpbnZhbGlkIGVzY2FwZSBjaGFyYWN0ZXIgYXQgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAgbmFtZSBpZGVudGlmaWVyJyk7XG59XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICdVbmV4cGVjdGVkIEVPRiB3aGlsZSBwYXJzaW5nIHVuaWNvZGUgZXNjYXBlJyk7XG59XG5sZXQgYyA9IGNhY2hlO1xuaWYgKGMgPT09IDB4N2IpIHtcbmMgPSBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlKCk7XG51ZmxhZ1N0YXR1cyA9IHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeSgwLCAnRm91bmQgYSB1bmljb2RlIHJ1YnkgZXNjYXBlIHdoaWNoIGlzIG9ubHkgdmFsaWQgd2l0aCB1LWZsYWcnKTtcbn0gZWxzZSB7XG5jID0gcGFyc2VVbmljb2RlUXVhZEVzY2FwZShjLCBmYWxzZSk7XG5pZiAoKChjID4gMHhmZmZmKSAmJiAoZm9yQ2FwdHVyaW5nID09PSB0cnVlKSkpIHtcbnVmbGFnU3RhdHVzID0gdXBkYXRlUmVnZXhVZmxhZ0lzTWFuZGF0b3J5KHVmbGFnU3RhdHVzLCAnVGhlIG5hbWUgb2YgYSBjYXB0dXJpbmcgZ3JvdXAgY29udGFpbmVkIGEgZG91YmxlIHVuaWNvZGUgcXVhZCBlc2NhcGUgd2hpY2ggaXMgdmFsaWQgYXMgYSBzdXJyb2dhdGUgcGFpciB3aGljaCByZXF1aXJlcyB1LWZsYWcgYW5kIHdoaWNoIGNhbm5vdCBiZSBtYWRlIHZhbGlkIHdpdGhvdXQgdS1mbGFnJyk7XG59XG59XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbmZvdW5kSW52YWxpZEdyb3VwTmFtZSA9IHRydWU7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRWFybHkgRU9GIHdoaWxlIHBhcnNpbmcgYSBncm91cCBuYW1lJyk7XG59XG5pZiAoYyA9PT0gMHgxMTAwMDApIHtcbmZvdW5kSW52YWxpZEdyb3VwTmFtZSA9IHRydWU7XG5pZiAoKCh3ZWJDb21wYXQgPT09IGZhbHNlKSB8fCAoZm9yQ2FwdHVyaW5nID09PSB0cnVlKSkpIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdSZWdleCBjb250YWluZWQgYSBncm91cCBuYW1lIHdpdGggaW52YWxpZCB1bmljb2RlIGVzY2FwZScpO1xufVxucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwodWZsYWdTdGF0dXMsICdUaGUgbmFtZSBvZiBhIGBcXFxca2AgZXNjYXBlIGNvbnRhaW5lZCBhIGJyb2tlbiB1bmljb2RlIHJ1YnkgZXNjYXBlIGFuZCB0aGlzIGNhbiBub3QgbGVhZCB0byBhIHZhbGlkIHJlZ2V4IHdpdGggdS1mbGFnJyk7XG59XG5sZXQgZmlyc3RDaGFyU3RyID0gdG9TdHJpbmdFeHBlbnNpdmUoYyk7XG5sYXN0Q2Fub25pemVkSW5wdXQgKz0gZmlyc3RDaGFyU3RyO1xubGV0IHdpZGUgPSAoc3RhcnQ/IGlzSWRlbnRTdGFydChjLCAtMSkgOiBpc0lkZW50UmVzdENocihjLCAtMSkpO1xuaWYgKHdpZGUgPT09ICgtMikpIHtcbnJldHVybiB1ZmxhZ1N0YXR1cztcbn1cbmlmICh3aWRlID09PSAoLTMpKSB7XG5pZiAoZm9yQ2FwdHVyaW5nID09PSB0cnVlKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzTWFuZGF0b3J5KHVmbGFnU3RhdHVzLCAnRm91bmQgYSBjb2RlcG9pbnQgaW4gYSBjYXB0dXJpbmcgZ3JvdXAgbmFtZSB0aGF0IHJlcXVpcmVzIHRoZSB1LWZsYWcgdG8gYmUgY29uc2lkZXJlZCB2YWxpZCcpO1xufVxuaWYgKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHtcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNNYW5kYXRvcnkodWZsYWdTdGF0dXMsICdGb3VuZCBhIGNvZGVwb2ludCBpbiBhIGBcXFxca2AgZXNjYXBlIGdyb3VwIG5hbWUgdGhhdCByZXF1aXJlcyB0aGUgdS1mbGFnIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQnKTtcbn1cbnJldHVybiB1ZmxhZ1N0YXR1cztcbn1cbmlmIChmb3JDYXB0dXJpbmcgPT09IHRydWUpIHtcbmZvdW5kSW52YWxpZEdyb3VwTmFtZSA9IHRydWU7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgaW52YWxpZCB1bmljb2RlIGVzY2FwZSBpbnNpZGUgdGhlIGdyb3VwIG5hbWUgb2YgYSBjYXB0dXJpbmcgZ3JvdXAsIHRoaXMgY2Fubm90IGJlIHZhbGlkJyk7XG59XG5pZiAod2ViQ29tcGF0ID09PSBmYWxzZSkge1xuZm91bmRJbnZhbGlkR3JvdXBOYW1lID0gdHJ1ZTtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdFbmNvdW50ZXJlZCBpbnZhbGlkIHVuaWNvZGUgZXNjYXBlIGluc2lkZSB0aGUgZ3JvdXAgbmFtZSBvZiBhIGBcXFxca2AgZXNjYXBlLCB0aGlzIGNhbiBub3QgYmVjb21lIHZhbGlkIHdpdGhvdXQgd2ViIGNvbXBhdCBtb2RlJyk7XG59XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCh1ZmxhZ1N0YXR1cywgJ0VuY291bnRlcmVkIGludmFsaWQgdW5pY29kZSBlc2NhcGUgaW5zaWRlIHRoZSBncm91cCBuYW1lIG9mIGEgYFxcXFxrYCBlc2NhcGUsIHRoaXMgaXMgaW52YWxpZCB3aXRoIHUtZmxhZycpO1xufVxuZnVuY3Rpb24gcGFyc2VFc2NhcGVGb3JSZWdleEF0b20oYykge1xubGV0IHMgPSAoKGMgPiAweDdlKT8gNCA6IHJlZ2V4QXRvbUVzY2FwZVN0YXJ0SnVtcFRhYmxlW2NdKTtcbnN3aXRjaCAocykge1xuY2FzZSAwOlxuc2tpcCgpO1xucmV0dXJuIDA7XG5jYXNlIDI6XG5za2lwKCk7XG5yZXR1cm4gcGFyc2VVbmljb2RlRXNjYXBlRm9yUmVnZXhBdG9tKCk7XG5jYXNlIDM6XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdFbmNvdW50ZXJlZCBlYXJseSBFT0Ygd2hpbGUgcGFyc2luZyBoZXggZXNjYXBlJyk7XG59XG5sZXQgYSA9IGNhY2hlO1xubGV0IHZhID0gZ2V0SGV4VmFsdWUoYSk7XG5pZiAodmEgPT09IDE2KSB7XG5sZXQgcmVhc29uID0gJ0ZpcnN0IGNoYXIgb2YgaGV4IGVzY2FwZSBub3QgYSB2YWxpZCBkaWdpdCc7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCByZWFzb24pO1xufVxucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IocmVhc29uKTtcbn1cbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIGVhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGhleCBlc2NhcGUnKTtcbn1cbmxldCBiID0gY2FjaGU7XG5sZXQgdmIgPSBnZXRIZXhWYWx1ZShiKTtcbmlmICh2YiA9PT0gMTYpIHtcbmxldCByZWFzb24gPSAnU2Vjb25kIGNoYXIgb2YgaGV4IGVzY2FwZSBub3QgYSB2YWxpZCBkaWdpdCc7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCByZWFzb24pO1xufVxucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IocmVhc29uKTtcbn1cbnNraXAoKTtcbnJldHVybiAwO1xuY2FzZSAxOlxuc2tpcCgpO1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ0F0b21zIGNhbiBvbmx5IGVzY2FwZSBjZXJ0YWluIG5vbi1zcGVjaWFsIGNoYXJzIHdpdGhvdXQgdS1mbGFnJyk7XG5jYXNlIDQ6XG5sZXQgd2lkZSA9IGlzSWRlbnRSZXN0Q2hyKGMsIHBvaW50ZXIpO1xuaWYgKHdpZGUgPT09ICgtMykpIHtcbmMgPSBpbnB1dC5jb2RlUG9pbnRBdChwb2ludGVyKTtcbnNraXBGYXN0V2l0aG91dFVwZGF0aW5nQ2FjaGUoKTtcbnNraXAoKTtcbmlmICh3ZWJDb21wYXQgPT09IGZhbHNlKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcigoKCgnQ2Fubm90IHVzZSBhIHN1cnJvZ2F0ZSBwYWlyIGFzIGF0b20gZXNjYXBlICgnICsgYykgKyAnLCBgJykgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChjKSkgKyAnYCknKTtcbn1cbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICdBdG9tIGVzY2FwZSBjYW4gb25seSBlc2NhcGUgY2VydGFpbiBzeW50YXggY2hhcnMgd2l0aCB1LWZsYWcnKTtcbn1cbmlmICh3aWRlID09PSAoLTIpKSB7XG5za2lwKCk7XG5pZiAod2ViQ29tcGF0ID09PSBmYWxzZSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoKCgoJ0Nhbm5vdCBlc2NhcGUgdGhpcyByZWd1bGFyIGlkZW50aWZpZXIgY2hhcmFjdGVyIFtvcmQ9JyArIGMpICsgJ11bJykgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKSArICddJyk7XG59XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCAnQXRvbSBlc2NhcGUgY2FuIG9ubHkgZXNjYXBlIGNlcnRhaW4gc3ludGF4IGNoYXJzIHdpdGggdS1mbGFnJyk7XG59XG47XG5za2lwKCk7XG5pZiAoKChjID09PSAweDIwMjgpIHx8IChjID09PSAweDIwMjkpKSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ1JlZ3VsYXIgZXhwcmVzc2lvbnMgZG8gbm90IHN1cHBvcnQgbGluZSBjb250aW51YXRpb25zIChlc2NhcGVkIG5ld2xpbmUpJyk7XG59XG5pZiAod2ViQ29tcGF0ID09PSBmYWxzZSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoKCgoJ0Nhbm5vdCBlc2NhcGUgdGhpcyBub24taWRlbnRpZmllciBjaGFyYWN0ZXIgW29yZD0nICsgYykgKyAnXVsnKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpICsgJ10nKTtcbn1cbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICdBdG9tIGVzY2FwZSBjYW4gb25seSBlc2NhcGUgY2VydGFpbiBzeW50YXggY2hhcnMgd2l0aCB1LWZsYWcnKTtcbmNhc2UgNTpcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIGVhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGNoYXIgZXNjYXBlJyk7XG59XG5sZXQgZCA9IGNhY2hlO1xuaWYgKGlzQXNjaWlMZXR0ZXIoZCkpIHtcbnNraXAoKTtcbnJldHVybiAwO1xufVxubGV0IHJlYXNvbiA9ICgnSWxsZWdhbCBjaGFyIGVzY2FwZSBjaGFyIChvcmQ9JyArIGQpICsgJyknO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgcmVhc29uKTtcbn1cbnJldHVybiByZWdleFN5bnRheEVycm9yKHJlYXNvbik7XG5jYXNlIDY6XG5jb25zdCBGUk9NX0FUT00gPSBmYWxzZTtcbnJldHVybiBwYXJzZVJlZ2V4UHJvcGVydHlFc2NhcGUoYywgRlJPTV9BVE9NKTtcbmNhc2UgNzpcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDA7XG5pZiAoaXNBc2NpaU51bWJlcihjYWNoZSkpIHtcbmxldCByZWFzb24gPSAnQmFjayByZWZlcmVuY2VzIGNhbiBub3QgaGF2ZSBtb3JlIHR3byBvciBtb3JlIGNvbnNlY3V0aXZlIG51bWJlcnMnO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgcmVhc29uKTtcbn0gZWxzZSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcihyZWFzb24pO1xufVxufVxucmV0dXJuIDA7XG5jYXNlIDg6XG5yZXR1cm4gcGFyc2VSZWdleERlY2ltYWxFc2NhcGUoYyk7XG5jYXNlIDk6XG57XG5sZXQgdWZsYWdTdGF0dXMgPSAwO1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRWFybHkgRU9GIHdoaWxlIHBhcnNpbmcgYFxcXFxrYCBlc2NhcGUgaW4gcmVnZXggY2hhcmFjdGVyIGNsYXNzJyk7XG5jID0gY2FjaGU7XG5pZiAoYyAhPT0gMHgzYykge1xua0NoYXJDbGFzc0VzY2FwZWQgPSB0cnVlO1xubGV0IHJlYXNvbiA9ICdOYW1lZCBiYWNrIHJlZmVyZW5jZSBcXFxcazsgbWlzc2luZyBncm91cCBuYW1lJztcbmlmICh3ZWJDb21wYXQgPT09IGZhbHNlKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcihyZWFzb24sIGMpO1xufVxucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgcmVhc29uKTtcbn1cbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0Vhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGBcXFxca2AgZXNjYXBlIGluIHJlZ2V4IGNoYXJhY3RlciBjbGFzcycpO1xuYyA9IGNhY2hlO1xudWZsYWdTdGF0dXMgPSBwYXJzZVJlZ2V4R3JvdXBOYW1lKGMsIHVmbGFnU3RhdHVzLCBmYWxzZSk7XG5yZXR1cm4gdWZsYWdTdGF0dXM7XG59XG5jYXNlIDEwOlxuc2tpcCgpO1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ1JlZ3VsYXIgZXhwcmVzc2lvbnMgZG8gbm90IHN1cHBvcnQgbGluZSBjb250aW51YXRpb25zIChlc2NhcGVkIG5ld2xpbmUpJyk7XG5jYXNlIDExOlxuc2tpcCgpO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ0F0b20gZXNjYXBlIGNhbiBvbmx5IGVzY2FwZSBjZXJ0YWluIGxldHRlcnMgd2l0aG91dCB1LWZsYWcnKTtcbn1cbnJldHVybiByZWdleFN5bnRheEVycm9yKCgnQ2Fubm90IGVzY2FwZSB0aGlzIGxldHRlciBbJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpICsgJ10nKTtcbjtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhEZWNpbWFsRXNjYXBlKGMpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0Vhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGRlY2ltYWwgZXNjYXBlIGluIHJlZ2V4Jyk7XG5sZXQgZCA9IGNhY2hlO1xuaWYgKCgoZCA+PSAweDMwKSAmJiAoZCA8PSAweDM5KSkpIHtcbnNraXAoKTtcbmxldCBlID0gY2FjaGU7XG5pZiAoKChlID49IDB4MzApICYmIChlIDw9IDB4MzkpKSkge1xubGV0IHJlYXNvbiA9ICdQYXJzZWQgdG9vIG1hbnkgZGlnaXRzJztcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsIHJlYXNvbik7XG59IGVsc2Uge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IocmVhc29uKTtcbn1cbn0gZWxzZSB7XG5sYXJnZXN0QmFja1JlZmVyZW5jZSA9IE1hdGgubWF4KCgoYyAtIDB4MzApICogMTApICsgKGQgLSAweDMwKSk7XG59XG59IGVsc2Uge1xubGFyZ2VzdEJhY2tSZWZlcmVuY2UgPSBNYXRoLm1heChsYXJnZXN0QmFja1JlZmVyZW5jZSwgYyAtIDB4MzApO1xufVxucmV0dXJuIDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4Q2hhckNsYXNzKCkge1xuc2tpcCgpO1xubGV0IHByZXYgPSAwO1xubGV0IHN1cnJvZ2F0ZSA9IDA7XG5sZXQgaXNTdXJyb2dhdGUgPSBmYWxzZTtcbmxldCBpc1N1cnJvZ2F0ZUhlYWQgPSBmYWxzZTtcbmxldCB3YXNTdXJyb2dhdGUgPSB0cnVlO1xubGV0IHdhc1N1cnJvZ2F0ZUhlYWQgPSBmYWxzZTtcbmxldCB1cmFuZ2VPcGVuID0gZmFsc2U7XG5sZXQgdXJhbmdlTGVmdCA9IC0xO1xubGV0IG5yYW5nZU9wZW4gPSBmYWxzZTtcbmxldCBucmFuZ2VMZWZ0ID0gLTE7XG5sZXQgZmxhZ1N0YXRlID0gMDtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIGVhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGNoYXIgY2xhc3MgKDEpJyk7XG5sZXQgYyA9IGNhY2hlO1xuaWYgKGMgPT09IDB4NWUpIHtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0VuY291bnRlcmVkIGVhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGNoYXIgY2xhc3MgKDIpJyk7XG5jID0gY2FjaGU7XG59XG53aGlsZSAoYyAhPT0gMHg1ZCkge1xubGV0IHdhc0VzY2FwZSA9IGZhbHNlO1xubGV0IHdhc0RvdWJsZVF1YWQgPSBmYWxzZTtcbmxldCB3YXNCYWRVbmlFc2NhcGUgPSBmYWxzZTtcbmxldCB3YXNQcm9wRXNjYXBlID0gZmFsc2U7XG5sZXQgd2FzUHJvcE9ubHkgPSBmYWxzZTtcbmxldCB3YXNCYWRQcm9wRXNjYXBlID0gZmFsc2U7XG5sZXQgd2FzUnVieVdlYkVzY2FwZSA9IGZhbHNlO1xubGV0IGVzY2FwZUNoYXJVUCA9IDA7XG5pZiAoYyA9PT0gMHg1Yykge1xuc2tpcCgpO1xud2FzRXNjYXBlID0gdHJ1ZTtcbmlmIChwb2ludGVyID49IGxlbikge1xucmVnZXhTeW50YXhFcnJvcignRWFybHkgRU9GIGFmdGVyIGJhY2tzbGFzaCBpbiBjaGFyIGNsYXNzJyk7XG5yZXR1cm4gMHgxMTAwMDA7XG59XG5jID0gY2FjaGU7XG5lc2NhcGVDaGFyVVAgPSBjO1xubGV0IGVzY2FwZVBvaW50ZXIgPSBwb2ludGVyO1xuYyA9IHBhcnNlUmVnZXhDaGFyQ2xhc3NFc2NhcGUoYyk7XG5pZiAoZXNjYXBlQ2hhclVQID09PSAweDc1KSB7XG5pZiAoYyA9PT0gMHgxMTAwMDApIHtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDB4MTEwMDAwO1xuaWYgKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHJldHVybiAweDExMDAwMDtcbndhc0JhZFVuaUVzY2FwZSA9IHRydWU7XG5mbGFnU3RhdGUgPSB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKGZsYWdTdGF0ZSwgJ0EgYnJva2VuIGBcXFxcdWAgZXNjYXBlIGNhbiBuZXZlciBiZSB2YWxpZCB3aXRoIHUtZmxhZycpO1xud2FzUHJvcE9ubHkgPSAocG9pbnRlciAtIGVzY2FwZVBvaW50ZXIpID09PSAxO1xufSBlbHNlIGlmICgoYyAmIDY3MTA4ODY0KSA+IDApIHtcbmMgXj0gNjcxMDg4NjQ7XG53YXNSdWJ5V2ViRXNjYXBlID0gd2ViQ29tcGF0ID09PSB0cnVlO1xufSBlbHNlIGlmIChjID4gMHhmZmZmKSB7XG53YXNEb3VibGVRdWFkID0gdHJ1ZTtcbn1cbn0gZWxzZSBpZiAoKChlc2NhcGVDaGFyVVAgPT09IDB4NzApIHx8IChlc2NhcGVDaGFyVVAgPT09IDB4NTApKSkge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xuaWYgKCgoKChjID09PSAweDExMDAwMCkgfHwgKGMgPT09IDM0NjY4NTQ0KSkpIHx8ICgoYyAmIDE2Nzc3MjE2KSA9PT0gMTY3NzcyMTYpKSkge1xud2FzQmFkUHJvcEVzY2FwZSA9IHRydWU7XG59IGVsc2Uge1xud2FzUHJvcEVzY2FwZSA9IHRydWU7XG53YXNQcm9wT25seSA9IChwb2ludGVyIC0gZXNjYXBlUG9pbnRlcikgPT09IDE7XG59XG59XG59XG5pZiAoYyA9PT0gMHgxMTAwMDApIHtcbmlmICghd2FzQmFkVW5pRXNjYXBlKSB7XG5mbGFnU3RhdGUgPSByZWdleFN5bnRheEVycm9yKGxhc3RQb3RlbnRpYWxSZWdleEVycm9yKTtcbn1cbn0gZWxzZSBpZiAoYyA9PT0gMzQ2Njg1NDQpIHtcbmZsYWdTdGF0ZSA9IHJlZ2V4U3ludGF4RXJyb3IobGFzdFBvdGVudGlhbFJlZ2V4RXJyb3IpO1xuYyA9IDMzNTU0NDMyO1xufSBlbHNlIGlmIChjID09PSAzMzU1NDQzMikge1xuXG59IGVsc2UgaWYgKGMgPT09IDB4MTEwMDAxKSB7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5mbGFnU3RhdGUgPSB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICdDaGFyIGNsYXNzIGNhbiBub3QgY29udGFpbiBgXFxcXEJgJyk7XG59IGVsc2Uge1xuZmxhZ1N0YXRlID0gcmVnZXhTeW50YXhFcnJvcignQ2hhciBjbGFzcyBjYW4gbm90IGNvbnRhaW4gYFxcXFxCYCcpO1xufVxuYyA9IDB4NDI7XG59IGVsc2UgaWYgKGMgPT09IDB4MTEwMDAyKSB7XG5mbGFnU3RhdGUgPSB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKGZsYWdTdGF0ZSwgbGFzdFBvdGVudGlhbFJlZ2V4RXJyb3IpO1xuYyA9IDB4NWM7XG59IGVsc2Uge1xuaWYgKGMgJiAxNjc3NzIxNikge1xuYyA9IGMgXiAxNjc3NzIxNjtcbmZsYWdTdGF0ZSA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoZmxhZ1N0YXRlLCBsYXN0UG90ZW50aWFsUmVnZXhFcnJvcik7XG59XG5pZiAoYyAmIDgzODg2MDgpIHtcbmMgPSBjIF4gODM4ODYwODtcbmZsYWdTdGF0ZSA9IHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeShmbGFnU3RhdGUsIGxhc3RQb3RlbnRpYWxSZWdleEVycm9yKTtcbn1cbn1cbn0gZWxzZSBpZiAoKCgoKCgoYyA9PT0gMHgwRCkgfHwgKGMgPT09IDB4MEEpKSkgfHwgKGMgPT09IDB4MjAyOCkpKSB8fCAoYyA9PT0gMHgyMDI5KSkpIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdFbmNvdW50ZXJlZCBuZXdsaW5lJyk7XG59IGVsc2Uge1xuc2tpcCgpO1xufVxuaWYgKHdhc0JhZFVuaUVzY2FwZSkge1xuXG59IGVsc2UgaWYgKHdhc0VzY2FwZSkge1xuaXNTdXJyb2dhdGUgPSBjID4gMHhmZmZmO1xuaWYgKGlzU3Vycm9nYXRlKSBzdXJyb2dhdGUgPSBjO1xuaXNTdXJyb2dhdGVIZWFkID0gZmFsc2U7XG59IGVsc2UgaWYgKCh3YXNTdXJyb2dhdGVIZWFkICYmIGlzU3Vycm9nYXRlVGFpbChjKSkpIHtcbmlzU3Vycm9nYXRlID0gdHJ1ZTtcbmlzU3Vycm9nYXRlSGVhZCA9IGZhbHNlO1xuc3Vycm9nYXRlID0gZ2V0U3Vycm9nYXRlKHByZXYsIGMpO1xufSBlbHNlIHtcbmlzU3Vycm9nYXRlID0gZmFsc2U7XG5pc1N1cnJvZ2F0ZUhlYWQgPSBpc1N1cnJvZ2F0ZUxlYWQoYyk7XG59XG5pZiAodXJhbmdlT3Blbikge1xubGV0IHVyYW5nZVJpZ2h0ID0gKGlzU3Vycm9nYXRlPyBzdXJyb2dhdGUgOiAoKHdhc1N1cnJvZ2F0ZUhlYWQ/IHByZXYgOiBjKSkpO1xuaWYgKCgodXJhbmdlTGVmdCA9PT0gMzM1NTQ0MzIpIHx8ICh1cmFuZ2VSaWdodCA9PT0gMzM1NTQ0MzIpKSkge1xuZmxhZ1N0YXRlID0gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbChmbGFnU3RhdGUsICdDaGFyYWN0ZXIgY2xhc3MgZXNjYXBlcyBgXFxcXGQgXFxcXEQgXFxcXHMgXFxcXFMgXFxcXHcgXFxcXFcgXFxcXHAgXFxcXFBgIG5vdCBhbGxvd2VkIGluIHJhbmdlcyB3aXRoIHUnKTtcbn0gZWxzZSBpZiAoKCghaXNTdXJyb2dhdGVIZWFkKSB8fCB3YXNTdXJyb2dhdGVIZWFkKSkge1xudXJhbmdlT3BlbiA9IGZhbHNlO1xuaWYgKHVyYW5nZUxlZnQgPiB1cmFuZ2VSaWdodCkge1xuZmxhZ1N0YXRlID0gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbChmbGFnU3RhdGUsICgoKCgoKCgnRW5jb3VudGVyZWQgaW5jb3JyZWN0IHJhbmdlIChsZWZ0PnJpZ2h0LCAnICsgdXJhbmdlTGVmdCkgKyAnID4gJykgKyB1cmFuZ2VSaWdodCkgKyAnLCAweCcpICsgdXJhbmdlTGVmdC50b1N0cmluZygxNikpICsgJyA+IDB4JykgKyB1cmFuZ2VSaWdodC50b1N0cmluZygxNikpICsgJykgd2hpY2ggaXMgaWxsZWdhbCB3aXRoIHUtZmxhZycpO1xufVxudXJhbmdlTGVmdCA9IC0xO1xufSBlbHNlIHtcblxufVxufSBlbHNlIGlmICgoKCgoYyA9PT0gMHgyZCkgJiYgKCF3YXNFc2NhcGUpKSkgJiYgKHVyYW5nZUxlZnQgIT09ICgtMSkpKSkge1xudXJhbmdlT3BlbiA9IHRydWU7XG59IGVsc2Uge1xudXJhbmdlTGVmdCA9IChpc1N1cnJvZ2F0ZT8gc3Vycm9nYXRlIDogYyk7XG59XG5sZXQgY1RtcCA9ICgoKHdhc1J1YnlXZWJFc2NhcGUgfHwgd2FzUHJvcEVzY2FwZSkpPyBlc2NhcGVDaGFyVVAgOiBjKTtcbmxldCBjVGFpbCA9IGM7XG5sZXQgc3RpbGxEYXRhTGVmdCA9IHRydWU7XG5sZXQgcnVieUhhY2tMaHMgPSAoKCh3YXNSdWJ5V2ViRXNjYXBlIHx8IHdhc0JhZFVuaUVzY2FwZSkpIHx8IHdhc1Byb3BFc2NhcGUpO1xubGV0IHJ1YnlIYWNrUmhzUGVlayA9ICh3YXNCYWRVbmlFc2NhcGUgfHwgKCh3YXNCYWRQcm9wRXNjYXBlICYmICghd2FzUHJvcE9ubHkpKSkpO1xubGV0IHJ1YnlIYWNrUmhzQ3VybHkgPSAod2FzUnVieVdlYkVzY2FwZSB8fCAoKHdhc1Byb3BFc2NhcGUgJiYgKCF3YXNQcm9wT25seSkpKSk7XG53aGlsZSAoc3RpbGxEYXRhTGVmdCkge1xuaWYgKHdhc0RvdWJsZVF1YWQpIHtcbndhc0RvdWJsZVF1YWQgPSBmYWxzZTtcbmNUYWlsID0gY29kZVBvaW50VG9TdXJyb2dhdGVUYWlsKGNUbXApO1xuY1RtcCA9IGNvZGVQb2ludFRvU3Vycm9nYXRlSGVhZChjVG1wKTtcbn0gZWxzZSBpZiAocnVieUhhY2tMaHMpIHtcbnJ1YnlIYWNrTGhzID0gZmFsc2U7XG5jVG1wID0gZXNjYXBlQ2hhclVQO1xuaWYgKHdhc1Byb3BPbmx5KSBzdGlsbERhdGFMZWZ0ID0gZmFsc2U7XG59IGVsc2UgaWYgKHJ1YnlIYWNrUmhzQ3VybHkpIHtcbnJ1YnlIYWNrUmhzQ3VybHkgPSBmYWxzZTtcbmNUbXAgPSAweDdkO1xuc3RpbGxEYXRhTGVmdCA9IGZhbHNlO1xufSBlbHNlIGlmIChydWJ5SGFja1Joc1BlZWspIHtcbmNUbXAgPSBwZWVrZCgtMSk7XG5ydWJ5SGFja1Joc1BlZWsgPSBmYWxzZTtcbnN0aWxsRGF0YUxlZnQgPSBmYWxzZTtcbn0gZWxzZSB7XG5zdGlsbERhdGFMZWZ0ID0gZmFsc2U7XG5jVG1wID0gY1RhaWw7XG59XG5pZiAobnJhbmdlT3Blbikge1xuY29uc3QgbnJhbmdlUmlnaHQgPSBjVG1wO1xuaWYgKCgobnJhbmdlTGVmdCA9PT0gMzM1NTQ0MzIpIHx8IChucmFuZ2VSaWdodCA9PT0gMzM1NTQ0MzIpKSkge1xuaWYgKHdlYkNvbXBhdCA9PT0gZmFsc2UpIHtcbmZsYWdTdGF0ZSA9IHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeShmbGFnU3RhdGUsICdDaGFyYWN0ZXIgY2xhc3MgZXNjYXBlcyBgXFxcXGQgXFxcXEQgXFxcXHMgXFxcXFMgXFxcXHcgXFxcXFcgXFxcXHAgXFxcXFBgIG5vdCBhbGxvd2VkIGluIHJhbmdlcycpO1xufVxufSBlbHNlIHtcbmlmIChucmFuZ2VMZWZ0ID4gbnJhbmdlUmlnaHQpIHtcbmZsYWdTdGF0ZSA9IHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeShmbGFnU3RhdGUsICgoKCgoKCgnRW5jb3VudGVyZWQgaW5jb3JyZWN0IHJhbmdlIChsZWZ0PnJpZ2h0LCAnICsgbnJhbmdlTGVmdCkgKyAnID4gJykgKyBucmFuZ2VSaWdodCkgKyAnLCAweCcpICsgbnJhbmdlTGVmdC50b1N0cmluZygxNikpICsgJyA+IDB4JykgKyBucmFuZ2VSaWdodC50b1N0cmluZygxNikpICsgJykgd2hlbiBwYXJzaW5nIGFzIGlmIHdpdGhvdXQgdS1mbGFnJyk7XG59XG59XG5ucmFuZ2VMZWZ0ID0gLTE7XG5ucmFuZ2VPcGVuID0gZmFsc2U7XG59IGVsc2UgaWYgKCgoKChjVG1wID09PSAweDJkKSAmJiAoIXdhc0VzY2FwZSkpKSAmJiAobnJhbmdlTGVmdCAhPT0gKC0xKSkpKSB7XG5ucmFuZ2VPcGVuID0gdHJ1ZTtcbn0gZWxzZSB7XG5ucmFuZ2VMZWZ0ID0gY1RtcDtcbn1cbn1cbndhc1N1cnJvZ2F0ZSA9IGlzU3Vycm9nYXRlO1xud2FzU3Vycm9nYXRlSGVhZCA9IGlzU3Vycm9nYXRlSGVhZDtcbnByZXYgPSBjO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignVW5leHBlY3RlZCBlYXJseSBFT0Ygd2hpbGUgcGFyc2luZyBjaGFyYWN0ZXIgY2xhc3MnKTtcbn1cbmMgPSBjYWNoZTtcbn1cbnNraXAoKTtcbmlmICgodXJhbmdlT3BlbiAmJiB3YXNTdXJyb2dhdGVIZWFkKSkge1xuaWYgKCgodXJhbmdlTGVmdCA9PT0gMzM1NTQ0MzIpIHx8IChwcmV2ID09PSAzMzU1NDQzMikpKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbChmbGFnU3RhdGUsICdDaGFyYWN0ZXIgY2xhc3MgZXNjYXBlcyBgXFxcXGQgXFxcXEQgXFxcXHMgXFxcXFMgXFxcXHcgXFxcXFcgXFxcXHAgXFxcXFBgIGFyZSBvbmx5IG9rIGFzIGEgcmFuZ2Ugd2l0aCB3ZWJjb21wYXQsIHdpdGhvdXQgdWZsYWcnKTtcbn1cbmlmICh1cmFuZ2VMZWZ0ID4gcHJldikge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoZmxhZ1N0YXRlLCAoKCgoKCgoJ0VuY291bnRlcmVkIGluY29ycmVjdCByYW5nZSBlbmQgKGxlZnQ+cmlnaHQsICcgKyB1cmFuZ2VMZWZ0KSArICcgPiAnKSArIHByZXYpICsgJywgMHgnKSArIHVyYW5nZUxlZnQudG9TdHJpbmcoMTYpKSArICcgPiAweCcpICsgcHJldi50b1N0cmluZygxNikpICsgJykgd2hpY2ggaXMgaWxsZWdhbCB3aXRoIHUtZmxhZycpO1xufVxucmV0dXJuIGZsYWdTdGF0ZTtcbn1cbnJldHVybiBmbGFnU3RhdGU7XG59XG5mdW5jdGlvbiBzdXJyb2dhdGVUb0NvZGVwb2ludChoZWFkLCB0YWlsKSB7XG5yZXR1cm4gKCgoaGVhZCAmIDB4M2ZmKSA8PCAxMCkgfCAodGFpbCAmIDB4M2ZmKSkgKyAweDEwMDAwO1xufVxuZnVuY3Rpb24gY29kZVBvaW50VG9TdXJyb2dhdGVUYWlsKGNvZGVwb2ludCkge1xucmV0dXJuICgoY29kZXBvaW50IC0gMHgxMDAwMCkgJiAwYjExMTExMTExMTEpICsgMHhEQzAwO1xufVxuZnVuY3Rpb24gY29kZVBvaW50VG9TdXJyb2dhdGVIZWFkKGNvZGVwb2ludCkge1xucmV0dXJuICgoY29kZXBvaW50IC0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleENoYXJDbGFzc0VzY2FwZShjKSB7XG5sZXQgcyA9ICgoYyA+PSAweDdmKT8gMSA6IHJlZ2V4Q2xhc3NFc2NhcGVTdGFydEp1bXBUYWJsZVtjXSk7XG5zd2l0Y2ggKHMpIHtcbmNhc2UgMDpcbnNraXAoKTtcbjtcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbnVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgKCdDYW5ub3QgZXNjYXBlIGAnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSkgKyAnYCBpbiBhIHJlZ2V4IGNoYXIgY2xhc3Mgd2l0aCB0aGUgdS1mbGFnJyk7XG5yZXR1cm4gYyB8IDE2Nzc3MjE2O1xufVxuaWYgKGlzSWRlbnRSZXN0Q2hyKGMsIHBvaW50ZXIpID09PSAoLTEpKSB7XG51cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICgnQ2Fubm90IGVzY2FwZSBgJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpICsgJ2AgaW4gYSByZWdleCBjaGFyIGNsYXNzIHdpdGggdGhlIHUtZmxhZycpO1xucmV0dXJuIGMgfCAxNjc3NzIxNjtcbn1cbjtcbnJlZ2V4U3ludGF4RXJyb3IoKCdDYW5ub3QgZXNjYXBlIGAnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSkgKyAnYCBpbiBhIHJlZ2V4IGNoYXIgY2xhc3MnKTtcbnJldHVybiAweDExMDAwMDtcbmNhc2UgMTpcbntcbnVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgKCdDYW5ub3QgZXNjYXBlIGAnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSkgKyAnYCBpbiBhIGNoYXIgY2xhc3Mgd2l0aCB0aGUgdS1mbGFnJyk7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5za2lwKCk7XG5yZXR1cm4gYyB8IDE2Nzc3MjE2O1xufVxubGV0IHdpZGUgPSBpc0lkZW50UmVzdENocihjLCAtMSk7XG5pZiAod2lkZSA9PT0gKC0yKSkge1xucmVnZXhTeW50YXhFcnJvcigoJ0Nhbm5vdCBlc2NhcGUgYCcgKyBTdHJpbmcuZnJvbUNvZGVQb2ludChjKSkgKyAnYCBpbiBhIGNoYXIgY2xhc3MnKTtcbnJldHVybiAweDExMDAwMDtcbn1cbmlmICgoKGMgPT09IDB4MjAyOCkgfHwgKGMgPT09IDB4MjAyOSkpKSB7XG5za2lwKCk7XG5yZWdleFN5bnRheEVycm9yKCdSZWd1bGFyIGV4cHJlc3Npb25zIGRvIG5vdCBzdXBwb3J0IGxpbmUgY29udGludWF0aW9ucyAoZXNjYXBlZCB4MjAyOCB4MjAyOSknKTtcbnJldHVybiAweDExMDAwMDtcbn1cbnNraXAoKTtcbnJldHVybiBjIHwgMTY3NzcyMTY7XG59XG5jYXNlIDI6XG5za2lwKCk7XG5yZXR1cm4gcGFyc2VVbmljb2RlRXNjYXBlRm9yUmVnZXhDaGFyQ2xhc3MoKTtcbmNhc2UgMzpcbnNraXAoKTtcbmlmIChlb2ZkKDEpKSB7XG5yZWdleFN5bnRheEVycm9yKCdGb3VuZCBFT0YgYmVmb3JlIGNvbXBsZXRlbHkgcGFyc2luZyBhIGhleCBlc2NhcGUgKGluIGEgY2hhciBjbGFzcyBvZiBhIHJlZ2V4KScpO1xucmV0dXJuIDB4MTEwMDAwO1xufVxubGV0IGEgPSBjYWNoZTtcbmxldCB2YSA9IGdldEhleFZhbHVlKGEpO1xuaWYgKHZhID09PSAxNikge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xudXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCAnRmlyc3QgY2hhcmFjdGVyIG9mIGhleCBlc2NhcGUgd2FzIGludmFsaWQnKTtcbnJldHVybiAxNjc3NzMzNjtcbn1cbnJlZ2V4U3ludGF4RXJyb3IoJ0ZpcnN0IGNoYXJhY3RlciBvZiBoZXggZXNjYXBlIHdhcyBpbnZhbGlkJyk7XG5yZXR1cm4gMHgxMTAwMDA7XG59XG5za2lwKCk7XG5sZXQgYiA9IGNhY2hlO1xubGV0IHZiID0gZ2V0SGV4VmFsdWUoYik7XG5pZiAodmIgPT09IDE2KSB7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG51cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICdTZWNvbmQgY2hhcmFjdGVyIG9mIGhleCBlc2NhcGUgd2FzIGludmFsaWQnKTtcbnJldHVybiAxNjc3NzMzNjtcbn1cbnJlZ2V4U3ludGF4RXJyb3IoJ1NlY29uZCBjaGFyYWN0ZXIgb2YgaGV4IGVzY2FwZSB3YXMgaW52YWxpZCcpO1xucmV0dXJuIDB4MTEwMDAwO1xufVxuc2tpcCgpO1xucmV0dXJuICh2YSA8PCA0KSB8IHZiO1xuY2FzZSA0Olxue1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5yZWdleFN5bnRheEVycm9yKCdFYXJseSBFT0Ygd2hpbGUgcGFyc2luZyBgXFxcXGNgIGluIGEgY2hhcmFjdGVyIGNsYXNzJyk7XG5yZXR1cm4gMHgxMTAwMDA7XG59XG5sZXQgZCA9IGNhY2hlO1xuaWYgKGlzQXNjaWlMZXR0ZXIoZCkpIHtcbnNraXAoKTtcbnJldHVybiBkICUgMzI7XG59XG5sZXQgcmVhc29uID0gJ1RoZSBgXFxcXGNgIGVzY2FwZSBpcyBvbmx5IGxlZ2FsIGluIGEgY2hhciBjbGFzcyB3aXRob3V0IHUtZmxhZyBhbmQgaW4gd2ViY29tcGF0IG1vZGUnO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xudXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCByZWFzb24pO1xucmV0dXJuIDB4MTEwMDAyO1xufVxucmVnZXhTeW50YXhFcnJvcihyZWFzb24pO1xucmV0dXJuIDB4MTEwMDAwO1xufVxuY2FzZSA1Olxuc2tpcCgpO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xua0NoYXJDbGFzc0VzY2FwZWQgPSB0cnVlO1xudXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCAnQ2FuIG9ubHkgaGF2ZSBgXFxcXGtgIGluIGEgY2hhciBjbGFzcyB3aXRob3V0IHUtZmxhZyBhbmQgaW4gd2ViY29tcGF0IG1vZGUnKTtcbnJldHVybiAxNjc3NzMyMztcbn1cbnJlZ2V4U3ludGF4RXJyb3IoJ0EgY2hhcmFjdGVyIGNsYXNzIGlzIG5vdCBhbGxvd2VkIHRvIGhhdmUgYFxcXFxrYCBiYWNrLXJlZmVyZW5jZScpO1xucmV0dXJuIDB4MTEwMDAwO1xuY2FzZSA2Olxuc2tpcCgpO1xucmV0dXJuIDg7XG5jYXNlIDc6XG57XG5za2lwKCk7XG5yZXR1cm4gMHgxMTAwMDE7XG59XG5jYXNlIDg6XG5za2lwKCk7XG5yZXR1cm4gMHgwMDBDO1xuY2FzZSA5Olxuc2tpcCgpO1xucmV0dXJuIDB4MDAwQTtcbmNhc2UgMTA6XG5za2lwKCk7XG5yZXR1cm4gMHgwMDBEO1xuY2FzZSAxMTpcbnNraXAoKTtcbnJldHVybiAweDAwMDk7XG5jYXNlIDEyOlxuc2tpcCgpO1xucmV0dXJuIDB4MDAwQjtcbmNhc2UgMTM6XG5za2lwKCk7XG5yZXR1cm4gMzM1NTQ0MzI7XG5jYXNlIDE0OlxuY29uc3QgRlJPTV9DSEFSQ0xBU1MgPSB0cnVlO1xubGV0IHJlZ2V4UHJvcFN0YXRlID0gcGFyc2VSZWdleFByb3BlcnR5RXNjYXBlKGMsIEZST01fQ0hBUkNMQVNTKTtcbmlmIChyZWdleFByb3BTdGF0ZSA9PT0gNCkge1xucmV0dXJuIDM0NjY4NTQ0O1xufVxuaWYgKHJlZ2V4UHJvcFN0YXRlID09PSAyKSB7XG5yZXR1cm4gNTAzMzE2NDg7XG59XG5pZiAocmVnZXhQcm9wU3RhdGUgPT09IDEpIHtcbnJldHVybiA0MTk0MzA0MDtcbn1cbjtcbjtcbnJldHVybiAzMzU1NDQzMjtcbmNhc2UgMTU6XG57XG5za2lwKCk7XG5pZiAoKHBvaW50ZXIgPCBsZW4gJiYgaXNBc2NpaU51bWJlcihjYWNoZSkpKSB7XG5sZXQgcmVhc29uID0gJ0FuIGVzY2FwZWQgemVybyBjYW5ub3QgYmUgZm9sbG93ZWQgYnkgYW5vdGhlciBudW1iZXIgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGFuIG9jdGFsIGVzY2FwZSc7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG51cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsIHJlYXNvbik7XG5yZXR1cm4gcGFyc2VPY3RhbEZyb21TZWNvbmREaWdpdChjKSB8IDE2Nzc3MjE2O1xufVxucmVnZXhTeW50YXhFcnJvcihyZWFzb24pO1xucmV0dXJuIDB4MTEwMDAwO1xufVxucmV0dXJuIDA7XG59XG5jYXNlIDE2Olxue1xuc2tpcCgpO1xubGV0IHJlYXNvbiA9ICdBIGNoYXJhY3RlciBjbGFzcyBpcyBub3QgYWxsb3dlZCB0byBoYXZlIG51bWVyaWMgYmFjay1yZWZlcmVuY2UnO1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xudXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCByZWFzb24pO1xucmV0dXJuIHBhcnNlT2N0YWxGcm9tU2Vjb25kRGlnaXQoYykgfCAxNjc3NzIxNjtcbn1cbnJlZ2V4U3ludGF4RXJyb3IocmVhc29uKTtcbnJldHVybiAweDExMDAwMDtcbn1cbmNhc2UgMTc6XG5za2lwKCk7XG5yZXR1cm4gcGFyc2VEZWNpbWFsRXNjYXBlKGMpO1xuY2FzZSAxODpcbnNraXAoKTtcbnJldHVybiBjO1xuY2FzZSAxOTpcbntcbnNraXAoKTtcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbnJldHVybiAweDJkO1xufVxudXBkYXRlUmVnZXhVZmxhZ0lzTWFuZGF0b3J5KDAsICdFc2NhcGluZyBhIGRhc2ggaW4gYSBjaGFyIGNsYXNzIGlzIG5vdCBhbGxvd2VkJyk7XG5yZXR1cm4gODM4ODY1Mztcbn1cbmNhc2UgMjA6XG5za2lwKCk7XG5yZWdleFN5bnRheEVycm9yKCdSZWd1bGFyIGV4cHJlc3Npb25zIGRvIG5vdCBzdXBwb3J0IGxpbmUgY29udGludWF0aW9ucyAoZXNjYXBlZCBuZXdsaW5lKScpO1xucmV0dXJuIDB4MTEwMDAwO1xuO1xufVxufVxuZnVuY3Rpb24gcGFyc2VSZWdleFByb3BlcnR5RXNjYXBlKGMsIGZyb21DaGFyQ2xhc3MpIHtcbmlmICghc3VwcG9ydFJlZ2V4UHJvcGVydHlFc2NhcGVzKSB7XG5sZXQgdWZsYWdTdGF0ZSA9IHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ1Byb3BlcnR5IGVzY2FwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnRseSB0YXJnZXRlZCBsYW5ndWFnZSB2ZXJzaW9uJyk7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSByZXR1cm4gdWZsYWdTdGF0ZTtcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNNYW5kYXRvcnkodWZsYWdTdGF0ZSwgJ0Nhbm5vdCBlc2NhcGUgYFxcXFxwYCB3aXRob3V0IHUtZmxhZycpO1xufVxuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRWFybHkgRU9GIGFmdGVyIGEgcmVnZXggYFxcXFxwYCcpO1xuaWYgKGNhY2hlICE9PSAweDdiKSB7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSByZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCAnUHJvcGVydHkgZXNjYXBlIGBcXFxccGAgbXVzdCBzdGFydCB3aXRoIGEgY3VybHkgYnJhY2tldCcpO1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ1Byb3BlcnR5IGVzY2FwZSBgXFxcXHBgIG11c3Qgc3RhcnQgd2l0aCBhIGN1cmx5IGJyYWNrZXQnKTtcbn1cbmMgPSBza2lwUGVlaygpO1xubGV0IHBvaW50ZXJPZmZzZXQgPSBwb2ludGVyO1xubGV0IG5hbWUgPSAnJztcbmxldCBzYXdDb21tYXMgPSAwO1xubGV0IGhhc0VxID0gZmFsc2U7XG5sZXQgdmFsdWUgPSAnJztcbmRvIHtcbmlmICgoKCgoKChjID49IDB4NjEpICYmIChjIDw9IDB4N2EpKSkgfHwgKCgoYyA+PSAweDQxKSAmJiAoYyA8PSAweDVhKSkpKSkgfHwgKGMgPT09IDB4NWYpKSkge1xuXG59IGVsc2UgaWYgKGMgPT09IDB4N2QpIHtcbmJyZWFrO1xufSBlbHNlIGlmIChjID09PSAweDNkKSB7XG5pZiAocG9pbnRlck9mZnNldCA9PT0gcG9pbnRlcikge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ1Byb3BlcnR5IGVzY2FwZSBgXFxcXHBgIGhhZCBubyB2YWx1ZSBhZnRlciB0aGUgYD1gIHdoaWNoIGlzIGlsbGVnYWwnKTtcbn1cbnJldHVybiByZWdleFN5bnRheEVycm9yKCdQcm9wZXJ0eSBlc2NhcGUgYFxcXFxwYCBoYWQgbm8gdmFsdWUgYWZ0ZXIgdGhlIGA9YCB3aGljaCBpcyBpbGxlZ2FsJyk7XG59XG5pZiAoaGFzRXEpIHtcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICdQcm9wZXJ0eSBlc2NhcGUgYFxcXFxwYCBjb250YWluZWQgZG91YmxlIGVxdWFsIHNpZ24sIHdoaWNoIGlzIG5vdCB2YWxpZCcpO1xufVxucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ1Byb3BlcnR5IGVzY2FwZSBgXFxcXHBgIGNvbnRhaW5lZCBkb3VibGUgZXF1YWwgc2lnbiwgd2hpY2ggaXMgbm90IHZhbGlkJyk7XG59XG5oYXNFcSA9IHRydWU7XG5uYW1lID0gc2xpY2UocG9pbnRlck9mZnNldCwgcG9pbnRlcik7XG5wb2ludGVyT2Zmc2V0ID0gcG9pbnRlciArIDE7XG59IGVsc2Uge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgKCdQcm9wZXJ0eSBlc2NhcGUgYFxcXFxwYCBjb250YWluZWQgaWxsZWdhbCBjaGFyYWN0ZXIgYCcgKyBzbGljZShwb2ludGVyLCBwb2ludGVyICsgMSkpICsgJ2AnKTtcbn1cbnJldHVybiByZWdleFN5bnRheEVycm9yKCgnUHJvcGVydHkgZXNjYXBlIGBcXFxccGAgY29udGFpbmVkIGlsbGVnYWwgY2hhcmFjdGVyIGAnICsgc2xpY2UocG9pbnRlciwgcG9pbnRlciArIDEpKSArICdgJyk7XG59XG5jID0gc2tpcFBlZWsoKTtcbmlmIChwb2ludGVyID49IGxlbikge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ0VuY291bnRlcmVkIGVhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGBcXFxccGAgcHJvcGVydHkgZXNjYXBlJyk7XG59XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgZWFybHkgRU9GIHdoaWxlIHBhcnNpbmcgYFxcXFxwYCBwcm9wZXJ0eSBlc2NhcGUnKTtcbn1cbn0gd2hpbGUgKHRydWUpO1xuaWYgKHBvaW50ZXJPZmZzZXQgPT09IHBvaW50ZXIpIHtcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbmlmIChoYXNFcSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ1Byb3BlcnR5IGVzY2FwZSBgXFxcXHBgIGhhZCBubyB2YWx1ZSBhZnRlciB0aGUgYD1gIHdoaWNoIGlzIGlsbGVnYWwnKTtcbn1cbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNJbGxlZ2FsKDAsICgnUHJvcGVydHkgZXNjYXBlIGBcXFxccGAgY29udGFpbmVkIGlsbGVnYWwgY2hhcmFjdGVyIGAnICsgc2xpY2UocG9pbnRlciwgcG9pbnRlciArIDEpKSArICdgJyk7XG59XG5pZiAoaGFzRXEpIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdQcm9wZXJ0eSBlc2NhcGUgYFxcXFxwYCBoYWQgbm8gdmFsdWUgYWZ0ZXIgdGhlIGA9YCB3aGljaCBpcyBpbGxlZ2FsJyk7XG59XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcigoJ1Byb3BlcnR5IGVzY2FwZSBgXFxcXHBgIGNvbnRhaW5lZCBpbGxlZ2FsIGNoYXJhY3RlciBgJyArIHNsaWNlKHBvaW50ZXIsIHBvaW50ZXIgKyAxKSkgKyAnYCcpO1xufVxuaWYgKGhhc0VxKSB2YWx1ZSA9IHNsaWNlKHBvaW50ZXJPZmZzZXQsIHBvaW50ZXIpOyBlbHNlIG5hbWUgPSBzbGljZShwb2ludGVyT2Zmc2V0LCBwb2ludGVyKTtcbmxldCBuYyA9ICgnLCcgKyBuYW1lKSArICcsJztcbmlmIChoYXNFcSkge1xuaWYgKCFUQUJMRV9OT05CSU5fVU5JX1BST1BTLmluY2x1ZGVzKG5jKSkge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgKCdUaGUgYFxcXFxwYCBlc2NhcGVkIGJpbmFyeSBwcm9wZXJ0eSBuYW1lIGAnICsgbmFtZSkgKyAnYCBpcyBub3QgdmFsaWQgKGRvZXMgbm90IGFwcGVhciBpbiBcInRhYmxlLW5vbmJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcIiknKTtcbn1cbnJldHVybiByZWdleFN5bnRheEVycm9yKCgnVGhlIGBcXFxccGAgZXNjYXBlZCBiaW5hcnkgcHJvcGVydHkgbmFtZSBgJyArIG5hbWUpICsgJ2AgaXMgbm90IHZhbGlkIChkb2VzIG5vdCBhcHBlYXIgaW4gXCJ0YWJsZS1ub25iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXCIpJyk7XG59XG5sZXQgdmMgPSAoJywnICsgdmFsdWUpICsgJywnO1xuaWYgKCgoIVRBQkxFX0dFTl9DQVRfVkFMVUVTLmluY2x1ZGVzKHZjKSkgJiYgKCFUQUJMRV9TQ1JJUFRfVkFMVUVTLmluY2x1ZGVzKHZjKSkpKSB7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCAoJ1RoZSBlc2NhcGVkIHByb3BlcnR5IHZhbHVlIGAnICsgdmFsdWUpICsgJ2AgaXMgbm90IHZhbGlkIChkb2VzIG5vdCBhcHBlYXIgaW4gXCJ0YWJsZS11bmljb2RlLWdlbmVyYWwtY2F0ZWdvcnktdmFsdWVzXCIgbm9yIFwidGFibGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzXCIpJyk7XG59XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcigoJ1RoZSBlc2NhcGVkIHByb3BlcnR5IHZhbHVlIGAnICsgdmFsdWUpICsgJ2AgaXMgbm90IHZhbGlkIChkb2VzIG5vdCBhcHBlYXIgaW4gXCJ0YWJsZS11bmljb2RlLWdlbmVyYWwtY2F0ZWdvcnktdmFsdWVzXCIgbm9yIFwidGFibGUtdW5pY29kZS1zY3JpcHQtdmFsdWVzXCIpJyk7XG59XG5za2lwKCk7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5yZXR1cm4gMDtcbn1cbnJldHVybiB1cGRhdGVSZWdleFVmbGFnSXNNYW5kYXRvcnkoMCwgJ1RoZSBgXFxcXHBgIHByb3BlcnR5IGVzY2FwZSBpcyBvbmx5IGxlZ2FsIHdpdGggYSB1LWZsYWcsIG9yIGFzIGEgd2ViY29tcGF0IGVkZ2UgY2FzZScpO1xufVxuaWYgKCgoIVRBQkxFX0JJTl9VTklfUFJPUFMuaW5jbHVkZXMobmMpKSAmJiAoIVRBQkxFX0dFTl9DQVRfVkFMVUVTLmluY2x1ZGVzKG5jKSkpKSB7XG5pZiAod2ViQ29tcGF0ID09PSB0cnVlKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzSWxsZWdhbCgwLCAoJ1RoZSBlc2NhcGVkIGxvbmUgcHJvcGVydHkgbmFtZSBgJyArIG5hbWUpICsgJ2AgaXMgbm90IHZhbGlkIChkb2VzIG5vdCBhcHBlYXIgaW4gXCJ0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXCIgbm9yIFwidGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1wiKScpO1xufVxucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoKCdUaGUgZXNjYXBlZCBsb25lIHByb3BlcnR5IG5hbWUgYCcgKyBuYW1lKSArICdgIGlzIG5vdCB2YWxpZCAoZG9lcyBub3QgYXBwZWFyIGluIFwidGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllc1wiIG5vciBcInRhYmxlLXVuaWNvZGUtZ2VuZXJhbC1jYXRlZ29yeS12YWx1ZXNcIikgd2l0aCB1LWZsYWcsIGFuZCBgXFxcXHBgIGlzIG5vdCB2YWxpZCB3aXRob3V0IHUtZmxhZyBhbmQgd2l0aG91dCB3ZWJjb21wYXQnKTtcbn1cbnNraXAoKTtcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbnJldHVybiAwO1xufVxucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc01hbmRhdG9yeSgwLCAnVGhlIGBcXFxccGAgcHJvcGVydHkgZXNjYXBlIGlzIG9ubHkgbGVnYWwgd2l0aCBhIHUtZmxhZywgb3IgYXMgYSB3ZWJjb21wYXQgZWRnZSBjYXNlJyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4RmxhZ3MoKSB7XG5sZXQgZyA9IDA7XG5sZXQgaSA9IDA7XG5sZXQgbSA9IDA7XG5sZXQgdSA9IDA7XG5sZXQgeSA9IDA7XG5sZXQgcyA9IDA7XG53aGlsZSAocG9pbnRlciA8IGxlbikge1xubGV0IGMgPSBjYWNoZTtcbnN3aXRjaCAoYykge1xuY2FzZSAweDY3OlxuKytnO1xuYnJlYWs7XG5jYXNlIDB4Njk6XG4rK2k7XG5icmVhaztcbmNhc2UgMHg2RDpcbisrbTtcbmJyZWFrO1xuY2FzZSAweDc1OlxuKyt1O1xuYnJlYWs7XG5jYXNlIDB4Nzk6XG4rK3k7XG5icmVhaztcbmNhc2UgMHg3MzpcbmlmICghc3VwcG9ydFJlZ2V4RG90YWxsRmxhZykge1xucmV0dXJuIFRIUk9XKCdUaGUgZG90YWxsIGZsYWcgYHNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnRseSB0YXJnZXRlZCBsYW5ndWFnZSB2ZXJzaW9uJywgcG9pbnRlciwgcG9pbnRlcik7XG59XG4rK3M7XG5icmVhaztcbmRlZmF1bHQ6XG5pZiAoKGlzQXNjaWlMZXR0ZXIoYykgfHwgKGMgPT09IDB4NWMpKSkge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoKCgoJ1Vua25vd24gcmVnZXggZmxhZyBbb3JkPScgKyBjKSArICcsIGAnKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpICsgJ2ApXScpO1xufVxuaWYgKCgoKCgoZyB8IGkpIHwgbSkgfCB1KSB8IHkpIHwgcykgPiAxKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgYXQgbGVhc3Qgb25lIHJlZ2V4IGZsYWcgdHdpY2UnKTtcbn1cbnJldHVybiAoKHUgPiAwKT8gMSA6IDIpO1xufVxuc2tpcCgpO1xufVxuaWYgKCgoKCgoZyB8IGkpIHwgbSkgfCB1KSB8IHkpIHwgcykgPiAxKSB7XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRW5jb3VudGVyZWQgYXQgbGVhc3Qgb25lIHJlZ2V4IGZsYWcgdHdpY2UnKTtcbn1cbnJldHVybiAoKHUgPiAwKT8gMSA6IDIpO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleEN1cmx5UXVhbnRpZmllcihjKSB7XG5sZXQgbWluID0gMDtcbndoaWxlIChpc0FzY2lpTnVtYmVyKGMpKSB7XG5taW4gPSAobWluICogMTApICsgKGMgLSAweDMwKTtcbnNraXAoKTtcbmlmIChwb2ludGVyID49IGxlbikgcmV0dXJuIDM7XG5jID0gY2FjaGU7XG59XG5pZiAoYyAhPT0gMHgyYykge1xuaWYgKGMgIT09IDB4N2QpIHJldHVybiAzO1xuc2tpcCgpO1xucmV0dXJuIDE7XG59XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiAzO1xuYyA9IGNhY2hlO1xuaWYgKCFpc0FzY2lpTnVtYmVyKGMpKSB7XG5pZiAoYyAhPT0gMHg3ZCkgcmV0dXJuIDM7XG5za2lwKCk7XG5yZXR1cm4gMTtcbn1cbmxldCBtYXggPSAwO1xuZG8ge1xubWF4ID0gKG1heCAqIDEwKSArIChjIC0gMHgzMCk7XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiAzO1xuYyA9IGNhY2hlO1xufSB3aGlsZSAoaXNBc2NpaU51bWJlcihjKSk7XG5pZiAoYyAhPT0gMHg3ZCkgcmV0dXJuIDM7XG5za2lwKCk7XG5pZiAobWluIDw9IG1heCkgcmV0dXJuIDE7XG5yZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlTGVhZChjKSB7XG5yZXR1cm4gKChjID49IDB4RDgwMCkgJiYgKGMgPD0gMHhEQkZGKSk7XG59XG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVRhaWwoYykge1xucmV0dXJuICgoYyA+PSAweERDMDApICYmIChjIDw9IDB4REZGRikpO1xufVxuZnVuY3Rpb24gZ2V0U3Vycm9nYXRlKGMxLCBjMikge1xucmV0dXJuICgoKGMxIC0gMHhEODAwKSAqIDB4NDAwKSArIChjMiAtIDB4REMwMCkpICsgMHgxMDAwMDtcbn1cbmZ1bmN0aW9uIHBhcnNlRGVjaW1hbEVzY2FwZShjKSB7XG5sZXQgcmVhc29uID0gJ0Nhbm5vdCBlc2NhcGUgXFxcXDggb3IgXFxcXDkgaW4gYSByZWdleCBjaGFyIGNsYXNzIHdpdGggdS1mbGFnJztcbmlmICh3ZWJDb21wYXQgPT09IHRydWUpIHtcbnVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgcmVhc29uKTtcbnJldHVybiBjIHwgMTY3NzcyMTY7XG59XG5yZWdleFN5bnRheEVycm9yKHJlYXNvbik7XG5yZXR1cm4gMHgxMTAwMDA7XG59XG5mdW5jdGlvbiBwYXJzZU9jdGFsRnJvbVNlY29uZERpZ2l0KGZpcnN0Q2hhcikge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gZmlyc3RDaGFyIC0gMHgzMDtcbmxldCBzZWNvbmRDaGFyID0gY2FjaGU7XG5pZiAoaXNMb3dlck9jdGFsKGZpcnN0Q2hhcikpIHtcbmlmIChpc09jdGFsKHNlY29uZENoYXIpKSB7XG5za2lwKCk7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiAoKGZpcnN0Q2hhciAtIDB4MzApICogOCkgKyAoc2Vjb25kQ2hhciAtIDB4MzApO1xubGV0IHRoaXJkQ2hhciA9IGNhY2hlO1xuaWYgKGlzT2N0YWwodGhpcmRDaGFyKSkge1xuc2tpcCgpO1xucmV0dXJuICgoKChmaXJzdENoYXIgLSAweDMwKSAqIDgpICogOCkgKyAoKHNlY29uZENoYXIgLSAweDMwKSAqIDgpKSArICh0aGlyZENoYXIgLSAweDMwKTtcbn1cbnJldHVybiAoKGZpcnN0Q2hhciAtIDB4MzApICogOCkgKyAoc2Vjb25kQ2hhciAtIDB4MzApO1xufVxucmV0dXJuIGZpcnN0Q2hhciAtIDB4MzA7XG59XG5pZiAoaXNPY3RhbChzZWNvbmRDaGFyKSkge1xuc2tpcCgpO1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gKChmaXJzdENoYXIgLSAweDMwKSAqIDgpICsgKHNlY29uZENoYXIgLSAweDMwKTtcbmxldCB0aGlyZENoYXIgPSBjYWNoZTtcbmlmIChpc0xvd2VyT2N0YWwodGhpcmRDaGFyKSkge1xuc2tpcCgpO1xucmV0dXJuICgoKChmaXJzdENoYXIgLSAweDMwKSAqIDgpICogOCkgKyAoKHNlY29uZENoYXIgLSAweDMwKSAqIDgpKSArICh0aGlyZENoYXIgLSAweDMwKTtcbn1cbnJldHVybiAoKGZpcnN0Q2hhciAtIDB4MzApICogOCkgKyAoc2Vjb25kQ2hhciAtIDB4MzApO1xufVxucmV0dXJuIGZpcnN0Q2hhciAtIDB4MzA7XG59XG5mdW5jdGlvbiBpc09jdGFsKGMpIHtcbnJldHVybiAoKGMgPj0gMHgzMCkgJiYgKGMgPD0gMHgzNykpO1xufVxuZnVuY3Rpb24gaXNMb3dlck9jdGFsKGMpIHtcbnJldHVybiAoKGMgPj0gMHgzMCkgJiYgKGMgPD0gMHgzMykpO1xufVxuZnVuY3Rpb24gaXNVcHBlck9jdGFsKGMpIHtcbnJldHVybiAoKGMgPj0gMHgzNCkgJiYgKGMgPD0gMHgzNykpO1xufVxuZnVuY3Rpb24gcGFyc2VVbmljb2RlRXNjYXBlRm9yTm9uUmVnZXgoKSB7XG5sZXQgYyA9IGNhY2hlO1xuaWYgKGMgIT09IDB4N2IpIHtcbnJldHVybiBwYXJzZVVuaWNvZGVRdWFkRXNjYXBlKGMsIHRydWUpO1xufVxucmV0dXJuIHBhcnNlVW5pY29kZVJ1YnlFc2NhcGUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVW5pY29kZUVzY2FwZUZvclJlZ2V4QXRvbSgpIHtcbmlmIChwb2ludGVyID49IGxlbikge1xucmV0dXJuIHJlZ2V4U3ludGF4RXJyb3IoJ0Vhcmx5IEVPRiB3aGlsZSB0cnlpbmcgdG8gcGFyc2UgdW5pY29kZSBlc2NhcGUnKTtcbn1cbmxldCBjID0gY2FjaGU7XG5sZXQgd2FzUnVieSA9IGZhbHNlO1xuaWYgKGMgPT09IDB4N2IpIHtcbmMgPSBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlKCk7XG53YXNSdWJ5ID0gdHJ1ZTtcbn0gZWxzZSB7XG5jID0gcGFyc2VVbmljb2RlUXVhZEVzY2FwZShjLCBmYWxzZSk7XG59XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJldHVybiByZWdleFN5bnRheEVycm9yKCdFT0Ygd2hpbGUgdHJ5aW5nIHRvIHBhcnNlIHJlZ2V4IGF0b20gdW5pY29kZSBlc2NhcGUnKTtcbn1cbmlmIChjID09PSAweDExMDAwMCkge1xuaWYgKHdlYkNvbXBhdCA9PT0gdHJ1ZSkge1xucmV0dXJuIHVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ0Vycm9yIHdoaWxlIHRyeWluZyB0byBwYXJzZSByZWdleCBhdG9tIHVuaWNvZGUgZXNjYXBlJyk7XG59XG5yZXR1cm4gcmVnZXhTeW50YXhFcnJvcignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHBhcnNlIHJlZ2V4IGF0b20gdW5pY29kZSBlc2NhcGUnKTtcbn1cbmlmICgod2FzUnVieSAmJiAod2ViQ29tcGF0ID09PSBmYWxzZSkpKSB7XG5yZXR1cm4gdXBkYXRlUmVnZXhVZmxhZ0lzTWFuZGF0b3J5KDAsICdBIHJlZ2V4IGF0b20gdGhhdCBpcyBhbiB1bmljb2RlIHJ1YnkgZXNjYXBlIGlzIG9ubHkgbGVnYWwgd2l0aCB1LWZsYWcnKTtcbn1cbmlmICgoKCh3YXNSdWJ5ICYmICh3ZWJDb21wYXQgPT09IHRydWUpKSkgJiYgKCFjLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2Etel0vaSkpKSkge1xuaWYgKChwb2ludGVyIDwgbGVuICYmIChjYWNoZSA9PT0gMHgzZikpKSB7XG5za2lwKCk7XG59XG5yZXR1cm4gODtcbn1cbnJldHVybiAwO1xufVxuZnVuY3Rpb24gcGFyc2VVbmljb2RlRXNjYXBlRm9yUmVnZXhDaGFyQ2xhc3MoKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHtcbnJlZ2V4U3ludGF4RXJyb3IoJ0Vhcmx5IEVPRiB3aGlsZSBwYXJzaW5nIGEgdW5pY29kZSBlc2NhcGUgaW4gYSByZWdleCBjaGFyIGNsYXNzJyk7XG5yZXR1cm4gMHgxMTAwMDA7XG59XG5sZXQgYyA9IGNhY2hlO1xubGV0IHdhc1F1YWQgPSB0cnVlO1xuaWYgKGMgPT09IDB4N2IpIHtcbmMgPSBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlKCk7XG53YXNRdWFkID0gZmFsc2U7XG59IGVsc2Uge1xuYyA9IHBhcnNlVW5pY29kZVF1YWRFc2NhcGUoYywgZmFsc2UpO1xufVxuaWYgKHBvaW50ZXIgPj0gbGVuKSB7XG5yZWdleFN5bnRheEVycm9yKCdFYXJseSBFT0Ygd2hpbGUgcGFyc2luZyBhIHVuaWNvZGUgZXNjYXBlIGluIGEgcmVnZXggY2hhciBjbGFzcycpO1xucmV0dXJuIDB4MTEwMDAwO1xufVxuaWYgKGMgPT09IDB4MTEwMDAwKSB7XG5yZXR1cm4gMHgxMTAwMDA7XG59XG5sZXQgcnVieVdlYkV4Y2VwdGlvbiA9IGZhbHNlO1xuaWYgKCF3YXNRdWFkKSB7XG5pZiAod2ViQ29tcGF0ID09PSBmYWxzZSkge1xudXBkYXRlUmVnZXhVZmxhZ0lzTWFuZGF0b3J5KDAsICdGb3VuZCBhIHVuaWNvZGUgcnVieSBlc2NhcGUgd2hpY2ggaXMgb25seSB2YWxpZCB3aXRoIHUtZmxhZycpO1xucnVieVdlYkV4Y2VwdGlvbiA9IHRydWU7XG59XG5jIHw9IDY3MTA4ODY0O1xufVxuaWYgKHJ1YnlXZWJFeGNlcHRpb24pIHJldHVybiBjIHwgODM4ODYwODtcbnJldHVybiBjO1xufVxuZnVuY3Rpb24gcGFyc2VVbmljb2RlUXVhZEVzY2FwZShhLCBub0RvdWJsZSkge1xuaWYgKGVvZmQoMykpIHtcbnVwZGF0ZVJlZ2V4VWZsYWdJc0lsbGVnYWwoMCwgJ1VuZXhwZWN0ZWQgRU9GIHdoaWxlIHBhcnNpbmcgdW5pY29kZSBxdWFkIGVzY2FwZScpO1xucmV0dXJuIDB4MTEwMDAwO1xufVxubGV0IGIgPSBwZWVrZCgxKTtcbmxldCBjID0gcGVla2QoMik7XG5sZXQgZCA9IHBlZWtkKDMpO1xubGV0IHZhID0gZ2V0SGV4VmFsdWUoYSk7XG5sZXQgdmIgPSBnZXRIZXhWYWx1ZShiKTtcbmxldCB2YyA9IGdldEhleFZhbHVlKGMpO1xubGV0IHZkID0gZ2V0SGV4VmFsdWUoZCk7XG5pZiAoKCgodmEgfCB2YikgfCB2YykgfCB2ZCkgPiAxNSkge1xudXBkYXRlUmVnZXhQb3RlbnRpYWxFcnJvcignQXR0ZW1wdGVkIHRvIHBhcnNlIGEgdW5pY29kZSBxdWFkIGVzY2FwZSBidXQgYXQgbGVhc3Qgb25lIGRpZ2l0IHdhcyBub3QgYSBoZXgnKTtcbnJldHVybiAweDExMDAwMDtcbn1cbnNraXAoKTtcbnNraXAoKTtcbnNraXAoKTtcbnNraXAoKTtcbmxldCBmaXJzdFBhcnQgPSAoKCh2YSA8PCAxMikgfCAodmIgPDwgOCkpIHwgKHZjIDw8IDQpKSB8IHZkO1xuaWYgKCgoKCgoKCgoKG5vRG91YmxlIHx8IChmaXJzdFBhcnQgPCAweEQ4MDApKSkgfHwgKGZpcnN0UGFydCA+IDB4REJGRikpKSB8fCBlb2ZkKDUpKSkgfHwgKGNhY2hlICE9PSAweDVjKSkpIHx8IChwZWVrZCgxKSAhPT0gMHg3NSkpKSB7XG5yZXR1cm4gZmlyc3RQYXJ0O1xufVxubGV0IGUgPSBwZWVrZCgyKTtcbmxldCBmID0gcGVla2QoMyk7XG5sZXQgZyA9IHBlZWtkKDQpO1xubGV0IGggPSBwZWVrZCg1KTtcbmxldCB2ZSA9IGdldEhleFZhbHVlKGUpO1xubGV0IHZmID0gZ2V0SGV4VmFsdWUoZik7XG5sZXQgdmcgPSBnZXRIZXhWYWx1ZShnKTtcbmxldCB2aCA9IGdldEhleFZhbHVlKGgpO1xuaWYgKCgoKHZlIHwgdmYpIHwgdmcpIHwgdmgpID4gMTUpIHtcbnJldHVybiBmaXJzdFBhcnQ7XG59XG5sZXQgc2Vjb25kUGFydCA9ICgoKHZlIDw8IDEyKSB8ICh2ZiA8PCA4KSkgfCAodmcgPDwgNCkpIHwgdmg7XG5pZiAoKChzZWNvbmRQYXJ0IDwgMHhEQzAwKSB8fCAoc2Vjb25kUGFydCA+IDB4REZGRikpKSB7XG5yZXR1cm4gZmlyc3RQYXJ0O1xufVxuc2tpcCgpO1xuc2tpcCgpO1xuc2tpcCgpO1xuc2tpcCgpO1xuc2tpcCgpO1xuc2tpcCgpO1xubGV0IGNvZGVwb2ludCA9IHN1cnJvZ2F0ZVRvQ29kZXBvaW50KGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XG51cGRhdGVSZWdleFBvdGVudGlhbEVycm9yKCdBIGRvdWJsZSB1bmljb2RlIHF1YWQgZXNjYXBlIHRoYXQgcmVwcmVzZW50cyBhIHN1cnJvZ2F0ZSBwYWlyIGluIGNoYXIgY2xhc3Mgb3IgZ3JvdXAgbmFtZSBpcyBvbmx5IHZhbGlkIHdpdGggdS1mbGFnJyk7XG5yZXR1cm4gY29kZXBvaW50O1xufVxuZnVuY3Rpb24gcGFyc2VVbmljb2RlUnVieUVzY2FwZSgpIHtcbnNraXAoKTtcbmxldCBjID0gcGFyc2VVbmljb2RlUnVieUVzY2FwZUJvZHkoKTtcbmlmICgoKCgoYyA9PT0gMHgxMTAwMDApIHx8IHBvaW50ZXIgPj0gbGVuKSkgfHwgKCEoY2FjaGUgPT09IDB4N2QpKSkpIHtcbnJldHVybiAweDExMDAwMDtcbn1cbnNraXAoKTtcbnJldHVybiBjO1xufVxuZnVuY3Rpb24gcGFyc2VVbmljb2RlUnVieUVzY2FwZUJvZHkoKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiAweDExMDAwMDtcbmxldCBhID0gY2FjaGU7XG5sZXQgdiA9IGdldEhleFZhbHVlKGEpO1xuaWYgKHYgPT09IDE2KSByZXR1cm4gMHgxMTAwMDA7XG5za2lwKCk7XG5yZXR1cm4gcGFyc2VVbmljb2RlUnVieUVzY2FwZUJvZHkyKHYpO1xufVxuZnVuY3Rpb24gcGFyc2VVbmljb2RlUnVieUVzY2FwZUJvZHkyKHYpIHtcbmlmICh2ID09PSAwKSB7XG5pZiAocG9pbnRlciA+PSBsZW4pIHJldHVybiAweDExMDAwMDtcbmxldCBjID0gc2tpcFplcm9lcygpO1xudiA9IGdldEhleFZhbHVlKGMpO1xuaWYgKHYgPT09IDE2KSB7XG5yZXR1cm4gMDtcbn1cbnNraXAoKTtcbn1cbnJldHVybiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTModik7XG59XG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTModikge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMHgxMTAwMDA7XG5sZXQgYiA9IGNhY2hlO1xubGV0IHZiID0gZ2V0SGV4VmFsdWUoYik7XG5pZiAodmIgPT09IDE2KSByZXR1cm4gdjtcbnNraXAoKTtcbnJldHVybiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTQoKHYgPDwgNCkgKyB2Yik7XG59XG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTQodikge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMHgxMTAwMDA7XG5sZXQgYyA9IGNhY2hlO1xubGV0IHZjID0gZ2V0SGV4VmFsdWUoYyk7XG5pZiAodmMgPT09IDE2KSByZXR1cm4gdjtcbnNraXAoKTtcbnJldHVybiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTUoKHYgPDwgNCkgKyB2Yyk7XG59XG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTUodikge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMHgxMTAwMDA7XG5sZXQgZCA9IGNhY2hlO1xubGV0IHZkID0gZ2V0SGV4VmFsdWUoZCk7XG5pZiAodmQgPT09IDE2KSByZXR1cm4gdjtcbnNraXAoKTtcbnJldHVybiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTYoKHYgPDwgNCkgKyB2ZCk7XG59XG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTYodikge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMHgxMTAwMDA7XG5sZXQgZSA9IGNhY2hlO1xubGV0IHZlID0gZ2V0SGV4VmFsdWUoZSk7XG5pZiAodmUgPT09IDE2KSByZXR1cm4gdjtcbnNraXAoKTtcbnJldHVybiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTcoKHYgPDwgNCkgKyB2ZSk7XG59XG5mdW5jdGlvbiBwYXJzZVVuaWNvZGVSdWJ5RXNjYXBlQm9keTcodikge1xuaWYgKHBvaW50ZXIgPj0gbGVuKSByZXR1cm4gMHgxMTAwMDA7XG5sZXQgZiA9IGNhY2hlO1xubGV0IHZmID0gZ2V0SGV4VmFsdWUoZik7XG5pZiAodmYgPT09IDE2KSByZXR1cm4gdjtcbnNraXAoKTtcbmxldCByID0gKHYgPDwgNCkgKyB2ZjtcbmlmIChyID49IDB4MTEwMDAwKSByZXR1cm4gMHgxMTAwMDA7XG5yZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHBhcnNlT3RoZXJVbmljb2RlKGMpIHtcbnN3aXRjaCAoYykge1xuY2FzZSAweEEwOlxucmV0dXJuIHBhcnNlU3BhY2UoKTtcbmNhc2UgMHhGRUZGOlxucmV0dXJuIHBhcnNlU3BhY2UoKTtcbmNhc2UgMHgyMDI4OlxucmV0dXJuIHBhcnNlTmV3bGluZVNvbG8oKTtcbmNhc2UgMHgyMDI5OlxucmV0dXJuIHBhcnNlTmV3bGluZVNvbG8oKTtcbmRlZmF1bHQ6XG5sZXQgdCA9IHBhcnNlSWRlbnRVbmljb2RlT3JFcnJvcihjKTtcbmlmICh0ICE9PSAyMDk3MTc1KSByZXR1cm4gdDtcbnJldHVybiBwYXJzZVdoaXRlc3BhY2VVbmljb2RlT3JFcnJvcihjKTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlSWRlbnRVbmljb2RlT3JFcnJvcihjKSB7XG5sZXQgY3UgPSBpbnB1dC5jb2RlUG9pbnRBdChwb2ludGVyIC0gMSk7XG5sZXQgd2lkZSA9IGlzSWRlbnRTdGFydChjdSwgcG9pbnRlciAtIDEpO1xuaWYgKHdpZGUgIT09ICgtMSkpIHtcbmlmICh3aWRlID09PSAoLTMpKSBza2lwKCk7XG5yZXR1cm4gcGFyc2VJZGVudGlmaWVyUmVzdChTdHJpbmcuZnJvbUNvZGVQb2ludChjdSksICgod2lkZSA9PT0gKC0zKSk/IDIgOiAxKSk7XG59XG5pZiAoIWxhc3RSZXBvcnRhYmxlTGV4ZXJFcnJvcikgbGFzdFJlcG9ydGFibGVMZXhlckVycm9yID0gKCgoJ1VuZXhwZWN0ZWQgdW5pY29kZSBjaGFyYWN0ZXI6ICcgKyBjKSArICcgKCcpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSkgKyAnKSc7XG5yZXR1cm4gMjA5NzE3NTtcbn1cbmZ1bmN0aW9uIHBhcnNlV2hpdGVzcGFjZVVuaWNvZGVPckVycm9yKGMpIHtcbnJldHVybiAoWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMGEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDBdLmluY2x1ZGVzKGMpPyAyNTcgOiAyMDk3MTc1KTtcbn1cbmZ1bmN0aW9uIFRIUk9XKHN0ciwgdG9rZW5TdGFydCwgdG9rZW5TdG9wKSB7XG4kZXJyb3IoJ1Rocm93aW5nIHRoaXMgZXJyb3I6Jywgc3RyKTtcbl9USFJPVygnTGV4ZXIgZXJyb3IhICcgKyBzdHIsIHRva2VuU3RhcnQsIHRva2VuU3RvcCk7XG59XG5mdW5jdGlvbiBfVEhST1coc3RyLCB0b2tlblN0YXJ0LCB0b2tlblN0b3AsIG1zZyA9ICcnLCB3aXRoQ29kZUZyYW1lID0gZXJyb3JDb2RlRnJhbWUsIGZ1bGxDb2RlRnJhbWVMb2NhbCA9IHRydW5jQ29kZUZyYW1lKSB7XG5sZXQgZWN0eHQgPSAod2l0aENvZGVGcmFtZT8gZ2V0RXJyb3JDb250ZXh0KHRva2VuU3RhcnQsIHRva2VuU3RvcCwgbXNnLCBmdWxsQ29kZUZyYW1lTG9jYWwpIDogJycpO1xubGV0IGNvbnRleHQgPSAoKCdcXG5gYGBgYFxcbicgKyAoKChlY3R4dFtlY3R4dC5sZW5ndGggLSAxXSAhPT0gJ1xcbicpPyAnXFxuJyA6ICcnKSkpICsgZWN0eHQpICsgJ2BgYGBgXFxuJztcbiRsb2coJ0Vycm9yIGF0OicgKyBjb250ZXh0KTtcbmlmIChncmFjZWZ1bEVycm9ycyA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcigoKHN0ciArICdcXG4nKSArICgod2l0aENvZGVGcmFtZT8gJ1xcbicgOiAnJykpKSArIGVjdHh0KTsgZWxzZSAkZXJyb3Ioc3RyKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yQ29udGV4dCh0b2tlblN0YXJ0LCB0b2tlblN0b3AsIG1zZywgdHJ1bmNDb2RlRnJhbWUgPSBmYWxzZSkge1xubGV0IGlucHV0T2Zmc2V0ID0gMDtcbmlmICgodHJ1bmNDb2RlRnJhbWUgJiYgKHRva2VuU3RhcnQgPiAxMDApKSkgaW5wdXRPZmZzZXQgPSB0b2tlblN0YXJ0IC0gMTAwO1xubGV0IGlucHV0TGVuID0gaW5wdXQubGVuZ3RoIC0gaW5wdXRPZmZzZXQ7XG5pZiAoKHRydW5jQ29kZUZyYW1lICYmICgodG9rZW5TdG9wICsgMTAwKSA8IGlucHV0Lmxlbmd0aCkpKSBpbnB1dExlbiA9ICh0b2tlblN0b3AgKyAxMDApIC0gaW5wdXRPZmZzZXQ7XG5sZXQgaXNQb2ludGVySW5jbHVkZWQgPSB0cnVlO1xuaWYgKChpbnB1dE9mZnNldCArIGlucHV0TGVuKSA8IHBvaW50ZXIpIHtcbmxldCBsZW4gPSBwb2ludGVyIC0gaW5wdXRPZmZzZXQ7XG5pZiAobGVuIDwgMTAyNCkge1xuaW5wdXRMZW4gPSBsZW47XG59IGVsc2Uge1xuaXNQb2ludGVySW5jbHVkZWQgPSBmYWxzZTtcbn1cbn1cbmxldCB1c2VkSW5wdXQgPSBpbnB1dC5zbGljZShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbik7XG5sZXQgdG9rZW5PZmZzZXQgPSB0b2tlblN0YXJ0IC0gaW5wdXRPZmZzZXQ7XG5sZXQgbmwxID0gdXNlZElucHV0Lmxhc3RJbmRleE9mKCdcXG4nLCB0b2tlbk9mZnNldCk7XG5sZXQgbmwyID0gdXNlZElucHV0LmluZGV4T2YoJ1xcbicsIG5sMSArIDEpO1xuaWYgKG5sMiA8IDApIG5sMiA9IHVzZWRJbnB1dC5sZW5ndGg7XG5sZXQgYXJyb3dDb3VudCA9ICgodG9rZW5TdG9wIC0gdG9rZW5TdGFydCkgfHwgMSk7XG5sZXQgaW5kZW50Q291bnQgPSB0b2tlbk9mZnNldCAtIChubDEgKyAxKTtcbmxldCBwb2ludGVyTGluZSA9IGN1cnJlbnRMaW5lO1xubGV0IGVycm9yTGluZSA9IGN1cnJlbnRMaW5lO1xubGV0IGVycm9yQ29sdW1uID0gKCgoKGlucHV0T2Zmc2V0ID4gMCkgJiYgKG5sMSA8IDApKSk/ICgtMSkgOiAoKHRva2VuU3RhcnQgLSBpbnB1dE9mZnNldCkgLSAoKChubDEgPj0gMCk/IG5sMSArIDEgOiAwKSkpKTtcbmlmIChpc1BvaW50ZXJJbmNsdWRlZCkge1xubGV0IHJlbGF0aXZlUG9pbnRlciA9IHBvaW50ZXIgLSBpbnB1dE9mZnNldDtcbmxldCBzZWFyY2hQb2ludGVyID0gcmVsYXRpdmVQb2ludGVyO1xud2hpbGUgKHNlYXJjaFBvaW50ZXIgPiAwKSB7XG5zZWFyY2hQb2ludGVyID0gdXNlZElucHV0Lmxhc3RJbmRleE9mKCdcXG4nLCBzZWFyY2hQb2ludGVyIC0gMSk7XG4tLXBvaW50ZXJMaW5lO1xuaWYgKHNlYXJjaFBvaW50ZXIgPiBubDEpIC0tZXJyb3JMaW5lO1xufVxuaWYgKHNlYXJjaFBvaW50ZXIgIT09IDApIHBvaW50ZXJMaW5lICs9IDE7XG59XG5sZXQgbWF4UG9pbnRlcmxpbmVMZW4gPSAoJycgKyBjdXJyZW50TGluZSkubGVuZ3RoO1xubGV0IGd1dHRlcldpZHRoID0gbWF4UG9pbnRlcmxpbmVMZW4gKyA0O1xubGV0IHByZSA9IHVzZWRJbnB1dC5zbGljZSgwLCBubDIpLnNwbGl0KCdcXG4nKTtcbmxldCBwb3N0ID0gdXNlZElucHV0LnNsaWNlKG5sMiArIDEsIGlucHV0TGVuKS5zcGxpdCgnXFxuJyk7XG53aGlsZSAoKChwcmUubGVuZ3RoID4gMSkgJiYgKHByZVswXS5sZW5ndGggPT09IDApKSkge1xucHJlLnNoaWZ0KCk7XG4rK3BvaW50ZXJMaW5lO1xufVxud2hpbGUgKCgocG9zdC5sZW5ndGggPiAwKSAmJiAocG9zdFtwb3N0Lmxlbmd0aCAtIDFdLmxlbmd0aCA9PT0gMCkpKSB7XG5wb3N0LnBvcCgpO1xufVxubGV0IGxjID0gcG9pbnRlckxpbmU7XG5sZXQgcHJlMiA9IHByZS5tYXAocyA9PiAoKCgnICcgKyAoJycgKyAobGMrKykpLnBhZFN0YXJ0KG1heFBvaW50ZXJsaW5lTGVuLCAnICcpKSArICcg4pWRICcpICsgcy50cmltUmlnaHQoKSkpLmpvaW4oJ1xcbicpO1xubGV0IHBvc3QyID0gcG9zdC5tYXAocyA9PiAoKCgnICcgKyAoJycgKyAobGMrKykpLnBhZFN0YXJ0KG1heFBvaW50ZXJsaW5lTGVuLCAnICcpKSArICcg4pWRICcpICsgcy50cmltUmlnaHQoKSkpLmpvaW4oJ1xcbicpO1xuaWYgKCgnJyArIGxjKS5sZW5ndGggPiBtYXhQb2ludGVybGluZUxlbikge1xubWF4UG9pbnRlcmxpbmVMZW4gPSAoJycgKyBsYykubGVuZ3RoO1xuZ3V0dGVyV2lkdGggPSBtYXhQb2ludGVybGluZUxlbiArIDQ7XG5sYyA9IHBvaW50ZXJMaW5lO1xucHJlMiA9IHByZS5tYXAocyA9PiAoKCgnICcgKyAoJycgKyAobGMrKykpLnBhZFN0YXJ0KG1heFBvaW50ZXJsaW5lTGVuLCAnICcpKSArICcg4pWRICcpICsgcy50cmltUmlnaHQoKSkpLmpvaW4oJ1xcbicpO1xucG9zdDIgPSBwb3N0Lm1hcChzID0+ICgoKCcgJyArICgnJyArIChsYysrKSkucGFkU3RhcnQobWF4UG9pbnRlcmxpbmVMZW4sICcgJykpICsgJyDilZEgJykgKyBzLnRyaW1SaWdodCgpKSkuam9pbignXFxuJyk7XG59XG5sZXQgY29sID0gKChwb2ludGVyTGluZSA9PT0gMSk/IGlucHV0T2Zmc2V0IDogdXNlZElucHV0Lmxhc3RJbmRleE9mKGlucHV0T2Zmc2V0KSk7XG5sZXQgdG9wID0gKCgoKCgoKCdzdGFydEAnICsgcG9pbnRlckxpbmUpICsgJzonKSArICgoKGNvbCA8IDApPyAnPycgOiBjb2wpKSkgKyAnLCBlcnJvckAnKSArIGVycm9yTGluZSkgKyAnOicpICsgKCgoZXJyb3JDb2x1bW4gPCAwKT8gJz8nIDogZXJyb3JDb2x1bW4pKSkgKyAnXFxuJztcbmxldCBiYXIgPSAn4pWQJy5yZXBlYXQodG9wLmxlbmd0aCAtIGd1dHRlcldpZHRoKSArICdcXG4nO1xubGV0IGhlYWRlciA9ICgn4pWUJyArICfilZAnLnJlcGVhdChtYXhQb2ludGVybGluZUxlbikpICsgJ+KVkOKVpic7XG5sZXQgZm9vdGVyID0gKCfilZonICsgJ+KVkCcucmVwZWF0KG1heFBvaW50ZXJsaW5lTGVuKSkgKyAn4pWQ4pWpJztcbmxldCByZXR1cm5WYWx1ZSA9ICgoKCgoKCgoKCgoKCgoKCh0b3AgKyBoZWFkZXIpICsgYmFyKSArIHByZTIpICsgJ1xcbicpICsgJyAnLnJlcGVhdChNYXRoLm1heCgwLCBtYXhQb2ludGVybGluZUxlbiArIDEpKSkgKyAnIOKVkSAnKSArICcgJy5yZXBlYXQoTWF0aC5tYXgoMCwgaW5kZW50Q291bnQpKSkgKyAnXicucmVwZWF0KE1hdGgubWF4KDAsIGFycm93Q291bnQpKSkgKyAnLS0tLS0tLSBlcnJvcicpICsgKChtc2c/ICc6ICcgKyBtc2cgOiAnJykpKSArICgoKHRva2VuT2Zmc2V0ID49IHVzZWRJbnB1dC5sZW5ndGgpPyAnIGF0IEVPRicgOiAnJykpKSArICgocG9zdDI/ICdcXG4nIDogJycpKSkgKyBwb3N0MikgKyAnXFxuJykgKyBmb290ZXIpICsgYmFyKSArICcnO1xucmV0dXJuIHJldHVyblZhbHVlLnNwbGl0KCdcXG4nKS5tYXAocyA9PiAocy50cmltUmlnaHQoKSkpLmpvaW4oJ1xcbicpO1xufVxucmV0dXJuIHt0b2tlbnM6dG9rZW5TdG9yYWdlLCBuZXh0VG9rZW46bmV4dFRva2VuLCBhc2k6YWRkQXNpLCB0aHJvdzpfVEhST1csIGxleEVycm9yOmZ1bmN0aW9uKCkge1xuVEhST1cobGFzdFJlcG9ydGFibGVMZXhlckVycm9yLCBzdGFydEZvckVycm9yLCBwb2ludGVyKTtcbn0sIGdldFRva2VuQ291bnRBbnk6ZnVuY3Rpb24oKSB7XG5yZXR1cm4gYW55VG9rZW5Db3VudDtcbn0sIGdldFRva2VuQ291bnRTb2xpZDpmdW5jdGlvbigpIHtcbnJldHVybiBzb2xpZFRva2VuQ291bnQ7XG59LCBwcmV2RW5kQ29sdW1uOmZ1bmN0aW9uKCkge1xucmV0dXJuIHByZXZUb2tlbkVuZENvbHVtbjtcbn0sIHByZXZFbmRMaW5lOmZ1bmN0aW9uKCkge1xucmV0dXJuIHByZXZUb2tlbkVuZExpbmU7XG59LCBwcmV2RW5kUG9pbnRlcjpmdW5jdGlvbigpIHtcbnJldHVybiBwcmV2VG9rZW5FbmRQb2ludGVyO1xufSwgY3VyckNvbHVtbjpmdW5jdGlvbigpIHtcbnJldHVybiBwb2ludGVyIC0gY3VycmVudENvbE9mZnNldDtcbn0sIGN1cnJMaW5lOmZ1bmN0aW9uKCkge1xucmV0dXJuIGN1cnJlbnRMaW5lO1xufSwgY3VyclBvaW50ZXI6ZnVuY3Rpb24oKSB7XG5yZXR1cm4gcG9pbnRlcjtcbn0sIGdldE5sd2FzOmZ1bmN0aW9uKCkge1xucmV0dXJuIG5sd2FzO1xufSwgZ2V0Q2Fub046ZnVuY3Rpb24oKSB7XG5yZXR1cm4gbGFzdENhbm9uaXplZElucHV0O1xufSwgZ2V0VHlwZTpmdW5jdGlvbigpIHtcbnJldHVybiBsYXN0VHlwZTtcbn0sIGdldFN0YXJ0OmZ1bmN0aW9uKCkge1xucmV0dXJuIGxhc3RTdGFydDtcbn0sIGdldFN0b3A6ZnVuY3Rpb24oKSB7XG5yZXR1cm4gbGFzdFN0b3A7XG59LCBnZXRMaW5lOmZ1bmN0aW9uKCkge1xucmV0dXJuIGxhc3RMaW5lO1xufSwgZ2V0Q29sdW1uOmZ1bmN0aW9uKCkge1xucmV0dXJuIGxhc3RDb2x1bW47XG59LCBzbGljZUlucHV0OnNsaWNlfTtcbn1cbmZ1bmN0aW9uIGlzTGZQc0xzKGMpIHtcbnJldHVybiAoKGMgPT09IDB4MEEpIHx8IGlzUHNMcyhjKSk7XG59XG5mdW5jdGlvbiBpc1BzTHMoYykge1xucmV0dXJuICgoYyA9PT0gMHgyMDI4KSB8fCAoYyA9PT0gMHgyMDI5KSk7XG59XG5mdW5jdGlvbiBTVEFSVCh0eXBlKSB7XG5zd2l0Y2ggKHR5cGUpIHtcbmNhc2UgMTpcbnJldHVybiAnU1RBUlRfU1BBQ0UnO1xuY2FzZSAyOlxucmV0dXJuICdTVEFSVF9JRCc7XG5jYXNlIDM6XG5yZXR1cm4gJ1NUQVJUX0tFWSc7XG5jYXNlIDQ6XG5yZXR1cm4gJ1NUQVJUX05MX1NPTE8nO1xuY2FzZSA1OlxucmV0dXJuICdTVEFSVF9DUic7XG5jYXNlIDY6XG5yZXR1cm4gJ1NUQVJUX1NUUklORyc7XG5jYXNlIDc6XG5yZXR1cm4gJ1NUQVJUX0RFQ0lNQUwnO1xuY2FzZSA4OlxucmV0dXJuICdTVEFSVF9ET1QnO1xuY2FzZSA5OlxucmV0dXJuICdTVEFSVF9DVVJMWV9DTE9TRSc7XG5jYXNlIDEwOlxucmV0dXJuICdTVEFSVF9FUSc7XG5jYXNlIDExOlxucmV0dXJuICdTVEFSVF9ESVYnO1xuY2FzZSAxMjpcbnJldHVybiAnU1RBUlRfUExVUyc7XG5jYXNlIDEzOlxucmV0dXJuICdTVEFSVF9NSU4nO1xuY2FzZSAxNDpcbnJldHVybiAnU1RBUlRfWkVSTyc7XG5jYXNlIDE1OlxucmV0dXJuICdTVEFSVF9URU1QTEFURSc7XG5jYXNlIDE2OlxucmV0dXJuICdTVEFSVF9FWENMJztcbmNhc2UgMTc6XG5yZXR1cm4gJ1NUQVJUX1BFUkNFTlQnO1xuY2FzZSAxODpcbnJldHVybiAnU1RBUlRfQU5EJztcbmNhc2UgMTk6XG5yZXR1cm4gJ1NUQVJUX1NUQVInO1xuY2FzZSAyMDpcbnJldHVybiAnU1RBUlRfQ0FSRVQnO1xuY2FzZSAyMTpcbnJldHVybiAnU1RBUlRfTFQnO1xuY2FzZSAyMjpcbnJldHVybiAnU1RBUlRfR1QnO1xuY2FzZSAyMzpcbnJldHVybiAnU1RBUlRfT1InO1xuY2FzZSAyNDpcbnJldHVybiAnU1RBUlRfQlNMQVNIJztcbmNhc2UgMjY6XG5yZXR1cm4gJ1NUQVJUX0VSUk9SJztcbn1cbnJldHVybiAoJ1M8JyArIFQodHlwZSkpICsgJz4nO1xufVxuLy8gPC9sZXhlcj5cblxuLy8gPHBhcnNlcj5cbmxldCBBU1NFUlRfQVNJX1JFR0VYX05FWFQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNhbnNGbGFnKGZsYWdzLCBmbGFnKSB7XG5yZXR1cm4gKGZsYWdzIHwgZmxhZykgXiBmbGFnO1xufVxuZnVuY3Rpb24gaGFzQWxsRmxhZ3MoZmxhZ3MxLCBmbGFnczIpIHtcbnJldHVybiAoZmxhZ3MxICYgZmxhZ3MyKSA9PT0gZmxhZ3MyO1xufVxuZnVuY3Rpb24gaGFzQW55RmxhZyhmbGFnczEsIGZsYWdzMikge1xucmV0dXJuIChmbGFnczEgJiBmbGFnczIpICE9PSAwO1xufVxuZnVuY3Rpb24gaGFzTm9GbGFnKGZsYWdzLCBmbGFnKSB7XG5yZXR1cm4gKGZsYWdzICYgZmxhZykgPT09IDA7XG59XG5mdW5jdGlvbiBQYXJzZXIoY29kZSwgb3B0aW9ucyA9IHt9KSB7XG5sZXQge2dvYWxNb2RlOm9wdGlvbnNfZ29hbE1vZGUgPSBmYWxzZSwgY29sbGVjdFRva2VuczpvcHRpb25zX2NvbGxlY3RUb2tlbnMgPSAwLCB3ZWJDb21wYXQ6b3B0aW9uc193ZWJDb21wYXQgPSB0cnVlLCBzdHJpY3RNb2RlOm9wdGlvbnNfc3RyaWN0TW9kZSA9IGZhbHNlLCBhc3RSb290Om9wdGlvbnNfYXN0Um9vdCA9IG51bGwsIHRva2VuU3RvcmFnZTpvcHRpb25zX3Rva2VuU3RvcmFnZSwgZ2V0TGV4ZXIgPSBudWxsLCBhbGxvd0dsb2JhbFJldHVybiA9IGZhbHNlLCB0YXJnZXRFc1ZlcnNpb24gPSBJbmZpbml0eSwgZXhwb3NlU2NvcGVzOm9wdGlvbnNfZXhwb3NlU2NvcGVzID0gZmFsc2UsIGFzdFVpZHMgPSBmYWxzZSwgcmFuZ2VzOm9wdGlvbnNfcmFuZ2VzID0gZmFsc2UsIHRlbXBsYXRlTmV3bGluZU5vcm1hbGl6YXRpb24gPSB0cnVlLCBlcnJvckNvZGVGcmFtZSA9IHRydWUsIHRydW5jQ29kZUZyYW1lID0gdHJ1ZSwgJGxvZyA9IGNvbnNvbGUubG9nLCAkd2FybiA9IGNvbnNvbGUud2FybiwgJGVycm9yID0gY29uc29sZS5lcnJvciwgc291cmNlRmllbGQgPSAnJywgYmFiZWxDb21wYXQgPSBmYWxzZSwgYmFiZWxUb2tlbkNvbXBhdCA9IGZhbHNlLCBhY29ybkNvbXBhdCA9IGZhbHNlLCBBU1RfZGlyZWN0aXZlTm9kZXMgPSBmYWxzZX0gPSBvcHRpb25zO1xubGV0IGdvYWxNb2RlID0gZmFsc2U7XG5pZiAoKHR5cGVvZiBvcHRpb25zX2dvYWxNb2RlKSA9PT0gJ3N0cmluZycpIHtcbmlmIChvcHRpb25zX2dvYWxNb2RlID09PSAnbW9kdWxlJykgZ29hbE1vZGUgPSB0cnVlOyBlbHNlIGlmIChvcHRpb25zX2dvYWxNb2RlID09PSAnc2NyaXB0JykgZ29hbE1vZGUgPSBmYWxzZTsgZWxzZSByZXR1cm4gVEhST1dfUkFOR0UoKCdVbmtub3duIGdvYWwgc3ltYm9sIHZhbHVlOiBgJyArIG9wdGlvbnNfZ29hbE1vZGUpICsgJ2AnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59IGVsc2Uge1xuZ29hbE1vZGUgPSBvcHRpb25zX2dvYWxNb2RlO1xufVxubGV0IGNvbGxlY3RUb2tlbnMgPSAwO1xuaWYgKCh0eXBlb2Ygb3B0aW9uc19jb2xsZWN0VG9rZW5zKSA9PT0gJ3N0cmluZycpIHtcbmlmIChvcHRpb25zX2NvbGxlY3RUb2tlbnMgPT09ICdhbGwnKSBjb2xsZWN0VG9rZW5zID0gMjsgZWxzZSBpZiAob3B0aW9uc19jb2xsZWN0VG9rZW5zID09PSAnc29saWQnKSBjb2xsZWN0VG9rZW5zID0gMTsgZWxzZSBpZiAob3B0aW9uc19jb2xsZWN0VG9rZW5zID09PSAnbm9uZScpIGNvbGxlY3RUb2tlbnMgPSAwOyBlbHNlIGlmIChvcHRpb25zX2NvbGxlY3RUb2tlbnMgPT09ICd0eXBlcycpIGNvbGxlY3RUb2tlbnMgPSAzOyBlbHNlIHJldHVybiBUSFJPV19SQU5HRSgoJ1Vua25vd24gY29sbGVjdFRva2VucyB2YWx1ZTogYCcgKyBvcHRpb25zX2NvbGxlY3RUb2tlbnMpICsgJ2AnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59IGVsc2Uge1xuY29sbGVjdFRva2VucyA9IG9wdGlvbnNfY29sbGVjdFRva2Vucztcbn1cbmxldCBOT0RFX05BTUVfUFJPUEVSVFkgPSAoYmFiZWxDb21wYXQ/ICdPYmplY3RQcm9wZXJ0eScgOiAnUHJvcGVydHknKTtcbmxldCBOT0RFX05BTUVfTUVUSE9EX09CSkVDVCA9IChiYWJlbENvbXBhdD8gJ09iamVjdE1ldGhvZCcgOiAnUHJvcGVydHknKTtcbmxldCBOT0RFX05BTUVfTUVUSE9EX0NMQVNTID0gKGJhYmVsQ29tcGF0PyAnQ2xhc3NNZXRob2QnIDogJ01ldGhvZERlZmluaXRpb24nKTtcbmxldCB0b2sgPSBMZXhlcihjb2RlLCB7dGFyZ2V0RXNWZXJzaW9uLCBwYXJzaW5nR29hbDpnb2FsTW9kZSwgY29sbGVjdFRva2VucywgcmV0dXJuVG9rZW5zOihiYWJlbENvbXBhdD8gMiA6IDMpLCB3ZWJDb21wYXQ6b3B0aW9uc193ZWJDb21wYXQsIGdyYWNlZnVsRXJyb3JzOmZhbHNlLCB0b2tlblN0b3JhZ2U6b3B0aW9uc190b2tlblN0b3JhZ2UsIGJhYmVsVG9rZW5Db21wYXQsIGVycm9yQ29kZUZyYW1lLCB0cnVuY0NvZGVGcmFtZSwgJGxvZywgJHdhcm4sICRlcnJvcn0pO1xubGV0IHRva190aHJvdyA9IHRvay50aHJvdztcbmxldCB0b2tfbGV4RXJyb3IgPSB0b2subGV4RXJyb3I7XG5sZXQgdG9rX2FzaSA9IHRvay5hc2k7XG5sZXQgdG9rX3ByZXZFbmRDb2x1bW4gPSB0b2sucHJldkVuZENvbHVtbjtcbmxldCB0b2tfcHJldkVuZExpbmUgPSB0b2sucHJldkVuZExpbmU7XG5sZXQgdG9rX3ByZXZFbmRQb2ludGVyID0gdG9rLnByZXZFbmRQb2ludGVyO1xubGV0IHRva19jdXJyQ29sdW1uID0gdG9rLmN1cnJDb2x1bW47XG5sZXQgdG9rX2N1cnJMaW5lID0gdG9rLmN1cnJMaW5lO1xubGV0IHRva19jdXJyUG9pbnRlciA9IHRvay5jdXJyUG9pbnRlcjtcbmxldCB0b2tfbmV4dFRva2VuID0gdG9rLm5leHRUb2tlbjtcbmxldCB0b2tfZ2V0Tmx3YXMgPSB0b2suZ2V0Tmx3YXM7XG5sZXQgdG9rX2dldENhbm9OID0gdG9rLmdldENhbm9OO1xubGV0IHRva19nZXRUeXBlID0gdG9rLmdldFR5cGU7XG5sZXQgdG9rX2dldFN0YXJ0ID0gdG9rLmdldFN0YXJ0O1xubGV0IHRva19nZXRTdG9wID0gdG9rLmdldFN0b3A7XG5sZXQgdG9rX2dldExpbmUgPSB0b2suZ2V0TGluZTtcbmxldCB0b2tfZ2V0Q29sdW1uID0gdG9rLmdldENvbHVtbjtcbmxldCB0b2tfc2xpY2VJbnB1dCA9IHRvay5zbGljZUlucHV0O1xubGV0IGFzc2VydEV4cGVjdGVkRmFpbCA9ICcnO1xubGV0ICR0cF9hc3NlcnRFeHBlY3RlZF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9hc3NlcnRFeHBlY3RlZF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCBhbGxvd0V4cG9uZW50aWF0aW9uID0gKCh0YXJnZXRFc1ZlcnNpb24gPj0gNykgfHwgKHRhcmdldEVzVmVyc2lvbiA9PT0gSW5maW5pdHkpKTtcbmxldCBhbGxvd1RyYWlsaW5nRnVuY3Rpb25Db21tYSA9ICgodGFyZ2V0RXNWZXJzaW9uID49IDgpIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5sZXQgYWxsb3dBc3luY0Z1bmN0aW9ucyA9ICgodGFyZ2V0RXNWZXJzaW9uID49IDgpIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5sZXQgYWxsb3dBc3luY0dlbmVyYXRvcnMgPSAoKHRhcmdldEVzVmVyc2lvbiA+PSA5KSB8fCAodGFyZ2V0RXNWZXJzaW9uID09PSBJbmZpbml0eSkpO1xubGV0IGFsbG93QmFkRXNjYXBlc0luVGFnZ2VkVGVtcGxhdGVzID0gKCh0YXJnZXRFc1ZlcnNpb24gPj0gOSkgfHwgKHRhcmdldEVzVmVyc2lvbiA9PT0gSW5maW5pdHkpKTtcbmxldCBhbGxvd09wdGlvbmFsQ2F0Y2hCaW5kaW5nID0gKCh0YXJnZXRFc1ZlcnNpb24gPj0gMTApIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5sZXQgYWxsb3dEeW5hbWljSW1wb3J0ID0gKCh0YXJnZXRFc1ZlcnNpb24gPj0gMTEpIHx8ICh0YXJnZXRFc1ZlcnNpb24gPT09IEluZmluaXR5KSk7XG5sZXQgYWxsb3dFeHBvcnRTdGFyQXMgPSAoKHRhcmdldEVzVmVyc2lvbiA+PSAxMSkgfHwgKHRhcmdldEVzVmVyc2lvbiA9PT0gSW5maW5pdHkpKTtcbmlmIChnZXRMZXhlcikgZ2V0TGV4ZXIodG9rKTtcbmZ1bmN0aW9uIFRIUk9XX1JBTkdFKGRlc2MsIHRva2VuU3RhcnQsIHRva2VuU3RvcCwgLi4uYXJncykge1xuaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyAzIGFyZ3MgZm9yIFRIUk9XX1JBTkdFLCByZWNlaXZlZCAnICsgYXJndW1lbnRzLmxlbmd0aCk7XG5pZiAodG9rZW5TdGFydCA+IHRva2VuU3RvcCkgdGhyb3cgbmV3IEVycm9yKCgoKCdyYW5nZSBzaG91bGQgYmUgPj0wLCB3YXMgWycgKyB0b2tlblN0YXJ0KSArICcsICcpICsgdG9rZW5TdG9wKSArICddJyk7XG4kbG9nKCdcXG4nKTtcbiRsb2coJ0Vycm9yIGluIHBhcnNlcjonLCBkZXNjLCAncmVtYWluaW5nIHRocm93IGFyZ3M7JywgYXJncyk7XG5sZXQgZnVsbEVycm1zZyA9ICgnUGFyc2VyIGVycm9yISAnICsgZGVzYykgKyAoKCh0b2tfZ2V0VHlwZSgpID09PSAyMDk3MTczKT8gJyAoYXQgRU9GKScgOiAnJykpO1xudG9rX3Rocm93KGZ1bGxFcnJtc2csIHRva2VuU3RhcnQsIHRva2VuU3RvcCwgJycpO1xufVxubGV0IHVpZF9jb3VudGVyID0gMDtcbmxldCBfdHJlZSA9IHt0eXBlOidQcm9ncmFtJywgbG9jOnVuZGVmaW5lZCwgYm9keTpbXX07XG5pZiAoYmFiZWxDb21wYXQpIHtcbl90cmVlID0ge3R5cGU6J1Byb2dyYW0nLCBsb2M6dW5kZWZpbmVkLCBib2R5OltdLCBzb3VyY2VUeXBlOigoZ29hbE1vZGUgPT09IGZhbHNlKT8gJ3NjcmlwdCcgOiAnbW9kdWxlJyksIGludGVycHJldGVyOm51bGx9O1xufVxuaWYgKGFjb3JuQ29tcGF0KSB7XG5fdHJlZSA9IHt0eXBlOidQcm9ncmFtJywgbG9jOnVuZGVmaW5lZCwgYm9keTpbXSwgc291cmNlVHlwZTooKGdvYWxNb2RlID09PSBmYWxzZSk/ICdzY3JpcHQnIDogJ21vZHVsZScpfTtcbn1cbmxldCBfcGF0aCA9IFtfdHJlZV07XG5sZXQgX3BuYW1lcztcbmlmIChvcHRpb25zX2FzdFJvb3QpIHtcbm9wdGlvbnNfYXN0Um9vdC5yb290ID0gX3RyZWU7XG5vcHRpb25zX2FzdFJvb3QucGF0aCA9IF9wYXRoO1xufVxuZnVuY3Rpb24gQVNUX2dldENsb3NlZExvYygkdHBfZmlyc3Rfc3RhcnQsICR0cF9maXJzdF9saW5lLCAkdHBfZmlyc3RfY29sdW1uKSB7XG5yZXR1cm4gQVNUX2dldENsb3NlTG9jKCR0cF9maXJzdF9zdGFydCwgJHRwX2ZpcnN0X2xpbmUsICR0cF9maXJzdF9jb2x1bW4sIHRva19wcmV2RW5kUG9pbnRlcigpLCB0b2tfcHJldkVuZExpbmUoKSwgdG9rX3ByZXZFbmRDb2x1bW4oKSk7XG59XG5mdW5jdGlvbiBBU1RfZ2V0Q2xvc2VMb2Moc3RhcnRJbmRleCwgc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgZW5kSW5kZXgsIGVuZExpbmUsIGVuZENvbHVtbikge1xuaWYgKG9wdGlvbnNfcmFuZ2VzKSB7XG5yZXR1cm4ge3N0YXJ0OntsaW5lOnN0YXJ0TGluZSB8IDAsIGNvbHVtbjpzdGFydENvbHVtbiB8IDB9LCBlbmQ6e2xpbmU6ZW5kTGluZSB8IDAsIGNvbHVtbjplbmRDb2x1bW4gfCAwfSwgcmFuZ2U6e3N0YXJ0OnN0YXJ0SW5kZXggfCAwLCBlbmQ6ZW5kSW5kZXggfCAwfSwgc291cmNlOnNvdXJjZUZpZWxkfTtcbn1cbnJldHVybiB7c3RhcnQ6e2xpbmU6c3RhcnRMaW5lLCBjb2x1bW46c3RhcnRDb2x1bW59LCBlbmQ6e2xpbmU6ZW5kTGluZSwgY29sdW1uOmVuZENvbHVtbn0sIHNvdXJjZTpzb3VyY2VGaWVsZH07XG59XG5mdW5jdGlvbiBBU1Rfb3Blbihwcm9wLCBuZXdOb2RlKSB7XG5BU1Rfc2V0Tm9kZShwcm9wLCBuZXdOb2RlKTtcbl9wYXRoW19wYXRoLmxlbmd0aF0gPSBuZXdOb2RlO1xufVxuZnVuY3Rpb24gQVNUX2Nsb3NlKCR0cF9vcGVuX3N0YXJ0LCAkdHBfb3Blbl9saW5lLCAkdHBfb3Blbl9jb2x1bW4pIHtcbkFTVF9zZXQoJ2xvYycsIEFTVF9nZXRDbG9zZUxvYygkdHBfb3Blbl9zdGFydCwgJHRwX29wZW5fbGluZSwgJHRwX29wZW5fY29sdW1uLCB0b2tfcHJldkVuZFBvaW50ZXIoKSwgdG9rX3ByZXZFbmRMaW5lKCksIHRva19wcmV2RW5kQ29sdW1uKCkpKTtcbl9wYXRoLnBvcCgpO1xufVxuZnVuY3Rpb24gQVNUX2Nsb3NlVGVtcGxhdGVFbGVtZW50KGlzVGVtcGxhdGVEb3VibGUsICR0cF90aWNrX3N0YXJ0LCAkdHBfdGlja19saW5lLCAkdHBfdGlja19jb2x1bW4pIHtcbmxldCBjb2xFbmQgPSB0b2tfcHJldkVuZENvbHVtbigpIC0gMTtcbmxldCBwb2ludGVyRW5kID0gdG9rX3ByZXZFbmRQb2ludGVyKCk7XG5pZiAoaXNUZW1wbGF0ZURvdWJsZSkge1xuLS1jb2xFbmQ7XG4tLXBvaW50ZXJFbmQ7XG59XG5BU1Rfc2V0KCdsb2MnLCBBU1RfZ2V0Q2xvc2VMb2MoJHRwX3RpY2tfc3RhcnQsICR0cF90aWNrX2xpbmUsICR0cF90aWNrX2NvbHVtbiwgcG9pbnRlckVuZCwgdG9rX3ByZXZFbmRMaW5lKCksIGNvbEVuZCkpO1xuX3BhdGgucG9wKCk7XG59XG5mdW5jdGlvbiBBU1Rfc2V0KHByb3AsIHZhbHVlKSB7XG5fcGF0aFtfcGF0aC5sZW5ndGggLSAxXVtwcm9wXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gQVNUX3NldE5vZGUoYXN0UHJvcCwgbm9kZSkge1xuaWYgKGFzdFVpZHMpIG5vZGUuJHVpZCA9IHVpZF9jb3VudGVyKys7XG5sZXQgcGFyZW50Tm9kZSA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdO1xubGV0IHAgPSBwYXJlbnROb2RlW2FzdFByb3BdO1xuaWYgKEFycmF5LmlzQXJyYXkocCkpIHtcbnBbcC5sZW5ndGhdID0gbm9kZTtcbn0gZWxzZSB7XG5wYXJlbnROb2RlW2FzdFByb3BdID0gbm9kZTtcbn1cbn1cbmZ1bmN0aW9uIEFTVF9zZXROb2RlRGFuZ2Vyb3VzbHkoYXN0UHJvcCwgbm9kZSkge1xuaWYgKGFzdFVpZHMpIG5vZGUuJHVpZCA9IHVpZF9jb3VudGVyKys7XG5sZXQgcGFyZW50Tm9kZSA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdO1xubGV0IHAgPSBwYXJlbnROb2RlW2FzdFByb3BdO1xuaWYgKEFycmF5LmlzQXJyYXkocCkpIHtcbnBbcC5sZW5ndGhdID0gbm9kZTtcbn0gZWxzZSB7XG5wYXJlbnROb2RlW2FzdFByb3BdID0gbm9kZTtcbn1cbn1cbmZ1bmN0aW9uIEFTVF9zZXRJZGVudChhc3RQcm9wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKSB7XG5sZXQgaWRlbnROb2RlID0gQVNUX2dldElkZW50Tm9kZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKTtcbkFTVF9zZXROb2RlKGFzdFByb3AsIGlkZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBBU1RfZ2V0SWRlbnROb2RlKCR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24pIHtcbmxldCBjb2wgPSAkdHBfaWRlbnRfY29sdW1uO1xubGV0IGxpbmUgPSAkdHBfaWRlbnRfbGluZTtcbmxldCBsZW4gPSAkdHBfaWRlbnRfc3RvcCAtICR0cF9pZGVudF9zdGFydDtcbmxldCBjb2xFbmQgPSBjb2wgKyBsZW47XG5sZXQgaWRlbnROb2RlID0ge3R5cGU6J0lkZW50aWZpZXInLCBsb2M6QVNUX2dldENsb3NlTG9jKCR0cF9pZGVudF9zdGFydCwgbGluZSwgY29sLCAkdHBfaWRlbnRfc3RvcCwgbGluZSwgY29sRW5kKSwgbmFtZTokdHBfaWRlbnRfY2Fub259O1xuaWYgKGJhYmVsQ29tcGF0KSBpZGVudE5vZGUubG9jLmlkZW50aWZpZXJOYW1lID0gJHRwX2lkZW50X2Nhbm9uO1xucmV0dXJuIGlkZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIEFTVF9zZXRMaXRlcmFsKGFzdFByb3AsICR0cF9saXRfdHlwZSwgJHRwX2xpdF9zdGFydCwgJHRwX2xpdF9zdG9wLCAkdHBfbGl0X2xpbmUsICR0cF9saXRfY29sdW1uLCAkdHBfbGl0X2Nhbm9uKSB7XG5fQVNUX3NldExpdGVyYWwoYXN0UHJvcCwgJHRwX2xpdF90eXBlLCAkdHBfbGl0X3N0YXJ0LCAkdHBfbGl0X3N0b3AsICR0cF9saXRfbGluZSwgJHRwX2xpdF9jb2x1bW4sICR0cF9saXRfY2Fub24sIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIF9BU1Rfc2V0TGl0ZXJhbChhc3RQcm9wLCAkdHBfbGl0X3R5cGUsICR0cF9saXRfc3RhcnQsICR0cF9saXRfc3RvcCwgJHRwX2xpdF9saW5lLCAkdHBfbGl0X2NvbHVtbiwgJHRwX2xpdF9jYW5vbiwgZnJvbURpcmVjdGl2ZSkge1xuaWYgKGlzU3RyaW5nVG9rZW4oJHRwX2xpdF90eXBlKSkge1xuQVNUX3NldFN0cmluZ0xpdGVyYWwoYXN0UHJvcCwgJHRwX2xpdF9zdGFydCwgJHRwX2xpdF9zdG9wLCAkdHBfbGl0X2xpbmUsICR0cF9saXRfY29sdW1uLCAkdHBfbGl0X2Nhbm9uLCBmcm9tRGlyZWN0aXZlKTtcbn0gZWxzZSBpZiAoaXNOdW1iZXJUb2tlbigkdHBfbGl0X3R5cGUpKSB7XG5pZiAoaXNCaWdpbnRUb2tlbigkdHBfbGl0X3R5cGUpKSB7XG5BU1Rfc2V0QmlnSW50KGFzdFByb3AsICR0cF9saXRfc3RhcnQsICR0cF9saXRfc3RvcCwgJHRwX2xpdF9saW5lLCAkdHBfbGl0X2NvbHVtbik7XG59IGVsc2Uge1xuQVNUX3NldE51bWJlckxpdGVyYWwoYXN0UHJvcCwgJHRwX2xpdF90eXBlLCAkdHBfbGl0X3N0YXJ0LCAkdHBfbGl0X3N0b3AsICR0cF9saXRfbGluZSwgJHRwX2xpdF9jb2x1bW4pO1xufVxufSBlbHNlIHtcbkFTVF9zZXRSZWdleExpdGVyYWwoYXN0UHJvcCwgJHRwX2xpdF9zdGFydCwgJHRwX2xpdF9zdG9wLCAkdHBfbGl0X2xpbmUsICR0cF9saXRfY29sdW1uKTtcbn1cbn1cbmZ1bmN0aW9uIEFTVF9nZXRTdHJpbmdOb2RlKCR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfc3RvcCwgJHRwX3N0cmluZ19saW5lLCAkdHBfc3RyaW5nX2NvbHVtbiwgJHRwX3N0cmluZ19jYW5vbiwgZnJvbURpcmVjdGl2ZSkge1xuaWYgKGJhYmVsQ29tcGF0KSByZXR1cm4gQVNUX2JhYmVsR2V0U3RyaW5nTm9kZSgkdHBfc3RyaW5nX3N0YXJ0LCAkdHBfc3RyaW5nX3N0b3AsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sICR0cF9zdHJpbmdfY2Fub24sIGZyb21EaXJlY3RpdmUpO1xubGV0IG5vZGUgPSB7dHlwZTonTGl0ZXJhbCcsIGxvYzpBU1RfZ2V0Q2xvc2VMb2MoJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19saW5lLCAkdHBfc3RyaW5nX2NvbHVtbiwgdG9rX3ByZXZFbmRQb2ludGVyKCksIHRva19wcmV2RW5kTGluZSgpLCB0b2tfcHJldkVuZENvbHVtbigpKSwgdmFsdWU6JHRwX3N0cmluZ19jYW5vbiwgcmF3OnRva19zbGljZUlucHV0KCR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfc3RvcCl9O1xucmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBBU1Rfc2V0U3RyaW5nTGl0ZXJhbChhc3RQcm9wLCAkdHBfc3RyaW5nX3N0YXJ0LCAkdHBfc3RyaW5nX3N0b3AsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sICR0cF9zdHJpbmdfY2Fub24sIGZyb21EaXJlY3RpdmUpIHtcbmxldCBzdHJpbmdOb2RlID0gQVNUX2dldFN0cmluZ05vZGUoJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19zdG9wLCAkdHBfc3RyaW5nX2xpbmUsICR0cF9zdHJpbmdfY29sdW1uLCAkdHBfc3RyaW5nX2Nhbm9uLCBmcm9tRGlyZWN0aXZlKTtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHN0cmluZ05vZGUpO1xufVxuZnVuY3Rpb24gQVNUX2dldE51bWJlck5vZGUoJHRwX251bWJlcl90eXBlLCAkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pIHtcbmlmIChpc0JpZ2ludFRva2VuKCR0cF9udW1iZXJfdHlwZSkpIHJldHVybiBBU1RfZ2V0QmlnSW50Tm9kZSgkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pO1xuaWYgKGJhYmVsQ29tcGF0KSByZXR1cm4gQVNUX2JhYmVsR2V0TnVtYmVyTm9kZSgkdHBfbnVtYmVyX3R5cGUsICR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCwgJHRwX251bWJlcl9saW5lLCAkdHBfbnVtYmVyX2NvbHVtbik7XG5sZXQgc3RyID0gdG9rX3NsaWNlSW5wdXQoJHRwX251bWJlcl9zdGFydCwgJHRwX251bWJlcl9zdG9wKTtcbmxldCB2YWx1ZSA9ICgoJHRwX251bWJlcl90eXBlID09PSA0MTA1KT8gcGFyc2VGbG9hdChzdHIpIDogKCgoJHRwX251bWJlcl90eXBlID09PSA0MTA0KT8gcGFyc2VJbnQoc3RyLnNsaWNlKDIpLCAxNikgOiAoKCgkdHBfbnVtYmVyX3R5cGUgPT09IDQxMDYpPyBwYXJzZUludChzdHIuc2xpY2UoMiksIDIpIDogKCgoJHRwX251bWJlcl90eXBlID09PSA0MTA3KT8gcGFyc2VJbnQoc3RyLnNsaWNlKDIpLCA4KSA6ICgoKChzdHIuaW5jbHVkZXMoJzgnKSB8fCBzdHIuaW5jbHVkZXMoJzknKSkpPyBwYXJzZUZsb2F0KHN0ci5zbGljZSgxKSkgOiBwYXJzZUludChzdHIuc2xpY2UoMSksIDgpKSkpKSkpKSkpO1xucmV0dXJuIHt0eXBlOidMaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZUxvYygkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uLCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4gKyAoJHRwX251bWJlcl9zdG9wIC0gJHRwX251bWJlcl9zdGFydCkpLCB2YWx1ZTp2YWx1ZSwgcmF3OnN0cn07XG59XG5mdW5jdGlvbiBBU1Rfc2V0TnVtYmVyTGl0ZXJhbChhc3RQcm9wLCAkdHBfbnVtYmVyX3R5cGUsICR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCwgJHRwX251bWJlcl9saW5lLCAkdHBfbnVtYmVyX2NvbHVtbikge1xubGV0IG51bWJlck5vZGUgPSBBU1RfZ2V0TnVtYmVyTm9kZSgkdHBfbnVtYmVyX3R5cGUsICR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCwgJHRwX251bWJlcl9saW5lLCAkdHBfbnVtYmVyX2NvbHVtbik7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCBudW1iZXJOb2RlKTtcbn1cbmZ1bmN0aW9uIEFTVF9nZXRCaWdJbnROb2RlKCR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCwgJHRwX251bWJlcl9saW5lLCAkdHBfbnVtYmVyX2NvbHVtbikge1xuaWYgKGFjb3JuQ29tcGF0KSByZXR1cm4gQVNUX2Fjb3JuR2V0QmlnSW50Tm9kZSgkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pO1xuaWYgKGJhYmVsQ29tcGF0KSByZXR1cm4gQVNUX2JhYmVsR2V0QmlnSW50Tm9kZSgkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pO1xucmV0dXJuIHt0eXBlOidCaWdJbnRMaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZUxvYygkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uLCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4gKyAoJHRwX251bWJlcl9zdG9wIC0gJHRwX251bWJlcl9zdGFydCkpLCB2YWx1ZTpudWxsLCBiaWdpbnQ6dG9rX3NsaWNlSW5wdXQoJHRwX251bWJlcl9zdGFydCwgJHRwX251bWJlcl9zdG9wIC0gMSl9O1xufVxuZnVuY3Rpb24gQVNUX3NldEJpZ0ludChhc3RQcm9wLCAkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pIHtcbmxldCBiaWdpbnROb2RlID0gQVNUX2dldEJpZ0ludE5vZGUoJHRwX251bWJlcl9zdGFydCwgJHRwX251bWJlcl9zdG9wLCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uKTtcbkFTVF9zZXROb2RlKGFzdFByb3AsIGJpZ2ludE5vZGUpO1xufVxuZnVuY3Rpb24gQVNUX2dldFJlZ2V4Tm9kZSgkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9zdG9wLCAkdHBfcmVnZXhfbGluZSwgJHRwX3JlZ2V4X2NvbHVtbikge1xuaWYgKGFjb3JuQ29tcGF0KSByZXR1cm4gQVNUX2Fjb3JuR2V0UmVnZXhOb2RlKCR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X3N0b3AsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uKTtcbmlmIChiYWJlbENvbXBhdCkgcmV0dXJuIEFTVF9iYWJlbEdldFJlZ2V4Tm9kZSgkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9zdG9wLCAkdHBfcmVnZXhfbGluZSwgJHRwX3JlZ2V4X2NvbHVtbik7XG5sZXQgc3RyID0gdG9rX3NsaWNlSW5wdXQoJHRwX3JlZ2V4X3N0YXJ0LCAkdHBfcmVnZXhfc3RvcCk7XG5sZXQgcG9zID0gc3RyLmxhc3RJbmRleE9mKCcvJyk7XG5sZXQgYm9keSA9IHN0ci5zbGljZSgxLCBwb3MpO1xubGV0IHRhaWwgPSBzdHIuc2xpY2UocG9zICsgMSk7XG5yZXR1cm4ge3R5cGU6J0xpdGVyYWwnLCBsb2M6QVNUX2dldENsb3NlTG9jKCR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X2xpbmUsICR0cF9yZWdleF9jb2x1bW4sICR0cF9yZWdleF9zdG9wLCAkdHBfcmVnZXhfbGluZSwgJHRwX3JlZ2V4X2NvbHVtbiArICgkdHBfcmVnZXhfc3RvcCAtICR0cF9yZWdleF9zdGFydCkpLCB2YWx1ZTpudWxsLCByZWdleDp7cGF0dGVybjpib2R5LCBmbGFnczp0YWlsfSwgcmF3OnN0cn07XG59XG5mdW5jdGlvbiBBU1Rfc2V0UmVnZXhMaXRlcmFsKGFzdFByb3AsICR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X3N0b3AsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uKSB7XG5sZXQgcmVnZXhOb2RlID0gQVNUX2dldFJlZ2V4Tm9kZSgkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9zdG9wLCAkdHBfcmVnZXhfbGluZSwgJHRwX3JlZ2V4X2NvbHVtbik7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCByZWdleE5vZGUpO1xufVxuZnVuY3Rpb24gQVNUX2FkZChwcm9wLCB2YWx1ZSkge1xubGV0IGFyciA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdW3Byb3BdO1xuYXJyW2Fyci5sZW5ndGhdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBBU1RfcG9wTm9kZShwcm9wKSB7XG5sZXQgcGFyZW50ID0gX3BhdGhbX3BhdGgubGVuZ3RoIC0gMV07XG5sZXQgcCA9IHBhcmVudFtwcm9wXTtcbmlmIChBcnJheS5pc0FycmF5KHApKSB7XG5yZXR1cm4gcC5wb3AoKTtcbn0gZWxzZSB7XG5yZXR1cm4gcDtcbn1cbn1cbmZ1bmN0aW9uIEFTVF93cmFwQ2xvc2VkQ3VzdG9tKHByb3AsIG5ld05vZGUsIG5ld1Byb3ApIHtcbmxldCBjaGlsZCA9IEFTVF9wb3BOb2RlKHByb3ApO1xuQVNUX29wZW4ocHJvcCwgbmV3Tm9kZSk7XG5BU1Rfc2V0KG5ld1Byb3AsIGNoaWxkKTtcbn1cbmZ1bmN0aW9uIEFTVF93cmFwQ2xvc2VkSW50b0FycmF5Q3VzdG9tKHByb3AsIG5ld05vZGUsIG5ld1Byb3ApIHtcbmxldCBjaGlsZCA9IEFTVF9wb3BOb2RlKHByb3ApO1xuQVNUX29wZW4ocHJvcCwgbmV3Tm9kZSk7XG5BU1Rfc2V0KG5ld1Byb3AsIFtjaGlsZF0pO1xufVxuZnVuY3Rpb24gQVNUX2Rlc3RydWN0KHByb3ApIHtcbmxldCBwYXJlbnQgPSBfcGF0aFtfcGF0aC5sZW5ndGggLSAxXTtcbmxldCBub2RlID0gcGFyZW50W3Byb3BdO1xuaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbmxldCBsYXN0ID0gbm9kZS5sZW5ndGggLSAxO1xuQVNUX19kZXN0cnVjdChub2RlW2xhc3RdLCBub2RlLCBsYXN0KTtcbnJldHVybjtcbn1cbkFTVF9fZGVzdHJ1Y3Qobm9kZSwgcGFyZW50LCBwcm9wKTtcbn1cbmZ1bmN0aW9uIEFTVF9fZGVzdHJ1Y3Qobm9kZSwgcGFyZW50LCBhc3RQcm9wKSB7XG5zd2l0Y2ggKG5vZGUudHlwZSkge1xuY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbm5vZGUudHlwZSA9ICdBcnJheVBhdHRlcm4nO1xubGV0IGVsZW1lbnRzID0gbm9kZS5lbGVtZW50cztcbmxldCBlID0gZWxlbWVudHMubGVuZ3RoO1xuZm9yIChsZXQgaSA9IDA7aSA8IGU7KytpKSB7XG5sZXQgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuaWYgKGVsZW1lbnQpIEFTVF9fZGVzdHJ1Y3QoZWxlbWVudCwgZWxlbWVudHMsIGkpO1xufVxucmV0dXJuO1xuY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG5ub2RlLnR5cGUgPSAnT2JqZWN0UGF0dGVybic7XG5sZXQgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcbmxldCBuID0gcHJvcGVydGllcy5sZW5ndGg7XG5mb3IgKGxldCBpID0gMDtpIDwgbjsrK2kpIHtcbmlmIChwcm9wZXJ0aWVzW2ldLnR5cGUgPT09IE5PREVfTkFNRV9QUk9QRVJUWSkge1xuXG59IGVsc2Uge1xuXG59XG5BU1RfX2Rlc3RydWN0KHByb3BlcnRpZXNbaV0sIHByb3BlcnRpZXMsIGkpO1xufVxucmV0dXJuO1xuY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuQVNUX19kZXN0cnVjdChub2RlLmxlZnQsIG5vZGUsICdsZWZ0Jyk7XG5BU1RfZGVzdHJ1Y3RSZXBsYWNlQXNzaWdubWVudChwYXJlbnQsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSBOT0RFX05BTUVfUFJPUEVSVFk6XG5BU1RfX2Rlc3RydWN0KG5vZGUudmFsdWUsIG5vZGUsICd2YWx1ZScpO1xucmV0dXJuO1xuY2FzZSAnU3ByZWFkRWxlbWVudCc6XG5ub2RlLnR5cGUgPSAnUmVzdEVsZW1lbnQnO1xuQVNUX19kZXN0cnVjdChub2RlLmFyZ3VtZW50LCBub2RlLCAnYXJndW1lbnQnKTtcbnJldHVybjtcbn1cbn1cbmZ1bmN0aW9uIEFTVF9kZXN0cnVjdFJlcGxhY2VBc3NpZ25tZW50KHBhcmVudE5vZGUsIHByb3ApIHtcbmxldCBvbGROb2RlID0gcGFyZW50Tm9kZVtwcm9wXTtcbmlmIChvbGROb2RlLm9wZXJhdG9yICE9PSAnPScpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBzaG91bGQgYmUgYSByZWd1bGFyIGFzc2lnbm1lbnQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5sZXQgbmV3Tm9kZSA9IHt0eXBlOidBc3NpZ25tZW50UGF0dGVybicsIGxvYzpvbGROb2RlLmxvYywgbGVmdDpvbGROb2RlLmxlZnQsIHJpZ2h0Om9sZE5vZGUucmlnaHR9O1xucGFyZW50Tm9kZVtwcm9wXSA9IG5ld05vZGU7XG59XG5mdW5jdGlvbiBBU1RfY29udmVydEFycmF5VG9QYXR0ZXJuKCR0cF9lcV90eXBlLCBhc3RQcm9wKSB7XG5pZiAoJHRwX2VxX3R5cGUgPT09IDQ5MjY0KSB7XG5sZXQgbm9kZSA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdW2FzdFByb3BdO1xuaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbm5vZGUgPSBub2RlW25vZGUubGVuZ3RoIC0gMV07XG59XG5pZiAoKChub2RlLnR5cGUgPT09ICdBcnJheUV4cHJlc3Npb24nKSB8fCAobm9kZS50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpKSkge1xuQVNUX2Rlc3RydWN0KGFzdFByb3ApO1xufVxufVxufVxuZnVuY3Rpb24gQVNUX3Rocm93SWZJbGxlZ2FsVXBkYXRlQXJnKGFzdFByb3ApIHtcbmxldCBoZWFkID0gX3BhdGhbX3BhdGgubGVuZ3RoIC0gMV07XG5sZXQgcHJldiA9IChoZWFkICYmIGhlYWRbYXN0UHJvcF0pO1xuaWYgKCgoIXByZXYpIHx8ICgoKHByZXYgaW5zdGFuY2VvZiBBcnJheSk/ICgoKCFwcmV2Lmxlbmd0aCkgfHwgKCgocHJldltwcmV2Lmxlbmd0aCAtIDFdLnR5cGUgIT09ICdJZGVudGlmaWVyJykgJiYgKHByZXZbcHJldi5sZW5ndGggLSAxXS50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpKSkpKSA6ICgoKHByZXYudHlwZSAhPT0gJ0lkZW50aWZpZXInKSAmJiAocHJldi50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpKSkpKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2FuIG9ubHkgaW5jcmVtZW50IG9yIGRlY3JlbWVudCBhbiBpZGVudGlmaWVyIG9yIG1lbWJlciBleHByZXNzaW9uJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuZnVuY3Rpb24gQVNUX3BhdGNoQXN5bmNDYWxsKCR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGFzdFByb3ApIHtcbmxldCBub2RlID0gX3BhdGhbX3BhdGgubGVuZ3RoIC0gMV07XG5sZXQgYXJncyA9IG5vZGVbYXN0UHJvcF07XG5pZiAoYXJncyBpbnN0YW5jZW9mIEFycmF5KSBhcmdzID0gYXJnc1swXTtcbmlmIChhcmdzLnR5cGUgPT09ICdTZXF1ZW5jZUV4cHJlc3Npb24nKSBhcmdzID0gYXJncy5leHByZXNzaW9uczsgZWxzZSBhcmdzID0gW2FyZ3NdO1xuaWYgKG5vZGVbYXN0UHJvcF0gaW5zdGFuY2VvZiBBcnJheSkgbm9kZVthc3RQcm9wXSA9IFtdOyBlbHNlIG5vZGVbYXN0UHJvcF0gPSB1bmRlZmluZWQ7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonQ2FsbEV4cHJlc3Npb24nLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uKSwgY2FsbGVlOkFTVF9nZXRJZGVudE5vZGUoJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiksIGFyZ3VtZW50czphcmdzfSk7XG59XG5mdW5jdGlvbiBBU1RfYmFiZWxEaXJlY3RpdmVzKCkge1xubGV0IG5vZGUgPSBfcGF0aFtfcGF0aC5sZW5ndGggLSAxXTtcbmxldCBkaXJzID0gW107XG5BU1Rfc2V0KCdkaXJlY3RpdmVzJywgZGlycyk7XG53aGlsZSAoKG5vZGUuYm9keS5sZW5ndGggJiYgKG5vZGUuYm9keVswXS5kaXJlY3RpdmUgIT09IHVuZGVmaW5lZCkpKSB7XG5sZXQgZGlyID0gbm9kZS5ib2R5LnNoaWZ0KCk7XG5kaXJzW2RpcnMubGVuZ3RoXSA9IHt0eXBlOidEaXJlY3RpdmUnLCBsb2M6ZGlyLmxvYywgdmFsdWU6ZGlyLmV4cHJlc3Npb259O1xuZGlyLmV4cHJlc3Npb24udHlwZSA9ICdEaXJlY3RpdmVMaXRlcmFsJztcbn1cbn1cbmZ1bmN0aW9uIEFTVF9iYWJlbFBhcmVudGhlc2l6ZXNDbG9zZWQoJHRwX3BhcmVuT3Blbl9zdGFydCwgYXN0UHJvcCkge1xubGV0IHBhcmVudCA9IF9wYXRoW19wYXRoLmxlbmd0aCAtIDFdO1xubGV0IGNoaWxkID0gcGFyZW50W2FzdFByb3BdO1xuaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG5jaGlsZCA9IGNoaWxkW2NoaWxkLmxlbmd0aCAtIDFdO1xufVxuaWYgKGNoaWxkLmV4dHJhKSB7XG5jaGlsZC5leHRyYS5wYXJlbnRoZXNpemVkID0gdHJ1ZTtcbmNoaWxkLmV4dHJhLnBhcmVuU3RhcnQgPSAkdHBfcGFyZW5PcGVuX3N0YXJ0O1xufSBlbHNlIHtcbmNoaWxkLmV4dHJhID0ge3BhcmVudGhlc2l6ZWQ6dHJ1ZSwgcGFyZW5TdGFydDokdHBfcGFyZW5PcGVuX3N0YXJ0fTtcbn1cbn1cbmZ1bmN0aW9uIEFTVF9iYWJlbEFkZENvbW1lbnQoJHRwX2NvbW1lbnRfc3RhcnQsICR0cF9jb21tZW50X3N0b3AsICR0cF9jb21tZW50X2xpbmUsICR0cF9jb21tZW50X2NvbHVtbiwgJHRwX2NvbW1lbnRfdHlwZSkge1xuaWYgKCFfcGF0aFtfcGF0aC5sZW5ndGggLSAxXS5pbm5lckNvbW1lbnRzKSBfcGF0aFtfcGF0aC5sZW5ndGggLSAxXS5pbm5lckNvbW1lbnRzID0gW107XG5sZXQgc3RyID0gdG9rX3NsaWNlSW5wdXQoJHRwX2NvbW1lbnRfc3RhcnQsICR0cF9jb21tZW50X3N0b3ApO1xubGV0IHR5cGVOYW1lID0gJ0NvbW1lbnRMaW5lJztcbmxldCB2YWx1ZSA9ICcnO1xuaWYgKCR0cF9jb21tZW50X3R5cGUgPT09IDEyODUpIHtcbnZhbHVlID0gdG9rX3NsaWNlSW5wdXQoJHRwX2NvbW1lbnRfc3RhcnQgKyAyLCAkdHBfY29tbWVudF9zdG9wKTtcbn0gZWxzZSBpZiAoJHRwX2NvbW1lbnRfdHlwZSA9PT0gMTI4Nikge1xudHlwZU5hbWUgPSAnQ29tbWVudEJsb2NrJztcbnZhbHVlID0gdG9rX3NsaWNlSW5wdXQoJHRwX2NvbW1lbnRfc3RhcnQgKyAyLCAkdHBfY29tbWVudF9zdG9wIC0gMik7XG59IGVsc2Uge1xudmFsdWUgPSAoKHN0ci5zbGljZSgwLCAzKSA9PT0gJy0tPicpPyB0b2tfc2xpY2VJbnB1dCgkdHBfY29tbWVudF9zdGFydCArIDMsICR0cF9jb21tZW50X3N0b3ApIDogdG9rX3NsaWNlSW5wdXQoJHRwX2NvbW1lbnRfc3RhcnQgKyA0LCAkdHBfY29tbWVudF9zdG9wKSk7XG59XG5sZXQgY29tbWVudE5vZGUgPSB7dHlwZTp0eXBlTmFtZSwgbG9jOkFTVF9nZXRDbG9zZUxvYygkdHBfY29tbWVudF9zdGFydCwgJHRwX2NvbW1lbnRfbGluZSwgJHRwX2NvbW1lbnRfY29sdW1uLCB0b2tfY3VyclBvaW50ZXIoKSwgdG9rX2N1cnJMaW5lKCksIHRva19jdXJyQ29sdW1uKCkpLCB2YWx1ZTp2YWx1ZX07XG5BU1Rfc2V0Tm9kZSgnaW5uZXJDb21tZW50cycsIGNvbW1lbnROb2RlKTtcbnJldHVybiBjb21tZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIEFTVF9iYWJlbEdldFN0cmluZ05vZGUoJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19zdG9wLCAkdHBfc3RyaW5nX2xpbmUsICR0cF9zdHJpbmdfY29sdW1uLCAkdHBfc3RyaW5nX2Nhbm9uLCBmcm9tRGlyZWN0aXZlKSB7XG5sZXQgc3RyID0gdG9rX3NsaWNlSW5wdXQoJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19zdG9wKTtcbmxldCB2YWx1ZSA9IChmcm9tRGlyZWN0aXZlPyBzdHIuc2xpY2UoMSwgLTEpIDogJHRwX3N0cmluZ19jYW5vbik7XG5yZXR1cm4ge3R5cGU6J1N0cmluZ0xpdGVyYWwnLCBsb2M6QVNUX2dldENsb3NlTG9jKCR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sIHRva19wcmV2RW5kUG9pbnRlcigpLCB0b2tfcHJldkVuZExpbmUoKSwgdG9rX3ByZXZFbmRDb2x1bW4oKSksIHZhbHVlOnZhbHVlLCBleHRyYTp7cmF3VmFsdWU6dmFsdWUsIHJhdzpzdHJ9fTtcbn1cbmZ1bmN0aW9uIEFTVF9iYWJlbEdldE51bWJlck5vZGUoJHRwX251bWJlcl90eXBlLCAkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pIHtcbmxldCBzdHIgPSB0b2tfc2xpY2VJbnB1dCgkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3ApO1xubGV0IHZhbHVlID0gKCgkdHBfbnVtYmVyX3R5cGUgPT09IDQxMDUpPyBwYXJzZUZsb2F0KHN0cikgOiAoKCgkdHBfbnVtYmVyX3R5cGUgPT09IDQxMDQpPyBwYXJzZUludChzdHIuc2xpY2UoMiksIDE2KSA6ICgoKCR0cF9udW1iZXJfdHlwZSA9PT0gNDEwNik/IHBhcnNlSW50KHN0ci5zbGljZSgyKSwgMikgOiAoKCgkdHBfbnVtYmVyX3R5cGUgPT09IDQxMDcpPyBwYXJzZUludChzdHIuc2xpY2UoMiksIDgpIDogKCgoKHN0ci5pbmNsdWRlcygnOCcpIHx8IHN0ci5pbmNsdWRlcygnOScpKSk/IHBhcnNlRmxvYXQoc3RyLnNsaWNlKDEpKSA6IHBhcnNlSW50KHN0ci5zbGljZSgxKSwgOCkpKSkpKSkpKSk7XG5yZXR1cm4ge3R5cGU6J051bWVyaWNMaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZUxvYygkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uLCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4gKyAoJHRwX251bWJlcl9zdG9wIC0gJHRwX251bWJlcl9zdGFydCkpLCB2YWx1ZTp2YWx1ZSwgZXh0cmE6e3Jhd1ZhbHVlOnZhbHVlLCByYXc6c3RyfX07XG59XG5mdW5jdGlvbiBBU1RfYmFiZWxHZXRCaWdJbnROb2RlKCR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCwgJHRwX251bWJlcl9saW5lLCAkdHBfbnVtYmVyX2NvbHVtbikge1xubGV0IHN0ciA9IHRva19zbGljZUlucHV0KCR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCAtIDEpO1xucmV0dXJuIHt0eXBlOidCaWdJbnRMaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZUxvYygkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uLCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4gKyAoJHRwX251bWJlcl9zdG9wIC0gJHRwX251bWJlcl9zdGFydCkpLCB2YWx1ZTpzdHIsIGV4dHJhOntyYXdWYWx1ZTpzdHIsIHJhdzpzdHIgKyAnbid9fTtcbn1cbmZ1bmN0aW9uIEFTVF9iYWJlbEdldFJlZ2V4Tm9kZSgkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9zdG9wLCAkdHBfcmVnZXhfbGluZSwgJHRwX3JlZ2V4X2NvbHVtbikge1xubGV0IHN0ciA9IHRva19zbGljZUlucHV0KCR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X3N0b3ApO1xubGV0IHBvcyA9IHN0ci5sYXN0SW5kZXhPZignLycpO1xubGV0IGJvZHkgPSBzdHIuc2xpY2UoMSwgcG9zKTtcbmxldCB0YWlsID0gc3RyLnNsaWNlKHBvcyArIDEpO1xucmV0dXJuIHt0eXBlOidSZWdFeHBMaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZUxvYygkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uLCAkdHBfcmVnZXhfc3RvcCwgJHRwX3JlZ2V4X2xpbmUsICR0cF9yZWdleF9jb2x1bW4gKyAoJHRwX3JlZ2V4X3N0b3AgLSAkdHBfcmVnZXhfc3RhcnQpKSwgcGF0dGVybjpib2R5LCBmbGFnczp0YWlsLCBleHRyYTp7cmF3VmFsdWU6dW5kZWZpbmVkLCByYXc6c3RyfSwgdmFsdWU6dW5kZWZpbmVkfTtcbn1cbmZ1bmN0aW9uIEFTVF9hY29ybkdldEJpZ0ludE5vZGUoJHRwX251bWJlcl9zdGFydCwgJHRwX251bWJlcl9zdG9wLCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uKSB7XG5sZXQgc3RybiA9IHRva19zbGljZUlucHV0KCR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfc3RvcCk7XG5sZXQgc3RyID0gc3Rybi5zbGljZSgwLCAtMSk7XG5yZXR1cm4ge3R5cGU6J0xpdGVyYWwnLCBsb2M6QVNUX2dldENsb3NlTG9jKCR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4sICR0cF9udW1iZXJfc3RvcCwgJHRwX251bWJlcl9saW5lLCAkdHBfbnVtYmVyX2NvbHVtbiArICgkdHBfbnVtYmVyX3N0b3AgLSAkdHBfbnVtYmVyX3N0YXJ0KSksIHJhdzpzdHJuLCBiaWdpbnQ6c3RyLCB2YWx1ZTpCaWdJbnQoc3RyKX07XG59XG5mdW5jdGlvbiBBU1RfYWNvcm5HZXRSZWdleE5vZGUoJHRwX3JlZ2V4X3N0YXJ0LCAkdHBfcmVnZXhfc3RvcCwgJHRwX3JlZ2V4X2xpbmUsICR0cF9yZWdleF9jb2x1bW4pIHtcbmxldCBzdHIgPSB0b2tfc2xpY2VJbnB1dCgkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9zdG9wKTtcbmxldCBwb3MgPSBzdHIubGFzdEluZGV4T2YoJy8nKTtcbmxldCBib2R5ID0gc3RyLnNsaWNlKDEsIHBvcyk7XG5sZXQgdGFpbCA9IHN0ci5zbGljZShwb3MgKyAxKTtcbnJldHVybiB7dHlwZTonTGl0ZXJhbCcsIGxvYzpBU1RfZ2V0Q2xvc2VMb2MoJHRwX3JlZ2V4X3N0YXJ0LCAkdHBfcmVnZXhfbGluZSwgJHRwX3JlZ2V4X2NvbHVtbiwgJHRwX3JlZ2V4X3N0b3AsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uICsgKCR0cF9yZWdleF9zdG9wIC0gJHRwX3JlZ2V4X3N0YXJ0KSksIHZhbHVlOm5ldyBSZWdFeHAoYm9keSwgdGFpbCksIHJlZ2V4OntwYXR0ZXJuOmJvZHksIGZsYWdzOnRhaWx9LCByYXc6c3RyfTtcbn1cbmZ1bmN0aW9uIGluaXRMZXhlcihsZXhlckZsYWdzKSB7XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBSZXgobGV4ZXJGbGFncykge1xuX3NraXAobGV4ZXJGbGFncyB8IDQpO1xufVxuZnVuY3Rpb24gc2tpcERpdihsZXhlckZsYWdzKSB7XG5fc2tpcChsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBBbnkobGV4ZXJGbGFncykge1xuX3NraXAobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBfc2tpcChsZXhlckZsYWdzKSB7XG50b2tfbmV4dFRva2VuKGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwOTcxNzUpIHtcbnJldHVybiB0b2tfbGV4RXJyb3IoKTtcbn1cbmlmICghYmFiZWxDb21wYXQpIHJldHVybjtcbmxldCAkdHBfbWF5YmVDb21tZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9tYXliZUNvbW1lbnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX21heWJlQ29tbWVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX21heWJlQ29tbWVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9tYXliZUNvbW1lbnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG53aGlsZSAoaXNDb21tZW50VG9rZW4oJHRwX21heWJlQ29tbWVudF90eXBlKSkge1xudG9rX25leHRUb2tlbihsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAyMDk3MTc1KSB7XG5yZXR1cm4gdG9rX2xleEVycm9yKCk7XG59XG5BU1RfYmFiZWxBZGRDb21tZW50KCR0cF9tYXliZUNvbW1lbnRfc3RhcnQsICR0cF9tYXliZUNvbW1lbnRfc3RvcCwgJHRwX21heWJlQ29tbWVudF9saW5lLCAkdHBfbWF5YmVDb21tZW50X2NvbHVtbiwgJHRwX21heWJlQ29tbWVudF90eXBlKTtcbiR0cF9tYXliZUNvbW1lbnRfdHlwZSA9IHRva19nZXRUeXBlKCk7XG4kdHBfbWF5YmVDb21tZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xuJHRwX21heWJlQ29tbWVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG4kdHBfbWF5YmVDb21tZW50X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG4kdHBfbWF5YmVDb21tZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xufVxufVxuZnVuY3Rpb24gc2tpcFRvUGFyZW5PcGVuT3JEaWUobGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3MSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnRXhwZWN0ZWQgdG8gcGFyc2UgYW4gb3BlbmluZyBwYXJlbiwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG59XG5mdW5jdGlvbiBza2lwVG9DdXJseU9wZW5PckRpZShsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTEzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0byBwYXJzZSBhbiBvcGVuaW5nIGN1cmx5LCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmZ1bmN0aW9uIHNraXBUb0Zyb21PckRpZShsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDIwOTQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ05leHQgdG9rZW4gc2hvdWxkIGJlIHRoZSBpZGVudCBgZnJvbWAgYnV0IHdhcyBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmZ1bmN0aW9uIHNraXBUb1N0cmluZ09yRGllKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG5pZiAoIWlzU3RyaW5nVG9rZW4odG9rX2dldFR5cGUoKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ05leHQgdG9rZW4gc2hvdWxkIGJlIGEgc3RyaW5nIGJ1dCB3YXMgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG59XG5mdW5jdGlvbiBza2lwVG9JZGVudE9yRGllKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG5pZiAoIWlzSWRlbnRUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnTmV4dCB0b2tlbiBzaG91bGQgYmUgYW4gaWRlbnQgYnV0IHdhcyBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmZ1bmN0aW9uIHNraXBUb0Fycm93T3JEaWUobGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ5OSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnTmV4dCB0b2tlbiBzaG91bGQgYmUgYD0+YCBidXQgd2FzIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuZnVuY3Rpb24gc2tpcFRvQXNDb21tYUN1cmx5Q2xvc2UobGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb0FzQ29tbWFGcm9tKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBza2lwVG9Db2xvbk9yRGllKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0ODkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ05leHQgdG9rZW4gc2hvdWxkIGJlIGA6YCBidXQgd2FzIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuZnVuY3Rpb24gc2tpcFRvVGFyZ2V0T3JEaWUobGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAyMTE2KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdOZXh0IHRva2VuIHNob3VsZCBiZSBgdGFyZ2V0YCBidXQgd2FzIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuZnVuY3Rpb24gc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncykge1xuc2tpcFJleChsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKSB7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvRXhwcmVzc2lvblN0YXJ0R3JvdXBlZChsZXhlckZsYWdzKSB7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvRXhwcmVzc2lvblN0YXJ0U2VtaShsZXhlckZsYWdzKSB7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvRXhwcmVzc2lvblN0YXJ0U3F1YXJlQ2xvc2VDb21tYShsZXhlckZsYWdzKSB7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvQWZ0ZXJOZXcobGV4ZXJGbGFncykge1xuc2tpcFJleChsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb1N3aXRjaEJvZHkobGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb0JpbmRpbmdTdGFydChsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvQmluZGluZ1N0YXJ0R3JvdXBlZChsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvQ29sb25QYXJlbk9wZW4obGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb0lkZW50UGFyZW5PcGVuKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBza2lwVG9JZGVudFN0YXJQYXJlbk9wZW4obGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb0lkZW50U3RhckN1cmx5T3BlbihsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvSWRlbnRDdXJseU9wZW4obGV4ZXJGbGFncykge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHNraXBUb0lkZW50Q3VybHlDbG9zZShsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvSWRlbnRTdGFyQ3VybHlPcGVuUGFyZW5PcGVuU3RyaW5nKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBza2lwVG9Bd2FpdFBhcmVuT3BlbihsZXhlckZsYWdzKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gc2tpcFRvSWRlbnRTdHJpbmdOdW1iZXJTcXVhcmVPcGVuKGxleGVyRmxhZ3MpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBza2lwSWRlbnRTYWZlU2xvd0FuZEV4cGVuc2l2ZShsZXhlckZsYWdzLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uKSB7XG5zd2l0Y2ggKHRva19nZXRUeXBlKCkpIHtcbmNhc2UgMjA4NDpcblxuY2FzZSAyMTIxOlxuXG5jYXNlIDIxMjM6XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBIHVuYXJ5IGV4cHJlc3Npb24gaXMgbm90IGFsbG93ZWQgaGVyZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbnJldHVybjtcbmNhc2UgMjEwNDpcbnNraXBUb0FmdGVyTmV3KGxleGVyRmxhZ3MpO1xucmV0dXJuO1xuY2FzZSAyMDc1OlxuaWYgKCgoZ29hbE1vZGUgPT09IHRydWUpIHx8ICgobGV4ZXJGbGFncyAmIDgpICE9PSAwKSkpIHtcbmlmIChsZWZ0SGFuZFNpZGVFeHByZXNzaW9uID09PSB0cnVlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0FuIGBhd2FpdGAgZXhwcmVzc2lvbiBpcyBub3QgYWxsb3dlZCBoZXJlJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xucmV0dXJuO1xufVxuc2tpcERpdihsZXhlckZsYWdzKTtcbnJldHVybiAwO1xuY2FzZSAyMTI2OlxuaWYgKChsZXhlckZsYWdzICYgODMyMCkgIT09IDApIHtcbmlmIChsZWZ0SGFuZFNpZGVFeHByZXNzaW9uID09PSB0cnVlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0EgYHlpZWxkYCBleHByZXNzaW9uIGlzIG5vdCBhbGxvd2VkIGhlcmUnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xucmV0dXJuO1xufVxuc2tpcERpdihsZXhlckZsYWdzKTtcbnJldHVybjtcbn1cbnNraXBEaXYobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBwYXJzZVRvcExldmVscyhsZXhlckZsYWdzKSB7XG5sZXQgc2Nvb3AgPSBTQ09QRV9jcmVhdGVHbG9iYWwoJ19wYXJzZVRvcExldmVscycpO1xuaWYgKG9wdGlvbnNfZXhwb3NlU2NvcGVzKSBBU1Rfc2V0KCckc2NvcGUnLCBzY29vcCk7XG5sZXQgZXhwb3J0ZWROYW1lcyA9IG5ldyBTZXQoKTtcbmxldCBleHBvcnRlZEJpbmRpbmdzID0gbmV3IFNldCgpO1xubGV0IGxlbjtcbmxldCBiYWs7XG5wYXJzZUJvZHlQYXJ0c1dpdGhEaXJlY3RpdmVzKGxleGVyRmxhZ3MsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCAxLCAwLCAwLCAwLCAwLCAwLCAnJywgdHJ1ZSwgJ2JvZHknKTtcbmlmIChnb2FsTW9kZSA9PT0gdHJ1ZSkge1xubGV0IGdsb2JhbE5hbWVzID0gc2Nvb3AubmFtZXM7XG5leHBvcnRlZEJpbmRpbmdzLmZvckVhY2gobmFtZSA9PiB7XG5pZiAoKChuYW1lICE9PSAnZGVmYXVsdCcpICYmICgoKGdsb2JhbE5hbWVzID09PSBudWxsKSB8fCAoIWdsb2JhbE5hbWVzLmhhcyhuYW1lKSkpKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cG9ydGluZyBhIG5hbWUgdGhhdCB3YXMgbm90IGJvdW5kIGluIGdsb2JhbDogYCcgKyBuYW1lKSArICdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufSk7XG59XG59XG5mdW5jdGlvbiBTQ09QRV9jcmVhdGVHbG9iYWwoZGVzYykge1xubGV0IHNjb29wID0ge3BhcmVudDpudWxsLCB0eXBlOjAsIG5hbWVzOm51bGwsIGR1cGVQYXJhbUVycm9yU3RhcnQ6MCwgZHVwZVBhcmFtRXJyb3JTdG9wOjB9O1xuaWYgKGFzdFVpZHMpIHNjb29wLiR1aWQgPSB1aWRfY291bnRlcisrO1xucmV0dXJuIHNjb29wO1xufVxuZnVuY3Rpb24gU0NPUEVfYWRkTGF5ZXIoc2Nvb3AsIHNjb3BlVHlwZSwgZGVzYykge1xubGV0IHNjb29wTmV3ID0ge3BhcmVudDpzY29vcCwgdHlwZTpzY29wZVR5cGUsIG5hbWVzOm51bGwsIGR1cGVQYXJhbUVycm9yU3RhcnQ6MCwgZHVwZVBhcmFtRXJyb3JTdG9wOjB9O1xucmV0dXJuIHNjb29wTmV3O1xufVxuZnVuY3Rpb24gU0NPUEVfYWRkRnVuY0RlY2xOYW1lKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfYmluZGluZ0lkZW50X3N0YXJ0LCAkdHBfYmluZGluZ0lkZW50X3N0b3AsICR0cF9iaW5kaW5nSWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCBmZFN0YXRlKSB7XG5pZiAoYmluZGluZ1R5cGUgPT09IDMpIHtcblNDT1BFX2FkZFZhckJpbmRpbmcobGV4ZXJGbGFncywgc2Nvb3AsICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQsICR0cF9iaW5kaW5nSWRlbnRfc3RvcCwgJHRwX2JpbmRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUpO1xufSBlbHNlIHtcblNDT1BFX2FkZExleEJpbmRpbmcoc2Nvb3AsICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQsICR0cF9iaW5kaW5nSWRlbnRfc3RvcCwgJHRwX2JpbmRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGZkU3RhdGUpO1xufVxufVxuZnVuY3Rpb24gU0NPUEVfYWN0dWFsbHlBZGRCaW5kaW5nKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfYmluZGluZ0lkZW50X3N0YXJ0LCAkdHBfYmluZGluZ0lkZW50X3N0b3AsICR0cF9iaW5kaW5nSWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKSB7XG5pZiAoYmluZGluZ1R5cGUgPT09IDIpIHtcblNDT1BFX2FkZFZhckJpbmRpbmcobGV4ZXJGbGFncywgc2Nvb3AsICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQsICR0cF9iaW5kaW5nSWRlbnRfc3RvcCwgJHRwX2JpbmRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUpO1xufSBlbHNlIHtcblNDT1BFX2FkZExleEJpbmRpbmcoc2Nvb3AsICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQsICR0cF9iaW5kaW5nSWRlbnRfc3RvcCwgJHRwX2JpbmRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIDEpO1xufVxufVxuZnVuY3Rpb24gU0NPUEVfYWRkVmFyQmluZGluZyhsZXhlckZsYWdzLCBzY29vcCwgJHRwX2JpbmRpbmdJZGVudF9zdGFydCwgJHRwX2JpbmRpbmdJZGVudF9zdG9wLCAkdHBfYmluZGluZ0lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSkge1xubGV0IGN1cnJTY29vcCA9IHNjb29wO1xuZG8ge1xuaWYgKGN1cnJTY29vcC5uYW1lcyA9PT0gbnVsbCkge1xuY3VyclNjb29wLm5hbWVzID0gbmV3IE1hcCgpO1xufSBlbHNlIGlmIChjdXJyU2Nvb3AubmFtZXMuaGFzKCR0cF9iaW5kaW5nSWRlbnRfY2Fub24pKSB7XG5sZXQgYmluZGluZ1R5cGUgPSBjdXJyU2Nvb3AubmFtZXMuZ2V0KCR0cF9iaW5kaW5nSWRlbnRfY2Fub24pO1xudmVyaWZ5RHVwbGljYXRlVmFyQmluZGluZyhsZXhlckZsYWdzLCBiaW5kaW5nVHlwZSwgJHRwX2JpbmRpbmdJZGVudF9zdGFydCwgJHRwX2JpbmRpbmdJZGVudF9zdG9wLCAkdHBfYmluZGluZ0lkZW50X2Nhbm9uKTtcbn1cbmN1cnJTY29vcC5uYW1lcy5zZXQoJHRwX2JpbmRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUpO1xuY3VyclNjb29wID0gY3VyclNjb29wLnBhcmVudDtcbn0gd2hpbGUgKChjdXJyU2Nvb3AgJiYgKGN1cnJTY29vcC50eXBlICE9PSA5KSkpO1xufVxuZnVuY3Rpb24gdmVyaWZ5RHVwbGljYXRlVmFyQmluZGluZyhsZXhlckZsYWdzLCB2YWx1ZSwgJHRwX2JpbmRpbmdJZGVudF9zdGFydCwgJHRwX2JpbmRpbmdJZGVudF9zdG9wLCAkdHBfYmluZGluZ0lkZW50X2Nhbm9uKSB7XG5zd2l0Y2ggKHZhbHVlKSB7XG5jYXNlIDA6XG5cbmNhc2UgMTpcblxuY2FzZSAyOlxuXG5jYXNlIDM6XG5cbmNhc2UgNDpcbnJldHVybjtcbmNhc2UgNTpcblxuY2FzZSA2OlxuXG5jYXNlIDc6XG5cbmNhc2UgODpcbnJldHVybiBUSFJPV19SQU5HRSgnRm91bmQgYSB2YXIgYmluZGluZyB0aGF0IGlzIGR1cGxpY2F0ZSBvZiBhIGxleGljYWwgYmluZGluZyBvbiB0aGUgc2FtZSBvciBsb3dlciBzdGF0ZW1lbnQgbGV2ZWwnLCAkdHBfYmluZGluZ0lkZW50X3N0YXJ0LCAkdHBfYmluZGluZ0lkZW50X3N0b3ApO1xuY2FzZSAxMDpcbnJldHVybiBUSFJPV19SQU5HRSgoJ0NhbiBub3QgY3JlYXRlIGEgYmluZGluZyBmb3IgYCcgKyAkdHBfYmluZGluZ0lkZW50X2Nhbm9uKSArICdgIGJlY2F1c2Ugd2FzIGFscmVhZHkgYm91bmQgYXMgYSBjYXRjaCBjbGF1c2UgcGF0dGVybiBiaW5kaW5nJywgJHRwX2JpbmRpbmdJZGVudF9zdGFydCwgJHRwX2JpbmRpbmdJZGVudF9zdG9wKTtcbmNhc2UgOTpcbmlmIChvcHRpb25zX3dlYkNvbXBhdCA9PT0gZmFsc2UpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0NhbiBub3QgY3JlYXRlIGEgYmluZGluZyBmb3IgYCcgKyAkdHBfYmluZGluZ0lkZW50X2Nhbm9uKSArICdgIGJlY2F1c2Ugd2FzIGFscmVhZHkgYm91bmQgYXMgYSBjYXRjaCBjbGF1c2UgYmluZGluZycsICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQsICR0cF9iaW5kaW5nSWRlbnRfc3RvcCk7XG59XG5yZXR1cm47XG59XG59XG5mdW5jdGlvbiBTQ09QRV9hZGRMZXhCaW5kaW5nKHNjb29wLCAkdHBfYmluZGluZ0lkZW50X3N0YXJ0LCAkdHBfYmluZGluZ0lkZW50X3N0b3AsICR0cF9iaW5kaW5nSWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCBmZFN0YXRlKSB7XG5pZiAoc2Nvb3AgPT09IG51bGwpIHtcbnJldHVybjtcbn1cbmxldCB2YWx1ZSA9ICgoKChzY29vcC5uYW1lcyA9PT0gbnVsbCkgfHwgKCFzY29vcC5uYW1lcy5oYXMoJHRwX2JpbmRpbmdJZGVudF9jYW5vbikpKSk/IDAgOiBzY29vcC5uYW1lcy5nZXQoJHRwX2JpbmRpbmdJZGVudF9jYW5vbikpO1xuaWYgKHZhbHVlICE9PSAwKSB7XG5pZiAoYmluZGluZ1R5cGUgPT09IDEpIHtcbnNjb29wLmR1cGVQYXJhbUVycm9yU3RhcnQgPSAkdHBfYmluZGluZ0lkZW50X3N0YXJ0ICsgMTtcbnNjb29wLmR1cGVQYXJhbUVycm9yU3RvcCA9ICR0cF9iaW5kaW5nSWRlbnRfc3RvcDtcbn0gZWxzZSBpZiAoKCgoKG9wdGlvbnNfd2ViQ29tcGF0ICE9PSB0cnVlKSB8fCAodmFsdWUgIT09IDUpKSkgfHwgKGZkU3RhdGUgIT09IDMpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQXR0ZW1wdGVkIHRvIGNyZWF0ZSBhIGxleGljYWwgYmluZGluZyBmb3IgYCcgKyAkdHBfYmluZGluZ0lkZW50X2Nhbm9uKSArICdgIGJ1dCBhbm90aGVyIGJpbmRpbmcgYWxyZWFkeSBleGlzdGVkIG9uIHRoZSBzYW1lIGxldmVsJywgJHRwX2JpbmRpbmdJZGVudF9zdGFydCwgJHRwX2JpbmRpbmdJZGVudF9zdG9wKTtcbn0gZWxzZSB7XG5cbn1cbn1cbmlmICgoKCgoc2Nvb3AudHlwZSA9PT0gMTApICYmIChzY29vcC5wYXJlbnQubmFtZXMgIT09IG51bGwpKSkgJiYgc2Nvb3AucGFyZW50Lm5hbWVzLmhhcygkdHBfYmluZGluZ0lkZW50X2Nhbm9uKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0Nhbm5vdCBjcmVhdGUgbGV4aWNhbCBiaW5kaW5nIGZvciBgJyArICR0cF9iaW5kaW5nSWRlbnRfY2Fub24pICsgJ2AgYmVjYXVzZSBpdCBzaGFkb3dzIGEgZnVuY3Rpb24gcGFyYW1ldGVyJywgJHRwX2JpbmRpbmdJZGVudF9zdGFydCwgJHRwX2JpbmRpbmdJZGVudF9zdG9wKTtcbn1cbmlmICgoKCgoc2Nvb3AudHlwZSA9PT0gMTEpICYmICh2YWx1ZSAhPT0gMCkpKSAmJiAoYmluZGluZ1R5cGUgPT09IDEpKSkge1xuc2Nvb3AuZHVwZVBhcmFtRXJyb3JTdGFydCA9ICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQgKyAxO1xuc2Nvb3AuZHVwZVBhcmFtRXJyb3JTdG9wID0gJHRwX2JpbmRpbmdJZGVudF9zdG9wO1xufVxuaWYgKHNjb29wLnR5cGUgPT09IDYpIHtcbmxldCBwYXJlbnRWYWx1ZSA9ICgoKChzY29vcC5wYXJlbnQubmFtZXMgPT09IG51bGwpIHx8ICghc2Nvb3AucGFyZW50Lm5hbWVzLmhhcygkdHBfYmluZGluZ0lkZW50X2Nhbm9uKSkpKT8gMCA6IHNjb29wLnBhcmVudC5uYW1lcy5nZXQoJHRwX2JpbmRpbmdJZGVudF9jYW5vbikpO1xuaWYgKCgocGFyZW50VmFsdWUgPT09IDkpIHx8IChwYXJlbnRWYWx1ZSA9PT0gMTApKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQ2FuIG5vdCBjcmVhdGUgYSBsZXhpY2FsIGJpbmRpbmcgZm9yIGAnICsgJHRwX2JpbmRpbmdJZGVudF9jYW5vbikgKyAnYCBiZWNhdXNlIGl0IHNoYWRvd3MgYSBjYXRjaCBjbGF1c2UgYmluZGluZycsICR0cF9iaW5kaW5nSWRlbnRfc3RhcnQsICR0cF9iaW5kaW5nSWRlbnRfc3RvcCk7XG59XG59XG5pZiAoc2Nvb3AubmFtZXMgPT09IG51bGwpIHNjb29wLm5hbWVzID0gbmV3IE1hcCgpO1xuc2Nvb3AubmFtZXMuc2V0KCR0cF9iaW5kaW5nSWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKGxleGVyRmxhZ3MsIGFzdFByb3ApIHtcbmxldCBoYWRVc2VTdHJpY3QgPSBmYWxzZTtcbmxldCBpc1N0cmljdCA9IChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTI7XG5sZXQgaGFkT2N0YWwgPSBmYWxzZTtcbndoaWxlIChpc1N0cmluZ1Rva2VuKHRva19nZXRUeXBlKCkpKSB7XG5sZXQgJHRwX3N0cmluZ190eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfc3RyaW5nX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zdHJpbmdfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdHJpbmdfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfc3RyaW5nX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9zdHJpbmdfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5fQVNUX3NldExpdGVyYWwoYXN0UHJvcCwgJHRwX3N0cmluZ190eXBlLCAkdHBfc3RyaW5nX3N0YXJ0LCAkdHBfc3RyaW5nX3N0b3AsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sICR0cF9zdHJpbmdfY2Fub24sIHRydWUpO1xubGV0ICR0cF9uZXh0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0OTApIHtcbnBhcnNlRXhwcmVzc2lvbkFmdGVyTGl0ZXJhbChsZXhlckZsYWdzLCAkdHBfc3RyaW5nX3N0YXJ0LCAkdHBfc3RyaW5nX3N0b3AsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sIGFzdFByb3ApO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDkwKSB7XG5wYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncywgJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19zdG9wLCAkdHBfc3RyaW5nX2xpbmUsICR0cF9zdHJpbmdfY29sdW1uLCAxNiwgYXN0UHJvcCk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApIHtcbl9wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sIDE2LCBhc3RQcm9wKTtcbn1cbn1cbn1cbmlmICh0b2tfZ2V0U3RhcnQoKSA9PT0gJHRwX25leHRfc3RhcnQpIHtcbmxldCBkaXIgPSB0b2tfc2xpY2VJbnB1dCgkdHBfc3RyaW5nX3N0YXJ0ICsgMSwgJHRwX3N0cmluZ19zdG9wIC0gMSk7XG5pZiAoKCghaXNTdHJpY3QpICYmIC8oXnxbXlxcXFxdKShcXFxcXFxcXCkqXFxcXCg/OjBcXGR8WzEtOV0pLy50ZXN0KGRpcikpKSB7XG5oYWRPY3RhbCA9IHRydWU7XG59XG5pZiAoZGlyID09PSAndXNlIHN0cmljdCcpIHtcbmhhZFVzZVN0cmljdCA9IHRydWU7XG5sZXhlckZsYWdzID0gbGV4ZXJGbGFncyB8IDgxOTI7XG5pZiAoIWlzU3RyaWN0KSB7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gNDEwOCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdJbGxlZ2FsIGxlZ2FjeSBvY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuaWYgKCgoIWhhZE9jdGFsKSAmJiAvKF58W15cXFxcXSkoXFxcXFxcXFwpKlxcXFwoPzowXFxkfFsxLTldKS8udGVzdCh0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdPY3RhbCBpbiBkaXJlY3RpdmUgd2l0aCBzdHJpY3QgbW9kZSBkaXJlY3RpdmUgb3IgaW4gc3RyaWN0IG1vZGUgaXMgYWx3YXlzIGlsbGVnYWwnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG59XG5pc1N0cmljdCA9IHRydWU7XG59XG5pZiAoKEFTVF9kaXJlY3RpdmVOb2RlcyAmJiAoIWJhYmVsQ29tcGF0KSkpIHtcbkFTVF9zZXROb2RlRGFuZ2Vyb3VzbHkoYXN0UHJvcCwge3R5cGU6J0RpcmVjdGl2ZScsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4pLCBkaXJlY3RpdmU6ZGlyfSk7XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbn0gZWxzZSB7XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbkFTVF9zZXROb2RlRGFuZ2Vyb3VzbHkoYXN0UHJvcCwge3R5cGU6J0V4cHJlc3Npb25TdGF0ZW1lbnQnLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfc3RyaW5nX3N0YXJ0LCAkdHBfc3RyaW5nX2xpbmUsICR0cF9zdHJpbmdfY29sdW1uKSwgZXhwcmVzc2lvbjpBU1RfcG9wTm9kZShhc3RQcm9wKSwgZGlyZWN0aXZlOmRpcn0pO1xufVxufSBlbHNlIHtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX3NldE5vZGVEYW5nZXJvdXNseShhc3RQcm9wLCB7dHlwZTonRXhwcmVzc2lvblN0YXRlbWVudCcsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4pLCBleHByZXNzaW9uOkFTVF9wb3BOb2RlKGFzdFByb3ApfSk7XG5icmVhaztcbn1cbn1cbmlmICgoaGFkT2N0YWwgJiYgaXNTdHJpY3QpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ09jdGFsIGluIGRpcmVjdGl2ZSB3aXRoIHN0cmljdCBtb2RlIGRpcmVjdGl2ZSBvciBpbiBzdHJpY3QgbW9kZSBpcyBhbHdheXMgaWxsZWdhbCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiBoYWRVc2VTdHJpY3Q7XG59XG5mdW5jdGlvbiBwYXJzZUJvZHlQYXJ0c1dpdGhEaXJlY3RpdmVzKGxleGVyRmxhZ3MsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBwYXJhbXNTaW1wbGUsIGR1cGVQYXJhbUVycm9yU3RhcnQsIGR1cGVQYXJhbUVycm9yU3RvcCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3R5cGUsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdGFydCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0b3AsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9jYW5vbiwgaXNHbG9iYWxUb3BsZXZlbCwgYXN0UHJvcCkge1xubGV0IHdhc1N0cmljdCA9IChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTI7XG5sZXQgaXNTdHJpY3QgPSB3YXNTdHJpY3Q7XG5sZXQgaGFzVXNlU3RyaWN0ID0gcGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMobGV4ZXJGbGFncywgJ2JvZHknKTtcbmlmIChoYXNVc2VTdHJpY3QpIHtcbmlzU3RyaWN0ID0gdHJ1ZTtcbmlmICgoKHBhcmFtc1NpbXBsZSA9PT0gMikgfHwgKHBhcmFtc1NpbXBsZSA9PT0gMykpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBvbmx5IGRlY2xhcmUgdXNlIHN0cmljdCBpZiBmdW5jIHBhcmFtcyBhcmUgXCJzaW1wbGVcIicsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICgoKCgoIXdhc1N0cmljdCkgJiYgKCR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdGFydCAhPT0gMCkpKSAmJiBpc1N0cmljdE9ubHlLZXl3b3JkKCR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV90eXBlLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RhcnQsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdG9wLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfY2Fub24pKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQ2FuIG5vdCB1c2UgcmVzZXJ2ZWQga2V5d29yZCBgJyArICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9jYW5vbikgKyAnYCBpbiBzdHJpY3QgbW9kZSBhcyBpZCBmb3IgZnVuY3Rpb24gdGhhdCBoYXMgYSB1c2Ugc3RyaWN0IGRpcmVjdGl2ZScsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdGFydCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0b3ApO1xufVxubGV4ZXJGbGFncyB8PSA4MTkyO1xufVxuaWYgKCgoZHVwZVBhcmFtRXJyb3JTdGFydCAhPT0gMCkgJiYgKCgocGFyYW1zU2ltcGxlID09PSAzKSB8fCBpc1N0cmljdCkpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdGdW5jdGlvbiBoYWQgZHVwbGljYXRlIHBhcmFtcycsIGR1cGVQYXJhbUVycm9yU3RhcnQgLSAxLCBkdXBlUGFyYW1FcnJvclN0b3ApO1xufVxud2hpbGUgKCgodG9rX2dldFR5cGUoKSAhPT0gMjA5NzE3MykgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KSkpIHtcbnBhcnNlQm9keVBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIG51bGwsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGlzR2xvYmFsVG9wbGV2ZWwsIGZhbHNlLCA0LCBudWxsLCBhc3RQcm9wKTtcbn1cbmlmIChiYWJlbENvbXBhdCkgQVNUX2JhYmVsRGlyZWN0aXZlcygpO1xufVxuZnVuY3Rpb24gd3JhcExhYmVsU2V0KGxhYmVsU2V0LCBkZXNjKSB7XG5sZXQgc2V0ID0ge3BhcmVudExhYmVsczpsYWJlbFNldCwgc3RhdGVtZW50TGFiZWxzOm5ldyBTZXQoKSwgaXRlcmF0aW9uTGFiZWxzOm51bGx9O1xucmV0dXJuIHNldDtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50SGVhZGVyKGxleGVyRmxhZ3MsIGhlYWRQcm9wKSB7XG5sZXQgJHRwX29wZW5QYXJhbl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xucGFyc2VFeHByZXNzaW9ucygoKGxleGVyRmxhZ3MgfCA0MDk2KSB8IDE3OTIpIF4gMTc5MiwgaGVhZFByb3ApO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDcyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdNaXNzaW5nIGNsb3NpbmcgcGFyZW4gb2Ygc3RhdGVtZW50IGhlYWRlciwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsICR0cF9vcGVuUGFyYW5fc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBwYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKSB7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0OTApIHtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xucmV0dXJuO1xufVxuaWYgKCgoKCh0b2tfZ2V0VHlwZSgpID09PSAxNjUxNykgfHwgKHRva19nZXRObHdhcygpID09PSB0cnVlKSkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAyMDk3MTczKSkpIHtcbnRva19hc2koKTtcbn0gZWxzZSB7XG4kbG9nKCdwYXJzZSBlcnJvciBhdCBjdXJlbnQgdG9rZW4nKTtcbnJldHVybiBUSFJPV19SQU5HRSgnVW5hYmxlIHRvIEFTSScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlTmVzdGVkQm9keVBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApIHtcbnBhcnNlQm9keVBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZmFsc2UsIGlzTGFiZWxsZWQsIGZkU3RhdGUsIG5lc3RlZExhYmVscywgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUJvZHlQYXJ0KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgaXNHbG9iYWxUb3BsZXZlbCwgaXNMYWJlbGxlZCwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKSB7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5wYXJzZUlkZW50U3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgaXNHbG9iYWxUb3BsZXZlbCwgaXNMYWJlbGxlZCwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKTtcbnJldHVybjtcbn1cbmlmIChpc1B1bmN0dWF0b3JUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucGFyc2VQdW5jdHVhdG9yU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCk7XG5yZXR1cm47XG59XG5pZiAoaXNOdW1iZXJUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucGFyc2VGcm9tTnVtYmVyU3RhdGVtZW50KGxleGVyRmxhZ3MsIGFzdFByb3ApO1xucmV0dXJuO1xufVxuaWYgKGlzU3RyaW5nVG9rZW4odG9rX2dldFR5cGUoKSkpIHtcbnBhcnNlRnJvbVN0cmluZ1N0YXRlbWVudChsZXhlckZsYWdzLCBhc3RQcm9wKTtcbnJldHVybjtcbn1cbmlmIChpc1RpY2tUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucGFyc2VUaWNrU3RhdGVtZW50KGxleGVyRmxhZ3MsIGFzdFByb3ApO1xucmV0dXJuO1xufVxuaWYgKGlzUmVnZXhUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucGFyc2VGcm9tUmVnZXhTdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCk7XG5yZXR1cm47XG59XG5USFJPV19SQU5HRSgnVW5leHBlY3RlZCBFT0YnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obGV4ZXJGbGFncywgc2Nvb3AsIGlzRnVuY0RlY2wsIGlzUmVhbEZ1bmNFeHByLCAkdHBfYXN5bmNfdHlwZSwgJHRwX2FzdFJhbmdlX3N0YXJ0LCAkdHBfYXN0UmFuZ2VfbGluZSwgJHRwX2FzdFJhbmdlX2NvbHVtbiwgJHRwX2Z1bmNIZWFkX3N0YXJ0LCAkdHBfZnVuY0hlYWRfc3RvcCwgb3B0aW9uYWxJZGVudCwgaXNMYWJlbGxlZCwgZmRTdGF0ZSwgYXN0UHJvcCkge1xuc2tpcFRvSWRlbnRTdGFyUGFyZW5PcGVuKGxleGVyRmxhZ3MpO1xubGV0ICR0cF9zdGFyX3R5cGUgPSAwO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDA5KSB7XG4kdHBfc3Rhcl90eXBlID0gODIwMDk7XG4kdHBfZnVuY0hlYWRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5za2lwVG9JZGVudFBhcmVuT3BlbihsZXhlckZsYWdzKTtcbmlmICgoKCR0cF9hc3luY190eXBlID09PSAyMDc0KSAmJiAoIWFsbG93QXN5bmNHZW5lcmF0b3JzKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQXN5bmMgZ2VuZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudGx5IHRhcmdldGVkIGxhbmd1YWdlIHZlcnNpb24sIHRoZXkgd2VyZSBpbnRyb2R1Y2VkIGluIEVTOS9FUzIwMTgnLCAkdHBfZnVuY0hlYWRfc3RhcnQsICR0cF9mdW5jSGVhZF9zdG9wKTtcbn1cbn1cbmlmIChpc0xhYmVsbGVkID09PSB0cnVlKSB7XG5pZiAoZmRTdGF0ZSA9PT0gMSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBIFwibGFiZWxsZWQgZnVuY3Rpb24gZGVjbGFyYXRpb25cIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNpdHVhdGlvbicsICR0cF9mdW5jSGVhZF9zdGFydCwgJHRwX2Z1bmNIZWFkX3N0b3ApO1xufVxuaWYgKCR0cF9hc3luY190eXBlID09PSAyMDc0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0EgXCJsYWJlbGxlZCBmdW5jdGlvbiBkZWNsYXJhdGlvblwiIGNhbiBub3QgYmUgYXN5bmMnLCAkdHBfZnVuY0hlYWRfc3RhcnQsICR0cF9mdW5jSGVhZF9zdG9wKTtcbn1cbmlmICgkdHBfc3Rhcl90eXBlID09PSA4MjAwOSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBIFwibGFiZWxsZWQgZnVuY3Rpb24gZGVjbGFyYXRpb25cIiBjYW4gbm90IGJlIGEgZ2VuZXJhdG9yJywgJHRwX2Z1bmNIZWFkX3N0YXJ0LCAkdHBfZnVuY0hlYWRfc3RvcCk7XG59XG5pZiAoKChvcHRpb25zX3dlYkNvbXBhdCA9PT0gZmFsc2UpIHx8ICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQSBcImxhYmVsbGVkIGZ1bmN0aW9uIGRlY2xhcmF0aW9uXCIgaXMgb25seSBhbGxvd2VkIGluIHNsb3BweSB3ZWIgY29tcGF0IG1vZGUnLCAkdHBfZnVuY0hlYWRfc3RhcnQsICR0cF9mdW5jSGVhZF9zdG9wKTtcbn1cbn0gZWxzZSBpZiAoZmRTdGF0ZSA9PT0gMikge1xuaWYgKCR0cF9hc3luY190eXBlID09PSAyMDc0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0FuIGFzeW5jIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIGluIHdlYiBjb21wYXQgbW9kZSBpcyBzdGlsbCBub3QgYWxsb3dlZCBhcyBgaWYtZWxzZWAgY2hpbGQsIG9ubHkgcGxhaW4gZnVuYyBkZWNscyBhcmUgYWxsb3dlZCB0aGVyZScsICR0cF9mdW5jSGVhZF9zdGFydCwgJHRwX2Z1bmNIZWFkX3N0b3ApO1xufVxuaWYgKCR0cF9zdGFyX3R5cGUgPT09IDgyMDA5KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0EgZ2VuZXJhdG9yIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIGluIHdlYiBjb21wYXQgbW9kZSBpcyBzdGlsbCBub3QgYWxsb3dlZCBhcyBgaWYtZWxzZWAgY2hpbGQsIG9ubHkgcGxhaW4gZnVuYyBkZWNscyBhcmUgYWxsb3dlZCB0aGVyZScsICR0cF9mdW5jSGVhZF9zdGFydCwgJHRwX2Z1bmNIZWFkX3N0b3ApO1xufVxuaWYgKCgob3B0aW9uc193ZWJDb21wYXQgPT09IGZhbHNlKSB8fCAoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gODE5MikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0EgZnVuY3Rpb24gZGVjbGFyYXRpb24gY2FuIG9ubHkgYmUgdGhlIGNoaWxkIG9mIGFuIGBpZmAvYGVsc2VgIGluIHNsb3BweSB3ZWIgY29tcGF0IG1vZGUnLCAkdHBfZnVuY0hlYWRfc3RhcnQsICR0cF9mdW5jSGVhZF9zdG9wKTtcbn1cbnNjb29wID0gU0NPUEVfYWRkTGF5ZXIoc2Nvb3AsIDEyLCAnc3BlY2lhbCBcImZha2UtYmxvY2tcIiBmdW5jdGlvbiBzdGF0ZW1lbnQgZm9yIGxhYmVsJyk7XG59IGVsc2UgaWYgKCgoaXNGdW5jRGVjbCA9PT0gdHJ1ZSkgJiYgKGZkU3RhdGUgPT09IDEpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgcGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBoZXJlLCBvbmx5IGV4cGVjdGluZyBzdGF0ZW1lbnRzIGhlcmUnLCAkdHBfZnVuY0hlYWRfc3RhcnQsICR0cF9mdW5jSGVhZF9zdG9wKTtcbn1cbnJldHVybiBwYXJzZUZ1bmN0aW9uQWZ0ZXJLZXl3b3JkKGxleGVyRmxhZ3MsIHNjb29wLCBpc0Z1bmNEZWNsLCBpc1JlYWxGdW5jRXhwciwgb3B0aW9uYWxJZGVudCwgZmFsc2UsIGZhbHNlLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgMCwgMCwgJHRwX2FzdFJhbmdlX3N0YXJ0LCAkdHBfYXN0UmFuZ2VfbGluZSwgJHRwX2FzdFJhbmdlX2NvbHVtbiwgZmRTdGF0ZSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfZnVuY3Rpb25fc3RhcnQsICR0cF9mdW5jdGlvbl9saW5lLCAkdHBfZnVuY3Rpb25fY29sdW1uLCBhc3RQcm9wKSB7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gODIwMDkpIHtcbnJldHVybiBwYXJzZUdlbmVyYXRvckZ1bmN0aW9uRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfZnVuY3Rpb25fc3RhcnQsICR0cF9mdW5jdGlvbl9saW5lLCAkdHBfZnVuY3Rpb25fY29sdW1uLCBhc3RQcm9wKTtcbn1cbnBhcnNlRnVuY3Rpb25BZnRlcktleXdvcmQobGV4ZXJGbGFncywgbnVsbCwgZmFsc2UsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIDAsIDAsIDAsICR0cF9mdW5jdGlvbl9zdGFydCwgJHRwX2Z1bmN0aW9uX2xpbmUsICR0cF9mdW5jdGlvbl9jb2x1bW4sIDEsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VHZW5lcmF0b3JGdW5jdGlvbkV4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX2Z1bmN0aW9uX3N0YXJ0LCAkdHBfZnVuY3Rpb25fbGluZSwgJHRwX2Z1bmN0aW9uX2NvbHVtbiwgYXN0UHJvcCkge1xuc2tpcFRvSWRlbnRQYXJlbk9wZW4obGV4ZXJGbGFncyk7XG5wYXJzZUZ1bmN0aW9uQWZ0ZXJLZXl3b3JkKGxleGVyRmxhZ3MsIG51bGwsIGZhbHNlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCA4MjAwOSwgMCwgMCwgJHRwX2Z1bmN0aW9uX3N0YXJ0LCAkdHBfZnVuY3Rpb25fbGluZSwgJHRwX2Z1bmN0aW9uX2NvbHVtbiwgMSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUFzeW5jRnVuY3Rpb25EZWNsKGxleGVyRmxhZ3MsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIGZyb21TdG10T3JFeHByLCBzY29vcCwgaXNFeHBvcnQsIGV4cG9ydGVkQmluZGluZ3MsIGlzTGFiZWxsZWQsIGZkU3RhdGUsIGFzdFByb3ApIHtcbmxldCAkdHBfZnVuY3Rpb25fc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgY2Fub25OYW1lID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKGxleGVyRmxhZ3MsIHNjb29wLCAoKGZyb21TdG10T3JFeHByID09PSAxKT8gZmFsc2UgOiB0cnVlKSwgKChmcm9tU3RtdE9yRXhwciA9PT0gMSk/IHRydWUgOiBmYWxzZSksIDIwNzQsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19zdGFydCwgJHRwX2Z1bmN0aW9uX3N0b3AsICgoKChpc0V4cG9ydCA9PT0gdHJ1ZSkgfHwgKGZyb21TdG10T3JFeHByID09PSAxKSkpPyB0cnVlIDogZmFsc2UpLCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBhc3RQcm9wKTtcbmlmIChpc0V4cG9ydCA9PT0gdHJ1ZSkge1xuYWRkQmluZGluZ1RvRXhwb3J0cyhleHBvcnRlZEJpbmRpbmdzLCBjYW5vbk5hbWUpO1xufVxucmV0dXJuIDE2O1xufVxuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkFmdGVyS2V5d29yZChsZXhlckZsYWdzLCBvdXRlclNjb29wLCBpc0Z1bmNEZWNsLCBpc1JlYWxGdW5jRXhwciwgb3B0aW9uYWxJZGVudCwgaXNDbGFzc0NvbnN0cnVjdG9yLCBpc01ldGhvZCwgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlLCAkdHBfYXN0UmFuZ2Vfc3RhcnQsICR0cF9hc3RSYW5nZV9saW5lLCAkdHBfYXN0UmFuZ2VfY29sdW1uLCBmZFN0YXRlLCBhc3RQcm9wKSB7XG5pZiAoKGJhYmVsQ29tcGF0ICYmIChpc01ldGhvZCAhPT0gZmFsc2UpKSkge1xuQVNUX3NldCgnZ2VuZXJhdG9yJywgJHRwX3N0YXJfdHlwZSA9PT0gODIwMDkpO1xuQVNUX3NldCgnYXN5bmMnLCAkdHBfYXN5bmNfdHlwZSA9PT0gMjA3NCk7XG59IGVsc2UgaWYgKGFjb3JuQ29tcGF0KSB7XG5pZiAoYWxsb3dBc3luY0Z1bmN0aW9ucykge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6KChpc0Z1bmNEZWNsID09PSB0cnVlKT8gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIDogJ0Z1bmN0aW9uRXhwcmVzc2lvbicpLCBsb2M6dW5kZWZpbmVkLCBnZW5lcmF0b3I6JHRwX3N0YXJfdHlwZSA9PT0gODIwMDksIGFzeW5jOiR0cF9hc3luY190eXBlID09PSAyMDc0LCBleHByZXNzaW9uOmZhbHNlLCBpZDp1bmRlZmluZWQsIHBhcmFtczpbXSwgYm9keTp1bmRlZmluZWR9KTtcbn0gZWxzZSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTooKGlzRnVuY0RlY2wgPT09IHRydWUpPyAnRnVuY3Rpb25EZWNsYXJhdGlvbicgOiAnRnVuY3Rpb25FeHByZXNzaW9uJyksIGxvYzp1bmRlZmluZWQsIGdlbmVyYXRvcjokdHBfc3Rhcl90eXBlID09PSA4MjAwOSwgZXhwcmVzc2lvbjpmYWxzZSwgaWQ6dW5kZWZpbmVkLCBwYXJhbXM6W10sIGJvZHk6dW5kZWZpbmVkfSk7XG59XG59IGVsc2Uge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6KChpc0Z1bmNEZWNsID09PSB0cnVlKT8gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIDogJ0Z1bmN0aW9uRXhwcmVzc2lvbicpLCBsb2M6dW5kZWZpbmVkLCBnZW5lcmF0b3I6JHRwX3N0YXJfdHlwZSA9PT0gODIwMDksIGFzeW5jOiR0cF9hc3luY190eXBlID09PSAyMDc0LCBpZDp1bmRlZmluZWQsIHBhcmFtczpbXSwgYm9keTp1bmRlZmluZWR9KTtcbn1cbmxldCBpbm5lclNjb29wID0gU0NPUEVfY3JlYXRlR2xvYmFsKCdwYXJzZUZ1bmN0aW9uQWZ0ZXJLZXl3b3JkX21haW5fZnVuY19zY29wZScpO1xubGV0ICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV90eXBlID0gMDtcbmxldCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfbGluZSA9IDA7XG5sZXQgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2NvbHVtbiA9IDA7XG5sZXQgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0YXJ0ID0gMDtcbmxldCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RvcCA9IDA7XG5sZXQgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2Nhbm9uID0gJyc7XG5sZXQgY2Fub25OYW1lID0gJyc7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG4kdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfdHlwZSA9IHRva19nZXRUeXBlKCk7XG4kdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfbGluZSA9IHRva19nZXRMaW5lKCk7XG4kdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xuJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG4kdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RvcCA9IHRva19nZXRTdG9wKCk7XG4kdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbmxldCBiaW5kaW5nRmxhZ3MgPSAoKGxleGVyRmxhZ3MgfCAxMzYpIF4gMTM2KSB8IGdldEZ1bmNJZGVudEFzeW5jR2VuU3RhdGUoaXNSZWFsRnVuY0V4cHIsIGxleGVyRmxhZ3MsICR0cF9zdGFyX3R5cGUsICR0cF9hc3luY190eXBlKTtcbmxldCBuYW1lQmluZGluZ1R5cGUgPSAoKCgoKChpc0Z1bmNEZWNsID09PSB0cnVlKSAmJiAoZmRTdGF0ZSA9PT0gNCkpKSAmJiAoKCgobGV4ZXJGbGFncyAmIDI1NikgPT09IDApIHx8IChnb2FsTW9kZSA9PT0gZmFsc2UpKSkpKT8gMyA6IDUpO1xuY2Fub25OYW1lID0gJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2Nhbm9uO1xuZmF0YWxCaW5kaW5nSWRlbnRDaGVjaygkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfdHlwZSwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0YXJ0LCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RvcCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2Nhbm9uLCBuYW1lQmluZGluZ1R5cGUsIGJpbmRpbmdGbGFncyk7XG5pZiAoaXNGdW5jRGVjbCA9PT0gdHJ1ZSkge1xuU0NPUEVfYWRkRnVuY0RlY2xOYW1lKGxleGVyRmxhZ3MsIG91dGVyU2Nvb3AsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdGFydCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0b3AsIGNhbm9uTmFtZSwgbmFtZUJpbmRpbmdUeXBlLCBmZFN0YXRlKTtcbn1cbmlubmVyU2Nvb3AgPSBTQ09QRV9hZGRMYXllcihpbm5lclNjb29wLCA5LCAncGFyc2VGdW5jdGlvbkFmdGVyS2V5d29yZF9oaWRlX2Z1bmNfbmFtZScpO1xuc2tpcFRvUGFyZW5PcGVuT3JEaWUobGV4ZXJGbGFncyk7XG5BU1Rfc2V0SWRlbnQoJ2lkJywgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0YXJ0LCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RvcCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2xpbmUsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9jb2x1bW4sICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9jYW5vbik7XG59IGVsc2UgaWYgKCgoaXNGdW5jRGVjbCA9PT0gdHJ1ZSkgJiYgKG9wdGlvbmFsSWRlbnQgPT09IGZhbHNlKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRnVuY3Rpb24gZGVjbCBtaXNzaW5nIHJlcXVpcmVkIGlkZW50JywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufSBlbHNlIHtcbkFTVF9zZXQoJ2lkJywgbnVsbCk7XG59XG5sZXhlckZsYWdzID0gcmVzZXRMZXhlckZsYWdzRm9yRnVuY0FuZEFycm93KGxleGVyRmxhZ3MsICR0cF9zdGFyX3R5cGUsICR0cF9hc3luY190eXBlLCBmYWxzZSk7XG5pZiAoaXNDbGFzc0NvbnN0cnVjdG9yID09PSB0cnVlKSB7XG5sZXhlckZsYWdzIHw9IDE2O1xufSBlbHNlIHtcbmxleGVyRmxhZ3MgPSAobGV4ZXJGbGFncyB8IDE2NDAwKSBeIDE2NDAwO1xufVxuaWYgKGlzTWV0aG9kID09PSB0cnVlKSBsZXhlckZsYWdzIHw9IDMyNzY4OyBlbHNlIGxleGVyRmxhZ3MgPSAobGV4ZXJGbGFncyB8IDMyNzY4KSBeIDMyNzY4O1xucGFyc2VGdW5jdGlvbkZyb21QYXJhbXMobGV4ZXJGbGFncywgaW5uZXJTY29vcCwgKCgkdHBfYXN5bmNfdHlwZSA9PT0gMCk/IDYgOiA1KSwgKChpc0Z1bmNEZWNsID09PSB0cnVlKT8gMiA6IDEpLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfdHlwZSwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0YXJ0LCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RvcCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2Nhbm9uLCBpc01ldGhvZCwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUpO1xuaWYgKCgoIWJhYmVsQ29tcGF0KSB8fCAoaXNNZXRob2QgPT09IGZhbHNlKSkpIHtcbkFTVF9jbG9zZSgkdHBfYXN0UmFuZ2Vfc3RhcnQsICR0cF9hc3RSYW5nZV9saW5lLCAkdHBfYXN0UmFuZ2VfY29sdW1uKTtcbn1cbnJldHVybiBjYW5vbk5hbWU7XG59XG5mdW5jdGlvbiBnZXRGdW5jSWRlbnRHZW5lcmF0b3JTdGF0ZShpc1JlYWxGdW5jRXhwciwgZW5jbG9zaW5nU2NvcGVGbGFncywgJHRwX3N0YXJfdHlwZSkge1xuaWYgKChlbmNsb3NpbmdTY29wZUZsYWdzICYgODE5MikgPT09IDgxOTIpIHJldHVybiAxMjg7XG5pZiAoaXNSZWFsRnVuY0V4cHIgPT09IHRydWUpIHJldHVybiAoKCR0cF9zdGFyX3R5cGUgPT09IDgyMDA5KT8gMTI4IDogMCk7XG5yZXR1cm4gKCgoZW5jbG9zaW5nU2NvcGVGbGFncyAmIDEyOCkgIT09IDApPyAxMjggOiAwKTtcbn1cbmZ1bmN0aW9uIGdldEZ1bmNJZGVudEFzeW5jU3RhdGUoaXNSZWFsRnVuY0V4cHIsIGVuY2xvc2luZ1Njb3BlRmxhZ3MsICR0cF9hc3luY190eXBlKSB7XG5pZiAoZ29hbE1vZGUgPT09IHRydWUpIHJldHVybiA4O1xuaWYgKGlzUmVhbEZ1bmNFeHByID09PSB0cnVlKSByZXR1cm4gKCgkdHBfYXN5bmNfdHlwZSA9PT0gMjA3NCk/IDggOiAwKTtcbnJldHVybiAoKChlbmNsb3NpbmdTY29wZUZsYWdzICYgOCkgIT09IDApPyA4IDogMCk7XG59XG5mdW5jdGlvbiBnZXRGdW5jSWRlbnRBc3luY0dlblN0YXRlKGlzUmVhbEZ1bmNFeHByLCBlbmNsb3NpbmdTY29wZUZsYWdzLCAkdHBfc3Rhcl90eXBlLCAkdHBfYXN5bmNfdHlwZSkge1xucmV0dXJuIGdldEZ1bmNJZGVudEdlbmVyYXRvclN0YXRlKGlzUmVhbEZ1bmNFeHByLCBlbmNsb3NpbmdTY29wZUZsYWdzLCAkdHBfc3Rhcl90eXBlKSB8IGdldEZ1bmNJZGVudEFzeW5jU3RhdGUoaXNSZWFsRnVuY0V4cHIsIGVuY2xvc2luZ1Njb3BlRmxhZ3MsICR0cF9hc3luY190eXBlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0TGV4ZXJGbGFnc0ZvckZ1bmNBbmRBcnJvdyhsZXhlckZsYWdzLCAkdHBfc3Rhcl90eXBlLCAkdHBfYXN5bmNfdHlwZSwgZnVuY1R5cGUpIHtcbmxleGVyRmxhZ3MgPSBsZXhlckZsYWdzICYgNTkzOTI7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbmxleGVyRmxhZ3MgfD0gODtcbn1cbmlmICgkdHBfc3Rhcl90eXBlID09PSA4MjAwOSkge1xubGV4ZXJGbGFncyB8PSAxMjg7XG59XG5pZiAoZnVuY1R5cGUgPT09IGZhbHNlKSBsZXhlckZsYWdzID0gbGV4ZXJGbGFncyB8IDI7XG5yZXR1cm4gbGV4ZXJGbGFncztcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Gcm9tUGFyYW1zKGxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nRnJvbSwgZXhwcmVzc2lvblN0YXRlLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfdHlwZSwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X3N0YXJ0LCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RvcCwgJHRwX2Z1bmN0aW9uTmFtZVRvVmVyaWZ5X2Nhbm9uLCBpc01ldGhvZCwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUpIHtcbmxldCBwYXJhbVNjb29wID0gU0NPUEVfYWRkTGF5ZXIoc2Nvb3AsIDMsICdwYXJzZUZ1bmN0aW9uRnJvbVBhcmFtcyhhcmcpJyk7XG5sZXQgcGFyYW1zU2ltcGxlID0gcGFyc2VGdW5jQXJndW1lbnRzKGxleGVyRmxhZ3MgfCA0MDk2LCBwYXJhbVNjb29wLCBiaW5kaW5nRnJvbSwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUpO1xubGV0IGR1cGVQYXJhbUVycm9yU3RhcnQgPSBwYXJhbVNjb29wLmR1cGVQYXJhbUVycm9yU3RhcnQ7XG5sZXQgZHVwZVBhcmFtRXJyb3JTdG9wID0gcGFyYW1TY29vcC5kdXBlUGFyYW1FcnJvclN0b3A7XG5pZiAoKChpc01ldGhvZCA9PT0gdHJ1ZSkgJiYgKGR1cGVQYXJhbUVycm9yU3RhcnQgIT09IDApKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdNZXRob2QgaGFkIGR1cGxpY2F0ZSBwYXJhbXMnLCBkdXBlUGFyYW1FcnJvclN0YXJ0IC0gMSwgZHVwZVBhcmFtRXJyb3JTdG9wKTtcbn1cbmxldCBmaW5hbEZ1bmNTY29wZSA9IFNDT1BFX2FkZExheWVyKHBhcmFtU2Nvb3AsIDEwLCAncGFyc2VGdW5jdGlvbkZyb21QYXJhbXMoYm9keSknKTtcbmlmIChvcHRpb25zX2V4cG9zZVNjb3BlcykgQVNUX3NldCgnJHNjb3BlJywgZmluYWxGdW5jU2NvcGUpO1xucGFyc2VGdW5jdGlvbkJvZHkobGV4ZXJGbGFncywgZmluYWxGdW5jU2NvcGUsIGV4cHJlc3Npb25TdGF0ZSwgcGFyYW1zU2ltcGxlLCBkdXBlUGFyYW1FcnJvclN0YXJ0LCBkdXBlUGFyYW1FcnJvclN0b3AsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV90eXBlLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RhcnQsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdG9wLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfY2Fub24sIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0FyZ3VtZW50cyhsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ0Zyb20sICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlKSB7XG5sZXhlckZsYWdzID0gbGV4ZXJGbGFncyB8IDY0O1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDcxKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ011c3QgaGF2ZSBmdW5jIGFyZ3VtZW50cyBuZXh0IGJ1dCBkaWQgbm90IGZpbmQgYChgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvQmluZGluZ1N0YXJ0R3JvdXBlZChsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ3Mikge1xuaWYgKCR0cF9zZXRfdHlwZSA9PT0gMjExMikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdTZXR0ZXJzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbWV0ZXInLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwVG9DdXJseU9wZW5PckRpZShsZXhlckZsYWdzKTtcbnJldHVybiAxO1xufVxuaWYgKCR0cF9nZXRfdHlwZSA9PT0gMjA5Nikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdHZXR0ZXJzIGNhbiBub3QgaGF2ZSBhbnkgcGFyYW1ldGVycycsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmxldCBwYXJhbXNTaW1wbGUgPSBwYXJzZUJpbmRpbmdzKGxleGVyRmxhZ3MsIHNjb29wLCAxLCBiaW5kaW5nRnJvbSwgZmFsc2UsICR0cF9zZXRfdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsICdwYXJhbXMnKTtcbkFTVF9kZXN0cnVjdCgncGFyYW1zJyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3NpbmcgZnVuY3Rpb24gcGFyYW0gZGVmaW5pdGlvbiBjbG9zaW5nIHBhcmVudGhlc2lzLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvQ3VybHlPcGVuT3JEaWUobGV4ZXJGbGFncyk7XG5yZXR1cm4gcGFyYW1zU2ltcGxlO1xufVxuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkJvZHkobGV4ZXJGbGFncywgc2Nvb3AsIGJsb2NrVHlwZSwgcGFyYW1zU2ltcGxlLCBkdXBlUGFyYW1FcnJvclN0YXJ0LCBkdXBlUGFyYW1FcnJvclN0b3AsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV90eXBlLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RhcnQsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdG9wLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfY2Fub24sIGlzQXJyb3cpIHtcbmxldCBsZXhlckZsYWdzTm9UZW1wbGF0ZSA9IChsZXhlckZsYWdzIHwgNzkzNikgXiA3OTM2O1xubGV0ICR0cF9jdXJseV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfY3VybHlfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9jdXJseV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFnc05vVGVtcGxhdGUpO1xuQVNUX29wZW4oJ2JvZHknLCB7dHlwZTonQmxvY2tTdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBib2R5OltdfSk7XG5pZiAob3B0aW9uc19leHBvc2VTY29wZXMpIEFTVF9zZXQoJyRzY29wZScsIHNjb29wKTtcbnBhcnNlQm9keVBhcnRzV2l0aERpcmVjdGl2ZXMobGV4ZXJGbGFnc05vVGVtcGxhdGUsIHNjb29wLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcGFyYW1zU2ltcGxlLCBkdXBlUGFyYW1FcnJvclN0YXJ0LCBkdXBlUGFyYW1FcnJvclN0b3AsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV90eXBlLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfc3RhcnQsICR0cF9mdW5jdGlvbk5hbWVUb1ZlcmlmeV9zdG9wLCAkdHBfZnVuY3Rpb25OYW1lVG9WZXJpZnlfY2Fub24sIGZhbHNlLCAnYm9keScpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdNaXNzaW5nIGZ1bmN0aW9uIGJvZHkgY2xvc2luZyBjdXJseSwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmIChpc0Fycm93KSB7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xuaWYgKCgodG9rX2dldE5sd2FzKCkgPT09IHRydWUpICYmIGlzUmVnZXhUb2tlbih0b2tfZ2V0VHlwZSgpKSkpIHtcbkFTU0VSVF9BU0lfUkVHRVhfTkVYVCA9IHRydWU7XG59XG59IGVsc2UgaWYgKGJsb2NrVHlwZSA9PT0gMSkge1xuc2tpcERpdihsZXhlckZsYWdzKTtcbn0gZWxzZSB7XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbn1cbkFTVF9jbG9zZSgkdHBfY3VybHlfc3RhcnQsICR0cF9jdXJseV9saW5lLCAkdHBfY3VybHlfY29sdW1uKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSA0OTI2NCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdPYmplY3QgZGVzdHJ1Y3R1cmluZyBpcyBub3QgYWxsb3dlZCBhdCB0aGUgc3RhcnQgb2Ygc3RhdGVtZW50IG9yIGFycm93IGJvZHksIG11c3Qgd3JhcCB0aGUgb2JqZWN0IGluIHBhcmVudGhlc2lzIGZvciB0aGF0IHRvIHdvcmsnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG59XG5mdW5jdGlvbiBwYXJzZUlkZW50U3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgaXNHbG9iYWxUb3BsZXZlbCwgaXNMYWJlbGxlZCwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnN3aXRjaCAoJHRwX2lkZW50X3R5cGUpIHtcbmNhc2UgMjA3NDpcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODkpIHtcbnJldHVybiBwYXJzZUxhYmVsZWRTdGF0ZW1lbnRJbnN0ZWFkKGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgMjA3NCwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKTtcbn1cbnBhcnNlQXN5bmNTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGZhbHNlLCB1bmRlZmluZWQsIGlzTGFiZWxsZWQsIGZkU3RhdGUsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMDc2OlxucGFyc2VCcmVha1N0YXRlbWVudChsZXhlckZsYWdzLCBsYWJlbFNldCwgYXN0UHJvcCk7XG5yZXR1cm47XG5jYXNlIDIwNzk6XG5wYXJzZUNsYXNzRGVjbGFyYXRpb24obGV4ZXJGbGFncywgc2Nvb3AsIGZhbHNlLCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBhc3RQcm9wKTtcbnJldHVybjtcbmNhc2UgMjA4MDpcbnBhcnNlQ29uc3RTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGlzTGFiZWxsZWQsIGZkU3RhdGUsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMDgxOlxucGFyc2VDb250aW51ZVN0YXRlbWVudChsZXhlckZsYWdzLCBsYWJlbFNldCwgYXN0UHJvcCk7XG5yZXR1cm47XG5jYXNlIDIwODI6XG5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KGxleGVyRmxhZ3MsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMDg1OlxucGFyc2VEb1N0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMDg5OlxucGFyc2VFeHBvcnRTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGlzR2xvYmFsVG9wbGV2ZWwsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMDkzOlxucGFyc2VGb3JTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBhc3RQcm9wKTtcbnJldHVybjtcbmNhc2UgMjA5NTpcbjtcbnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihsZXhlckZsYWdzLCBzY29vcCwgdHJ1ZSwgZmFsc2UsIDAsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsIGZhbHNlLCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBhc3RQcm9wKTtcbnJldHVybjtcbmNhc2UgMjA5NzpcbnBhcnNlSWZTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBhc3RQcm9wKTtcbnJldHVybjtcbmNhc2UgMjA5OTpcbnBhcnNlSW1wb3J0RGVjbGFyYXRpb24obGV4ZXJGbGFncywgc2Nvb3AsIGlzR2xvYmFsVG9wbGV2ZWwsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMTAzOlxuaWYgKCgoKChpc0xhYmVsbGVkID09PSB0cnVlKSB8fCAoZmRTdGF0ZSA9PT0gMSkpKSB8fCAoZmRTdGF0ZSA9PT0gMikpKSB7XG5wYXJzZUxldEV4cHJlc3Npb25TdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApO1xufSBlbHNlIHtcbnBhcnNlTGV0RGVjbGFyYXRpb24obGV4ZXJGbGFncywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgc2Nvb3AsIGxhYmVsU2V0LCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApO1xufVxucmV0dXJuO1xuY2FzZSAyMTExOlxucGFyc2VSZXR1cm5TdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCk7XG5yZXR1cm47XG5jYXNlIDIxMTU6XG5wYXJzZVN3aXRjaFN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGFzdFByb3ApO1xucmV0dXJuO1xuY2FzZSAyMTE4OlxucGFyc2VUaHJvd1N0YXRlbWVudChsZXhlckZsYWdzLCBhc3RQcm9wKTtcbnJldHVybjtcbmNhc2UgMjEyMDpcbnBhcnNlVHJ5U3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCk7XG5yZXR1cm47XG5jYXNlIDIxMjI6XG5wYXJzZVZhclN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgYXN0UHJvcCk7XG5yZXR1cm47XG5jYXNlIDIxMjQ6XG5wYXJzZVdoaWxlU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCk7XG5yZXR1cm47XG5jYXNlIDIxMjU6XG5wYXJzZVdpdGhTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBhc3RQcm9wKTtcbnJldHVybjtcbn1cbnBhcnNlSWRlbnRMYWJlbE9yRXhwcmVzc2lvblN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGZkU3RhdGUsIG5lc3RlZExhYmVscywgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUZyb21OdW1iZXJTdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9udW1iZXJfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX251bWJlcl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfbnVtYmVyX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfbnVtYmVyX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX251bWJlcl9zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonRXhwcmVzc2lvblN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGV4cHJlc3Npb246QVNUX2dldE51bWJlck5vZGUoJHRwX251bWJlcl90eXBlLCAkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX3N0b3AsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pfSk7XG5wYXJzZUV4cHJlc3Npb25BZnRlckxpdGVyYWwobGV4ZXJGbGFncywgJHRwX251bWJlcl9zdGFydCwgJHRwX251bWJlcl9zdG9wLCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uLCAnZXhwcmVzc2lvbicpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5fcGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCAkdHBfbnVtYmVyX3N0YXJ0LCAkdHBfbnVtYmVyX2xpbmUsICR0cF9udW1iZXJfY29sdW1uLCAxNiwgJ2V4cHJlc3Npb24nKTtcbn1cbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF9udW1iZXJfc3RhcnQsICR0cF9udW1iZXJfbGluZSwgJHRwX251bWJlcl9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VGcm9tU3RyaW5nU3RhdGVtZW50KGxleGVyRmxhZ3MsIGFzdFByb3ApIHtcbmxldCAkdHBfc3RyaW5nX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zdHJpbmdfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdHJpbmdfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfc3RyaW5nX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9zdHJpbmdfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonRXhwcmVzc2lvblN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGV4cHJlc3Npb246QVNUX2dldFN0cmluZ05vZGUoJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19zdG9wLCAkdHBfc3RyaW5nX2xpbmUsICR0cF9zdHJpbmdfY29sdW1uLCAkdHBfc3RyaW5nX2Nhbm9uLCBmYWxzZSl9KTtcbnBhcnNlRXhwcmVzc2lvbkFmdGVyTGl0ZXJhbChsZXhlckZsYWdzLCAkdHBfc3RyaW5nX3N0YXJ0LCAkdHBfc3RyaW5nX3N0b3AsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sICdleHByZXNzaW9uJyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApIHtcbl9wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICR0cF9zdHJpbmdfc3RhcnQsICR0cF9zdHJpbmdfbGluZSwgJHRwX3N0cmluZ19jb2x1bW4sIDE2LCAnZXhwcmVzc2lvbicpO1xufVxucGFyc2VTZW1pT3JBc2kobGV4ZXJGbGFncyk7XG5BU1RfY2xvc2UoJHRwX3N0cmluZ19zdGFydCwgJHRwX3N0cmluZ19saW5lLCAkdHBfc3RyaW5nX2NvbHVtbik7XG59XG5mdW5jdGlvbiBwYXJzZUZyb21SZWdleFN0YXRlbWVudChsZXhlckZsYWdzLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3JlZ2V4X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9yZWdleF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3JlZ2V4X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3JlZ2V4X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuc2tpcERpdihsZXhlckZsYWdzKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidFeHByZXNzaW9uU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgZXhwcmVzc2lvbjpBU1RfZ2V0UmVnZXhOb2RlKCR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X3N0b3AsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uKX0pO1xucGFyc2VFeHByZXNzaW9uQWZ0ZXJMaXRlcmFsKGxleGVyRmxhZ3MsICR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X3N0b3AsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uLCAnZXhwcmVzc2lvbicpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5fcGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCAkdHBfcmVnZXhfc3RhcnQsICR0cF9yZWdleF9saW5lLCAkdHBfcmVnZXhfY29sdW1uLCAxNiwgJ2V4cHJlc3Npb24nKTtcbn1cbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF9yZWdleF9zdGFydCwgJHRwX3JlZ2V4X2xpbmUsICR0cF9yZWdleF9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VUaWNrU3RhdGVtZW50KGxleGVyRmxhZ3MsIGFzdFByb3ApIHtcbmxldCAkdHBfdGlja19saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfdGlja19jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3RpY2tfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfdGlja19zdG9wID0gdG9rX2dldFN0b3AoKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidFeHByZXNzaW9uU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgZXhwcmVzc2lvbjp1bmRlZmluZWR9KTtcbnBhcnNlVGlja0V4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX3RpY2tfc3RhcnQsICR0cF90aWNrX3N0b3AsICR0cF90aWNrX2xpbmUsICR0cF90aWNrX2NvbHVtbiwgJ2V4cHJlc3Npb24nKTtcbnBhcnNlRXhwcmVzc2lvbkFmdGVyTGl0ZXJhbChsZXhlckZsYWdzLCAkdHBfdGlja19zdGFydCwgJHRwX3RpY2tfc3RvcCwgJHRwX3RpY2tfbGluZSwgJHRwX3RpY2tfY29sdW1uLCAnZXhwcmVzc2lvbicpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5fcGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCAkdHBfdGlja19zdGFydCwgJHRwX3RpY2tfbGluZSwgJHRwX3RpY2tfY29sdW1uLCAxNiwgJ2V4cHJlc3Npb24nKTtcbn1cbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF90aWNrX3N0YXJ0LCAkdHBfdGlja19saW5lLCAkdHBfdGlja19jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VBc3luY1N0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiwgaXNFeHBvcnQsIGV4cG9ydGVkQmluZGluZ3MsIGlzTGFiZWxsZWQsIGZkU3RhdGUsIGFzdFByb3ApIHtcbl9wYXJzZUFzeW5jKGxleGVyRmxhZ3MsIHNjb29wLCAyLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19zdG9wLCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgJHRwX2FzeW5jX2Nhbm9uLCA0LCBpc0V4cG9ydCwgdHJ1ZSwgZXhwb3J0ZWRCaW5kaW5ncywgaXNMYWJlbGxlZCwgZmRTdGF0ZSwgZmFsc2UsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VBc3luY0V4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiwgaXNOZXdBcmcsIGlzRXhwb3J0LCBhbGxvd0Fzc2lnbm1lbnQsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24sIGFzdFByb3ApIHtcbnJldHVybiBfcGFyc2VBc3luYyhsZXhlckZsYWdzLCBudWxsLCAxLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19zdG9wLCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgJHRwX2FzeW5jX2Nhbm9uLCBpc05ld0FyZywgaXNFeHBvcnQsIGFsbG93QXNzaWdubWVudCwgdW5kZWZpbmVkLCBmYWxzZSwgMSwgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBfcGFyc2VBc3luYyhsZXhlckZsYWdzLCBzY29vcCwgZnJvbVN0bXRPckV4cHIsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGlzTmV3QXJnLCBpc0V4cG9ydCwgYWxsb3dBc3NpZ25tZW50LCBleHBvcnRlZEJpbmRpbmdzLCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKSB7XG5pZiAoIWFsbG93QXN5bmNGdW5jdGlvbnMpIHtcbmlmICgoKHRva19nZXRUeXBlKCkgPT09IDIwOTUpICYmICghdG9rX2dldE5sd2FzKCkpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBc3luYyBmdW5jdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnRseSB0YXJnZXRlZCB2ZXJzaW9uLCB0aGV5IGFyZSA+PSBFUzggLyBFUzIwMTcnLCAkdHBfYXN5bmNfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHBhcnNlRXhwcmVzc2lvbkFmdGVyQXN5bmNBc1Zhck5hbWUobGV4ZXJGbGFncywgZnJvbVN0bXRPckV4cHIsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGlzTmV3QXJnLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApO1xufVxubGV0IG5ld2xpbmVBZnRlckFzeW5jID0gdG9rX2dldE5sd2FzKCkgPT09IHRydWU7XG5sZXQgJHRwX2FmdGVyQXN5bmNfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5pZiAoaXNJZGVudFRva2VuKCR0cF9hZnRlckFzeW5jX3R5cGUpKSB7XG5sZXQgJHRwX2lkZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuaWYgKG5ld2xpbmVBZnRlckFzeW5jKSB7XG5yZXR1cm4gcGFyc2VFeHByZXNzaW9uQWZ0ZXJBc3luY0FzVmFyTmFtZShsZXhlckZsYWdzLCBmcm9tU3RtdE9yRXhwciwgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiwgaXNOZXdBcmcsIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCk7XG59XG5pZiAoJHRwX2FmdGVyQXN5bmNfdHlwZSA9PT0gMjA5NSkge1xuaWYgKGxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPT09IHRydWUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQW4gYXN5bmMgZnVuY3Rpb24gZXhwcmVzc2lvbiBpcyBub3QgYWxsb3dlZCBoZXJlJywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCk7XG59XG5yZXR1cm4gcGFyc2VBc3luY0Z1bmN0aW9uRGVjbChsZXhlckZsYWdzLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCBmcm9tU3RtdE9yRXhwciwgc2Nvb3AsIGlzRXhwb3J0LCBleHBvcnRlZEJpbmRpbmdzLCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBhc3RQcm9wKTtcbn1cbmlmICgoKCR0cF9hZnRlckFzeW5jX3R5cGUgPT09IDY3NjM2KSB8fCAoJHRwX2FmdGVyQXN5bmNfdHlwZSA9PT0gNjc2MzcpKSkge1xucmV0dXJuIHBhcnNlRXhwcmVzc2lvbkFmdGVyQXN5bmNBc1Zhck5hbWUobGV4ZXJGbGFncywgZnJvbVN0bXRPckV4cHIsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGlzTmV3QXJnLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApO1xufVxuaWYgKGlzTmV3QXJnID09PSAzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBhcHBseSBgbmV3YCB0byBhbiAoYXN5bmMpIGFycm93JywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCk7XG59XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBbiBhc3luYyBmdW5jdGlvbiBleHByZXNzaW9uIGlzIG5vdCBhbGxvd2VkIGhlcmUnLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9pZGVudF9zdG9wKTtcbn1cbnBhcnNlUGFyZW5sZXNzQXJyb3dBZnRlckFzeW5jKGxleGVyRmxhZ3MsIGZyb21TdG10T3JFeHByLCBhbGxvd0Fzc2lnbm1lbnQsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIGFzdFByb3ApO1xucmV0dXJuIDE2O1xufVxuaWYgKCR0cF9hZnRlckFzeW5jX3R5cGUgPT09IDE2NDcxKSB7XG5pZiAoaXNOZXdBcmcgPT09IDMpIHtcbkFTVF9zZXRJZGVudCgnY2FsbGVlJywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbik7XG5yZXR1cm4gMzI7XG59XG5pZiAoZnJvbVN0bXRPckV4cHIgPT09IDIpIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidFeHByZXNzaW9uU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgZXhwcmVzc2lvbjp1bmRlZmluZWR9KTtcbmFzdFByb3AgPSAnZXhwcmVzc2lvbic7XG59XG5sZXQgciA9IHBhcnNlR3JvdXBUb3BsZXZlbHMobGV4ZXJGbGFncywgZnJvbVN0bXRPckV4cHIsIGFsbG93QXNzaWdubWVudCwgMjA3NCwgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiwgKG5ld2xpbmVBZnRlckFzeW5jPyB0cnVlIDogZmFsc2UpLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKTtcbmlmIChmcm9tU3RtdE9yRXhwciA9PT0gMikge1xuQVNUX2Nsb3NlKCR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4pO1xufVxucmV0dXJuIHI7XG59XG5yZXR1cm4gcGFyc2VFeHByZXNzaW9uQWZ0ZXJBc3luY0FzVmFyTmFtZShsZXhlckZsYWdzLCBmcm9tU3RtdE9yRXhwciwgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiwgaXNOZXdBcmcsIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBpc0Fzc2lnbmFibGUoc3RhdGUpIHtcbnJldHVybiAoc3RhdGUgJiAzMikgPT09IDMyO1xufVxuZnVuY3Rpb24gbm90QXNzaWduYWJsZShzdGF0ZSkge1xucmV0dXJuIChzdGF0ZSAmIDE2KSA9PT0gMTY7XG59XG5mdW5jdGlvbiBzZXRBc3NpZ25hYmxlKHN0YXRlKSB7XG5yZXR1cm4gKChzdGF0ZSB8IDMyKSB8IDE2KSBeIDE2O1xufVxuZnVuY3Rpb24gc2V0Tm90QXNzaWduYWJsZShzdGF0ZSkge1xucmV0dXJuICgoc3RhdGUgfCAzMikgfCAxNikgXiAzMjtcbn1cbmZ1bmN0aW9uIG1lcmdlQXNzaWduYWJsZShvdmVycmlkZSwgc3RhdGUpIHtcbnJldHVybiBvdmVycmlkZSB8ICgoKHN0YXRlIHwgMTYpIHwgMzIpIF4gNDgpO1xufVxuZnVuY3Rpb24gcGFyc2VBd2FpdChsZXhlckZsYWdzLCAkdHBfYXdhaXRfdHlwZSwgJHRwX2F3YWl0X3N0YXJ0LCAkdHBfYXdhaXRfc3RvcCwgJHRwX2F3YWl0X2xpbmUsICR0cF9hd2FpdF9jb2x1bW4sICR0cF9hd2FpdF9jYW5vbiwgaXNOZXdBcmcsIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCkge1xuaWYgKChsZXhlckZsYWdzICYgOCkgIT09IDApIHtcbnJldHVybiBwYXJzZUF3YWl0S2V5d29yZChsZXhlckZsYWdzLCAkdHBfYXdhaXRfc3RhcnQsICR0cF9hd2FpdF9zdG9wLCAkdHBfYXdhaXRfbGluZSwgJHRwX2F3YWl0X2NvbHVtbiwgaXNOZXdBcmcsIGFzdFByb3ApO1xufVxuaWYgKGdvYWxNb2RlID09PSBmYWxzZSkge1xucmV0dXJuIHBhcnNlQXdhaXRWYXIobGV4ZXJGbGFncywgJHRwX2F3YWl0X3N0YXJ0LCAkdHBfYXdhaXRfc3RvcCwgJHRwX2F3YWl0X2xpbmUsICR0cF9hd2FpdF9jb2x1bW4sICR0cF9hd2FpdF90eXBlLCAkdHBfYXdhaXRfY2Fub24sIGlzTmV3QXJnLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGBhd2FpdGAgYXMgdmFyIHdoZW4gZ29hbD1tb2R1bGUgYnV0IGZvdW5kIGBhd2FpdGAgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvbicsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RhcnQoKSArIDEpO1xufVxuZnVuY3Rpb24gcGFyc2VBd2FpdEtleXdvcmQobGV4ZXJGbGFncywgJHRwX2F3YWl0X3N0YXJ0LCAkdHBfYXdhaXRfc3RvcCwgJHRwX2F3YWl0X2xpbmUsICR0cF9hd2FpdF9jb2x1bW4sIGlzTmV3QXJnLCBhc3RQcm9wKSB7XG5pZiAoaXNOZXdBcmcgPT09IDMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2Fubm90IGBhd2FpdGAgYXMgdGhlIGFyZyBvZiBgbmV3YCcsICR0cF9hd2FpdF9zdGFydCwgJHRwX2F3YWl0X3N0b3ApO1xufVxuaWYgKChsZXhlckZsYWdzICYgNjQpID09PSA2NCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBd2FpdCBpcyBpbGxlZ2FsIGFzIGRlZmF1bHQgYXJnIHZhbHVlJywgJHRwX2F3YWl0X3N0YXJ0LCAkdHBfYXdhaXRfc3RvcCk7XG59XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonQXdhaXRFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgYXJndW1lbnQ6dW5kZWZpbmVkfSk7XG5wYXJzZVZhbHVlKGxleGVyRmxhZ3MsIGZhbHNlLCA0LCBmYWxzZSwgJ2FyZ3VtZW50Jyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gODIwMTApIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIGxocyBvZiAqKiBjYW4gbm90IGJlIHRoaXMga2luZCBvZiB1bmFyeSBleHByZXNzaW9uIChzeW50YWN0aWNhbGx5IG5vdCBhbGxvd2VkLCB5b3UgaGF2ZSB0byB3cmFwIHNvbWV0aGluZyknLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5BU1RfY2xvc2UoJHRwX2F3YWl0X3N0YXJ0LCAkdHBfYXdhaXRfbGluZSwgJHRwX2F3YWl0X2NvbHVtbik7XG5yZXR1cm4gODA7XG59XG5mdW5jdGlvbiBwYXJzZUF3YWl0VmFyKGxleGVyRmxhZ3MsICR0cF9hd2FpdF9zdGFydCwgJHRwX2F3YWl0X3N0b3AsICR0cF9hd2FpdF9saW5lLCAkdHBfYXdhaXRfY29sdW1uLCAkdHBfYXdhaXRfdHlwZSwgJHRwX2F3YWl0X2Nhbm9uLCBpc05ld0FyZywgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKSB7XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlSWRlbnRPclBhcmVubGVzc0Fycm93KGxleGVyRmxhZ3MsICR0cF9hd2FpdF90eXBlLCAkdHBfYXdhaXRfc3RhcnQsICR0cF9hd2FpdF9zdG9wLCAkdHBfYXdhaXRfbGluZSwgJHRwX2F3YWl0X2NvbHVtbiwgJHRwX2F3YWl0X2Nhbm9uLCAzMiwgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfYXdhaXRfc3RhcnQsICR0cF9hd2FpdF9saW5lLCAkdHBfYXdhaXRfY29sdW1uLCBhc3NpZ25hYmxlLCBpc05ld0FyZywgZmFsc2UsIGFzdFByb3ApO1xucmV0dXJuIGFzc2lnbmFibGUgfCA2NDtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBhc3RQcm9wKSB7XG5sZXQgbGV4ZXJGbGFnc05vVGVtcGxhdGUgPSAobGV4ZXJGbGFncyB8IDYxNDQpIF4gNjE0NDtcbmxldCAkdHBfY3VybHlfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2N1cmx5X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfY3VybHlfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3NOb1RlbXBsYXRlKTtcbmlmIChiYWJlbENvbXBhdCkge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0Jsb2NrU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgZGlyZWN0aXZlczpbXSwgYm9keTpbXX0pO1xufSBlbHNlIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidCbG9ja1N0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGJvZHk6W119KTtcbn1cbmlmIChvcHRpb25zX2V4cG9zZVNjb3BlcykgQVNUX3NldCgnJHNjb3BlJywgc2Nvb3ApO1xud2hpbGUgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KSB7XG5wYXJzZU5lc3RlZEJvZHlQYXJ0KGxleGVyRmxhZ3NOb1RlbXBsYXRlLCBzY29vcCwgbGFiZWxTZXQsIGZhbHNlLCAzLCBudWxsLCAnYm9keScpO1xufVxuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncyk7XG5BU1RfY2xvc2UoJHRwX2N1cmx5X3N0YXJ0LCAkdHBfY3VybHlfbGluZSwgJHRwX2N1cmx5X2NvbHVtbik7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gNDkyNjQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQSBzdGF0ZW1lbnQgY2FuIG5vdCBzdGFydCB3aXRoIG9iamVjdCBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgKGJlY2F1c2UgYmxvY2spJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuZnVuY3Rpb24gcGFyc2VCcmVha1N0YXRlbWVudChsZXhlckZsYWdzLCBsYWJlbFNldCwgYXN0UHJvcCkge1xubGV0ICR0cF9icmVha19saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfYnJlYWtfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9icmVha19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9icmVha19zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xubGV0ICR0cF9hZnRlckJyZWFrX3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xuaWYgKChpc0lkZW50VG9rZW4oJHRwX2FmdGVyQnJlYWtfdHlwZSkgJiYgKHRva19nZXRObHdhcygpID09PSBmYWxzZSkpKSB7XG5sZXQgJHRwX2xhYmVsX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9sYWJlbF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2xhYmVsX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2xhYmVsX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9sYWJlbF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuZmluZExhYmVsRm9yQnJlYWsobGFiZWxTZXQsICR0cF9sYWJlbF9zdGFydCwgJHRwX2xhYmVsX3N0b3AsICR0cF9sYWJlbF9jYW5vbik7XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbmlmICgoKHRva19nZXRObHdhcygpID09PSB0cnVlKSAmJiBpc1JlZ2V4VG9rZW4odG9rX2dldFR5cGUoKSkpKSB7XG50b2tfYXNpKCk7XG59IGVsc2Uge1xucGFyc2VTZW1pT3JBc2kobGV4ZXJGbGFncyk7XG59XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonQnJlYWtTdGF0ZW1lbnQnLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfYnJlYWtfc3RhcnQsICR0cF9icmVha19saW5lLCAkdHBfYnJlYWtfY29sdW1uKSwgbGFiZWw6QVNUX2dldElkZW50Tm9kZSgkdHBfbGFiZWxfc3RhcnQsICR0cF9sYWJlbF9zdG9wLCAkdHBfbGFiZWxfbGluZSwgJHRwX2xhYmVsX2NvbHVtbiwgJHRwX2xhYmVsX2Nhbm9uKX0pO1xufSBlbHNlIGlmICgobGV4ZXJGbGFncyAmIDE1MzYpID09PSAwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBvbmx5IGBicmVha2Agd2l0aG91dCBsYWJlbCBpbnNpZGUgYSBgc3dpdGNoYCBvciBsb29wJywgJHRwX2JyZWFrX3N0YXJ0LCAkdHBfYnJlYWtfc3RvcCk7XG59IGVsc2Uge1xuaWYgKCgodG9rX2dldE5sd2FzKCkgPT09IHRydWUpICYmIGlzUmVnZXhUb2tlbigkdHBfYWZ0ZXJCcmVha190eXBlKSkpIHtcbnRva19hc2koKTtcbn0gZWxzZSB7XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbn1cbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidCcmVha1N0YXRlbWVudCcsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9icmVha19zdGFydCwgJHRwX2JyZWFrX2xpbmUsICR0cF9icmVha19jb2x1bW4pLCBsYWJlbDpudWxsfSk7XG59XG59XG5mdW5jdGlvbiBmaW5kTGFiZWxGb3JCcmVhayhpbnB1dExhYmVsU2V0LCAkdHBfbGFiZWxfc3RhcnQsICR0cF9sYWJlbF9zdG9wLCAkdHBfbGFiZWxOYW1lX2Nhbm9uKSB7XG5pZiAoaW5wdXRMYWJlbFNldCA9PT0gbnVsbCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKGBUaGUgbGFiZWwgKFxcYCR7dG9rX3NsaWNlSW5wdXQoJHRwX2xhYmVsX3N0YXJ0LCAkdHBfbGFiZWxfc3RvcCl9XFxgKSBmb3IgdGhpcyBcXGBicmVha1xcYCB3YXMgbm90IGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbGFiZWwgc2V0LCB3aGljaCBpcyBpbGxlZ2FsYCwgJHRwX2xhYmVsX3N0YXJ0LCAkdHBfbGFiZWxfc3RvcCk7XG59XG5sZXQgbGFiZWxTZXQgPSBpbnB1dExhYmVsU2V0O1xubGV0IGlkID0gJHRwX2xhYmVsTmFtZV9jYW5vbjtcbmRvIHtcbmlmIChsYWJlbFNldC5zdGF0ZW1lbnRMYWJlbHMuaGFzKGlkKSkge1xucmV0dXJuO1xufVxufSB3aGlsZSAobGFiZWxTZXQgPSBsYWJlbFNldC5wYXJlbnRMYWJlbHMpO1xuVEhST1dfUkFOR0UoKCdUaGUgbGFiZWwgKGAnICsgJHRwX2xhYmVsTmFtZV9jYW5vbikgKyAnYCkgZm9yIHRoaXMgYGJyZWFrYCB3YXMgbm90IGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbGFiZWwgc2V0LCB3aGljaCBpcyBpbGxlZ2FsJywgJHRwX2xhYmVsX3N0YXJ0LCAkdHBfbGFiZWxfc3RvcCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxhYmVsRm9yQ29udGludWUobGFiZWxTZXQsICR0cF9sYWJlbF9jYW5vbiwgJHRwX2xhYmVsX3N0YXJ0LCAkdHBfbGFiZWxfc3RvcCkge1xuaWYgKGxhYmVsU2V0ID09PSBudWxsKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdUaGlzIGBjb250aW51ZWAgaGFkIGEgbGFiZWwgKGAnICsgJHRwX2xhYmVsX2Nhbm9uKSArICdgKSB0aGF0IHdhcyBub3QgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBsYWJlbCBzZXQgYXMgdGhlIGRpcmVjdCBwYXJlbnQgb2YgYSBsb29wLCB3aGljaCB3b3VsZCBiZSByZXF1aXJlZCcsICR0cF9sYWJlbF9zdGFydCwgJHRwX2xhYmVsX3N0b3ApO1xufVxubGV0IHNldCA9IGxhYmVsU2V0O1xuZG8ge1xuaWYgKChzZXQuaXRlcmF0aW9uTGFiZWxzICYmIHNldC5pdGVyYXRpb25MYWJlbHMuaGFzKCR0cF9sYWJlbF9jYW5vbikpKSB7XG5yZXR1cm47XG59XG59IHdoaWxlIChzZXQgPSBzZXQucGFyZW50TGFiZWxzKTtcbnJldHVybiBUSFJPV19SQU5HRSgoJ1RoaXMgYGNvbnRpbnVlYCBoYWQgYSBsYWJlbCAoYCcgKyAkdHBfbGFiZWxfY2Fub24pICsgJ2ApIHRoYXQgd2FzIG5vdCBkZWZpbmVkIGluIHRoZSBjdXJyZW50IGxhYmVsIHNldCBhcyB0aGUgZGlyZWN0IHBhcmVudCBvZiBhIGxvb3AsIHdoaWNoIHdvdWxkIGJlIHJlcXVpcmVkJywgJHRwX2xhYmVsX3N0YXJ0LCAkdHBfbGFiZWxfc3RvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnN0U3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBpc0xhYmVsbGVkLCBmZFN0YXRlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2NvbnN0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9jb25zdF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2NvbnN0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2NvbnN0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuc2tpcFRvQmluZGluZ1N0YXJ0KGxleGVyRmxhZ3MpO1xuaWYgKCgoKChpc0xhYmVsbGVkID09PSB0cnVlKSB8fCAoZmRTdGF0ZSA9PT0gMSkpKSB8fCAoZmRTdGF0ZSA9PT0gMikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBwYXJzZSBhIGxhYmVsbGVkIGNvbnN0IGRlY2xhcmF0aW9uLCBvbmx5IGV4cGVjdGluZyBzdGF0ZW1lbnRzIGhlcmUnLCAkdHBfY29uc3Rfc3RhcnQsICR0cF9jb25zdF9zdG9wKTtcbn1cbnBhcnNlQW55VmFyRGVjbGFyYXRpb24obGV4ZXJGbGFncywgJHRwX2NvbnN0X3N0YXJ0LCAkdHBfY29uc3RfbGluZSwgJHRwX2NvbnN0X2NvbHVtbiwgc2Nvb3AsIDcsIDEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGludWVTdGF0ZW1lbnQobGV4ZXJGbGFncywgbGFiZWxTZXQsIGFzdFByb3ApIHtcbmxldCAkdHBfY29udGludWVfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2NvbnRpbnVlX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfY29udGludWVfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmlmICgobGV4ZXJGbGFncyAmIDUxMikgPT09IDApIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2FuIG9ubHkgYGNvbnRpbnVlYCBpbnNpZGUgYSBsb29wJywgJHRwX2NvbnRpbnVlX3N0YXJ0LCAkdHBfY29udGludWVfc3RhcnQgKyAxKTtcbn1cbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xuaWYgKChpc0lkZW50VG9rZW4odG9rX2dldFR5cGUoKSkgJiYgKHRva19nZXRObHdhcygpID09PSBmYWxzZSkpKSB7XG5sZXQgJHRwX2xhYmVsX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9sYWJlbF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2xhYmVsX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2xhYmVsX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9sYWJlbF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xudmFsaWRhdGVMYWJlbEZvckNvbnRpbnVlKGxhYmVsU2V0LCAkdHBfbGFiZWxfY2Fub24sICR0cF9sYWJlbF9zdGFydCwgJHRwX2xhYmVsX3N0b3ApO1xuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncyk7XG5pZiAoKCh0b2tfZ2V0Tmx3YXMoKSA9PT0gdHJ1ZSkgJiYgaXNSZWdleFRva2VuKHRva19nZXRUeXBlKCkpKSkge1xudG9rX2FzaSgpO1xufSBlbHNlIHtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xufVxuQVNUX3NldE5vZGUoYXN0UHJvcCwge3R5cGU6J0NvbnRpbnVlU3RhdGVtZW50JywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX2NvbnRpbnVlX3N0YXJ0LCAkdHBfY29udGludWVfbGluZSwgJHRwX2NvbnRpbnVlX2NvbHVtbiksIGxhYmVsOkFTVF9nZXRJZGVudE5vZGUoJHRwX2xhYmVsX3N0YXJ0LCAkdHBfbGFiZWxfc3RvcCwgJHRwX2xhYmVsX2xpbmUsICR0cF9sYWJlbF9jb2x1bW4sICR0cF9sYWJlbF9jYW5vbil9KTtcbn0gZWxzZSB7XG5pZiAoKCh0b2tfZ2V0Tmx3YXMoKSA9PT0gdHJ1ZSkgJiYgaXNSZWdleFRva2VuKHRva19nZXRUeXBlKCkpKSkge1xudG9rX2FzaSgpO1xufSBlbHNlIHtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xufVxuQVNUX3NldE5vZGUoYXN0UHJvcCwge3R5cGU6J0NvbnRpbnVlU3RhdGVtZW50JywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX2NvbnRpbnVlX3N0YXJ0LCAkdHBfY29udGludWVfbGluZSwgJHRwX2NvbnRpbnVlX2NvbHVtbiksIGxhYmVsOm51bGx9KTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9kZWJ1Z2dlcl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfZGVidWdnZXJfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9kZWJ1Z2dlcl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9kZWJ1Z2dlcl9zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xuaWYgKGlzUmVnZXhUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xuaWYgKHRva19nZXRObHdhcygpID09PSBmYWxzZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdNaXNzaW5nIHNlbWktY29sb24gYWZ0ZXIgZGVidWdnZXIga2V5d29yZCcsICR0cF9kZWJ1Z2dlcl9zdG9wLCAkdHBfZGVidWdnZXJfc3RvcCk7XG59XG50b2tfYXNpKCk7XG59IGVsc2Uge1xucGFyc2VTZW1pT3JBc2kobGV4ZXJGbGFncyk7XG59XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonRGVidWdnZXJTdGF0ZW1lbnQnLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfZGVidWdnZXJfc3RhcnQsICR0cF9kZWJ1Z2dlcl9saW5lLCAkdHBfZGVidWdnZXJfY29sdW1uKX0pO1xufVxuZnVuY3Rpb24gcGFyc2VEb1N0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGFzdFByb3ApIHtcbmxldCAkdHBfZG9fbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2RvX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfZG9fc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0RvV2hpbGVTdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBib2R5OnVuZGVmaW5lZCwgdGVzdDp1bmRlZmluZWR9KTtcbnBhcnNlTmVzdGVkQm9keVBhcnQobGV4ZXJGbGFncyB8IDUxMiwgc2Nvb3AsIGxhYmVsU2V0LCBmYWxzZSwgMSwgbnVsbCwgJ2JvZHknKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAyMTI0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdBIGBkb2AgbXVzdCBiZSBmb2xsb3dlZCBieSBhIGB3aGlsZWAsIGJ1dCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvUGFyZW5PcGVuT3JEaWUobGV4ZXJGbGFncyk7XG5wYXJzZVN0YXRlbWVudEhlYWRlcihsZXhlckZsYWdzLCAndGVzdCcpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDkwKSB7XG50b2tfYXNpKCk7XG59IGVsc2Uge1xucGFyc2VTZW1pT3JBc2kobGV4ZXJGbGFncyk7XG59XG5BU1RfY2xvc2UoJHRwX2RvX3N0YXJ0LCAkdHBfZG9fbGluZSwgJHRwX2RvX2NvbHVtbik7XG59XG5mdW5jdGlvbiBwYXJzZUV4cG9ydERlZmF1bHRBc3luYyhsZXhlckZsYWdzLCBzY29vcCwgZXhwb3J0ZWRCaW5kaW5ncykge1xubGV0ICR0cF9hc3luY19saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfYXN5bmNfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9hc3luY19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9hc3luY19zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfYXN5bmNfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBSZXgobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMjA5NSkge1xucmV0dXJuIHBhcnNlQXN5bmNTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIHRydWUsIGV4cG9ydGVkQmluZGluZ3MsIGZhbHNlLCA0LCAnZGVjbGFyYXRpb24nKTtcbn1cbnBhcnNlQXN5bmNFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIDQsIHRydWUsIHRydWUsIGZhbHNlLCAnZGVjbGFyYXRpb24nKTtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHBvcnREZWZhdWx0KGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZXhwb3J0X2xpbmUsICR0cF9leHBvcnRfY29sdW1uLCAkdHBfZGVmYXVsdF9zdGFydCwgJHRwX2RlZmF1bHRfc3RvcCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsIGxvYzp1bmRlZmluZWQsIGRlY2xhcmF0aW9uOnVuZGVmaW5lZH0pO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xuU0NPUEVfYWRkTGV4QmluZGluZyhzY29vcCwgJHRwX2RlZmF1bHRfc3RhcnQsICR0cF9kZWZhdWx0X3N0b3AsICcqZGVmYXVsdConLCA2LCA0KTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2RlZmF1bHRfc3RhcnQsICR0cF9kZWZhdWx0X3N0b3AsICdkZWZhdWx0Jyk7XG5hZGRCaW5kaW5nVG9FeHBvcnRzKGV4cG9ydGVkQmluZGluZ3MsICcqZGVmYXVsdConKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAyMDc5KSB7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbiA9IHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihsZXhlckZsYWdzLCBzY29vcCwgdHJ1ZSwgZmFsc2UsIDMsICdkZWNsYXJhdGlvbicpO1xuYWRkQmluZGluZ1RvRXhwb3J0cyhleHBvcnRlZEJpbmRpbmdzLCAkdHBfZXhwb3J0ZWROYW1lX2Nhbm9uKTtcbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMjA5NSkge1xubGV0ICR0cF9mdW5jdGlvbl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfZnVuY3Rpb25fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9mdW5jdGlvbl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9mdW5jdGlvbl9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX2Nhbm9uID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKGxleGVyRmxhZ3MsIHNjb29wLCB0cnVlLCBmYWxzZSwgMCwgJHRwX2Z1bmN0aW9uX3N0YXJ0LCAkdHBfZnVuY3Rpb25fbGluZSwgJHRwX2Z1bmN0aW9uX2NvbHVtbiwgJHRwX2V4cG9ydF9zdGFydCwgJHRwX2Z1bmN0aW9uX3N0b3AsIHRydWUsIGZhbHNlLCA0LCAnZGVjbGFyYXRpb24nKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbik7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDIwNzQpIHtcbnBhcnNlRXhwb3J0RGVmYXVsdEFzeW5jKGxleGVyRmxhZ3MsIHNjb29wLCBleHBvcnRlZEJpbmRpbmdzKTtcbn0gZWxzZSB7XG5wYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJ2RlY2xhcmF0aW9uJyk7XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbn1cbkFTVF9jbG9zZSgkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZXhwb3J0X2xpbmUsICR0cF9leHBvcnRfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwb3J0U3RhcihsZXhlckZsYWdzLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZXhwb3J0X2xpbmUsICR0cF9leHBvcnRfY29sdW1uLCBleHBvcnRlZE5hbWVzLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3N0YXJfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3N0YXJfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdGFyX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwNzMpIHtcbmlmICghYWxsb3dFeHBvcnRTdGFyQXMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIGBleHBvcnQgKiBhcyB4IGZyb20gc3JjYCwgc3ludGF4IHdhcyBpbnRyb2R1Y2VkIGluIEVTMjAyMCBidXQgY3VycmVudGx5IHRhcmdldGVkIHZlcnNpb24gaXMgbG93ZXInLCAkdHBfZXhwb3J0X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBUb0lkZW50T3JEaWUobGV4ZXJGbGFncyk7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5hZGROYW1lVG9FeHBvcnRzKGV4cG9ydGVkTmFtZXMsICR0cF9leHBvcnRlZE5hbWVfc3RhcnQsICR0cF9leHBvcnRlZE5hbWVfc3RvcCwgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbik7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xubGV0IHNwZWNpZmllcnMgPSBbe3R5cGU6J0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9zdGFyX3N0YXJ0LCAkdHBfc3Rhcl9saW5lLCAkdHBfc3Rhcl9jb2x1bW4pLCBleHBvcnRlZDpBU1RfZ2V0SWRlbnROb2RlKCR0cF9leHBvcnRlZE5hbWVfc3RhcnQsICR0cF9leHBvcnRlZE5hbWVfc3RvcCwgJHRwX2V4cG9ydGVkTmFtZV9saW5lLCAkdHBfZXhwb3J0ZWROYW1lX2NvbHVtbiwgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbil9XTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAyMDk0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0byBmaW5kIGBhc2Agb3IgYGZyb21gLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvU3RyaW5nT3JEaWUobGV4ZXJGbGFncyk7XG5sZXQgJHRwX3NvdXJjZV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfc291cmNlX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc291cmNlX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3NvdXJjZV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfc291cmNlX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbmxldCBzb3VyY2UgPSBBU1RfZ2V0U3RyaW5nTm9kZSgkdHBfc291cmNlX3N0YXJ0LCAkdHBfc291cmNlX3N0b3AsICR0cF9zb3VyY2VfbGluZSwgJHRwX3NvdXJjZV9jb2x1bW4sICR0cF9zb3VyY2VfY2Fub24sIGZhbHNlKTtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuaWYgKGJhYmVsQ29tcGF0KSB7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9leHBvcnRfc3RhcnQsICR0cF9leHBvcnRfbGluZSwgJHRwX2V4cG9ydF9jb2x1bW4pLCBzcGVjaWZpZXJzLCBzb3VyY2V9KTtcbn0gZWxzZSB7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9leHBvcnRfc3RhcnQsICR0cF9leHBvcnRfbGluZSwgJHRwX2V4cG9ydF9jb2x1bW4pLCBzcGVjaWZpZXJzLCBkZWNsYXJhdGlvbjpudWxsLCBzb3VyY2V9KTtcbn1cbnJldHVybjtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAyMDk0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0byBmaW5kIGBhc2Agb3IgYGZyb21gLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvU3RyaW5nT3JEaWUobGV4ZXJGbGFncyk7XG5sZXQgJHRwX3NvdXJjZV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfc291cmNlX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc291cmNlX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3NvdXJjZV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfc291cmNlX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbmxldCBzb3VyY2UgPSBBU1RfZ2V0U3RyaW5nTm9kZSgkdHBfc291cmNlX3N0YXJ0LCAkdHBfc291cmNlX3N0b3AsICR0cF9zb3VyY2VfbGluZSwgJHRwX3NvdXJjZV9jb2x1bW4sICR0cF9zb3VyY2VfY2Fub24sIGZhbHNlKTtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX3NldE5vZGUoYXN0UHJvcCwge3R5cGU6J0V4cG9ydEFsbERlY2xhcmF0aW9uJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX2V4cG9ydF9zdGFydCwgJHRwX2V4cG9ydF9saW5lLCAkdHBfZXhwb3J0X2NvbHVtbiksIHNvdXJjZX0pO1xufVxuZnVuY3Rpb24gcGFyc2VFeHBvcnROYW1lZChsZXhlckZsYWdzLCBzY29vcCwgJHRwX2V4cG9ydF9zdGFydCwgJHRwX2V4cG9ydF9zdG9wLCAkdHBfZXhwb3J0X2xpbmUsICR0cF9leHBvcnRfY29sdW1uLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsIGxvYzp1bmRlZmluZWQsIHNwZWNpZmllcnM6W10sIGRlY2xhcmF0aW9uOnVuZGVmaW5lZCwgc291cmNlOnVuZGVmaW5lZH0pO1xubGV0IG5lZWRzU2VtaSA9IHRydWU7XG5sZXQgJHRwX2V4cG9ydFZhbHVlU3RhcnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2V4cG9ydFZhbHVlU3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9leHBvcnRWYWx1ZVN0YXJ0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2V4cG9ydFZhbHVlU3RhcnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MTMpIHtcbkFTVF9zZXQoJ2RlY2xhcmF0aW9uJywgbnVsbCk7XG5sZXQgdG1wRXhwb3J0ZWROYW1lcyA9IG5ldyBTZXQoKTtcbmxldCB0bXBFeHBvcnRlZEJpbmRpbmdzID0gbmV3IFNldCgpO1xucGFyc2VFeHBvcnRPYmplY3QobGV4ZXJGbGFncywgdG1wRXhwb3J0ZWROYW1lcywgdG1wRXhwb3J0ZWRCaW5kaW5ncyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMjA5NCkge1xuc2tpcFRvU3RyaW5nT3JEaWUobGV4ZXJGbGFncyk7XG5sZXQgJHRwX2Zyb21fbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2Zyb21fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9mcm9tX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2Zyb21fc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2Zyb21fY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xuQVNUX3NldFN0cmluZ0xpdGVyYWwoJ3NvdXJjZScsICR0cF9mcm9tX3N0YXJ0LCAkdHBfZnJvbV9zdG9wLCAkdHBfZnJvbV9saW5lLCAkdHBfZnJvbV9jb2x1bW4sICR0cF9mcm9tX2Nhbm9uLCBmYWxzZSk7XG59IGVsc2Uge1xuQVNUX3NldCgnc291cmNlJywgbnVsbCk7XG50bXBFeHBvcnRlZE5hbWVzLmZvckVhY2gobmFtZSA9PiAoYWRkTmFtZVRvRXhwb3J0cyhleHBvcnRlZE5hbWVzLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZXhwb3J0X3N0b3AsIG5hbWUpKSk7XG50bXBFeHBvcnRlZEJpbmRpbmdzLmZvckVhY2gobmFtZSA9PiAoYWRkQmluZGluZ1RvRXhwb3J0cyhleHBvcnRlZEJpbmRpbmdzLCBuYW1lKSkpO1xufVxufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAyMTIyKSB7XG5sZXQgJHRwX3Zhcl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfdmFyX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfdmFyX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5za2lwVG9CaW5kaW5nU3RhcnQobGV4ZXJGbGFncyk7XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MsICR0cF92YXJfc3RhcnQsICR0cF92YXJfbGluZSwgJHRwX3Zhcl9jb2x1bW4sIHNjb29wLCAyLCAzLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCAnZGVjbGFyYXRpb24nKTtcbkFTVF9zZXQoJ3NvdXJjZScsIG51bGwpO1xubmVlZHNTZW1pID0gZmFsc2U7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDIxMDMpIHtcbmxldCAkdHBfbGV0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9sZXRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9sZXRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbnNraXBUb0JpbmRpbmdTdGFydChsZXhlckZsYWdzKTtcbnBhcnNlQW55VmFyRGVjbGFyYXRpb24obGV4ZXJGbGFncywgJHRwX2xldF9zdGFydCwgJHRwX2xldF9saW5lLCAkdHBfbGV0X2NvbHVtbiwgc2Nvb3AsIDYsIDMsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsICdkZWNsYXJhdGlvbicpO1xuQVNUX3NldCgnc291cmNlJywgbnVsbCk7XG5uZWVkc1NlbWkgPSBmYWxzZTtcbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMjA4MCkge1xubGV0ICR0cF9jb25zdF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfY29uc3RfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9jb25zdF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvQmluZGluZ1N0YXJ0KGxleGVyRmxhZ3MpO1xucGFyc2VBbnlWYXJEZWNsYXJhdGlvbihsZXhlckZsYWdzLCAkdHBfY29uc3Rfc3RhcnQsICR0cF9jb25zdF9saW5lLCAkdHBfY29uc3RfY29sdW1uLCBzY29vcCwgNywgMywgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgJ2RlY2xhcmF0aW9uJyk7XG5BU1Rfc2V0KCdzb3VyY2UnLCBudWxsKTtcbm5lZWRzU2VtaSA9IGZhbHNlO1xufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAyMDc5KSB7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbiA9IHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihsZXhlckZsYWdzLCBzY29vcCwgZmFsc2UsIGZhbHNlLCAzLCAnZGVjbGFyYXRpb24nKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2V4cG9ydFZhbHVlU3RhcnRfc3RhcnQsICR0cF9leHBvcnRWYWx1ZVN0YXJ0X3N0b3AsICR0cF9leHBvcnRlZE5hbWVfY2Fub24pO1xuYWRkQmluZGluZ1RvRXhwb3J0cyhleHBvcnRlZEJpbmRpbmdzLCAkdHBfZXhwb3J0ZWROYW1lX2Nhbm9uKTtcbm5lZWRzU2VtaSA9IGZhbHNlO1xuQVNUX3NldCgnc291cmNlJywgbnVsbCk7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDIwOTUpIHtcbmxldCAkdHBfZnVuY3Rpb25fc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbiA9IHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihsZXhlckZsYWdzLCBzY29vcCwgdHJ1ZSwgZmFsc2UsIDAsICR0cF9leHBvcnRWYWx1ZVN0YXJ0X3N0YXJ0LCAkdHBfZXhwb3J0VmFsdWVTdGFydF9saW5lLCAkdHBfZXhwb3J0VmFsdWVTdGFydF9jb2x1bW4sICR0cF9leHBvcnRfc3RhcnQsICR0cF9mdW5jdGlvbl9zdG9wLCBmYWxzZSwgZmFsc2UsIDMsICdkZWNsYXJhdGlvbicpO1xuYWRkTmFtZVRvRXhwb3J0cyhleHBvcnRlZE5hbWVzLCAkdHBfZXhwb3J0VmFsdWVTdGFydF9zdGFydCwgJHRwX2V4cG9ydFZhbHVlU3RhcnRfc3RvcCwgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbik7XG5hZGRCaW5kaW5nVG9FeHBvcnRzKGV4cG9ydGVkQmluZGluZ3MsICR0cF9leHBvcnRlZE5hbWVfY2Fub24pO1xuQVNUX3NldCgnc291cmNlJywgbnVsbCk7XG5uZWVkc1NlbWkgPSBmYWxzZTtcbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMjA3NCkge1xubGV0ICR0cF9hc3luY19saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfYXN5bmNfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9hc3luY19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9hc3luY19zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMjA5NSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW4gb25seSBleHBvcnQgYXN5bmMgZnVuY3Rpb25zIChub3QgYXJyb3dzKSwgZGlkIG5vdCBmaW5kIGEgZnVuY3Rpb24nLCAkdHBfZXhwb3J0X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICh0b2tfZ2V0Tmx3YXMoKSA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBc3luYyBjYW4gbm90IGJlIGZvbGxvd2VkIGJ5IGEgbmV3bGluZSBhcyBpdCByZXN1bHRzIGluIGBleHBvcnQgYXN5bmM7YCwgd2hpY2ggaXMgbm90IHZhbGlkIChhbmQgcHJvYmFibHkgbm90IHdoYXQgeW91IHdhbnRlZCknLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCk7XG59XG5sZXQgJHRwX2Z1bmN0aW9uX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2Z1bmN0aW9uX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9leHBvcnRlZE5hbWVfY2Fub24gPSBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obGV4ZXJGbGFncywgc2Nvb3AsIHRydWUsIGZhbHNlLCAyMDc0LCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZnVuY3Rpb25fc3RvcCwgZmFsc2UsIGZhbHNlLCAzLCAnZGVjbGFyYXRpb24nKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2Z1bmN0aW9uX3N0YXJ0LCAkdHBfZnVuY3Rpb25fc3RvcCwgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbik7XG5hZGRCaW5kaW5nVG9FeHBvcnRzKGV4cG9ydGVkQmluZGluZ3MsICR0cF9leHBvcnRlZE5hbWVfY2Fub24pO1xuQVNUX3NldCgnc291cmNlJywgbnVsbCk7XG5uZWVkc1NlbWkgPSBmYWxzZTtcbn0gZWxzZSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdVbmtub3duIGV4cG9ydCB0eXBlIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIChub3RlOiB5b3UgY2FuIG9ubHkgZXhwb3J0IGluZGl2aWR1YWwgdmFycyB0aHJvdWdoIGBleHBvcnQge2Zvb307YCknLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAobmVlZHNTZW1pKSB7XG5pZiAoKCh0b2tfZ2V0Tmx3YXMoKSA9PT0gdHJ1ZSkgJiYgaXNSZWdleFRva2VuKHRva19nZXRUeXBlKCkpKSkge1xudG9rX2FzaSgpO1xufSBlbHNlIHtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xufVxufVxuQVNUX2Nsb3NlKCR0cF9leHBvcnRfc3RhcnQsICR0cF9leHBvcnRfbGluZSwgJHRwX2V4cG9ydF9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VFeHBvcnRTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGlzR2xvYmFsVG9wbGV2ZWwsIGFzdFByb3ApIHtcbmxldCAkdHBfZXhwb3J0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9leHBvcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9leHBvcnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfZXhwb3J0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuaWYgKGdvYWxNb2RlICE9PSB0cnVlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBgZXhwb3J0YCBrZXl3b3JkIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB0aGUgbW9kdWxlIGdvYWwnLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZXhwb3J0X3N0b3ApO1xufVxuaWYgKGlzR2xvYmFsVG9wbGV2ZWwgPT09IGZhbHNlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBgZXhwb3J0YCBrZXl3b3JkIGlzIG9ubHkgc3VwcG9ydGVkIGF0IHRoZSB0b3AgbGV2ZWwnLCAkdHBfZXhwb3J0X3N0YXJ0LCAkdHBfZXhwb3J0X3N0b3ApO1xufVxuc2tpcFRvSWRlbnRTdGFyQ3VybHlPcGVuKGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwODMpIHtcbmxldCAkdHBfZGVmYXVsdF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9kZWZhdWx0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xucmV0dXJuIHBhcnNlRXhwb3J0RGVmYXVsdChsZXhlckZsYWdzLCBzY29vcCwgJHRwX2V4cG9ydF9zdGFydCwgJHRwX2V4cG9ydF9saW5lLCAkdHBfZXhwb3J0X2NvbHVtbiwgJHRwX2RlZmF1bHRfc3RhcnQsICR0cF9kZWZhdWx0X3N0b3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDA5KSB7XG5yZXR1cm4gcGFyc2VFeHBvcnRTdGFyKGxleGVyRmxhZ3MsICR0cF9leHBvcnRfc3RhcnQsICR0cF9leHBvcnRfbGluZSwgJHRwX2V4cG9ydF9jb2x1bW4sIGV4cG9ydGVkTmFtZXMsIGFzdFByb3ApO1xufVxucmV0dXJuIHBhcnNlRXhwb3J0TmFtZWQobGV4ZXJGbGFncywgc2Nvb3AsICR0cF9leHBvcnRfc3RhcnQsICR0cF9leHBvcnRfc3RvcCwgJHRwX2V4cG9ydF9saW5lLCAkdHBfZXhwb3J0X2NvbHVtbiwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBhZGROYW1lVG9FeHBvcnRzKGV4cG9ydGVkTmFtZXMsICR0cF9leHBvcnRlZE5hbWVfc3RhcnQsICR0cF9leHBvcnRlZE5hbWVfc3RvcCwgZXhwb3J0ZWROYW1lKSB7XG5pZiAoKChleHBvcnRlZE5hbWVzICE9PSB1bmRlZmluZWQpICYmIChleHBvcnRlZE5hbWUgIT09ICcnKSkpIHtcbmlmIChleHBvcnRlZE5hbWVzLmhhcyhleHBvcnRlZE5hbWUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdUcmllZCB0byBleHBvcnQgdGhlIG5hbWUgYCcgKyBleHBvcnRlZE5hbWUpICsgJ2AgdHdpY2UnLCAkdHBfZXhwb3J0ZWROYW1lX3N0YXJ0LCAkdHBfZXhwb3J0ZWROYW1lX3N0b3ApO1xufVxuZXhwb3J0ZWROYW1lcy5hZGQoZXhwb3J0ZWROYW1lKTtcbn1cbn1cbmZ1bmN0aW9uIGFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgZXhwb3J0ZWRUb2tlbkNhbm9uTmFtZSkge1xuaWYgKCgoZXhwb3J0ZWRCaW5kaW5ncyAhPT0gdW5kZWZpbmVkKSAmJiAoZXhwb3J0ZWRUb2tlbkNhbm9uTmFtZSAhPT0gJycpKSkge1xuZXhwb3J0ZWRCaW5kaW5ncy5hZGQoZXhwb3J0ZWRUb2tlbkNhbm9uTmFtZSk7XG59XG59XG5mdW5jdGlvbiBwYXJzZUV4cG9ydE9iamVjdChsZXhlckZsYWdzLCB0bXBFeHBvcnRlZE5hbWVzLCB0bXBFeHBvcnRlZEJpbmRpbmdzKSB7XG5za2lwVG9JZGVudEN1cmx5Q2xvc2UobGV4ZXJGbGFncyk7XG53aGlsZSAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5wYXJzZUV4cG9ydFNwZWNpZmllcihsZXhlckZsYWdzLCB0bXBFeHBvcnRlZE5hbWVzLCB0bXBFeHBvcnRlZEJpbmRpbmdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ4MCkgYnJlYWs7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KSB7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODYpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRXhwb3J0IG9iamVjdCBjYW5ub3QgaGF2ZSBzcHJlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRXhwb3J0IG9iamVjdCB1c2VzIGBhc2AgdG8gYWxpYXMgKGB7YSBhcyB5fWApLCBub3QgY29sb24gKGB7YTogeX1gKScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgnRXhwb3J0IG9iamVjdCBjYW4gb25seSBoYXZlIFwic2hvcnRoYW5kXCIgYHt4fWAgb3IgXCJhc1wiIGB7eCBhcyB5fScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHBvcnRTcGVjaWZpZXIobGV4ZXJGbGFncywgdG1wRXhwb3J0ZWROYW1lcywgdG1wRXhwb3J0ZWRCaW5kaW5ncykge1xubGV0ICR0cF9uYW1lX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9uYW1lX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfbmFtZV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9uYW1lX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9uYW1lX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2V4cG9ydGVkTmFtZV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfZXhwb3J0ZWROYW1lX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwNzMpIHtcbnNraXBUb0lkZW50T3JEaWUobGV4ZXJGbGFncyk7XG4kdHBfZXhwb3J0ZWROYW1lX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xuJHRwX2V4cG9ydGVkTmFtZV9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG4kdHBfZXhwb3J0ZWROYW1lX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG4kdHBfZXhwb3J0ZWROYW1lX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuJHRwX2V4cG9ydGVkTmFtZV9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmFkZE5hbWVUb0V4cG9ydHModG1wRXhwb3J0ZWROYW1lcywgJHRwX2V4cG9ydGVkTmFtZV9zdGFydCwgJHRwX2V4cG9ydGVkTmFtZV9zdG9wLCAkdHBfZXhwb3J0ZWROYW1lX2Nhbm9uKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHModG1wRXhwb3J0ZWRCaW5kaW5ncywgJHRwX25hbWVfY2Fub24pO1xuQVNUX3NldE5vZGUoJ3NwZWNpZmllcnMnLCB7dHlwZTonRXhwb3J0U3BlY2lmaWVyJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX25hbWVfc3RhcnQsICR0cF9uYW1lX2xpbmUsICR0cF9uYW1lX2NvbHVtbiksIGxvY2FsOkFTVF9nZXRJZGVudE5vZGUoJHRwX25hbWVfc3RhcnQsICR0cF9uYW1lX3N0b3AsICR0cF9uYW1lX2xpbmUsICR0cF9uYW1lX2NvbHVtbiwgJHRwX25hbWVfY2Fub24pLCBleHBvcnRlZDpBU1RfZ2V0SWRlbnROb2RlKCR0cF9leHBvcnRlZE5hbWVfc3RhcnQsICR0cF9leHBvcnRlZE5hbWVfc3RvcCwgJHRwX2V4cG9ydGVkTmFtZV9saW5lLCAkdHBfZXhwb3J0ZWROYW1lX2NvbHVtbiwgJHRwX2V4cG9ydGVkTmFtZV9jYW5vbil9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCkge1xuc2Nvb3AgPSBTQ09QRV9hZGRMYXllcihzY29vcCwgMSwgJ3BhcnNlRm9yU3RhdGVtZW50KGhlYWRlciknKTtcbmxldCAkdHBfZm9yX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9mb3JfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9mb3Jfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfZm9yX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuc2tpcFRvQXdhaXRQYXJlbk9wZW4obGV4ZXJGbGFncyk7XG5sZXQgYXdhaXRhYmxlID0gdG9rX2dldFR5cGUoKSA9PT0gMjA3NTtcbmlmIChhd2FpdGFibGUpIHtcbmxldCAkdHBfYXdhaXRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAoIWFsbG93QXN5bmNHZW5lcmF0b3JzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ2Bmb3IgYXdhaXRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGFyZ2V0ZWQgbGFuZ3VhZ2UgdmVyc2lvbiwgdGhleSB3ZXJlIGludHJvZHVjZWQgaW4gRVM5L0VTMjAxOCcsICR0cF9mb3Jfc3RhcnQsICR0cF9hd2FpdF9zdG9wKTtcbn1cbmlmICgobGV4ZXJGbGFncyAmIDgpID09PSAwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBvbmx5IHVzZSBgZm9yLWF3YWl0YCBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb24nLCAkdHBfZm9yX3N0YXJ0LCAkdHBfYXdhaXRfc3RvcCk7XG59XG5za2lwVG9QYXJlbk9wZW5PckRpZShsZXhlckZsYWdzKTtcbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzEpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3Npbmcgb3BlbmluZyBwYXJlbiBvZiB0aGUgYGZvcmAgaGVhZGVyLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgJHRwX2Zvcl9zdGFydCwgJHRwX2Zvcl9zdG9wKTtcbn1cbnNraXBUb0V4cHJlc3Npb25TdGFydFNlbWkobGV4ZXJGbGFncyk7XG5wYXJzZUZvckhlYWRlcigoKGxleGVyRmxhZ3MgfCA0MDk2KSB8IDE3OTIpIF4gMTc5MiwgJHRwX2Zvcl9zdGFydCwgc2Nvb3AsIGF3YWl0YWJsZSwgYXN0UHJvcCk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3NpbmcgY2xvc2luZyBwYXJlbiBvZiB0aGUgYGZvcmAgaGVhZGVyLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncyk7XG5wYXJzZU5lc3RlZEJvZHlQYXJ0KGxleGVyRmxhZ3MgfCA1MTIsIHNjb29wLCBsYWJlbFNldCwgZmFsc2UsIDEsIG51bGwsICdib2R5Jyk7XG5BU1RfY2xvc2UoJHRwX2Zvcl9zdGFydCwgJHRwX2Zvcl9saW5lLCAkdHBfZm9yX2NvbHVtbik7XG59XG5mdW5jdGlvbiBwYXJzZUZvckhlYWRlclZhcihsZXhlckZsYWdzLCBzY29vcCwgYXN0UHJvcCkge1xubGV0ICR0cF92YXJfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3Zhcl9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3Zhcl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF92YXJfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5za2lwVG9CaW5kaW5nU3RhcnQobGV4ZXJGbGFncyk7XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MgfCAzMiwgJHRwX3Zhcl9zdGFydCwgJHRwX3Zhcl9saW5lLCAkdHBfdmFyX2NvbHVtbiwgc2Nvb3AsIDIsIDIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhc3RQcm9wKTtcbnJldHVybiAzMjtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9ySGVhZGVyTGV0KGxleGVyRmxhZ3MsICR0cF9mb3Jfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0YXJ0LCAkdHBfc3RhcnRPZkZvckhlYWRlcl9zdG9wLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9saW5lLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9jb2x1bW4sIHNjb29wLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2xldElkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9sZXRJZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfbGV0SWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9sZXRJZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9sZXRJZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfbGV0SWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5sZXQgJHRwX2xldEFyZ190eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfbGV0QXJnX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuaWYgKGlzSWRlbnRUb2tlbigkdHBfbGV0QXJnX3R5cGUpKSB7XG5pZiAoJHRwX2xldEFyZ190eXBlID09PSA2NzYzNikge1xuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnTGV0IGJpbmRpbmcgbWlzc2luZyBiaW5kaW5nIG5hbWVzIGFzIGBsZXRgIGNhbm5vdCBiZSBhIHZhciBuYW1lIGluIHN0cmljdCBtb2RlJywgJHRwX2xldElkZW50X3N0YXJ0LCAkdHBfbGV0QXJnX3N0b3ApO1xufVxuQVNUX3NldElkZW50KGFzdFByb3AsICR0cF9sZXRJZGVudF9zdGFydCwgJHRwX2xldElkZW50X3N0b3AsICR0cF9sZXRJZGVudF9saW5lLCAkdHBfbGV0SWRlbnRfY29sdW1uLCAkdHBfbGV0SWRlbnRfY2Fub24pO1xucmV0dXJuIDMyO1xufVxuaWYgKCR0cF9sZXRBcmdfdHlwZSA9PT0gMjEwNikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBIGBmb3IgKGxldCBvZiAuLi4pYCBpcyBhbHdheXMgaWxsZWdhbCcsICR0cF9mb3Jfc3RhcnQsICR0cF9sZXRBcmdfc3RvcCk7XG59XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MgfCAzMiwgJHRwX2xldElkZW50X3N0YXJ0LCAkdHBfbGV0SWRlbnRfbGluZSwgJHRwX2xldElkZW50X2NvbHVtbiwgc2Nvb3AsIDYsIDIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhc3RQcm9wKTtcbnJldHVybiAzMjtcbn1cbmlmICgoKCR0cF9sZXRBcmdfdHlwZSA9PT0gMTY1MDkpIHx8ICgkdHBfbGV0QXJnX3R5cGUgPT09IDE2NTEzKSkpIHtcbnBhcnNlQW55VmFyRGVjbGFyYXRpb24obGV4ZXJGbGFncyB8IDMyLCAkdHBfbGV0SWRlbnRfc3RhcnQsICR0cF9sZXRJZGVudF9saW5lLCAkdHBfbGV0SWRlbnRfY29sdW1uLCBzY29vcCwgNiwgMiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFzdFByb3ApO1xucmV0dXJuIDMyO1xufVxuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnTGV0IGJpbmRpbmcgbWlzc2luZyBiaW5kaW5nIG5hbWVzIGluIHN0cmljdCBtb2RlJywgJHRwX2xldElkZW50X3N0YXJ0LCAkdHBfbGV0SWRlbnRfc3RvcCk7XG59XG5pZiAoJHRwX2xldEFyZ190eXBlID09PSAxNjQ5MCkge1xuQVNUX3NldElkZW50KGFzdFByb3AsICR0cF9sZXRJZGVudF9zdGFydCwgJHRwX2xldElkZW50X3N0b3AsICR0cF9sZXRJZGVudF9saW5lLCAkdHBfbGV0SWRlbnRfY29sdW1uLCAkdHBfbGV0SWRlbnRfY2Fub24pO1xucmV0dXJuIDE2O1xufVxubGV0IGFzc2lnbmFibGUgPSBwYXJzZVZhbHVlQWZ0ZXJJZGVudChsZXhlckZsYWdzLCAkdHBfbGV0SWRlbnRfdHlwZSwgJHRwX2xldElkZW50X3N0YXJ0LCAkdHBfbGV0SWRlbnRfc3RvcCwgJHRwX2xldElkZW50X2xpbmUsICR0cF9sZXRJZGVudF9jb2x1bW4sICR0cF9sZXRJZGVudF9jYW5vbiwgMCwgdHJ1ZSwgYXN0UHJvcCk7XG5hc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MgfCAzMiwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0b3AsICR0cF9zdGFydE9mRm9ySGVhZGVyX2xpbmUsICR0cF9zdGFydE9mRm9ySGVhZGVyX2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMjEwNikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGBsZXRgIGFzIGEgdmFyIG5hbWUgb24gdGhlIGxlZnQgc2lkZSBpbiBhIGBmb3Itb2ZgIGhlYWRlcicsICR0cF9mb3Jfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIGFzc2lnbmFibGU7XG59XG5mdW5jdGlvbiBwYXJzZUZvckhlYWRlckNvbnN0KGxleGVyRmxhZ3MsIHNjb29wLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2NvbnN0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9jb25zdF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2NvbnN0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5za2lwVG9CaW5kaW5nU3RhcnQobGV4ZXJGbGFncyk7XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MgfCAzMiwgJHRwX2NvbnN0X3N0YXJ0LCAkdHBfY29uc3RfbGluZSwgJHRwX2NvbnN0X2NvbHVtbiwgc2Nvb3AsIDcsIDIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhc3RQcm9wKTtcbnJldHVybiAzMjtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9ySGVhZGVyQ3VybHkobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9jdXJseV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfY3VybHlfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9jdXJseV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9jdXJseV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCBkZXN0cnVjdGlibGUgPSBwYXJzZU9iamVjdE91dGVyKGxleGVyRmxhZ3MgfCAzMiwgbnVsbCwgMCwgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhc3RQcm9wKTtcbmxldCAkdHBfY3VybHlDbG9zZV90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfY3VybHlDbG9zZV9zdG9wID0gdG9rX2dldFN0YXJ0KCk7XG5pZiAoKGRlc3RydWN0aWJsZSAmIDQpID09PSA0KSB7XG5pZiAoKCgoKCR0cF9jdXJseUNsb3NlX3R5cGUgIT09IDQ5MjY0KSAmJiAoJHRwX2N1cmx5Q2xvc2VfdHlwZSAhPT0gMjEwNikpKSAmJiAoJHRwX2N1cmx5Q2xvc2VfdHlwZSAhPT0gNjc2MzYpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGxocyBhcyByZWd1bGFyIGZvci1sb29wIGJlY2F1c2UgaXQgbXVzdCBkZXN0cnVjdCcsICR0cF9jdXJseV9zdGFydCwgJHRwX2N1cmx5Q2xvc2Vfc3RvcCk7XG59XG5kZXN0cnVjdGlibGUgPSAoZGVzdHJ1Y3RpYmxlIHwgNCkgXiA0O1xufVxucmV0dXJuIHBhcnNlUGF0dGVyblRhaWxJbkZvckhlYWRlcihsZXhlckZsYWdzLCAkdHBfY3VybHlfc3RhcnQsICR0cF9jdXJseV9zdG9wLCAkdHBfY3VybHlfbGluZSwgJHRwX2N1cmx5X2NvbHVtbiwgMTY1MTcsIGRlc3RydWN0aWJsZSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUZvckhlYWRlckJyYWNrZXQobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9zcXVhcmVfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3NxdWFyZV9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3NxdWFyZV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9zcXVhcmVfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgZGVzdHJ1Y3RpYmxlID0gcGFyc2VBcnJheU91dGVyKGxleGVyRmxhZ3MgfCAzMiwgbnVsbCwgMCwgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhc3RQcm9wKTtcbmxldCAkdHBfYnJhY2tldENsb3NlX3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9icmFja2V0Q2xvc2Vfc3RvcCA9IHRva19nZXRTdGFydCgpO1xuaWYgKChkZXN0cnVjdGlibGUgJiA0KSA9PT0gNCkge1xuaWYgKCgoKCgkdHBfYnJhY2tldENsb3NlX3R5cGUgIT09IDQ5MjY0KSAmJiAoJHRwX2JyYWNrZXRDbG9zZV90eXBlICE9PSAyMTA2KSkpICYmICgkdHBfYnJhY2tldENsb3NlX3R5cGUgIT09IDY3NjM2KSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2Fubm90IHVzZSBsaHMgYXMgcmVndWxhciBmb3ItbG9vcCBiZWNhdXNlIGl0IG11c3QgZGVzdHJ1Y3QnLCAkdHBfc3F1YXJlX3N0YXJ0LCAkdHBfYnJhY2tldENsb3NlX3N0b3ApO1xufVxuZGVzdHJ1Y3RpYmxlID0gKGRlc3RydWN0aWJsZSB8IDQpIF4gNDtcbn1cbmxldCBhc3NpZ25hYmxlID0gcGFyc2VQYXR0ZXJuVGFpbEluRm9ySGVhZGVyKGxleGVyRmxhZ3MsICR0cF9zcXVhcmVfc3RhcnQsICR0cF9zcXVhcmVfc3RvcCwgJHRwX3NxdWFyZV9saW5lLCAkdHBfc3F1YXJlX2NvbHVtbiwgMTY1MTAsIGRlc3RydWN0aWJsZSwgYXN0UHJvcCk7XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9ySGVhZGVyT3RoZXIobGV4ZXJGbGFncywgYXN0UHJvcCkge1xucmV0dXJuIHBhcnNlVmFsdWUobGV4ZXJGbGFncyB8IDMyLCB0cnVlLCA0LCBmYWxzZSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUZvckhlYWRlcihsZXhlckZsYWdzLCAkdHBfZm9yX3N0YXJ0LCBzY29vcCwgYXdhaXRhYmxlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlRm9ySGVhZGVyTGhzKGxleGVyRmxhZ3MsICR0cF9mb3Jfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0YXJ0LCAkdHBfc3RhcnRPZkZvckhlYWRlcl9zdG9wLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9saW5lLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9jb2x1bW4sIHNjb29wLCBhc3RQcm9wKTtcbnJldHVybiBwYXJzZUZvckhlYWRlclJlc3QobGV4ZXJGbGFncywgJHRwX2Zvcl9zdGFydCwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0b3AsICR0cF9zdGFydE9mRm9ySGVhZGVyX2xpbmUsICR0cF9zdGFydE9mRm9ySGVhZGVyX2NvbHVtbiwgYXdhaXRhYmxlLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9ySGVhZGVyTGhzKGxleGVyRmxhZ3MsICR0cF9mb3Jfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0YXJ0LCAkdHBfc3RhcnRPZkZvckhlYWRlcl9zdG9wLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9saW5lLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9jb2x1bW4sIHNjb29wLCBhc3RQcm9wKSB7XG5zd2l0Y2ggKHRva19nZXRUeXBlKCkpIHtcbmNhc2UgMjEyMjpcbnJldHVybiBwYXJzZUZvckhlYWRlclZhcihsZXhlckZsYWdzLCBzY29vcCwgYXN0UHJvcCk7XG5jYXNlIDIxMDM6XG5yZXR1cm4gcGFyc2VGb3JIZWFkZXJMZXQobGV4ZXJGbGFncywgJHRwX2Zvcl9zdGFydCwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0b3AsICR0cF9zdGFydE9mRm9ySGVhZGVyX2xpbmUsICR0cF9zdGFydE9mRm9ySGVhZGVyX2NvbHVtbiwgc2Nvb3AsIGFzdFByb3ApO1xuY2FzZSAyMDgwOlxucmV0dXJuIHBhcnNlRm9ySGVhZGVyQ29uc3QobGV4ZXJGbGFncywgc2Nvb3AsIGFzdFByb3ApO1xuY2FzZSAxNjQ5MDpcbkFTVF9zZXROb2RlRGFuZ2Vyb3VzbHkoYXN0UHJvcCwgbnVsbCk7XG5yZXR1cm4gMTY7XG5jYXNlIDE2NTEzOlxucmV0dXJuIHBhcnNlRm9ySGVhZGVyQ3VybHkobGV4ZXJGbGFncywgYXN0UHJvcCk7XG5jYXNlIDE2NTA5OlxucmV0dXJuIHBhcnNlRm9ySGVhZGVyQnJhY2tldChsZXhlckZsYWdzLCBhc3RQcm9wKTtcbn1cbmxldCBhc3NpZ25hYmxlID0gcGFyc2VGb3JIZWFkZXJPdGhlcihsZXhlckZsYWdzLCBhc3RQcm9wKTtcbnJldHVybiBwYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncyB8IDMyLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9zdGFydCwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RvcCwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfbGluZSwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9ySGVhZGVyUmVzdChsZXhlckZsYWdzLCAkdHBfZm9yX3N0YXJ0LCAkdHBfc3RhcnRPZkZvckhlYWRlcl9zdGFydCwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RvcCwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfbGluZSwgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfY29sdW1uLCBhd2FpdGFibGUsIGFzc2lnbmFibGUsIGFzdFByb3ApIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAyMTA2KSB7XG5yZXR1cm4gcGFyc2VGb3JGcm9tT2YobGV4ZXJGbGFncywgJHRwX2Zvcl9zdGFydCwgYXdhaXRhYmxlLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbmlmIChhd2FpdGFibGUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnYGZvciBhd2FpdGAgb25seSBhY2NlcHRzIHRoZSBgZm9yLW9mYCB0eXBlJywgJHRwX2Zvcl9zdGFydCwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gNjc2MzYpIHtcbnJldHVybiBwYXJzZUZvckZyb21JbihsZXhlckZsYWdzLCAkdHBfZm9yX3N0YXJ0LCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOidGb3JTdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBpbml0OnVuZGVmaW5lZCwgdGVzdDp1bmRlZmluZWQsIHVwZGF0ZTp1bmRlZmluZWQsIGJvZHk6dW5kZWZpbmVkfSwgJ2luaXQnKTtcbnJldHVybiBwYXJzZUZvckZyb21TZW1pKGxleGVyRmxhZ3MsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0YXJ0LCAkdHBfc3RhcnRPZkZvckhlYWRlcl9saW5lLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VGb3JGcm9tT2YobGV4ZXJGbGFncywgJHRwX2Zvcl9zdGFydCwgYXdhaXRhYmxlLCBhc3NpZ25hYmxlLCBhc3RQcm9wKSB7XG5pZiAobm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdMZWZ0IHBhcnQgb2YgZm9yLW9mIG11c3QgYmUgYXNzaWduYWJsZScsICR0cF9mb3Jfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J0Zvck9mU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgbGVmdDp1bmRlZmluZWQsIHJpZ2h0OnVuZGVmaW5lZCwgYXdhaXQ6YXdhaXRhYmxlLCBib2R5OnVuZGVmaW5lZH0sICdsZWZ0Jyk7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5wYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJ3JpZ2h0Jyk7XG59XG5mdW5jdGlvbiBwYXJzZUZvckZyb21JbihsZXhlckZsYWdzLCAkdHBfZm9yX3N0YXJ0LCBhc3NpZ25hYmxlLCBhc3RQcm9wKSB7XG5pZiAobm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdMZWZ0IHBhcnQgb2YgZm9yLWluIG11c3QgYmUgYXNzaWduYWJsZScsICR0cF9mb3Jfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J0ZvckluU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgbGVmdDp1bmRlZmluZWQsIHJpZ2h0OnVuZGVmaW5lZCwgYm9keTp1bmRlZmluZWR9LCAnbGVmdCcpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xucGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCAncmlnaHQnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9yRnJvbVNlbWkobGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZGb3JIZWFkZXJfc3RhcnQsICR0cF9zdGFydE9mRm9ySGVhZGVyX2xpbmUsICR0cF9zdGFydE9mRm9ySGVhZGVyX2NvbHVtbikge1xubGV0IGhhZENvbW1hID0gdG9rX2dldFR5cGUoKSA9PT0gMTY0ODA7XG5sZXQgcG90ZW50aWFsQ29tbWFTdGFydCA9IHRva19nZXRTdGFydCgpO1xuaWYgKGhhZENvbW1hKSB7XG5fcGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzIHwgMzIsICR0cF9zdGFydE9mRm9ySGVhZGVyX3N0YXJ0LCAkdHBfc3RhcnRPZkZvckhlYWRlcl9saW5lLCAkdHBfc3RhcnRPZkZvckhlYWRlcl9jb2x1bW4sIDE2LCAnaW5pdCcpO1xufVxuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDkwKSB7XG5pZiAoKGhhZENvbW1hICYmICgoKHRva19nZXRUeXBlKCkgPT09IDIxMDYpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSA2NzYzNikpKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ29tbWEgbm90IGFsbG93ZWQgaW4gbGVmdCBzaWRlIG9mIGBmb3ItaW5gL2Bmb3Itb2ZgIGhlYWRlcicsIHBvdGVudGlhbENvbW1hU3RhcnQsIHBvdGVudGlhbENvbW1hU3RhcnQgKyAxKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3NpbmcgZmlyc3Qgc2VtaSBpbiBgZm9yYCBoZWFkZXIsIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gX3BhcnNlRm9yRnJvbVNlbWkobGV4ZXJGbGFncyk7XG59XG5mdW5jdGlvbiBfcGFyc2VGb3JGcm9tU2VtaShsZXhlckZsYWdzKSB7XG5za2lwVG9FeHByZXNzaW9uU3RhcnRTZW1pKGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDkwKSB7XG5BU1Rfc2V0KCd0ZXN0JywgbnVsbCk7XG59IGVsc2Uge1xucGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCAndGVzdCcpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDkwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdNaXNzaW5nIHNlY29uZCBzZW1pIGluIGBmb3JgIGhlYWRlciwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbnNraXBUb0V4cHJlc3Npb25TdGFydEdyb3VwZWQobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0NzIpIHtcbkFTVF9zZXQoJ3VwZGF0ZScsIG51bGwpO1xufSBlbHNlIHtcbnBhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgJ3VwZGF0ZScpO1xufVxufVxuZnVuY3Rpb24gcGFyc2VQYXR0ZXJuVGFpbEluRm9ySGVhZGVyKGxleGVyRmxhZ3MsICR0cF9wYXR0ZXJuU3RhcnRfc3RhcnQsICR0cF9wYXR0ZXJuU3RhcnRfc3RvcCwgJHRwX3BhdHRlcm5TdGFydF9saW5lLCAkdHBfcGF0dGVyblN0YXJ0X2NvbHVtbiwgY2xvc2luZ1B1bmNUeXBlLCBkZXN0cnVjdGlibGUsIGFzdFByb3ApIHtcbmxldCBhc3NpZ25hYmxlID0gKCgoZGVzdHJ1Y3RpYmxlICYgMSkgIT09IDApPyAxNiA6IDMyKTtcbmxldCAkdHBfcGF0dGVyblRhaWxTdGFydF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmlmICgoKCR0cF9wYXR0ZXJuVGFpbFN0YXJ0X3R5cGUgIT09IDQ5MjY0KSAmJiBpc0FueUFzc2lnbm1lbnRPcCgpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgY29tcG91bmQgYXNzaWduIHRvIGFuIG9iamVjdCBvciBhcnJheSBwYXR0ZXJuJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuYXNzaWduYWJsZSA9IHBhcnNlVmFsdWVUYWlsKGxleGVyRmxhZ3MgfCAzMiwgJHRwX3BhdHRlcm5TdGFydF9zdGFydCwgJHRwX3BhdHRlcm5TdGFydF9saW5lLCAkdHBfcGF0dGVyblN0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgNCwgZmFsc2UsIGFzdFByb3ApO1xubGV0ICR0cF9hZnRlTGhzX3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xuaWYgKCgoJHRwX2FmdGVMaHNfdHlwZSA9PT0gMjEwNikgfHwgKCR0cF9hZnRlTGhzX3R5cGUgPT09IDY3NjM2KSkpIHtcbmlmIChub3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBmb3ItaGVhZGVyIGxocyBiaW5kaW5nIHBhdHRlcm4gaXMgbm90IGRlc3RydWN0aWJsZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbkFTVF9kZXN0cnVjdChhc3RQcm9wKTtcbnJldHVybiBhc3NpZ25hYmxlO1xufVxuaWYgKCR0cF9hZnRlTGhzX3R5cGUgPT09IDE2NDkwKSB7XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmlmICgkdHBfYWZ0ZUxoc190eXBlID09PSA0OTI2NCkge1xubGV0ICR0cF9lcV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9lcV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbnBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzIHwgMzIsICR0cF9wYXR0ZXJuU3RhcnRfc3RhcnQsICR0cF9wYXR0ZXJuU3RhcnRfc3RvcCwgJHRwX3BhdHRlcm5TdGFydF9saW5lLCAkdHBfcGF0dGVyblN0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0OTApIHtcbnJldHVybiAxNjtcbn1cbmlmICgoKHRva19nZXRUeXBlKCkgPT09IDY3NjM2KSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMjEwNikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBsZWZ0IHNpZGUgb2YgYSBgZm9yLW9mYCBhbmQgYGZvci1pbmAgY2FuIG5vdCBiZSBhbiBhc3NpZ25tZW50LCBldmVuIGlmIGl0IGlzIGEgQmluZGluZ1BhdHRlcm4nLCAkdHBfZXFfc3RhcnQsICR0cF9lcV9zdG9wKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgnVW5rbm93biBpbnB1dCBmb2xsb3dlZCB0aGUgbGVmdCBzaWRlIG9mIGEgZm9yIGxvb3AgaGVhZGVyIGFmdGVyIGFzc2lnbm1lbnQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5wYXJzZU9wdGlvbmFsRGVzdHJ1Y3RpYmxlUmVzdE9mRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfcGF0dGVyblN0YXJ0X3N0YXJ0LCAkdHBfcGF0dGVyblN0YXJ0X3N0b3AsICR0cF9wYXR0ZXJuU3RhcnRfbGluZSwgJHRwX3BhdHRlcm5TdGFydF9jb2x1bW4sIGFzc2lnbmFibGUsIGRlc3RydWN0aWJsZSwgY2xvc2luZ1B1bmNUeXBlLCBhc3RQcm9wKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xuX3BhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgJHRwX3BhdHRlcm5TdGFydF9zdGFydCwgJHRwX3BhdHRlcm5TdGFydF9saW5lLCAkdHBfcGF0dGVyblN0YXJ0X2NvbHVtbiwgMTYsIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDkwKSB7XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgnVW5rbm93biBpbnB1dCBmb2xsb3dlZCB0aGUgbGVmdCBzaWRlIG9mIGEgZm9yIGxvb3AgaGVhZGVyJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGFzdFByb3ApIHtcbmxldCAkdHBfaWZfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2lmX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfaWZfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbnNraXBUb1BhcmVuT3Blbk9yRGllKGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0lmU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgdGVzdDp1bmRlZmluZWQsIGNvbnNlcXVlbnQ6dW5kZWZpbmVkLCBhbHRlcm5hdGU6dW5kZWZpbmVkfSk7XG5wYXJzZVN0YXRlbWVudEhlYWRlcihsZXhlckZsYWdzLCAndGVzdCcpO1xucGFyc2VOZXN0ZWRCb2R5UGFydChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGZhbHNlLCAyLCBudWxsLCAnY29uc2VxdWVudCcpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwODYpIHtcbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xucGFyc2VOZXN0ZWRCb2R5UGFydChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGZhbHNlLCAyLCBudWxsLCAnYWx0ZXJuYXRlJyk7XG59IGVsc2Uge1xuQVNUX3NldCgnYWx0ZXJuYXRlJywgbnVsbCk7XG59XG5BU1RfY2xvc2UoJHRwX2lmX3N0YXJ0LCAkdHBfaWZfbGluZSwgJHRwX2lmX2NvbHVtbik7XG59XG5mdW5jdGlvbiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKGxleGVyRmxhZ3MsIHNjb29wLCBpc0dsb2JhbFRvcGxldmVsLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2ltcG9ydF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaW1wb3J0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfaW1wb3J0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2ltcG9ydF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBUb0lkZW50U3RhckN1cmx5T3BlblBhcmVuT3BlblN0cmluZyhsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ3MSkge1xucmV0dXJuIHBhcnNlRHluYW1pY0ltcG9ydFN0YXRlbWVudChsZXhlckZsYWdzLCAkdHBfaW1wb3J0X3N0YXJ0LCAkdHBfaW1wb3J0X3N0b3AsICR0cF9pbXBvcnRfbGluZSwgJHRwX2ltcG9ydF9jb2x1bW4sIGFzdFByb3ApO1xufVxuaWYgKGdvYWxNb2RlICE9PSB0cnVlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBgaW1wb3J0YCBrZXl3b3JkIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB0aGUgbW9kdWxlIGdvYWwnLCAkdHBfaW1wb3J0X3N0YXJ0LCAkdHBfaW1wb3J0X3N0b3ApO1xufVxuaWYgKGlzR2xvYmFsVG9wbGV2ZWwgPT09IGZhbHNlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBgaW1wb3J0YCBrZXl3b3JkIGlzIG9ubHkgc3VwcG9ydGVkIGF0IHRoZSB0b3AgbGV2ZWwnLCAkdHBfaW1wb3J0X3N0YXJ0LCAkdHBfaW1wb3J0X3N0b3ApO1xufVxuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0ltcG9ydERlY2xhcmF0aW9uJywgbG9jOnVuZGVmaW5lZCwgc3BlY2lmaWVyczpbXSwgc291cmNlOnVuZGVmaW5lZH0pO1xuaWYgKGlzSWRlbnRUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucGFyc2VJbXBvcnREZWZhdWx0KGxleGVyRmxhZ3MsIHNjb29wKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xuc2tpcFRvSWRlbnRTdGFyQ3VybHlPcGVuKGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDA5KSB7XG5wYXJzZUltcG9ydE5hbWVzcGFjZShsZXhlckZsYWdzLCBzY29vcCk7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NTEzKSB7XG5wYXJzZUltcG9ydE9iamVjdChsZXhlckZsYWdzLCBzY29vcCk7XG59IGVsc2Uge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBIGRlZmF1bHQgaW1wb3J0IGNhbiBvbmx5IGJlIGZvbGxvd2VkIGJ5IGEgc3RhciBvciBvYmplY3Qgc3BlY2lmaWVyJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAyMDk0KSB7XG5za2lwVG9TdHJpbmdPckRpZShsZXhlckZsYWdzKTtcbn0gZWxzZSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBkZWZhdWx0IGBpbXBvcnRgIHNob3VsZCBiZSBmb2xsb3dlZCBieSBhbm90aGVyIHNwZWNpZmllciBvciBgZnJvbWAnLCAkdHBfaW1wb3J0X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gODIwMDkpIHtcbnBhcnNlSW1wb3J0TmFtZXNwYWNlKGxleGVyRmxhZ3MsIHNjb29wKTtcbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MTMpIHtcbnBhcnNlSW1wb3J0T2JqZWN0KGxleGVyRmxhZ3MsIHNjb29wKTtcbn0gZWxzZSB7XG5pZiAoIWlzU3RyaW5nVG9rZW4odG9rX2dldFR5cGUoKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGVkIGEgdmFsaWQgdG9rZW4gYWZ0ZXIgdGhlIGBpbXBvcnRgIGtleXdvcmQsIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG59XG5sZXQgJHRwX3NvdXJjZV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfc291cmNlX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc291cmNlX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3NvdXJjZV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfc291cmNlX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbkFTVF9zZXRTdHJpbmdMaXRlcmFsKCdzb3VyY2UnLCAkdHBfc291cmNlX3N0YXJ0LCAkdHBfc291cmNlX3N0b3AsICR0cF9zb3VyY2VfbGluZSwgJHRwX3NvdXJjZV9jb2x1bW4sICR0cF9zb3VyY2VfY2Fub24sIGZhbHNlKTtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfbGluZSwgJHRwX2ltcG9ydF9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VJbXBvcnREZWZhdWx0KGxleGVyRmxhZ3MsIHNjb29wKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbmZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgNywgbGV4ZXJGbGFncyk7XG5TQ09QRV9hZGRMZXhCaW5kaW5nKHNjb29wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24sIDYsIDMpO1xuc2tpcFRvQXNDb21tYUZyb20obGV4ZXJGbGFncyk7XG5BU1Rfc2V0Tm9kZSgnc3BlY2lmaWVycycsIHt0eXBlOidJbXBvcnREZWZhdWx0U3BlY2lmaWVyJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiksIGxvY2FsOkFTVF9nZXRJZGVudE5vZGUoJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbil9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW1wb3J0T2JqZWN0KGxleGVyRmxhZ3MsIHNjb29wKSB7XG5za2lwVG9JZGVudEN1cmx5Q2xvc2UobGV4ZXJGbGFncyk7XG53aGlsZSAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5wYXJzZUltcG9ydFNwZWNpZmllcihsZXhlckZsYWdzLCBzY29vcCk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApIGJyZWFrO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjUxNykge1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg2KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0ltcG9ydCBvYmplY3QgY2Fubm90IGhhdmUgc3ByZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg5KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0ltcG9ydCBvYmplY3QgdXNlcyBgYXNgIHRvIGFsaWFzIChge2EgYXMgeX1gKSwgbm90IGNvbG9uIChge2E6IHl9YCknLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdNaXNzaW5nIGltcG9ydCBkZWZpbml0aW9uIGNsb3NpbmcgY3VybHksIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwVG9Gcm9tT3JEaWUobGV4ZXJGbGFncyk7XG5za2lwVG9TdHJpbmdPckRpZShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW1wb3J0U3BlY2lmaWVyKGxleGVyRmxhZ3MsIHNjb29wKSB7XG5sZXQgJHRwX25hbWVfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX25hbWVfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9uYW1lX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX25hbWVfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX25hbWVfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbmxldCAkdHBfbG9jYWxfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2xvY2FsX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9sb2NhbF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2xvY2FsX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2xvY2FsX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9sb2NhbF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcFRvQXNDb21tYUN1cmx5Q2xvc2UobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMjA3Mykge1xuc2tpcFRvSWRlbnRPckRpZShsZXhlckZsYWdzKTtcbiR0cF9sb2NhbF90eXBlID0gdG9rX2dldFR5cGUoKTtcbiR0cF9sb2NhbF9saW5lID0gdG9rX2dldExpbmUoKTtcbiR0cF9sb2NhbF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG4kdHBfbG9jYWxfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbiR0cF9sb2NhbF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbiR0cF9sb2NhbF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2xvY2FsX3R5cGUsICR0cF9sb2NhbF9zdGFydCwgJHRwX2xvY2FsX3N0b3AsICR0cF9sb2NhbF9jYW5vbiwgNywgbGV4ZXJGbGFncyk7XG5TQ09QRV9hZGRMZXhCaW5kaW5nKHNjb29wLCAkdHBfbG9jYWxfc3RhcnQsICR0cF9sb2NhbF9zdG9wLCAkdHBfbG9jYWxfY2Fub24sIDYsIDEpO1xuQVNUX3NldE5vZGUoJ3NwZWNpZmllcnMnLCB7dHlwZTonSW1wb3J0U3BlY2lmaWVyJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX25hbWVfc3RhcnQsICR0cF9uYW1lX2xpbmUsICR0cF9uYW1lX2NvbHVtbiksIGltcG9ydGVkOkFTVF9nZXRJZGVudE5vZGUoJHRwX25hbWVfc3RhcnQsICR0cF9uYW1lX3N0b3AsICR0cF9uYW1lX2xpbmUsICR0cF9uYW1lX2NvbHVtbiwgJHRwX25hbWVfY2Fub24pLCBsb2NhbDpBU1RfZ2V0SWRlbnROb2RlKCR0cF9sb2NhbF9zdGFydCwgJHRwX2xvY2FsX3N0b3AsICR0cF9sb2NhbF9saW5lLCAkdHBfbG9jYWxfY29sdW1uLCAkdHBfbG9jYWxfY2Fub24pfSk7XG59XG5mdW5jdGlvbiBwYXJzZUltcG9ydE5hbWVzcGFjZShsZXhlckZsYWdzLCBzY29vcCkge1xubGV0ICR0cF9zdGFyX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zdGFyX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc3Rhcl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAyMDczKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdOZXh0IHRva2VuIHNob3VsZCBiZSBgYXNgIGJ1dCB3YXMgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwVG9JZGVudE9yRGllKGxleGVyRmxhZ3MpO1xubGV0ICR0cF9sb2NhbF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfbG9jYWxfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2xvY2FsX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfbG9jYWxfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfbG9jYWxfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2xvY2FsX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwVG9Gcm9tT3JEaWUobGV4ZXJGbGFncyk7XG5mYXRhbEJpbmRpbmdJZGVudENoZWNrKCR0cF9sb2NhbF90eXBlLCAkdHBfbG9jYWxfc3RhcnQsICR0cF9sb2NhbF9zdG9wLCAkdHBfbG9jYWxfY2Fub24sIDcsIGxleGVyRmxhZ3MpO1xuU0NPUEVfYWRkTGV4QmluZGluZyhzY29vcCwgJHRwX2xvY2FsX3N0YXJ0LCAkdHBfbG9jYWxfc3RvcCwgJHRwX2xvY2FsX2Nhbm9uLCA2LCAxKTtcbkFTVF9zZXROb2RlKCdzcGVjaWZpZXJzJywge3R5cGU6J0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9zdGFyX3N0YXJ0LCAkdHBfc3Rhcl9saW5lLCAkdHBfc3Rhcl9jb2x1bW4pLCBsb2NhbDpBU1RfZ2V0SWRlbnROb2RlKCR0cF9sb2NhbF9zdGFydCwgJHRwX2xvY2FsX3N0b3AsICR0cF9sb2NhbF9saW5lLCAkdHBfbG9jYWxfY29sdW1uLCAkdHBfbG9jYWxfY2Fub24pfSk7XG5za2lwVG9TdHJpbmdPckRpZShsZXhlckZsYWdzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTGV0RGVjbGFyYXRpb24obGV4ZXJGbGFncywgJHRwX2xldF9zdGFydCwgJHRwX2xldF9saW5lLCAkdHBfbGV0X2NvbHVtbiwgc2Nvb3AsIGxhYmVsU2V0LCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApIHtcbmxldCAkdHBfaWRlbnRfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2lkZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9pZGVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2lkZW50X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2lkZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9pZGVudF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcERpdihsZXhlckZsYWdzKTtcbmlmIChpc0lkZW50VG9rZW4odG9rX2dldFR5cGUoKSkpIHtcbmxldCAkdHBfYmluZGluZ190eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfYmluZGluZ19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9iaW5kaW5nX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9iaW5kaW5nX2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5sZXQgaWRlbnRCaW5kaW5nRXJyb3JNc2cgPSAoKHRva19nZXRObHdhcygpID09PSB0cnVlKT8gbm9uRmF0YWxCaW5kaW5nSWRlbnRDaGVjaygkdHBfYmluZGluZ190eXBlLCAkdHBfYmluZGluZ19zdGFydCwgJHRwX2JpbmRpbmdfc3RvcCwgJHRwX2JpbmRpbmdfY2Fub24sIDYsIGxleGVyRmxhZ3MpIDogJycpO1xuaWYgKGlkZW50QmluZGluZ0Vycm9yTXNnICE9PSAnJykge1xuaWYgKFsyMDc1LCAyMTI2LCAyMDcyLCAyMDg4LCAyMDk4LCAyMTAyLCAyMTAzLCAyMTA3LCAyMTA4LCAyMTA5LCAyMTEwLCAyMTEzXS5pbmNsdWRlcyh0b2tfZ2V0VHlwZSgpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgoJ0F0dGVtcHRlZCB0byBjcmVhdGUgYSBgbGV0YCBiaW5kaW5nIG9uIHNwZWNpYWwgcmVzZXJ2ZWQga2V5d29yZCBgJyArIHRva19zbGljZUlucHV0KCR0cF9iaW5kaW5nX3N0YXJ0LCAkdHBfYmluZGluZ19zdG9wKSkgKyAnYCBidXQ6ICcpICsgaWRlbnRCaW5kaW5nRXJyb3JNc2csICR0cF9iaW5kaW5nX3N0YXJ0LCAkdHBfYmluZGluZ19zdG9wKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgoJ2BsZXRgIG11c3QgYmUgYSBkZWNsYXJhdGlvbiBpbiBzdHJpY3QgbW9kZSBidXQgdGhlIG5leHQgaWRlbnQgaXMgYSByZXNlcnZlZCBrZXl3b3JkIChgJyArIHRva19zbGljZUlucHV0KCR0cF9iaW5kaW5nX3N0YXJ0LCAkdHBfYmluZGluZ19zdG9wKSkgKyAnYCknLCAkdHBfYmluZGluZ19zdGFydCwgJHRwX2JpbmRpbmdfc3RvcCk7XG59XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MsICR0cF9sZXRfc3RhcnQsICR0cF9sZXRfbGluZSwgJHRwX2xldF9jb2x1bW4sIHNjb29wLCA2LCAxLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXN0UHJvcCk7XG59IGVsc2UgaWYgKCgodG9rX2dldFR5cGUoKSA9PT0gMTY1MDkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMykpKSB7XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MsICR0cF9sZXRfc3RhcnQsICR0cF9sZXRfbGluZSwgJHRwX2xldF9jb2x1bW4sIHNjb29wLCA2LCAxLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXN0UHJvcCk7XG59IGVsc2UgaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnTGV0IGRlY2xhcmF0aW9uIG1pc3NpbmcgYmluZGluZyBuYW1lcyBhbmQgYGxldGAgY2Fubm90IGJlIGEgcmVndWxhciB2YXIgb3IgbGFiZWwgbmFtZSBpbiBzdHJpY3QgbW9kZScsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3ApO1xufSBlbHNlIHtcbl9wYXJzZUxldEFzUGxhaW5WYXJOYW1lRXhwcmVzc2lvblN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApO1xufVxufVxuZnVuY3Rpb24gcGFyc2VMZXRFeHByZXNzaW9uU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5pZiAoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gODE5Mikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdgbGV0YCBkZWNsYXJhdGlvbiBub3QgYWxsb3dlZCBoZXJlIGFuZCBgbGV0YCBjYW5ub3QgYmUgYSByZWd1bGFyIHZhciBvciBsYWJlbCBuYW1lIGluIHN0cmljdCBtb2RlJywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MDkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnSXQgaXMgbmV2ZXIgdmFsaWQgZm9yIGFuIGV4cHJlc3Npb24gc3RhdGVtZW50IHRvIGJlZ2luIHdpdGggYGxldFtgLCBhbmQgYSBgbGV0YCBkZWNsYXJhdGlvbiB3b3VsZCBub3QgYmUgdmFsaWQgaGVyZScsICR0cF9pZGVudF9zdGFydCwgdG9rX2dldFN0b3AoKSk7XG59XG5fcGFyc2VMZXRBc1BsYWluVmFyTmFtZUV4cHJlc3Npb25TdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUxldEFzUGxhaW5WYXJOYW1lRXhwcmVzc2lvblN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4OSkge1xucmV0dXJuIHBhcnNlTGFiZWxlZFN0YXRlbWVudEluc3RlYWQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKTtcbn1cbmxldCAkdHBfbmV4dF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmlmICgoKCR0cF9uZXh0X3R5cGUgPT09IDY3NjM2KSB8fCAoJHRwX25leHRfdHlwZSA9PT0gNjc2MzYpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGBsZXRgIGFzIGEgcmVndWxhciB2YXIgbmFtZSBhcyB0aGUgbGhzIG9mIGBpbmAgb3IgYGluc3RhbmNlb2ZgIGluIGEgdG9wbGV2ZWwgZXhwcmVzc2lvbiBzdGF0ZW1lbnQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonRXhwcmVzc2lvblN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGV4cHJlc3Npb246dW5kZWZpbmVkfSk7XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlSWRlbnRPclBhcmVubGVzc0Fycm93KGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCAzMiwgdHJ1ZSwgJ2V4cHJlc3Npb24nKTtcbmFzc2lnbmFibGUgPSBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCBhc3NpZ25hYmxlLCA0LCBmYWxzZSwgJ2V4cHJlc3Npb24nKTtcbnBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgYXNzaWduYWJsZSwgJ2V4cHJlc3Npb24nKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xuX3BhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgMTYsICdleHByZXNzaW9uJyk7XG59XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmV0dXJuU3RhdGVtZW50KGxleGVyRmxhZ3MsIGFzdFByb3ApIHtcbmxldCAkdHBfcmV0dXJuX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9yZXR1cm5fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9yZXR1cm5fc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmlmICgoKCFhbGxvd0dsb2JhbFJldHVybikgJiYgKChsZXhlckZsYWdzICYgMjU2KSA9PT0gMjU2KSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnTm90IGNvbmZpZ3VyZWQgdG8gcGFyc2UgYHJldHVybmAgc3RhdGVtZW50IGluIGdsb2JhbCwgYmFpbGluZycsICR0cF9yZXR1cm5fc3RhcnQsICR0cF9yZXR1cm5fc3RhcnQgKyAxKTtcbn1cbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J1JldHVyblN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGFyZ3VtZW50OnVuZGVmaW5lZH0pO1xuaWYgKCgodG9rX2dldE5sd2FzKCkgPT09IHRydWUpICYmIGlzUmVnZXhUb2tlbih0b2tfZ2V0VHlwZSgpKSkpIHtcbnRva19hc2koKTtcbkFTVF9zZXQoJ2FyZ3VtZW50JywgbnVsbCk7XG59IGVsc2Uge1xuaWYgKCgoKCgoKHRva19nZXRObHdhcygpID09PSBmYWxzZSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDIwOTcxNzMpKSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NDkwKSkpICYmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjUxNykpKSB7XG5wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICdhcmd1bWVudCcpO1xufSBlbHNlIHtcbkFTVF9zZXQoJ2FyZ3VtZW50JywgbnVsbCk7XG59XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbn1cbkFTVF9jbG9zZSgkdHBfcmV0dXJuX3N0YXJ0LCAkdHBfcmV0dXJuX2xpbmUsICR0cF9yZXR1cm5fY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3dpdGNoU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCkge1xubGV0ICR0cF9zd2l0Y2hfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3N3aXRjaF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3N3aXRjaF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvUGFyZW5PcGVuT3JEaWUobGV4ZXJGbGFncyk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonU3dpdGNoU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgZGlzY3JpbWluYW50OnVuZGVmaW5lZCwgY2FzZXM6W119KTtcbmxldCBsZXhlckZsYWdzRm9yU3dpdGNoID0gKGxleGVyRmxhZ3MgfCA2NDAwKSBeIDY0MDA7XG5wYXJzZVN0YXRlbWVudEhlYWRlcihsZXhlckZsYWdzRm9yU3dpdGNoLCAnZGlzY3JpbWluYW50Jyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY1MTMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3Npbmcgb3BlbmluZyBjdXJseSBvZiBgc3dpdGNoYCBib2R5LCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvU3dpdGNoQm9keShsZXhlckZsYWdzRm9yU3dpdGNoKTtcbmxldCBjYXNlc1Njb29wID0gU0NPUEVfYWRkTGF5ZXIoc2Nvb3AsIDgsICdwYXJzZVN3aXRjaFN0YXRlbWVudCcpO1xucGFyc2VTd2l0Y2hDYXNlcyhsZXhlckZsYWdzRm9yU3dpdGNoIHwgMTAyNCwgY2FzZXNTY29vcCwgbGFiZWxTZXQsICdjYXNlcycpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdNaXNzaW5nIHRoZSBjbG9zaW5nIGN1cmx5IG9mIHRoZSBzd2l0Y2ggYm9keSwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBUb1N0YXRlbWVudFN0YXJ0KGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF9zd2l0Y2hfc3RhcnQsICR0cF9zd2l0Y2hfbGluZSwgJHRwX3N3aXRjaF9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VTd2l0Y2hDYXNlcyhsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGFzdFByb3ApIHtcbmxldCBoYWREZWZhdWx0ID0gZmFsc2U7XG53aGlsZSAodHJ1ZSkge1xubGV0ICR0cF9jYXNlRGVmYXVsdF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfY2FzZURlZmF1bHRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9jYXNlRGVmYXVsdF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwNzcpIHtcbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidTd2l0Y2hDYXNlJywgbG9jOnVuZGVmaW5lZCwgdGVzdDp1bmRlZmluZWQsIGNvbnNlcXVlbnQ6W119KTtcbnBhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgJ3Rlc3QnKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ4OSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdNaXNzaW5nIGNvbG9uIGFmdGVyIGNhc2UgZXhwcicsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMjA4Mykge1xuaWYgKGhhZERlZmF1bHQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRm91bmQgc2Vjb25kIGBkZWZhdWx0YCBpbiBzYW1lIHN3aXRjaCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmhhZERlZmF1bHQgPSB0cnVlO1xuc2tpcFRvQ29sb25PckRpZShsZXhlckZsYWdzKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidTd2l0Y2hDYXNlJywgbG9jOnVuZGVmaW5lZCwgdGVzdDpudWxsLCBjb25zZXF1ZW50OltdfSk7XG59IGVsc2Uge1xuYnJlYWs7XG59XG5za2lwVG9TdGF0ZW1lbnRTdGFydChsZXhlckZsYWdzKTtcbndoaWxlICgoKCgodG9rX2dldFR5cGUoKSAhPT0gMTY1MTcpICYmICh0b2tfZ2V0VHlwZSgpICE9PSAyMDc3KSkpICYmICh0b2tfZ2V0VHlwZSgpICE9PSAyMDgzKSkpIHtcbnBhcnNlTmVzdGVkQm9keVBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBmYWxzZSwgMywgbnVsbCwgJ2NvbnNlcXVlbnQnKTtcbn1cbkFTVF9jbG9zZSgkdHBfY2FzZURlZmF1bHRfc3RhcnQsICR0cF9jYXNlRGVmYXVsdF9saW5lLCAkdHBfY2FzZURlZmF1bHRfY29sdW1uKTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlVGhyb3dTdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF90aHJvd19saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfdGhyb3dfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF90aHJvd19zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J1Rocm93U3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgYXJndW1lbnQ6dW5kZWZpbmVkfSk7XG5pZiAodG9rX2dldE5sd2FzKCkgPT09IHRydWUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRm91bmQgYSBuZXdsaW5lIGJldHdlZW4gYHRocm93YCBhbmQgaXRzIGFyZ3VtZW50IGJ1dCB0aGF0IGlzIG5vdCBhbGxvd2VkJywgJHRwX3Rocm93X3N0YXJ0LCB0b2tfZ2V0U3RhcnQoKSk7XG59XG5sZXQgdG1wTGV4ZXJGbGFncyA9IChsZXhlckZsYWdzIHwgMTgyNCkgXiAxODI0O1xucGFyc2VFeHByZXNzaW9ucyh0bXBMZXhlckZsYWdzLCAnYXJndW1lbnQnKTtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF90aHJvd19zdGFydCwgJHRwX3Rocm93X2xpbmUsICR0cF90aHJvd19jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VUcnlTdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBhc3RQcm9wKSB7XG5sZXQgJHRwX3RyeV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfdHJ5X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfdHJ5X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3RyeV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBUb0N1cmx5T3Blbk9yRGllKGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J1RyeVN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGJsb2NrOnVuZGVmaW5lZCwgaGFuZGxlcjp1bmRlZmluZWQsIGZpbmFsaXplcjp1bmRlZmluZWR9KTtcbmxldCB0cnlTY29vcCA9IFNDT1BFX2FkZExheWVyKHNjb29wLCA0LCAncGFyc2VUcnlTdGF0ZW1lbnQodHJ5KScpO1xucGFyc2VCbG9ja1N0YXRlbWVudChsZXhlckZsYWdzLCB0cnlTY29vcCwgbGFiZWxTZXQsICdibG9jaycpO1xubGV0IGhhc0VpdGhlciA9IGZhbHNlO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDIwNzgpIHtcbmhhc0VpdGhlciA9IHRydWU7XG5sZXQgJHRwX2NhdGNoX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9jYXRjaF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2NhdGNoX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oJ2hhbmRsZXInLCB7dHlwZTonQ2F0Y2hDbGF1c2UnLCBsb2M6dW5kZWZpbmVkLCBwYXJhbTp1bmRlZmluZWQsIGJvZHk6dW5kZWZpbmVkfSk7XG5sZXQgY2F0Y2hIZWFkU2Nvb3AgPSBTQ09QRV9hZGRMYXllcihzY29vcCwgNSwgJ3BhcnNlVHJ5U3RhdGVtZW50KGNhdGNoLXZhciknKTtcbmxldCBjYXRjaEJvZHlTY29vcCA9IFNDT1BFX2FkZExheWVyKGNhdGNoSGVhZFNjb29wLCA2LCAncGFyc2VUcnlTdGF0ZW1lbnQoY2F0Y2gtYm9keSknKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMykge1xuaWYgKCFhbGxvd09wdGlvbmFsQ2F0Y2hCaW5kaW5nKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ01pc3NpbmcgdGhlIGBjYXRjaGAgY2xhdXNlLiBPcHRpb25hbCBjYXRjaCBjbGF1c2UgaXMgb25seSBzdXBwb3J0ZWQgc2luY2UgRVMxMCAgRVMyMDE5JywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuQVNUX3NldCgncGFyYW0nLCBudWxsKTtcbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0NzEpIHtcbnNraXBUb0JpbmRpbmdTdGFydChsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ3Mikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgY2F0Y2ggY2xhdXNlIG11c3QgaGF2ZSBhIGJpbmRpbmcnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5sZXQgJHRwX2JpbmRpbmdfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2JpbmRpbmdfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9iaW5kaW5nX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5wYXJzZUJpbmRpbmcobGV4ZXJGbGFncyB8IDQwOTYsICR0cF9iaW5kaW5nX3N0YXJ0LCAkdHBfYmluZGluZ19saW5lLCAkdHBfYmluZGluZ19jb2x1bW4sIGNhdGNoSGVhZFNjb29wLCAxMCwgNCwgZmFsc2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAncGFyYW0nKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYXRjaCBjbGF1c2UgcmVxdWlyZXMgZXhhY3RseSBvbmUgcGFyYW1ldGVyLCBub3QgbW9yZSAoYW5kIG5vIHRyYWlsaW5nIGNvbW1hKScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3Mikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnTWlzc2luZyByaWdodCBwYXJlbiBmb3IgdGhlIGNhdGNoIGNsYXVzZSwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBUb0N1cmx5T3Blbk9yRGllKGxleGVyRmxhZ3MpO1xufSBlbHNlIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3Npbmcgc3RhcnQgb2YgY2F0Y2ggY2xhdXNlIChgKGApIG9yIHN0YXJ0IG9mIGNhdGNoIGJvZHkgKGB7YCksIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5wYXJzZUJsb2NrU3RhdGVtZW50KGxleGVyRmxhZ3MsIGNhdGNoQm9keVNjb29wLCBsYWJlbFNldCwgJ2JvZHknKTtcbkFTVF9jbG9zZSgkdHBfY2F0Y2hfc3RhcnQsICR0cF9jYXRjaF9saW5lLCAkdHBfY2F0Y2hfY29sdW1uKTtcbn0gZWxzZSB7XG5BU1Rfc2V0KCdoYW5kbGVyJywgbnVsbCk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMjA5Mikge1xuaGFzRWl0aGVyID0gdHJ1ZTtcbnNraXBUb0N1cmx5T3Blbk9yRGllKGxleGVyRmxhZ3MpO1xubGV0IGZpbmFsbHlTY29vcCA9IFNDT1BFX2FkZExheWVyKHNjb29wLCA3LCAncGFyc2VUcnlTdGF0ZW1lbnQoZmluYWxseSknKTtcbnBhcnNlQmxvY2tTdGF0ZW1lbnQobGV4ZXJGbGFncywgZmluYWxseVNjb29wLCBsYWJlbFNldCwgJ2ZpbmFsaXplcicpO1xufSBlbHNlIHtcbkFTVF9zZXQoJ2ZpbmFsaXplcicsIG51bGwpO1xufVxuQVNUX2Nsb3NlKCR0cF90cnlfc3RhcnQsICR0cF90cnlfbGluZSwgJHRwX3RyeV9jb2x1bW4pO1xuaWYgKCFoYXNFaXRoZXIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVHJ5IG11c3QgaGF2ZSBjYXRjaCBvciBmaW5hbGx5JywgJHRwX3RyeV9zdGFydCwgJHRwX3RyeV9zdG9wKTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlVmFyU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3Zhcl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfdmFyX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfdmFyX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5za2lwVG9CaW5kaW5nU3RhcnQobGV4ZXJGbGFncyk7XG5wYXJzZUFueVZhckRlY2xhcmF0aW9uKGxleGVyRmxhZ3MsICR0cF92YXJfc3RhcnQsICR0cF92YXJfbGluZSwgJHRwX3Zhcl9jb2x1bW4sIHNjb29wLCAyLCAxLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZVdoaWxlU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCkge1xubGV0ICR0cF93aGlsZV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfd2hpbGVfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF93aGlsZV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvUGFyZW5PcGVuT3JEaWUobGV4ZXJGbGFncyk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonV2hpbGVTdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCB0ZXN0OnVuZGVmaW5lZCwgYm9keTp1bmRlZmluZWR9KTtcbnBhcnNlU3RhdGVtZW50SGVhZGVyKGxleGVyRmxhZ3MsICd0ZXN0Jyk7XG5wYXJzZU5lc3RlZEJvZHlQYXJ0KGxleGVyRmxhZ3MgfCA1MTIsIHNjb29wLCBsYWJlbFNldCwgZmFsc2UsIDEsIG51bGwsICdib2R5Jyk7XG5BU1RfY2xvc2UoJHRwX3doaWxlX3N0YXJ0LCAkdHBfd2hpbGVfbGluZSwgJHRwX3doaWxlX2NvbHVtbik7XG59XG5mdW5jdGlvbiBwYXJzZUlkZW50TGFiZWxPckV4cHJlc3Npb25TdGF0ZW1lbnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApIHtcbmxldCAkdHBfaWRlbnRfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2lkZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9pZGVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2lkZW50X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2lkZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9pZGVudF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcElkZW50U2FmZVNsb3dBbmRFeHBlbnNpdmUobGV4ZXJGbGFncywgZmFsc2UpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg5KSB7XG5yZXR1cm4gcGFyc2VMYWJlbGVkU3RhdGVtZW50SW5zdGVhZChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBmZFN0YXRlLCBuZXN0ZWRMYWJlbHMsIGFzdFByb3ApO1xufVxuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0V4cHJlc3Npb25TdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBleHByZXNzaW9uOnVuZGVmaW5lZH0pO1xucGFyc2VFeHByZXNzaW9uc0FmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sICdleHByZXNzaW9uJyk7XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlTGFiZWxlZFN0YXRlbWVudEluc3RlYWQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgZmRTdGF0ZSwgbmVzdGVkTGFiZWxzLCBhc3RQcm9wKSB7XG5pZiAoKCgkdHBfaWRlbnRfdHlwZSAhPT0gMjA4OCkgJiYgKCR0cF9pZGVudF90eXBlICE9PSAyMDcyKSkpIHtcbmZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgMCwgbGV4ZXJGbGFncyk7XG59XG5sZXQgc2V0ID0gbGFiZWxTZXQ7XG53aGlsZSAoc2V0KSB7XG5pZiAoc2V0LnN0YXRlbWVudExhYmVscy5oYXMoJHRwX2lkZW50X2Nhbm9uKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdTYXcgdGhlIHNhbWUgbGFiZWwgdHdpY2Ugd2hpY2ggaXMgbm90IGFsbG93ZWQnLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKTtcbn1cbnNldCA9IHNldC5wYXJlbnRMYWJlbHM7XG59XG5sYWJlbFNldCA9IHdyYXBMYWJlbFNldChsYWJlbFNldCwgJ2xhYmVsbGVkIHN0YXRlbWVudCcpO1xubGFiZWxTZXQuc3RhdGVtZW50TGFiZWxzLmFkZCgkdHBfaWRlbnRfY2Fub24pO1xuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncyk7XG5pZiAoZmRTdGF0ZSA9PT0gMikge1xuZmRTdGF0ZSA9IDE7XG59XG5pZiAobmVzdGVkTGFiZWxzID09PSBudWxsKSB7XG5uZXN0ZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG59XG5uZXN0ZWRMYWJlbHMuYWRkKCR0cF9pZGVudF9jYW5vbik7XG5pZiAoKGlzSWRlbnRUb2tlbih0b2tfZ2V0VHlwZSgpKSAmJiAoKCgoKHRva19nZXRUeXBlKCkgPT09IDIwOTMpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAyMTI0KSkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAyMDg1KSkpKSkge1xubGFiZWxTZXQuaXRlcmF0aW9uTGFiZWxzID0gbmVzdGVkTGFiZWxzO1xufVxuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0xhYmVsZWRTdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBsYWJlbDpBU1RfZ2V0SWRlbnROb2RlKCR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24pLCBib2R5OnVuZGVmaW5lZH0pO1xucGFyc2VOZXN0ZWRCb2R5UGFydChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIHRydWUsIGZkU3RhdGUsIG5lc3RlZExhYmVscywgJ2JvZHknKTtcbkFTVF9jbG9zZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHVuY3R1YXRvclN0YXRlbWVudChsZXhlckZsYWdzLCBzY29vcCwgbGFiZWxTZXQsIGFzdFByb3ApIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMykge1xubGV0IGJsb2NrU2Nvb3AgPSBTQ09QRV9hZGRMYXllcihzY29vcCwgMiwgJ3BhcnNlUHVuY3R1YXRvclN0YXRlbWVudC5ibG9jaycpO1xucGFyc2VCbG9ja1N0YXRlbWVudChsZXhlckZsYWdzLCBibG9ja1Njb29wLCBsYWJlbFNldCwgYXN0UHJvcCk7XG5yZXR1cm47XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0OTApIHtcbnBhcnNlRW1wdHlTdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCk7XG5yZXR1cm47XG59XG5sZXQgJHRwX2lkZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9pZGVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2lkZW50X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonRXhwcmVzc2lvblN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGV4cHJlc3Npb246dW5kZWZpbmVkfSk7XG5wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICdleHByZXNzaW9uJyk7XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1wdHlTdGF0ZW1lbnQobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9zZW1pX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zZW1pX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc2VtaV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvU3RhdGVtZW50U3RhcnQobGV4ZXJGbGFncyk7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonRW1wdHlTdGF0ZW1lbnQnLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfc2VtaV9zdGFydCwgJHRwX3NlbWlfbGluZSwgJHRwX3NlbWlfY29sdW1uKX0pO1xufVxuZnVuY3Rpb24gcGFyc2VXaXRoU3RhdGVtZW50KGxleGVyRmxhZ3MsIHNjb29wLCBsYWJlbFNldCwgYXN0UHJvcCkge1xubGV0ICR0cF93aXRoX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF93aXRoX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfd2l0aF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF93aXRoX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIGB3aXRoYCBzdGF0ZW1lbnQgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLCAkdHBfd2l0aF9zdGFydCwgJHRwX3dpdGhfc3RvcCk7XG59XG5za2lwVG9QYXJlbk9wZW5PckRpZShsZXhlckZsYWdzKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidXaXRoU3RhdGVtZW50JywgbG9jOnVuZGVmaW5lZCwgb2JqZWN0OnVuZGVmaW5lZCwgYm9keTp1bmRlZmluZWR9KTtcbnBhcnNlU3RhdGVtZW50SGVhZGVyKGxleGVyRmxhZ3MsICdvYmplY3QnKTtcbnBhcnNlTmVzdGVkQm9keVBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIGxhYmVsU2V0LCBmYWxzZSwgMSwgbnVsbCwgJ2JvZHknKTtcbkFTVF9jbG9zZSgkdHBfd2l0aF9zdGFydCwgJHRwX3dpdGhfbGluZSwgJHRwX3dpdGhfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQW55VmFyRGVjbGFyYXRpb24obGV4ZXJGbGFncywgJHRwX2JpbmRpbmdfc3RhcnQsICR0cF9iaW5kaW5nX2xpbmUsICR0cF9iaW5kaW5nX2NvbHVtbiwgc2Nvb3AsIGJpbmRpbmdUeXBlLCBiaW5kaW5nT3JpZ2luLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKSB7XG5pZiAoKCgoKCFpc0lkZW50VG9rZW4odG9rX2dldFR5cGUoKSkpICYmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjUwOSkpKSAmJiAodG9rX2dldFR5cGUoKSAhPT0gMTY1MTMpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdFeHBlY3RlZCBpZGVudGlmaWVyLCBvciBhcnJheS9vYmplY3QgZGVzdHJ1Y3R1cmluZycsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmxldCBrZXl3b3JkID0gKChiaW5kaW5nVHlwZSA9PT0gMik/ICd2YXInIDogKCgoYmluZGluZ1R5cGUgPT09IDYpPyAnbGV0JyA6ICdjb25zdCcpKSk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonVmFyaWFibGVEZWNsYXJhdGlvbicsIGxvYzp1bmRlZmluZWQsIGtpbmQ6a2V5d29yZCwgZGVjbGFyYXRpb25zOltdfSk7XG5wYXJzZUJpbmRpbmdzKGxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nVHlwZSwgYmluZGluZ09yaWdpbiwgdHJ1ZSwgMCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgJ2RlY2xhcmF0aW9ucycpO1xuaWYgKCgoYmluZGluZ09yaWdpbiA9PT0gMSkgfHwgKGJpbmRpbmdPcmlnaW4gPT09IDMpKSkge1xucGFyc2VTZW1pT3JBc2kobGV4ZXJGbGFncyk7XG59XG5BU1RfY2xvc2UoJHRwX2JpbmRpbmdfc3RhcnQsICR0cF9iaW5kaW5nX2xpbmUsICR0cF9iaW5kaW5nX2NvbHVtbik7XG59XG5mdW5jdGlvbiBwYXJzZUJpbmRpbmdzKGxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nVHlwZSwgYmluZGluZ09yaWdpbiwgZGVmYXVsdE9wdGlvbnMsICR0cF9zZXRfdHlwZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xubGV0IG1hbnkgPSAwO1xubGV0IGluaXRlZCA9IGZhbHNlO1xubGV0IHN0YXJ0V2FzT2JqZWN0T3JBcnJheSA9ICgodG9rX2dldFR5cGUoKSA9PT0gMTY1MDkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMykpO1xubGV0IHBhcmFtc1NpbXBsZSA9IDE7XG5kbyB7XG4rK21hbnk7XG5sZXQgJHRwX2JpbmRpbmdTdGFydF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfYmluZGluZ1N0YXJ0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9iaW5kaW5nU3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9iaW5kaW5nU3RhcnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCB3YXNSZXN0ID0gJHRwX2JpbmRpbmdTdGFydF90eXBlID09PSAxNjQ4NjtcbmxldCBwYXJhbVNpbXBsZSA9IHBhcnNlQmluZGluZyhsZXhlckZsYWdzLCAkdHBfYmluZGluZ1N0YXJ0X3N0YXJ0LCAkdHBfYmluZGluZ1N0YXJ0X2xpbmUsICR0cF9iaW5kaW5nU3RhcnRfY29sdW1uLCBzY29vcCwgYmluZGluZ1R5cGUsIGJpbmRpbmdPcmlnaW4sIGRlZmF1bHRPcHRpb25zLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbmlmICgod2FzUmVzdCAmJiAoJHRwX3NldF90eXBlID09PSAyMTEyKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQSBzZXR0ZXIgY2FuIG5vdCBoYXZlIGEgcmVzdCBhcmcgKHVubGVzcyBpbnNpZGUgYSBwYXR0ZXJuKScsICR0cF9iaW5kaW5nU3RhcnRfc3RhcnQsIHRva19nZXRTdGFydCgpKTtcbn1cbmlmIChwYXJhbVNpbXBsZSA9PT0gNCkge1xuaW5pdGVkID0gdHJ1ZTtcbnBhcmFtc1NpbXBsZSA9IDM7XG59IGVsc2UgaWYgKHBhcmFtU2ltcGxlID09PSAzKSB7XG5wYXJhbXNTaW1wbGUgPSAzO1xufSBlbHNlIGlmIChwYXJhbVNpbXBsZSA9PT0gMikge1xuaWYgKHBhcmFtc1NpbXBsZSA9PT0gMSkge1xucGFyYW1zU2ltcGxlID0gMjtcbn1cbn1cbmlmICh3YXNSZXN0KSB7XG5icmVhaztcbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ4MCkgYnJlYWs7XG5za2lwVG9CaW5kaW5nU3RhcnRHcm91cGVkKGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDcyKSB7XG5pZiAoYmluZGluZ1R5cGUgPT09IDEpIHtcbmlmIChhbGxvd1RyYWlsaW5nRnVuY3Rpb25Db21tYSkge1xucmV0dXJuIHBhcmFtc1NpbXBsZTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgnVGFyZ2V0ZWQgbGFuZ3VhZ2UgdmVyc2lvbiBkb2VzIG5vdCBzdXBwb3J0IHRyYWlsaW5nIGZ1bmN0aW9uIGFyZyBjb21tYScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbn0gd2hpbGUgKHRydWUpO1xuaWYgKCgobWFueSAhPT0gMSkgJiYgKCR0cF9zZXRfdHlwZSA9PT0gMjExMikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1NldHRlcnMgcmVxdWlyZSBleGFjdGx5IG9uZSBwYXJhbWV0ZXInLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAoKChiaW5kaW5nT3JpZ2luID09PSAyKSAmJiAoKCh0b2tfZ2V0VHlwZSgpID09PSA2NzYzNikgfHwgKHRva19nZXRUeXBlKCkgPT09IDIxMDYpKSkpKSB7XG5pZiAobWFueSAhPT0gMSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdGb3ItaW4gYW5kIGZvci1vZiBjYW4gb25seSBoYXZlIG9uZSBiaW5kaW5nLCBmb3VuZCAnICsgbWFueSwgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuaWYgKChpbml0ZWQgJiYgKCgoKCgoKChzdGFydFdhc09iamVjdE9yQXJyYXkgfHwgKG9wdGlvbnNfd2ViQ29tcGF0ID09PSBmYWxzZSkpKSB8fCAoYmluZGluZ1R5cGUgIT09IDIpKSkgfHwgKHRva19nZXRUeXBlKCkgPT09IDIxMDYpKSkgfHwgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpKSkpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Zvci1pbiBhbmQgZm9yLW9mIGJpbmRpbmcgY2FuIG5vdCBoYXZlIGFuIGluaXQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG59XG5yZXR1cm4gcGFyYW1zU2ltcGxlO1xufVxuZnVuY3Rpb24gcGFyc2VCaW5kaW5nKGxleGVyRmxhZ3MsICR0cF9iaW5kaW5nU3RhcnRfc3RhcnQsICR0cF9iaW5kaW5nU3RhcnRfbGluZSwgJHRwX2JpbmRpbmdTdGFydF9jb2x1bW4sIHNjb29wLCBiaW5kaW5nVHlwZSwgYmluZGluZ09yaWdpbiwgZGVmYXVsdHNPcHRpb24sIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApIHtcbmxldCBtdXN0SGF2ZUluaXQgPSBmYWxzZTtcbmxldCBwYXJhbVNpbXBsZSA9IDA7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5sZXQgJHRwX2JpbmRpbmdfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2JpbmRpbmdfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfYmluZGluZ19zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfYmluZGluZ19jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuZmF0YWxCaW5kaW5nSWRlbnRDaGVjaygkdHBfYmluZGluZ190eXBlLCAkdHBfYmluZGluZ19zdGFydCwgJHRwX2JpbmRpbmdfc3RvcCwgJHRwX2JpbmRpbmdfY2Fub24sIGJpbmRpbmdUeXBlLCBsZXhlckZsYWdzKTtcbmlmIChiaW5kaW5nVHlwZSA9PT0gMTApIHtcbmJpbmRpbmdUeXBlID0gOTtcbn1cblNDT1BFX2FjdHVhbGx5QWRkQmluZGluZyhsZXhlckZsYWdzLCBzY29vcCwgJHRwX2JpbmRpbmdfc3RhcnQsICR0cF9iaW5kaW5nX3N0b3AsICR0cF9iaW5kaW5nX2Nhbm9uLCBiaW5kaW5nVHlwZSk7XG5hZGROYW1lVG9FeHBvcnRzKGV4cG9ydGVkTmFtZXMsICR0cF9iaW5kaW5nX3N0YXJ0LCAkdHBfYmluZGluZ19zdG9wLCAkdHBfYmluZGluZ19jYW5vbik7XG5hZGRCaW5kaW5nVG9FeHBvcnRzKGV4cG9ydGVkQmluZGluZ3MsICR0cF9iaW5kaW5nX2Nhbm9uKTtcbmxldCAkdHBfaWRlbnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2lkZW50X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfaWRlbnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfaWRlbnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2lkZW50X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xuQVNUX3NldElkZW50KGFzdFByb3AsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24pO1xuaWYgKCgoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gMCkgJiYgKG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2JpbmRpbmdfdHlwZSwgJHRwX2JpbmRpbmdfc3RhcnQsICR0cF9iaW5kaW5nX3N0b3AsICR0cF9iaW5kaW5nX2Nhbm9uLCBiaW5kaW5nVHlwZSwgbGV4ZXJGbGFncyB8IDgxOTIpICE9PSAnJykpKSB7XG5wYXJhbVNpbXBsZSA9IDI7XG59IGVsc2Uge1xucGFyYW1TaW1wbGUgPSAxO1xufVxufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMykge1xubGV0IGRlc3RydWN0aWJsZSA9IHBhcnNlT2JqZWN0T3V0ZXIobGV4ZXJGbGFncywgc2Nvb3AsIGJpbmRpbmdUeXBlLCBmYWxzZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCk7XG52ZXJpZnlEZXN0cnVjdGlibGVGb3JCaW5kaW5nKGRlc3RydWN0aWJsZSwgYmluZGluZ1R5cGUpO1xuQVNUX2Rlc3RydWN0KGFzdFByb3ApO1xucGFyYW1TaW1wbGUgPSAzO1xuaWYgKCgoKChiaW5kaW5nT3JpZ2luICE9PSA0KSAmJiAoKChiaW5kaW5nT3JpZ2luICE9PSAyKSB8fCAoKCh0b2tfZ2V0VHlwZSgpICE9PSA2NzYzNikgJiYgKHRva19nZXRUeXBlKCkgIT09IDIxMDYpKSkpKSkpICYmICgoKCgoYmluZGluZ1R5cGUgPT09IDcpIHx8IChiaW5kaW5nVHlwZSA9PT0gNikpKSB8fCAoYmluZGluZ1R5cGUgPT09IDIpKSkpKSB7XG5tdXN0SGF2ZUluaXQgPSB0cnVlO1xufVxufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwOSkge1xubGV0IGRlc3RydWN0aWJsZSA9IHBhcnNlQXJyYXlPdXRlcihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIGZhbHNlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbnZlcmlmeURlc3RydWN0aWJsZUZvckJpbmRpbmcoZGVzdHJ1Y3RpYmxlLCBiaW5kaW5nVHlwZSk7XG5BU1RfZGVzdHJ1Y3QoYXN0UHJvcCk7XG5wYXJhbVNpbXBsZSA9IDM7XG5pZiAoKCgoKGJpbmRpbmdPcmlnaW4gIT09IDQpICYmICgoKGJpbmRpbmdPcmlnaW4gIT09IDIpIHx8ICgoKHRva19nZXRUeXBlKCkgIT09IDY3NjM2KSAmJiAodG9rX2dldFR5cGUoKSAhPT0gMjEwNikpKSkpKSkgJiYgKCgoKChiaW5kaW5nVHlwZSA9PT0gNykgfHwgKGJpbmRpbmdUeXBlID09PSA2KSkpIHx8IChiaW5kaW5nVHlwZSA9PT0gMikpKSkpIHtcbm11c3RIYXZlSW5pdCA9IHRydWU7XG59XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg2KSB7XG5pZiAoYmluZGluZ1R5cGUgIT09IDEpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnUmVzdCBpcyBub3QgYWxsb3dlZCBhcyB0b3BsZXZlbCBmb3IgdmFyL2xldC9jb25zdCBkZWNsYXJhdGlvbiBiaW5kaW5nJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxubGV0IHN1YkRlc3RydWN0ID0gcGFyc2VBcnJvd2FibGVTcHJlYWRPclJlc3QobGV4ZXJGbGFncywgc2Nvb3AsIDE2NDcyLCBiaW5kaW5nVHlwZSwgMCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCk7XG52ZXJpZnlEZXN0cnVjdGlibGVGb3JCaW5kaW5nKHN1YkRlc3RydWN0LCBiaW5kaW5nVHlwZSk7XG5wYXJhbVNpbXBsZSA9IDM7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDcyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0V4cGVjdGVkIHRvIHBhcnNlIGEobm90aGVyKSBiaW5kaW5nIGJ1dCBub25lIHdhcyBmb3VuZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSA0OTI2NCkge1xuaWYgKGJpbmRpbmdPcmlnaW4gPT09IDQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2F0Y2ggY2xhdXNlIGNhbiBub3QgaGF2ZSBpbml0IC8gZGVmYXVsdCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbnBhcmFtU2ltcGxlID0gNDtcbmlmIChkZWZhdWx0c09wdGlvbiA9PT0gZmFsc2UpIHtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOidBc3NpZ25tZW50UGF0dGVybicsIGxvYzp1bmRlZmluZWQsIGxlZnQ6dW5kZWZpbmVkLCByaWdodDp1bmRlZmluZWR9LCAnbGVmdCcpO1xucGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsICdyaWdodCcpO1xuQVNUX2Nsb3NlKCR0cF9iaW5kaW5nU3RhcnRfc3RhcnQsICR0cF9iaW5kaW5nU3RhcnRfbGluZSwgJHRwX2JpbmRpbmdTdGFydF9jb2x1bW4pO1xufSBlbHNlIHtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKCdkZWNsYXJhdGlvbnMnLCB7dHlwZTonVmFyaWFibGVEZWNsYXJhdG9yJywgbG9jOnVuZGVmaW5lZCwgaWQ6dW5kZWZpbmVkLCBpbml0OnVuZGVmaW5lZH0sICdpZCcpO1xucGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsICdpbml0Jyk7XG5BU1RfY2xvc2UoJHRwX2JpbmRpbmdTdGFydF9zdGFydCwgJHRwX2JpbmRpbmdTdGFydF9saW5lLCAkdHBfYmluZGluZ1N0YXJ0X2NvbHVtbik7XG59XG59IGVsc2UgaWYgKG11c3RIYXZlSW5pdCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdEZWNsYXJhdGlvbiBkZXN0cnVjdHVyaW5nIG11c3QgaGF2ZSBpbml0JywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufSBlbHNlIGlmICgoKGJpbmRpbmdUeXBlID09PSA3KSAmJiAoKChiaW5kaW5nT3JpZ2luICE9PSAyKSB8fCAoKCh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5MCkgfHwgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSkpKSkpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NvbnN0YW50cyBtdXN0IGJlIGluaXRpYWxpemVkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufSBlbHNlIGlmIChkZWZhdWx0c09wdGlvbiA9PT0gdHJ1ZSkge1xuaWYgKCgodG9rX2dldE5sd2FzKCkgPT09IHRydWUpICYmIGlzUmVnZXhUb2tlbih0b2tfZ2V0VHlwZSgpKSkpIHtcbmlmIChiaW5kaW5nT3JpZ2luID09PSAyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0lsbGVnYWwgcmVnZXggYWZ0ZXIgYmluZGluZyBkZWNsYXJhdGlvbiBpbiBgZm9yYCBoZWFkZXInLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5BU1NFUlRfQVNJX1JFR0VYX05FWFQgPSB0cnVlO1xufVxuQVNUX3NldE5vZGVEYW5nZXJvdXNseSgnZGVjbGFyYXRpb25zJywge3R5cGU6J1ZhcmlhYmxlRGVjbGFyYXRvcicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9iaW5kaW5nU3RhcnRfc3RhcnQsICR0cF9iaW5kaW5nU3RhcnRfbGluZSwgJHRwX2JpbmRpbmdTdGFydF9jb2x1bW4pLCBpZDpBU1RfcG9wTm9kZSgnZGVjbGFyYXRpb25zJyksIGluaXQ6bnVsbH0pO1xufSBlbHNlIHtcblxufVxucmV0dXJuIHBhcmFtU2ltcGxlO1xufVxuZnVuY3Rpb24gZmF0YWxCaW5kaW5nSWRlbnRDaGVjaygkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSwgbGV4ZXJGbGFncykge1xubGV0IHN0ciA9IG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGxleGVyRmxhZ3MpO1xuaWYgKHN0ciAhPT0gJycpIFRIUk9XX1JBTkdFKGBDYW5ub3QgdXNlIHRoaXMgbmFtZSAoXFxgJHt0b2tfc2xpY2VJbnB1dCgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKX1cXGApIGFzIGEgdmFyaWFibGUgbmFtZSBiZWNhdXNlOiAke3N0cn1gLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKTtcbn1cbmZ1bmN0aW9uIG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGxleGVyRmxhZ3MpIHtcbmlmICgoJHRwX2lkZW50X3N0b3AgLSAkdHBfaWRlbnRfc3RhcnQpID09PSAkdHBfaWRlbnRfY2Fub24ubGVuZ3RoKSB7XG5pZiAoJHRwX2lkZW50X3R5cGUgPT09IDIwNDgpIHJldHVybiAnJztcbnJldHVybiBub25GYXRhbEJpbmRpbmdJZGVudENoZWNrQnlFbnVtKGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbn1cbnJldHVybiBub25GYXRhbEJpbmRpbmdJZGVudENoZWNrQnlTdHJpbmcobGV4ZXJGbGFncywgJHRwX2lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSk7XG59XG5mdW5jdGlvbiBub25GYXRhbEJpbmRpbmdJZGVudENoZWNrQnlFbnVtKGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKSB7XG5zd2l0Y2ggKCR0cF9pZGVudF90eXBlKSB7XG5jYXNlIDIwNzY6XG5cbmNhc2UgMjA3NzpcblxuY2FzZSAyMDc4OlxuXG5jYXNlIDIwNzk6XG5cbmNhc2UgMjA4MDpcblxuY2FzZSAyMDgxOlxuXG5jYXNlIDIwODI6XG5cbmNhc2UgMjA4MzpcblxuY2FzZSAyMDg0OlxuXG5jYXNlIDIwODU6XG5cbmNhc2UgMjA4NjpcblxuY2FzZSAyMDg5OlxuXG5jYXNlIDIwOTA6XG5cbmNhc2UgMjA5MjpcblxuY2FzZSAyMDkzOlxuXG5jYXNlIDIwOTU6XG5cbmNhc2UgMjA5NzpcblxuY2FzZSAyMDk5OlxuXG5jYXNlIDY3NjM2OlxuXG5jYXNlIDY3NjM3OlxuXG5jYXNlIDIxMDQ6XG5cbmNhc2UgMjExMTpcblxuY2FzZSAyMTE0OlxuXG5jYXNlIDIxMTU6XG5cbmNhc2UgMjExNzpcblxuY2FzZSAyMTE4OlxuXG5jYXNlIDIxMjA6XG5cbmNhc2UgMjEyMTpcblxuY2FzZSAyMTIyOlxuXG5jYXNlIDIxMjM6XG5cbmNhc2UgMjEyNDpcblxuY2FzZSAyMTI1OlxuXG5jYXNlIDIxMDU6XG5cbmNhc2UgMjExOTpcblxuY2FzZSAyMDkxOlxuXG5jYXNlIDIwODc6XG5yZXR1cm4gJ0Nhbm5vdCBuZXZlciB1c2UgdGhpcyByZXNlcnZlZCB3b3JkIGFzIGEgdmFyaWFibGUgbmFtZSc7XG5jYXNlIDIxMDM6XG5pZiAoYmluZGluZ1R5cGUgPT09IDgpIHJldHVybiAnQ2FuIG5vdCB1c2UgYGxldGAgYXMgYSBjbGFzcyBuYW1lJztcbmlmICgoKGJpbmRpbmdUeXBlID09PSA2KSB8fCAoYmluZGluZ1R5cGUgPT09IDcpKSkgcmV0dXJuICdDYW4gbm90IHVzZSBgbGV0YCB3aGVuIGJpbmRpbmcgdGhyb3VnaCBgbGV0YCBvciBgY29uc3RgJztcbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSByZXR1cm4gJ0NhbiBub3QgdXNlIGBsZXRgIGFzIHZhcmlhYmxlIG5hbWUgaW4gc3RyaWN0IG1vZGUnO1xucmV0dXJuICcnO1xuY2FzZSAyMTEzOlxuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHJldHVybiAnYHN0YXRpY2AgaXMgYSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJztcbnJldHVybiAnJztcbmNhc2UgMjA4ODpcblxuY2FzZSAyMDcyOlxuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHJldHVybiAoJ0Nhbm5vdCBjcmVhdGUgYSBiaW5kaW5nIG5hbWVkIGAnICsgJHRwX2lkZW50X2Nhbm9uKSArICdgIGluIHN0cmljdCBtb2RlJztcbnJldHVybiAnJztcbmNhc2UgMjA5ODpcblxuY2FzZSAyMTA3OlxuXG5jYXNlIDIxMDk6XG5cbmNhc2UgMjEwMjpcblxuY2FzZSAyMTA4OlxuXG5jYXNlIDIxMTA6XG5pZiAoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gODE5MikgcmV0dXJuICdDYW5ub3QgdXNlIHRoaXMgcmVzZXJ2ZWQgd29yZCBhcyBhIHZhcmlhYmxlIG5hbWUgaW4gc3RyaWN0IG1vZGUnO1xucmV0dXJuICcnO1xuY2FzZSAyMDc1OlxuaWYgKGFsbG93QXN5bmNGdW5jdGlvbnMpIHtcbmlmIChnb2FsTW9kZSA9PT0gdHJ1ZSkgcmV0dXJuICdBd2FpdCBpcyBpbGxlZ2FsIGFzIHZhciBuYW1lIHdpdGggbW9kdWxlIGdvYWwnO1xuaWYgKChsZXhlckZsYWdzICYgOCkgIT09IDApIHJldHVybiAnQXdhaXQgbm90IGFsbG93ZWQgaGVyZSc7XG59XG5yZXR1cm4gJyc7XG5jYXNlIDIxMjY6XG5pZiAoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gODE5MikgcmV0dXJuICdDYW5ub3QgdXNlIHRoaXMgcmVzZXJ2ZWQgd29yZCBhcyBhIHZhcmlhYmxlIG5hbWUgaW4gc3RyaWN0IG1vZGUnO1xuaWYgKChsZXhlckZsYWdzICYgMTI4KSAhPT0gMCkgcmV0dXJuICdDYW5ub3QgdXNlIHRoaXMgcmVzZXJ2ZWQgd29yZCBhcyBhIHZhcmlhYmxlIG5hbWUgaW5zaWRlIGEgZ2VuZXJhdG9yJztcbnJldHVybiAnJztcbn1cbnJldHVybiAnJztcbn1cbmZ1bmN0aW9uIG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2tCeVN0cmluZyhsZXhlckZsYWdzLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKSB7XG5zd2l0Y2ggKCR0cF9pZGVudF9jYW5vbikge1xuY2FzZSAnYnJlYWsnOlxuXG5jYXNlICdjYXNlJzpcblxuY2FzZSAnY2F0Y2gnOlxuXG5jYXNlICdjbGFzcyc6XG5cbmNhc2UgJ2NvbnN0JzpcblxuY2FzZSAnY29udGludWUnOlxuXG5jYXNlICdkZWJ1Z2dlcic6XG5cbmNhc2UgJ2RlZmF1bHQnOlxuXG5jYXNlICdkZWxldGUnOlxuXG5jYXNlICdkbyc6XG5cbmNhc2UgJ2Vsc2UnOlxuXG5jYXNlICdleHBvcnQnOlxuXG5jYXNlICdleHRlbmRzJzpcblxuY2FzZSAnZmluYWxseSc6XG5cbmNhc2UgJ2Zvcic6XG5cbmNhc2UgJ2Z1bmN0aW9uJzpcblxuY2FzZSAnaWYnOlxuXG5jYXNlICdpbXBvcnQnOlxuXG5jYXNlICdpbic6XG5cbmNhc2UgJ2luc3RhbmNlb2YnOlxuXG5jYXNlICduZXcnOlxuXG5jYXNlICdyZXR1cm4nOlxuXG5jYXNlICdzdXBlcic6XG5cbmNhc2UgJ3N3aXRjaCc6XG5cbmNhc2UgJ3RoaXMnOlxuXG5jYXNlICd0aHJvdyc6XG5cbmNhc2UgJ3RyeSc6XG5cbmNhc2UgJ3R5cGVvZic6XG5cbmNhc2UgJ3Zhcic6XG5cbmNhc2UgJ3ZvaWQnOlxuXG5jYXNlICd3aGlsZSc6XG5cbmNhc2UgJ3dpdGgnOlxuXG5jYXNlICdudWxsJzpcblxuY2FzZSAndHJ1ZSc6XG5cbmNhc2UgJ2ZhbHNlJzpcblxuY2FzZSAnZW51bSc6XG5yZXR1cm4gKCdLZXl3b3JkcyBtYXkgbm90IGhhdmUgZXNjYXBlcyBpbiB0aGVpciBuYW1lIGFuZCB0aGlzIHJlc29sdmVzIHRvIGAnICsgJHRwX2lkZW50X2Nhbm9uKSArICdgJztcbmNhc2UgJ2xldCc6XG5pZiAoYmluZGluZ1R5cGUgPT09IDgpIHJldHVybiAnQ2FuIG5vdCB1c2UgYGxldGAgYXMgYSBjbGFzcyBuYW1lJztcbmlmICgoKGJpbmRpbmdUeXBlID09PSA2KSB8fCAoYmluZGluZ1R5cGUgPT09IDcpKSkgcmV0dXJuICdDYW4gbm90IHVzZSBgbGV0YCB3aGVuIGJpbmRpbmcgdGhyb3VnaCBgbGV0YCBvciBgY29uc3RgJztcbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSByZXR1cm4gJ0NhbiBub3QgdXNlIGBsZXRgIGFzIHZhcmlhYmxlIG5hbWUgaW4gc3RyaWN0IG1vZGUnO1xucmV0dXJuICcnO1xuY2FzZSAnc3RhdGljJzpcbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSByZXR1cm4gKCdLZXl3b3JkcyBtYXkgbm90IGhhdmUgZXNjYXBlcyBpbiB0aGVpciBuYW1lIGFuZCB0aGlzIHJlc29sdmVzIHRvIGAnICsgJHRwX2lkZW50X2Nhbm9uKSArICdgJztcbnJldHVybiAnJztcbmNhc2UgJ2V2YWwnOlxuXG5jYXNlICdhcmd1bWVudHMnOlxuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHJldHVybiAoJ0Nhbm5vdCBjcmVhdGUgYSBiaW5kaW5nIG5hbWVkIGAnICsgJHRwX2lkZW50X2Nhbm9uKSArICdgIGluIHN0cmljdCBtb2RlJztcbnJldHVybiAnJztcbmNhc2UgJ2ltcGxlbWVudHMnOlxuXG5jYXNlICdwYWNrYWdlJzpcblxuY2FzZSAncHJvdGVjdGVkJzpcblxuY2FzZSAnaW50ZXJmYWNlJzpcblxuY2FzZSAncHJpdmF0ZSc6XG5cbmNhc2UgJ3B1YmxpYyc6XG5pZiAoKGxleGVyRmxhZ3MgJiA4MTkyKSA9PT0gODE5MikgcmV0dXJuICgnS2V5d29yZHMgbWF5IG5vdCBoYXZlIGVzY2FwZXMgaW4gdGhlaXIgbmFtZSBhbmQgdGhpcyByZXNvbHZlcyB0byBgJyArICR0cF9pZGVudF9jYW5vbikgKyAnYCc7XG5yZXR1cm4gJyc7XG5jYXNlICdhd2FpdCc6XG5pZiAoYWxsb3dBc3luY0Z1bmN0aW9ucykge1xuaWYgKGdvYWxNb2RlID09PSB0cnVlKSByZXR1cm4gJ0F3YWl0IGlzIGlsbGVnYWwgYXMgdmFyIG5hbWUgd2l0aCBtb2R1bGUgZ29hbCc7XG5pZiAoKGxleGVyRmxhZ3MgJiA4KSAhPT0gMCkgcmV0dXJuICdBd2FpdCBub3QgYWxsb3dlZCBoZXJlJztcbn1cbnJldHVybiAnJztcbmNhc2UgJ3lpZWxkJzpcbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSByZXR1cm4gJ0Nhbm5vdCB1c2UgdGhpcyByZXNlcnZlZCB3b3JkIGFzIGEgdmFyaWFibGUgbmFtZSBpbiBzdHJpY3QgbW9kZSc7XG5pZiAoKGxleGVyRmxhZ3MgJiAxMjgpICE9PSAwKSByZXR1cm4gJ0Nhbm5vdCB1c2UgdGhpcyByZXNlcnZlZCB3b3JkIGFzIGEgdmFyaWFibGUgbmFtZSBpbnNpZGUgYSBnZW5lcmF0b3InO1xucmV0dXJuICcnO1xufVxucmV0dXJuICcnO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsIGFzdFByb3ApIHtcbmxldCAkdHBfc3RhcnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3N0YXJ0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc3RhcnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfc3RhcnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlVmFsdWUobGV4ZXJGbGFncywgdHJ1ZSwgNCwgZmFsc2UsIGFzdFByb3ApO1xucmV0dXJuIHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfc3RhcnRfc3RhcnQsICR0cF9zdGFydF9zdG9wLCAkdHBfc3RhcnRfbGluZSwgJHRwX3N0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BZnRlckxpdGVyYWwobGV4ZXJGbGFncywgJHRwX2xpdGVyYWxfc3RhcnQsICR0cF9saXRlcmFsX3N0b3AsICR0cF9saXRlcmFsX2xpbmUsICR0cF9saXRlcmFsX2NvbHVtbiwgYXN0UHJvcCkge1xubGV0IGFzc2lnbmFibGUgPSBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfbGl0ZXJhbF9zdGFydCwgJHRwX2xpdGVyYWxfbGluZSwgJHRwX2xpdGVyYWxfY29sdW1uLCAxNiwgNCwgZmFsc2UsIGFzdFByb3ApO1xucGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF9saXRlcmFsX3N0YXJ0LCAkdHBfbGl0ZXJhbF9zdG9wLCAkdHBfbGl0ZXJhbF9saW5lLCAkdHBfbGl0ZXJhbF9jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQWZ0ZXJJZGVudChsZXhlckZsYWdzLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGFzdFByb3ApIHtcbmxldCBhc3NpZ25hYmxlID0gcGFyc2VWYWx1ZUFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCB0cnVlLCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApO1xucmV0dXJuIGFzc2lnbmFibGU7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BZnRlckFzeW5jQXNWYXJOYW1lKGxleGVyRmxhZ3MsIHN0bXRPckV4cHIsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGlzTmV3QXJnLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApIHtcbmlmIChzdG10T3JFeHByID09PSAyKSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonRXhwcmVzc2lvblN0YXRlbWVudCcsIGxvYzp1bmRlZmluZWQsIGV4cHJlc3Npb246dW5kZWZpbmVkfSk7XG5hc3RQcm9wID0gJ2V4cHJlc3Npb24nO1xufVxubGV0IGFzc2lnbmFibGUgPSAxNjtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5OSkge1xuYXNzaWduYWJsZSA9IHBhcnNlQXJyb3dQYXJlbmxlc3NGcm9tUHVuYyhsZXhlckZsYWdzLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAyMDc0LCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19zdG9wLCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgJHRwX2FzeW5jX2Nhbm9uLCBhbGxvd0Fzc2lnbm1lbnQsIDEsIDAsIGFzdFByb3ApO1xufSBlbHNlIHtcbmFzc2lnbmFibGUgPSBwYXJzZUlkZW50T3JQYXJlbmxlc3NBcnJvdyhsZXhlckZsYWdzLCAyMDc0LCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19zdG9wLCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgJHRwX2FzeW5jX2Nhbm9uLCAzMiwgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCBhc3NpZ25hYmxlLCBpc05ld0FyZywgZmFsc2UsIGFzdFByb3ApO1xuaWYgKHN0bXRPckV4cHIgPT09IDIpIHtcbmFzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApO1xufVxufVxuaWYgKHN0bXRPckV4cHIgPT09IDIpIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xuX3BhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgMTYsIGFzdFByb3ApO1xufVxucGFyc2VTZW1pT3JBc2kobGV4ZXJGbGFncyk7XG5BU1RfY2xvc2UoJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbik7XG59XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGFyZW5sZXNzQXJyb3dBZnRlckFzeW5jKGxleGVyRmxhZ3MsIGZyb21TdG10T3JFeHByLCBhbGxvd0Fzc2lnbm1lbnQsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIGFzdFByb3ApIHtcbmlmIChmcm9tU3RtdE9yRXhwciA9PT0gMikge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0V4cHJlc3Npb25TdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBleHByZXNzaW9uOnVuZGVmaW5lZH0pO1xuYXN0UHJvcCA9ICdleHByZXNzaW9uJztcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSAyMDc1KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCB1c2UgYGF3YWl0YCBhcyBhbiBhcmcgbmFtZSB3aXRoIGFzeW5jIGFycm93cycsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmxldCAkdHBfaWRlbnRfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2lkZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9pZGVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2lkZW50X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2lkZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9pZGVudF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xubGV0IGlzU2ltcGxlID0gMTtcbmlmIChpc1N0cmljdE9ubHlLZXl3b3JkKCR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24pKSB7XG5pc1NpbXBsZSA9IDI7XG59XG5za2lwVG9BcnJvd09yRGllKGxleGVyRmxhZ3MpO1xucGFyc2VBcnJvd1BhcmVubGVzc0Zyb21QdW5jKGxleGVyRmxhZ3MsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBhbGxvd0Fzc2lnbm1lbnQsIGlzU2ltcGxlLCAyMDc0LCBhc3RQcm9wKTtcbmlmIChmcm9tU3RtdE9yRXhwciA9PT0gMikge1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5fcGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAxNiwgYXN0UHJvcCk7XG59XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uKTtcbn1cbn1cbmZ1bmN0aW9uIGlzU3RyaWN0T25seUtleXdvcmQoJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbikge1xuaWYgKCR0cF9pZGVudF9jYW5vbi5sZW5ndGggPT09ICgkdHBfaWRlbnRfc3RvcCAtICR0cF9pZGVudF9zdGFydCkpIHtcbnJldHVybiBpc1N0cmljdE9ubHlLZXl3b3JkQnlFbnVtKCR0cF9pZGVudF90eXBlKTtcbn1cbnJldHVybiBpc1N0cmljdE9ubHlLZXl3b3JkQnlTdHJpbmcoJHRwX2lkZW50X2Nhbm9uKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0T25seUtleXdvcmRCeUVudW0oJHRwX2lkZW50X3R5cGUpIHtcbnN3aXRjaCAoJHRwX2lkZW50X3R5cGUpIHtcbmNhc2UgMjA4ODpcblxuY2FzZSAyMDcyOlxuXG5jYXNlIDIwOTg6XG5cbmNhc2UgMjEwMjpcblxuY2FzZSAyMTAzOlxuXG5jYXNlIDIxMDc6XG5cbmNhc2UgMjEwODpcblxuY2FzZSAyMTA5OlxuXG5jYXNlIDIxMTA6XG5cbmNhc2UgMjExMzpcblxuY2FzZSAyMTI2OlxucmV0dXJuIHRydWU7XG59XG5yZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1N0cmljdE9ubHlLZXl3b3JkQnlTdHJpbmcoJHRwX2lkZW50X2Nhbm9uKSB7XG5zd2l0Y2ggKCR0cF9pZGVudF9jYW5vbikge1xuY2FzZSAnZXZhbCc6XG5cbmNhc2UgJ2FyZ3VtZW50cyc6XG5cbmNhc2UgJ2ltcGxlbWVudHMnOlxuXG5jYXNlICdpbnRlcmZhY2UnOlxuXG5jYXNlICdsZXQnOlxuXG5jYXNlICdwYWNrYWdlJzpcblxuY2FzZSAncHJpdmF0ZSc6XG5cbmNhc2UgJ3Byb3RlY3RlZCc6XG5cbmNhc2UgJ3B1YmxpYyc6XG5cbmNhc2UgJ3N0YXRpYyc6XG5cbmNhc2UgJ3lpZWxkJzpcbnJldHVybiB0cnVlO1xufVxucmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF9maXJzdEV4cHJfc3RhcnQsICR0cF9maXJzdEV4cHJfc3RvcCwgJHRwX2ZpcnN0RXhwcl9saW5lLCAkdHBfZmlyc3RFeHByX2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCkge1xuaWYgKGlzQW55QXNzaWdubWVudE9wKCkpIHtcbmlmIChub3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdDYW5ub3QgYXNzaWduIHRvIGxocyAoc3RhcnRpbmcgd2l0aCBgJyArIHRva19zbGljZUlucHV0KCR0cF9maXJzdEV4cHJfc3RhcnQsICR0cF9maXJzdEV4cHJfc3RvcCkpICsgJ2ApIGJlY2F1c2UgaXQgaXMgbm90IGEgdmFsaWQgYXNzaWdubWVudCB0YXJnZXQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gcGFyc2VFeHByZXNzaW9uRnJvbUFzc2lnbm1lbnRPcChsZXhlckZsYWdzLCAkdHBfZmlyc3RFeHByX3N0YXJ0LCAkdHBfZmlyc3RFeHByX2xpbmUsICR0cF9maXJzdEV4cHJfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbnJldHVybiBwYXJzZUV4cHJlc3Npb25Gcm9tQmluYXJ5T3AobGV4ZXJGbGFncywgJHRwX2ZpcnN0RXhwcl9zdGFydCwgJHRwX2ZpcnN0RXhwcl9saW5lLCAkdHBfZmlyc3RFeHByX2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25Gcm9tQXNzaWdubWVudE9wKGxleGVyRmxhZ3MsICR0cF9maXJzdEFzc2lnbm1lbnRfc3RhcnQsICR0cF9maXJzdEFzc2lnbm1lbnRfbGluZSwgJHRwX2ZpcnN0QXNzaWdubWVudF9jb2x1bW4sIGxoc0Fzc2lnbmFibGUsIGFzdFByb3ApIHtcbmxldCAkdHBfZXFfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5BU1RfY29udmVydEFycmF5VG9QYXR0ZXJuKCR0cF9lcV90eXBlLCBhc3RQcm9wKTtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOidBc3NpZ25tZW50RXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIGxlZnQ6dW5kZWZpbmVkLCBvcGVyYXRvcjp0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSksIHJpZ2h0OnVuZGVmaW5lZH0sICdsZWZ0Jyk7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5sZXQgcmhzQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCAncmlnaHQnKTtcbkFTVF9jbG9zZSgkdHBfZmlyc3RBc3NpZ25tZW50X3N0YXJ0LCAkdHBfZmlyc3RBc3NpZ25tZW50X2xpbmUsICR0cF9maXJzdEFzc2lnbm1lbnRfY29sdW1uKTtcbnJldHVybiBzZXROb3RBc3NpZ25hYmxlKG1lcmdlQXNzaWduYWJsZShyaHNBc3NpZ25hYmxlLCBsaHNBc3NpZ25hYmxlKSk7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25Gcm9tQmluYXJ5T3AobGV4ZXJGbGFncywgJHRwX2ZpcnN0RXhwcl9zdGFydCwgJHRwX2ZpcnN0RXhwcl9saW5lLCAkdHBfZmlyc3RFeHByX2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCkge1xuaWYgKChhc3NpZ25hYmxlICYgMTAyNCkgPT09IDEwMjQpIHJldHVybiBhc3NpZ25hYmxlO1xubGV0ICR0cF9uZXh0X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0IHJlcGVhdCA9IGZhbHNlO1xuZG8ge1xucmVwZWF0ID0gZmFsc2U7XG5pZiAoJHRwX25leHRfdHlwZSA9PT0gMTY1MDYpIHtcbmxldCBub3dBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uRnJvbVRlcm5hcnlPcChsZXhlckZsYWdzLCAkdHBfZmlyc3RFeHByX3N0YXJ0LCAkdHBfZmlyc3RFeHByX2xpbmUsICR0cF9maXJzdEV4cHJfY29sdW1uLCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBzZXROb3RBc3NpZ25hYmxlKG5vd0Fzc2lnbmFibGUgfCBhc3NpZ25hYmxlKTtcbnJlcGVhdCA9IHRydWU7XG59IGVsc2UgaWYgKGlzTm9uQXNzaWduQmluT3AoJHRwX25leHRfdHlwZSwgbGV4ZXJGbGFncykpIHtcbmxldCBub3dBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uRnJvbUJpbmFyeU9wT25seVN0cm9uZ2VyKGxleGVyRmxhZ3MsICR0cF9maXJzdEV4cHJfc3RhcnQsICR0cF9maXJzdEV4cHJfbGluZSwgJHRwX2ZpcnN0RXhwcl9jb2x1bW4sIDAsIGFzdFByb3ApO1xuYXNzaWduYWJsZSA9IHNldE5vdEFzc2lnbmFibGUobm93QXNzaWduYWJsZSB8IGFzc2lnbmFibGUpO1xucmVwZWF0ID0gdHJ1ZTtcbn1cbiR0cF9uZXh0X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xufSB3aGlsZSAocmVwZWF0KTtcbmlmIChpc0FueUFzc2lnbm1lbnRPcCgpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBub3QgaGF2ZSBhbiBhc3NpZ25tZW50IGFmdGVyIGEgbm9uLWFzc2lnbm1lbnQgb3BlcmF0b3InLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmZ1bmN0aW9uIHByZXZlbnROdWxsaXNoV2l0aExvZ2ljKCR0cF9vcF90eXBlLCAkdHBfb3Bfc3RhcnQsICR0cF9vcF9zdG9wLCBjb2FsU2Vlbikge1xuaWYgKCgoJHRwX29wX3R5cGUgPT09IDgyMDA1KSB8fCAoJHRwX29wX3R5cGUgPT09IDgyMDUxKSkpIHtcbmlmIChjb2FsU2VlbiA9PT0gMSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGA/P2AgYW5kIGAmJmAvYHx8YCBpbiB0aGUgc2FtZSBleHByZXNzaW9uIHdpdGhvdXQgc29tZSBncm91cGluZycsICR0cF9vcF9zdGFydCwgJHRwX29wX3N0b3ApO1xufVxucmV0dXJuIDI7XG59XG5pZiAoJHRwX29wX3R5cGUgPT09IDgyMDQ0KSB7XG5pZiAoY29hbFNlZW4gPT09IDIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2Fubm90IHVzZSBgPz9gIGFuZCBgJiZgL2B8fGAgaW4gdGhlIHNhbWUgZXhwcmVzc2lvbiB3aXRob3V0IHNvbWUgZ3JvdXBpbmcnLCAkdHBfb3Bfc3RhcnQsICR0cF9vcF9zdG9wKTtcbn1cbnJldHVybiAxO1xufVxucmV0dXJuIGNvYWxTZWVuO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uRnJvbUJpbmFyeU9wT25seVN0cm9uZ2VyKGxleGVyRmxhZ3MsICR0cF9maXJzdEV4cHJfc3RhcnQsICR0cF9maXJzdEV4cHJfbGluZSwgJHRwX2ZpcnN0RXhwcl9jb2x1bW4sIGNvYWxTZWVuLCBhc3RQcm9wKSB7XG5sZXQgJHRwX29wX3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9vcF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9vcF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmNvYWxTZWVuID0gcHJldmVudE51bGxpc2hXaXRoTG9naWMoJHRwX29wX3R5cGUsICR0cF9vcF9zdGFydCwgJHRwX29wX3N0b3AsIGNvYWxTZWVuKTtcbmxldCBBU1Rfbm9kZU5hbWUgPSAoKCgoKCgkdHBfb3BfdHlwZSA9PT0gODIwMDUpIHx8ICgkdHBfb3BfdHlwZSA9PT0gODIwNTEpKSkgfHwgKCR0cF9vcF90eXBlID09PSA4MjA0NCkpKT8gJ0xvZ2ljYWxFeHByZXNzaW9uJyA6ICdCaW5hcnlFeHByZXNzaW9uJyk7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTpBU1Rfbm9kZU5hbWUsIGxvYzp1bmRlZmluZWQsIGxlZnQ6dW5kZWZpbmVkLCBvcGVyYXRvcjp0b2tfc2xpY2VJbnB1dCgkdHBfb3Bfc3RhcnQsICR0cF9vcF9zdG9wKSwgcmlnaHQ6dW5kZWZpbmVkfSwgJ2xlZnQnKTtcbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbmxldCAkdHBfcmlnaHRFeHByU3RhcnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3JpZ2h0RXhwclN0YXJ0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfcmlnaHRFeHByU3RhcnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCBhc3NpZ25hYmxlID0gcGFyc2VWYWx1ZShsZXhlckZsYWdzLCBmYWxzZSwgNCwgZmFsc2UsICdyaWdodCcpO1xubGV0IG90aGVyU3RyZW5ndGggPSBnZXRTdHJlbmd0aCgkdHBfb3BfdHlwZSwgJHRwX29wX3N0YXJ0LCAkdHBfb3Bfc3RvcCk7XG53aGlsZSAoY29udGludWVQYXJzaW5nQmluT3AobGV4ZXJGbGFncywgb3RoZXJTdHJlbmd0aCkpIHtcbmFzc2lnbmFibGUgfD0gcGFyc2VFeHByZXNzaW9uRnJvbUJpbmFyeU9wT25seVN0cm9uZ2VyKGxleGVyRmxhZ3MsICR0cF9yaWdodEV4cHJTdGFydF9zdGFydCwgJHRwX3JpZ2h0RXhwclN0YXJ0X2xpbmUsICR0cF9yaWdodEV4cHJTdGFydF9jb2x1bW4sIGNvYWxTZWVuLCAncmlnaHQnKTtcbn1cbnByZXZlbnROdWxsaXNoV2l0aExvZ2ljKHRva19nZXRUeXBlKCksIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpLCBjb2FsU2Vlbik7XG5BU1RfY2xvc2UoJHRwX2ZpcnN0RXhwcl9zdGFydCwgJHRwX2ZpcnN0RXhwcl9saW5lLCAkdHBfZmlyc3RFeHByX2NvbHVtbik7XG5yZXR1cm4gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkZyb21UZXJuYXJ5T3AobGV4ZXJGbGFncywgJHRwX2ZpcnN0RXhwcl9zdGFydCwgJHRwX2ZpcnN0RXhwcl9saW5lLCAkdHBfZmlyc3RFeHByX2NvbHVtbiwgYXN0UHJvcCkge1xuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIHRlc3Q6dW5kZWZpbmVkLCBjb25zZXF1ZW50OnVuZGVmaW5lZCwgYWx0ZXJuYXRlOnVuZGVmaW5lZH0sICd0ZXN0Jyk7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5sZXQgbWlkQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbigoKGxleGVyRmxhZ3MgfCAzMikgXiAzMikgfCA0MDk2LCAnY29uc2VxdWVudCcpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDg5KSB7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2FuIG5vdCB1c2UgY29tbWEgaW5zaWRlIHRlcm5hcnkgZXhwcmVzc2lvbnMnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIGluc2lkZSB0ZXJuYXJ5JywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xubGV0IHJoc0Fzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJ2FsdGVybmF0ZScpO1xuQVNUX2Nsb3NlKCR0cF9maXJzdEV4cHJfc3RhcnQsICR0cF9maXJzdEV4cHJfbGluZSwgJHRwX2ZpcnN0RXhwcl9jb2x1bW4pO1xucmV0dXJuIHNldE5vdEFzc2lnbmFibGUobWlkQXNzaWduYWJsZSB8IHJoc0Fzc2lnbmFibGUpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uc0FmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGFzdFByb3ApIHtcbmxldCBhc3NpZ25hYmxlRm9yUGlnZ2llcyA9IHBhcnNlRXhwcmVzc2lvbkFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIDAsIGFzdFByb3ApO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5hc3NpZ25hYmxlRm9yUGlnZ2llcyA9IF9wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sIGFzc2lnbmFibGVGb3JQaWdnaWVzLCBhc3RQcm9wKTtcbn1cbnJldHVybiBhc3NpZ25hYmxlRm9yUGlnZ2llcztcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9zdGFydE9mRmlyc3RFeHByX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zdGFydE9mRmlyc3RFeHByX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfc3RhcnRPZkZpcnN0RXhwcl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0IGFzc2lnbmFibGVGb3JQaWdnaWVzID0gcGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsIGFzdFByb3ApO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5hc3NpZ25hYmxlRm9yUGlnZ2llcyA9IF9wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICR0cF9zdGFydE9mRmlyc3RFeHByX3N0YXJ0LCAkdHBfc3RhcnRPZkZpcnN0RXhwcl9saW5lLCAkdHBfc3RhcnRPZkZpcnN0RXhwcl9jb2x1bW4sIGFzc2lnbmFibGVGb3JQaWdnaWVzLCBhc3RQcm9wKTtcbn1cbnJldHVybiBhc3NpZ25hYmxlRm9yUGlnZ2llcztcbn1cbmZ1bmN0aW9uIF9wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICR0cF9zdGFydE9mRmlyc3RFeHByX3N0YXJ0LCAkdHBfc3RhcnRPZkZpcnN0RXhwcl9saW5lLCAkdHBfc3RhcnRPZkZpcnN0RXhwcl9jb2x1biwgYXNzaWduYWJsZUZvclBpZ2dpZXMsIGFzdFByb3ApIHtcbkFTVF93cmFwQ2xvc2VkSW50b0FycmF5Q3VzdG9tKGFzdFByb3AsIHt0eXBlOidTZXF1ZW5jZUV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBleHByZXNzaW9uczp1bmRlZmluZWR9LCAnZXhwcmVzc2lvbnMnKTtcbmFzc2lnbmFibGVGb3JQaWdnaWVzID0gX19wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsIGFzc2lnbmFibGVGb3JQaWdnaWVzLCAnZXhwcmVzc2lvbnMnKTtcbkFTVF9jbG9zZSgkdHBfc3RhcnRPZkZpcnN0RXhwcl9zdGFydCwgJHRwX3N0YXJ0T2ZGaXJzdEV4cHJfbGluZSwgJHRwX3N0YXJ0T2ZGaXJzdEV4cHJfY29sdW4pO1xucmV0dXJuIGFzc2lnbmFibGVGb3JQaWdnaWVzO1xufVxuZnVuY3Rpb24gX19wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsIGFzc2lnbmFibGVGb3JQaWdnaWVzLCBhc3RQcm9wKSB7XG5kbyB7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5sZXQgbm93QXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCBhc3RQcm9wKTtcbmFzc2lnbmFibGVGb3JQaWdnaWVzIHw9IG5vd0Fzc2lnbmFibGU7XG59IHdoaWxlICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCk7XG5yZXR1cm4gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlRm9yUGlnZ2llcyk7XG59XG5mdW5jdGlvbiBpc0FueUFzc2lnbm1lbnRPcCgpIHtcbmlmICghKCh0b2tfZ2V0VHlwZSgpICYgMzI3NjgpID09PSAzMjc2OCkpIHJldHVybiBmYWxzZTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSA0OTI0NCkgcmV0dXJuIHRydWU7XG5pZiAoIWFsbG93RXhwb25lbnRpYXRpb24pIHtcbnJldHVybiBUSFJPV19SQU5HRSgnYCoqYCB3YXMgaW50cm9kdWNlZCBpbiBFUzcnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzTm9uQXNzaWduQmluT3AodHlwZSwgbGV4ZXJGbGFncykge1xuaWYgKCEoKHR5cGUgJiA2NTUzNikgPT09IDY1NTM2KSkgcmV0dXJuIGZhbHNlO1xuaWYgKHR5cGUgPT09IDgyMDEwKSB7XG5pZiAoIWFsbG93RXhwb25lbnRpYXRpb24pIHtcbnJldHVybiBUSFJPV19SQU5HRSgnYCoqYCB3YXMgaW50cm9kdWNlZCBpbiBFUzcnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gdHJ1ZTtcbn1cbmlmICh0eXBlID09PSA2NzYzNikge1xucmV0dXJuIChsZXhlckZsYWdzICYgMzIpID09PSAwO1xufVxucmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRTdHJlbmd0aCh0eXBlLCAkdHBfdG9rZW5TdGFydCwgJHRwX3Rva2VuU3RvcCkge1xuc3dpdGNoICh0eXBlKSB7XG5jYXNlIDgyMDEwOlxucmV0dXJuIDE2O1xuY2FzZSA4MjAwOTpcbnJldHVybiAxNTtcbmNhc2UgODIwMjM6XG5yZXR1cm4gMTU7XG5jYXNlIDgyMDAyOlxucmV0dXJuIDE1O1xuY2FzZSA4MjAxMzpcbnJldHVybiAxNDtcbmNhc2UgODIwMTc6XG5yZXR1cm4gMTQ7XG5jYXNlIDgyMDI4OlxucmV0dXJuIDEzO1xuY2FzZSA4MjAzNzpcbnJldHVybiAxMztcbmNhc2UgODIwMzg6XG5yZXR1cm4gMTM7XG5jYXNlIDgyMDI3OlxucmV0dXJuIDEyO1xuY2FzZSA4MjAyOTpcbnJldHVybiAxMjtcbmNhc2UgODIwMzY6XG5yZXR1cm4gMTI7XG5jYXNlIDgyMDM5OlxucmV0dXJuIDEyO1xuY2FzZSA2NzYzNjpcbnJldHVybiAxMjtcbmNhc2UgNjc2Mzc6XG5yZXR1cm4gMTI7XG5jYXNlIDgyMDMzOlxucmV0dXJuIDExO1xuY2FzZSA4MjAwMDpcbnJldHVybiAxMTtcbmNhc2UgODIwMzQ6XG5yZXR1cm4gMTE7XG5jYXNlIDgyMDAxOlxucmV0dXJuIDExO1xuY2FzZSA4MjAwNDpcbnJldHVybiAxMDtcbmNhc2UgODIwNDc6XG5yZXR1cm4gOTtcbmNhc2UgODIwNTA6XG5yZXR1cm4gODtcbmNhc2UgODIwNDQ6XG5yZXR1cm4gNztcbmNhc2UgODIwMDU6XG5yZXR1cm4gNjtcbmNhc2UgODIwNTE6XG5yZXR1cm4gNTtcbn1cblRIUk9XX1JBTkdFKCdVbmtub3duIG9wZXJhdG9yJywgJHRwX3Rva2VuU3RhcnQsICR0cF90b2tlblN0b3ApO1xufVxuZnVuY3Rpb24gY29udGludWVQYXJzaW5nQmluT3AobGV4ZXJGbGFncywgb3RoZXJTdHJlbmd0aCkge1xuc3dpdGNoICh0b2tfZ2V0VHlwZSgpKSB7XG5jYXNlIDgyMDMzOlxucmV0dXJuIDExID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMDA6XG5yZXR1cm4gMTEgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjAzNDpcbnJldHVybiAxMSA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDAxOlxucmV0dXJuIDExID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMDU6XG5yZXR1cm4gNiA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDUxOlxucmV0dXJuIDUgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjAxMzpcbnJldHVybiAxNCA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDE3OlxucmV0dXJuIDE0ID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMjc6XG5yZXR1cm4gMTIgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjAzNjpcbnJldHVybiAxMiA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDI5OlxucmV0dXJuIDEyID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMzk6XG5yZXR1cm4gMTIgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjAwOTpcbnJldHVybiAxNSA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDIzOlxucmV0dXJuIDE1ID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMDI6XG5yZXR1cm4gMTUgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjAyODpcbnJldHVybiAxMyA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDM3OlxucmV0dXJuIDEzID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMzg6XG5yZXR1cm4gMTMgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA2NzYzNjpcbmlmICgobGV4ZXJGbGFncyAmIDMyKSA9PT0gMzIpIHtcbnJldHVybiBmYWxzZTtcbn1cbnJldHVybiAxMiA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDY3NjM3OlxucmV0dXJuIDEyID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwMDQ6XG5yZXR1cm4gMTAgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjA0NzpcbnJldHVybiA5ID4gb3RoZXJTdHJlbmd0aDtcbmNhc2UgODIwNTA6XG5yZXR1cm4gOCA+IG90aGVyU3RyZW5ndGg7XG5jYXNlIDgyMDQ0OlxucmV0dXJuIDcgPiBvdGhlclN0cmVuZ3RoO1xuY2FzZSA4MjAxMDpcbmlmICghYWxsb3dFeHBvbmVudGlhdGlvbikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdgKipgIHdhcyBpbnRyb2R1Y2VkIGluIEVTNycsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiB0cnVlO1xufVxucmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShsZXhlckZsYWdzLCBhbGxvd0Fzc2lnbm1lbnQsIGlzTmV3QXJnLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3N0YXJ0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zdGFydF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3N0YXJ0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlVmFsdWVIZWFkQm9keShsZXhlckZsYWdzLCBmYWxzZSwgaXNOZXdBcmcsIGFsbG93QXNzaWdubWVudCwgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgYXN0UHJvcCk7XG5yZXR1cm4gcGFyc2VWYWx1ZVRhaWwobGV4ZXJGbGFncywgJHRwX3N0YXJ0X3N0YXJ0LCAkdHBfc3RhcnRfbGluZSwgJHRwX3N0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgaXNOZXdBcmcsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24sIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZUFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApIHtcbmxldCBhc3NpZ25hYmxlID0gcGFyc2VWYWx1ZUhlYWRCb2R5QWZ0ZXJJZGVudChsZXhlckZsYWdzLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIDQsIGFsbG93QXNzaWdubWVudCwgZmFsc2UsIGFzdFByb3ApO1xucmV0dXJuIHBhcnNlVmFsdWVUYWlsKGxleGVyRmxhZ3MsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sIGFzc2lnbmFibGUsIDQsIGZhbHNlLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVIZWFkQm9keShsZXhlckZsYWdzLCBtYXliZSwgaXNOZXdBcmcsIGFsbG93QXNzaWdubWVudCwgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgYXN0UHJvcCkge1xubGV0IHN0YXJ0X2Zvcl9hc3NlcnQ7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5yZXR1cm4gcGFyc2VWYWx1ZUhlYWRCb2R5SWRlbnQobGV4ZXJGbGFncywgaXNOZXdBcmcsIDAsIGFsbG93QXNzaWdubWVudCwgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgYXN0UHJvcCk7XG59XG5pZiAoaXNOdW1iZXJTdHJpbmdSZWdleCh0b2tfZ2V0VHlwZSgpKSkge1xubGV0ICR0cF9saXRfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2xpdF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfbGl0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfbGl0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2xpdF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfbGl0X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwRGl2KGxleGVyRmxhZ3MpO1xuQVNUX3NldExpdGVyYWwoYXN0UHJvcCwgJHRwX2xpdF90eXBlLCAkdHBfbGl0X3N0YXJ0LCAkdHBfbGl0X3N0b3AsICR0cF9saXRfbGluZSwgJHRwX2xpdF9jb2x1bW4sICR0cF9saXRfY2Fub24pO1xucmV0dXJuIDE2O1xufVxuaWYgKGlzVGVtcGxhdGVTdGFydCh0b2tfZ2V0VHlwZSgpKSkge1xubGV0ICR0cF90aWNrX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF90aWNrX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfdGlja19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF90aWNrX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xucGFyc2VUaWNrRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfdGlja19zdGFydCwgJHRwX3RpY2tfc3RvcCwgJHRwX3RpY2tfbGluZSwgJHRwX3RpY2tfY29sdW1uLCBhc3RQcm9wKTtcbnJldHVybiAxNjtcbn1cbmlmIChpc1B1bmN0dWF0b3JUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NTEzKSB7XG5sZXQgc2tpcEluaXQgPSAoKCgoKChhbGxvd0Fzc2lnbm1lbnQgPT09IHRydWUpICYmIChsZWZ0SGFuZFNpZGVFeHByZXNzaW9uID09PSBmYWxzZSkpKSAmJiAoaXNOZXdBcmcgPT09IDQpKSk/IHRydWUgOiBmYWxzZSk7XG5sZXQgd2FzRGVzdHJ1Y3QgPSBwYXJzZU9iamVjdE91dGVyKGxleGVyRmxhZ3MsIG51bGwsIDAsIHNraXBJbml0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXN0UHJvcCk7XG5yZXR1cm4gX3BhcnNlVmFsdWVIZWFkQm9keUFmdGVyT2JqQXJyKHdhc0Rlc3RydWN0KTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwOSkge1xubGV0IHNraXBJbml0ID0gKCgoKCgoYWxsb3dBc3NpZ25tZW50ID09PSB0cnVlKSAmJiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gZmFsc2UpKSkgJiYgKGlzTmV3QXJnID09PSA0KSkpPyB0cnVlIDogZmFsc2UpO1xubGV0IHdhc0Rlc3RydWN0ID0gcGFyc2VBcnJheU91dGVyKGxleGVyRmxhZ3MsIG51bGwsIDAsIHNraXBJbml0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXN0UHJvcCk7XG5yZXR1cm4gX3BhcnNlVmFsdWVIZWFkQm9keUFmdGVyT2JqQXJyKHdhc0Rlc3RydWN0KTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ3MSkge1xucmV0dXJuIHBhcnNlR3JvdXBUb3BsZXZlbHMobGV4ZXJGbGFncywgMiwgYWxsb3dBc3NpZ25tZW50LCAwLCAwLCAwLCAwLCAwLCAnJywgZmFsc2UsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24sIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDc4KSB7XG5yZXR1cm4gcGFyc2VVcGRhdGVQcmVmaXgobGV4ZXJGbGFncywgaXNOZXdBcmcsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24sICcrKycsIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgyKSB7XG5yZXR1cm4gcGFyc2VVcGRhdGVQcmVmaXgobGV4ZXJGbGFncywgaXNOZXdBcmcsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24sICctLScsIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDEzKSB7XG5yZXR1cm4gcGFyc2VVbmFyeShsZXhlckZsYWdzLCBpc05ld0FyZywgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgJysnLCBhc3RQcm9wKTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSA4MjAxNykge1xucmV0dXJuIHBhcnNlVW5hcnkobGV4ZXJGbGFncywgaXNOZXdBcmcsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24sICctJywgYXN0UHJvcCk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0NjMpIHtcbnJldHVybiBwYXJzZVVuYXJ5KGxleGVyRmxhZ3MsIGlzTmV3QXJnLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCAnIScsIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NTE4KSB7XG5yZXR1cm4gcGFyc2VVbmFyeShsZXhlckZsYWdzLCBpc05ld0FyZywgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgJ34nLCBhc3RQcm9wKTtcbn1cbn1cbmlmIChtYXliZSA9PT0gZmFsc2UpIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4Nikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdVbmV4cGVjdGVkIHNwcmVhZC9yZXN0IGRvdHMnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0YXJ0KCkgKyAxKTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4NSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdVbmV4cGVjdGVkIGRvdCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgnRXhwZWN0ZWQgdG8gcGFyc2UgYSB2YWx1ZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiAxNjtcbn1cbmZ1bmN0aW9uIF9wYXJzZVZhbHVlSGVhZEJvZHlBZnRlck9iakFycih3YXNEZXN0cnVjdCkge1xuaWYgKCh3YXNEZXN0cnVjdCAmIDQpID09PSA0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0ZvdW5kIGEgc3RydWN0IHRoYXQgbXVzdCBiZSBkZXN0cnVjdHVyZWQgYnV0IHdhcyBub3QnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5sZXQgYXNzaWduYWJsZSA9IGNvcHlQaWdnaWVzKDAsIHdhc0Rlc3RydWN0KTtcbmlmICgod2FzRGVzdHJ1Y3QgJiAxKSA9PT0gMCkge1xucmV0dXJuIHNldEFzc2lnbmFibGUoYXNzaWduYWJsZSk7XG59XG5yZXR1cm4gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVIZWFkQm9keUlkZW50KGxleGVyRmxhZ3MsIGlzTmV3QXJnLCBiaW5kaW5nVHlwZSwgYWxsb3dBc3NpZ25tZW50LCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBJZGVudFNhZmVTbG93QW5kRXhwZW5zaXZlKGxleGVyRmxhZ3MsIGxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xucmV0dXJuIHBhcnNlVmFsdWVIZWFkQm9keUFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCBpc05ld0FyZywgYWxsb3dBc3NpZ25tZW50LCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVIZWFkQm9keUFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCBpc05ld0FyZywgYWxsb3dBc3NpZ25tZW50LCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKSB7XG5zd2l0Y2ggKCR0cF9pZGVudF90eXBlKSB7XG5jYXNlIDIwNzI6XG57XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0OTkpIHtcbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBub3QgdXNlIGBhcmd1bWVudHNgIGFzIGFyZyBuYW1lIGluIHN0cmljdCBtb2RlJywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCk7XG59XG5yZXR1cm4gcGFyc2VBcnJvd1BhcmVubGVzc0Zyb21QdW5jKGxleGVyRmxhZ3MsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCB0cnVlLCAzLCAwLCBhc3RQcm9wKTtcbn1cbkFTVF9zZXRJZGVudChhc3RQcm9wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKTtcbnJldHVybiB2ZXJpZnlFdmFsQXJndW1lbnRzVmFyKGxleGVyRmxhZ3MpO1xufVxuY2FzZSAyMDc0OlxucmV0dXJuIHBhcnNlQXN5bmNFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGlzTmV3QXJnLCBmYWxzZSwgYWxsb3dBc3NpZ25tZW50LCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBhc3RQcm9wKTtcbmNhc2UgMjA3NTpcbnJldHVybiBwYXJzZUF3YWl0KGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBpc05ld0FyZywgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKTtcbmNhc2UgMjA3OTpcbnJldHVybiBwYXJzZUNsYXNzRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCBhc3RQcm9wKTtcbmNhc2UgMjA4NDpcbjtcbnJldHVybiBfcGFyc2VVbmFyeShsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJ2RlbGV0ZScsIGlzTmV3QXJnLCBhc3RQcm9wKTtcbmNhc2UgMjA4ODpcbntcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5OSkge1xuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2FuIG5vdCB1c2UgYGV2YWxgIGFzIGFyZyBuYW1lIGluIHN0cmljdCBtb2RlJywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCk7XG59XG5yZXR1cm4gcGFyc2VBcnJvd1BhcmVubGVzc0Zyb21QdW5jKGxleGVyRmxhZ3MsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCB0cnVlLCAzLCAwLCBhc3RQcm9wKTtcbn1cbkFTVF9zZXRJZGVudChhc3RQcm9wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKTtcbnJldHVybiB2ZXJpZnlFdmFsQXJndW1lbnRzVmFyKGxleGVyRmxhZ3MpO1xufVxuY2FzZSAyMDkxOlxucmV0dXJuIHBhcnNlRmFsc2VLZXl3b3JkKCR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sIGFzdFByb3ApO1xuY2FzZSAyMDk1OlxucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgYXN0UHJvcCk7XG5yZXR1cm4gMTY7XG5jYXNlIDIwOTk6XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0NzEpIHtcbnJldHVybiBwYXJzZUR5bmFtaWNJbXBvcnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sIGFzdFByb3ApO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdJbXBvcnQga2V5d29yZCBvbmx5IGFsbG93ZWQgb24gdG9wbGV2ZWwgb3IgaW4gYSBkeW5hbWljIGltcG9ydCcsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3ApO1xuY2FzZSAyMTAzOlxuO1xuaWYgKCgoYmluZGluZ1R5cGUgPT09IDYpIHx8IChiaW5kaW5nVHlwZSA9PT0gNykpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBub3QgdXNlIGBsZXRgIHdoZW4gYmluZGluZyB0aHJvdWdoIGBsZXRgIG9yIGBjb25zdGAnLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKTtcbn1cbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBub3QgdXNlIGBsZXRgIGFzIHZhcmlhYmxlIG5hbWUgaW4gc3RyaWN0IG1vZGUnLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKTtcbn1cbnJldHVybiBwYXJzZUlkZW50T3JQYXJlbmxlc3NBcnJvdyhsZXhlckZsYWdzLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgMzIsIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCk7XG5jYXNlIDIxMDQ6XG5sZXQgbmV3QXNzaWduYWJsZSA9IHBhcnNlTmV3S2V5d29yZChsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBhc3RQcm9wKTtcbnJldHVybiBzZXROb3RBc3NpZ25hYmxlKG5ld0Fzc2lnbmFibGUpO1xuY2FzZSAyMTA1OlxucmV0dXJuIHBhcnNlTnVsbEtleXdvcmQoJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgYXN0UHJvcCk7XG5jYXNlIDIxMTQ6XG5yZXR1cm4gcGFyc2VTdXBlcktleXdvcmQobGV4ZXJGbGFncywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sIGFzdFByb3ApO1xuY2FzZSAyMTE5OlxucmV0dXJuIHBhcnNlVHJ1ZUtleXdvcmQoJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgYXN0UHJvcCk7XG5jYXNlIDIxMTc6XG5yZXR1cm4gcGFyc2VUaGlzS2V5d29yZCgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCBhc3RQcm9wKTtcbmNhc2UgMjEyMTpcbjtcbnJldHVybiBfcGFyc2VVbmFyeShsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJ3R5cGVvZicsIGlzTmV3QXJnLCBhc3RQcm9wKTtcbmNhc2UgMjEyMzpcbjtcbnJldHVybiBfcGFyc2VVbmFyeShsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJ3ZvaWQnLCBpc05ld0FyZywgYXN0UHJvcCk7XG5jYXNlIDIxMjY6XG5yZXR1cm4gcGFyc2VZaWVsZChsZXhlckZsYWdzLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKTtcbn1cbmZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGxleGVyRmxhZ3MpO1xucmV0dXJuIHBhcnNlSWRlbnRPclBhcmVubGVzc0Fycm93KGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCAzMiwgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUV2YWxBcmd1bWVudHNWYXIobGV4ZXJGbGFncykge1xuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDApIHJldHVybiAzMjtcbmlmIChpc0FueUFzc2lnbm1lbnRPcCgpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBhc3NpZ24gdG8gYGV2YWxgIGFuZCBgYXJndW1lbnRzYCBpbiBzdHJpY3QgbW9kZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICgoKHRva19nZXRUeXBlKCkgPT09IDE2NDc4KSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODIpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgYXNzaWduIHRvIGBldmFsYCBhbmQgYGFyZ3VtZW50c2AgaW4gc3RyaWN0IG1vZGUnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gMTY7XG59XG5mdW5jdGlvbiBwYXJzZVRydWVLZXl3b3JkKCR0cF90cnVlX3N0YXJ0LCAkdHBfdHJ1ZV9saW5lLCAkdHBfdHJ1ZV9jb2x1bW4sIGFzdFByb3ApIHtcbmlmIChiYWJlbENvbXBhdCkge1xuQVNUX3NldE5vZGUoYXN0UHJvcCwge3R5cGU6J0Jvb2xlYW5MaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX3RydWVfc3RhcnQsICR0cF90cnVlX2xpbmUsICR0cF90cnVlX2NvbHVtbiksIHZhbHVlOnRydWV9KTtcbn0gZWxzZSB7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonTGl0ZXJhbCcsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF90cnVlX3N0YXJ0LCAkdHBfdHJ1ZV9saW5lLCAkdHBfdHJ1ZV9jb2x1bW4pLCB2YWx1ZTp0cnVlLCByYXc6J3RydWUnfSk7XG59XG5yZXR1cm4gMTY7XG59XG5mdW5jdGlvbiBwYXJzZUZhbHNlS2V5d29yZCgkdHBfZmFsc2Vfc3RhcnQsICR0cF9mYWxzZV9saW5lLCAkdHBfZmFsc2VfY29sdW1uLCBhc3RQcm9wKSB7XG5pZiAoYmFiZWxDb21wYXQpIHtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidCb29sZWFuTGl0ZXJhbCcsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9mYWxzZV9zdGFydCwgJHRwX2ZhbHNlX2xpbmUsICR0cF9mYWxzZV9jb2x1bW4pLCB2YWx1ZTpmYWxzZX0pO1xufSBlbHNlIHtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidMaXRlcmFsJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX2ZhbHNlX3N0YXJ0LCAkdHBfZmFsc2VfbGluZSwgJHRwX2ZhbHNlX2NvbHVtbiksIHZhbHVlOmZhbHNlLCByYXc6J2ZhbHNlJ30pO1xufVxucmV0dXJuIDE2O1xufVxuZnVuY3Rpb24gcGFyc2VOdWxsS2V5d29yZCgkdHBfbnVsbF9zdGFydCwgJHRwX251bGxfbGluZSwgJHRwX251bGxfY29sdW1uLCBhc3RQcm9wKSB7XG5pZiAoYmFiZWxDb21wYXQpIHtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidOdWxsTGl0ZXJhbCcsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9udWxsX3N0YXJ0LCAkdHBfbnVsbF9saW5lLCAkdHBfbnVsbF9jb2x1bW4pfSk7XG59IGVsc2Uge1xuQVNUX3NldE5vZGUoYXN0UHJvcCwge3R5cGU6J0xpdGVyYWwnLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfbnVsbF9zdGFydCwgJHRwX251bGxfbGluZSwgJHRwX251bGxfY29sdW1uKSwgdmFsdWU6bnVsbCwgcmF3OidudWxsJ30pO1xufVxucmV0dXJuIDE2O1xufVxuZnVuY3Rpb24gcGFyc2VTdXBlcktleXdvcmQobGV4ZXJGbGFncywgJHRwX3N1cGVyX3N0YXJ0LCAkdHBfc3VwZXJfc3RvcCwgJHRwX3N1cGVyX2xpbmUsICR0cF9zdXBlcl9jb2x1bW4sIGFzdFByb3ApIHtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidTdXBlcicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9zdXBlcl9zdGFydCwgJHRwX3N1cGVyX2xpbmUsICR0cF9zdXBlcl9jb2x1bW4pfSk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0NzEpIHtcbmlmICgobGV4ZXJGbGFncyAmIDE2Mzg0KSA9PT0gMCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW4gb25seSB1c2UgYHN1cGVyKClgIGluIGNvbnN0cnVjdG9ycyBvZiBjbGFzc2VzIHRoYXQgZXh0ZW5kIGFub3RoZXIgY2xhc3MnLCAkdHBfc3VwZXJfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIDE2O1xufVxuaWYgKCgodG9rX2dldFR5cGUoKSA9PT0gMTY1MDkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4NSkpKSB7XG5pZiAoKGxleGVyRmxhZ3MgJiAzMjc2OCkgPT09IDApIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwOSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW4gb25seSB1c2UgYHN1cGVyW2Zvb11gIGluIGNsYXNzIG9yIG9iamVjdCBtZXRob2RzIG9yIGluIGFycm93cyBuZXN0ZWQgaW4gdGhvc2UgbWV0aG9kcy9hcnJvd3MnLCAkdHBfc3VwZXJfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufSBlbHNlIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2FuIG9ubHkgdXNlIGBzdXBlci5mb29gIGluIGNsYXNzIG9yIG9iamVjdCBtZXRob2RzIG9yIGluIGFycm93cyBuZXN0ZWQgaW4gdGhvc2UgbWV0aG9kcy9hcnJvd3MnLCAkdHBfc3VwZXJfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxufVxucmV0dXJuIDE2O1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBvbmx5IGJlIHVzZWQgYXMgY2FsbCBvciBtZW1iZXIgZXhwcmVzc2lvbicsICR0cF9zdXBlcl9zdGFydCwgJHRwX3N1cGVyX3N0b3ApO1xufVxuZnVuY3Rpb24gcGFyc2VOZXdLZXl3b3JkKGxleGVyRmxhZ3MsICR0cF9uZXdfc3RhcnQsICR0cF9uZXdfc3RvcCwgJHRwX25ld19saW5lLCAkdHBfbmV3X2NvbHVtbiwgJHRwX25ld19jYW5vbiwgYXN0UHJvcCkge1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg1KSByZXR1cm4gcGFyc2VOZXdEb3RUYXJnZXQobGV4ZXJGbGFncywgJHRwX25ld19zdGFydCwgJHRwX25ld19zdG9wLCAkdHBfbmV3X2xpbmUsICR0cF9uZXdfY29sdW1uLCAkdHBfbmV3X2Nhbm9uLCBhc3RQcm9wKTtcbnJldHVybiBwYXJzZU5ld0V4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX25ld19zdGFydCwgJHRwX25ld19saW5lLCAkdHBfbmV3X2NvbHVtbiwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZU5ld0RvdFRhcmdldChsZXhlckZsYWdzLCAkdHBfbmV3X3N0YXJ0LCAkdHBfbmV3X3N0b3AsICR0cF9uZXdfbGluZSwgJHRwX25ld19jb2x1bW4sICR0cF9uZXdfY2Fub24sIGFzdFByb3ApIHtcbmlmICgobGV4ZXJGbGFncyAmIDIpID09PSAwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ011c3QgYmUgaW5zaWRlL25lc3RlZCBhIHJlZ3VsYXIgZnVuY3Rpb24gdG8gdXNlIGBuZXcudGFyZ2V0YCcsICR0cF9uZXdfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvVGFyZ2V0T3JEaWUobGV4ZXJGbGFncyk7XG5sZXQgJHRwX3Byb3BlcnR5X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9wcm9wZXJ0eV9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3Byb3BlcnR5X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3Byb3BlcnR5X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9wcm9wZXJ0eV9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcERpdihsZXhlckZsYWdzKTtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidNZXRhUHJvcGVydHknLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfbmV3X3N0YXJ0LCAkdHBfbmV3X2xpbmUsICR0cF9uZXdfY29sdW1uKSwgbWV0YTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9uZXdfc3RhcnQsICR0cF9uZXdfc3RvcCwgJHRwX25ld19saW5lLCAkdHBfbmV3X2NvbHVtbiwgJHRwX25ld19jYW5vbiksIHByb3BlcnR5OkFTVF9nZXRJZGVudE5vZGUoJHRwX3Byb3BlcnR5X3N0YXJ0LCAkdHBfcHJvcGVydHlfc3RvcCwgJHRwX3Byb3BlcnR5X2xpbmUsICR0cF9wcm9wZXJ0eV9jb2x1bW4sICR0cF9wcm9wZXJ0eV9jYW5vbil9KTtcbnJldHVybiAxNjtcbn1cbmZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfbmV3X3N0YXJ0LCAkdHBfbmV3X2xpbmUsICR0cF9uZXdfY29sdW1uLCBhc3RQcm9wKSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonTmV3RXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIGFyZ3VtZW50czpbXSwgY2FsbGVlOnVuZGVmaW5lZH0pO1xuaWYgKChpc0lkZW50VG9rZW4odG9rX2dldFR5cGUoKSkgJiYgKHRva19nZXRUeXBlKCkgPT09IDIwOTkpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGR5bmFtaWMgaW1wb3J0IGFzIGFuIGFyZ3VtZW50IHRvIGBuZXdgLCB0aGUgc3BlYyBzaW1wbHkgZG9lcyBub3QgYWxsb3cgaXQnLCAkdHBfbmV3X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmxldCBhc3NpZ25hYmxlRm9yUGlnZ2llcyA9IHBhcnNlVmFsdWUobGV4ZXJGbGFncywgZmFsc2UsIDMsIGZhbHNlLCAnY2FsbGVlJyk7XG5BU1RfY2xvc2UoJHRwX25ld19zdGFydCwgJHRwX25ld19saW5lLCAkdHBfbmV3X2NvbHVtbik7XG5yZXR1cm4gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlRm9yUGlnZ2llcyk7XG59XG5mdW5jdGlvbiBwYXJzZVRoaXNLZXl3b3JkKCR0cF90aGlzX3N0YXJ0LCAkdHBfdGhpc19saW5lLCAkdHBfdGhpc19jb2x1bW4sIGFzdFByb3ApIHtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidUaGlzRXhwcmVzc2lvbicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF90aGlzX3N0YXJ0LCAkdHBfdGhpc19saW5lLCAkdHBfdGhpc19jb2x1bW4pfSk7XG5yZXR1cm4gMTY7XG59XG5mdW5jdGlvbiBwYXJzZVVuYXJ5KGxleGVyRmxhZ3MsIGlzTmV3QXJnLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBvcE5hbWUsIGFzdFByb3ApIHtcbmxldCAkdHBfdW5hcnlfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3VuYXJ5X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfdW5hcnlfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfdW5hcnlfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnVGhlIHVuYXJ5IGV4cHJlc3Npb24gYCcgKyBvcE5hbWUpICsgJ2AgaXMgbm90IGFsbG93ZWQgaGVyZScsICR0cF91bmFyeV9zdGFydCwgJHRwX3VuYXJ5X3N0b3ApO1xufVxuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xucmV0dXJuIF9wYXJzZVVuYXJ5KGxleGVyRmxhZ3MsICR0cF91bmFyeV9zdGFydCwgJHRwX3VuYXJ5X3N0b3AsICR0cF91bmFyeV9saW5lLCAkdHBfdW5hcnlfY29sdW1uLCBvcE5hbWUsIGlzTmV3QXJnLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZVVuYXJ5KGxleGVyRmxhZ3MsICR0cF91bmFyeV9zdGFydCwgJHRwX3VuYXJ5X3N0b3AsICR0cF91bmFyeV9saW5lLCAkdHBfdW5hcnlfY29sdW1uLCBvcE5hbWUsIGlzTmV3QXJnLCBhc3RQcm9wKSB7XG5pZiAoaXNOZXdBcmcgPT09IDMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0Nhbm5vdCBgJyArIG9wTmFtZSkgKyAnYCBpbnNpZGUgYG5ld2AnLCAkdHBfdW5hcnlfc3RhcnQsICR0cF91bmFyeV9zdG9wKTtcbn1cbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidVbmFyeUV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBvcGVyYXRvcjpvcE5hbWUsIHByZWZpeDp0cnVlLCBhcmd1bWVudDp1bmRlZmluZWR9KTtcbmxldCBhc3NpZ25hYmxlID0gcGFyc2VWYWx1ZShsZXhlckZsYWdzLCBmYWxzZSwgNCwgZmFsc2UsICdhcmd1bWVudCcpO1xuaWYgKChsZXhlckZsYWdzICYgODE5MikgPT09IDgxOTIpIHtcbmlmICgoKG9wTmFtZSA9PT0gJ2RlbGV0ZScpICYmIChfcGF0aFtfcGF0aC5sZW5ndGggLSAxXS5hcmd1bWVudC50eXBlID09PSAnSWRlbnRpZmllcicpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgZGVsZXRlIGFuIGlkZW50aWZpZXIgd2l0aG91dCB0YWlsLCBpbiBzdHJpY3QgbW9kZScsICR0cF91bmFyeV9zdGFydCwgJHRwX3VuYXJ5X3N0b3ApO1xufVxufVxuQVNUX2Nsb3NlKCR0cF91bmFyeV9zdGFydCwgJHRwX3VuYXJ5X2xpbmUsICR0cF91bmFyeV9jb2x1bW4pO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDEwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBsaHMgb2YgKiogY2FuIG5vdCBiZSB0aGlzIGtpbmQgb2YgdW5hcnkgZXhwcmVzc2lvbiAoc3ludGFjdGljYWxseSBub3QgYWxsb3dlZCwgeW91IGhhdmUgdG8gd3JhcCBzb21ldGhpbmcpJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHNldE5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSk7XG59XG5mdW5jdGlvbiBwYXJzZVVwZGF0ZVByZWZpeChsZXhlckZsYWdzLCBpc05ld0FyZywgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgb3BOYW1lLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3B1bmNfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3B1bmNfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9wdW5jX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3B1bmNfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQW4gdXBkYXRlIGV4cHJlc3Npb24gYCcgKyBvcE5hbWUpICsgJ2AgaXMgbm90IGFsbG93ZWQgaGVyZScsICR0cF9wdW5jX3N0YXJ0LCAkdHBfcHVuY19zdG9wKTtcbn1cbmlmIChpc05ld0FyZyA9PT0gMykge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQ2Fubm90IGBuZXdgIG9uIGEgYCcgKyBvcE5hbWUpICsgJ2AgZXhwcicsICR0cF9wdW5jX3N0YXJ0LCAkdHBfcHVuY19zdG9wKTtcbn1cbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidVcGRhdGVFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgYXJndW1lbnQ6dW5kZWZpbmVkLCBvcGVyYXRvcjpvcE5hbWUsIHByZWZpeDp0cnVlfSk7XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlVmFsdWUobGV4ZXJGbGFncywgZmFsc2UsIDQsIGZhbHNlLCAnYXJndW1lbnQnKTtcbkFTVF90aHJvd0lmSWxsZWdhbFVwZGF0ZUFyZygnYXJndW1lbnQnKTtcbkFTVF9jbG9zZSgkdHBfcHVuY19zdGFydCwgJHRwX3B1bmNfbGluZSwgJHRwX3B1bmNfY29sdW1uKTtcbmlmIChub3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBpbmMvZGVjIGEgbm9uLWFzc2lnbmFibGUgdmFsdWUgYXMgcHJlZml4JywgJHRwX3B1bmNfc3RhcnQsICR0cF9wdW5jX3N0b3ApO1xufVxucmV0dXJuIHNldE5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSk7XG59XG5mdW5jdGlvbiBwYXJzZVlpZWxkKGxleGVyRmxhZ3MsICR0cF95aWVsZElkZW50X3R5cGUsICR0cF95aWVsZElkZW50X3N0YXJ0LCAkdHBfeWllbGRJZGVudF9zdG9wLCAkdHBfeWllbGRJZGVudF9saW5lLCAkdHBfeWllbGRJZGVudF9jb2x1bW4sICR0cF95aWVsZElkZW50X2Nhbm9uLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApIHtcbmlmICgobGV4ZXJGbGFncyAmIDEyOCkgIT09IDApIHtcbnJldHVybiBwYXJzZVlpZWxkS2V5d29yZChsZXhlckZsYWdzLCAkdHBfeWllbGRJZGVudF9zdGFydCwgJHRwX3lpZWxkSWRlbnRfc3RvcCwgJHRwX3lpZWxkSWRlbnRfbGluZSwgJHRwX3lpZWxkSWRlbnRfY29sdW1uLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApO1xufVxucmV0dXJuIHBhcnNlWWllbGRWYXJuYW1lKGxleGVyRmxhZ3MsICR0cF95aWVsZElkZW50X3R5cGUsICR0cF95aWVsZElkZW50X3N0YXJ0LCAkdHBfeWllbGRJZGVudF9zdG9wLCAkdHBfeWllbGRJZGVudF9saW5lLCAkdHBfeWllbGRJZGVudF9jb2x1bW4sICR0cF95aWVsZElkZW50X2Nhbm9uLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VZaWVsZEtleXdvcmQobGV4ZXJGbGFncywgJHRwX3lpZWxkX3N0YXJ0LCAkdHBfeWllbGRfc3RvcCwgJHRwX3lpZWxkX2xpbmUsICR0cF95aWVsZF9jb2x1bW4sIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCkge1xuaWYgKChsZXhlckZsYWdzICYgNjQpID09PSA2NCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgYHlpZWxkYCBrZXl3b3JkIGluIGFyZyBkZWZhdWx0IG11c3QgYmUgYSB2YXIgbmFtZSBidXQgdGhhdCBpcyBub3QgYWxsb3dlZCBpbnNpZGUgYSBnZW5lcmF0b3InLCAkdHBfeWllbGRfc3RhcnQsICR0cF95aWVsZF9zdG9wKTtcbn1cbmlmIChhbGxvd0Fzc2lnbm1lbnQgPT09IGZhbHNlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0RpZCBub3QgZXhwZWN0IHRvIHBhcnNlIGFuIEFzc2lnbm1lbnRFeHByZXNzaW9uIGJ1dCBmb3VuZCBgeWllbGRgJywgJHRwX3lpZWxkX3N0YXJ0LCAkdHBfeWllbGRfc3RvcCk7XG59XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonWWllbGRFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgZGVsZWdhdGU6dW5kZWZpbmVkLCBhcmd1bWVudDp1bmRlZmluZWR9KTtcbmlmICgoKHRva19nZXRObHdhcygpID09PSB0cnVlKSAmJiBpc1JlZ2V4VG9rZW4odG9rX2dldFR5cGUoKSkpKSB7XG5BU1Rfc2V0KCdkZWxlZ2F0ZScsIGZhbHNlKTtcbkFTVF9zZXQoJ2FyZ3VtZW50JywgbnVsbCk7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDA5KSB7XG5BU1Rfc2V0KCdkZWxlZ2F0ZScsIHRydWUpO1xucGFyc2VZaWVsZFN0YXJBcmd1bWVudChsZXhlckZsYWdzLCAkdHBfeWllbGRfc3RhcnQsICdhcmd1bWVudCcpO1xufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSA4MjAxMCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW5ub3QgdXNlIGB5aWVsZGAgdG8gdGhlIGxlZnQgb2YgdGhlIGAqKmAgb3BlcmF0b3InLCAkdHBfeWllbGRfc3RhcnQsICR0cF95aWVsZF9zdG9wKTtcbn0gZWxzZSB7XG5BU1Rfc2V0KCdkZWxlZ2F0ZScsIGZhbHNlKTtcbnBhcnNlWWllbGRBcmd1bWVudChsZXhlckZsYWdzLCAnYXJndW1lbnQnKTtcbn1cbkFTVF9jbG9zZSgkdHBfeWllbGRfc3RhcnQsICR0cF95aWVsZF9saW5lLCAkdHBfeWllbGRfY29sdW1uKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwNikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDYW4gbm90IGhhdmUgYSBgeWllbGRgIGV4cHJlc3Npb24gb24gdGhlIGxlZnQgc2lkZSBvZiBhIHRlcm5hcnknLCAkdHBfeWllbGRfc3RhcnQsICR0cF95aWVsZF9zdG9wKTtcbn1cbnJldHVybiAxNDQ7XG59XG5mdW5jdGlvbiBwYXJzZVlpZWxkU3RhckFyZ3VtZW50KGxleGVyRmxhZ3MsICR0cF95aWVsZF9zdGFydCwgYXN0UHJvcCkge1xuaWYgKHRva19nZXRObHdhcygpID09PSB0cnVlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0EgbmV3bGluZSBhZnRlciBgeWllbGRgIGlzIGlsbGVnYWwgZm9yIGB5aWVsZCAqYCcsICR0cF95aWVsZF9zdGFydCwgdG9rX2dldFN0YXJ0KCkpO1xufVxuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xubGV0ICR0cF92YWx1ZVN0YXJ0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF92YWx1ZVN0YXJ0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfdmFsdWVTdGFydF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF92YWx1ZVN0YXJ0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0IGFzc2lnbmFibGUgPSBwYXJzZVZhbHVlKGxleGVyRmxhZ3MsIHRydWUsIDQsIGZhbHNlLCBhc3RQcm9wKTtcbnBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfdmFsdWVTdGFydF9zdGFydCwgJHRwX3ZhbHVlU3RhcnRfc3RvcCwgJHRwX3ZhbHVlU3RhcnRfbGluZSwgJHRwX3ZhbHVlU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlWWllbGRWYXJuYW1lKGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApIHtcbmlmICgobGV4ZXJGbGFncyAmIDgxOTIpID09PSA4MTkyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCB1c2UgYHlpZWxkYCBvdXRzaWRlIG9mIGdlbmVyYXRvciBmdW5jdGlvbnMgd2hlbiBpbiBzdHJpY3QgbW9kZScsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3ApO1xufVxubGV0IGFzc2lnbmFibGVGbGFncyA9IHBhcnNlSWRlbnRPclBhcmVubGVzc0Fycm93KGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCAzMiwgYWxsb3dBc3NpZ25tZW50LCBhc3RQcm9wKTtcbnJldHVybiBjb3B5UGlnZ2llcygzMiwgYXNzaWduYWJsZUZsYWdzKTtcbn1cbmZ1bmN0aW9uIHBhcnNlWWllbGRBcmd1bWVudChsZXhlckZsYWdzLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3lpZWxkQXJnU3RhcnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3lpZWxkQXJnU3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF95aWVsZEFyZ1N0YXJ0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3lpZWxkQXJnU3RhcnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAodG9rX2dldE5sd2FzKCkgPT09IHRydWUpIHtcbkFTVF9zZXQoYXN0UHJvcCwgbnVsbCk7XG5yZXR1cm47XG59XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlVmFsdWVIZWFkQm9keShsZXhlckZsYWdzLCB0cnVlLCA0LCB0cnVlLCBmYWxzZSwgYXN0UHJvcCk7XG5pZiAodG9rX2dldFN0YXJ0KCkgPT09ICR0cF95aWVsZEFyZ1N0YXJ0X3N0YXJ0KSB7XG5BU1Rfc2V0KGFzdFByb3AsIG51bGwpO1xucmV0dXJuO1xufVxuYXNzaWduYWJsZSA9IHBhcnNlVmFsdWVUYWlsKGxleGVyRmxhZ3MsICR0cF95aWVsZEFyZ1N0YXJ0X3N0YXJ0LCAkdHBfeWllbGRBcmdTdGFydF9saW5lLCAkdHBfeWllbGRBcmdTdGFydF9jb2x1bW4sIGFzc2lnbmFibGUsIDQsIGZhbHNlLCBhc3RQcm9wKTtcbnBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfeWllbGRBcmdTdGFydF9zdGFydCwgJHRwX3lpZWxkQXJnU3RhcnRfc3RvcCwgJHRwX3lpZWxkQXJnU3RhcnRfbGluZSwgJHRwX3lpZWxkQXJnU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSWRlbnRPclBhcmVubGVzc0Fycm93KGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBhc3NpZ25hYmxlLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5OSkge1xucmV0dXJuIHBhcnNlQXJyb3dQYXJlbmxlc3NGcm9tUHVuYyhsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYWxsb3dBc3NpZ25tZW50LCAxLCAwLCBhc3RQcm9wKTtcbn0gZWxzZSB7XG5BU1Rfc2V0SWRlbnQoYXN0UHJvcCwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbik7XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlQXJyb3dQYXJlbmxlc3NGcm9tUHVuYyhsZXhlckZsYWdzLCAkdHBfYXJyb3dTdGFydF9zdGFydCwgJHRwX2Fycm93U3RhcnRfbGluZSwgJHRwX2Fycm93U3RhcnRfY29sdW1uLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYWxsb3dBc3NpZ25tZW50LCB3YXNTaW1wbGUsICR0cF9hc3luY190eXBlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2Fycm93X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2Fycm93X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuaWYgKCgoKGxleGVyRmxhZ3MgJiAxMjgpID09PSAxMjgpICYmICgkdHBfaWRlbnRfdHlwZSA9PT0gMjEyNikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Fycm93cyBjYW5ub3QgYmUgZ2VuZXJhdG9ycyBhbmQgcGFyZW5sZXNzIGB5aWVsZGAgcGFyYW0gaW4gYSBnZW5lcmF0b3Igd291bGQgYmUgcGFyc2luZyBhIHlpZWxkIGV4cHJlc3Npb24gYW5kIGZhaWwgYXQgdGhlIGFycm93JywgJHRwX2Fycm93X3N0YXJ0LCAkdHBfYXJyb3dfc3RvcCk7XG59XG5mYXRhbEJpbmRpbmdJZGVudENoZWNrKCR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24sIDEsIGxleGVyRmxhZ3MpO1xuaWYgKGlzU3RyaWN0T25seUtleXdvcmQoJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbikpIHtcbndhc1NpbXBsZSA9IDM7XG59XG5pZiAodG9rX2dldE5sd2FzKCkgPT09IHRydWUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIGFycm93IGlzIGEgcmVzdHJpY3RlZCBwcm9kdWN0aW9uIGFuZCB0aGVyZSBjYW4gbm90IGJlIGEgbmV3bGluZSBiZWZvcmUgYD0+YCB0b2tlbicsICR0cF9hcnJvd19zdGFydCwgJHRwX2Fycm93X3N0b3ApO1xufVxuaWYgKGJhYmVsQ29tcGF0KSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBwYXJhbXM6W0FTVF9nZXRJZGVudE5vZGUoJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbildLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGFzeW5jOiR0cF9hc3luY190eXBlID09PSAyMDc0LCBib2R5OnVuZGVmaW5lZH0pO1xufSBlbHNlIGlmICgoYWNvcm5Db21wYXQgJiYgKCFhbGxvd0FzeW5jRnVuY3Rpb25zKSkpIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIHBhcmFtczpbQVNUX2dldElkZW50Tm9kZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKV0sIGlkOm51bGwsIGdlbmVyYXRvcjpmYWxzZSwgZXhwcmVzc2lvbjp1bmRlZmluZWQsIGJvZHk6dW5kZWZpbmVkfSk7XG59IGVsc2Uge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgcGFyYW1zOltBU1RfZ2V0SWRlbnROb2RlKCR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24pXSwgaWQ6bnVsbCwgZ2VuZXJhdG9yOmZhbHNlLCBhc3luYzokdHBfYXN5bmNfdHlwZSA9PT0gMjA3NCwgZXhwcmVzc2lvbjp1bmRlZmluZWQsIGJvZHk6dW5kZWZpbmVkfSk7XG59XG5sZXQgYXJyb3dTY29vcCA9IFNDT1BFX2NyZWF0ZUdsb2JhbCgncGFyc2VBcnJvd1BhcmVubGVzc0Zyb21QdW5jJyk7XG5sZXQgcGFyYW1TY29vcCA9IFNDT1BFX2FkZExheWVyKGFycm93U2Nvb3AsIDExLCAncGFyc2VBcnJvd1BhcmVubGVzc0Zyb21QdW5jKGFyZyknKTtcblNDT1BFX2FkZExleEJpbmRpbmcocGFyYW1TY29vcCwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uLCAxLCAxKTtcbnBhcnNlQXJyb3dGcm9tUHVuYyhsZXhlckZsYWdzLCBwYXJhbVNjb29wLCAkdHBfYXN5bmNfdHlwZSwgYWxsb3dBc3NpZ25tZW50LCB3YXNTaW1wbGUpO1xuQVNUX2Nsb3NlKCR0cF9hcnJvd1N0YXJ0X3N0YXJ0LCAkdHBfYXJyb3dTdGFydF9saW5lLCAkdHBfYXJyb3dTdGFydF9jb2x1bW4pO1xucmV0dXJuIDEwNDA7XG59XG5mdW5jdGlvbiBwYXJzZVRpY2tFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF90aWNrX3N0YXJ0LCAkdHBfdGlja19zdG9wLCAkdHBfdGlja19saW5lLCAkdHBfdGlja19jb2x1bW4sIGFzdFByb3ApIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidUZW1wbGF0ZUxpdGVyYWwnLCBsb2M6dW5kZWZpbmVkLCBleHByZXNzaW9uczpbXSwgcXVhc2lzOltdfSk7XG5sZXQgYXdhaXRZaWVsZEZsYWdzRnJvbUFzc2lnbmFibGUgPSA4O1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDUyNDMwOCkge1xucGFyc2VRdWFzaVBhcnQobGV4ZXJGbGFncywgdHJ1ZSwgZmFsc2UpO1xuQVNUX2Nsb3NlKCR0cF90aWNrX3N0YXJ0LCAkdHBfdGlja19saW5lLCAkdHBfdGlja19jb2x1bW4pO1xucmV0dXJuIGF3YWl0WWllbGRGbGFnc0Zyb21Bc3NpZ25hYmxlO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDUyNDMwNSkge1xucGFyc2VRdWFzaVBhcnQobGV4ZXJGbGFncywgZmFsc2UsIGZhbHNlKTtcbmxldCB0bXBMZXhlckZsYWdzID0gKCgobGV4ZXJGbGFncyB8IDIwNDgpIHwgNDA5NikgfCAxODI0KSBeIDE4MjQ7XG5sZXQgd2FzVGFpbCA9IHRydWU7XG5kbyB7XG5hd2FpdFlpZWxkRmxhZ3NGcm9tQXNzaWduYWJsZSB8PSBwYXJzZUV4cHJlc3Npb25zKHRtcExleGVyRmxhZ3MsICdleHByZXNzaW9ucycpO1xud2FzVGFpbCA9ICgoKCh0b2tfZ2V0VHlwZSgpID09PSA1MjQzMDcpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNTcyODgzKSkpPyB0cnVlIDogZmFsc2UpO1xucGFyc2VRdWFzaVBhcnQobGV4ZXJGbGFncywgd2FzVGFpbCwgZmFsc2UpO1xufSB3aGlsZSAod2FzVGFpbCA9PT0gZmFsc2UpO1xuQVNUX2Nsb3NlKCR0cF90aWNrX3N0YXJ0LCAkdHBfdGlja19saW5lLCAkdHBfdGlja19jb2x1bW4pO1xucmV0dXJuIGF3YWl0WWllbGRGbGFnc0Zyb21Bc3NpZ25hYmxlO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdUZW1wbGF0ZSBjb250YWluZWQgYmFkIGVzY2FwZSwgd2hpY2ggaXMgb25seSB2YWxpZCBpbiBfdGFnZ2VkXyB0ZW1wbGF0ZXMgKGFuZCBvbmx5IHNpbmNlIEVTOS9FUzIwMTgpJywgJHRwX3RpY2tfc3RhcnQsICR0cF90aWNrX3N0b3ApO1xufVxuZnVuY3Rpb24gcGFyc2VRdWFzaVBhcnQobGV4ZXJGbGFncywgd2FzVGFpbCwgYWxsb3dCYWRFc2NhcGVzKSB7XG5sZXQgJHRwX3RpY2tfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX3RpY2tfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3RpY2tfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF90aWNrX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3RpY2tfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX3RpY2tfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbmxldCBoYXNEb3VibGVTdGFydCA9IGZhbHNlO1xubGV0IG5vQ29va2VkID0gZmFsc2U7XG5pZiAoaXNCYWRUaWNrVG9rZW4odG9rX2dldFR5cGUoKSkpIHtcbmlmICghYWxsb3dCYWRFc2NhcGVzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RlbXBsYXRlIGNvbnRhaW5lZCBhbiBpbGxlZ2FsIGVzY2FwZSwgdGhlc2UgYXJlIG9ubHkgYWxsb3dlZCBpbiBfdGFnZ2VkXyB0ZW1wbGF0ZXMgaW4gPj1FUzIwMTgnLCAkdHBfdGlja19zdGFydCwgJHRwX3RpY2tfc3RvcCk7XG59XG5ub0Nvb2tlZCA9IHRydWU7XG59XG5pZiAoKCgoKCgodG9rX2dldFR5cGUoKSA9PT0gNTI0MzA4KSB8fCAodG9rX2dldFR5cGUoKSA9PT0gNTI0MzA3KSkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNTcyODg0KSkpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNTcyODgzKSkpIHtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG59IGVsc2UgaWYgKCgoKCgoKHRva19nZXRUeXBlKCkgPT09IDUyNDMwNSkgfHwgKHRva19nZXRUeXBlKCkgPT09IDUyNDMwNikpKSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTU3Mjg4MSkpKSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTU3Mjg4MikpKSB7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5oYXNEb3VibGVTdGFydCA9IHRydWU7XG59IGVsc2Uge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgZmlyc3QgdG9rZW4gYWZ0ZXIgdGhlIHRlbXBsYXRlIGV4cHJlc3Npb24gc2hvdWxkIGJlIGEgY29udGludWF0aW9uIG9mIHRoZSB0ZW1wbGF0ZScsICR0cF90aWNrX3N0YXJ0LCAkdHBfdGlja19zdG9wKTtcbn1cbmxldCBjbG9zZVdyYXBwZXJMZW4gPSAoKCgoKCgoKCR0cF90aWNrX3R5cGUgPT09IDUyNDMwNSkgfHwgKCR0cF90aWNrX3R5cGUgPT09IDUyNDMwNikpKSB8fCAoJHRwX3RpY2tfdHlwZSA9PT0gMTU3Mjg4MSkpKSB8fCAoJHRwX3RpY2tfdHlwZSA9PT0gMTU3Mjg4MikpKT8gMiA6IDEpO1xubGV0IHF1YXNpVmFsdWUgPSB0b2tfc2xpY2VJbnB1dCgkdHBfdGlja19zdGFydCArIDEsICR0cF90aWNrX3N0b3AgLSBjbG9zZVdyYXBwZXJMZW4pO1xuaWYgKCgoKGFjb3JuQ29tcGF0IHx8IGJhYmVsQ29tcGF0KSkgfHwgdGVtcGxhdGVOZXdsaW5lTm9ybWFsaXphdGlvbikpIHtcbnF1YXNpVmFsdWUgPSBxdWFzaVZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpO1xufVxubGV0IGNvb2tlZFZhbHVlID0gKG5vQ29va2VkPyBudWxsIDogJHRwX3RpY2tfY2Fub24pO1xuQVNUX29wZW4oJ3F1YXNpcycsIHt0eXBlOidUZW1wbGF0ZUVsZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCB0YWlsOndhc1RhaWwgPT09IHRydWUsIHZhbHVlOntyYXc6cXVhc2lWYWx1ZSwgY29va2VkOmNvb2tlZFZhbHVlfX0pO1xuQVNUX2Nsb3NlVGVtcGxhdGVFbGVtZW50KGhhc0RvdWJsZVN0YXJ0LCAkdHBfdGlja19zdGFydCwgJHRwX3RpY2tfbGluZSwgJHRwX3RpY2tfY29sdW1uICsgMSk7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBhc3NpZ25hYmxlLCBpc05ld0FyZywgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgYXN0UHJvcCkge1xuaWYgKChhc3NpZ25hYmxlICYgMTAyNCkgPT09IDEwMjQpIHJldHVybiBhc3NpZ25hYmxlO1xuc3dpdGNoICh0b2tfZ2V0VHlwZSgpKSB7XG5jYXNlIDE2NDg1OlxucmV0dXJuIF9wYXJzZVZhbHVlVGFpbERvdFByb3BlcnR5KGxleGVyRmxhZ3MsICR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4sIGFzc2lnbmFibGUsIGlzTmV3QXJnLCBhc3RQcm9wKTtcbmNhc2UgMTY1MDk6XG5yZXR1cm4gX3BhcnNlVmFsdWVUYWlsRHluYW1pY1Byb3BlcnR5KGxleGVyRmxhZ3MsICR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4sIGFzc2lnbmFibGUsIGlzTmV3QXJnLCBhc3RQcm9wKTtcbmNhc2UgMTY0NzE6XG5yZXR1cm4gX3BhcnNlVmFsdWVUYWlsQ2FsbChsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBhc3NpZ25hYmxlLCBpc05ld0FyZywgYXN0UHJvcCk7XG5jYXNlIDgyMDQzOlxuaWYgKGlzTmV3QXJnID09PSAzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCB1c2UgYD8uYCBpbiB0aGUgYXJnIG9mIGBuZXdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHBhcnNlT3B0aW9uYWxWYWx1ZVRhaWxPdXRlcihsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbmNhc2UgNTI0MzA4OlxuXG5jYXNlIDUyNDMwNTpcblxuY2FzZSAxNTcyODg0OlxuXG5jYXNlIDE1NzI4ODE6XG5yZXR1cm4gX3BhcnNlVmFsdWVUYWlsVGVtcGxhdGUobGV4ZXJGbGFncywgJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbiwgYXNzaWduYWJsZSwgaXNOZXdBcmcsIGFzdFByb3ApO1xuY2FzZSAxNjQ3ODpcbmlmIChpc05ld0FyZyA9PT0gMykgcmV0dXJuIF9wYXJzZVZhbHVlVGFpbE5ld0FyZyhhc3NpZ25hYmxlKTtcbnJldHVybiBwYXJzZVZhbHVlVGFpbFVwZGF0ZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbiwgYXNzaWduYWJsZSwgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgJysrJywgYXN0UHJvcCk7XG5jYXNlIDE2NDgyOlxuaWYgKGlzTmV3QXJnID09PSAzKSByZXR1cm4gX3BhcnNlVmFsdWVUYWlsTmV3QXJnKGFzc2lnbmFibGUpO1xucmV0dXJuIHBhcnNlVmFsdWVUYWlsVXBkYXRlRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBhc3NpZ25hYmxlLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCAnLS0nLCBhc3RQcm9wKTtcbn1cbmlmIChpc05ld0FyZyA9PT0gMykgcmV0dXJuIF9wYXJzZVZhbHVlVGFpbE5ld0FyZyhhc3NpZ25hYmxlKTtcbnJldHVybiBhc3NpZ25hYmxlO1xufVxuZnVuY3Rpb24gcGFyc2VPcHRpb25hbFZhbHVlVGFpbE91dGVyKGxleGVyRmxhZ3MsICR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApIHtcbmRvIHtcbmxldCAkdHBfbmV4dF90eXBlID0gdG9rX2dldFR5cGUoKTtcbnN3aXRjaCAoJHRwX25leHRfdHlwZSkge1xuY2FzZSA4MjA0MzpcbnNraXBBbnkobGV4ZXJGbGFncyk7XG5sZXQgJHRwX3FfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5pZiAoaXNJZGVudFRva2VuKCR0cF9xX3R5cGUpKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbmlmICghaXNJZGVudFRva2VuKCR0cF9pZGVudF90eXBlKSkgVEhST1dfUkFOR0UoJ0V4cGVjdGVkIGlkZW50IGFmdGVyIGRvdCcsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3ApO1xuc2tpcERpdihsZXhlckZsYWdzKTtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidPcHRpb25hbE1lbWJlckV4cHJlc3Npb24nLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uKSwgb3B0aW9uYWw6dHJ1ZSwgY29tcHV0ZWQ6ZmFsc2UsIG9iamVjdDpBU1RfcG9wTm9kZShhc3RQcm9wKSwgcHJvcGVydHk6QVNUX2dldElkZW50Tm9kZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKX0pO1xufSBlbHNlIGlmICgkdHBfcV90eXBlID09PSAxNjUwOSkge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOidPcHRpb25hbE1lbWJlckV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBvcHRpb25hbDp0cnVlLCBjb21wdXRlZDp0cnVlLCBvYmplY3Q6dW5kZWZpbmVkLCBwcm9wZXJ0eTp1bmRlZmluZWR9LCAnb2JqZWN0Jyk7XG5wYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJ3Byb3BlcnR5Jyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY1MTApIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGVkIHRoZSBjbG9zaW5nIGBdYCBjaGFyIG9mIGEgZHluYW1pYyBwcm9wZXJ0eSwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBEaXYobGV4ZXJGbGFncyk7XG5BU1RfY2xvc2UoJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbik7XG59IGVsc2UgaWYgKCR0cF9xX3R5cGUgPT09IDE2NDcxKSB7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTonT3B0aW9uYWxDYWxsRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIG9wdGlvbmFsOnRydWUsIGNhbGxlZTp1bmRlZmluZWQsIGFyZ3VtZW50czpbXX0sICdjYWxsZWUnKTtcbmxldCBub3dBc3NpZ25hYmxlID0gcGFyc2VDYWxsQXJncyhsZXhlckZsYWdzLCAnYXJndW1lbnRzJyk7XG5hc3NpZ25hYmxlID0gbWVyZ2VBc3NpZ25hYmxlKG5vd0Fzc2lnbmFibGUsIGFzc2lnbmFibGUpO1xuQVNUX2Nsb3NlKCR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4pO1xufSBlbHNlIGlmIChpc1RlbXBsYXRlU3RhcnQoJHRwX3FfdHlwZSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQW4gdmFsdWUgY29udGFpbmluZyB0aGUgb3B0aW9uYWwgY2hhaW5pbmcgb3BlcmF0b3IgY2Fubm90IGJlIGZvbGxvd2VkIGJ5IGEgdGVtcGxhdGUnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59IGVsc2UgaWYgKCR0cF9xX3R5cGUgPT09IDgyMDQzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBjYW5ub3QgYD8uPy5gLCBtdXN0IGhhdmUgc29tZXRoaW5nIGluIGJldHdlZW4nLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5icmVhaztcbmNhc2UgMTY0ODU6XG5za2lwQW55KGxleGVyRmxhZ3MpO1xubGV0ICR0cF9pZGVudF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfaWRlbnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2lkZW50X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfaWRlbnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfaWRlbnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2lkZW50X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5pZiAoIWlzSWRlbnRUb2tlbigkdHBfaWRlbnRfdHlwZSkpIFRIUk9XX1JBTkdFKCdFeHBlY3RlZCBpZGVudCBhZnRlciBkb3QnLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKTtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5BU1Rfc2V0Tm9kZShhc3RQcm9wLCB7dHlwZTonT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbiksIG9wdGlvbmFsOmZhbHNlLCBjb21wdXRlZDpmYWxzZSwgb2JqZWN0OkFTVF9wb3BOb2RlKGFzdFByb3ApLCBwcm9wZXJ0eTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24pfSk7XG5icmVhaztcbmNhc2UgMTY0NzE6XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTonT3B0aW9uYWxDYWxsRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIG9wdGlvbmFsOmZhbHNlLCBjYWxsZWU6dW5kZWZpbmVkLCBhcmd1bWVudHM6dW5kZWZpbmVkfSwgJ2NhbGxlZScpO1xubGV0IG5vd0Fzc2lnbmFibGUgPSBwYXJzZUNhbGxBcmdzKGxleGVyRmxhZ3MsICdhcmd1bWVudHMnKTtcbmFzc2lnbmFibGUgPSBtZXJnZUFzc2lnbmFibGUobm93QXNzaWduYWJsZSwgYXNzaWduYWJsZSk7XG5BU1RfY2xvc2UoJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbik7XG5icmVhaztcbmNhc2UgMTY1MDk6XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIG9wdGlvbmFsOmZhbHNlLCBjb21wdXRlZDp0cnVlLCBvYmplY3Q6dW5kZWZpbmVkLCBwcm9wZXJ0eTp1bmRlZmluZWR9LCAnb2JqZWN0Jyk7XG5wYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJ3Byb3BlcnR5Jyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY1MTApIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGVkIHRoZSBjbG9zaW5nIGBdYCBjaGFyIG9mIGEgZHluYW1pYyBwcm9wZXJ0eSwgZm91bmRgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcERpdihsZXhlckZsYWdzKTtcbmFzc2lnbmFibGUgPSBwYXJzZU9wdGlvbmFsVmFsdWVUYWlsT3V0ZXIobGV4ZXJGbGFncywgJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbiwgYXNzaWduYWJsZSwgJ3Byb3BlcnR5Jyk7XG5BU1RfY2xvc2UoJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbik7XG5icmVhaztcbmRlZmF1bHQ6XG5pZiAoaXNUZW1wbGF0ZVN0YXJ0KCR0cF9uZXh0X3R5cGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0FuIHZhbHVlIGNvbnRhaW5pbmcgdGhlIG9wdGlvbmFsIGNoYWluaW5nIG9wZXJhdG9yIGNhbm5vdCBiZSBmb2xsb3dlZCBieSBhIHRlbXBsYXRlJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHNldE5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSk7XG59XG59IHdoaWxlICh0cnVlKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZVZhbHVlVGFpbERvdFByb3BlcnR5KGxleGVyRmxhZ3MsICR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4sIGFzc2lnbmFibGUsIGlzTmV3QXJnLCBhc3RQcm9wKSB7XG5za2lwVG9JZGVudE9yRGllKGxleGVyRmxhZ3MgfCA2NTUzNik7XG5sZXQgJHRwX2lkZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9pZGVudF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2lkZW50X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2lkZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9pZGVudF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcERpdihsZXhlckZsYWdzKTtcbkFTVF9zZXROb2RlKGFzdFByb3AsIHt0eXBlOidNZW1iZXJFeHByZXNzaW9uJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbiksIG9iamVjdDpBU1RfcG9wTm9kZShhc3RQcm9wKSwgcHJvcGVydHk6QVNUX2dldElkZW50Tm9kZSgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uKSwgY29tcHV0ZWQ6ZmFsc2V9KTtcbnJldHVybiBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBzZXRBc3NpZ25hYmxlKGFzc2lnbmFibGUpLCBpc05ld0FyZywgZmFsc2UsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gX3BhcnNlVmFsdWVUYWlsRHluYW1pY1Byb3BlcnR5KGxleGVyRmxhZ3MsICR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4sIGFzc2lnbmFibGUsIGlzTmV3QXJnLCBhc3RQcm9wKSB7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTonTWVtYmVyRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIG9iamVjdDp1bmRlZmluZWQsIHByb3BlcnR5OnVuZGVmaW5lZCwgY29tcHV0ZWQ6dHJ1ZX0sICdvYmplY3QnKTtcbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbmxldCBub3dBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9ucygoKGxleGVyRmxhZ3MgfCA0MDk2KSB8IDE4MjQpIF4gMTgyNCwgJ3Byb3BlcnR5Jyk7XG5hc3NpZ25hYmxlID0gbWVyZ2VBc3NpZ25hYmxlKG5vd0Fzc2lnbmFibGUsIGFzc2lnbmFibGUpO1xuYXNzaWduYWJsZSA9IChhc3NpZ25hYmxlIHwgMTAyNCkgXiAxMDI0O1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTEwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0aGUgY2xvc2luZyBicmFja2V0IGBdYCBmb3IgYSBkeW5hbWljIHByb3BlcnR5LCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcERpdihsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uKTtcbnJldHVybiBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBzZXRBc3NpZ25hYmxlKGFzc2lnbmFibGUpLCBpc05ld0FyZywgZmFsc2UsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gX3BhcnNlVmFsdWVUYWlsQ2FsbChsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBhc3NpZ25hYmxlLCBpc05ld0FyZywgYXN0UHJvcCkge1xuaWYgKGlzTmV3QXJnID09PSAzKSB7XG5sZXQgbm93QXNzaWduYWJsZSA9IHBhcnNlQ2FsbEFyZ3MobGV4ZXJGbGFncywgJ2FyZ3VtZW50cycpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDk5KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBgbmV3YCBrZXl3b3JkIGNhbiBub3QgYmUgYXBwbGllZCB0byBhbiBhcnJvdycsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmFzc2lnbmFibGUgPSBtZXJnZUFzc2lnbmFibGUobm93QXNzaWduYWJsZSwgYXNzaWduYWJsZSk7XG5hc3NpZ25hYmxlID0gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbnJldHVybiBhc3NpZ25hYmxlO1xufVxuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J0NhbGxFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgY2FsbGVlOnVuZGVmaW5lZCwgYXJndW1lbnRzOltdfSwgJ2NhbGxlZScpO1xubGV0IG5vd0Fzc2lnbmFibGUgPSBwYXJzZUNhbGxBcmdzKGxleGVyRmxhZ3MsICdhcmd1bWVudHMnKTtcbmFzc2lnbmFibGUgPSBtZXJnZUFzc2lnbmFibGUobm93QXNzaWduYWJsZSwgYXNzaWduYWJsZSk7XG5BU1RfY2xvc2UoJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbik7XG5yZXR1cm4gcGFyc2VWYWx1ZVRhaWwobGV4ZXJGbGFncywgJHRwX3ZhbHVlRmlyc3Rfc3RhcnQsICR0cF92YWx1ZUZpcnN0X2xpbmUsICR0cF92YWx1ZUZpcnN0X2NvbHVtbiwgc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSwgaXNOZXdBcmcsIGZhbHNlLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZVZhbHVlVGFpbFRlbXBsYXRlKGxleGVyRmxhZ3MsICR0cF92YWx1ZUZpcnN0X3N0YXJ0LCAkdHBfdmFsdWVGaXJzdF9saW5lLCAkdHBfdmFsdWVGaXJzdF9jb2x1bW4sIGFzc2lnbmFibGUsIGlzTmV3QXJnLCBhc3RQcm9wKSB7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTonVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgdGFnOnVuZGVmaW5lZCwgcXVhc2k6dW5kZWZpbmVkfSwgJ3RhZycpO1xubGV0ICR0cF9RdWFzaV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfUXVhc2lfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9RdWFzaV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuQVNUX29wZW4oJ3F1YXNpJywge3R5cGU6J1RlbXBsYXRlTGl0ZXJhbCcsIGxvYzp1bmRlZmluZWQsIGV4cHJlc3Npb25zOltdLCBxdWFzaXM6W119KTtcbl9wYXJzZVZhbHVlVGFpbFRlbXBsYXRlUmVzdChsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfUXVhc2lfc3RhcnQsICR0cF9RdWFzaV9saW5lLCAkdHBfUXVhc2lfY29sdW1uKTtcbkFTVF9jbG9zZSgkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uKTtcbnJldHVybiBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfdmFsdWVGaXJzdF9zdGFydCwgJHRwX3ZhbHVlRmlyc3RfbGluZSwgJHRwX3ZhbHVlRmlyc3RfY29sdW1uLCBzZXROb3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpLCBpc05ld0FyZywgZmFsc2UsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gX3BhcnNlVmFsdWVUYWlsVGVtcGxhdGVSZXN0KGxleGVyRmxhZ3MpIHtcbmxldCBhd2FpdFlpZWxkRmxhZ3NGcm9tQXNzaWduYWJsZSA9IDg7XG5pZiAoKCh0b2tfZ2V0VHlwZSgpID09PSA1MjQzMDgpIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNTcyODg0KSkpIHtcbnBhcnNlUXVhc2lQYXJ0KGxleGVyRmxhZ3MsIHRydWUsIGFsbG93QmFkRXNjYXBlc0luVGFnZ2VkVGVtcGxhdGVzKTtcbnJldHVybjtcbn1cbnBhcnNlUXVhc2lQYXJ0KGxleGVyRmxhZ3MsIGZhbHNlLCBhbGxvd0JhZEVzY2FwZXNJblRhZ2dlZFRlbXBsYXRlcyk7XG5sZXQgdG1wTGV4ZXJGbGFncyA9ICgoKGxleGVyRmxhZ3MgfCAyMDQ4KSB8IDQwOTYpIHwgMTgyNCkgXiAxODI0O1xubGV0IHdhc1RhaWwgPSB0cnVlO1xuZG8ge1xuYXdhaXRZaWVsZEZsYWdzRnJvbUFzc2lnbmFibGUgfD0gcGFyc2VFeHByZXNzaW9ucyh0bXBMZXhlckZsYWdzLCAnZXhwcmVzc2lvbnMnKTtcbndhc1RhaWwgPSAoKCgodG9rX2dldFR5cGUoKSA9PT0gNTI0MzA3KSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTU3Mjg4MykpKT8gdHJ1ZSA6IGZhbHNlKTtcbnBhcnNlUXVhc2lQYXJ0KGxleGVyRmxhZ3MsIHdhc1RhaWwsIGFsbG93QmFkRXNjYXBlc0luVGFnZ2VkVGVtcGxhdGVzKTtcbn0gd2hpbGUgKHdhc1RhaWwgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZVZhbHVlVGFpbE5ld0FyZyhhc3NpZ25hYmxlKSB7XG5yZXR1cm4gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVUYWlsVXBkYXRlRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfYXJnU3RhcnRfc3RhcnQsICR0cF9hcmdTdGFydF9saW5lLCAkdHBfYXJnU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCBsZWZ0SGFuZFNpZGVFeHByZXNzaW9uLCBvcE5hbWUsIGFzdFByb3ApIHtcbmxldCAkdHBfb3Bfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfb3Bfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQSBgJyArIG9wTmFtZSkgKyAnYCB1cGRhdGUgZXhwcmVzc2lvbiBpcyBub3QgYWxsb3dlZCBoZXJlJywgJHRwX29wX3N0YXJ0LCAkdHBfb3Bfc3RvcCk7XG59XG5pZiAodG9rX2dldE5sd2FzKCkgPT09IHRydWUpIHtcbmlmICgobGV4ZXJGbGFncyAmIDQwOTYpID09PSA0MDk2KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdUaGUgcG9zdGZpeCBgJyArIG9wTmFtZSkgKyAnYCBpcyBhIHJlc3RyaWN0ZWQgcHJvZHVjdGlvbiBzbyBBU0kgbXVzdCBhcHBseSBidXQgdGhhdCBpcyBub3QgdmFsaWQgaW4gdGhpcyBjb250ZXh0JywgJHRwX29wX3N0YXJ0LCAkdHBfb3Bfc3RvcCk7XG59XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmlmIChub3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdDYW5ub3QgcG9zdGZpeCBgJyArIG9wTmFtZSkgKyAnYCBhIG5vbi1hc3NpZ25hYmxlIHZhbHVlJywgJHRwX29wX3N0YXJ0LCAkdHBfb3Bfc3RvcCk7XG59XG5BU1RfdGhyb3dJZklsbGVnYWxVcGRhdGVBcmcoYXN0UHJvcCk7XG5za2lwRGl2KGxleGVyRmxhZ3MpO1xuQVNUX3NldE5vZGVEYW5nZXJvdXNseShhc3RQcm9wLCB7dHlwZTonVXBkYXRlRXhwcmVzc2lvbicsIGxvYzpBU1RfZ2V0Q2xvc2VkTG9jKCR0cF9hcmdTdGFydF9zdGFydCwgJHRwX2FyZ1N0YXJ0X2xpbmUsICR0cF9hcmdTdGFydF9jb2x1bW4pLCBhcmd1bWVudDpBU1RfcG9wTm9kZShhc3RQcm9wKSwgb3BlcmF0b3I6b3BOYW1lLCBwcmVmaXg6ZmFsc2V9KTtcbnJldHVybiAxNjtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbEFyZ3MobGV4ZXJGbGFncywgYXN0UHJvcCkge1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0R3JvdXBlZChsZXhlckZsYWdzKTtcbmxleGVyRmxhZ3MgPSAoKGxleGVyRmxhZ3MgfCA0MDk2KSB8IDMyKSBeIDMyO1xubGV0IGFzc2lnbmFibGUgPSA4O1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDcyKSB7XG5za2lwRGl2KGxleGVyRmxhZ3MpO1xufSBlbHNlIHtcbmRvIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4Nikge1xubGV0ICR0cF9zcHJlYWRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3NwcmVhZF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3NwcmVhZF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J1NwcmVhZEVsZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBhcmd1bWVudDp1bmRlZmluZWR9KTtcbmxldCBub3dBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsICdhcmd1bWVudCcpO1xuYXNzaWduYWJsZSA9IG1lcmdlQXNzaWduYWJsZShub3dBc3NpZ25hYmxlLCBhc3NpZ25hYmxlKTtcbkFTVF9jbG9zZSgkdHBfc3ByZWFkX3N0YXJ0LCAkdHBfc3ByZWFkX2xpbmUsICR0cF9zcHJlYWRfY29sdW1uKTtcbn0gZWxzZSB7XG5sZXQgbm93QXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBtZXJnZUFzc2lnbmFibGUobm93QXNzaWduYWJsZSwgYXNzaWduYWJsZSk7XG59XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApIGJyZWFrO1xubGV0ICR0cF9jb21tYV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9jb21tYV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbnNraXBUb0V4cHJlc3Npb25TdGFydEdyb3VwZWQobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0NzIpIHtcbmlmIChhbGxvd1RyYWlsaW5nRnVuY3Rpb25Db21tYSkgYnJlYWs7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RhcmdldGVkIGxhbmd1YWdlIHZlcnNpb24gZG9lcyBub3Qgc3VwcG9ydCB0cmFpbGluZyBjYWxsIGFyZyBjb21tYScsICR0cF9jb21tYV9zdGFydCwgJHRwX2NvbW1hX3N0b3ApO1xufVxufSB3aGlsZSAodHJ1ZSk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGluZyBjbG9zaW5nIHBhcmVuIGApYCBmb3IgdGhlIGNhbGwsIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwRGl2KGxleGVyRmxhZ3MpO1xufVxucmV0dXJuIChhc3NpZ25hYmxlIHwgMTAyNCkgXiAxMDI0O1xufVxuZnVuY3Rpb24gcGFyc2VEeW5hbWljSW1wb3J0U3RhdGVtZW50KGxleGVyRmxhZ3MsICR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfc3RvcCwgJHRwX2ltcG9ydF9saW5lLCAkdHBfaW1wb3J0X2NvbHVtbiwgYXN0UHJvcCkge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0V4cHJlc3Npb25TdGF0ZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBleHByZXNzaW9uOnVuZGVmaW5lZH0pO1xucGFyc2VEeW5hbWljSW1wb3J0KGxleGVyRmxhZ3MsICR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfc3RvcCwgJHRwX2ltcG9ydF9saW5lLCAkdHBfaW1wb3J0X2NvbHVtbiwgJ2V4cHJlc3Npb24nKTtcbmxldCBhc3NpZ25hYmxlID0gcGFyc2VWYWx1ZVRhaWwobGV4ZXJGbGFncywgJHRwX2ltcG9ydF9zdGFydCwgJHRwX2ltcG9ydF9saW5lLCAkdHBfaW1wb3J0X2NvbHVtbiwgMTYsIDQsIGZhbHNlLCAnZXhwcmVzc2lvbicpO1xucGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfc3RvcCwgJHRwX2ltcG9ydF9saW5lLCAkdHBfaW1wb3J0X2NvbHVtbiwgYXNzaWduYWJsZSwgJ2V4cHJlc3Npb24nKTtcbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfbGluZSwgJHRwX2ltcG9ydF9jb2x1bW4pO1xufVxuZnVuY3Rpb24gcGFyc2VEeW5hbWljSW1wb3J0KGxleGVyRmxhZ3MsICR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfc3RvcCwgJHRwX2ltcG9ydF9saW5lLCAkdHBfaW1wb3J0X2NvbHVtbiwgYXN0UHJvcCkge1xuaWYgKCFhbGxvd0R5bmFtaWNJbXBvcnQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRHluYW1pYyBpbXBvcnQgc3ludGF4IG5vdCBzdXBwb3J0ZWQuIFJlcXVpcmVzIHZlcnNpb24gRVMyMDIwKyAvIEVTMTErLicsICR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfc3RvcCk7XG59XG5pZiAoYWNvcm5Db21wYXQpIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidJbXBvcnRFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgc291cmNlOnVuZGVmaW5lZH0pO1xufSBlbHNlIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidDYWxsRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIGNhbGxlZTp1bmRlZmluZWQsIGFyZ3VtZW50czpbXX0pO1xuQVNUX3NldE5vZGUoJ2NhbGxlZScsIHt0eXBlOidJbXBvcnQnLCBsb2M6QVNUX2dldENsb3NlZExvYygkdHBfaW1wb3J0X3N0YXJ0LCAkdHBfaW1wb3J0X2xpbmUsICR0cF9pbXBvcnRfY29sdW1uKX0pO1xufVxuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xubGV0IGFzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgKGFjb3JuQ29tcGF0PyAnc291cmNlJyA6ICdhcmd1bWVudHMnKSk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzIpIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdEeW5hbWljIGBpbXBvcnRgIG9ubHkgZXhwZWN0ZWQgZXhhY3RseSBvbmUgYXJndW1lbnQgYW5kIGRvZXMgbm90IGFsbG93IGZvciBhIHRyYWlsaW5nIGNvbW1hJywgJHRwX2ltcG9ydF9zdGFydCwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gNjc2MzYpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIGR5bmFtaWMgaW1wb3J0IHN5bnRheCBleHBsaWNpdGx5IGZvcmJpZHMgdGhlIGBpbmAgb3BlcmF0b3InLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBkeW5hbWljIGBpbXBvcnRgIGFyZ3VtZW50IHdhcyBmb2xsb3dlZCBieSB1bmtub3duIGNvbnRlbnQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwRGl2KGxleGVyRmxhZ3MpO1xuQVNUX2Nsb3NlKCR0cF9pbXBvcnRfc3RhcnQsICR0cF9pbXBvcnRfbGluZSwgJHRwX2ltcG9ydF9jb2x1bW4pO1xucmV0dXJuIGFzc2lnbmFibGU7XG59XG5mdW5jdGlvbiBwYXJzZUFycm93RnJvbVB1bmMobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgJHRwX2FzeW5jX3R5cGUsIGFsbG93QXNzaWdubWVudCwgcGFyYW1zU2ltcGxlKSB7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5pZiAoYWxsb3dBc3NpZ25tZW50ID09PSBmYWxzZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdXYXMgcGFyc2luZyBhIHZhbHVlIHRoYXQgY291bGQgbm90IGJlIEFzc2lnbm1lbnRFeHByZXNzaW9uIGJ1dCBmb3VuZCBhbiBhcnJvdycsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmIChvcHRpb25zX2V4cG9zZVNjb3BlcykgQVNUX3NldCgnJHNjb3BlJywgcGFyYW1TY29vcCk7XG5pZiAocGFyYW1TY29vcC5kdXBlUGFyYW1FcnJvclN0YXJ0ICE9PSAwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Fycm93IGhhZCBkdXBsaWNhdGUgcGFyYW1zJywgcGFyYW1TY29vcC5kdXBlUGFyYW1FcnJvclN0YXJ0IC0gMSwgcGFyYW1TY29vcC5kdXBlUGFyYW1FcnJvclN0b3ApO1xufVxubGV0IGluc2lkZUZvckxocyA9IChsZXhlckZsYWdzICYgMzIpID09PSAzMjtcbmxldCBhcnJvd0luaGVyaXRlZEZsYWdzID0gbGV4ZXJGbGFncyAmIDE4O1xubGV4ZXJGbGFncyA9IHJlc2V0TGV4ZXJGbGFnc0ZvckZ1bmNBbmRBcnJvdyhsZXhlckZsYWdzLCAwLCAkdHBfYXN5bmNfdHlwZSwgdHJ1ZSk7XG5sZXhlckZsYWdzIHw9IGFycm93SW5oZXJpdGVkRmxhZ3M7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MTMpIHtcbmlmICghYmFiZWxDb21wYXQpIEFTVF9zZXQoJ2V4cHJlc3Npb24nLCBmYWxzZSk7XG5sZXQgYXJyb3dTY29vcCA9IFNDT1BFX2FkZExheWVyKHBhcmFtU2Nvb3AsIDEwLCAncGFyc2VBcnJvd0Zyb21QdW5jJyk7XG5wYXJzZUZ1bmN0aW9uQm9keShsZXhlckZsYWdzLCBhcnJvd1Njb29wLCAxLCBwYXJhbXNTaW1wbGUsIDAsIDAsIDAsIDAsIDAsICcnLCB0cnVlKTtcbmlmICgoaXNSZWdleFRva2VuKHRva19nZXRUeXBlKCkpICYmICghdG9rX2dldE5sd2FzKCkpKSkge1xuVEhST1dfUkFOR0UoJ0ZvdW5kIGEgcmVnZXggb3IgZGl2aXNpb24gYWZ0ZXIgYW4gYXJyb3csIHRoYXQgaXMgaWxsZWdhbCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn0gZWxzZSB7XG5pZiAoaW5zaWRlRm9yTGhzKSBsZXhlckZsYWdzIHw9IDMyO1xuaWYgKCFiYWJlbENvbXBhdCkgQVNUX3NldCgnZXhwcmVzc2lvbicsIHRydWUpO1xucGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsICdib2R5Jyk7XG59XG57XG5sZXQgJHRwX2Vycm9yX3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9lcnJvcl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9lcnJvcl9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfZXJyb3JfbmwgPSB0b2tfZ2V0Tmx3YXMoKTtcbmlmICgoaW5zaWRlRm9yTGhzICYmICgkdHBfZXJyb3JfdHlwZSA9PT0gNjc2MzYpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBcnJvd3MgY2Fubm90IGJlIGxocyB0byBmb3ItaW4nLCAkdHBfZXJyb3Jfc3RhcnQsICR0cF9lcnJvcl9zdG9wKTtcbn1cbmlmICgkdHBfZXJyb3JfdHlwZSA9PT0gMTY0ODUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQmxvY2sgYm9keSBhcnJvd3MgY2FuIG5vdCBiZSBpbW1lZGlhdGVseSBhY2Nlc3NlZCB3aXRob3V0IGEgZ3JvdXAnLCAkdHBfZXJyb3Jfc3RhcnQsICR0cF9lcnJvcl9zdG9wKTtcbn1cbmlmICgkdHBfZXJyb3JfbmwpIHtcbmlmICgkdHBfZXJyb3JfdHlwZSA9PT0gODIwMjMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQW4gYXJyb3cgZnVuY3Rpb24gY2FuIG5vdCBiZSBwYXJ0IG9mIGFuIG9wZXJhdG9yIHRvIHRoZSByaWdodCcsICR0cF9lcnJvcl9zdGFydCwgJHRwX2Vycm9yX3N0b3ApO1xufVxucmV0dXJuIDEwNDA7XG59XG5pZiAoJHRwX2Vycm9yX3R5cGUgPT09IDE2NDcxKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Jsb2NrIGJvZHkgYXJyb3dzIGNhbiBub3QgYmUgaW1tZWRpYXRlbHkgaW52b2tlZCB3aXRob3V0IGEgZ3JvdXAnLCAkdHBfZXJyb3Jfc3RhcnQsICR0cF9lcnJvcl9zdG9wKTtcbn1cbmlmICgkdHBfZXJyb3JfdHlwZSA9PT0gMTY1MDkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQmxvY2sgYm9keSBhcnJvd3MgY2FuIG5vdCBiZSBpbW1lZGlhdGVseSBhY2Nlc3NlZCB3aXRob3V0IGEgZ3JvdXAnLCAkdHBfZXJyb3Jfc3RhcnQsICR0cF9lcnJvcl9zdG9wKTtcbn1cbmlmIChpc1RlbXBsYXRlU3RhcnQoJHRwX2Vycm9yX3R5cGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Jsb2NrIGJvZHkgYXJyb3dzIGNhbiBub3QgYmUgaW1tZWRpYXRlbHkgdGFnZ2VkIHdpdGhvdXQgYSBncm91cCcsICR0cF9lcnJvcl9zdGFydCwgJHRwX2Vycm9yX3N0b3ApO1xufVxuaWYgKChpc0FueUFzc2lnbm1lbnRPcCgpIHx8ICgoJHRwX2Vycm9yX3R5cGUgJiA2NTUzNikgPT09IDY1NTM2KSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQW4gYXJyb3cgZnVuY3Rpb24gY2FuIG5vdCBiZSBwYXJ0IG9mIGFuIG9wZXJhdG9yIHRvIHRoZSByaWdodCcsICR0cF9lcnJvcl9zdGFydCwgJHRwX2Vycm9yX3N0b3ApO1xufVxuaWYgKCgoJHRwX2Vycm9yX3R5cGUgPT09IDE2NDc4KSB8fCAoJHRwX2Vycm9yX3R5cGUgPT09IDE2NDgyKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQW4gYXJyb3cgZnVuY3Rpb24gY2FuIG5vdCBoYXZlIGEgcG9zdGZpeCB1cGRhdGUgb3BlcmF0b3InLCAkdHBfZXJyb3Jfc3RhcnQsICR0cF9lcnJvcl9zdG9wKTtcbn1cbn1cbnJldHVybiAxMDQwO1xufVxuZnVuY3Rpb24gcGFyc2VHcm91cFRvcGxldmVscyhsZXhlckZsYWdzQmVmb3JlUGFyZW4sIGFzeW5jU3RtdE9yRXhwciwgYWxsb3dBc3NpZ25tZW50Rm9yR3JvdXBUb0JlQXJyb3csICR0cF9hc3luY190eXBlLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19zdG9wLCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgJHRwX2FzeW5jX2Nhbm9uLCBuZXdsaW5lQWZ0ZXJBc3luYywgbGVmdEhhbmRTaWRlRXhwcmVzc2lvbiwgYXN0UHJvcCkge1xubGV0ICR0cF9wYXJlbl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfcGFyZW5fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9wYXJlbl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0R3JvdXBlZChsZXhlckZsYWdzQmVmb3JlUGFyZW4pO1xubGV0ICR0cF9maXJzdFRva2VuQWZ0ZXJQYXJlbl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfZmlyc3RUb2tlbkFmdGVyUGFyZW5fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9maXJzdFRva2VuQWZ0ZXJQYXJlbl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0IGxleGVyRmxhZ3MgPSAoKGxleGVyRmxhZ3NCZWZvcmVQYXJlbiB8IDQwOTYpIHwgMTgyNCkgXiAxODI0O1xubGV0IGFycm93U2Nvb3AgPSBTQ09QRV9jcmVhdGVHbG9iYWwoJ19wYXJzZUdyb3VwVG9wbGV2ZWxzJyk7XG5sZXQgcGFyYW1TY29vcCA9IFNDT1BFX2FkZExheWVyKGFycm93U2Nvb3AsIDExLCAnX3BhcnNlR3JvdXBUb3BsZXZlbHMoYXJnKScpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDcyKSB7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbnNraXBEaXYobGV4ZXJGbGFncyk7XG5yZXR1cm4gcGFyc2VBZnRlckFzeW5jR3JvdXAobGV4ZXJGbGFnc0JlZm9yZVBhcmVuLCBwYXJhbVNjb29wLCBhc3luY1N0bXRPckV4cHIsIGFsbG93QXNzaWdubWVudEZvckdyb3VwVG9CZUFycm93LCAxLCBmYWxzZSwgbmV3bGluZUFmdGVyQXN5bmMsIHRydWUsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIDgsIGFzdFByb3ApO1xufVxuc2tpcFRvQXJyb3dPckRpZShsZXhlckZsYWdzKTtcbmxldCAkdHBfYXJyb3dfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfYXJyb3dfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBcnJvdyBub3QgYWxsb3dlZCBpbiB0aGlzIHBvc2l0aW9uJywgJHRwX3BhcmVuX3N0YXJ0LCAkdHBfYXJyb3dfc3RvcCk7XG59XG5sZXhlckZsYWdzID0gbGV4ZXJGbGFnc0JlZm9yZVBhcmVuO1xuaWYgKHRva19nZXRObHdhcygpID09PSB0cnVlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBhcnJvdyB0b2tlbiBgPT5gIGlzIGEgcmVzdHJpY3RlZCBwcm9kdWN0aW9uIGFuZCBjYW5ub3QgaGF2ZSBhIG5ld2xpbmUgcHJlY2VkaW5nIGl0JywgJHRwX2Fycm93X3N0YXJ0LCAkdHBfYXJyb3dfc3RvcCk7XG59XG5pZiAoYmFiZWxDb21wYXQpIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIHBhcmFtczpbXSwgaWQ6bnVsbCwgZ2VuZXJhdG9yOmZhbHNlLCBhc3luYzpmYWxzZSwgYm9keTp1bmRlZmluZWR9KTtcbn0gZWxzZSBpZiAoKGFjb3JuQ29tcGF0ICYmICghYWxsb3dBc3luY0Z1bmN0aW9ucykpKSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBwYXJhbXM6W10sIGlkOm51bGwsIGdlbmVyYXRvcjpmYWxzZSwgZXhwcmVzc2lvbjp1bmRlZmluZWQsIGJvZHk6dW5kZWZpbmVkfSk7XG59IGVsc2Uge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgcGFyYW1zOltdLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGFzeW5jOmZhbHNlLCBleHByZXNzaW9uOnVuZGVmaW5lZCwgYm9keTp1bmRlZmluZWR9KTtcbn1cbmxldCBhc3NpZ25hYmxlID0gcGFyc2VBcnJvd0Zyb21QdW5jKGxleGVyRmxhZ3MsIHBhcmFtU2Nvb3AsIDAsIGFsbG93QXNzaWdubWVudEZvckdyb3VwVG9CZUFycm93LCAxKTtcbkFTVF9jbG9zZSgkdHBfcGFyZW5fc3RhcnQsICR0cF9wYXJlbl9saW5lLCAkdHBfcGFyZW5fY29sdW1uKTtcbnJldHVybiBhc3NpZ25hYmxlO1xufVxubGV0IGZvdW5kU2luZ2xlSWRlbnRXcmFwID0gZmFsc2U7XG5sZXQgcm9vdEFzdFByb3AgPSBhc3RQcm9wO1xubGV0IGRlc3RydWN0aWJsZSA9IDA7XG5sZXQgYXNzaWduYWJsZSA9IDg7XG5sZXQgdG9wbGV2ZWxDb21tYSA9IGZhbHNlO1xubGV0IHdhc1NpbXBsZSA9IDE7XG5sZXQgbXVzdEJlQXJyb3cgPSBmYWxzZTtcbndoaWxlICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3Mikge1xuaWYgKGlzSWRlbnRUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xubGV0ICR0cF9pZGVudF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfaWRlbnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2lkZW50X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfaWRlbnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfaWRlbnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2lkZW50X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwSWRlbnRTYWZlU2xvd0FuZEV4cGVuc2l2ZShsZXhlckZsYWdzLCBmYWxzZSk7XG5sZXQgd2FzQXNzaWdubWVudCA9IHRva19nZXRUeXBlKCkgPT09IDQ5MjY0O1xubGV0IHdhc0NvbW1hT3JFbmQgPSAoKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTY0NzIpKTtcbmxldCBleHByQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIDEsIGFzdFByb3ApO1xuYXNzaWduYWJsZSA9IG1lcmdlQXNzaWduYWJsZShleHByQXNzaWduYWJsZSwgYXNzaWduYWJsZSk7XG5TQ09QRV9hZGRMZXhCaW5kaW5nKHBhcmFtU2Nvb3AsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgMSwgMSk7XG5pZiAod2FzQXNzaWdubWVudCkge1xud2FzU2ltcGxlID0gMztcbn0gZWxzZSBpZiAod2FzQ29tbWFPckVuZCkge1xuaWYgKCgoIXRvcGxldmVsQ29tbWEpICYmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ3MikpKSB7XG5mb3VuZFNpbmdsZUlkZW50V3JhcCA9IHRydWU7XG59XG5pZiAobm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2UgaWYgKGlzU3RyaWN0T25seUtleXdvcmQoJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbikpIHtcbndhc1NpbXBsZSA9IDM7XG59IGVsc2Uge1xuXG59XG59IGVsc2Uge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NTEzKSB7XG5sZXQgJHRwX3N0YXJ0T2ZQYXR0ZXJuX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9zdGFydE9mUGF0dGVybl9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlT2JqZWN0T3V0ZXIobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgMSwgdHJ1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFzdFByb3ApO1xuaWYgKCgodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApICYmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3MikpKSB7XG5kZXN0cnVjdGlibGUgfD0gMTtcbn1cbmFzc2lnbmFibGUgPSBwYXJzZUFmdGVyUGF0dGVybkluR3JvdXAobGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0YXJ0LCAkdHBfc3RhcnRPZlBhdHRlcm5fc3RvcCwgJHRwX3N0YXJ0T2ZQYXR0ZXJuX2xpbmUsICR0cF9zdGFydE9mUGF0dGVybl9jb2x1bW4sIGFzc2lnbmFibGUsIGRlc3RydWN0aWJsZSwgYXN0UHJvcCk7XG53YXNTaW1wbGUgPSAzO1xufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwOSkge1xubGV0ICR0cF9zdGFydE9mUGF0dGVybl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfc3RhcnRPZlBhdHRlcm5fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdGFydE9mUGF0dGVybl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9zdGFydE9mUGF0dGVybl9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmRlc3RydWN0aWJsZSB8PSBwYXJzZUFycmF5T3V0ZXIobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgMSwgdHJ1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFzdFByb3ApO1xuaWYgKCgodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApICYmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3MikpKSB7XG5kZXN0cnVjdGlibGUgfD0gMTtcbn1cbmFzc2lnbmFibGUgPSBwYXJzZUFmdGVyUGF0dGVybkluR3JvdXAobGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0YXJ0LCAkdHBfc3RhcnRPZlBhdHRlcm5fc3RvcCwgJHRwX3N0YXJ0T2ZQYXR0ZXJuX2xpbmUsICR0cF9zdGFydE9mUGF0dGVybl9jb2x1bW4sIGFzc2lnbmFibGUsIGRlc3RydWN0aWJsZSwgYXN0UHJvcCk7XG53YXNTaW1wbGUgPSAzO1xufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4Nikge1xud2FzU2ltcGxlID0gMztcbmxldCBzdWJEZXN0cnVjdCA9IHBhcnNlQXJyb3dhYmxlU3ByZWFkT3JSZXN0KGxleGVyRmxhZ3MsIHBhcmFtU2Nvb3AsIDE2NDcyLCAxLCAkdHBfYXN5bmNfdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFzdFByb3ApO1xuZGVzdHJ1Y3RpYmxlIHw9IHN1YkRlc3RydWN0O1xuaWYgKCR0cF9hc3luY190eXBlID09PSAyMDc0KSB7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzIpIHtcbmRlc3RydWN0aWJsZSB8PSAxO1xufSBlbHNlIHtcblxufVxufSBlbHNlIHtcbmlmICgoKChzdWJEZXN0cnVjdCAmIDEpID09PSAxKSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgLi4uIGFyZ3VtZW50IG11c3QgYmUgZGVzdHJ1Y3RpYmxlIGluIGFuIGFycm93IGhlYWRlciwgZm91bmQgc29tZXRoaW5nIHRoYXQgd2FzIG5vdCBkZXN0cnVjdGlibGUnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5tdXN0QmVBcnJvdyA9IHRydWU7XG5icmVhaztcbn1cbn0gZWxzZSB7XG5kZXN0cnVjdGlibGUgfD0gMTtcbmxldCBleHByQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBtZXJnZUFzc2lnbmFibGUoZXhwckFzc2lnbmFibGUsIGFzc2lnbmFibGUpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5pZiAoIXRvcGxldmVsQ29tbWEpIHtcbnRvcGxldmVsQ29tbWEgPSB0cnVlO1xuQVNUX3dyYXBDbG9zZWRJbnRvQXJyYXlDdXN0b20ocm9vdEFzdFByb3AsIHt0eXBlOidTZXF1ZW5jZUV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBleHByZXNzaW9uczp1bmRlZmluZWR9LCAnZXhwcmVzc2lvbnMnKTtcbmFzdFByb3AgPSAnZXhwcmVzc2lvbnMnO1xufVxuYXNzaWduYWJsZSA9IF9fcGFyc2VFeHByZXNzaW9ucyhsZXhlckZsYWdzLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbmlmICh0b3BsZXZlbENvbW1hKSB7XG5pZiAoYmFiZWxDb21wYXQpIEFTVF9zZXQoJ2V4dHJhJywge3BhcmVudGhlc2l6ZWQ6dHJ1ZSwgcGFyZW5TdGFydDokdHBfcGFyZW5fc3RhcnR9KTtcbkFTVF9jbG9zZSgkdHBfZmlyc3RUb2tlbkFmdGVyUGFyZW5fc3RhcnQsICR0cF9maXJzdFRva2VuQWZ0ZXJQYXJlbl9saW5lLCAkdHBfZmlyc3RUb2tlbkFmdGVyUGFyZW5fY29sdW1uKTtcbmFzc2lnbmFibGUgPSBzZXROb3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpO1xufVxuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDcyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0aGUgY2xvc2luZyBwYXJlbiBgKWAgZm9yIHRoZSBncm91cCwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBEaXYobGV4ZXJGbGFncyk7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5OSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgaGVhZGVyIG9mIHRoaXMgYXN5bmMgYXJyb3cgY29udGFpbmVkIHNvbWV0aGluZyB0aGF0IGlzIG5vdCB2YWxpZCBhIHBhcmFtJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHBhcnNlQWZ0ZXJBc3luY0dyb3VwKGxleGVyRmxhZ3NCZWZvcmVQYXJlbiwgcGFyYW1TY29vcCwgYXN5bmNTdG10T3JFeHByLCBhbGxvd0Fzc2lnbm1lbnRGb3JHcm91cFRvQmVBcnJvdywgd2FzU2ltcGxlLCB0b3BsZXZlbENvbW1hLCBuZXdsaW5lQWZ0ZXJBc3luYywgZmFsc2UsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGFzc2lnbmFibGUsIHJvb3RBc3RQcm9wKTtcbn1cbmlmICgoYmFiZWxDb21wYXQgJiYgKCF0b3BsZXZlbENvbW1hKSkpIHtcbkFTVF9iYWJlbFBhcmVudGhlc2l6ZXNDbG9zZWQoJHRwX3BhcmVuX3N0YXJ0LCBhc3RQcm9wKTtcbn1cbnJldHVybiAoYXNzaWduYWJsZSB8IDEwMjQpIF4gMTAyNDtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ4MCkgYnJlYWs7XG5za2lwVG9FeHByZXNzaW9uU3RhcnRHcm91cGVkKGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDcyKSB7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDApIHtcbmlmIChhbGxvd1RyYWlsaW5nRnVuY3Rpb25Db21tYSkge1xubXVzdEJlQXJyb3cgPSB0cnVlO1xuYnJlYWs7XG59XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0VuY291bnRlcmVkIHRyYWlsaW5nIGNvbW1hIGluIHRoZSB0b3BsZXZlbCBvZiBhIGdyb3VwLCB0aGlzIGNvdWxkIGJlIHZhbGlkIGluIGFycm93cyBidXQgbm90IHdpdGggdGhlIGN1cnJlbnRseSB0YXJnZXRlZCBsYW5ndWFnZSB2ZXJzaW9uJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuaWYgKCF0b3BsZXZlbENvbW1hKSB7XG50b3BsZXZlbENvbW1hID0gdHJ1ZTtcbkFTVF93cmFwQ2xvc2VkSW50b0FycmF5Q3VzdG9tKHJvb3RBc3RQcm9wLCB7dHlwZTonU2VxdWVuY2VFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgZXhwcmVzc2lvbnM6dW5kZWZpbmVkfSwgJ2V4cHJlc3Npb25zJyk7XG5hc3RQcm9wID0gJ2V4cHJlc3Npb25zJztcbn1cbn1cbmlmICh0b3BsZXZlbENvbW1hKSB7XG5hc3NpZ25hYmxlID0gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbmlmIChiYWJlbENvbXBhdCkgQVNUX3NldCgnZXh0cmEnLCB7cGFyZW50aGVzaXplZDp0cnVlLCBwYXJlblN0YXJ0OiR0cF9wYXJlbl9zdGFydH0pO1xuQVNUX2Nsb3NlKCR0cF9maXJzdFRva2VuQWZ0ZXJQYXJlbl9zdGFydCwgJHRwX2ZpcnN0VG9rZW5BZnRlclBhcmVuX2xpbmUsICR0cF9maXJzdFRva2VuQWZ0ZXJQYXJlbl9jb2x1bW4pO1xufVxuZGVzdHJ1Y3RpYmxlID0gY29weVBpZ2dpZXMoZGVzdHJ1Y3RpYmxlLCBhc3NpZ25hYmxlKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3Mikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnTWlzc2luZyBjbG9zaW5nIHBhcmVuIGApYCBmb3IgZ3JvdXAsIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwRGl2KGxleGVyRmxhZ3MpO1xubGV4ZXJGbGFncyA9IGxleGVyRmxhZ3NCZWZvcmVQYXJlbjtcbnZlcmlmeURlc3RydWN0aWJsZShkZXN0cnVjdGlibGUpO1xubGV0IGlzQXJyb3cgPSB0b2tfZ2V0VHlwZSgpID09PSAxNjQ5OTtcbmlmIChpc0Fycm93KSB7XG5kZXN0cnVjdGlibGUgfD0gMTAyNDtcbmxldCAkdHBfYXJyb3dfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfYXJyb3dfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAobGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9PT0gdHJ1ZSkge1xubGV0ICR0cF9lcnJvck9mZnNldF9zdGFydCA9ICgoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpPyAkdHBfYXN5bmNfc3RhcnQgOiAkdHBfcGFyZW5fc3RhcnQpO1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBcnJvdyBub3QgYWxsb3dlZCBpbiB0aGlzIHBvc2l0aW9uJywgJHRwX2Vycm9yT2Zmc2V0X3N0YXJ0LCAkdHBfYXJyb3dfc3RvcCk7XG59XG5pZiAodG9rX2dldE5sd2FzKCkgPT09IHRydWUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQXJyb3cgaXMgcmVzdHJpY3RlZCBwcm9kdWN0aW9uOyBjYW5ub3QgaGF2ZSBuZXdsaW5lIGJlZm9yZSB0aGUgYXJyb3cgdG9rZW4nLCAkdHBfYXJyb3dfc3RhcnQsICR0cF9hcnJvd19zdG9wKTtcbn1cbmlmICgoZGVzdHJ1Y3RpYmxlICYgMSkgPT09IDEpIHtcbmlmICgkdHBfYXN5bmNfdHlwZSA9PT0gMjA3NCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFzeW5jIGFycm93IGlzIG5vdCBkZXN0cnVjdGlibGUgc28gYXJyb3cgaXMgaWxsZWdhbCcsICR0cF9hcnJvd19zdGFydCwgJHRwX2Fycm93X3N0b3ApO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFycm93IGlzIG5vdCBkZXN0cnVjdGlibGUgc28gYXJyb3cgaXMgaWxsZWdhbCcsICR0cF9hcnJvd19zdGFydCwgJHRwX2Fycm93X3N0b3ApO1xufVxuaWYgKChkZXN0cnVjdGlibGUgJiAyKSA9PT0gMikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGFycm93IGNhbiBvbmx5IGJlIGRlc3RydWN0ZWQgdGhyb3VnaCBhc3NpZ25tZW50IHNvIGFycm93IGlzIGlsbGVnYWwnLCAkdHBfYXJyb3dfc3RhcnQsICR0cF9hcnJvd19zdG9wKTtcbn1cbmlmICgoZGVzdHJ1Y3RpYmxlICYgNjQpICE9PSAwKSB7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhlIHBhcmFtZXRlciBoZWFkZXIgb2YgYW4gYXN5bmMgYXJyb3cgY2Fubm90IGNvbnRhaW4gYGF3YWl0YCBhcyB2YXJuYW1lIG5vciBhcyBhIGtleXdvcmQnLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19zdG9wKTtcbn1cbmlmICgobGV4ZXJGbGFncyAmIDgpICE9PSAwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBwYXJhbWV0ZXIgaGVhZGVyIG9mIGFuIGFycm93IGluc2lkZSBhbiBhc3luYyBmdW5jdGlvbiBjYW5ub3QgY29udGFpbiBgYXdhaXRgIGFzIHZhcm5hbWUgbm9yIGFzIGEga2V5d29yZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmlmICgoZGVzdHJ1Y3RpYmxlICYgMTI4KSA9PT0gMTI4KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBhcmd1bWVudHMgb2YgYW4gYXJyb3cgY2Fubm90IGNvbnRhaW4gYSB5aWVsZCBleHByZXNzaW9uIGluIHRoZWlyIGRlZmF1bHRzJywgJHRwX2Fycm93X3N0YXJ0LCAkdHBfYXJyb3dfc3RvcCk7XG59XG59IGVsc2UgaWYgKCgoKGRlc3RydWN0aWJsZSAmIDQpID09PSA0KSB8fCBtdXN0QmVBcnJvdykpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnR3JvdXAgY29udGFpbmVkIGEgdmFsdWUgdGhhdCBtdXN0IGRlc3RydWN0IGJ1dCB0aGlzIHdhcyBub3QgYW4gYXJyb3cgc28gaXQgaXMgaW52YWxpZCcsICR0cF9wYXJlbl9zdGFydCwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbmRlc3RydWN0aWJsZSA9IGNvcHlQaWdnaWVzKGRlc3RydWN0aWJsZSwgYXNzaWduYWJsZSk7XG5yZXR1cm4gcGFyc2VBZnRlckFzeW5jR3JvdXAobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgYXN5bmNTdG10T3JFeHByLCBhbGxvd0Fzc2lnbm1lbnRGb3JHcm91cFRvQmVBcnJvdywgd2FzU2ltcGxlLCB0b3BsZXZlbENvbW1hLCBuZXdsaW5lQWZ0ZXJBc3luYywgZmFsc2UsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGFzc2lnbmFibGUsIHJvb3RBc3RQcm9wKTtcbn1cbmlmIChpc0Fycm93KSB7XG5wYXJzZUFycm93QWZ0ZXJHcm91cChsZXhlckZsYWdzLCBwYXJhbVNjb29wLCB3YXNTaW1wbGUsIHRvcGxldmVsQ29tbWEsIDAsICR0cF9wYXJlbl9zdGFydCwgJHRwX3BhcmVuX2xpbmUsICR0cF9wYXJlbl9jb2x1bW4sIGFsbG93QXNzaWdubWVudEZvckdyb3VwVG9CZUFycm93LCByb290QXN0UHJvcCk7XG5hc3NpZ25hYmxlID0gY29weVBpZ2dpZXMoYXNzaWduYWJsZSwgZGVzdHJ1Y3RpYmxlKTtcbnJldHVybiAxMDQwIHwgKGFzc2lnbmFibGUgJiA2NCk7XG59XG5pZiAoKGJhYmVsQ29tcGF0ICYmICghdG9wbGV2ZWxDb21tYSkpKSB7XG5BU1RfYmFiZWxQYXJlbnRoZXNpemVzQ2xvc2VkKCR0cF9wYXJlbl9zdGFydCwgYXN0UHJvcCk7XG59XG5yZXR1cm4gKGFzc2lnbmFibGUgfCAxMDI0KSBeIDEwMjQ7XG59XG5mdW5jdGlvbiBwYXJzZUFmdGVyUGF0dGVybkluR3JvdXAobGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0YXJ0LCAkdHBfc3RhcnRPZlBhdHRlcm5fc3RvcCwgJHRwX3N0YXJ0T2ZQYXR0ZXJuX2xpbmUsICR0cF9zdGFydE9mUGF0dGVybl9jb2x1bW4sIGFzc2lnbmFibGUsIGRlc3RydWN0aWJsZSwgYXN0UHJvcCkge1xuaWYgKCgodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApICYmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3MikpKSB7XG5pZiAoKGRlc3RydWN0aWJsZSAmIDQpID09PSA0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1BhdHRlcm4gY2FuIG5vdCBoYXZlIGEgdGFpbCBidXQgZGlkIG5vdCBmaW5kIGEgY29tbWEgb3IgY2xvc2luZyBwYXJlbiBvZiB0aGUgYXJyb3cgaGVhZGVyJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxubGV0IGV4cHJBc3NpZ25hYmxlID0gcGFyc2VWYWx1ZVRhaWwobGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0YXJ0LCAkdHBfc3RhcnRPZlBhdHRlcm5fbGluZSwgJHRwX3N0YXJ0T2ZQYXR0ZXJuX2NvbHVtbiwgMTYsIDQsIGZhbHNlLCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBtZXJnZUFzc2lnbmFibGUoZXhwckFzc2lnbmFibGUsIGFzc2lnbmFibGUpO1xuaWYgKCgodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApICYmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ3MikpKSB7XG5hc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF9zdGFydE9mUGF0dGVybl9zdGFydCwgJHRwX3N0YXJ0T2ZQYXR0ZXJuX3N0b3AsICR0cF9zdGFydE9mUGF0dGVybl9saW5lLCAkdHBfc3RhcnRPZlBhdHRlcm5fY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbn1cbn0gZWxzZSB7XG5hc3NpZ25hYmxlID0gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbn1cbnJldHVybiBhc3NpZ25hYmxlO1xufVxuZnVuY3Rpb24gcGFyc2VBZnRlckFzeW5jR3JvdXAobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgZnJvbVN0bXRPckV4cHIsIGFsbG93QXNzaWdubWVudCwgd2FzU2ltcGxlLCB0b3BsZXZlbENvbW1hLCBuZXdsaW5lQWZ0ZXJBc3luYywgemVyb0FyZ3MsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24sIGFzc2lnbmFibGUsIGFzdFByb3ApIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5OSkge1xubGV0ICR0cF9hcnJvd19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9hcnJvd19zdG9wID0gdG9rX2dldFN0b3AoKTtcbmlmICh0b2tfZ2V0Tmx3YXMoKSA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgYXJyb3cgaXMgYSByZXN0cmljdGVkIHByb2R1Y3Rpb24gYW4gdGhlcmUgY2FuIG5vdCBiZSBhIG5ld2xpbmUgYmVmb3JlIGA9PmAgdG9rZW4nLCAkdHBfYXJyb3dfc3RhcnQsICR0cF9hcnJvd19zdG9wKTtcbn1cbmlmIChuZXdsaW5lQWZ0ZXJBc3luYyA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBIG5ld2xpbmUgYWZ0ZXIgYXN5bmMgaXMgYWx3YXlzIGEgc3ludGF4IGVycm9yIGlmIHRoZSByaHMgdHVybnMgdG8gYmUgYW4gYXJyb3cgZnVuY3Rpb24nLCAkdHBfYXJyb3dfc3RhcnQsICR0cF9hcnJvd19zdG9wKTtcbn1cbmlmICh6ZXJvQXJncykge1xucGFyc2VBcnJvd0FmdGVyQXN5bmNOb0FyZ0dyb3VwKGxleGVyRmxhZ3MsIHBhcmFtU2Nvb3AsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCk7XG59IGVsc2Uge1xucGFyc2VBcnJvd0FmdGVyR3JvdXAobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgd2FzU2ltcGxlLCB0b3BsZXZlbENvbW1hLCAyMDc0LCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApO1xufVxufSBlbHNlIHtcbmlmICh6ZXJvQXJncykge1xuQVNUX3NldE5vZGUoYXN0UHJvcCwge3R5cGU6J0NhbGxFeHByZXNzaW9uJywgbG9jOkFTVF9nZXRDbG9zZWRMb2MoJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiksIGNhbGxlZTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX3N0b3AsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCAkdHBfYXN5bmNfY2Fub24pLCBhcmd1bWVudHM6W119KTtcbn0gZWxzZSB7XG5BU1RfcGF0Y2hBc3luY0NhbGwoJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sICR0cF9hc3luY19jYW5vbiwgYXN0UHJvcCk7XG59XG5sZXQgYXNzaWduYWJsZSA9IHBhcnNlVmFsdWVUYWlsKGxleGVyRmxhZ3MsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIDE2LCA0LCBmYWxzZSwgYXN0UHJvcCk7XG5pZiAoZnJvbVN0bXRPckV4cHIgPT09IDIpIHtcbmFzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfc3RvcCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5hc3NpZ25hYmxlID0gX3BhcnNlRXhwcmVzc2lvbnMobGV4ZXJGbGFncywgJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG59XG5wYXJzZVNlbWlPckFzaShsZXhlckZsYWdzKTtcbn1cbnJldHVybiBhc3NpZ25hYmxlO1xufVxuaWYgKGZyb21TdG10T3JFeHByID09PSAyKSB7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApIHtcbl9wYXJzZUV4cHJlc3Npb25zKGxleGVyRmxhZ3MsICR0cF9hc3luY19zdGFydCwgJHRwX2FzeW5jX2xpbmUsICR0cF9hc3luY19jb2x1bW4sIDE2LCBhc3RQcm9wKTtcbn1cbnBhcnNlU2VtaU9yQXNpKGxleGVyRmxhZ3MpO1xufVxucmV0dXJuIDEwNDAgfCAoYXNzaWduYWJsZSAmIDY0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyb3dBZnRlckFzeW5jTm9BcmdHcm91cChsZXhlckZsYWdzLCBwYXJhbVNjb29wLCAkdHBfYXN5bmNfc3RhcnQsICR0cF9hc3luY19saW5lLCAkdHBfYXN5bmNfY29sdW1uLCBhbGxvd0Fzc2lnbm1lbnQsIGFzdFByb3ApIHtcbmlmIChiYWJlbENvbXBhdCkge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgcGFyYW1zOltdLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGFzeW5jOnRydWUsIGJvZHk6dW5kZWZpbmVkfSk7XG59IGVsc2UgaWYgKChhY29ybkNvbXBhdCAmJiAoIWFsbG93QXN5bmNGdW5jdGlvbnMpKSkge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgcGFyYW1zOltdLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGV4cHJlc3Npb246dW5kZWZpbmVkLCBib2R5OnVuZGVmaW5lZH0pO1xufSBlbHNlIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIHBhcmFtczpbXSwgaWQ6bnVsbCwgZ2VuZXJhdG9yOmZhbHNlLCBhc3luYzp0cnVlLCBleHByZXNzaW9uOnVuZGVmaW5lZCwgYm9keTp1bmRlZmluZWR9KTtcbn1cbmxldCBhc3NpZ25hYmxlID0gcGFyc2VBcnJvd0Zyb21QdW5jKGxleGVyRmxhZ3MsIHBhcmFtU2Nvb3AsIDIwNzQsIGFsbG93QXNzaWdubWVudCwgMSk7XG5BU1RfY2xvc2UoJHRwX2FzeW5jX3N0YXJ0LCAkdHBfYXN5bmNfbGluZSwgJHRwX2FzeW5jX2NvbHVtbik7XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyb3dBZnRlckdyb3VwKGxleGVyRmxhZ3MsIHBhcmFtU2Nvb3AsIHdhc1NpbXBsZSwgdG9wbGV2ZWxDb21tYSwgJHRwX2FzeW5jX3R5cGUsICR0cF9hcnJvd1N0YXJ0X3N0YXJ0LCAkdHBfYXJyb3dTdGFydF9saW5lLCAkdHBfYXJyb3dTdGFydF9jb2x1bW4sIGFsbG93QXNzaWdubWVudCwgYXN0UHJvcCkge1xuaWYgKGJhYmVsQ29tcGF0KSB7XG5BU1Rfd3JhcENsb3NlZEludG9BcnJheUN1c3RvbShhc3RQcm9wLCB7dHlwZTonQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBwYXJhbXM6dW5kZWZpbmVkLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGFzeW5jOiR0cF9hc3luY190eXBlID09PSAyMDc0LCBib2R5OnVuZGVmaW5lZH0sICdwYXJhbXMnKTtcbn0gZWxzZSBpZiAoKGFjb3JuQ29tcGF0ICYmICghYWxsb3dBc3luY0Z1bmN0aW9ucykpKSB7XG5BU1Rfd3JhcENsb3NlZEludG9BcnJheUN1c3RvbShhc3RQcm9wLCB7dHlwZTonQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBwYXJhbXM6dW5kZWZpbmVkLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGV4cHJlc3Npb246dW5kZWZpbmVkLCBib2R5OnVuZGVmaW5lZH0sICdwYXJhbXMnKTtcbn0gZWxzZSB7XG5BU1Rfd3JhcENsb3NlZEludG9BcnJheUN1c3RvbShhc3RQcm9wLCB7dHlwZTonQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBwYXJhbXM6dW5kZWZpbmVkLCBpZDpudWxsLCBnZW5lcmF0b3I6ZmFsc2UsIGFzeW5jOiR0cF9hc3luY190eXBlID09PSAyMDc0LCBleHByZXNzaW9uOnVuZGVmaW5lZCwgYm9keTp1bmRlZmluZWR9LCAncGFyYW1zJyk7XG59XG5sZXQgdG9wID0gX3BhdGhbX3BhdGgubGVuZ3RoIC0gMV07XG5pZiAodG9wbGV2ZWxDb21tYSkge1xubGV0IHBhcmFtcyA9IHRvcC5wYXJhbXNbdG9wLnBhcmFtcy5sZW5ndGggLSAxXTtcbnRvcC5wYXJhbXMgPSBwYXJhbXMuZXhwcmVzc2lvbnM7XG59XG5sZXQgcGFyYW1zID0gdG9wLnBhcmFtcztcbmZvciAobGV0IGkgPSAwO2kgPCBwYXJhbXMubGVuZ3RoOysraSkge1xuQVNUX19kZXN0cnVjdChwYXJhbXNbaV0sIHBhcmFtcywgaSk7XG59XG5wYXJzZUFycm93RnJvbVB1bmMobGV4ZXJGbGFncywgcGFyYW1TY29vcCwgJHRwX2FzeW5jX3R5cGUsIGFsbG93QXNzaWdubWVudCwgd2FzU2ltcGxlKTtcbkFTVF9jbG9zZSgkdHBfYXJyb3dTdGFydF9zdGFydCwgJHRwX2Fycm93U3RhcnRfbGluZSwgJHRwX2Fycm93U3RhcnRfY29sdW1uKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPdXRlcihsZXhlckZsYWdzQmVmb3JlUGFyZW4sIHNjb29wLCBiaW5kaW5nVHlwZSwgc2tpcEluaXQsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApIHtcbmxldCBkZXN0cnVjdGlibGUgPSBwYXJzZUFycmF5TGl0ZXJhbFBhdHRlcm4obGV4ZXJGbGFnc0JlZm9yZVBhcmVuLCBzY29vcCwgYmluZGluZ1R5cGUsIHNraXBJbml0LCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbnJldHVybiBkZXN0cnVjdGlibGU7XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5TGl0ZXJhbFBhdHRlcm4obGV4ZXJGbGFnc0JlZm9yZVBhcmVuLCBzY29vcCwgYmluZGluZ1R5cGUsIHNraXBJbml0LCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBfYXN0UHJvcCkge1xubGV0IGxleGVyRmxhZ3MgPSAobGV4ZXJGbGFnc0JlZm9yZVBhcmVuIHwgMzIpIF4gMzI7XG5sZXQgJHRwX2FycmF5T3Blbl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfYXJyYXlPcGVuX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfYXJyYXlPcGVuX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5za2lwVG9FeHByZXNzaW9uU3RhcnRTcXVhcmVDbG9zZUNvbW1hKGxleGVyRmxhZ3MpO1xuQVNUX29wZW4oX2FzdFByb3AsIHt0eXBlOidBcnJheUV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBlbGVtZW50czpbXX0pO1xubGV0IGFzdFByb3AgPSAnZWxlbWVudHMnO1xubGV0IGRlc3RydWN0aWJsZSA9IDA7XG53aGlsZSAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApIHtcbnNraXBUb0V4cHJlc3Npb25TdGFydFNxdWFyZUNsb3NlQ29tbWEobGV4ZXJGbGFncyk7XG5BU1RfYWRkKGFzdFByb3AsIG51bGwpO1xufVxubGV0IHNwcmVhZFN0YWdlID0gMDtcbmxldCBhc3NpZ25hYmxlWWllbGRBd2FpdFN0YXRlID0gODtcbndoaWxlICh0b2tfZ2V0VHlwZSgpICE9PSAxNjUxMCkge1xubGV0ICR0cF9lbGVtZW50U3RhcnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2VsZW1lbnRTdGFydF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2VsZW1lbnRTdGFydF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9lbGVtZW50U3RhcnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBJZGVudFNhZmVTbG93QW5kRXhwZW5zaXZlKGxleGVyRmxhZ3MsIGZhbHNlKTtcbmxldCBuZXh0SXNBc3NpZ25tZW50ID0gdG9rX2dldFR5cGUoKSA9PT0gNDkyNjQ7XG5sZXQgbmV4dElzQ29tbWFPckVuZCA9ICgodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApIHx8ICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMCkpO1xubGV0IGxlZnRBc3NpZ25hYmxlID0gcGFyc2VWYWx1ZUhlYWRCb2R5QWZ0ZXJJZGVudChsZXhlckZsYWdzLCAkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIDQsIHRydWUsIGZhbHNlLCBhc3RQcm9wKTtcbmFzc2lnbmFibGVZaWVsZEF3YWl0U3RhdGUgfD0gbGVmdEFzc2lnbmFibGU7XG5pZiAobmV4dElzQXNzaWdubWVudCkge1xuaWYgKG5vdEFzc2lnbmFibGUobGVmdEFzc2lnbmFibGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdDYW5ub3QgYXNzaWduIG9yIGRlc3RydWN0IHRvIGtleXdvcmQgYCcgKyB0b2tfc2xpY2VJbnB1dCgkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wKSkgKyAnYCcsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3ApO1xufVxuU0NPUEVfYWN0dWFsbHlBZGRCaW5kaW5nKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgJHRwX2lkZW50X2Nhbm9uKTtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOidBc3NpZ25tZW50RXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIGxlZnQ6dW5kZWZpbmVkLCBvcGVyYXRvcjonPScsIHJpZ2h0OnVuZGVmaW5lZH0sICdsZWZ0Jyk7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5sZXQgcmlnaHRBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsICdyaWdodCcpO1xuQVNUX2Nsb3NlKCR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4pO1xuYXNzaWduYWJsZVlpZWxkQXdhaXRTdGF0ZSB8PSByaWdodEFzc2lnbmFibGU7XG59IGVsc2UgaWYgKG5leHRJc0NvbW1hT3JFbmQpIHtcbmlmIChub3RBc3NpZ25hYmxlKGxlZnRBc3NpZ25hYmxlKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2Uge1xuU0NPUEVfYWN0dWFsbHlBZGRCaW5kaW5nKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgJHRwX2lkZW50X2Nhbm9uKTtcbn1cbn0gZWxzZSB7XG5pZiAoYmluZGluZ1R5cGUgPT09IDEpIHtcbmRlc3RydWN0aWJsZSB8PSAyO1xufSBlbHNlIGlmIChiaW5kaW5nVHlwZSAhPT0gMCkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59XG5sZXQgbm93RGVzdHJ1Y3QgPSBwYXJzZU9wdGlvbmFsRGVzdHJ1Y3RpYmxlUmVzdE9mRXhwcmVzc2lvbihsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgbGVmdEFzc2lnbmFibGUsIDEsIDE2NTEwLCBhc3RQcm9wKTtcbmRlc3RydWN0aWJsZSB8PSBub3dEZXN0cnVjdDtcbn1cbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MTMpIHtcbmxldCAkdHBfb2JqT3Blbl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfb2JqT3Blbl9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX29iak9wZW5fc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfb2JqT3Blbl9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCBvYmpEZXN0cnVjdGlibGUgPSBwYXJzZU9iamVjdEFuZEFzc2lnbihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIHRydWUsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApO1xuZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlT3B0aW9uYWxEZXN0cnVjdGlibGVSZXN0T2ZFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF9vYmpPcGVuX3N0YXJ0LCAkdHBfb2JqT3Blbl9zdG9wLCAkdHBfb2JqT3Blbl9saW5lLCAkdHBfb2JqT3Blbl9jb2x1bW4sICgoKG9iakRlc3RydWN0aWJsZSAmIDEpID09PSAxKT8gMTYgOiAzMiksIG9iakRlc3RydWN0aWJsZSwgMTY1MTAsIGFzdFByb3ApO1xufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwOSkge1xubGV0ICR0cF9hcnJPcGVuX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9hcnJPcGVuX2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfYXJyT3Blbl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9hcnJPcGVuX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0IGFyckRlc3RydWN0aWJsZSA9IHBhcnNlQXJyYXlMaXRlcmFsUGF0dGVybihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIHRydWUsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApO1xuZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlT3B0aW9uYWxEZXN0cnVjdGlibGVSZXN0T2ZFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF9hcnJPcGVuX3N0YXJ0LCAkdHBfYXJyT3Blbl9zdG9wLCAkdHBfYXJyT3Blbl9saW5lLCAkdHBfYXJyT3Blbl9jb2x1bW4sICgoKGFyckRlc3RydWN0aWJsZSAmIDEpID09PSAxKT8gMTYgOiAzMiksIGFyckRlc3RydWN0aWJsZSwgMTY1MTAsIGFzdFByb3ApO1xufSBlbHNlIGlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4Nikge1xubGV0IHN1YkRlc3RydWN0ID0gcGFyc2VBcnJvd2FibGVTcHJlYWRPclJlc3QobGV4ZXJGbGFncywgc2Nvb3AsIDE2NTEwLCBiaW5kaW5nVHlwZSwgMCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCk7XG5kZXN0cnVjdGlibGUgfD0gc3ViRGVzdHJ1Y3Q7XG5pZiAoc3ByZWFkU3RhZ2UgPT09IDApIHNwcmVhZFN0YWdlID0gMTtcbn0gZWxzZSB7XG5sZXQgJHRwX2V4cHJTdGFydF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfZXhwclN0YXJ0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfZXhwclN0YXJ0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2V4cHJTdGFydF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCB3YXNQYXJlbiA9IHRva19nZXRUeXBlKCkgPT09IDE2NDcxO1xubGV0IGFzc2lnbmFibGUgPSBwYXJzZVZhbHVlKGxleGVyRmxhZ3MsIHRydWUsIDQsIGZhbHNlLCBhc3RQcm9wKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSA0OTI2NCkge1xuaWYgKGlzQXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J0Fzc2lnbm1lbnRFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgbGVmdDp1bmRlZmluZWQsIG9wZXJhdG9yOic9JywgcmlnaHQ6dW5kZWZpbmVkfSwgJ2xlZnQnKTtcbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbmRlc3RydWN0aWJsZSB8PSBwYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgJ3JpZ2h0Jyk7XG5BU1RfY2xvc2UoJHRwX2VsZW1lbnRTdGFydF9zdGFydCwgJHRwX2VsZW1lbnRTdGFydF9saW5lLCAkdHBfZWxlbWVudFN0YXJ0X2NvbHVtbik7XG59IGVsc2Uge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnQ2Fubm90IGFzc2lnbiB0byBsaHMgKHN0YXJ0aW5nIHdpdGggYCcgKyB0b2tfc2xpY2VJbnB1dCgkdHBfZWxlbWVudFN0YXJ0X3N0YXJ0LCAkdHBfZWxlbWVudFN0YXJ0X3N0b3ApKSArICdgKScsICR0cF9lbGVtZW50U3RhcnRfc3RhcnQsICR0cF9lbGVtZW50U3RhcnRfc3RvcCk7XG59XG59XG5pZiAoKCh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ4MCkgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NTEwKSkpIHtcbmFzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncywgJHRwX2V4cHJTdGFydF9zdGFydCwgJHRwX2V4cHJTdGFydF9zdG9wLCAkdHBfZXhwclN0YXJ0X2xpbmUsICR0cF9leHByU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbmFzc2lnbmFibGUgPSBzZXROb3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpO1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2UgaWYgKCgoKHdhc1BhcmVuICYmIGlzQXNzaWduYWJsZShhc3NpZ25hYmxlKSkpICYmICgoKGJpbmRpbmdUeXBlID09PSAwKSB8fCAoYmluZGluZ1R5cGUgPT09IDEpKSkpKSB7XG5kZXN0cnVjdGlibGUgfD0gMjtcbn0gZWxzZSBpZiAoKHdhc1BhcmVuIHx8IG5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSkpKSB7XG5kZXN0cnVjdGlibGUgfD0gMTtcbn0gZWxzZSB7XG5cbn1cbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjQ4MCkgYnJlYWs7XG5za2lwVG9FeHByZXNzaW9uU3RhcnRTcXVhcmVDbG9zZUNvbW1hKGxleGVyRmxhZ3MpO1xud2hpbGUgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5za2lwVG9FeHByZXNzaW9uU3RhcnRTcXVhcmVDbG9zZUNvbW1hKGxleGVyRmxhZ3MpO1xuQVNUX2FkZChhc3RQcm9wLCBudWxsKTtcbn1cbmlmIChzcHJlYWRTdGFnZSA9PT0gMSkge1xuc3ByZWFkU3RhZ2UgPSAyO1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59XG59XG5sZXhlckZsYWdzID0gbGV4ZXJGbGFnc0JlZm9yZVBhcmVuO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTEwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0aGUgY2xvc2luZyBicmFja2V0IGBdYCBmb3IgdGhlIGFycmF5LCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcERpdihsZXhlckZsYWdzKTtcbkFTVF9jbG9zZSgkdHBfYXJyYXlPcGVuX3N0YXJ0LCAkdHBfYXJyYXlPcGVuX2xpbmUsICR0cF9hcnJheU9wZW5fY29sdW1uKTtcbmlmIChza2lwSW5pdCA9PT0gdHJ1ZSkge1xuZGVzdHJ1Y3RpYmxlID0gcGFyc2VQYXR0ZXJuQXNzaWduTWF5YmUobGV4ZXJGbGFncywgJHRwX2FycmF5T3Blbl9zdGFydCwgJHRwX2FycmF5T3Blbl9saW5lLCAkdHBfYXJyYXlPcGVuX2NvbHVtbiwgZGVzdHJ1Y3RpYmxlLCBfYXN0UHJvcCk7XG59XG5yZXR1cm4gKGNvcHlQaWdnaWVzKGRlc3RydWN0aWJsZSwgYXNzaWduYWJsZVlpZWxkQXdhaXRTdGF0ZSkgfCAxMDI0KSBeIDEwMjQ7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdE91dGVyKGxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nVHlwZSwgc2tpcEluaXQsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApIHtcbnJldHVybiBwYXJzZU9iamVjdEFuZEFzc2lnbihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIHNraXBJbml0LCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0QW5kQXNzaWduKGxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nVHlwZSwgc2tpcEluaXQsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApIHtcbmxldCAkdHBfY3VybHlfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2N1cmx5X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfY3VybHlfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidPYmplY3RFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgcHJvcGVydGllczpbXX0pO1xubGV0IGRlc3RydWN0aWJsZSA9IHBhcnNlT2JqZWN0U2Fuc0Fzc2lnbihsZXhlckZsYWdzIHwgNDA5Niwgc2Nvb3AsIGJpbmRpbmdUeXBlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCAncHJvcGVydGllcycpO1xuQVNUX2Nsb3NlKCR0cF9jdXJseV9zdGFydCwgJHRwX2N1cmx5X2xpbmUsICR0cF9jdXJseV9jb2x1bW4pO1xuaWYgKHNraXBJbml0ID09PSB0cnVlKSB7XG5kZXN0cnVjdGlibGUgPSBwYXJzZVBhdHRlcm5Bc3NpZ25NYXliZShsZXhlckZsYWdzLCAkdHBfY3VybHlfc3RhcnQsICR0cF9jdXJseV9saW5lLCAkdHBfY3VybHlfY29sdW1uLCBkZXN0cnVjdGlibGUsIGFzdFByb3ApO1xufVxucmV0dXJuIGRlc3RydWN0aWJsZTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0U2Fuc0Fzc2lnbihvdXRlckxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nVHlwZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xubGV0IGxleGVyRmxhZ3MgPSAob3V0ZXJMZXhlckZsYWdzIHwgMjA4MCkgXiAyMDgwO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbmxldCBkZXN0cnVjdGlibGUgPSAwO1xubGV0IGhhc1RodW5kZXJQcm90byA9IGZhbHNlO1xuZG8ge1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ09iamVjdHMgY2FudCBoYXZlIGNvbW1hIHdpdGhvdXQgc29tZXRoaW5nIHByZWNlZGluZyBpdCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmxldCBjdXJyZW50RGVzdHJ1Y3QgPSBwYXJzZU9iamVjdFBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIGJpbmRpbmdUeXBlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbmlmICgoY3VycmVudERlc3RydWN0ICYgNTEyKSAhPT0gMCkge1xuY3VycmVudERlc3RydWN0IF49IDUxMjtcbmlmIChoYXNUaHVuZGVyUHJvdG8pIHtcbmRlc3RydWN0aWJsZSB8PSA0O1xufVxuaGFzVGh1bmRlclByb3RvID0gdHJ1ZTtcbn1cbmRlc3RydWN0aWJsZSB8PSBjdXJyZW50RGVzdHJ1Y3Q7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0ODApIGJyZWFrO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn0gd2hpbGUgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KTtcbmxleGVyRmxhZ3MgPSBvdXRlckxleGVyRmxhZ3M7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY1MTcpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGVkIHRoZSBjbG9zaW5nIGN1cmx5IGB9YCBmb3IgYW4gb2JqZWN0LCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcERpdihsZXhlckZsYWdzKTtcbnJldHVybiBkZXN0cnVjdGlibGU7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdFBhcnQobGV4ZXJGbGFncywgc2Nvb3AsIGJpbmRpbmdUeXBlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3N0YXJ0T2ZLZXlfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX3N0YXJ0T2ZLZXlfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3N0YXJ0T2ZLZXlfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdGFydE9mS2V5X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5pZiAoaXNJZGVudFRva2VuKCR0cF9zdGFydE9mS2V5X3R5cGUpKSB7XG5yZXR1cm4gcGFyc2VPYmplY3RQYXJ0RnJvbUlkZW50KGxleGVyRmxhZ3MsICR0cF9zdGFydE9mS2V5X3R5cGUsIHNjb29wLCBiaW5kaW5nVHlwZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCk7XG59XG5pZiAoJHRwX3N0YXJ0T2ZLZXlfdHlwZSA9PT0gMTY1MTcpIHtcbnJldHVybiAwO1xufVxuaWYgKGlzTnVtYmVyU3RyaW5nVG9rZW4oJHRwX3N0YXJ0T2ZLZXlfdHlwZSkpIHtcbnJldHVybiBwYXJzZU9iamVjdFBhcnRGcm9tTGl0ZXJhbChsZXhlckZsYWdzLCBzY29vcCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYmluZGluZ1R5cGUsIGFzdFByb3ApO1xufVxuaWYgKCR0cF9zdGFydE9mS2V5X3R5cGUgPT09IDE2NTA5KSB7XG5yZXR1cm4gcGFyc2VPYmplY3RQYXJ0RnJvbUNvbXB1dGVkKGxleGVyRmxhZ3MsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBiaW5kaW5nVHlwZSwgYXN0UHJvcCk7XG59XG5pZiAoJHRwX3N0YXJ0T2ZLZXlfdHlwZSA9PT0gMTY0ODYpIHtcbnJldHVybiBwYXJzZU9iamVjdFJlc3RTcHJlYWQobGV4ZXJGbGFncywgc2Nvb3AsIGJpbmRpbmdUeXBlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbn1cbmlmICgkdHBfc3RhcnRPZktleV90eXBlID09PSA4MjAwOSkge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbnJldHVybiBwYXJzZU9iamVjdE1ldGhvZEZyb21LZXkobGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZLZXlfc3RhcnQsICR0cF9zdGFydE9mS2V5X2xpbmUsICR0cF9zdGFydE9mS2V5X2NvbHVtbiwgJ2luaXQnLCB0cnVlLCAwLCA4MjAwOSwgMCwgMCwgYXN0UHJvcCk7XG59XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdVbmV4cGVjdGVkIHRva2VuLCB3YW50ZWQgdG8gcGFyc2UgYSBzdGFydCBvZiBhIHByb3BlcnR5IGluIGFuIG9iamVjdCBsaXRlcmFsL3BhdHRlcm4sIGdvdCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0TWV0aG9kRnJvbUtleShsZXhlckZsYWdzLCAkdHBfc3RhcnRPZlByb3Bfc3RhcnQsICR0cF9zdGFydE9mUHJvcF9saW5lLCAkdHBfc3RhcnRPZlByb3BfY29sdW1uLCBraW5kLCBpc1JlYWxNZXRob2QsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdGZfZ2V0VG9rZW5fdHlwZSwgJHRmX3NldFRva2VuX3R5cGUsIGFzdFByb3ApIHtcbmxldCAkdHBfa2V5U3RhcnRfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2tleVN0YXJ0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9rZXlTdGFydF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2tleVN0YXJ0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2tleVN0YXJ0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9rZXlTdGFydF9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuaWYgKGlzSWRlbnRUb2tlbigkdHBfa2V5U3RhcnRfdHlwZSkpIHtcbnNraXBBbnkobGV4ZXJGbGFncyk7XG5BU1Rfc2V0SWRlbnQoYXN0UHJvcCwgJHRwX2tleVN0YXJ0X3N0YXJ0LCAkdHBfa2V5U3RhcnRfc3RvcCwgJHRwX2tleVN0YXJ0X2xpbmUsICR0cF9rZXlTdGFydF9jb2x1bW4sICR0cF9rZXlTdGFydF9jYW5vbik7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzEpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGVkIHRvIHBhcnNlIGFuIG9wZW5pbmcgcGFyZW4sIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHBhcnNlT2JqZWN0TWV0aG9kKGxleGVyRmxhZ3MsICR0cF9zdGFydE9mUHJvcF9zdGFydCwgJHRwX3N0YXJ0T2ZQcm9wX2xpbmUsICR0cF9zdGFydE9mUHJvcF9jb2x1bW4sIGtpbmQsIGZhbHNlLCBpc1JlYWxNZXRob2QsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdGZfZ2V0VG9rZW5fdHlwZSwgJHRmX3NldFRva2VuX3R5cGUsIGFzdFByb3ApO1xufVxuaWYgKGlzTnVtYmVyU3RyaW5nVG9rZW4oJHRwX2tleVN0YXJ0X3R5cGUpKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuQVNUX3NldExpdGVyYWwoYXN0UHJvcCwgJHRwX2tleVN0YXJ0X3R5cGUsICR0cF9rZXlTdGFydF9zdGFydCwgJHRwX2tleVN0YXJ0X3N0b3AsICR0cF9rZXlTdGFydF9saW5lLCAkdHBfa2V5U3RhcnRfY29sdW1uLCAkdHBfa2V5U3RhcnRfY2Fub24pO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDcxKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdFeHBlY3RlZCB0byBwYXJzZSBhbiBvcGVuaW5nIHBhcmVuLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiBwYXJzZU9iamVjdE1ldGhvZChsZXhlckZsYWdzLCAkdHBfc3RhcnRPZlByb3Bfc3RhcnQsICR0cF9zdGFydE9mUHJvcF9saW5lLCAkdHBfc3RhcnRPZlByb3BfY29sdW1uLCBraW5kLCBmYWxzZSwgaXNSZWFsTWV0aG9kLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRmX2dldFRva2VuX3R5cGUsICR0Zl9zZXRUb2tlbl90eXBlLCBhc3RQcm9wKTtcbn1cbmlmICgkdHBfa2V5U3RhcnRfdHlwZSA9PT0gMTY1MDkpIHtcbnNraXBSZXgobGV4ZXJGbGFncyk7XG5wYXJzZUV4cHJlc3Npb24obGV4ZXJGbGFncywgYXN0UHJvcCk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY1MTApIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ01pc3NpbmcgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgbmFtZSwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnNraXBBbnkobGV4ZXJGbGFncyk7XG5pZiAodG9rX2dldFR5cGUoKSAhPT0gMTY0NzEpIHtcbnJldHVybiBUSFJPV19SQU5HRSgoJ0V4cGVjdGVkIHRvIHBhcnNlIGFuIG9wZW5pbmcgcGFyZW4sIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHBhcnNlT2JqZWN0TWV0aG9kKGxleGVyRmxhZ3MsICR0cF9zdGFydE9mUHJvcF9zdGFydCwgJHRwX3N0YXJ0T2ZQcm9wX2xpbmUsICR0cF9zdGFydE9mUHJvcF9jb2x1bW4sIGtpbmQsIHRydWUsIGlzUmVhbE1ldGhvZCwgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0Zl9nZXRUb2tlbl90eXBlLCAkdGZfc2V0VG9rZW5fdHlwZSwgYXN0UHJvcCk7XG59XG5USFJPV19SQU5HRSgoJ0V4cGVjdGVkIHRvIHBhcnNlIGFuIG9iamVjdCBtZXRob2Qga2V5LCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RQYXJ0RnJvbUlkZW50KGxleGVyRmxhZ3MsICR0cF9wcm9wTGVhZGluZ0lkZW50X3R5cGUsIHNjb29wLCBiaW5kaW5nVHlwZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xubGV0ICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xubGV0ICR0cF9hZnRlcklkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xuaWYgKCR0cF9hZnRlcklkZW50X3R5cGUgPT09IDE2NDg5KSB7XG5BU1Rfc2V0SWRlbnQoYXN0UHJvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUsICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24pO1xubGV0IGRlc3RydWN0aWJsZSA9IDA7XG5pZiAoKChvcHRpb25zX3dlYkNvbXBhdCA9PT0gdHJ1ZSkgJiYgKCR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uID09PSAnX19wcm90b19fJykpKSB7XG5kZXN0cnVjdGlibGUgPSA1MTI7XG59XG5yZXR1cm4gZGVzdHJ1Y3RpYmxlIHwgcGFyc2VPYmplY3RQcm9wZXJ0eUZyb21Db2xvbihsZXhlckZsYWdzLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCBzY29vcCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYmluZGluZ1R5cGUsIGZhbHNlLCBhc3RQcm9wKTtcbn1cbmlmICgkdHBfYWZ0ZXJJZGVudF90eXBlID09PSAxNjQ3MSkge1xuQVNUX3NldElkZW50KGFzdFByb3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uKTtcbnJldHVybiBwYXJzZU9iamVjdE1ldGhvZChsZXhlckZsYWdzLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCAnaW5pdCcsIGZhbHNlLCB0cnVlLCAwLCAwLCAwLCAwLCBhc3RQcm9wKTtcbn1cbmlmICgoKCR0cF9hZnRlcklkZW50X3R5cGUgPT09IDE2NDgwKSB8fCAoJHRwX2FmdGVySWRlbnRfdHlwZSA9PT0gMTY1MTcpKSkge1xucmV0dXJuIHBhcnNlT2JqZWN0U2hvcnRoYW5kKGxleGVyRmxhZ3MsICR0cF9wcm9wTGVhZGluZ0lkZW50X3R5cGUsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSwgc2Nvb3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApO1xufVxuaWYgKCR0cF9hZnRlcklkZW50X3R5cGUgPT09IDQ5MjY0KSB7XG5yZXR1cm4gcGFyc2VPYmplY3RTaG9ydGhhbmRXaXRoSW5pdChsZXhlckZsYWdzLCAkdHBfcHJvcExlYWRpbmdJZGVudF90eXBlLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbn1cbmlmICgkdHBfcHJvcExlYWRpbmdJZGVudF90eXBlID09PSAyMDc0KSB7XG5pZiAoIWFsbG93QXN5bmNGdW5jdGlvbnMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQXN5bmMgZnVuY3Rpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50bHkgdGFyZ2V0ZWQgbGFuZ3VhZ2UgdmVyc2lvbicsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICh0b2tfZ2V0Tmx3YXMoKSA9PT0gdHJ1ZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBc3luYyBtZXRob2RzIGFyZSBhIHJlc3RyaWN0ZWQgcHJvZHVjdGlvbiBhbmQgY2Fubm90IGhhdmUgYSBuZXdsaW5lIGZvbGxvd2luZyBpdCcsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCB0b2tfZ2V0U3RhcnQoKSk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gODIwMDkpIHtcbmlmICghYWxsb3dBc3luY0dlbmVyYXRvcnMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQXN5bmMgZ2VuZXJhdG9yIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnRseSB0YXJnZXRlZCBsYW5ndWFnZSB2ZXJzaW9uJywgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcEFueShsZXhlckZsYWdzKTtcbnJldHVybiBwYXJzZU9iamVjdE1ldGhvZEZyb21LZXkobGV4ZXJGbGFncywgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUsICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiwgJ2luaXQnLCB0cnVlLCAyMDc0LCA4MjAwOSwgMCwgMCwgYXN0UHJvcCk7XG59XG5yZXR1cm4gcGFyc2VPYmplY3RNZXRob2RGcm9tS2V5KGxleGVyRmxhZ3MsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICdpbml0JywgdHJ1ZSwgMjA3NCwgMCwgMCwgMCwgYXN0UHJvcCk7XG59XG5pZiAoJHRwX3Byb3BMZWFkaW5nSWRlbnRfdHlwZSA9PT0gMjA5Nikge1xucmV0dXJuIHBhcnNlT2JqZWN0TWV0aG9kRnJvbUtleShsZXhlckZsYWdzLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCAnZ2V0JywgZmFsc2UsIDAsIDAsIDIwOTYsIDAsIGFzdFByb3ApO1xufVxuaWYgKCR0cF9wcm9wTGVhZGluZ0lkZW50X3R5cGUgPT09IDIxMTIpIHtcbnJldHVybiBwYXJzZU9iamVjdE1ldGhvZEZyb21LZXkobGV4ZXJGbGFncywgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUsICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiwgJ3NldCcsIGZhbHNlLCAwLCAwLCAwLCAyMTEyLCBhc3RQcm9wKTtcbn1cbmlmICgkdHBfcHJvcExlYWRpbmdJZGVudF90eXBlID09PSAyMTEzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ09iamVjdCBtZW1iZXJzIGNhbiBub3QgYmUgXCJzdGF0aWNcIicsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgoKCgnVW5leHBlY3RlZCB0b2tlbiBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBhZnRlciBzdGFydCBvZiBwcm9wZXJ0eSBgJykgKyAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbikgKyAnYCB3aGlsZSB0cnlpbmcgdG8gcGFyc2UgYW4gb2JqZWN0IHByb3BlcnR5L21ldGhvZCcsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlGcm9tQ29sb24obGV4ZXJGbGFncywgJHRwX3N0YXJ0T2ZLZXlfc3RhcnQsICR0cF9zdGFydE9mS2V5X2xpbmUsICR0cF9zdGFydE9mS2V5X2NvbHVtbiwgc2Nvb3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGJpbmRpbmdUeXBlLCBpc0NvbXB1dGVkLCBhc3RQcm9wKSB7XG5za2lwUmV4KGxleGVyRmxhZ3MpO1xuaWYgKGJhYmVsQ29tcGF0KSB7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTpOT0RFX05BTUVfUFJPUEVSVFksIGxvYzp1bmRlZmluZWQsIGtleTp1bmRlZmluZWQsIG1ldGhvZDpmYWxzZSwgY29tcHV0ZWQ6aXNDb21wdXRlZCwgdmFsdWU6dW5kZWZpbmVkLCBzaG9ydGhhbmQ6ZmFsc2V9LCAna2V5Jyk7XG59IGVsc2Uge1xuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6Tk9ERV9OQU1FX1BST1BFUlRZLCBsb2M6dW5kZWZpbmVkLCBrZXk6dW5kZWZpbmVkLCBraW5kOidpbml0JywgbWV0aG9kOmZhbHNlLCBjb21wdXRlZDppc0NvbXB1dGVkLCB2YWx1ZTp1bmRlZmluZWQsIHNob3J0aGFuZDpmYWxzZX0sICdrZXknKTtcbn1cbmxldCBkZXN0cnVjdGlibGUgPSBfcGFyc2VPYmplY3RQcm9wZXJ0eUZyb21Db2xvbihsZXhlckZsYWdzLCBzY29vcCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYmluZGluZ1R5cGUpO1xuQVNUX2Nsb3NlKCR0cF9zdGFydE9mS2V5X3N0YXJ0LCAkdHBfc3RhcnRPZktleV9saW5lLCAkdHBfc3RhcnRPZktleV9jb2x1bW4pO1xucmV0dXJuIGRlc3RydWN0aWJsZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZU9iamVjdFByb3BlcnR5RnJvbUNvbG9uKGxleGVyRmxhZ3MsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBiaW5kaW5nVHlwZSkge1xuaWYgKGlzSWRlbnRUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucmV0dXJuIHBhcnNlT2JqZWN0UHJvcGVydHlWYWx1ZUZyb21JZGVudChsZXhlckZsYWdzLCBzY29vcCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYmluZGluZ1R5cGUpO1xufVxubGV0ICR0cF9zdGFydF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfc3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9zdGFydF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9zdGFydF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUxMykge1xubGV0IGRlc3RydWN0aWJsZSA9IHBhcnNlT2JqZWN0T3V0ZXIobGV4ZXJGbGFncywgc2Nvb3AsIGJpbmRpbmdUeXBlLCB0cnVlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCAndmFsdWUnKTtcbmxldCBvYmpBc3NpZ25hYmxlID0gKChkZXN0cnVjdGlibGUgJiAxKT8gMTYgOiAzMik7XG5pZiAoKCh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkgfHwgKHRva19nZXRUeXBlKCkgPT09IDE2NTE3KSkpIHtcbnJldHVybiBkZXN0cnVjdGlibGU7XG59XG5pZiAoNCAmIGRlc3RydWN0aWJsZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnT2JqZWN0IHBhdHRlcm4gY29udGFpbmVkIHBhcnRzIGNhdXNlIGl0IG5vdCB0byBiZSB2YWxpZCBhcyBhIHJlZ3VsYXIgb2JqZWN0IGxpdGVyYWwgc28gdGhlIG5leHQgdG9rZW4gYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaXMgaWxsZWdhbCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmxldCBleHByQXNzaWduYWJsZSA9IHBhcnNlVmFsdWVUYWlsKGxleGVyRmxhZ3MsICR0cF9zdGFydF9zdGFydCwgJHRwX3N0YXJ0X2xpbmUsICR0cF9zdGFydF9jb2x1bW4sIG9iakFzc2lnbmFibGUsIDQsIGZhbHNlLCAndmFsdWUnKTtcbmxldCB3YXNBc3NpZ25tZW50ID0gdG9rX2dldFR5cGUoKSA9PT0gNDkyNjQ7XG5leHByQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfc3RhcnRfc3RhcnQsICR0cF9zdGFydF9zdG9wLCAkdHBfc3RhcnRfbGluZSwgJHRwX3N0YXJ0X2NvbHVtbiwgZXhwckFzc2lnbmFibGUsICd2YWx1ZScpO1xuaWYgKCh3YXNBc3NpZ25tZW50IHx8IGlzQXNzaWduYWJsZShleHByQXNzaWduYWJsZSkpKSB7XG5yZXR1cm4gY29weVBpZ2dpZXMoMiwgZXhwckFzc2lnbmFibGUpO1xufVxucmV0dXJuIGNvcHlQaWdnaWVzKDEsIGV4cHJBc3NpZ25hYmxlKTtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjUwOSkge1xubGV0IGRlc3RydWN0aWJsZSA9IHBhcnNlQXJyYXlPdXRlcihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIHRydWUsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsICd2YWx1ZScpO1xubGV0IG9iakFzc2lnbmFibGUgPSAoKGRlc3RydWN0aWJsZSAmIDEpPyAxNiA6IDMyKTtcbmlmICgoKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTY1MTcpKSkge1xucmV0dXJuIGRlc3RydWN0aWJsZTtcbn1cbmlmICg0ICYgZGVzdHJ1Y3RpYmxlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdPYmplY3QgcGF0dGVybiBjb250YWluZWQgcGFydHMgY2F1c2UgaXQgbm90IHRvIGJlIHZhbGlkIGFzIGEgcmVndWxhciBvYmplY3QgbGl0ZXJhbCBzbyB0aGUgbmV4dCB0b2tlbiBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpcyBpbGxlZ2FsJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxubGV0IGV4cHJBc3NpZ25hYmxlID0gcGFyc2VWYWx1ZVRhaWwobGV4ZXJGbGFncywgJHRwX3N0YXJ0X3N0YXJ0LCAkdHBfc3RhcnRfbGluZSwgJHRwX3N0YXJ0X2NvbHVtbiwgb2JqQXNzaWduYWJsZSwgNCwgZmFsc2UsICd2YWx1ZScpO1xubGV0IHdhc0Fzc2lnbm1lbnQgPSB0b2tfZ2V0VHlwZSgpID09PSA0OTI2NDtcbmV4cHJBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF9zdGFydF9zdGFydCwgJHRwX3N0YXJ0X3N0b3AsICR0cF9zdGFydF9saW5lLCAkdHBfc3RhcnRfY29sdW1uLCBleHByQXNzaWduYWJsZSwgJ3ZhbHVlJyk7XG5pZiAoKHdhc0Fzc2lnbm1lbnQgfHwgaXNBc3NpZ25hYmxlKGV4cHJBc3NpZ25hYmxlKSkpIHtcbnJldHVybiBjb3B5UGlnZ2llcygyLCBleHByQXNzaWduYWJsZSk7XG59XG5yZXR1cm4gY29weVBpZ2dpZXMoMSwgZXhwckFzc2lnbmFibGUpO1xufVxubGV0IHZhbHVlQXNzaWduYWJsZSA9IHBhcnNlVmFsdWUobGV4ZXJGbGFncywgdHJ1ZSwgNCwgZmFsc2UsICd2YWx1ZScpO1xubGV0IHdhc0Fzc2lnbm1lbnQgPSB0b2tfZ2V0VHlwZSgpID09PSA0OTI2NDtcbnZhbHVlQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfc3RhcnRfc3RhcnQsICR0cF9zdGFydF9zdG9wLCAkdHBfc3RhcnRfbGluZSwgJHRwX3N0YXJ0X2NvbHVtbiwgdmFsdWVBc3NpZ25hYmxlLCAndmFsdWUnKTtcbmlmICgod2FzQXNzaWdubWVudCB8fCBpc0Fzc2lnbmFibGUodmFsdWVBc3NpZ25hYmxlKSkpIHtcbnJldHVybiBjb3B5UGlnZ2llcygyLCB2YWx1ZUFzc2lnbmFibGUpO1xufVxucmV0dXJuIGNvcHlQaWdnaWVzKDEsIHZhbHVlQXNzaWduYWJsZSk7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5VmFsdWVGcm9tSWRlbnQobGV4ZXJGbGFncywgc2Nvb3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGJpbmRpbmdUeXBlKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBJZGVudFNhZmVTbG93QW5kRXhwZW5zaXZlKGxleGVyRmxhZ3MsIGZhbHNlKTtcbmxldCAkdHBfYWZ0ZXJFeHByX3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xuaWYgKCgoJHRwX2FmdGVyRXhwcl90eXBlID09PSAxNjQ4MCkgfHwgKCR0cF9hZnRlckV4cHJfdHlwZSA9PT0gMTY1MTcpKSkge1xubGV0IGFzc2lnbmFibGVPckVycm9yTXNnID0gbm9uRmF0YWxCaW5kaW5nSWRlbnRDaGVjaygkdHBfaWRlbnRfdHlwZSwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSwgbGV4ZXJGbGFncyk7XG5pZiAoYXNzaWduYWJsZU9yRXJyb3JNc2cubGVuZ3RoICE9PSAwKSB7XG5sZXQgdmFsdWVBc3NpZ25hYmxlID0gcGFyc2VWYWx1ZUFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCB0cnVlLCAndmFsdWUnKTtcbnJldHVybiBjb3B5UGlnZ2llcygxLCB2YWx1ZUFzc2lnbmFibGUpO1xufVxuQVNUX3NldElkZW50KCd2YWx1ZScsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24pO1xuU0NPUEVfYWN0dWFsbHlBZGRCaW5kaW5nKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgJHRwX2lkZW50X2Nhbm9uKTtcbnJldHVybiAwO1xufVxuaWYgKCR0cF9hZnRlckV4cHJfdHlwZSA9PT0gNDkyNjQpIHtcbmxldCBhc3NpZ25hYmxlT3JFcnJvck1zZyA9IG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGxleGVyRmxhZ3MpO1xuaWYgKGFzc2lnbmFibGVPckVycm9yTXNnLmxlbmd0aCAhPT0gMCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdUaGUgbGhzIHdhcyBub3QgYXNzaWduYWJsZSBzbyB0aGlzIGlzIGFuIGVycm9yJywgJHRwX2lkZW50X3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cblNDT1BFX2FjdHVhbGx5QWRkQmluZGluZyhsZXhlckZsYWdzLCBzY29vcCwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSk7XG5hZGROYW1lVG9FeHBvcnRzKGV4cG9ydGVkTmFtZXMsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbik7XG5hZGRCaW5kaW5nVG9FeHBvcnRzKGV4cG9ydGVkQmluZGluZ3MsICR0cF9pZGVudF9jYW5vbik7XG5BU1Rfc2V0SWRlbnQoJ3ZhbHVlJywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbik7XG5sZXQgcmhzQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgMzIsICd2YWx1ZScpO1xucmV0dXJuIGNvcHlQaWdnaWVzKDAsIHJoc0Fzc2lnbmFibGUpO1xufVxubGV0IHZhbHVlQXNzaWduYWJsZSA9IHBhcnNlVmFsdWVBZnRlcklkZW50KGxleGVyRmxhZ3MsICR0cF9pZGVudF90eXBlLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgJHRwX2lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSwgdHJ1ZSwgJ3ZhbHVlJyk7XG5pZiAobm90QXNzaWduYWJsZSh2YWx1ZUFzc2lnbmFibGUpKSB7XG5sZXQgcmhzQXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfbGluZSwgJHRwX2lkZW50X2NvbHVtbiwgdmFsdWVBc3NpZ25hYmxlLCAndmFsdWUnKTtcbnJldHVybiBjb3B5UGlnZ2llcygxLCByaHNBc3NpZ25hYmxlKTtcbn1cbmxldCB3YXNBc3NpZ24gPSB0b2tfZ2V0VHlwZSgpID09PSA0OTI2NDtcbmxldCByaHNBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCB2YWx1ZUFzc2lnbmFibGUsICd2YWx1ZScpO1xuaWYgKCh3YXNBc3NpZ24gfHwgaXNBc3NpZ25hYmxlKHJoc0Fzc2lnbmFibGUpKSkge1xucmV0dXJuIGNvcHlQaWdnaWVzKDIsIHJoc0Fzc2lnbmFibGUpO1xufVxucmV0dXJuIGNvcHlQaWdnaWVzKDEsIHJoc0Fzc2lnbmFibGUpO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RTaG9ydGhhbmQobGV4ZXJGbGFncywgJHRwX3Byb3BMZWFkaW5nSWRlbnRfdHlwZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUsICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCBzY29vcCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xubGV0IHJlcG9ydCA9IG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX3Byb3BMZWFkaW5nSWRlbnRfdHlwZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uLCBiaW5kaW5nVHlwZSwgbGV4ZXJGbGFncyk7XG5pZiAoKCgoKHJlcG9ydC5sZW5ndGggPiAwKSAmJiAoJHRwX3Byb3BMZWFkaW5nSWRlbnRfdHlwZSAhPT0gMjA4OCkpKSAmJiAoJHRwX3Byb3BMZWFkaW5nSWRlbnRfdHlwZSAhPT0gMjA3MikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UocmVwb3J0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCk7XG59XG5TQ09QRV9hY3R1YWxseUFkZEJpbmRpbmcobGV4ZXJGbGFncywgc2Nvb3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUpO1xuYWRkTmFtZVRvRXhwb3J0cyhleHBvcnRlZE5hbWVzLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24pO1xuYWRkQmluZGluZ1RvRXhwb3J0cyhleHBvcnRlZEJpbmRpbmdzLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbik7XG5pZiAoYmFiZWxDb21wYXQpIHtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOk5PREVfTkFNRV9QUk9QRVJUWSwgbG9jOnVuZGVmaW5lZCwga2V5OkFTVF9nZXRJZGVudE5vZGUoJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUsICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24pLCBtZXRob2Q6ZmFsc2UsIGNvbXB1dGVkOmZhbHNlLCB2YWx1ZTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uKSwgc2hvcnRoYW5kOnRydWUsIGV4dHJhOntzaG9ydGhhbmQ6dHJ1ZX19KTtcbn0gZWxzZSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTpOT0RFX05BTUVfUFJPUEVSVFksIGxvYzp1bmRlZmluZWQsIGtleTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uKSwga2luZDonaW5pdCcsIG1ldGhvZDpmYWxzZSwgY29tcHV0ZWQ6ZmFsc2UsIHZhbHVlOkFTVF9nZXRJZGVudE5vZGUoJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X2xpbmUsICR0cF9wcm9wTGVhZGluZ0lkZW50X2NvbHVtbiwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24pLCBzaG9ydGhhbmQ6dHJ1ZX0pO1xufVxuQVNUX2Nsb3NlKCR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4pO1xuaWYgKCR0cF9wcm9wTGVhZGluZ0lkZW50X3R5cGUgPT09IDIwNzUpIHtcbnJldHVybiA2NDtcbn1cbnJldHVybiAoKHJlcG9ydC5sZW5ndGggPiAwKT8gMSA6IDApO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RTaG9ydGhhbmRXaXRoSW5pdChsZXhlckZsYWdzLCAkdHBfcHJvcExlYWRpbmdJZGVudF90eXBlLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKSB7XG5mYXRhbEJpbmRpbmdJZGVudENoZWNrKCR0cF9wcm9wTGVhZGluZ0lkZW50X3R5cGUsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGxleGVyRmxhZ3MpO1xuU0NPUEVfYWN0dWFsbHlBZGRCaW5kaW5nKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RhcnQsICR0cF9wcm9wTGVhZGluZ0lkZW50X3N0b3AsICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY2Fub24pO1xuaWYgKGJhYmVsQ29tcGF0KSB7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTpOT0RFX05BTUVfUFJPUEVSVFksIGxvYzp1bmRlZmluZWQsIGtleTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uKSwgbWV0aG9kOmZhbHNlLCBjb21wdXRlZDpmYWxzZSwgdmFsdWU6QVNUX2dldElkZW50Tm9kZSgkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbiksIHNob3J0aGFuZDp0cnVlLCBleHRyYTp7c2hvcnRoYW5kOnRydWV9fSk7XG59IGVsc2Uge1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6Tk9ERV9OQU1FX1BST1BFUlRZLCBsb2M6dW5kZWZpbmVkLCBrZXk6QVNUX2dldElkZW50Tm9kZSgkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfc3RvcCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jYW5vbiksIGtpbmQ6J2luaXQnLCBtZXRob2Q6ZmFsc2UsIGNvbXB1dGVkOmZhbHNlLCB2YWx1ZTpBU1RfZ2V0SWRlbnROb2RlKCR0cF9wcm9wTGVhZGluZ0lkZW50X3N0YXJ0LCAkdHBfcHJvcExlYWRpbmdJZGVudF9zdG9wLCAkdHBfcHJvcExlYWRpbmdJZGVudF9saW5lLCAkdHBfcHJvcExlYWRpbmdJZGVudF9jb2x1bW4sICR0cF9wcm9wTGVhZGluZ0lkZW50X2Nhbm9uKSwgc2hvcnRoYW5kOnRydWV9KTtcbn1cbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKCd2YWx1ZScsIHt0eXBlOidBc3NpZ25tZW50RXhwcmVzc2lvbicsIGxvYzp1bmRlZmluZWQsIGxlZnQ6dW5kZWZpbmVkLCBvcGVyYXRvcjonPScsIHJpZ2h0OnVuZGVmaW5lZH0sICdsZWZ0Jyk7XG5za2lwVG9FeHByZXNzaW9uU3RhcnQobGV4ZXJGbGFncyk7XG5sZXQgbm93QXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCAncmlnaHQnKTtcbkFTVF9jbG9zZSgkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uKTtcbkFTVF9jbG9zZSgkdHBfcHJvcExlYWRpbmdJZGVudF9zdGFydCwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfbGluZSwgJHRwX3Byb3BMZWFkaW5nSWRlbnRfY29sdW1uKTtcbmlmICgkdHBfcHJvcExlYWRpbmdJZGVudF90eXBlID09PSAyMDc1KSB7XG5yZXR1cm4gY29weVBpZ2dpZXMoNjgsIG5vd0Fzc2lnbmFibGUpO1xufVxucmV0dXJuIGNvcHlQaWdnaWVzKDQsIG5vd0Fzc2lnbmFibGUpO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RQYXJ0RnJvbUxpdGVyYWwobGV4ZXJGbGFncywgc2Nvb3AsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGJpbmRpbmdUeXBlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2xpdF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfbGl0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9saXRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9saXRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfbGl0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9saXRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBUb0NvbG9uUGFyZW5PcGVuKGxleGVyRmxhZ3MpO1xuQVNUX3NldExpdGVyYWwoYXN0UHJvcCwgJHRwX2xpdF90eXBlLCAkdHBfbGl0X3N0YXJ0LCAkdHBfbGl0X3N0b3AsICR0cF9saXRfbGluZSwgJHRwX2xpdF9jb2x1bW4sICR0cF9saXRfY2Fub24pO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg5KSB7XG5sZXQgZGVzdHJ1Y3RpYmxlX2ZvclBpZ2dpZXMgPSAwO1xuaWYgKCgob3B0aW9uc193ZWJDb21wYXQgPT09IHRydWUpICYmICgkdHBfbGl0X2Nhbm9uID09PSAnX19wcm90b19fJykpKSB7XG5kZXN0cnVjdGlibGVfZm9yUGlnZ2llcyB8PSA1MTI7XG59XG5yZXR1cm4gZGVzdHJ1Y3RpYmxlX2ZvclBpZ2dpZXMgfCBwYXJzZU9iamVjdFByb3BlcnR5RnJvbUNvbG9uKGxleGVyRmxhZ3MsICR0cF9saXRfc3RhcnQsICR0cF9saXRfbGluZSwgJHRwX2xpdF9jb2x1bW4sIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBiaW5kaW5nVHlwZSwgZmFsc2UsIGFzdFByb3ApO1xufVxuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NDcxKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ09iamVjdCBsaXRlcmFsIGtleXMgdGhhdCBhcmUgc3RyaW5ncyBvciBudW1iZXJzIG11c3QgYmUgYSBtZXRob2Qgb3IgaGF2ZSBhIGNvbG9uJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIHBhcnNlT2JqZWN0TWV0aG9kKGxleGVyRmxhZ3MsICR0cF9saXRfc3RhcnQsICR0cF9saXRfbGluZSwgJHRwX2xpdF9jb2x1bW4sICdpbml0JywgZmFsc2UsIHRydWUsIDAsIDAsIDAsIDAsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RQYXJ0RnJvbUNvbXB1dGVkKGxleGVyRmxhZ3MsIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBiaW5kaW5nVHlwZSwgYXN0UHJvcCkge1xubGV0ICR0cF9rZXlTdGFydF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfa2V5U3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9rZXlTdGFydF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xubGV0IGFzc2lnbmFibGVfZm9yUGlnZ2llcyA9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCBhc3RQcm9wKTtcbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjUxMCkge1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDgwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBleHByZXNzaW9uIG9mIGEgY29tcHV0ZWQgcHJvcGVydHkga2V5IGNhbiBub3QgYmUgYSBjb21tYSBleHByZXNzaW9uJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCgnTWlzc2luZyBjbG9zaW5nIHNxdWFyZSBicmFja2V0IGZvciBjb21wdXRlZCBwcm9wZXJ0eSBuYW1lLCBmb3VuZCBgJyArIHRva19zbGljZUlucHV0KHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKSkgKyAnYCBpbnN0ZWFkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuc2tpcFRvQ29sb25QYXJlbk9wZW4obGV4ZXJGbGFncyk7XG5sZXQgJHRwX2FmdGVyS2V5X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xuaWYgKCR0cF9hZnRlcktleV90eXBlID09PSAxNjQ4OSkge1xubGV0IGFzc2lnbmFibGUgPSBwYXJzZU9iamVjdFByb3BlcnR5RnJvbUNvbG9uKGxleGVyRmxhZ3MsICR0cF9rZXlTdGFydF9zdGFydCwgJHRwX2tleVN0YXJ0X2xpbmUsICR0cF9rZXlTdGFydF9jb2x1bW4sIHNjb29wLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBiaW5kaW5nVHlwZSwgdHJ1ZSwgYXN0UHJvcCk7XG5yZXR1cm4gY29weVBpZ2dpZXMoYXNzaWduYWJsZSwgYXNzaWduYWJsZV9mb3JQaWdnaWVzKTtcbn1cbmlmICgkdHBfYWZ0ZXJLZXlfdHlwZSA9PT0gMTY0NzEpIHtcbmxldCBhc3NpZ25hYmxlID0gcGFyc2VPYmplY3RNZXRob2QobGV4ZXJGbGFncywgJHRwX2tleVN0YXJ0X3N0YXJ0LCAkdHBfa2V5U3RhcnRfbGluZSwgJHRwX2tleVN0YXJ0X2NvbHVtbiwgJ2luaXQnLCB0cnVlLCB0cnVlLCAwLCAwLCAwLCAwLCBhc3RQcm9wKTtcbnJldHVybiBjb3B5UGlnZ2llcyhhc3NpZ25hYmxlLCBhc3NpZ25hYmxlX2ZvclBpZ2dpZXMpO1xufVxuVEhST1dfUkFOR0UoKCdPYmplY3QgbGl0ZXJhbDsgY29tcHV0ZWQgcHJvcGVydHkgbXVzdCBiZSBmb2xsb3dlZCBieSBhIGNvbG9uIChwcm9wZXJ0eSkgcGFyZW4gKG1ldGhvZCksIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArIGAnIGluc3RlYWQnYCwgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RSZXN0U3ByZWFkKGxleGVyRmxhZ3MsIHNjb29wLCBiaW5kaW5nVHlwZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xuaWYgKCgodGFyZ2V0RXNWZXJzaW9uIDwgOSkgJiYgKHRhcmdldEVzVmVyc2lvbiAhPT0gSW5maW5pdHkpKSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdPYmplY3Qgc3ByZWFkL3Jlc3QgcmVxdWlyZXMgdGhlIHJlcXVlc3RlZCB2ZXJzaW9uIHRvIGJlIEVTOSsnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5yZXR1cm4gcGFyc2VBcnJvd2FibGVTcHJlYWRPclJlc3QobGV4ZXJGbGFncywgc2Nvb3AsIDE2NTE3LCBiaW5kaW5nVHlwZSwgMCwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdE1ldGhvZChsZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCBraW5kLCBpc0NvbXB1dGVkLCBpc1JlYWxNZXRob2QsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdGZfZ2V0VG9rZW5fdHlwZSwgJHRmX3NldFRva2VuX3R5cGUsIGFzdFByb3ApIHtcbmlmIChiYWJlbENvbXBhdCkge1xuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6Tk9ERV9OQU1FX01FVEhPRF9PQkpFQ1QsIGxvYzp1bmRlZmluZWQsIGtleTp1bmRlZmluZWQsIG1ldGhvZDppc1JlYWxNZXRob2QsIGdlbmVyYXRvcjp1bmRlZmluZWQsIGFzeW5jOnVuZGVmaW5lZCwgaWQ6dW5kZWZpbmVkLCBwYXJhbXM6W10sIGtpbmQ6KChraW5kID09PSAnaW5pdCcpPyAnbWV0aG9kJyA6IGtpbmQpLCBjb21wdXRlZDppc0NvbXB1dGVkLCBib2R5OnVuZGVmaW5lZH0sICdrZXknKTtcbn0gZWxzZSB7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTpOT0RFX05BTUVfTUVUSE9EX09CSkVDVCwgbG9jOnVuZGVmaW5lZCwga2V5OnVuZGVmaW5lZCwga2luZDpraW5kLCBtZXRob2Q6aXNSZWFsTWV0aG9kLCBjb21wdXRlZDppc0NvbXB1dGVkLCB2YWx1ZTp1bmRlZmluZWQsIHNob3J0aGFuZDpmYWxzZX0sICdrZXknKTtcbn1cbmlmIChhY29ybkNvbXBhdCkge1xubGV0ICR0cF9wYXJlbl9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfcGFyZW5fY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9wYXJlbl9zdGFydCA9IHRva19nZXRTdGFydCgpO1xucGFyc2VGdW5jdGlvbkFmdGVyS2V5d29yZChsZXhlckZsYWdzLCBudWxsLCBmYWxzZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRmX2dldFRva2VuX3R5cGUsICR0Zl9zZXRUb2tlbl90eXBlLCAkdHBfcGFyZW5fc3RhcnQsICR0cF9wYXJlbl9saW5lLCAkdHBfcGFyZW5fY29sdW1uLCAxLCAndmFsdWUnKTtcbn0gZWxzZSB7XG5wYXJzZUZ1bmN0aW9uQWZ0ZXJLZXl3b3JkKGxleGVyRmxhZ3MsIG51bGwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRydWUsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdGZfZ2V0VG9rZW5fdHlwZSwgJHRmX3NldFRva2VuX3R5cGUsICR0cF9tZXRob2RTdGFydF9zdGFydCwgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sIDEsICd2YWx1ZScpO1xufVxuQVNUX2Nsb3NlKCR0cF9tZXRob2RTdGFydF9zdGFydCwgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4pO1xucmV0dXJuIDE7XG59XG5mdW5jdGlvbiBwYXJzZVBhdHRlcm5Bc3NpZ25NYXliZShsZXhlckZsYWdzLCAkdHBfcGF0dGVyblN0YXJ0X3N0YXJ0LCAkdHBfcGF0dGVyblN0YXJ0X2xpbmUsICR0cF9wYXR0ZXJuU3RhcnRfY29sdW1uLCBkZXN0cnVjdGlibGUsIGFzdFByb3ApIHtcbnZlcmlmeURlc3RydWN0aWJsZShkZXN0cnVjdGlibGUpO1xuaWYgKCFpc0FueUFzc2lnbm1lbnRPcCgpKSB7XG5yZXR1cm4gZGVzdHJ1Y3RpYmxlO1xufVxuaWYgKHRva19nZXRUeXBlKCkgIT09IDQ5MjY0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBjb21wb3VuZC1hc3NpZ24gdG8gYW4gYXJyYXkgbGl0ZXJhbCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICgoZGVzdHJ1Y3RpYmxlICYgMSkgPT09IDEpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVHJpZWQgdG8gZGVzdHJ1Y3R1cmUgc29tZXRoaW5nIHRoYXQgaXMgbm90IGRlc3RydWN0aWJsZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmRlc3RydWN0aWJsZSA9IChkZXN0cnVjdGlibGUgfCA0KSBeIDQ7XG5BU1RfZGVzdHJ1Y3QoYXN0UHJvcCk7XG5BU1Rfd3JhcENsb3NlZEN1c3RvbShhc3RQcm9wLCB7dHlwZTonQXNzaWdubWVudEV4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBsZWZ0OnVuZGVmaW5lZCwgb3BlcmF0b3I6Jz0nLCByaWdodDp1bmRlZmluZWR9LCAnbGVmdCcpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xuZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlRXhwcmVzc2lvbihsZXhlckZsYWdzLCAncmlnaHQnKTtcbkFTVF9jbG9zZSgkdHBfcGF0dGVyblN0YXJ0X3N0YXJ0LCAkdHBfcGF0dGVyblN0YXJ0X2xpbmUsICR0cF9wYXR0ZXJuU3RhcnRfY29sdW1uKTtcbnJldHVybiBkZXN0cnVjdGlibGU7XG59XG5mdW5jdGlvbiBwYXJzZUNsYXNzRGVjbGFyYXRpb24obGV4ZXJGbGFncywgc2Nvb3AsIG9wdGlvbmFsSWRlbnQsIGlzTGFiZWxsZWQsIGZkU3RhdGUsIGFzdFByb3ApIHtcbmxldCBvcmlnaW5hbE91dGVyTGV4ZXJGbGFncyA9IGxleGVyRmxhZ3M7XG5sZXQgJHRwX2NsYXNzX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9jbGFzc19jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX2NsYXNzX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2NsYXNzX3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xuaWYgKCgoKChpc0xhYmVsbGVkID09PSB0cnVlKSB8fCAoZmRTdGF0ZSA9PT0gMSkpKSB8fCAoZmRTdGF0ZSA9PT0gMikpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0Nhbm5vdCBwYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIGhlcmUsIG9ubHkgZXhwZWN0aW5nIHN0YXRlbWVudHMgaGVyZScsICR0cF9jbGFzc19zdGFydCwgJHRwX2NsYXNzX3N0b3ApO1xufVxubGV4ZXJGbGFncyA9ICgobGV4ZXJGbGFncyB8IDgxOTIpIHwgNjE3NikgXiA2MTc2O1xuc2tpcFRvSWRlbnRDdXJseU9wZW4obGV4ZXJGbGFncyk7XG5BU1Rfb3Blbihhc3RQcm9wLCB7dHlwZTonQ2xhc3NEZWNsYXJhdGlvbicsIGxvYzp1bmRlZmluZWQsIGlkOnVuZGVmaW5lZCwgc3VwZXJDbGFzczp1bmRlZmluZWQsIGJvZHk6dW5kZWZpbmVkfSk7XG5sZXQgJHRwX25hbWVfY2Fub24gPSBwYXJzZUNsYXNzSWQobGV4ZXJGbGFncywgb3B0aW9uYWxJZGVudCwgc2Nvb3ApO1xuX3BhcnNlQ2xhc3MobGV4ZXJGbGFncywgb3JpZ2luYWxPdXRlckxleGVyRmxhZ3MsIDIpO1xuQVNUX2Nsb3NlKCR0cF9jbGFzc19zdGFydCwgJHRwX2NsYXNzX2xpbmUsICR0cF9jbGFzc19jb2x1bW4pO1xucmV0dXJuICR0cF9uYW1lX2Nhbm9uO1xufVxuZnVuY3Rpb24gcGFyc2VDbGFzc0V4cHJlc3Npb24obGV4ZXJGbGFncywgJHRwX2NsYXNzX3N0YXJ0LCAkdHBfY2xhc3NfbGluZSwgJHRwX2NsYXNzX2NvbHVtbiwgYXN0UHJvcCkge1xubGV0IG9yaWdpbmFsT3V0ZXJMZXhlckZsYWdzID0gbGV4ZXJGbGFncztcbmxleGVyRmxhZ3MgPSAoKGxleGVyRmxhZ3MgfCA4MTkyKSB8IDYxNzYpIF4gNjE3NjtcbkFTVF9vcGVuKGFzdFByb3AsIHt0eXBlOidDbGFzc0V4cHJlc3Npb24nLCBsb2M6dW5kZWZpbmVkLCBpZDp1bmRlZmluZWQsIHN1cGVyQ2xhc3M6dW5kZWZpbmVkLCBib2R5OnVuZGVmaW5lZH0pO1xucGFyc2VDbGFzc0lkKGxleGVyRmxhZ3MsIHRydWUsIG51bGwpO1xubGV0IGFzc2lnbmFibGUgPSBfcGFyc2VDbGFzcyhsZXhlckZsYWdzLCBvcmlnaW5hbE91dGVyTGV4ZXJGbGFncywgMSk7XG5BU1RfY2xvc2UoJHRwX2NsYXNzX3N0YXJ0LCAkdHBfY2xhc3NfbGluZSwgJHRwX2NsYXNzX2NvbHVtbik7XG5yZXR1cm4gc2V0Tm90QXNzaWduYWJsZShhc3NpZ25hYmxlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NJZChsZXhlckZsYWdzLCBvcHRpb25hbElkZW50LCBzY29vcCkge1xubGV0ICR0cF9iaW5kaW5nTmFtZV9jYW5vbiA9ICcnO1xuaWYgKChpc0lkZW50VG9rZW4odG9rX2dldFR5cGUoKSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDIwOTApKSkge1xubGV0ICR0cF9jbGFzc05hbWVfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5sZXQgJHRwX2NsYXNzTmFtZV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9jbGFzc05hbWVfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2NsYXNzTmFtZV9jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuZmF0YWxCaW5kaW5nSWRlbnRDaGVjaygkdHBfY2xhc3NOYW1lX3R5cGUsICR0cF9jbGFzc05hbWVfc3RhcnQsICR0cF9jbGFzc05hbWVfc3RvcCwgJHRwX2NsYXNzTmFtZV9jYW5vbiwgOCwgbGV4ZXJGbGFncyk7XG4kdHBfYmluZGluZ05hbWVfY2Fub24gPSAkdHBfY2xhc3NOYW1lX2Nhbm9uO1xuU0NPUEVfYWRkTGV4QmluZGluZyhzY29vcCwgJHRwX2NsYXNzTmFtZV9zdGFydCwgJHRwX2NsYXNzTmFtZV9zdG9wLCAkdHBfYmluZGluZ05hbWVfY2Fub24sIDgsIDEpO1xubGV0ICR0cF9pZF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBUb0lkZW50Q3VybHlPcGVuKGxleGVyRmxhZ3MpO1xuQVNUX3NldElkZW50KCdpZCcsICR0cF9pZF9zdGFydCwgJHRwX2lkX3N0b3AsICR0cF9pZF9saW5lLCAkdHBfaWRfY29sdW1uLCAkdHBfaWRfY2Fub24pO1xufSBlbHNlIGlmIChvcHRpb25hbElkZW50ID09PSBmYWxzZSkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDbGFzcyBkZWNsIG1pc3NpbmcgcmVxdWlyZWQgaWRlbnQsIGBleHRlbmRzYCBpcyBub3QgYSB2YWxpZCB2YXJpYWJsZSBuYW1lJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufSBlbHNlIHtcbkFTVF9zZXQoJ2lkJywgbnVsbCk7XG59XG5yZXR1cm4gJHRwX2JpbmRpbmdOYW1lX2Nhbm9uO1xufVxuZnVuY3Rpb24gX3BhcnNlQ2xhc3Mob3V0ZXJMZXhlckZsYWdzLCBvcmlnaW5hbE91dGVyTGV4ZXJGbGFncywgaXNFeHByZXNzaW9uKSB7XG5sZXQgYXNzaWduYWJsZSA9IDg7XG5sZXQgaW5uZXJMZXhlckZsYWdzID0gKG91dGVyTGV4ZXJGbGFncyB8IDE2KSBeIDE2O1xuaWYgKChpc0lkZW50VG9rZW4odG9rX2dldFR5cGUoKSkgJiYgKHRva19nZXRUeXBlKCkgPT09IDIwOTApKSkge1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KG91dGVyTGV4ZXJGbGFncyk7XG5hc3NpZ25hYmxlID0gcGFyc2VWYWx1ZShvdXRlckxleGVyRmxhZ3MsIGZhbHNlLCA0LCB0cnVlLCAnc3VwZXJDbGFzcycpO1xuaW5uZXJMZXhlckZsYWdzIHw9IDE2Mzg0O1xufSBlbHNlIHtcbkFTVF9zZXQoJ3N1cGVyQ2xhc3MnLCBudWxsKTtcbmlubmVyTGV4ZXJGbGFncyA9IChpbm5lckxleGVyRmxhZ3MgfCAxNjM4NCkgXiAxNjM4NDtcbn1cbmlmICh0b2tfZ2V0VHlwZSgpICE9PSAxNjUxMykge1xucmV0dXJuIFRIUk9XX1JBTkdFKCgnRXhwZWN0ZWQgdGhlIG9wZW5pbmcgY3VybHkgYHtgIG9mIGEgY2xhc3MgYm9keSwgZm91bmQgYCcgKyB0b2tfc2xpY2VJbnB1dCh0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSkpICsgJ2AgaW5zdGVhZCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlubmVyTGV4ZXJGbGFncyB8PSAzMjc2ODtcbmFzc2lnbmFibGUgfD0gcGFyc2VDbGFzc0JvZHkoaW5uZXJMZXhlckZsYWdzLCBvdXRlckxleGVyRmxhZ3MsIG9yaWdpbmFsT3V0ZXJMZXhlckZsYWdzLCBpc0V4cHJlc3Npb24sICdib2R5Jyk7XG5yZXR1cm4gYXNzaWduYWJsZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NCb2R5KGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgb3JpZ2luYWxPdXRlckxleGVyRmxhZ3MsIGlzRXhwcmVzc2lvbiwgYXN0UHJvcCkge1xubGV0ICR0cF9jdXJseV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfY3VybHlfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9jdXJseV9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J0NsYXNzQm9keScsIGxvYzp1bmRlZmluZWQsIGJvZHk6W119KTtcbmxldCBhc3NpZ25hYmxlID0gX3BhcnNlQ2xhc3NCb2R5KGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgb3JpZ2luYWxPdXRlckxleGVyRmxhZ3MsIGlzRXhwcmVzc2lvbiwgJ2JvZHknKTtcbkFTVF9jbG9zZSgkdHBfY3VybHlfc3RhcnQsICR0cF9jdXJseV9saW5lLCAkdHBfY3VybHlfY29sdW1uKTtcbnJldHVybiBhc3NpZ25hYmxlO1xufVxuZnVuY3Rpb24gX3BhcnNlQ2xhc3NCb2R5KGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgb3JpZ2luYWxPdXRlckxleGVyRmxhZ3MsIGlzRXhwcmVzc2lvbiwgYXN0UHJvcCkge1xubGV0IGRlc3RydWN0aWJsZUZvclBpZ2dpZXMgPSAxO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbndoaWxlICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ5MCkge1xuc2tpcEFueShsZXhlckZsYWdzKTtcbn1cbmxldCBoYXNDb25zdHJ1Y3RvciA9IGZhbHNlO1xud2hpbGUgKHRva19nZXRUeXBlKCkgIT09IDE2NTE3KSB7XG5sZXQgJHRwX21lbWJlclN0YXJ0X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX21lbWJlclN0YXJ0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0IGRlc3RydWN0Tm93ID0gcGFyc2VDbGFzc01ldGhvZChsZXhlckZsYWdzLCBvdXRlckxleGVyRmxhZ3MsIGFzdFByb3ApO1xuaWYgKChkZXN0cnVjdE5vdyAmIDI1NikgIT09IDApIHtcbmlmIChoYXNDb25zdHJ1Y3Rvcikge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdDbGFzc2VzIG1heSBvbmx5IGhhdmUgb25lIGNvbnN0cnVjdG9yJywgJHRwX21lbWJlclN0YXJ0X3N0YXJ0LCAkdHBfbWVtYmVyU3RhcnRfc3RvcCk7XG59XG5oYXNDb25zdHJ1Y3RvciA9IHRydWU7XG5kZXN0cnVjdE5vdyA9IChkZXN0cnVjdE5vdyB8IDI1NikgXiAyNTY7XG59XG5kZXN0cnVjdGlibGVGb3JQaWdnaWVzIHw9IGRlc3RydWN0Tm93O1xud2hpbGUgKHRva19nZXRUeXBlKCkgPT09IDE2NDkwKSB7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xufVxufVxuaWYgKGlzRXhwcmVzc2lvbiA9PT0gMSkge1xuc2tpcERpdihvcmlnaW5hbE91dGVyTGV4ZXJGbGFncyk7XG59IGVsc2Uge1xuc2tpcFRvU3RhdGVtZW50U3RhcnQob3JpZ2luYWxPdXRlckxleGVyRmxhZ3MpO1xufVxucmV0dXJuIGRlc3RydWN0aWJsZUZvclBpZ2dpZXM7XG59XG5mdW5jdGlvbiBwYXJzZUNsYXNzTWV0aG9kKGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgYXN0UHJvcCkge1xubGV0ICR0cF9tZXRob2RTdGFydF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9tZXRob2RTdGFydF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0IGlzU3RhdGljID0gZmFsc2U7XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMjExMykge1xuaXNTdGF0aWMgPSB0cnVlO1xubGV0ICR0cF9zdGF0aWNfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3N0YXRpY19jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3N0YXRpY19zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9zdGF0aWNfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX3N0YXRpY19jYW5vbiA9IHRva19nZXRDYW5vTigpO1xuc2tpcEFueShsZXhlckZsYWdzKTtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ3MSkge1xucmV0dXJuIF9wYXJzZUNsYXNzTWV0aG9kSWRlbnRLZXkobGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwgZmFsc2UsIDAsIDAsIDAsIDAsICR0cF9zdGF0aWNfc3RhcnQsICR0cF9zdGF0aWNfc3RvcCwgJHRwX3N0YXRpY19saW5lLCAkdHBfc3RhdGljX2NvbHVtbiwgJHRwX3N0YXRpY19jYW5vbiwgYXN0UHJvcCk7XG59XG59XG5sZXQgJHRwX2FmdGVyU3RhdGljTWF5YmVfdHlwZSA9IHRva19nZXRUeXBlKCk7XG5pZiAoaXNJZGVudFRva2VuKCR0cF9hZnRlclN0YXRpY01heWJlX3R5cGUpKSB7XG5yZXR1cm4gcGFyc2VDbGFzc01ldGhvZEZyb21JZGVudChsZXhlckZsYWdzLCBvdXRlckxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGlzU3RhdGljLCBhc3RQcm9wKTtcbn1cbmlmIChpc051bWJlclN0cmluZ1Rva2VuKCR0cF9hZnRlclN0YXRpY01heWJlX3R5cGUpKSB7XG5yZXR1cm4gcGFyc2VDbGFzc01ldGhvZExpdGVyYWxLZXkobGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwgaXNTdGF0aWMsIDAsIDAsIDAsIDAsIGFzdFByb3ApO1xufVxuaWYgKCR0cF9hZnRlclN0YXRpY01heWJlX3R5cGUgPT09IDE2NTA5KSB7XG5yZXR1cm4gcGFyc2VDbGFzc01ldGhvZENvbXB1dGVkS2V5KGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwgaXNTdGF0aWMsIDAsIDAsIDAsIDAsIGFzdFByb3ApO1xufVxuaWYgKCR0cF9hZnRlclN0YXRpY01heWJlX3R5cGUgPT09IDgyMDA5KSB7XG5za2lwVG9JZGVudFN0cmluZ051bWJlclNxdWFyZU9wZW4obGV4ZXJGbGFncyk7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5yZXR1cm4gcGFyc2VDbGFzc01ldGhvZElkZW50S2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGlzU3RhdGljLCAwLCA4MjAwOSwgMCwgMCwgYXN0UHJvcCk7XG59XG5pZiAoaXNOdW1iZXJTdHJpbmdUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucmV0dXJuIHBhcnNlQ2xhc3NNZXRob2RMaXRlcmFsS2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGlzU3RhdGljLCAwLCA4MjAwOSwgMCwgMCwgYXN0UHJvcCk7XG59XG5pZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MDkpIHtcbnJldHVybiBwYXJzZUNsYXNzTWV0aG9kQ29tcHV0ZWRLZXkobGV4ZXJGbGFncywgb3V0ZXJMZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiwgJHRwX21ldGhvZFN0YXJ0X3N0YXJ0LCBpc1N0YXRpYywgMCwgODIwMDksIDAsIDAsIGFzdFByb3ApO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdJbnZhbGlkIG9iamxpdCBrZXkgY2hhcmFjdGVyIGFmdGVyIGdlbmVyYXRvciBzdGFyJywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsIHRva19nZXRTdG9wKCkpO1xufVxucmV0dXJuIFRIUk9XX1JBTkdFKCdVbmV4cGVjdGVkIHRva2VuLCB3YW50ZWQgdG8gcGFyc2UgYSBzdGFydCBvZiBhIHByb3BlcnR5IGluIGFuIGNsYXNzIGxpdGVyYWwvcGF0dGVybicsICR0cF9tZXRob2RTdGFydF9saW5lLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NNZXRob2RGcm9tSWRlbnQobGV4ZXJGbGFncywgb3V0ZXJMZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiwgJHRwX21ldGhvZFN0YXJ0X3N0YXJ0LCBpc1N0YXRpYywgYXN0UHJvcCkge1xubGV0ICR0cF9pZGVudF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfaWRlbnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2lkZW50X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfaWRlbnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfaWRlbnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgJHRwX2lkZW50X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwQW55KGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDcxKSB7XG5yZXR1cm4gX3BhcnNlQ2xhc3NNZXRob2RJZGVudEtleShsZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiwgJHRwX21ldGhvZFN0YXJ0X3N0YXJ0LCBpc1N0YXRpYywgMCwgMCwgMCwgMCwgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2xpbmUsICR0cF9pZGVudF9jb2x1bW4sICR0cF9pZGVudF9jYW5vbiwgYXN0UHJvcCk7XG59XG5sZXQgJHRwX2FzeW5jX3R5cGUgPSAwO1xubGV0ICR0cF9zdGFyX3R5cGUgPSAwO1xubGV0ICR0cF9nZXRfdHlwZSA9IDA7XG5sZXQgJHRwX3NldF90eXBlID0gMDtcbnN3aXRjaCAoJHRwX2lkZW50X3R5cGUpIHtcbmNhc2UgMjA5NjpcbiR0cF9nZXRfdHlwZSA9IDIwOTY7XG5icmVhaztcbmNhc2UgMjExMjpcbiR0cF9zZXRfdHlwZSA9IDIxMTI7XG5icmVhaztcbmNhc2UgMjA3NDpcbmlmICghYWxsb3dBc3luY0Z1bmN0aW9ucykge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdBc3luYyBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50bHkgdGFyZ2V0ZWQgbGFuZ3VhZ2UgdmVyc2lvbicsICR0cF9tZXRob2RTdGFydF9zdGFydCwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAodG9rX2dldE5sd2FzKCkgPT09IHRydWUpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQXN5bmMgbWV0aG9kcyBhcmUgYSByZXN0cmljdGVkIHByb2R1Y3Rpb24gYW5kIGNhbm5vdCBoYXZlIGEgbmV3bGluZSBmb2xsb3dpbmcgaXQnLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgdG9rX2dldFN0YXJ0KCkpO1xufVxuJHRwX2FzeW5jX3R5cGUgPSAyMDc0O1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDgyMDA5KSB7XG5pZiAoIWFsbG93QXN5bmNHZW5lcmF0b3JzKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0FzeW5jIGdlbmVyYXRvciBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50bHkgdGFyZ2V0ZWQgbGFuZ3VhZ2UgdmVyc2lvbicsICR0cF9tZXRob2RTdGFydF9zdGFydCwgdG9rX2dldFN0b3AoKSk7XG59XG4kdHBfc3Rhcl90eXBlID0gODIwMDk7XG5za2lwVG9JZGVudFN0cmluZ051bWJlclNxdWFyZU9wZW4obGV4ZXJGbGFncyk7XG59XG5icmVhaztcbmRlZmF1bHQ6XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0VpdGhlciB0aGUgY3VycmVudCBtb2RpZmllciBpcyB1bmtub3duIG9yIHRoZSBpbnB1dCB0aGF0IGZvbGxvd2VkIHdhcyB1bmV4cGVjdGVkJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NTA5KSB7XG5yZXR1cm4gcGFyc2VDbGFzc01ldGhvZENvbXB1dGVkS2V5KGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwgaXNTdGF0aWMsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdHBfZ2V0X3R5cGUsICR0cF9zZXRfdHlwZSwgYXN0UHJvcCk7XG59XG5pZiAoaXNOdW1iZXJTdHJpbmdUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucmV0dXJuIHBhcnNlQ2xhc3NNZXRob2RMaXRlcmFsS2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGlzU3RhdGljLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUsIGFzdFByb3ApO1xufVxuaWYgKGlzSWRlbnRUb2tlbih0b2tfZ2V0VHlwZSgpKSkge1xucmV0dXJuIHBhcnNlQ2xhc3NNZXRob2RJZGVudEtleShsZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiwgJHRwX21ldGhvZFN0YXJ0X3N0YXJ0LCBpc1N0YXRpYywgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlLCBhc3RQcm9wKTtcbn1cbnJldHVybiBUSFJPV19SQU5HRSgnRXhwZWN0ZWQgdG8gcGFyc2UgdGhlIG1vZGlmaWVkIGtleSBvZiBhIGNsYXNzIG1ldGhvZCBidXQgY291bGQgbm90IHBhcnNlIG9uZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NNZXRob2RJZGVudEtleShsZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiwgJHRwX21ldGhvZFN0YXJ0X3N0YXJ0LCBpc1N0YXRpYywgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2tleV9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfa2V5X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfa2V5X3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5sZXQgJHRwX2tleV9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfa2V5X2Nhbm9uID0gdG9rX2dldENhbm9OKCk7XG5za2lwVG9QYXJlbk9wZW5PckRpZShsZXhlckZsYWdzKTtcbnJldHVybiBfcGFyc2VDbGFzc01ldGhvZElkZW50S2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGlzU3RhdGljLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUsICR0cF9rZXlfc3RhcnQsICR0cF9rZXlfc3RvcCwgJHRwX2tleV9saW5lLCAkdHBfa2V5X2NvbHVtbiwgJHRwX2tleV9jYW5vbiwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBfcGFyc2VDbGFzc01ldGhvZElkZW50S2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGlzU3RhdGljLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUsICR0cF9rZXlfc3RhcnQsICR0cF9rZXlfc3RvcCwgJHRwX2tleV9saW5lLCAkdHBfa2V5X2NvbHVtbiwgJHRwX2tleV9jYW5vbiwgYXN0UHJvcCkge1xuQVNUX3NldElkZW50KGFzdFByb3AsICR0cF9rZXlfc3RhcnQsICR0cF9rZXlfc3RvcCwgJHRwX2tleV9saW5lLCAkdHBfa2V5X2NvbHVtbiwgJHRwX2tleV9jYW5vbik7XG5pZiAoKGlzU3RhdGljICYmICgkdHBfa2V5X2Nhbm9uID09PSAncHJvdG90eXBlJykpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1N0YXRpYyBjbGFzcyBtZXRob2RzIGNhbiBub3QgYmUgY2FsbGVkIGBwcm90b3R5cGVgJywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsIHRva19nZXRTdG9wKCkpO1xufVxubGV0IGtpbmQgPSAnbWV0aG9kJztcbmxldCBpc0NsYXNzQ29uc3RydWN0b3IgPSBmYWxzZTtcbmlmICgoKCFpc1N0YXRpYykgJiYgKCR0cF9rZXlfY2Fub24gPT09ICdjb25zdHJ1Y3RvcicpKSkge1xuaXNDbGFzc0NvbnN0cnVjdG9yID0gdHJ1ZTtcbmtpbmQgPSAnY29uc3RydWN0b3InO1xuaWYgKCR0cF9hc3luY190eXBlID09PSAyMDc0KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NsYXNzIGNvbnN0cnVjdG9ycyBjYW4gbm90IGJlIGFzeW5jJywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsIHRva19nZXRTdG9wKCkpO1xufVxuaWYgKCR0cF9zdGFyX3R5cGUgPT09IDgyMDA5KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NsYXNzIGNvbnN0cnVjdG9ycyBjYW4gbm90IGJlIGdlbmVyYXRvcnMnLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAoJHRwX2dldF90eXBlID09PSAyMDk2KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NsYXNzIGNvbnN0cnVjdG9ycyBjYW4gbm90IGJlIGdldHRlcnMnLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAoJHRwX3NldF90eXBlID09PSAyMTEyKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NsYXNzIGNvbnN0cnVjdG9ycyBjYW4gbm90IGJlIHNldHRlcnMnLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgdG9rX2dldFN0b3AoKSk7XG59XG59IGVsc2UgaWYgKCR0cF9nZXRfdHlwZSA9PT0gMjA5Nikge1xua2luZCA9ICdnZXQnO1xufSBlbHNlIGlmICgkdHBfc2V0X3R5cGUgPT09IDIxMTIpIHtcbmtpbmQgPSAnc2V0Jztcbn0gZWxzZSB7XG5cbn1cbnJldHVybiBwYXJzZUNsYXNzTWV0aG9kQWZ0ZXJLZXkobGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwga2luZCwgaXNDbGFzc0NvbnN0cnVjdG9yLCBmYWxzZSwgaXNTdGF0aWMsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdHBfZ2V0X3R5cGUsICR0cF9zZXRfdHlwZSwgYXN0UHJvcCk7XG59XG5mdW5jdGlvbiBwYXJzZUNsYXNzTWV0aG9kTGl0ZXJhbEtleShsZXhlckZsYWdzLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiwgJHRwX21ldGhvZFN0YXJ0X3N0YXJ0LCBpc1N0YXRpYywgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX2xpdF90eXBlID0gdG9rX2dldFR5cGUoKTtcbmxldCAkdHBfbGl0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9saXRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9saXRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfbGl0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0ICR0cF9saXRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbmlmICgoaXNTdGF0aWMgJiYgKCR0cF9saXRfY2Fub24gPT09ICdwcm90b3R5cGUnKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnU3RhdGljIGNsYXNzIG1ldGhvZHMgY2FuIG5vdCBiZSBjYWxsZWQgYHByb3RvdHlwZWAnLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgdG9rX2dldFN0b3AoKSk7XG59XG5sZXQga2luZCA9ICdtZXRob2QnO1xubGV0IGlzQ2xhc3NDb25zdHJ1Y3RvciA9IGZhbHNlO1xuaWYgKCgoIWlzU3RhdGljKSAmJiAoJHRwX2xpdF9jYW5vbiA9PT0gJ2NvbnN0cnVjdG9yJykpKSB7XG5pc0NsYXNzQ29uc3RydWN0b3IgPSB0cnVlO1xua2luZCA9ICdjb25zdHJ1Y3Rvcic7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2xhc3MgY29uc3RydWN0b3JzIGNhbiBub3QgYmUgYXN5bmMnLCAkdHBfbWV0aG9kU3RhcnRfbGluZSwgdG9rX2dldFN0b3AoKSk7XG59XG5pZiAoJHRwX3N0YXJfdHlwZSA9PT0gODIwMDkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2xhc3MgY29uc3RydWN0b3JzIGNhbiBub3QgYmUgZ2VuZXJhdG9ycycsICR0cF9tZXRob2RTdGFydF9saW5lLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICgkdHBfZ2V0X3R5cGUgPT09IDIwOTYpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2xhc3MgY29uc3RydWN0b3JzIGNhbiBub3QgYmUgZ2V0dGVycycsICR0cF9tZXRob2RTdGFydF9saW5lLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICgkdHBfc2V0X3R5cGUgPT09IDIxMTIpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnQ2xhc3MgY29uc3RydWN0b3JzIGNhbiBub3QgYmUgc2V0dGVycycsICR0cF9tZXRob2RTdGFydF9saW5lLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn0gZWxzZSBpZiAoJHRwX2dldF90eXBlID09PSAyMDk2KSB7XG5raW5kID0gJ2dldCc7XG59IGVsc2UgaWYgKCR0cF9zZXRfdHlwZSA9PT0gMjExMikge1xua2luZCA9ICdzZXQnO1xufSBlbHNlIHtcblxufVxuc2tpcFRvUGFyZW5PcGVuT3JEaWUobGV4ZXJGbGFncyk7XG5BU1Rfc2V0TGl0ZXJhbChhc3RQcm9wLCAkdHBfbGl0X3R5cGUsICR0cF9saXRfc3RhcnQsICR0cF9saXRfc3RvcCwgJHRwX2xpdF9saW5lLCAkdHBfbGl0X2NvbHVtbiwgJHRwX2xpdF9jYW5vbik7XG5yZXR1cm4gcGFyc2VDbGFzc01ldGhvZEFmdGVyS2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGtpbmQsIGlzQ2xhc3NDb25zdHJ1Y3RvciwgZmFsc2UsIGlzU3RhdGljLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUsIGFzdFByb3ApO1xufVxuZnVuY3Rpb24gcGFyc2VDbGFzc01ldGhvZENvbXB1dGVkS2V5KGxleGVyRmxhZ3MsIG91dGVyTGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwgaXNTdGF0aWMsICR0cF9hc3luY190eXBlLCAkdHBfc3Rhcl90eXBlLCAkdHBfZ2V0X3R5cGUsICR0cF9zZXRfdHlwZSwgYXN0UHJvcCkge1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xubGV0IGFzc2lnbmFibGVfZm9yUGlnZ2llcyA9IHBhcnNlRXhwcmVzc2lvbihvdXRlckxleGVyRmxhZ3MsIGFzdFByb3ApO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDE2NTEwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoKCdNaXNzaW5nIHJpZ2h0IHNxdWFyZSBicmFja2V0IGZvciBjb21wdXRlZCBtZW1iZXIsIGZvdW5kIGAnICsgdG9rX3NsaWNlSW5wdXQodG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpKSArICdgIGluc3RlYWQnLCB0b2tfZ2V0U3RhcnQoKSwgdG9rX2dldFN0b3AoKSk7XG59XG5za2lwVG9QYXJlbk9wZW5PckRpZShsZXhlckZsYWdzKTtcbmxldCBraW5kID0gJ21ldGhvZCc7XG5pZiAoJHRwX2dldF90eXBlID09PSAyMDk2KSB7XG5raW5kID0gJ2dldCc7XG59IGVsc2UgaWYgKCR0cF9zZXRfdHlwZSA9PT0gMjExMikge1xua2luZCA9ICdzZXQnO1xufSBlbHNlIHtcblxufVxucGFyc2VDbGFzc01ldGhvZEFmdGVyS2V5KGxleGVyRmxhZ3MsICR0cF9tZXRob2RTdGFydF9saW5lLCAkdHBfbWV0aG9kU3RhcnRfY29sdW1uLCAkdHBfbWV0aG9kU3RhcnRfc3RhcnQsIGtpbmQsIGZhbHNlLCB0cnVlLCBpc1N0YXRpYywgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlLCBhc3RQcm9wKTtcbnJldHVybiBhc3NpZ25hYmxlX2ZvclBpZ2dpZXM7XG59XG5mdW5jdGlvbiBwYXJzZUNsYXNzTWV0aG9kQWZ0ZXJLZXkobGV4ZXJGbGFncywgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4sICR0cF9tZXRob2RTdGFydF9zdGFydCwga2luZCwgaXNDbGFzc0NvbnN0cnVjdG9yLCBpc0NvbXB1dGVkS2V5LCBpc1N0YXRpYywgJHRwX2FzeW5jX3R5cGUsICR0cF9zdGFyX3R5cGUsICR0cF9nZXRfdHlwZSwgJHRwX3NldF90eXBlLCBhc3RQcm9wKSB7XG5sZXQgJHRwX3BhcmVuX2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9wYXJlbl9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3BhcmVuX3N0YXJ0ID0gdG9rX2dldFN0YXJ0KCk7XG5pZiAoYmFiZWxDb21wYXQpIHtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOk5PREVfTkFNRV9NRVRIT0RfQ0xBU1MsIGxvYzp1bmRlZmluZWQsIGtleTp1bmRlZmluZWQsIHN0YXRpYzppc1N0YXRpYywgY29tcHV0ZWQ6aXNDb21wdXRlZEtleSwgYXN5bmM6dW5kZWZpbmVkLCBnZW5lcmF0b3I6dW5kZWZpbmVkLCBpZDp1bmRlZmluZWQsIHBhcmFtczpbXSwga2luZDpraW5kfSwgJ2tleScpO1xufSBlbHNlIHtcbkFTVF93cmFwQ2xvc2VkQ3VzdG9tKGFzdFByb3AsIHt0eXBlOk5PREVfTkFNRV9NRVRIT0RfQ0xBU1MsIGxvYzp1bmRlZmluZWQsIGtleTp1bmRlZmluZWQsIHN0YXRpYzppc1N0YXRpYywgY29tcHV0ZWQ6aXNDb21wdXRlZEtleSwga2luZDpraW5kLCB2YWx1ZTp1bmRlZmluZWR9LCAna2V5Jyk7XG59XG5wYXJzZUZ1bmN0aW9uQWZ0ZXJLZXl3b3JkKGxleGVyRmxhZ3MsIG51bGwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgaXNDbGFzc0NvbnN0cnVjdG9yLCB0cnVlLCAkdHBfYXN5bmNfdHlwZSwgJHRwX3N0YXJfdHlwZSwgJHRwX2dldF90eXBlLCAkdHBfc2V0X3R5cGUsIChhY29ybkNvbXBhdD8gJHRwX3BhcmVuX3N0YXJ0IDogJHRwX21ldGhvZFN0YXJ0X3N0YXJ0KSwgKGFjb3JuQ29tcGF0PyAkdHBfcGFyZW5fbGluZSA6ICR0cF9tZXRob2RTdGFydF9saW5lKSwgKGFjb3JuQ29tcGF0PyAkdHBfcGFyZW5fY29sdW1uIDogJHRwX21ldGhvZFN0YXJ0X2NvbHVtbiksIDEsICd2YWx1ZScpO1xuQVNUX2Nsb3NlKCR0cF9tZXRob2RTdGFydF9zdGFydCwgJHRwX21ldGhvZFN0YXJ0X2xpbmUsICR0cF9tZXRob2RTdGFydF9jb2x1bW4pO1xuaWYgKGlzQ2xhc3NDb25zdHJ1Y3RvciA9PT0gdHJ1ZSkge1xucmV0dXJuIDI1Njtcbn1cbnJldHVybiAxO1xufVxuZnVuY3Rpb24gdmVyaWZ5RGVzdHJ1Y3RpYmxlKGRlc3RydWN0aWJsZSkge1xuaWYgKCgoKGRlc3RydWN0aWJsZSAmIDEpID09PSAxKSAmJiAoKGRlc3RydWN0aWJsZSAmIDQpID09PSA0KSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRm91bmQgYSBwYXJ0IHRoYXQgY2FudCBkZXN0cnVjdCBhbmQgYSBwYXJ0IHRoYXQgbXVzdCBkZXN0cnVjdCBzbyBpdCBpcyBub3QgZGVzdHJ1Y3RpYmxlJywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxufVxuZnVuY3Rpb24gdmVyaWZ5RGVzdHJ1Y3RpYmxlRm9yQmluZGluZyhkZXN0cnVjdGlibGUsIGJpbmRpbmdUeXBlKSB7XG5pZiAoKGRlc3RydWN0aWJsZSAmIDEpICE9PSAwKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSBiaW5kaW5nIHBhdHRlcm4gaXMgbm90IGRlc3RydWN0aWJsZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmlmICgoKGJpbmRpbmdUeXBlICE9PSAwKSAmJiAoKGRlc3RydWN0aWJsZSAmIDIpICE9PSAwKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVGhpcyBiaW5kaW5nIGNhbiBub3QgYmUgdXNlZCBpbiBmdW5jdGlvbiBwYXJhbWV0ZXJzIGJlY2F1c2UgaXQgaXMgbm90IGRlc3RydWN0aWJsZScsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmZ1bmN0aW9uIHBhcnNlT3B0aW9uYWxEZXN0cnVjdGlibGVSZXN0T2ZFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF92YWx1ZVN0YXJ0X3N0YXJ0LCAkdHBfdmFsdWVTdGFydF9zdG9wLCAkdHBfdmFsdWVTdGFydF9saW5lLCAkdHBfdmFsdWVTdGFydF9jb2x1bW4sIGFzc2lnbmFibGUsIGRlc3RydWN0aWJsZSwgY2xvc2luZ1B1bmNUeXBlLCBhc3RQcm9wKSB7XG5pZiAoKCh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkgfHwgKHRva19nZXRUeXBlKCkgPT09IGNsb3NpbmdQdW5jVHlwZSkpKSB7XG5pZiAobm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSkgZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2UgaWYgKChkZXN0cnVjdGlibGUgJiA0KSA9PT0gNCkge1xucmV0dXJuIFRIUk9XX1JBTkdFKCdGb3VuZCBzb21ldGhpbmcgdGhhdCBoYWQgdG8gYmUgYSBQYXR0ZXJuIGJ1dCBoYWQgdG8gcGFyc2UgbW9yZSwgd2hpY2ggaXMgYW4gZXJyb3InLCAkdHBfdmFsdWVTdGFydF9zdGFydCwgdG9rX2dldFN0YXJ0KCkpO1xufSBlbHNlIHtcbmFzc2lnbmFibGUgPSBwYXJzZVZhbHVlVGFpbChsZXhlckZsYWdzLCAkdHBfdmFsdWVTdGFydF9zdGFydCwgJHRwX3ZhbHVlU3RhcnRfbGluZSwgJHRwX3ZhbHVlU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCA0LCBmYWxzZSwgYXN0UHJvcCk7XG5pZiAoaXNBc3NpZ25hYmxlKGFzc2lnbmFibGUpKSB7XG5kZXN0cnVjdGlibGUgPSAoZGVzdHJ1Y3RpYmxlIHwgNykgXiA3O1xufSBlbHNlIHtcbmRlc3RydWN0aWJsZSB8PSAxO1xufVxubGV0IGZpcnN0T3BOb3RBc3NpZ24gPSB0b2tfZ2V0VHlwZSgpICE9PSA0OTI2NDtcbmlmICgoKHRva19nZXRUeXBlKCkgIT09IDE2NDgwKSAmJiAodG9rX2dldFR5cGUoKSAhPT0gY2xvc2luZ1B1bmNUeXBlKSkpIHtcbmFzc2lnbmFibGUgfD0gcGFyc2VFeHByZXNzaW9uRnJvbU9wKGxleGVyRmxhZ3MsICR0cF92YWx1ZVN0YXJ0X3N0YXJ0LCAkdHBfdmFsdWVTdGFydF9zdG9wLCAkdHBfdmFsdWVTdGFydF9saW5lLCAkdHBfdmFsdWVTdGFydF9jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApO1xuaWYgKGZpcnN0T3BOb3RBc3NpZ24pIHtcbmRlc3RydWN0aWJsZSB8PSAxO1xufSBlbHNlIHtcblxufVxufSBlbHNlIGlmIChmaXJzdE9wTm90QXNzaWduKSB7XG5pZiAobm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2Uge1xuZGVzdHJ1Y3RpYmxlIHw9IDI7XG59XG59XG59XG5yZXR1cm4gY29weVBpZ2dpZXMoZGVzdHJ1Y3RpYmxlLCBhc3NpZ25hYmxlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyb3dhYmxlU3ByZWFkT3JSZXN0KGxleGVyRmxhZ3MsIHNjb29wLCBjbG9zaW5nUHVuY1R5cGUsIGJpbmRpbmdUeXBlLCAkdHBfYXN5bmNfdHlwZSwgZXhwb3J0ZWROYW1lcywgZXhwb3J0ZWRCaW5kaW5ncywgYXN0UHJvcCkge1xubGV0ICR0cF9zcHJlYWRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX3NwcmVhZF9jb2x1bW4gPSB0b2tfZ2V0Q29sdW1uKCk7XG5sZXQgJHRwX3NwcmVhZF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xuc2tpcFRvRXhwcmVzc2lvblN0YXJ0KGxleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgPT09IDE2NDg2KSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ0NhbiBub3QgcmVzdCB0d2ljZScsICR0cF9zcHJlYWRfc3RhcnQsIHRva19nZXRTdG9wKCkpO1xufVxuQVNUX29wZW4oYXN0UHJvcCwge3R5cGU6J1NwcmVhZEVsZW1lbnQnLCBsb2M6dW5kZWZpbmVkLCBhcmd1bWVudDp1bmRlZmluZWR9KTtcbmxldCBkZXN0cnVjdGlibGUgPSBfcGFyc2VBcnJvd2FibGVTcHJlYWRPclJlc3QobGV4ZXJGbGFncywgc2Nvb3AsIGNsb3NpbmdQdW5jVHlwZSwgYmluZGluZ1R5cGUsICR0cF9hc3luY190eXBlLCAkdHBfc3ByZWFkX3N0YXJ0LCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCAnYXJndW1lbnQnKTtcbkFTVF9jbG9zZSgkdHBfc3ByZWFkX3N0YXJ0LCAkdHBfc3ByZWFkX2xpbmUsICR0cF9zcHJlYWRfY29sdW1uKTtcbmlmICgoKHRva19nZXRUeXBlKCkgIT09IGNsb3NpbmdQdW5jVHlwZSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NDgwKSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnRW5jb3VudGVyZWQgaW52YWxpZCBpbnB1dCBhZnRlciBzcHJlYWQvcmVzdCBhcmd1bWVudCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbnJldHVybiBkZXN0cnVjdGlibGU7XG59XG5mdW5jdGlvbiBfcGFyc2VBcnJvd2FibGVTcHJlYWRPclJlc3QobGV4ZXJGbGFncywgc2Nvb3AsIGNsb3NpbmdQdW5jVHlwZSwgYmluZGluZ1R5cGUsICR0cF9hc3luY190eXBlLCAkdHRfc3ByZWFkVG9rZW5fc3RhcnQsIGV4cG9ydGVkTmFtZXMsIGV4cG9ydGVkQmluZGluZ3MsIGFzdFByb3ApIHtcbmxldCAkdHBfYXJnU3RhcnRfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2FyZ1N0YXJ0X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfYXJnU3RhcnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfYXJnU3RhcnRfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgZGVzdHJ1Y3RpYmxlID0gMDtcbmxldCBhc3NpZ25hYmxlID0gMzI7XG5pZiAoaXNJZGVudFRva2VuKHRva19nZXRUeXBlKCkpKSB7XG5sZXQgJHRwX2lkZW50X3R5cGUgPSB0b2tfZ2V0VHlwZSgpO1xubGV0ICR0cF9pZGVudF9saW5lID0gdG9rX2dldExpbmUoKTtcbmxldCAkdHBfaWRlbnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9pZGVudF9zdGFydCA9IHRva19nZXRTdGFydCgpO1xubGV0ICR0cF9pZGVudF9zdG9wID0gdG9rX2dldFN0b3AoKTtcbmxldCAkdHBfaWRlbnRfY2Fub24gPSB0b2tfZ2V0Q2Fub04oKTtcbnNraXBJZGVudFNhZmVTbG93QW5kRXhwZW5zaXZlKGxleGVyRmxhZ3MsIGZhbHNlKTtcbmxldCBhc3NpZ25CZWZvcmUgPSB0b2tfZ2V0VHlwZSgpID09PSA0OTI2NDtcbmxldCB3aWxsQmVTaW1wbGUgPSAoKCgodG9rX2dldFR5cGUoKSA9PT0gY2xvc2luZ1B1bmNUeXBlKSB8fCAodG9rX2dldFR5cGUoKSA9PT0gMTY0ODApKSkgfHwgYXNzaWduQmVmb3JlKTtcbmlmICh3aWxsQmVTaW1wbGUpIHtcbmxldCBhc3NpZ25hYmxlT3JFcnJvck1zZyA9IG5vbkZhdGFsQmluZGluZ0lkZW50Q2hlY2soJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9jYW5vbiwgYmluZGluZ1R5cGUsIGxleGVyRmxhZ3MpO1xuaWYgKGFzc2lnbmFibGVPckVycm9yTXNnLmxlbmd0aCAhPT0gMCkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59XG59IGVsc2Uge1xuZGVzdHJ1Y3RpYmxlIHw9IDI7XG59XG5hc3NpZ25hYmxlID0gcGFyc2VWYWx1ZUFmdGVySWRlbnQobGV4ZXJGbGFncywgJHRwX2lkZW50X3R5cGUsICR0cF9pZGVudF9zdGFydCwgJHRwX2lkZW50X3N0b3AsICR0cF9pZGVudF9saW5lLCAkdHBfaWRlbnRfY29sdW1uLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlLCB0cnVlLCBhc3RQcm9wKTtcbmlmICgoKHRva19nZXRUeXBlKCkgIT09IDE2NDgwKSAmJiAodG9rX2dldFR5cGUoKSAhPT0gY2xvc2luZ1B1bmNUeXBlKSkpIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSA0OTI2NCkge1xuaWYgKG5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSkpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVHJpZWQgdG8gYXNzaWduIHRvIGEgdmFsdWUgdGhhdCB3YXMgbm90IGFzc2lnbmFibGUgaW4gYXJyL29iaiBsaXQvcGF0dCcsIHRva19nZXRTdGFydCgpLCB0b2tfZ2V0U3RvcCgpKTtcbn1cbn1cbmRlc3RydWN0aWJsZSB8PSAxO1xuYXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfYXJnU3RhcnRfc3RhcnQsICR0cF9hcmdTdGFydF9zdG9wLCAkdHBfYXJnU3RhcnRfbGluZSwgJHRwX2FyZ1N0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG59XG5pZiAobm90QXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2UgaWYgKHdpbGxCZVNpbXBsZSkge1xuU0NPUEVfYWN0dWFsbHlBZGRCaW5kaW5nKGxleGVyRmxhZ3MsIHNjb29wLCAkdHBfaWRlbnRfc3RhcnQsICR0cF9pZGVudF9zdG9wLCAkdHBfaWRlbnRfY2Fub24sIGJpbmRpbmdUeXBlKTtcbmFkZE5hbWVUb0V4cG9ydHMoZXhwb3J0ZWROYW1lcywgJHRwX2lkZW50X3N0YXJ0LCAkdHBfaWRlbnRfc3RvcCwgJHRwX2lkZW50X2Nhbm9uKTtcbmFkZEJpbmRpbmdUb0V4cG9ydHMoZXhwb3J0ZWRCaW5kaW5ncywgJHRwX2lkZW50X2Nhbm9uKTtcbn0gZWxzZSB7XG5kZXN0cnVjdGlibGUgfD0gMjtcbn1cbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MDkpIHtcbmxldCBub3dEZXN0cnVjdCA9IHBhcnNlQXJyYXlMaXRlcmFsUGF0dGVybihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIGZhbHNlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbmlmICgoKCgodG9rX2dldFR5cGUoKSAhPT0gNDkyNjQpICYmICh0b2tfZ2V0VHlwZSgpICE9PSBjbG9zaW5nUHVuY1R5cGUpKSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NDgwKSkpIHtcbmRlc3RydWN0aWJsZSA9IHBhcnNlT3B0aW9uYWxEZXN0cnVjdGlibGVSZXN0T2ZFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF9hcmdTdGFydF9zdGFydCwgJHRwX2FyZ1N0YXJ0X3N0b3AsICR0cF9hcmdTdGFydF9saW5lLCAkdHBfYXJnU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCBub3dEZXN0cnVjdCwgY2xvc2luZ1B1bmNUeXBlLCBhc3RQcm9wKTtcbn0gZWxzZSB7XG5pZiAoKChjbG9zaW5nUHVuY1R5cGUgPT09IDE2NTE3KSAmJiAodG9rX2dldFR5cGUoKSAhPT0gNDkyNjQpKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IG5vd0Rlc3RydWN0IHwgMTtcbn0gZWxzZSB7XG5kZXN0cnVjdGlibGUgfD0gbm93RGVzdHJ1Y3Q7XG59XG59XG5hc3NpZ25hYmxlID0gKCgoZGVzdHJ1Y3RpYmxlICYgMSkgPT09IDEpPyAxNiA6IDMyKTtcbmlmICgoKGNsb3NpbmdQdW5jVHlwZSA9PT0gMTY1MTcpICYmIG5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSkpKSB7XG5kZXN0cnVjdGlibGUgfD0gMTtcbn1cbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gMTY1MTMpIHtcbmxldCAkdHBfY3VybHlfbGluZSA9IHRva19nZXRMaW5lKCk7XG5sZXQgJHRwX2N1cmx5X2NvbHVtbiA9IHRva19nZXRDb2x1bW4oKTtcbmxldCAkdHBfY3VybHlfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfY3VybHlfc3RvcCA9IHRva19nZXRTdG9wKCk7XG5sZXQgbm93RGVzdHJ1Y3QgPSBwYXJzZU9iamVjdEFuZEFzc2lnbihsZXhlckZsYWdzLCBzY29vcCwgYmluZGluZ1R5cGUsIGZhbHNlLCBleHBvcnRlZE5hbWVzLCBleHBvcnRlZEJpbmRpbmdzLCBhc3RQcm9wKTtcbmlmICgoKCgodG9rX2dldFR5cGUoKSAhPT0gNDkyNjQpICYmICh0b2tfZ2V0VHlwZSgpICE9PSBjbG9zaW5nUHVuY1R5cGUpKSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NDgwKSkpIHtcbmRlc3RydWN0aWJsZSA9IHBhcnNlT3B0aW9uYWxEZXN0cnVjdGlibGVSZXN0T2ZFeHByZXNzaW9uKGxleGVyRmxhZ3MsICR0cF9jdXJseV9zdGFydCwgJHRwX2N1cmx5X3N0b3AsICR0cF9jdXJseV9saW5lLCAkdHBfY3VybHlfY29sdW1uLCBhc3NpZ25hYmxlLCBub3dEZXN0cnVjdCwgY2xvc2luZ1B1bmNUeXBlLCBhc3RQcm9wKTtcbn0gZWxzZSB7XG5kZXN0cnVjdGlibGUgfD0gbm93RGVzdHJ1Y3Q7XG5pZiAoKChjbG9zaW5nUHVuY1R5cGUgPT09IDE2NTE3KSAmJiAodG9rX2dldFR5cGUoKSAhPT0gNDkyNjQpKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59XG59XG5hc3NpZ25hYmxlID0gKCgoZGVzdHJ1Y3RpYmxlICYgMSkgPT09IDEpPyAxNiA6IDMyKTtcbmlmICgoKGNsb3NpbmdQdW5jVHlwZSA9PT0gMTY1MTcpICYmIG5vdEFzc2lnbmFibGUoYXNzaWduYWJsZSkpKSB7XG5kZXN0cnVjdGlibGUgfD0gMTtcbn1cbn0gZWxzZSBpZiAodG9rX2dldFR5cGUoKSA9PT0gY2xvc2luZ1B1bmNUeXBlKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoZSByZXN0L3NwcmVhZCBvcGVyYXRvciBpcyBtaXNzaW5nIGFuIGFyZ3VtZW50JywgJHR0X3NwcmVhZFRva2VuX3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn0gZWxzZSB7XG5kZXN0cnVjdGlibGUgfD0gMjtcbmxldCAkdHBfZXhwclN0YXJ0X2xpbmUgPSB0b2tfZ2V0TGluZSgpO1xubGV0ICR0cF9leHByU3RhcnRfY29sdW1uID0gdG9rX2dldENvbHVtbigpO1xubGV0ICR0cF9leHByU3RhcnRfc3RhcnQgPSB0b2tfZ2V0U3RhcnQoKTtcbmxldCAkdHBfZXhwclN0YXJ0X3N0b3AgPSB0b2tfZ2V0U3RvcCgpO1xubGV0IG5vd0Fzc2lnbmFibGUgPSBwYXJzZVZhbHVlKGxleGVyRmxhZ3MsIHRydWUsIDQsIGZhbHNlLCBhc3RQcm9wKTtcbmlmIChub3RBc3NpZ25hYmxlKG5vd0Fzc2lnbmFibGUpKSB7XG5kZXN0cnVjdGlibGUgPSAxO1xufVxuYXNzaWduYWJsZSA9IG1lcmdlQXNzaWduYWJsZShub3dBc3NpZ25hYmxlLCBhc3NpZ25hYmxlKTtcbmlmICgoKCgodG9rX2dldFR5cGUoKSA9PT0gNDkyNjQpICYmICh0b2tfZ2V0VHlwZSgpICE9PSBjbG9zaW5nUHVuY1R5cGUpKSkgJiYgKHRva19nZXRUeXBlKCkgIT09IDE2NDgwKSkpIHtcbmlmIChub3RBc3NpZ25hYmxlKGFzc2lnbmFibGUpKSB7XG5yZXR1cm4gVEhST1dfUkFOR0UoJ1RoaXMgYC4uLmAgYXJnIGlzIGludmFsaWQ7IHJlc3Qgb25seSBhY2NlcHRzIGlkZW50cywgYXJyYXlzLCBhbmQgb2JqZWN0cyBhbmQgYXMgc3ByZWFkIHRoZSBhc3NpZ25tZW50IGlzIGlsbGVnYWwgYmVjYXVzZSB0aGUgbGhzIGlzIG5vdCBhc3NpZ25hYmxlJywgJHR0X3NwcmVhZFRva2VuX3N0YXJ0LCB0b2tfZ2V0U3RvcCgpKTtcbn1cbmFzc2lnbmFibGUgPSBwYXJzZUV4cHJlc3Npb25Gcm9tT3AobGV4ZXJGbGFncywgJHRwX2V4cHJTdGFydF9zdGFydCwgJHRwX2V4cHJTdGFydF9zdG9wLCAkdHBfZXhwclN0YXJ0X2xpbmUsICR0cF9leHByU3RhcnRfY29sdW1uLCBhc3NpZ25hYmxlLCBhc3RQcm9wKTtcbmRlc3RydWN0aWJsZSB8PSAxO1xufSBlbHNlIHtcbmlmICh0b2tfZ2V0VHlwZSgpID09PSAxNjQ4MCkge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59IGVsc2UgaWYgKHRva19nZXRUeXBlKCkgIT09IGNsb3NpbmdQdW5jVHlwZSkge1xuYXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfZXhwclN0YXJ0X3N0YXJ0LCAkdHBfZXhwclN0YXJ0X3N0b3AsICR0cF9leHByU3RhcnRfbGluZSwgJHRwX2V4cHJTdGFydF9jb2x1bW4sIGFzc2lnbmFibGUsIGFzdFByb3ApO1xufSBlbHNlIHtcblxufVxuaWYgKGlzQXNzaWduYWJsZShhc3NpZ25hYmxlKSkge1xuZGVzdHJ1Y3RpYmxlIHw9IDI7XG59IGVsc2Uge1xuZGVzdHJ1Y3RpYmxlIHw9IDE7XG59XG59XG5pZiAoKChjbG9zaW5nUHVuY1R5cGUgPT09IDE2NTE3KSAmJiAoIWlzQXNzaWduYWJsZShhc3NpZ25hYmxlKSkpKSBkZXN0cnVjdGlibGUgfD0gMTtcbnJldHVybiBjb3B5UGlnZ2llcyhkZXN0cnVjdGlibGUsIGFzc2lnbmFibGUpO1xufVxuaWYgKHRva19nZXRUeXBlKCkgIT09IGNsb3NpbmdQdW5jVHlwZSkge1xuaWYgKGJpbmRpbmdUeXBlID09PSAxKSB7XG5pZiAoJHRwX2FzeW5jX3R5cGUgPT09IDIwNzQpIHtcbmRlc3RydWN0aWJsZSB8PSAxO1xufSBlbHNlIHtcbmRlc3RydWN0aWJsZSB8PSAyO1xufVxufVxuaWYgKHRva19nZXRUeXBlKCkgPT09IDQ5MjY0KSB7XG52ZXJpZnlEZXN0cnVjdGlibGUoZGVzdHJ1Y3RpYmxlIHwgNCk7XG5kZXN0cnVjdGlibGUgPSAxO1xuQVNUX2Rlc3RydWN0KGFzdFByb3ApO1xuQVNUX3dyYXBDbG9zZWRDdXN0b20oYXN0UHJvcCwge3R5cGU6J0Fzc2lnbm1lbnRFeHByZXNzaW9uJywgbG9jOnVuZGVmaW5lZCwgbGVmdDp1bmRlZmluZWQsIG9wZXJhdG9yOic9JywgcmlnaHQ6dW5kZWZpbmVkfSwgJ2xlZnQnKTtcbnNraXBUb0V4cHJlc3Npb25TdGFydChsZXhlckZsYWdzKTtcbmxldCBub3dBc3NpZ25hYmxlID0gcGFyc2VFeHByZXNzaW9uKGxleGVyRmxhZ3MsICdyaWdodCcpO1xuYXNzaWduYWJsZSA9IG1lcmdlQXNzaWduYWJsZShub3dBc3NpZ25hYmxlLCBhc3NpZ25hYmxlKTtcbkFTVF9jbG9zZSgkdHBfYXJnU3RhcnRfc3RhcnQsICR0cF9hcmdTdGFydF9saW5lLCAkdHBfYXJnU3RhcnRfY29sdW1uKTtcbn0gZWxzZSB7XG5hc3NpZ25hYmxlID0gcGFyc2VWYWx1ZVRhaWwobGV4ZXJGbGFncywgJHRwX2FyZ1N0YXJ0X3N0YXJ0LCAkdHBfYXJnU3RhcnRfbGluZSwgJHRwX2FyZ1N0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgNCwgZmFsc2UsIGFzdFByb3ApO1xuYXNzaWduYWJsZSA9IHBhcnNlRXhwcmVzc2lvbkZyb21PcChsZXhlckZsYWdzLCAkdHBfYXJnU3RhcnRfc3RhcnQsICR0cF9hcmdTdGFydF9zdG9wLCAkdHBfYXJnU3RhcnRfbGluZSwgJHRwX2FyZ1N0YXJ0X2NvbHVtbiwgYXNzaWduYWJsZSwgYXN0UHJvcCk7XG59XG5kZXN0cnVjdGlibGUgfD0gMTtcbn1cbnJldHVybiBjb3B5UGlnZ2llcyhkZXN0cnVjdGlibGUsIGFzc2lnbmFibGUpO1xufVxubGV0IGluaXRpYWxMZXhlckZsYWdzID0gKCgyNjAgfCAoKCgob3B0aW9uc19zdHJpY3RNb2RlIHx8IChnb2FsTW9kZSA9PT0gdHJ1ZSkpKT8gODE5MiA6IDApKSkgfCA0KSBeIDQ7XG5pbml0TGV4ZXIoaW5pdGlhbExleGVyRmxhZ3MpO1xucGFyc2VUb3BMZXZlbHMoaW5pdGlhbExleGVyRmxhZ3MpO1xuaWYgKHRva19nZXRUeXBlKCkgIT09IDIwOTcxNzMpIHtcbnJldHVybiBUSFJPV19SQU5HRSgnVW5leHBlY3RlZCBmdXJ0aGVyIGlucHV0JywgdG9rX2dldFN0YXJ0KCksIHRva19nZXRTdG9wKCkpO1xufVxuX3RyZWUubG9jID0gQVNUX2dldENsb3NlTG9jKDAsIDEsIDAsIHRva19wcmV2RW5kUG9pbnRlcigpLCB0b2tfZ2V0TGluZSgpLCB0b2tfZ2V0Q29sdW1uKCkpO1xucmV0dXJuIHthc3Q6X3RyZWUsIHRva2Vuczp0b2sudG9rZW5zLCB0b2tlbkNvdW50U29saWQ6dG9rLmdldFRva2VuQ291bnRTb2xpZCgpLCB0b2tlbkNvdW50QW55OnRvay5nZXRUb2tlbkNvdW50QW55KCl9O1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZVN0YXJ0KHR5cGUpIHtcbnJldHVybiAoKCgoKCh0eXBlID09PSA1MjQzMDgpIHx8ICh0eXBlID09PSA1MjQzMDUpKSkgfHwgKHR5cGUgPT09IDE1NzI4ODQpKSkgfHwgKHR5cGUgPT09IDE1NzI4ODEpKTtcbn1cbmZ1bmN0aW9uIEQoZCkge1xuaWYgKGQgPT09IDApIHtcbnJldHVybiAnRD1NSUdIVF9ERVNUUlVDVCc7XG59XG5sZXQgYXJyID0gW107XG5pZiAoZCAmIDEpIHtcbmFyci5wdXNoKCdDQU5UX0RFU1RSVUNUJyk7XG5kIF49IDE7XG59XG5pZiAoZCAmIDQpIHtcbmFyci5wdXNoKCdNVVNUX0RFU1RSVUNUJyk7XG5kIF49IDQ7XG59XG5pZiAoZCAmIDIpIHtcbmFyci5wdXNoKCdERVNUUlVDVF9BU1NJR05fT05MWScpO1xuZCBePSAyO1xufVxuaWYgKGQgJiA4KSB7XG5hcnIucHVzaCgnKEFTU0lHTkFCTEVfVU5ERVRFUk1JTkVEKScpO1xuZCBePSA4O1xufVxuaWYgKGQgJiAxNikge1xuYXJyLnB1c2goJyhOT1RfQVNTSUdOQUJMRSknKTtcbmQgXj0gMTY7XG59XG5pZiAoZCAmIDMyKSB7XG5hcnIucHVzaCgnKElTX0FTU0lHTkFCTEUpJyk7XG5kIF49IDMyO1xufVxuZCA9IFAoZCwgYXJyKTtcbmlmIChkICE9PSAwKSB7XG5jb25zb2xlLmxvZygnR2F0aGVyZWQgZmxhZ3Mgc28gZmFyOicsIGFyci5qb2luKCcsICcpKTtcbn1cbnJldHVybiAnRD0nICsgYXJyLmpvaW4oJywgJyk7XG59XG5mdW5jdGlvbiBBKGEpIHtcbmlmIChhID09PSAwKSB7XG5yZXR1cm4gJ0E9QVNTSUdOQUJMRV9VTkRFVEVSTUlORUQnO1xufVxubGV0IGFyciA9IFtdO1xuaWYgKGEgJiA4KSB7XG5hcnIucHVzaCgnQVNTSUdOQUJMRV9VTkRFVEVSTUlORUQnKTtcbmEgXj0gODtcbn1cbmlmIChhICYgMTYpIHtcbmFyci5wdXNoKCdOT1RfQVNTSUdOQUJMRScpO1xuYSBePSAxNjtcbn1cbmlmIChhICYgMzIpIHtcbmFyci5wdXNoKCdJU19BU1NJR05BQkxFJyk7XG5hIF49IDMyO1xufVxuaWYgKGEgJiAxKSB7XG5hcnIucHVzaCgnKENBTlRfREVTVFJVQ1QpJyk7XG5hIF49IDE7XG59XG5pZiAoYSAmIDQpIHtcbmFyci5wdXNoKCcoTVVTVF9ERVNUUlVDVCknKTtcbmEgXj0gNDtcbn1cbmlmIChhICYgMikge1xuYXJyLnB1c2goJyhERVNUUlVDVF9BU1NJR05fT05MWSknKTtcbmEgXj0gMjtcbn1cbmEgPSBQKGEsIGFycik7XG5pZiAoYSAhPT0gMCkge1xuY29uc29sZS5sb2coJ0dhdGhlcmVkIGZsYWdzIHNvIGZhcjonLCBhcnIuam9pbignLCAnKSk7XG59XG5yZXR1cm4gJ0E9JyArIGFyci5qb2luKCcsICcpO1xufVxuZnVuY3Rpb24gQihiKSB7XG5pZiAoYiA9PT0gMCkgcmV0dXJuICdCPUJJTkRJTkdfVFlQRV9OT05FJztcbmlmIChiID09PSAxKSByZXR1cm4gJ0I9QklORElOR19UWVBFX0FSRyc7XG5pZiAoYiA9PT0gMikgcmV0dXJuICdCPUJJTkRJTkdfVFlQRV9WQVInO1xuaWYgKGIgPT09IDYpIHJldHVybiAnQj1CSU5ESU5HX1RZUEVfTEVUJztcbmlmIChiID09PSA3KSByZXR1cm4gJ0I9QklORElOR19UWVBFX0NPTlNUJztcbmlmIChiID09PSA4KSByZXR1cm4gJ0I9QklORElOR19UWVBFX0NMQVNTJztcbmlmIChiID09PSA5KSByZXR1cm4gJ0I9QklORElOR19UWVBFX0NBVENIX0lERU5UJztcbmlmIChiID09PSAxMCkgcmV0dXJuICdCPUJJTkRJTkdfVFlQRV9DQVRDSF9PVEhFUic7XG5pZiAoYiA9PT0gMykgcmV0dXJuICdCPUJJTkRJTkdfVFlQRV9GVU5DX1ZBUic7XG5pZiAoYiA9PT0gNSkgcmV0dXJuICdCPUJJTkRJTkdfVFlQRV9GVU5DX0xFWCc7XG5pZiAoYiA9PT0gNCkgcmV0dXJuICdCPUJJTkRJTkdfVFlQRV9GVU5DX1NUTVQnO1xufVxuZnVuY3Rpb24gUyhzKSB7XG5pZiAocyA9PT0gMCkgcmV0dXJuICdTQ09QRV9MQVlFUl9HTE9CQUwnO1xuaWYgKHMgPT09IDEpIHJldHVybiAnU0NPUEVfTEFZRVJfRk9SX0hFQURFUic7XG5pZiAocyA9PT0gMikgcmV0dXJuICdTQ09QRV9MQVlFUl9CTE9DSyc7XG5pZiAocyA9PT0gMykgcmV0dXJuICdTQ09QRV9MQVlFUl9GVU5DX1BBUkFNUyc7XG5pZiAocyA9PT0gNCkgcmV0dXJuICdTQ09QRV9MQVlFUl9UUlknO1xuaWYgKHMgPT09IDUpIHJldHVybiAnU0NPUEVfTEFZRVJfQ0FUQ0hfSEVBRCc7XG5pZiAocyA9PT0gNikgcmV0dXJuICdTQ09QRV9MQVlFUl9DQVRDSF9CT0RZJztcbmlmIChzID09PSA3KSByZXR1cm4gJ1NDT1BFX0xBWUVSX0ZJTkFMTFknO1xuaWYgKHMgPT09IDgpIHJldHVybiAnU0NPUEVfTEFZRVJfU1dJVENIJztcbmlmIChzID09PSA5KSByZXR1cm4gJ1NDT1BFX0xBWUVSX0ZVTkNfUk9PVCc7XG5pZiAocyA9PT0gMTApIHJldHVybiAnU0NPUEVfTEFZRVJfRlVOQ19CT0RZJztcbmlmIChzID09PSAxMSkgcmV0dXJuICdTQ09QRV9MQVlFUl9BUlJPV19QQVJBTVMnO1xuaWYgKHMgPT09IDEyKSByZXR1cm4gJ1NDT1BFX0xBWUVSX0ZBS0VfQkxPQ0snO1xufVxuZnVuY3Rpb24gRihmZFN0YXRlKSB7XG5pZiAoZmRTdGF0ZSA9PT0gMSkgcmV0dXJuICdGPUZEU19JTExFR0FMJzsgZWxzZSBpZiAoZmRTdGF0ZSA9PT0gMikgcmV0dXJuICdGPUZEU19JRkVMU0UnOyBlbHNlIGlmIChmZFN0YXRlID09PSAzKSByZXR1cm4gJ0Y9RkRTX0xFWCc7IGVsc2UgaWYgKGZkU3RhdGUgPT09IDQpIHJldHVybiAnRj1GRFNfVkFSJzsgZWxzZSA7XG59XG4vLyA8L3BhcnNlcj5cblxuXG5sZXQgVGVua28gPSBQYXJzZXI7XG5cblxuZXhwb3J0IGRlZmF1bHQgVGVua287IC8vIERvZXMgZHVhbCBleHBvcnQgbWFrZSBzZW5zZT8gRGVmYXVsdCBhbmQgYXMgbWVtYmVyLiBUbyBlYWNoIHRoZWlyIG93biwgZWhcbmV4cG9ydCB7XG5cbiAgVGVua28sXG4gIExleGVyLFxuXG4gIENPTExFQ1RfVE9LRU5TX05PTkUsXG4gIENPTExFQ1RfVE9LRU5TX1NPTElELFxuICBDT0xMRUNUX1RPS0VOU19BTEwsXG4gIENPTExFQ1RfVE9LRU5TX1RZUEVTLFxuXG4gIEdPQUxfTU9EVUxFLFxuICBHT0FMX1NDUklQVCxcblxuICBXRUJfQ09NUEFUX09GRixcbiAgV0VCX0NPTVBBVF9PTixcblxuICBWRVJTSU9OX0VYUE9ORU5USUFUSU9OLFxuICBWRVJTSU9OX1dIQVRFVkVSLFxuXG4gIGlzV2hpdGVUb2tlbixcbiAgaXNOZXdsaW5lVG9rZW4sXG4gIGlzQ29tbWVudFRva2VuLFxuICBpc0lkZW50VG9rZW4sXG4gIGlzTnVtYmVyVG9rZW4sXG4gIGlzQmlnaW50VG9rZW4sXG4gIGlzU3RyaW5nVG9rZW4sXG4gIGlzUHVuY3R1YXRvclRva2VuLFxuICBpc1JlZ2V4VG9rZW4sXG4gIGlzVGlja1Rva2VuLFxuICBpc0JhZFRpY2tUb2tlbixcbiAgaXNOdW1iZXJTdHJpbmdUb2tlbixcbiAgaXNOdW1iZXJTdHJpbmdSZWdleCxcblxuICB0b2t0eXBlVG9TdHJpbmcsXG5cbn07XG4gICJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tenko/build/tenko.prod.mjs\n");

/***/ })

}]);