(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[32],{

/***/ "./node_modules/chevrotain/lib_esm/src/api.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/api.js ***!
  \****************************************************/
/*! exports provided: VERSION, Parser, CstParser, EmbeddedActionsParser, ParserDefinitionErrorType, EMPTY_ALT, Lexer, LexerDefinitionErrorType, createToken, createTokenInstance, EOF, tokenLabel, tokenMatcher, tokenName, defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider, defaultParserErrorProvider, EarlyExitException, isRecognitionException, MismatchedTokenException, NotAllInputParsedException, NoViableAltException, defaultLexerErrorProvider, Alternation, Flat, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, serializeGrammar, serializeProduction, GAstVisitor, assignOccurrenceIndices, resolveGrammar, validateGrammar, clearCache, createSyntaxDiagramsCode, generateParserFactory, generateParserModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearCache\", function() { return clearCache; });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"./node_modules/chevrotain/lib_esm/src/version.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return _version__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"]; });\n\n/* harmony import */ var _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse/parser/parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"Parser\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CstParser\", function() { return _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"CstParser\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EmbeddedActionsParser\", function() { return _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"EmbeddedActionsParser\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ParserDefinitionErrorType\", function() { return _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_ALT\", function() { return _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"EMPTY_ALT\"]; });\n\n/* harmony import */ var _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scan/lexer_public */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__[\"Lexer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LexerDefinitionErrorType\", function() { return _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__[\"LexerDefinitionErrorType\"]; });\n\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createToken\", function() { return _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__[\"createToken\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createTokenInstance\", function() { return _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__[\"createTokenInstance\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EOF\", function() { return _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__[\"EOF\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"tokenLabel\", function() { return _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__[\"tokenLabel\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"tokenMatcher\", function() { return _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__[\"tokenMatcher\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"tokenName\", function() { return _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__[\"tokenName\"]; });\n\n/* harmony import */ var _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse/errors_public */ \"./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defaultGrammarResolverErrorProvider\", function() { return _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__[\"defaultGrammarResolverErrorProvider\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defaultGrammarValidatorErrorProvider\", function() { return _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__[\"defaultGrammarValidatorErrorProvider\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defaultParserErrorProvider\", function() { return _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__[\"defaultParserErrorProvider\"]; });\n\n/* harmony import */ var _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse/exceptions_public */ \"./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EarlyExitException\", function() { return _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__[\"EarlyExitException\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isRecognitionException\", function() { return _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__[\"isRecognitionException\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MismatchedTokenException\", function() { return _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__[\"MismatchedTokenException\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NotAllInputParsedException\", function() { return _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__[\"NotAllInputParsedException\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NoViableAltException\", function() { return _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__[\"NoViableAltException\"]; });\n\n/* harmony import */ var _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scan/lexer_errors_public */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defaultLexerErrorProvider\", function() { return _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_6__[\"defaultLexerErrorProvider\"]; });\n\n/* harmony import */ var _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parse/grammar/gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Alternation\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"Alternation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Flat\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"Flat\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NonTerminal\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"NonTerminal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Option\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"Option\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Repetition\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"Repetition\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RepetitionMandatory\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"RepetitionMandatory\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RepetitionMandatoryWithSeparator\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"RepetitionMandatoryWithSeparator\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RepetitionWithSeparator\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"RepetitionWithSeparator\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Rule\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"Rule\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Terminal\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"Terminal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"serializeGrammar\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"serializeGrammar\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"serializeProduction\", function() { return _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__[\"serializeProduction\"]; });\n\n/* harmony import */ var _parse_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse/grammar/gast/gast_visitor_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GAstVisitor\", function() { return _parse_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_8__[\"GAstVisitor\"]; });\n\n/* harmony import */ var _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parse/grammar/gast/gast_resolver_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"assignOccurrenceIndices\", function() { return _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__[\"assignOccurrenceIndices\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"resolveGrammar\", function() { return _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__[\"resolveGrammar\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"validateGrammar\", function() { return _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__[\"validateGrammar\"]; });\n\n/* harmony import */ var _diagrams_render_public__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./diagrams/render_public */ \"./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createSyntaxDiagramsCode\", function() { return _diagrams_render_public__WEBPACK_IMPORTED_MODULE_10__[\"createSyntaxDiagramsCode\"]; });\n\n/* harmony import */ var _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./generate/generate_public */ \"./node_modules/chevrotain/lib_esm/src/generate/generate_public.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"generateParserFactory\", function() { return _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__[\"generateParserFactory\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"generateParserModule\", function() { return _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__[\"generateParserModule\"]; });\n\n// semantic version\n\n\n\n// Tokens utilities\n\n// Other Utilities\n\n\n\n// grammar reflection API\n\n// GAST Utilities\n\n\n\n/* istanbul ignore next */\nfunction clearCache() {\n    console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n        \"\\n\\t It performs no action other than printing this message.\" +\n        \"\\n\\t Please avoid using it as it will be completely removed in the future\");\n}\n\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9hcGkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9hcGkuanM/ZmE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZW1hbnRpYyB2ZXJzaW9uXG5leHBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvblwiO1xuZXhwb3J0IHsgUGFyc2VyLCBDc3RQYXJzZXIsIEVtYmVkZGVkQWN0aW9uc1BhcnNlciwgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZSwgRU1QVFlfQUxUIH0gZnJvbSBcIi4vcGFyc2UvcGFyc2VyL3BhcnNlclwiO1xuZXhwb3J0IHsgTGV4ZXIsIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSB9IGZyb20gXCIuL3NjYW4vbGV4ZXJfcHVibGljXCI7XG4vLyBUb2tlbnMgdXRpbGl0aWVzXG5leHBvcnQgeyBjcmVhdGVUb2tlbiwgY3JlYXRlVG9rZW5JbnN0YW5jZSwgRU9GLCB0b2tlbkxhYmVsLCB0b2tlbk1hdGNoZXIsIHRva2VuTmFtZSB9IGZyb20gXCIuL3NjYW4vdG9rZW5zX3B1YmxpY1wiO1xuLy8gT3RoZXIgVXRpbGl0aWVzXG5leHBvcnQgeyBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlciwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLCBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuL3BhcnNlL2Vycm9yc19wdWJsaWNcIjtcbmV4cG9ydCB7IEVhcmx5RXhpdEV4Y2VwdGlvbiwgaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbiwgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uLCBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbiwgTm9WaWFibGVBbHRFeGNlcHRpb24gfSBmcm9tIFwiLi9wYXJzZS9leGNlcHRpb25zX3B1YmxpY1wiO1xuZXhwb3J0IHsgZGVmYXVsdExleGVyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpY1wiO1xuLy8gZ3JhbW1hciByZWZsZWN0aW9uIEFQSVxuZXhwb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwgfSBmcm9tIFwiLi9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbi8vIEdBU1QgVXRpbGl0aWVzXG5leHBvcnQgeyBzZXJpYWxpemVHcmFtbWFyLCBzZXJpYWxpemVQcm9kdWN0aW9uIH0gZnJvbSBcIi4vcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfcHVibGljXCI7XG5leHBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljXCI7XG5leHBvcnQgeyBhc3NpZ25PY2N1cnJlbmNlSW5kaWNlcywgcmVzb2x2ZUdyYW1tYXIsIHZhbGlkYXRlR3JhbW1hciB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3Jlc29sdmVyX3B1YmxpY1wiO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBjbGVhckNhY2hlIGZ1bmN0aW9uIHdhcyAnc29mdCcgcmVtb3ZlZCBmcm9tIHRoZSBDaGV2cm90YWluIEFQSS5cIiArXG4gICAgICAgIFwiXFxuXFx0IEl0IHBlcmZvcm1zIG5vIGFjdGlvbiBvdGhlciB0aGFuIHByaW50aW5nIHRoaXMgbWVzc2FnZS5cIiArXG4gICAgICAgIFwiXFxuXFx0IFBsZWFzZSBhdm9pZCB1c2luZyBpdCBhcyBpdCB3aWxsIGJlIGNvbXBsZXRlbHkgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXCIpO1xufVxuZXhwb3J0IHsgY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlIH0gZnJvbSBcIi4vZGlhZ3JhbXMvcmVuZGVyX3B1YmxpY1wiO1xuZXhwb3J0IHsgZ2VuZXJhdGVQYXJzZXJGYWN0b3J5LCBnZW5lcmF0ZVBhcnNlck1vZHVsZSB9IGZyb20gXCIuL2dlbmVyYXRlL2dlbmVyYXRlX3B1YmxpY1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/api.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js":
/*!***********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js ***!
  \***********************************************************************/
/*! exports provided: createSyntaxDiagramsCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createSyntaxDiagramsCode\", function() { return createSyntaxDiagramsCode; });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version */ \"./node_modules/chevrotain/lib_esm/src/version.js\");\n\nfunction createSyntaxDiagramsCode(grammar, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? \"https://unpkg.com/chevrotain@\" + _version__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"] + \"/diagrams/\" : _c, _d = _b.css, css = _d === void 0 ? \"https://unpkg.com/chevrotain@\" + _version__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"] + \"/diagrams/diagrams.css\" : _d;\n    var header = \"\\n<!-- This is a generated file -->\\n<!DOCTYPE html>\\n<meta charset=\\\"utf-8\\\">\\n<style>\\n  body {\\n    background-color: hsl(30, 20%, 95%)\\n  }\\n</style>\\n\\n\";\n    var cssHtml = \"\\n<link rel='stylesheet' href='\" + css + \"'>\\n\";\n    var scripts = \"\\n<script src='\" + resourceBase + \"vendor/railroad-diagrams.js'></script>\\n<script src='\" + resourceBase + \"src/diagrams_builder.js'></script>\\n<script src='\" + resourceBase + \"src/diagrams_behavior.js'></script>\\n<script src='\" + resourceBase + \"src/main.js'></script>\\n\";\n    var diagramsDiv = \"\\n<div id=\\\"diagrams\\\" align=\\\"center\\\"></div>    \\n\";\n    var serializedGrammar = \"\\n<script>\\n    window.serializedGrammar = \" + JSON.stringify(grammar, null, \"  \") + \";\\n</script>\\n\";\n    var initLogic = \"\\n<script>\\n    var diagramsDiv = document.getElementById(\\\"diagrams\\\");\\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\\n</script>\\n\";\n    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);\n}\n//# sourceMappingURL=render_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9kaWFncmFtcy9yZW5kZXJfcHVibGljLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvZGlhZ3JhbXMvcmVuZGVyX3B1YmxpYy5qcz8zYmY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi4vdmVyc2lvblwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZShncmFtbWFyLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnJlc291cmNlQmFzZSwgcmVzb3VyY2VCYXNlID0gX2MgPT09IHZvaWQgMCA/IFwiaHR0cHM6Ly91bnBrZy5jb20vY2hldnJvdGFpbkBcIiArIFZFUlNJT04gKyBcIi9kaWFncmFtcy9cIiA6IF9jLCBfZCA9IF9iLmNzcywgY3NzID0gX2QgPT09IHZvaWQgMCA/IFwiaHR0cHM6Ly91bnBrZy5jb20vY2hldnJvdGFpbkBcIiArIFZFUlNJT04gKyBcIi9kaWFncmFtcy9kaWFncmFtcy5jc3NcIiA6IF9kO1xuICAgIHZhciBoZWFkZXIgPSBcIlxcbjwhLS0gVGhpcyBpcyBhIGdlbmVyYXRlZCBmaWxlIC0tPlxcbjwhRE9DVFlQRSBodG1sPlxcbjxtZXRhIGNoYXJzZXQ9XFxcInV0Zi04XFxcIj5cXG48c3R5bGU+XFxuICBib2R5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaHNsKDMwLCAyMCUsIDk1JSlcXG4gIH1cXG48L3N0eWxlPlxcblxcblwiO1xuICAgIHZhciBjc3NIdG1sID0gXCJcXG48bGluayByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J1wiICsgY3NzICsgXCInPlxcblwiO1xuICAgIHZhciBzY3JpcHRzID0gXCJcXG48c2NyaXB0IHNyYz0nXCIgKyByZXNvdXJjZUJhc2UgKyBcInZlbmRvci9yYWlscm9hZC1kaWFncmFtcy5qcyc+PC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiICsgcmVzb3VyY2VCYXNlICsgXCJzcmMvZGlhZ3JhbXNfYnVpbGRlci5qcyc+PC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiICsgcmVzb3VyY2VCYXNlICsgXCJzcmMvZGlhZ3JhbXNfYmVoYXZpb3IuanMnPjwvc2NyaXB0PlxcbjxzY3JpcHQgc3JjPSdcIiArIHJlc291cmNlQmFzZSArIFwic3JjL21haW4uanMnPjwvc2NyaXB0PlxcblwiO1xuICAgIHZhciBkaWFncmFtc0RpdiA9IFwiXFxuPGRpdiBpZD1cXFwiZGlhZ3JhbXNcXFwiIGFsaWduPVxcXCJjZW50ZXJcXFwiPjwvZGl2PiAgICBcXG5cIjtcbiAgICB2YXIgc2VyaWFsaXplZEdyYW1tYXIgPSBcIlxcbjxzY3JpcHQ+XFxuICAgIHdpbmRvdy5zZXJpYWxpemVkR3JhbW1hciA9IFwiICsgSlNPTi5zdHJpbmdpZnkoZ3JhbW1hciwgbnVsbCwgXCIgIFwiKSArIFwiO1xcbjwvc2NyaXB0PlxcblwiO1xuICAgIHZhciBpbml0TG9naWMgPSBcIlxcbjxzY3JpcHQ+XFxuICAgIHZhciBkaWFncmFtc0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJkaWFncmFtc1xcXCIpO1xcbiAgICBtYWluLmRyYXdEaWFncmFtc0Zyb21TZXJpYWxpemVkR3JhbW1hcihzZXJpYWxpemVkR3JhbW1hciwgZGlhZ3JhbXNEaXYpO1xcbjwvc2NyaXB0PlxcblwiO1xuICAgIHJldHVybiAoaGVhZGVyICsgY3NzSHRtbCArIHNjcmlwdHMgKyBkaWFncmFtc0RpdiArIHNlcmlhbGl6ZWRHcmFtbWFyICsgaW5pdExvZ2ljKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcl9wdWJsaWMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/diagrams/render_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/generate/generate.js":
/*!******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/generate/generate.js ***!
  \******************************************************************/
/*! exports provided: genUmdModule, genWrapperFunction, genClass, genAllRules, genRule, genTerminal, genNonTerminal, genAlternation, genSingleAlt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genUmdModule\", function() { return genUmdModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genWrapperFunction\", function() { return genWrapperFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genClass\", function() { return genClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genAllRules\", function() { return genAllRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genRule\", function() { return genRule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genTerminal\", function() { return genTerminal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genNonTerminal\", function() { return genNonTerminal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genAlternation\", function() { return genAlternation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genSingleAlt\", function() { return genSingleAlt; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parse/grammar/gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\n\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\nvar NL = \"\\n\";\nfunction genUmdModule(options) {\n    return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nfunction genWrapperFunction(options) {\n    return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nfunction genClass(options) {\n    // TODO: how to pass the token vocabulary? Constructor? other?\n    var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n    return result;\n}\nfunction genAllRules(rules) {\n    var rulesText = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(rules, function (currRule) {\n        return genRule(currRule, 1);\n    });\n    return rulesText.join(\"\\n\");\n}\nfunction genRule(prod, n) {\n    var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"})\") + NL;\n    return result;\n}\nfunction genTerminal(prod, n) {\n    var name = prod.terminalType.name;\n    // TODO: potential performance optimization, avoid tokenMap Dictionary access\n    return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nfunction genNonTerminal(prod, n) {\n    return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nfunction genAlternation(prod, n) {\n    var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n    var alts = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });\n    result += alts.join(\",\" + NL);\n    result += NL + indent(n, \"])\" + NL);\n    return result;\n}\nfunction genSingleAlt(prod, n) {\n    var result = indent(n, \"{\") + NL;\n    if (prod.name) {\n        result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\",\") + NL;\n    }\n    result += indent(n + 1, \"ALT: function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"}\") + NL;\n    result += indent(n, \"}\");\n    return result;\n}\nfunction genProd(prod, n) {\n    /* istanbul ignore else */\n    if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"]) {\n        return genNonTerminal(prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"]) {\n        return genDSLRule(\"OPTION\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatory\"]) {\n        return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatoryWithSeparator\"]) {\n        return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionWithSeparator\"]) {\n        return genDSLRule(\"MANY_SEP\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Repetition\"]) {\n        return genDSLRule(\"MANY\", prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Alternation\"]) {\n        return genAlternation(prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]) {\n        return genTerminal(prod, n);\n    }\n    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Flat\"]) {\n        return genDefinition(prod.definition, n);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction genDSLRule(dslName, prod, n) {\n    var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n    if (prod.name || prod.separator) {\n        result += \"{\" + NL;\n        if (prod.name) {\n            result += indent(n + 1, \"NAME: \\\"\" + prod.name + \"\\\"\") + \",\" + NL;\n        }\n        if (prod.separator) {\n            result +=\n                indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) +\n                    \",\" +\n                    NL;\n        }\n        result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n        result += indent(n, \"}\") + NL;\n    }\n    else {\n        result += genDefFunction(prod.definition, n + 1);\n    }\n    result += indent(n, \")\") + NL;\n    return result;\n}\nfunction genDefFunction(definition, n) {\n    var def = \"function() {\" + NL;\n    def += genDefinition(definition, n);\n    def += indent(n, \"}\") + NL;\n    return def;\n}\nfunction genDefinition(def, n) {\n    var result = \"\";\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(def, function (prod) {\n        result += genProd(prod, n + 1);\n    });\n    return result;\n}\nfunction indent(howMuch, text) {\n    var spaces = Array(howMuch * 4 + 1).join(\" \");\n    return spaces + text;\n}\n//# sourceMappingURL=generate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9nZW5lcmF0ZS9nZW5lcmF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2dlbmVyYXRlL2dlbmVyYXRlLmpzP2Q0NDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9yRWFjaCwgbWFwIH0gZnJvbSBcIi4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBSZXBldGl0aW9uTWFuZGF0b3J5LCBPcHRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgVGVybWluYWwsIE5vblRlcm1pbmFsLCBBbHRlcm5hdGlvbiwgRmxhdCwgUmVwZXRpdGlvbiB9IGZyb20gXCIuLi9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbi8qKlxuICogTWlzc2luZyBmZWF0dXJlc1xuICogMS4gUnVsZSBhcmd1bWVudHNcbiAqIDIuIEdhdGVzXG4gKiAzLiBlbWJlZGRlZCBhY3Rpb25zXG4gKi9cbnZhciBOTCA9IFwiXFxuXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2VuVW1kTW9kdWxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gXCJcXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxcbiAgICAgICAgZGVmaW5lKFsnY2hldnJvdGFpbiddLCBmYWN0b3J5KTtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdjaGV2cm90YWluJykpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3Rvcnkocm9vdC5iKTtcXG4gICAgfVxcbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uIChjaGV2cm90YWluKSB7XFxuXFxuXCIgKyBnZW5DbGFzcyhvcHRpb25zKSArIFwiXFxuICAgIFxcbnJldHVybiB7XFxuICAgIFwiICsgb3B0aW9ucy5uYW1lICsgXCI6IFwiICsgb3B0aW9ucy5uYW1lICsgXCIgXFxufVxcbn0pKTtcXG5cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5XcmFwcGVyRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBcIiAgICBcXG5cIiArIGdlbkNsYXNzKG9wdGlvbnMpICsgXCJcXG5yZXR1cm4gbmV3IFwiICsgb3B0aW9ucy5uYW1lICsgXCIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpICAgIFxcblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbkNsYXNzKG9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBob3cgdG8gcGFzcyB0aGUgdG9rZW4gdm9jYWJ1bGFyeT8gQ29uc3RydWN0b3I/IG90aGVyP1xuICAgIHZhciByZXN1bHQgPSBcIlxcbmZ1bmN0aW9uIFwiICsgb3B0aW9ucy5uYW1lICsgXCIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcXG4gICAgLy8gaW52b2tlIHN1cGVyIGNvbnN0cnVjdG9yXFxuICAgIC8vIE5vIHN1cHBvcnQgZm9yIGVtYmVkZGVkIGFjdGlvbnMgY3VycmVudGx5LCBzbyB3ZSBjYW4gJ2hhcmRjb2RlJ1xcbiAgICAvLyBUaGUgdXNlIG9mIENzdFBhcnNlci5cXG4gICAgY2hldnJvdGFpbi5Dc3RQYXJzZXIuY2FsbCh0aGlzLCB0b2tlblZvY2FidWxhcnksIGNvbmZpZylcXG5cXG4gICAgY29uc3QgJCA9IHRoaXNcXG5cXG4gICAgXCIgKyBnZW5BbGxSdWxlcyhvcHRpb25zLnJ1bGVzKSArIFwiXFxuXFxuICAgIC8vIHZlcnkgaW1wb3J0YW50IHRvIGNhbGwgdGhpcyBhZnRlciBhbGwgdGhlIHJ1bGVzIGhhdmUgYmVlbiBkZWZpbmVkLlxcbiAgICAvLyBvdGhlcndpc2UgdGhlIHBhcnNlciBtYXkgbm90IHdvcmsgY29ycmVjdGx5IGFzIGl0IHdpbGwgbGFjayBpbmZvcm1hdGlvblxcbiAgICAvLyBkZXJpdmVkIGR1cmluZyB0aGUgc2VsZiBhbmFseXNpcyBwaGFzZS5cXG4gICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKHRoaXMpXFxufVxcblxcbi8vIGluaGVyaXRhbmNlIGFzIGltcGxlbWVudGVkIGluIGphdmFzY3JpcHQgaW4gdGhlIHByZXZpb3VzIGRlY2FkZS4uLiA6KFxcblwiICsgb3B0aW9ucy5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjaGV2cm90YWluLkNzdFBhcnNlci5wcm90b3R5cGUpXFxuXCIgKyBvcHRpb25zLm5hbWUgKyBcIi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBcIiArIG9wdGlvbnMubmFtZSArIFwiICAgIFxcbiAgICBcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbkFsbFJ1bGVzKHJ1bGVzKSB7XG4gICAgdmFyIHJ1bGVzVGV4dCA9IG1hcChydWxlcywgZnVuY3Rpb24gKGN1cnJSdWxlKSB7XG4gICAgICAgIHJldHVybiBnZW5SdWxlKGN1cnJSdWxlLCAxKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnVsZXNUZXh0LmpvaW4oXCJcXG5cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuUnVsZShwcm9kLCBuKSB7XG4gICAgdmFyIHJlc3VsdCA9IGluZGVudChuLCBcIiQuUlVMRShcXFwiXCIgKyBwcm9kLm5hbWUgKyBcIlxcXCIsIGZ1bmN0aW9uKCkge1wiKSArIE5MO1xuICAgIHJlc3VsdCArPSBnZW5EZWZpbml0aW9uKHByb2QuZGVmaW5pdGlvbiwgbiArIDEpO1xuICAgIHJlc3VsdCArPSBpbmRlbnQobiArIDEsIFwifSlcIikgKyBOTDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlblRlcm1pbmFsKHByb2QsIG4pIHtcbiAgICB2YXIgbmFtZSA9IHByb2QudGVybWluYWxUeXBlLm5hbWU7XG4gICAgLy8gVE9ETzogcG90ZW50aWFsIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgYXZvaWQgdG9rZW5NYXAgRGljdGlvbmFyeSBhY2Nlc3NcbiAgICByZXR1cm4gaW5kZW50KG4sIFwiJC5DT05TVU1FXCIgKyBwcm9kLmlkeCArIFwiKHRoaXMudG9rZW5zTWFwLlwiICsgbmFtZSArIFwiKVwiICsgTkwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbk5vblRlcm1pbmFsKHByb2QsIG4pIHtcbiAgICByZXR1cm4gaW5kZW50KG4sIFwiJC5TVUJSVUxFXCIgKyBwcm9kLmlkeCArIFwiKCQuXCIgKyBwcm9kLm5vblRlcm1pbmFsTmFtZSArIFwiKVwiICsgTkwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbkFsdGVybmF0aW9uKHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwiJC5PUlwiICsgcHJvZC5pZHggKyBcIihbXCIpICsgTkw7XG4gICAgdmFyIGFsdHMgPSBtYXAocHJvZC5kZWZpbml0aW9uLCBmdW5jdGlvbiAoYWx0RGVmKSB7IHJldHVybiBnZW5TaW5nbGVBbHQoYWx0RGVmLCBuICsgMSk7IH0pO1xuICAgIHJlc3VsdCArPSBhbHRzLmpvaW4oXCIsXCIgKyBOTCk7XG4gICAgcmVzdWx0ICs9IE5MICsgaW5kZW50KG4sIFwiXSlcIiArIE5MKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlblNpbmdsZUFsdChwcm9kLCBuKSB7XG4gICAgdmFyIHJlc3VsdCA9IGluZGVudChuLCBcIntcIikgKyBOTDtcbiAgICBpZiAocHJvZC5uYW1lKSB7XG4gICAgICAgIHJlc3VsdCArPSBpbmRlbnQobiArIDEsIFwiTkFNRTogXFxcIlwiICsgcHJvZC5uYW1lICsgXCJcXFwiLFwiKSArIE5MO1xuICAgIH1cbiAgICByZXN1bHQgKz0gaW5kZW50KG4gKyAxLCBcIkFMVDogZnVuY3Rpb24oKSB7XCIpICsgTkw7XG4gICAgcmVzdWx0ICs9IGdlbkRlZmluaXRpb24ocHJvZC5kZWZpbml0aW9uLCBuICsgMSk7XG4gICAgcmVzdWx0ICs9IGluZGVudChuICsgMSwgXCJ9XCIpICsgTkw7XG4gICAgcmVzdWx0ICs9IGluZGVudChuLCBcIn1cIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlblByb2QocHJvZCwgbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gZ2VuTm9uVGVybWluYWwocHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIGdlbkRTTFJ1bGUoXCJPUFRJT05cIiwgcHJvZCwgbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiBnZW5EU0xSdWxlKFwiQVRfTEVBU1RfT05FXCIsIHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGdlbkRTTFJ1bGUoXCJBVF9MRUFTVF9PTkVfU0VQXCIsIHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGdlbkRTTFJ1bGUoXCJNQU5ZX1NFUFwiLCBwcm9kLCBuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGdlbkRTTFJ1bGUoXCJNQU5ZXCIsIHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGdlbkFsdGVybmF0aW9uKHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIGdlblRlcm1pbmFsKHByb2QsIG4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgRmxhdCkge1xuICAgICAgICByZXR1cm4gZ2VuRGVmaW5pdGlvbihwcm9kLmRlZmluaXRpb24sIG4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5EU0xSdWxlKGRzbE5hbWUsIHByb2QsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gaW5kZW50KG4sIFwiJC5cIiArIChkc2xOYW1lICsgcHJvZC5pZHgpICsgXCIoXCIpO1xuICAgIGlmIChwcm9kLm5hbWUgfHwgcHJvZC5zZXBhcmF0b3IpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwie1wiICsgTkw7XG4gICAgICAgIGlmIChwcm9kLm5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnQobiArIDEsIFwiTkFNRTogXFxcIlwiICsgcHJvZC5uYW1lICsgXCJcXFwiXCIpICsgXCIsXCIgKyBOTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZC5zZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPVxuICAgICAgICAgICAgICAgIGluZGVudChuICsgMSwgXCJTRVA6IHRoaXMudG9rZW5zTWFwLlwiICsgcHJvZC5zZXBhcmF0b3IubmFtZSkgK1xuICAgICAgICAgICAgICAgICAgICBcIixcIiArXG4gICAgICAgICAgICAgICAgICAgIE5MO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIkRFRjogXCIgKyBnZW5EZWZGdW5jdGlvbihwcm9kLmRlZmluaXRpb24sIG4gKyAyKSArIE5MO1xuICAgICAgICByZXN1bHQgKz0gaW5kZW50KG4sIFwifVwiKSArIE5MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGdlbkRlZkZ1bmN0aW9uKHByb2QuZGVmaW5pdGlvbiwgbiArIDEpO1xuICAgIH1cbiAgICByZXN1bHQgKz0gaW5kZW50KG4sIFwiKVwiKSArIE5MO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5EZWZGdW5jdGlvbihkZWZpbml0aW9uLCBuKSB7XG4gICAgdmFyIGRlZiA9IFwiZnVuY3Rpb24oKSB7XCIgKyBOTDtcbiAgICBkZWYgKz0gZ2VuRGVmaW5pdGlvbihkZWZpbml0aW9uLCBuKTtcbiAgICBkZWYgKz0gaW5kZW50KG4sIFwifVwiKSArIE5MO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBnZW5EZWZpbml0aW9uKGRlZiwgbikge1xuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIGZvckVhY2goZGVmLCBmdW5jdGlvbiAocHJvZCkge1xuICAgICAgICByZXN1bHQgKz0gZ2VuUHJvZChwcm9kLCBuICsgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGluZGVudChob3dNdWNoLCB0ZXh0KSB7XG4gICAgdmFyIHNwYWNlcyA9IEFycmF5KGhvd011Y2ggKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgcmV0dXJuIHNwYWNlcyArIHRleHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/generate/generate.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/generate/generate_public.js":
/*!*************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/generate/generate_public.js ***!
  \*************************************************************************/
/*! exports provided: generateParserFactory, generateParserModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateParserFactory\", function() { return generateParserFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateParserModule\", function() { return generateParserModule; });\n/* harmony import */ var _generate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generate */ \"./node_modules/chevrotain/lib_esm/src/generate/generate.js\");\n\nfunction generateParserFactory(options) {\n    var wrapperText = Object(_generate__WEBPACK_IMPORTED_MODULE_0__[\"genWrapperFunction\"])({\n        name: options.name,\n        rules: options.rules\n    });\n    var constructorWrapper = new Function(\"tokenVocabulary\", \"config\", \"chevrotain\", wrapperText);\n    return function (config) {\n        return constructorWrapper(options.tokenVocabulary, config, \n        // TODO: check how the require is transpiled/webpacked\n        __webpack_require__(/*! ../api */ \"./node_modules/chevrotain/lib_esm/src/api.js\"));\n    };\n}\nfunction generateParserModule(options) {\n    return Object(_generate__WEBPACK_IMPORTED_MODULE_0__[\"genUmdModule\"])({ name: options.name, rules: options.rules });\n}\n//# sourceMappingURL=generate_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9nZW5lcmF0ZS9nZW5lcmF0ZV9wdWJsaWMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9nZW5lcmF0ZS9nZW5lcmF0ZV9wdWJsaWMuanM/Njc5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW5VbWRNb2R1bGUsIGdlbldyYXBwZXJGdW5jdGlvbiB9IGZyb20gXCIuL2dlbmVyYXRlXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXJzZXJGYWN0b3J5KG9wdGlvbnMpIHtcbiAgICB2YXIgd3JhcHBlclRleHQgPSBnZW5XcmFwcGVyRnVuY3Rpb24oe1xuICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICAgIHJ1bGVzOiBvcHRpb25zLnJ1bGVzXG4gICAgfSk7XG4gICAgdmFyIGNvbnN0cnVjdG9yV3JhcHBlciA9IG5ldyBGdW5jdGlvbihcInRva2VuVm9jYWJ1bGFyeVwiLCBcImNvbmZpZ1wiLCBcImNoZXZyb3RhaW5cIiwgd3JhcHBlclRleHQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcldyYXBwZXIob3B0aW9ucy50b2tlblZvY2FidWxhcnksIGNvbmZpZywgXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGhvdyB0aGUgcmVxdWlyZSBpcyB0cmFuc3BpbGVkL3dlYnBhY2tlZFxuICAgICAgICByZXF1aXJlKFwiLi4vYXBpXCIpKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGFyc2VyTW9kdWxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2VuVW1kTW9kdWxlKHsgbmFtZTogb3B0aW9ucy5uYW1lLCBydWxlczogb3B0aW9ucy5ydWxlcyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlX3B1YmxpYy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/generate/generate_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js ***!
  \*********************************************************************/
/*! exports provided: classNameFromInstance, functionName, defineNameProp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"classNameFromInstance\", function() { return classNameFromInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"functionName\", function() { return functionName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defineNameProp\", function() { return defineNameProp; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\nfunction classNameFromInstance(instance) {\n    return functionName(instance.constructor);\n}\nvar FUNC_NAME_REGEXP = /^\\s*function\\s*(\\S*)\\s*\\(/;\nvar NAME = \"name\";\n/* istanbul ignore next too many hacks for IE/old versions of node.js here*/\nfunction functionName(func) {\n    // Engines that support Function.prototype.name OR the nth (n>1) time after\n    // the name has been computed in the following else block.\n    var existingNameProp = func.name;\n    if (existingNameProp) {\n        return existingNameProp;\n    }\n    // hack for IE and engines that do not support Object.defineProperty on function.name (Node.js 0.10 && 0.12)\n    var computedName = func.toString().match(FUNC_NAME_REGEXP)[1];\n    return computedName;\n}\n/**\n * @returns {boolean} - has the property been successfully defined\n */\nfunction defineNameProp(obj, nameValue) {\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);\n    /* istanbul ignore else -> will only run in old versions of node.js */\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isUndefined\"])(namePropDescriptor) || namePropDescriptor.configurable) {\n        Object.defineProperty(obj, NAME, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: nameValue\n        });\n        return true;\n    }\n    /* istanbul ignore next -> will only run in old versions of node.js */\n    return false;\n}\n//# sourceMappingURL=lang_extensions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9sYW5nL2xhbmdfZXh0ZW5zaW9ucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL2xhbmcvbGFuZ19leHRlbnNpb25zLmpzP2Y3NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc05hbWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25OYW1lKGluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbn1cbnZhciBGVU5DX05BTUVfUkVHRVhQID0gL15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC87XG52YXIgTkFNRSA9IFwibmFtZVwiO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgdG9vIG1hbnkgaGFja3MgZm9yIElFL29sZCB2ZXJzaW9ucyBvZiBub2RlLmpzIGhlcmUqL1xuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmdW5jKSB7XG4gICAgLy8gRW5naW5lcyB0aGF0IHN1cHBvcnQgRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgT1IgdGhlIG50aCAobj4xKSB0aW1lIGFmdGVyXG4gICAgLy8gdGhlIG5hbWUgaGFzIGJlZW4gY29tcHV0ZWQgaW4gdGhlIGZvbGxvd2luZyBlbHNlIGJsb2NrLlxuICAgIHZhciBleGlzdGluZ05hbWVQcm9wID0gZnVuYy5uYW1lO1xuICAgIGlmIChleGlzdGluZ05hbWVQcm9wKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ05hbWVQcm9wO1xuICAgIH1cbiAgICAvLyBoYWNrIGZvciBJRSBhbmQgZW5naW5lcyB0aGF0IGRvIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbiBmdW5jdGlvbi5uYW1lIChOb2RlLmpzIDAuMTAgJiYgMC4xMilcbiAgICB2YXIgY29tcHV0ZWROYW1lID0gZnVuYy50b1N0cmluZygpLm1hdGNoKEZVTkNfTkFNRV9SRUdFWFApWzFdO1xuICAgIHJldHVybiBjb21wdXRlZE5hbWU7XG59XG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIGhhcyB0aGUgcHJvcGVydHkgYmVlbiBzdWNjZXNzZnVsbHkgZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lTmFtZVByb3Aob2JqLCBuYW1lVmFsdWUpIHtcbiAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIE5BTUUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0+IHdpbGwgb25seSBydW4gaW4gb2xkIHZlcnNpb25zIG9mIG5vZGUuanMgKi9cbiAgICBpZiAoaXNVbmRlZmluZWQobmFtZVByb3BEZXNjcmlwdG9yKSB8fCBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIE5BTUUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG5hbWVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0+IHdpbGwgb25seSBydW4gaW4gb2xkIHZlcnNpb25zIG9mIG5vZGUuanMgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nX2V4dGVuc2lvbnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/constants.js ***!
  \****************************************************************/
/*! exports provided: IN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IN\", function() { return IN; });\n// TODO: can this be removed? where is it used?\nvar IN = \"_~IN~_\";\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9jb25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9jb25zdGFudHMuanM/YjUyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUT0RPOiBjYW4gdGhpcyBiZSByZW1vdmVkPyB3aGVyZSBpcyBpdCB1c2VkP1xuZXhwb3J0IHZhciBJTiA9IFwiX35JTn5fXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/constants.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js":
/*!**************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js ***!
  \**************************************************************/
/*! exports provided: setNodeLocationOnlyOffset, setNodeLocationFull, addTerminalToCst, addNoneTerminalToCst, NamedDSLMethodsCollectorVisitor, expandAllNestedRuleNames */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setNodeLocationOnlyOffset\", function() { return setNodeLocationOnlyOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setNodeLocationFull\", function() { return setNodeLocationFull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addTerminalToCst\", function() { return addTerminalToCst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addNoneTerminalToCst\", function() { return addNoneTerminalToCst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NamedDSLMethodsCollectorVisitor\", function() { return NamedDSLMethodsCollectorVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expandAllNestedRuleNames\", function() { return expandAllNestedRuleNames; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../grammar/keys */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grammar/gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../grammar/gast/gast_visitor_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nfunction addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\nvar NamedDSLMethodsCollectorVisitor = /** @class */ (function (_super) {\n    __extends(NamedDSLMethodsCollectorVisitor, _super);\n    function NamedDSLMethodsCollectorVisitor(ruleIdx) {\n        var _this = _super.call(this) || this;\n        _this.result = [];\n        _this.ruleIdx = ruleIdx;\n        return _this;\n    }\n    NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {\n        // TODO: better hack to copy what we need here...\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isUndefined\"])(node.name)) {\n            // copy without name so this will indeed be processed later.\n            var nameLessNode \n            /* istanbul ignore else */\n            = void 0;\n            /* istanbul ignore else */\n            if (node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Option\"] ||\n                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Repetition\"] ||\n                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"RepetitionMandatory\"] ||\n                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Alternation\"]) {\n                nameLessNode = new newNodeConstructor({\n                    definition: node.definition,\n                    idx: node.idx\n                });\n            }\n            else if (node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"RepetitionMandatoryWithSeparator\"] ||\n                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"RepetitionWithSeparator\"]) {\n                nameLessNode = new newNodeConstructor({\n                    definition: node.definition,\n                    idx: node.idx,\n                    separator: node.separator\n                });\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n            var def = [nameLessNode];\n            var key = Object(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"getKeyForAutomaticLookahead\"])(this.ruleIdx, methodIdx, node.idx);\n            this.result.push({ def: def, key: key, name: node.name, orgProd: node });\n        }\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {\n        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Option\"], _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OPTION_IDX\"]);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {\n        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Repetition\"], _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_IDX\"]);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"RepetitionMandatory\"], _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_IDX\"]);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"RepetitionMandatoryWithSeparator\"], _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_SEP_IDX\"]);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"RepetitionWithSeparator\"], _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_SEP_IDX\"]);\n    };\n    NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {\n        var _this = this;\n        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Alternation\"], _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OR_IDX\"]);\n        var hasMoreThanOneAlternative = node.definition.length > 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(node.definition, function (currFlatAlt, altIdx) {\n            if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isUndefined\"])(currFlatAlt.name)) {\n                var def = currFlatAlt.definition;\n                if (hasMoreThanOneAlternative) {\n                    def = [new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Option\"]({ definition: currFlatAlt.definition })];\n                }\n                else {\n                    // mandatory\n                    def = currFlatAlt.definition;\n                }\n                var key = Object(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"getKeyForAltIndex\"])(_this.ruleIdx, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OR_IDX\"], node.idx, altIdx);\n                _this.result.push({\n                    def: def,\n                    key: key,\n                    name: currFlatAlt.name,\n                    orgProd: currFlatAlt\n                });\n            }\n        });\n    };\n    return NamedDSLMethodsCollectorVisitor;\n}(_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_3__[\"GAstVisitor\"]));\n\nfunction expandAllNestedRuleNames(topRules, fullToShortName) {\n    var result = {\n        allRuleNames: []\n    };\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(topRules, function (currTopRule) {\n        var currTopRuleShortName = fullToShortName[currTopRule.name];\n        result.allRuleNames.push(currTopRule.name);\n        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);\n        currTopRule.accept(namedCollectorVisitor);\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(namedCollectorVisitor.result, function (_a) {\n            var def = _a.def, key = _a.key, name = _a.name;\n            result.allRuleNames.push(currTopRule.name + name);\n        });\n    });\n    return result;\n}\n//# sourceMappingURL=cst.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9jc3QvY3N0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvY3N0L2NzdC5qcz9iYzZmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgZm9yRWFjaCwgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IEFUX0xFQVNUX09ORV9JRFgsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBnZXRLZXlGb3JBbHRJbmRleCwgZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkLCBNQU5ZX0lEWCwgTUFOWV9TRVBfSURYLCBPUFRJT05fSURYLCBPUl9JRFggfSBmcm9tIFwiLi4vZ3JhbW1hci9rZXlzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgfSBmcm9tIFwiLi4vZ3JhbW1hci9nYXN0L2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuLi9ncmFtbWFyL2dhc3QvZ2FzdF92aXNpdG9yX3B1YmxpY1wiO1xuLyoqXG4gKiBUaGlzIG5vZGVMb2NhdGlvbiB0cmFja2luZyBpcyBub3QgZWZmaWNpZW50IGFuZCBzaG91bGQgb25seSBiZSB1c2VkXG4gKiB3aGVuIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQgb3IgdGhlIFRva2VuIFZlY3RvciBjb250YWlucyB2aXJ0dWFsIFRva2Vuc1xuICogKGUuZywgUHl0aG9uIEluZGVudC9PdXRkZW50KVxuICogQXMgaXQgZXhlY3V0ZXMgdGhlIGNhbGN1bGF0aW9uIGZvciBldmVyeSBzaW5nbGUgdGVybWluYWwvbm9uVGVybWluYWxcbiAqIGFuZCBkb2VzIG5vdCByZWx5IG9uIHRoZSBmYWN0IHRoZSB0b2tlbiB2ZWN0b3IgaXMgKipzb3J0ZWQqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldChjdXJyTm9kZUxvY2F0aW9uLCBuZXdMb2NhdGlvbkluZm8pIHtcbiAgICAvLyBGaXJzdCAodmFsaWQpIHVwZGF0ZSBmb3IgdGhpcyBjc3Qgbm9kZVxuICAgIGlmIChpc05hTihjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBhc3N1bXB0aW9uMTogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZWl0aGVyIE5hTiBvciBhIHZhbGlkIG51bWJlclxuICAgICAgICAvLyBhc3N1bXB0aW9uMjogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZnVsbHkgdmFsaWQgaWYgaXQgZXhpc3RcbiAgICAgICAgLy8gKGJvdGggc3RhcnQvZW5kIG9mZnNldHMgZXhpc3QgYW5kIGFyZSBudW1iZXJzKS5cbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5zdGFydE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgIH1cbiAgICAvLyBPbmNlIHRoZSBzdGFydE9mZnNldCBoYXMgYmVlbiB1cGRhdGVkIHdpdGggYSB2YWxpZCBudW1iZXIgaXQgc2hvdWxkIG5ldmVyIHJlY2VpdmVcbiAgICAvLyBhbnkgZmFydGhlciB1cGRhdGVzIGFzIHRoZSBUb2tlbiB2ZWN0b3IgaXMgc29ydGVkLlxuICAgIC8vIFdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgdGhpcyB0aGlzIGNvbmRpdGlvbiBmb3IgZXZlcnkgbmV3IHBvc3NpYmxlIGxvY2F0aW9uIGluZm9cbiAgICAvLyBiZWNhdXNlIHdpdGggZXJyb3IgcmVjb3ZlcnkgZW5hYmxlZCB3ZSBtYXkgZW5jb3VudGVyIGludmFsaWQgdG9rZW5zIChOYU4gbG9jYXRpb24gcHJvcHMpXG4gICAgZWxzZSBpZiAoY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPCBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgbm9kZUxvY2F0aW9uIHRyYWNraW5nIGlzIG5vdCBlZmZpY2llbnQgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWRcbiAqIHdoZW4gZXJyb3IgcmVjb3ZlcnkgaXMgZW5hYmxlZCBvciB0aGUgVG9rZW4gVmVjdG9yIGNvbnRhaW5zIHZpcnR1YWwgVG9rZW5zXG4gKiAoZS5nLCBQeXRob24gSW5kZW50L091dGRlbnQpXG4gKiBBcyBpdCBleGVjdXRlcyB0aGUgY2FsY3VsYXRpb24gZm9yIGV2ZXJ5IHNpbmdsZSB0ZXJtaW5hbC9ub25UZXJtaW5hbFxuICogYW5kIGRvZXMgbm90IHJlbHkgb24gdGhlIGZhY3QgdGhlIHRva2VuIHZlY3RvciBpcyAqKnNvcnRlZCoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXROb2RlTG9jYXRpb25GdWxsKGN1cnJOb2RlTG9jYXRpb24sIG5ld0xvY2F0aW9uSW5mbykge1xuICAgIC8vIEZpcnN0ICh2YWxpZCkgdXBkYXRlIGZvciB0aGlzIGNzdCBub2RlXG4gICAgaWYgKGlzTmFOKGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGFzc3VtcHRpb24xOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBlaXRoZXIgTmFOIG9yIGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIC8vIGFzc3VtcHRpb24yOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBmdWxseSB2YWxpZCBpZiBpdCBleGlzdFxuICAgICAgICAvLyAoYWxsIHN0YXJ0L2VuZCBwcm9wcyBleGlzdCBhbmQgYXJlIG51bWJlcnMpLlxuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0Q29sdW1uID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0TGluZSA9IG5ld0xvY2F0aW9uSW5mby5zdGFydExpbmU7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uZW5kQ29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZExpbmUgPSBuZXdMb2NhdGlvbkluZm8uZW5kTGluZTtcbiAgICB9XG4gICAgLy8gT25jZSB0aGUgc3RhcnQgcHJvcHMgaGFzIGJlZW4gdXBkYXRlZCB3aXRoIGEgdmFsaWQgbnVtYmVyIGl0IHNob3VsZCBuZXZlciByZWNlaXZlXG4gICAgLy8gYW55IGZhcnRoZXIgdXBkYXRlcyBhcyB0aGUgVG9rZW4gdmVjdG9yIGlzIHNvcnRlZC5cbiAgICAvLyBXZSBzdGlsbCBoYXZlIHRvIGNoZWNrIHRoaXMgdGhpcyBjb25kaXRpb24gZm9yIGV2ZXJ5IG5ldyBwb3NzaWJsZSBsb2NhdGlvbiBpbmZvXG4gICAgLy8gYmVjYXVzZSB3aXRoIGVycm9yIHJlY292ZXJ5IGVuYWJsZWQgd2UgbWF5IGVuY291bnRlciBpbnZhbGlkIHRva2VucyAoTmFOIGxvY2F0aW9uIHByb3BzKVxuICAgIGVsc2UgaWYgKGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0IDwgbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldCA9PT0gdHJ1ZSkge1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kQ29sdW1uID0gbmV3TG9jYXRpb25JbmZvLmVuZENvbHVtbjtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRMaW5lID0gbmV3TG9jYXRpb25JbmZvLmVuZExpbmU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRlcm1pbmFsVG9Dc3Qobm9kZSwgdG9rZW4sIHRva2VuVHlwZU5hbWUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bdG9rZW5UeXBlTmFtZV0gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXS5wdXNoKHRva2VuKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkTm9uZVRlcm1pbmFsVG9Dc3Qobm9kZSwgcnVsZU5hbWUsIHJ1bGVSZXN1bHQpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbltydWxlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3J1bGVOYW1lXSA9IFtydWxlUmVzdWx0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bcnVsZU5hbWVdLnB1c2gocnVsZVJlc3VsdCk7XG4gICAgfVxufVxudmFyIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcihydWxlSWR4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlc3VsdCA9IFtdO1xuICAgICAgICBfdGhpcy5ydWxlSWR4ID0gcnVsZUlkeDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS5jb2xsZWN0TmFtZWREU0xNZXRob2QgPSBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZUNvbnN0cnVjdG9yLCBtZXRob2RJZHgpIHtcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGhhY2sgdG8gY29weSB3aGF0IHdlIG5lZWQgaGVyZS4uLlxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGNvcHkgd2l0aG91dCBuYW1lIHNvIHRoaXMgd2lsbCBpbmRlZWQgYmUgcHJvY2Vzc2VkIGxhdGVyLlxuICAgICAgICAgICAgdmFyIG5hbWVMZXNzTm9kZSBcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uIHx8XG4gICAgICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkgfHxcbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgICAgICBuYW1lTGVzc05vZGUgPSBuZXcgbmV3Tm9kZUNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogbm9kZS5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpZHg6IG5vZGUuaWR4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBuYW1lTGVzc05vZGUgPSBuZXcgbmV3Tm9kZUNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogbm9kZS5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3I6IG5vZGUuc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlZiA9IFtuYW1lTGVzc05vZGVdO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCh0aGlzLnJ1bGVJZHgsIG1ldGhvZElkeCwgbm9kZS5pZHgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaCh7IGRlZjogZGVmLCBrZXk6IGtleSwgbmFtZTogbm9kZS5uYW1lLCBvcmdQcm9kOiBub2RlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdE9wdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKG5vZGUsIE9wdGlvbiwgT1BUSU9OX0lEWCk7XG4gICAgfTtcbiAgICBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZChub2RlLCBSZXBldGl0aW9uLCBNQU5ZX0lEWCk7XG4gICAgfTtcbiAgICBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZChub2RlLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBBVF9MRUFTVF9PTkVfSURYKTtcbiAgICB9O1xuICAgIE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZChub2RlLCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgQVRfTEVBU1RfT05FX1NFUF9JRFgpO1xuICAgIH07XG4gICAgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKG5vZGUsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBNQU5ZX1NFUF9JRFgpO1xuICAgIH07XG4gICAgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKG5vZGUsIEFsdGVybmF0aW9uLCBPUl9JRFgpO1xuICAgICAgICB2YXIgaGFzTW9yZVRoYW5PbmVBbHRlcm5hdGl2ZSA9IG5vZGUuZGVmaW5pdGlvbi5sZW5ndGggPiAxO1xuICAgICAgICBmb3JFYWNoKG5vZGUuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGN1cnJGbGF0QWx0LCBhbHRJZHgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoY3VyckZsYXRBbHQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gY3VyckZsYXRBbHQuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9yZVRoYW5PbmVBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWYgPSBbbmV3IE9wdGlvbih7IGRlZmluaXRpb246IGN1cnJGbGF0QWx0LmRlZmluaXRpb24gfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFuZGF0b3J5XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IGN1cnJGbGF0QWx0LmRlZmluaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXlGb3JBbHRJbmRleChfdGhpcy5ydWxlSWR4LCBPUl9JRFgsIG5vZGUuaWR4LCBhbHRJZHgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjdXJyRmxhdEFsdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcmdQcm9kOiBjdXJyRmxhdEFsdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZXhwb3J0IHsgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZEFsbE5lc3RlZFJ1bGVOYW1lcyh0b3BSdWxlcywgZnVsbFRvU2hvcnROYW1lKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgYWxsUnVsZU5hbWVzOiBbXVxuICAgIH07XG4gICAgZm9yRWFjaCh0b3BSdWxlcywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgIHZhciBjdXJyVG9wUnVsZVNob3J0TmFtZSA9IGZ1bGxUb1Nob3J0TmFtZVtjdXJyVG9wUnVsZS5uYW1lXTtcbiAgICAgICAgcmVzdWx0LmFsbFJ1bGVOYW1lcy5wdXNoKGN1cnJUb3BSdWxlLm5hbWUpO1xuICAgICAgICB2YXIgbmFtZWRDb2xsZWN0b3JWaXNpdG9yID0gbmV3IE5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoY3VyclRvcFJ1bGVTaG9ydE5hbWUpO1xuICAgICAgICBjdXJyVG9wUnVsZS5hY2NlcHQobmFtZWRDb2xsZWN0b3JWaXNpdG9yKTtcbiAgICAgICAgZm9yRWFjaChuYW1lZENvbGxlY3RvclZpc2l0b3IucmVzdWx0LCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBfYS5kZWYsIGtleSA9IF9hLmtleSwgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgICAgICByZXN1bHQuYWxsUnVsZU5hbWVzLnB1c2goY3VyclRvcFJ1bGUubmFtZSArIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js ***!
  \**********************************************************************/
/*! exports provided: defaultVisit, createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults, CstVisitorDefinitionError, validateVisitor, validateMissingCstMethods, validateRedundantMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultVisit\", function() { return defaultVisit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createBaseSemanticVisitorConstructor\", function() { return createBaseSemanticVisitorConstructor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createBaseVisitorConstructorWithDefaults\", function() { return createBaseVisitorConstructorWithDefaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CstVisitorDefinitionError\", function() { return CstVisitorDefinitionError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateVisitor\", function() { return validateVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateMissingCstMethods\", function() { return validateMissingCstMethods; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateRedundantMethods\", function() { return validateRedundantMethods; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lang/lang_extensions */ \"./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js\");\n/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grammar/checks */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\");\n\n\n\nfunction defaultVisit(ctx, param) {\n    var childrenNames = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"keys\"])(ctx);\n    var childrenNamesLength = childrenNames.length;\n    for (var i = 0; i < childrenNamesLength; i++) {\n        var currChildName = childrenNames[i];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n            var currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                if (currChild.fullName !== undefined) {\n                    this[currChild.fullName](currChild.children, param);\n                }\n                else {\n                    this[currChild.name](currChild.children, param);\n                }\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n    return undefined;\n}\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    Object(_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__[\"defineNameProp\"])(derivedConstructor, grammarName + \"BaseSemantics\");\n    var semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isUndefined\"])(cstNode)) {\n                return undefined;\n            }\n            if (cstNode.fullName !== undefined) {\n                return this[cstNode.fullName](cstNode.children, param);\n            }\n            else {\n                return this[cstNode.name](cstNode.children, param);\n            }\n        },\n        validateVisitor: function () {\n            var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(semanticDefinitionErrors)) {\n                var errorMessages = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });\n                throw Error(\"Errors Detected in CST Visitor <\" + Object(_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__[\"functionName\"])(this.constructor) + \">:\\n\\t\" +\n                    (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n            }\n        }\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    Object(_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__[\"defineNameProp\"])(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    var withDefaultsProto = Object.create(baseConstructor.prototype);\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nvar CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n    return missingErrors.concat(redundantErrors);\n}\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(ruleNames, function (currRuleName) {\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(visitorInstance[currRuleName])) {\n            return {\n                msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + Object(_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__[\"functionName\"])(visitorInstance.constructor) + \" CST Visitor.\",\n                type: CstVisitorDefinitionError.MISSING_METHOD,\n                methodName: currRuleName\n            };\n        }\n    });\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"compact\"])(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nfunction validateRedundantMethods(visitorInstance, ruleNames) {\n    var errors = [];\n    for (var prop in visitorInstance) {\n        if (_grammar_checks__WEBPACK_IMPORTED_MODULE_2__[\"validTermsPattern\"].test(prop) &&\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(visitorInstance[prop]) &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(VALID_PROP_NAMES, prop) &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(ruleNames, prop)) {\n            errors.push({\n                msg: \"Redundant visitor method: <\" + prop + \"> on \" + Object(_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__[\"functionName\"])(visitorInstance.constructor) + \" CST Visitor\\n\" +\n                    \"There is no Grammar Rule corresponding to this method's name.\\n\" +\n                    (\"For utility methods on visitor classes use methods names that do not match /\" + _grammar_checks__WEBPACK_IMPORTED_MODULE_2__[\"validTermsPattern\"].source + \"/.\"),\n                type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n                methodName: prop\n            });\n        }\n    }\n    return errors;\n}\n//# sourceMappingURL=cst_visitor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9jc3QvY3N0X3Zpc2l0b3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9jc3QvY3N0X3Zpc2l0b3IuanM/NjM2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wYWN0LCBjb250YWlucywgZm9yRWFjaCwgaXNBcnJheSwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQsIGtleXMsIG1hcCB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgZGVmaW5lTmFtZVByb3AsIGZ1bmN0aW9uTmFtZSB9IGZyb20gXCIuLi8uLi9sYW5nL2xhbmdfZXh0ZW5zaW9uc1wiO1xuaW1wb3J0IHsgdmFsaWRUZXJtc1BhdHRlcm4gfSBmcm9tIFwiLi4vZ3JhbW1hci9jaGVja3NcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0VmlzaXQoY3R4LCBwYXJhbSkge1xuICAgIHZhciBjaGlsZHJlbk5hbWVzID0ga2V5cyhjdHgpO1xuICAgIHZhciBjaGlsZHJlbk5hbWVzTGVuZ3RoID0gY2hpbGRyZW5OYW1lcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbk5hbWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJDaGlsZE5hbWUgPSBjaGlsZHJlbk5hbWVzW2ldO1xuICAgICAgICB2YXIgY3VyckNoaWxkQXJyYXkgPSBjdHhbY3VyckNoaWxkTmFtZV07XG4gICAgICAgIHZhciBjdXJyQ2hpbGRBcnJheUxlbmd0aCA9IGN1cnJDaGlsZEFycmF5Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjdXJyQ2hpbGRBcnJheUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY3VyckNoaWxkID0gY3VyckNoaWxkQXJyYXlbal07XG4gICAgICAgICAgICAvLyBkaXN0aW5jdGlvbiBiZXR3ZWVuIFRva2VucyBDaGlsZHJlbiBhbmQgQ3N0Tm9kZSBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGN1cnJDaGlsZC50b2tlblR5cGVJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQ2hpbGQuZnVsbE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2N1cnJDaGlsZC5mdWxsTmFtZV0oY3VyckNoaWxkLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2N1cnJDaGlsZC5uYW1lXShjdXJyQ2hpbGQuY2hpbGRyZW4sIHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVmYXVsdFZpc2l0IGRvZXMgbm90IHN1cHBvcnQgZ2VuZXJpYyBvdXQgcGFyYW1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhc2VTZW1hbnRpY1Zpc2l0b3JDb25zdHJ1Y3RvcihncmFtbWFyTmFtZSwgcnVsZU5hbWVzKSB7XG4gICAgdmFyIGRlcml2ZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvLyBjYW4gYmUgb3ZlcndyaXR0ZW4gYWNjb3JkaW5nIHRvOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL1xuICAgIC8vIG5hbWU/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkZ1bmN0aW9uJTJGbmFtZVxuICAgIGRlZmluZU5hbWVQcm9wKGRlcml2ZWRDb25zdHJ1Y3RvciwgZ3JhbW1hck5hbWUgKyBcIkJhc2VTZW1hbnRpY3NcIik7XG4gICAgdmFyIHNlbWFudGljUHJvdG8gPSB7XG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiAoY3N0Tm9kZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIC8vIGVuYWJsZXMgd3JpdGluZyBtb3JlIGNvbmNpc2UgdmlzaXRvciBtZXRob2RzIHdoZW4gQ3N0Tm9kZSBoYXMgb25seSBhIHNpbmdsZSBjaGlsZFxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBIENTVCBOb2RlJ3MgY2hpbGRyZW4gZGljdGlvbmFyeSBjYW4gbmV2ZXIgaGF2ZSBlbXB0eSBhcnJheXMgYXMgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBrZXkgaXMgZGVmaW5lZCB0aGVyZSB3aWxsIGJlIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGFycmF5LlxuICAgICAgICAgICAgICAgIGNzdE5vZGUgPSBjc3ROb2RlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5hYmxlcyBwYXNzaW5nIG9wdGlvbmFsIENzdE5vZGVzIGNvbmNpc2VseS5cbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjc3ROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3N0Tm9kZS5mdWxsTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY3N0Tm9kZS5mdWxsTmFtZV0oY3N0Tm9kZS5jaGlsZHJlbiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY3N0Tm9kZS5uYW1lXShjc3ROb2RlLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRlVmlzaXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbWFudGljRGVmaW5pdGlvbkVycm9ycyA9IHZhbGlkYXRlVmlzaXRvcih0aGlzLCBydWxlTmFtZXMpO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHNlbWFudGljRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IG1hcChzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChjdXJyRGVmRXJyb3IpIHsgcmV0dXJuIGN1cnJEZWZFcnJvci5tc2c7IH0pO1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3JzIERldGVjdGVkIGluIENTVCBWaXNpdG9yIDxcIiArIGZ1bmN0aW9uTmFtZSh0aGlzLmNvbnN0cnVjdG9yKSArIFwiPjpcXG5cXHRcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgZXJyb3JNZXNzYWdlcy5qb2luKFwiXFxuXFxuXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcblxcdFwiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gc2VtYW50aWNQcm90bztcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGVyaXZlZENvbnN0cnVjdG9yO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5fUlVMRV9OQU1FUyA9IHJ1bGVOYW1lcztcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMoZ3JhbW1hck5hbWUsIHJ1bGVOYW1lcywgYmFzZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIGRlcml2ZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvLyBjYW4gYmUgb3ZlcndyaXR0ZW4gYWNjb3JkaW5nIHRvOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL1xuICAgIC8vIG5hbWU/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkZ1bmN0aW9uJTJGbmFtZVxuICAgIGRlZmluZU5hbWVQcm9wKGRlcml2ZWRDb25zdHJ1Y3RvciwgZ3JhbW1hck5hbWUgKyBcIkJhc2VTZW1hbnRpY3NXaXRoRGVmYXVsdHNcIik7XG4gICAgdmFyIHdpdGhEZWZhdWx0c1Byb3RvID0gT2JqZWN0LmNyZWF0ZShiYXNlQ29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBmb3JFYWNoKHJ1bGVOYW1lcywgZnVuY3Rpb24gKHJ1bGVOYW1lKSB7XG4gICAgICAgIHdpdGhEZWZhdWx0c1Byb3RvW3J1bGVOYW1lXSA9IGRlZmF1bHRWaXNpdDtcbiAgICB9KTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gd2l0aERlZmF1bHRzUHJvdG87XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlcml2ZWRDb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0IHZhciBDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yO1xuKGZ1bmN0aW9uIChDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yKSB7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiUkVEVU5EQU5UX01FVEhPRFwiXSA9IDBdID0gXCJSRURVTkRBTlRfTUVUSE9EXCI7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiTUlTU0lOR19NRVRIT0RcIl0gPSAxXSA9IFwiTUlTU0lOR19NRVRIT0RcIjtcbn0pKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgfHwgKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVmlzaXRvcih2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIHZhciBtaXNzaW5nRXJyb3JzID0gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcyk7XG4gICAgdmFyIHJlZHVuZGFudEVycm9ycyA9IHZhbGlkYXRlUmVkdW5kYW50TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcyk7XG4gICAgcmV0dXJuIG1pc3NpbmdFcnJvcnMuY29uY2F0KHJlZHVuZGFudEVycm9ycyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIHZhciBlcnJvcnMgPSBtYXAocnVsZU5hbWVzLCBmdW5jdGlvbiAoY3VyclJ1bGVOYW1lKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbih2aXNpdG9ySW5zdGFuY2VbY3VyclJ1bGVOYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbXNnOiBcIk1pc3NpbmcgdmlzaXRvciBtZXRob2Q6IDxcIiArIGN1cnJSdWxlTmFtZSArIFwiPiBvbiBcIiArIGZ1bmN0aW9uTmFtZSh2aXNpdG9ySW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgQ1NUIFZpc2l0b3IuXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvci5NSVNTSU5HX01FVEhPRCxcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lOiBjdXJyUnVsZU5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29tcGFjdChlcnJvcnMpO1xufVxudmFyIFZBTElEX1BST1BfTkFNRVMgPSBbXCJjb25zdHJ1Y3RvclwiLCBcInZpc2l0XCIsIFwidmFsaWRhdGVWaXNpdG9yXCJdO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVkdW5kYW50TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHZpc2l0b3JJbnN0YW5jZSkge1xuICAgICAgICBpZiAodmFsaWRUZXJtc1BhdHRlcm4udGVzdChwcm9wKSAmJlxuICAgICAgICAgICAgaXNGdW5jdGlvbih2aXNpdG9ySW5zdGFuY2VbcHJvcF0pICYmXG4gICAgICAgICAgICAhY29udGFpbnMoVkFMSURfUFJPUF9OQU1FUywgcHJvcCkgJiZcbiAgICAgICAgICAgICFjb250YWlucyhydWxlTmFtZXMsIHByb3ApKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbXNnOiBcIlJlZHVuZGFudCB2aXNpdG9yIG1ldGhvZDogPFwiICsgcHJvcCArIFwiPiBvbiBcIiArIGZ1bmN0aW9uTmFtZSh2aXNpdG9ySW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgQ1NUIFZpc2l0b3JcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgaXMgbm8gR3JhbW1hciBSdWxlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRob2QncyBuYW1lLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiRm9yIHV0aWxpdHkgbWV0aG9kcyBvbiB2aXNpdG9yIGNsYXNzZXMgdXNlIG1ldGhvZHMgbmFtZXMgdGhhdCBkbyBub3QgbWF0Y2ggL1wiICsgdmFsaWRUZXJtc1BhdHRlcm4uc291cmNlICsgXCIvLlwiKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yLlJFRFVOREFOVF9NRVRIT0QsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogcHJvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdF92aXNpdG9yLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/errors_public.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/errors_public.js ***!
  \********************************************************************/
/*! exports provided: defaultParserErrorProvider, defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultParserErrorProvider\", function() { return defaultParserErrorProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultGrammarResolverErrorProvider\", function() { return defaultGrammarResolverErrorProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultGrammarValidatorErrorProvider\", function() { return defaultGrammarValidatorErrorProvider; });\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./grammar/gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./grammar/gast/gast */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grammar/checks */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\");\n\n\n\n\n\n\nvar defaultParserErrorProvider = {\n    buildMismatchTokenMessage: function (_a) {\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\n        var hasLabel = Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"hasTokenLabel\"])(expected);\n        var expectedMsg = hasLabel\n            ? \"--> \" + Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"tokenLabel\"])(expected) + \" <--\"\n            : \"token of type --> \" + expected.name + \" <--\";\n        var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n        return msg;\n    },\n    buildNotAllInputParsedMessage: function (_a) {\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\n        return (\"Redundant input, expecting EOF but found: \" + firstRedundant.image);\n    },\n    buildNoViableAltMessage: function (_a) {\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var allLookAheadPaths = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"reduce\"])(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\n            var nextValidTokenSequences = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(allLookAheadPaths, function (currPath) {\n                return \"[\" + Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(currPath, function (currTokenType) {\n                    return Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"tokenLabel\"])(currTokenType);\n                }).join(\", \") + \"]\";\n            });\n            var nextValidSequenceItems = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(nextValidTokenSequences, function (itemMsg, idx) { return \"  \" + (idx + 1) + \". \" + itemMsg; });\n            var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage: function (_a) {\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\n        var errPrefix = \"Expecting: \";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        var actualText = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            var nextValidTokenSequences = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(expectedIterationPaths, function (currPath) {\n                return \"[\" + Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(currPath, function (currTokenType) {\n                    return Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"tokenLabel\"])(currTokenType);\n                }).join(\",\") + \"]\";\n            });\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\n                (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    }\n};\nObject.freeze(defaultParserErrorProvider);\nvar defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\n            undefinedRule.nonTerminalName +\n            \"<-\\n\" +\n            \"inside top level rule: ->\" +\n            topLevelRule.name +\n            \"<-\";\n        return msg;\n    }\n};\nvar defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Terminal\"]) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"NonTerminal\"]) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return \"\";\n            }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__[\"getProductionDslName\"])(duplicateProd);\n        var extraArgument = getExtraProductionArgument(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n    },\n    buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {\n        var msg = \"Invalid nested rule name: ->\" + nestedProd.name + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" +\n            (\"it must match the pattern: ->\" + _grammar_checks__WEBPACK_IMPORTED_MODULE_4__[\"validNestedRuleName\"].toString() + \"<-.\\n\") +\n            \"Note that this means a nested rule name must start with the '$'(dollar) sign.\";\n        return msg;\n    },\n    buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {\n        var duplicateName = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(nestedProd).name;\n        var errMsg = \"Duplicate nested rule name: ->\" + duplicateName + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" +\n            \"A nested name must be unique in the scope of a top level grammar rule.\";\n        return errMsg;\n    },\n    buildNamespaceConflictError: function (rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\n            (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") +\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\n            \"and Non-Terminal names start with a lower case letter.\";\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError: function (options) {\n        var pathMsg = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(options.prefixPath, function (currTok) {\n            return Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"tokenLabel\"])(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" +\n            (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") +\n            \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\n            \"For Further details.\";\n        return errMsg;\n    },\n    buildAlternationAmbiguityError: function (options) {\n        var pathMsg = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(options.prefixPath, function (currtok) {\n            return Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"tokenLabel\"])(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" +\n            (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage =\n            currMessage +\n                \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\n                \"For Further details.\";\n        return currMessage;\n    },\n    buildEmptyRepetitionError: function (options) {\n        var dslName = Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__[\"getProductionDslName\"])(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" +\n            \"This could lead to an infinite loop.\";\n        return errMsg;\n    },\n    buildTokenNameError: function (options) {\n        var tokTypeName = options.tokenType.name;\n        var errMsg = \"Invalid Grammar Token name: ->\" + tokTypeName + \"<- it must match the pattern: ->\" + options.expectedPattern.toString() + \"<-\";\n        return errMsg;\n    },\n    buildEmptyAlternationError: function (options) {\n        var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" +\n            (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") +\n            \"Only the last alternative may be an empty alternative.\";\n        return errMsg;\n    },\n    buildTooManyAlternativesError: function (options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\n            (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length +\n                1) + \" alternatives.\");\n        return errMsg;\n    },\n    buildLeftRecursionError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"](options.leftRecursionPath, function (currRule) { return currRule.name; });\n        var leftRecursivePath = ruleName + \" --> \" + pathNames\n            .concat([ruleName])\n            .join(\" --> \");\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\n            (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") +\n            (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") +\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n        return errMsg;\n    },\n    buildInvalidRuleNameError: function (options) {\n        var ruleName = options.topLevelRule.name;\n        var expectedPatternString = options.expectedPattern.toString();\n        var errMsg = \"Invalid grammar rule name: ->\" + ruleName + \"<- it must match the pattern: ->\" + expectedPatternString + \"<-\";\n        return errMsg;\n    },\n    buildDuplicateRuleNameError: function (options) {\n        var ruleName;\n        if (options.topLevelRule instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__[\"Rule\"]) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n        return errMsg;\n    }\n};\n//# sourceMappingURL=errors_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9lcnJvcnNfcHVibGljLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZXJyb3JzX3B1YmxpYy5qcz9hNTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc1Rva2VuTGFiZWwsIHRva2VuTGFiZWwgfSBmcm9tIFwiLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGZpcnN0LCBtYXAsIHJlZHVjZSB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTm9uVGVybWluYWwsIFJ1bGUsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ3JhbW1hci9nYXN0L2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBnZXRQcm9kdWN0aW9uRHNsTmFtZSB9IGZyb20gXCIuL2dyYW1tYXIvZ2FzdC9nYXN0XCI7XG5pbXBvcnQgeyB2YWxpZE5lc3RlZFJ1bGVOYW1lIH0gZnJvbSBcIi4vZ3JhbW1hci9jaGVja3NcIjtcbmV4cG9ydCB2YXIgZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIgPSB7XG4gICAgYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBleHBlY3RlZCA9IF9hLmV4cGVjdGVkLCBhY3R1YWwgPSBfYS5hY3R1YWwsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHZhciBoYXNMYWJlbCA9IGhhc1Rva2VuTGFiZWwoZXhwZWN0ZWQpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRNc2cgPSBoYXNMYWJlbFxuICAgICAgICAgICAgPyBcIi0tPiBcIiArIHRva2VuTGFiZWwoZXhwZWN0ZWQpICsgXCIgPC0tXCJcbiAgICAgICAgICAgIDogXCJ0b2tlbiBvZiB0eXBlIC0tPiBcIiArIGV4cGVjdGVkLm5hbWUgKyBcIiA8LS1cIjtcbiAgICAgICAgdmFyIG1zZyA9IFwiRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWRNc2cgKyBcIiBidXQgZm91bmQgLS0+ICdcIiArIGFjdHVhbC5pbWFnZSArIFwiJyA8LS1cIjtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGZpcnN0UmVkdW5kYW50ID0gX2EuZmlyc3RSZWR1bmRhbnQsIHJ1bGVOYW1lID0gX2EucnVsZU5hbWU7XG4gICAgICAgIHJldHVybiAoXCJSZWR1bmRhbnQgaW5wdXQsIGV4cGVjdGluZyBFT0YgYnV0IGZvdW5kOiBcIiArIGZpcnN0UmVkdW5kYW50LmltYWdlKTtcbiAgICB9LFxuICAgIGJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkUGF0aHNQZXJBbHQgPSBfYS5leHBlY3RlZFBhdGhzUGVyQWx0LCBhY3R1YWwgPSBfYS5hY3R1YWwsIHByZXZpb3VzID0gX2EucHJldmlvdXMsIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiA9IF9hLmN1c3RvbVVzZXJEZXNjcmlwdGlvbiwgcnVsZU5hbWUgPSBfYS5ydWxlTmFtZTtcbiAgICAgICAgdmFyIGVyclByZWZpeCA9IFwiRXhwZWN0aW5nOiBcIjtcbiAgICAgICAgLy8gVE9ETzogaXNzdWU6IE5vIFZpYWJsZSBBbHRlcm5hdGl2ZSBFcnJvciBtYXkgaGF2ZSBpbmNvbXBsZXRlIGRldGFpbHMuICM1MDJcbiAgICAgICAgdmFyIGFjdHVhbFRleHQgPSBmaXJzdChhY3R1YWwpLmltYWdlO1xuICAgICAgICB2YXIgZXJyU3VmZml4ID0gXCJcXG5idXQgZm91bmQ6ICdcIiArIGFjdHVhbFRleHQgKyBcIidcIjtcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbGxMb29rQWhlYWRQYXRocyA9IHJlZHVjZShleHBlY3RlZFBhdGhzUGVyQWx0LCBmdW5jdGlvbiAocmVzdWx0LCBjdXJyQWx0UGF0aHMpIHsgcmV0dXJuIHJlc3VsdC5jb25jYXQoY3VyckFsdFBhdGhzKTsgfSwgW10pO1xuICAgICAgICAgICAgdmFyIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzID0gbWFwKGFsbExvb2tBaGVhZFBhdGhzLCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBtYXAoY3VyclBhdGgsIGZ1bmN0aW9uIChjdXJyVG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkxhYmVsKGN1cnJUb2tlblR5cGUpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dFZhbGlkU2VxdWVuY2VJdGVtcyA9IG1hcChuZXh0VmFsaWRUb2tlblNlcXVlbmNlcywgZnVuY3Rpb24gKGl0ZW1Nc2csIGlkeCkgeyByZXR1cm4gXCIgIFwiICsgKGlkeCArIDEpICsgXCIuIFwiICsgaXRlbU1zZzsgfSk7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZERlc2NyaXB0aW9uID0gXCJvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOlxcblwiICsgbmV4dFZhbGlkU2VxdWVuY2VJdGVtcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGNhbGN1bGF0ZWREZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYnVpbGRFYXJseUV4aXRNZXNzYWdlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkSXRlcmF0aW9uUGF0aHMgPSBfYS5leHBlY3RlZEl0ZXJhdGlvblBhdGhzLCBhY3R1YWwgPSBfYS5hY3R1YWwsIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiA9IF9hLmN1c3RvbVVzZXJEZXNjcmlwdGlvbiwgcnVsZU5hbWUgPSBfYS5ydWxlTmFtZTtcbiAgICAgICAgdmFyIGVyclByZWZpeCA9IFwiRXhwZWN0aW5nOiBcIjtcbiAgICAgICAgLy8gVE9ETzogaXNzdWU6IE5vIFZpYWJsZSBBbHRlcm5hdGl2ZSBFcnJvciBtYXkgaGF2ZSBpbmNvbXBsZXRlIGRldGFpbHMuICM1MDJcbiAgICAgICAgdmFyIGFjdHVhbFRleHQgPSBmaXJzdChhY3R1YWwpLmltYWdlO1xuICAgICAgICB2YXIgZXJyU3VmZml4ID0gXCJcXG5idXQgZm91bmQ6ICdcIiArIGFjdHVhbFRleHQgKyBcIidcIjtcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXh0VmFsaWRUb2tlblNlcXVlbmNlcyA9IG1hcChleHBlY3RlZEl0ZXJhdGlvblBhdGhzLCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBtYXAoY3VyclBhdGgsIGZ1bmN0aW9uIChjdXJyVG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkxhYmVsKGN1cnJUb2tlblR5cGUpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkRGVzY3JpcHRpb24gPSBcImV4cGVjdGluZyBhdCBsZWFzdCBvbmUgaXRlcmF0aW9uIHdoaWNoIHN0YXJ0cyB3aXRoIG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6OlxcbiAgXCIgK1xuICAgICAgICAgICAgICAgIChcIjxcIiArIG5leHRWYWxpZFRva2VuU2VxdWVuY2VzLmpvaW4oXCIgLFwiKSArIFwiPlwiKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJQcmVmaXggKyBjYWxjdWxhdGVkRGVzY3JpcHRpb24gKyBlcnJTdWZmaXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuT2JqZWN0LmZyZWV6ZShkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcik7XG5leHBvcnQgdmFyIGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkUnVsZU5vdEZvdW5kRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIHVuZGVmaW5lZFJ1bGUpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiSW52YWxpZCBncmFtbWFyLCByZWZlcmVuY2UgdG8gYSBydWxlIHdoaWNoIGlzIG5vdCBkZWZpbmVkOiAtPlwiICtcbiAgICAgICAgICAgIHVuZGVmaW5lZFJ1bGUubm9uVGVybWluYWxOYW1lICtcbiAgICAgICAgICAgIFwiPC1cXG5cIiArXG4gICAgICAgICAgICBcImluc2lkZSB0b3AgbGV2ZWwgcnVsZTogLT5cIiArXG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGUubmFtZSArXG4gICAgICAgICAgICBcIjwtXCI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcjogZnVuY3Rpb24gKHRvcExldmVsUnVsZSwgZHVwbGljYXRlUHJvZHMpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQocHJvZCkge1xuICAgICAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcExldmVsTmFtZSA9IHRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZHVwbGljYXRlUHJvZCA9IGZpcnN0KGR1cGxpY2F0ZVByb2RzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZHVwbGljYXRlUHJvZC5pZHg7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBleHRyYUFyZ3VtZW50ID0gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIHZhciBoYXNFeHBsaWNpdEluZGV4ID0gaW5kZXggPiAwO1xuICAgICAgICB2YXIgbXNnID0gXCItPlwiICsgZHNsTmFtZSArIChoYXNFeHBsaWNpdEluZGV4ID8gaW5kZXggOiBcIlwiKSArIFwiPC0gXCIgKyAoZXh0cmFBcmd1bWVudCA/IFwid2l0aCBhcmd1bWVudDogLT5cIiArIGV4dHJhQXJndW1lbnQgKyBcIjwtXCIgOiBcIlwiKSArIFwiXFxuICAgICAgICAgICAgICAgICAgYXBwZWFycyBtb3JlIHRoYW4gb25jZSAoXCIgKyBkdXBsaWNhdGVQcm9kcy5sZW5ndGggKyBcIiB0aW1lcykgaW4gdGhlIHRvcCBsZXZlbCBydWxlOiAtPlwiICsgdG9wTGV2ZWxOYW1lICsgXCI8LS4gICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICBGb3IgZnVydGhlciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9GQVEuaHRtbCNOVU1FUklDQUxfU1VGRklYRVMgXFxuICAgICAgICAgICAgICAgICAgXCI7XG4gICAgICAgIC8vIHdoaXRlIHNwYWNlIHRyaW1taW5nIHRpbWUhIGJldHRlciB0byB0cmltIGFmdGVyd2FyZHMgYXMgaXQgYWxsb3dzIHRvIHVzZSBXRUxMIGZvcm1hdHRlZCBtdWx0aSBsaW5lIHRlbXBsYXRlIHN0cmluZ3MuLi5cbiAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1sgXFx0XSsvZywgXCIgXCIpO1xuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvXFxzXFxzKy9nLCBcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkSW52YWxpZE5lc3RlZFJ1bGVOYW1lRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIG5lc3RlZFByb2QpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiSW52YWxpZCBuZXN0ZWQgcnVsZSBuYW1lOiAtPlwiICsgbmVzdGVkUHJvZC5uYW1lICsgXCI8LSBpbnNpZGUgcnVsZTogLT5cIiArIHRvcExldmVsUnVsZS5uYW1lICsgXCI8LVxcblwiICtcbiAgICAgICAgICAgIChcIml0IG11c3QgbWF0Y2ggdGhlIHBhdHRlcm46IC0+XCIgKyB2YWxpZE5lc3RlZFJ1bGVOYW1lLnRvU3RyaW5nKCkgKyBcIjwtLlxcblwiKSArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCB0aGlzIG1lYW5zIGEgbmVzdGVkIHJ1bGUgbmFtZSBtdXN0IHN0YXJ0IHdpdGggdGhlICckJyhkb2xsYXIpIHNpZ24uXCI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICBidWlsZER1cGxpY2F0ZU5lc3RlZFJ1bGVOYW1lRXJyb3I6IGZ1bmN0aW9uICh0b3BMZXZlbFJ1bGUsIG5lc3RlZFByb2QpIHtcbiAgICAgICAgdmFyIGR1cGxpY2F0ZU5hbWUgPSBmaXJzdChuZXN0ZWRQcm9kKS5uYW1lO1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJEdXBsaWNhdGUgbmVzdGVkIHJ1bGUgbmFtZTogLT5cIiArIGR1cGxpY2F0ZU5hbWUgKyBcIjwtIGluc2lkZSBydWxlOiAtPlwiICsgdG9wTGV2ZWxSdWxlLm5hbWUgKyBcIjwtXFxuXCIgK1xuICAgICAgICAgICAgXCJBIG5lc3RlZCBuYW1lIG11c3QgYmUgdW5pcXVlIGluIHRoZSBzY29wZSBvZiBhIHRvcCBsZXZlbCBncmFtbWFyIHJ1bGUuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3I6IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSBcIk5hbWVzcGFjZSBjb25mbGljdCBmb3VuZCBpbiBncmFtbWFyLlxcblwiICtcbiAgICAgICAgICAgIChcIlRoZSBncmFtbWFyIGhhcyBib3RoIGEgVGVybWluYWwoVG9rZW4pIGFuZCBhIE5vbi1UZXJtaW5hbChSdWxlKSBuYW1lZDogPFwiICsgcnVsZS5uYW1lICsgXCI+LlxcblwiKSArXG4gICAgICAgICAgICBcIlRvIHJlc29sdmUgdGhpcyBtYWtlIHN1cmUgZWFjaCBUZXJtaW5hbCBhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIGFyZSB1bmlxdWVcXG5cIiArXG4gICAgICAgICAgICBcIlRoaXMgaXMgZWFzeSB0byBhY2NvbXBsaXNoIGJ5IHVzaW5nIHRoZSBjb252ZW50aW9uIHRoYXQgVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyXFxuXCIgK1xuICAgICAgICAgICAgXCJhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYSBsb3dlciBjYXNlIGxldHRlci5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHBhdGhNc2cgPSBtYXAob3B0aW9ucy5wcmVmaXhQYXRoLCBmdW5jdGlvbiAoY3VyclRvaykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuTGFiZWwoY3VyclRvayk7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGFsdGVybmF0aXZlczogPFwiICsgb3B0aW9ucy5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKSArIFwiPiBkdWUgdG8gY29tbW9uIGxvb2thaGVhZCBwcmVmaXhcXG5cIiArXG4gICAgICAgICAgICAoXCJpbiA8T1JcIiArIG9jY3VycmVuY2UgKyBcIj4gaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZSxcXG5cIikgK1xuICAgICAgICAgICAgKFwiPFwiICsgcGF0aE1zZyArIFwiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuXCIpICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0NPTU1PTl9QUkVGSVhcXG5cIiArXG4gICAgICAgICAgICBcIkZvciBGdXJ0aGVyIGRldGFpbHMuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXRoTXNnID0gbWFwKG9wdGlvbnMucHJlZml4UGF0aCwgZnVuY3Rpb24gKGN1cnJ0b2spIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbkxhYmVsKGN1cnJ0b2spO1xuICAgICAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBvY2N1cnJlbmNlID0gb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHggPT09IDAgPyBcIlwiIDogb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHg7XG4gICAgICAgIHZhciBjdXJyTWVzc2FnZSA9IFwiQW1iaWd1b3VzIEFsdGVybmF0aXZlcyBEZXRlY3RlZDogPFwiICsgb3B0aW9ucy5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKSArIFwiPiBpbiA8T1JcIiArIG9jY3VycmVuY2UgKyBcIj5cIiArXG4gICAgICAgICAgICAoXCIgaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZSxcXG5cIikgK1xuICAgICAgICAgICAgKFwiPFwiICsgcGF0aE1zZyArIFwiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuXCIpO1xuICAgICAgICBjdXJyTWVzc2FnZSA9XG4gICAgICAgICAgICBjdXJyTWVzc2FnZSArXG4gICAgICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQU1CSUdVT1VTX0FMVEVSTkFUSVZFU1xcblwiICtcbiAgICAgICAgICAgICAgICBcIkZvciBGdXJ0aGVyIGRldGFpbHMuXCI7XG4gICAgICAgIHJldHVybiBjdXJyTWVzc2FnZTtcbiAgICB9LFxuICAgIGJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3I6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUob3B0aW9ucy5yZXBldGl0aW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVwZXRpdGlvbi5pZHggIT09IDApIHtcbiAgICAgICAgICAgIGRzbE5hbWUgKz0gb3B0aW9ucy5yZXBldGl0aW9uLmlkeDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyTXNnID0gXCJUaGUgcmVwZXRpdGlvbiA8XCIgKyBkc2xOYW1lICsgXCI+IHdpdGhpbiBSdWxlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gY2FuIG5ldmVyIGNvbnN1bWUgYW55IHRva2Vucy5cXG5cIiArXG4gICAgICAgICAgICBcIlRoaXMgY291bGQgbGVhZCB0byBhbiBpbmZpbml0ZSBsb29wLlwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRUb2tlbk5hbWVFcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRva1R5cGVOYW1lID0gb3B0aW9ucy50b2tlblR5cGUubmFtZTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiSW52YWxpZCBHcmFtbWFyIFRva2VuIG5hbWU6IC0+XCIgKyB0b2tUeXBlTmFtZSArIFwiPC0gaXQgbXVzdCBtYXRjaCB0aGUgcGF0dGVybjogLT5cIiArIG9wdGlvbnMuZXhwZWN0ZWRQYXR0ZXJuLnRvU3RyaW5nKCkgKyBcIjwtXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiQW1iaWd1b3VzIGVtcHR5IGFsdGVybmF0aXZlOiA8XCIgKyAob3B0aW9ucy5lbXB0eUNob2ljZUlkeCArIDEpICsgXCI+XCIgK1xuICAgICAgICAgICAgKFwiIGluIDxPUlwiICsgb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHggKyBcIj4gaW5zaWRlIDxcIiArIG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWUgKyBcIj4gUnVsZS5cXG5cIikgK1xuICAgICAgICAgICAgXCJPbmx5IHRoZSBsYXN0IGFsdGVybmF0aXZlIG1heSBiZSBhbiBlbXB0eSBhbHRlcm5hdGl2ZS5cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyTXNnID0gXCJBbiBBbHRlcm5hdGlvbiBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMjU2IGFsdGVybmF0aXZlczpcXG5cIiArXG4gICAgICAgICAgICAoXCI8T1JcIiArIG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4ICsgXCI+IGluc2lkZSA8XCIgKyBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lICsgXCI+IFJ1bGUuXFxuIGhhcyBcIiArIChvcHRpb25zLmFsdGVybmF0aW9uLmRlZmluaXRpb24ubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAxKSArIFwiIGFsdGVybmF0aXZlcy5cIik7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZExlZnRSZWN1cnNpb25FcnJvcjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgdmFyIHBhdGhOYW1lcyA9IHV0aWxzLm1hcChvcHRpb25zLmxlZnRSZWN1cnNpb25QYXRoLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHsgcmV0dXJuIGN1cnJSdWxlLm5hbWU7IH0pO1xuICAgICAgICB2YXIgbGVmdFJlY3Vyc2l2ZVBhdGggPSBydWxlTmFtZSArIFwiIC0tPiBcIiArIHBhdGhOYW1lc1xuICAgICAgICAgICAgLmNvbmNhdChbcnVsZU5hbWVdKVxuICAgICAgICAgICAgLmpvaW4oXCIgLS0+IFwiKTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiTGVmdCBSZWN1cnNpb24gZm91bmQgaW4gZ3JhbW1hci5cXG5cIiArXG4gICAgICAgICAgICAoXCJydWxlOiA8XCIgKyBydWxlTmFtZSArIFwiPiBjYW4gYmUgaW52b2tlZCBmcm9tIGl0c2VsZiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSlcXG5cIikgK1xuICAgICAgICAgICAgKFwid2l0aG91dCBjb25zdW1pbmcgYW55IFRva2Vucy4gVGhlIGdyYW1tYXIgcGF0aCB0aGF0IGNhdXNlcyB0aGlzIGlzOiBcXG4gXCIgKyBsZWZ0UmVjdXJzaXZlUGF0aCArIFwiXFxuXCIpICtcbiAgICAgICAgICAgIFwiIFRvIGZpeCB0aGlzIHJlZmFjdG9yIHlvdXIgZ3JhbW1hciB0byByZW1vdmUgdGhlIGxlZnQgcmVjdXJzaW9uLlxcblwiICtcbiAgICAgICAgICAgIFwic2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MTF9wYXJzZXIjTGVmdF9GYWN0b3JpbmcuXCI7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEludmFsaWRSdWxlTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZXhwZWN0ZWRQYXR0ZXJuU3RyaW5nID0gb3B0aW9ucy5leHBlY3RlZFBhdHRlcm4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGVyck1zZyA9IFwiSW52YWxpZCBncmFtbWFyIHJ1bGUgbmFtZTogLT5cIiArIHJ1bGVOYW1lICsgXCI8LSBpdCBtdXN0IG1hdGNoIHRoZSBwYXR0ZXJuOiAtPlwiICsgZXhwZWN0ZWRQYXR0ZXJuU3RyaW5nICsgXCI8LVwiO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZU5hbWU7XG4gICAgICAgIGlmIChvcHRpb25zLnRvcExldmVsUnVsZSBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyck1zZyA9IFwiRHVwbGljYXRlIGRlZmluaXRpb24sIHJ1bGU6IC0+XCIgKyBydWxlTmFtZSArIFwiPC0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBncmFtbWFyOiAtPlwiICsgb3B0aW9ucy5ncmFtbWFyTmFtZSArIFwiPC1cIjtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzX3B1YmxpYy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js ***!
  \************************************************************************/
/*! exports provided: isRecognitionException, MismatchedTokenException, NoViableAltException, NotAllInputParsedException, EarlyExitException */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRecognitionException\", function() { return isRecognitionException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MismatchedTokenException\", function() { return MismatchedTokenException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoViableAltException\", function() { return NoViableAltException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotAllInputParsedException\", function() { return NotAllInputParsedException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EarlyExitException\", function() { return EarlyExitException; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\nvar MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nvar NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nvar EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nvar NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\nvar RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nfunction isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nfunction MismatchedTokenException(message, token, previousToken) {\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\n    this.message = message;\n    this.token = token;\n    this.previousToken = previousToken;\n    this.resyncedTokens = [];\n}\n// must use the \"Error.prototype\" instead of \"new Error\"\n// because the stack trace points to where \"new Error\" was invoked\"\nMismatchedTokenException.prototype = Error.prototype;\nfunction NoViableAltException(message, token, previousToken) {\n    this.name = NO_VIABLE_ALT_EXCEPTION;\n    this.message = message;\n    this.token = token;\n    this.previousToken = previousToken;\n    this.resyncedTokens = [];\n}\nNoViableAltException.prototype = Error.prototype;\nfunction NotAllInputParsedException(message, token) {\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n    this.message = message;\n    this.token = token;\n    this.resyncedTokens = [];\n}\nNotAllInputParsedException.prototype = Error.prototype;\nfunction EarlyExitException(message, token, previousToken) {\n    this.name = EARLY_EXIT_EXCEPTION;\n    this.message = message;\n    this.token = token;\n    this.previousToken = previousToken;\n    this.resyncedTokens = [];\n}\nEarlyExitException.prototype = Error.prototype;\n//# sourceMappingURL=exceptions_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9leGNlcHRpb25zX3B1YmxpYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2V4Y2VwdGlvbnNfcHVibGljLmpzP2JkOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29udGFpbnMgfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHNcIjtcbnZhciBNSVNNQVRDSEVEX1RPS0VOX0VYQ0VQVElPTiA9IFwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCI7XG52YXIgTk9fVklBQkxFX0FMVF9FWENFUFRJT04gPSBcIk5vVmlhYmxlQWx0RXhjZXB0aW9uXCI7XG52YXIgRUFSTFlfRVhJVF9FWENFUFRJT04gPSBcIkVhcmx5RXhpdEV4Y2VwdGlvblwiO1xudmFyIE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTiA9IFwiTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb25cIjtcbnZhciBSRUNPR05JVElPTl9FWENFUFRJT05fTkFNRVMgPSBbXG4gICAgTUlTTUFUQ0hFRF9UT0tFTl9FWENFUFRJT04sXG4gICAgTk9fVklBQkxFX0FMVF9FWENFUFRJT04sXG4gICAgRUFSTFlfRVhJVF9FWENFUFRJT04sXG4gICAgTk9UX0FMTF9JTlBVVF9QQVJTRURfRVhDRVBUSU9OXG5dO1xuT2JqZWN0LmZyZWV6ZShSRUNPR05JVElPTl9FWENFUFRJT05fTkFNRVMpO1xuLy8gaGFja3MgdG8gYnlwYXNzIG5vIHN1cHBvcnQgZm9yIGN1c3RvbSBFcnJvcnMgaW4gamF2YXNjcmlwdC90eXBlc2NyaXB0XG5leHBvcnQgZnVuY3Rpb24gaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlcnJvcikge1xuICAgIC8vIGNhbid0IGRvIGluc3RhbmNlb2Ygb24gaGFja2VkIGN1c3RvbSBqcyBleGNlcHRpb25zXG4gICAgcmV0dXJuIGNvbnRhaW5zKFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUywgZXJyb3IubmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKG1lc3NhZ2UsIHRva2VuLCBwcmV2aW91c1Rva2VuKSB7XG4gICAgdGhpcy5uYW1lID0gTUlTTUFUQ0hFRF9UT0tFTl9FWENFUFRJT047XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5wcmV2aW91c1Rva2VuID0gcHJldmlvdXNUb2tlbjtcbiAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG59XG4vLyBtdXN0IHVzZSB0aGUgXCJFcnJvci5wcm90b3R5cGVcIiBpbnN0ZWFkIG9mIFwibmV3IEVycm9yXCJcbi8vIGJlY2F1c2UgdGhlIHN0YWNrIHRyYWNlIHBvaW50cyB0byB3aGVyZSBcIm5ldyBFcnJvclwiIHdhcyBpbnZva2VkXCJcbk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5leHBvcnQgZnVuY3Rpb24gTm9WaWFibGVBbHRFeGNlcHRpb24obWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICB0aGlzLm5hbWUgPSBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgIHRoaXMucmVzeW5jZWRUb2tlbnMgPSBbXTtcbn1cbk5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmV4cG9ydCBmdW5jdGlvbiBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbihtZXNzYWdlLCB0b2tlbikge1xuICAgIHRoaXMubmFtZSA9IE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG59XG5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5leHBvcnQgZnVuY3Rpb24gRWFybHlFeGl0RXhjZXB0aW9uKG1lc3NhZ2UsIHRva2VuLCBwcmV2aW91c1Rva2VuKSB7XG4gICAgdGhpcy5uYW1lID0gRUFSTFlfRVhJVF9FWENFUFRJT047XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5wcmV2aW91c1Rva2VuID0gcHJldmlvdXNUb2tlbjtcbiAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG59XG5FYXJseUV4aXRFeGNlcHRpb24ucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9uc19wdWJsaWMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js ***!
  \*********************************************************************/
/*! exports provided: validateGrammar, identifyProductionForDuplicates, OccurrenceValidationCollector, validTermsPattern, validNestedRuleName, validateRuleName, validateNestedRuleName, validateTokenName, validateRuleDoesNotAlreadyExist, validateRuleIsOverridden, validateNoLeftRecursion, getFirstNoneTerminal, validateEmptyOrAlternative, validateAmbiguousAlternationAlternatives, RepetionCollector, validateTooManyAlts, validateSomeNonEmptyLookaheadPath, checkPrefixAlternativesAmbiguities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateGrammar\", function() { return validateGrammar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifyProductionForDuplicates\", function() { return identifyProductionForDuplicates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OccurrenceValidationCollector\", function() { return OccurrenceValidationCollector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validTermsPattern\", function() { return validTermsPattern; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validNestedRuleName\", function() { return validNestedRuleName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateRuleName\", function() { return validateRuleName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateNestedRuleName\", function() { return validateNestedRuleName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateTokenName\", function() { return validateTokenName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateRuleDoesNotAlreadyExist\", function() { return validateRuleDoesNotAlreadyExist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateRuleIsOverridden\", function() { return validateRuleIsOverridden; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateNoLeftRecursion\", function() { return validateNoLeftRecursion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFirstNoneTerminal\", function() { return getFirstNoneTerminal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateEmptyOrAlternative\", function() { return validateEmptyOrAlternative; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateAmbiguousAlternationAlternatives\", function() { return validateAmbiguousAlternationAlternatives; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepetionCollector\", function() { return RepetionCollector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateTooManyAlts\", function() { return validateTooManyAlts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateSomeNonEmptyLookaheadPath\", function() { return validateSomeNonEmptyLookaheadPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkPrefixAlternativesAmbiguities\", function() { return checkPrefixAlternativesAmbiguities; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parser_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser/parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _gast_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast/gast */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n/* harmony import */ var _lookahead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lookahead */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cst/cst */ \"./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js\");\n/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interpreter */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gast/gast_visitor_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {\n    var duplicateErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(leftRecursionErrors, _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])) {\n        emptyAltErrors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tokenNameErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](tokenTypes, function (currTokType) {\n        return validateTokenName(currTokType, errMsgProvider);\n    });\n    var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);\n    var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);\n    var tooManyAltsErrors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var ruleNameErrors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(topLevels, function (curRule) {\n        return validateRuleName(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"](duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));\n}\nfunction validateNestedRulesNames(topLevels, errMsgProvider) {\n    var result = [];\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(topLevels, function (curTopLevel) {\n        var namedCollectorVisitor = new _cst_cst__WEBPACK_IMPORTED_MODULE_4__[\"NamedDSLMethodsCollectorVisitor\"](\"\");\n        curTopLevel.accept(namedCollectorVisitor);\n        var nestedProds = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(namedCollectorVisitor.result, function (currItem) { return currItem.orgProd; });\n        result.push(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(nestedProds, function (currNestedProd) {\n            return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);\n        }));\n    });\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(result);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"groupBy\"](allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"](productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"](duplicates), function (currDuplicates) {\n        var firstProd = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"first\"](currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"getProductionDslName\"])(firstProd);\n        var defError = {\n            message: msg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n    return Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"getProductionDslName\"])(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"Terminal\"]) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"NonTerminal\"]) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__[\"GAstVisitor\"]));\n\nvar validTermsPattern = /^[a-zA-Z_]\\w*$/;\nvar validNestedRuleName = new RegExp(validTermsPattern.source.replace(\"^\", \"^\\\\$\"));\n// TODO: remove this limitation now that we use recorders\nfunction validateRuleName(rule, errMsgProvider) {\n    var errors = [];\n    var ruleName = rule.name;\n    if (!ruleName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildInvalidRuleNameError({\n                topLevelRule: rule,\n                expectedPattern: validTermsPattern\n            }),\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].INVALID_RULE_NAME,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\n// TODO: did the nested rule name regExp now change?\nfunction validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {\n    var errors = [];\n    var errMsg;\n    if (!nestedProd.name.match(validNestedRuleName)) {\n        errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);\n        errors.push({\n            message: errMsg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].INVALID_NESTED_RULE_NAME,\n            ruleName: topLevel.name\n        });\n    }\n    return errors;\n}\n// TODO: remove this limitation now that we use recorders\nfunction validateTokenName(tokenType, errMsgProvider) {\n    var errors = [];\n    var tokTypeName = tokenType.name;\n    if (!tokTypeName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildTokenNameError({\n                tokenType: tokenType,\n                expectedPattern: validTermsPattern\n            }),\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].INVALID_TOKEN_NAME\n        });\n    }\n    return errors;\n}\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"](definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"](nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"](nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"difference\"](nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](validNextSteps, function (currRefRule) {\n            var newPath = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"cloneArr\"](path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"](errorsFromNextSteps));\n    }\n}\nfunction getFirstNoneTerminal(definition) {\n    var result = [];\n    if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"](definition)) {\n        return result;\n    }\n    var firstProd = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"first\"](definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"NonTerminal\"]) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"Flat\"] ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"Option\"] ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"RepetitionMandatory\"] ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"RepetitionMandatoryWithSeparator\"] ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"RepetitionWithSeparator\"] ||\n        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"Repetition\"]) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"Alternation\"]) {\n        // each sub definition in alternation is a FLAT\n        result = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"](_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__[\"Terminal\"]) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"isOptionalProd\"])(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"drop\"](definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__[\"GAstVisitor\"]));\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"](ors, function (errors, currOr) {\n        var exceptLast = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"dropRight\"](currOr.definition);\n        var currErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = Object(_interpreter__WEBPACK_IMPORTED_MODULE_5__[\"nextPossibleTokensAfter\"])([currAlternative], [], null, 1);\n            if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"](possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"compact\"](currErrors));\n    }, []);\n    return errors;\n}\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // TODO: this filtering should be deprecated once we remove the ignoredIssues\n    //  IParserConfig property\n    var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];\n    if (ignoredIssuesForCurrentRule) {\n        ors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reject\"])(ors, function (currOr) {\n            return ignoredIssuesForCurrentRule[Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"getProductionDslName\"])(currOr) +\n                (currOr.idx === 0 ? \"\" : currOr.idx)];\n        });\n    }\n    // New Handling of ignoring ambiguities\n    // - https://github.com/SAP/chevrotain/issues/869\n    ors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reject\"])(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"](ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = Object(_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"getLookaheadPathsForOr\"])(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__[\"GAstVisitor\"]));\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"](ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(allRuleProductions, function (currProd) {\n            var prodType = Object(_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"getProdType\"])(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = Object(_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"getLookaheadPathsForOptionalProd\"])(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    Object(_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"containsPath\"])(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx]\n                        .ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !Object(_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"containsPath\"])(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"](identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"findAll\"])(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx]\n                .ignoreAmbiguities !== true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                Object(_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"isStrictPrefixOfPath\"])(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(tokenTypes, function (currToken) { return currToken.name; });\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\nfunction validateDuplicateNestedRules(topLevelRules, errMsgProvider) {\n    var errors = [];\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(topLevelRules, function (currTopRule) {\n        var namedCollectorVisitor = new _cst_cst__WEBPACK_IMPORTED_MODULE_4__[\"NamedDSLMethodsCollectorVisitor\"](\"\");\n        currTopRule.accept(namedCollectorVisitor);\n        var prodsByGroup = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"groupBy\"])(namedCollectorVisitor.result, function (item) { return item.name; });\n        var duplicates = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(prodsByGroup, function (currGroup) {\n            return currGroup.length > 1;\n        });\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(duplicates), function (currDupGroup) {\n            var currDupProds = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(currDupGroup, function (dupGroup) { return dupGroup.orgProd; });\n            var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);\n            errors.push({\n                message: errMsg,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__[\"ParserDefinitionErrorType\"].DUPLICATE_NESTED_NAME,\n                ruleName: currTopRule.name\n            });\n        });\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2NoZWNrcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvY2hlY2tzLmpzPzY2YzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGNvbnRhaW5zLCBldmVyeSwgZmluZEFsbCwgZmxhdHRlbiwgZm9yRWFjaCwgZ3JvdXBCeSwgaXNFbXB0eSwgbWFwLCBwaWNrLCByZWR1Y2UsIHJlamVjdCwgdmFsdWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4uL3BhcnNlci9wYXJzZXJcIjtcbmltcG9ydCB7IGdldFByb2R1Y3Rpb25Ec2xOYW1lLCBpc09wdGlvbmFsUHJvZCB9IGZyb20gXCIuL2dhc3QvZ2FzdFwiO1xuaW1wb3J0IHsgY29udGFpbnNQYXRoLCBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCwgZ2V0TG9va2FoZWFkUGF0aHNGb3JPciwgZ2V0UHJvZFR5cGUsIGlzU3RyaWN0UHJlZml4T2ZQYXRoIH0gZnJvbSBcIi4vbG9va2FoZWFkXCI7XG5pbXBvcnQgeyBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yIH0gZnJvbSBcIi4uL2NzdC9jc3RcIjtcbmltcG9ydCB7IG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyIH0gZnJvbSBcIi4vaW50ZXJwcmV0ZXJcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBGbGF0LCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3B1YmxpY1wiO1xuaW1wb3J0IHsgR0FzdFZpc2l0b3IgfSBmcm9tIFwiLi9nYXN0L2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdyYW1tYXIodG9wTGV2ZWxzLCBnbG9iYWxNYXhMb29rYWhlYWQsIHRva2VuVHlwZXMsIGlnbm9yZWRJc3N1ZXMsIGVyck1zZ1Byb3ZpZGVyLCBncmFtbWFyTmFtZSkge1xuICAgIHZhciBkdXBsaWNhdGVFcnJvcnMgPSB1dGlscy5tYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclRvcExldmVsKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUR1cGxpY2F0ZVByb2R1Y3Rpb25zKGN1cnJUb3BMZXZlbCwgZXJyTXNnUHJvdmlkZXIpO1xuICAgIH0pO1xuICAgIHZhciBsZWZ0UmVjdXJzaW9uRXJyb3JzID0gdXRpbHMubWFwKHRvcExldmVscywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbihjdXJyVG9wUnVsZSwgY3VyclRvcFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9KTtcbiAgICB2YXIgZW1wdHlBbHRFcnJvcnMgPSBbXTtcbiAgICB2YXIgYW1iaWd1b3VzQWx0c0Vycm9ycyA9IFtdO1xuICAgIHZhciBlbXB0eVJlcGV0aXRpb25FcnJvcnMgPSBbXTtcbiAgICAvLyBsZWZ0IHJlY3Vyc2lvbiBjb3VsZCBjYXVzZSBpbmZpbml0ZSBsb29wcyBpbiB0aGUgZm9sbG93aW5nIHZhbGlkYXRpb25zLlxuICAgIC8vIEl0IGlzIHNhZmVzdCB0byBmaXJzdCBoYXZlIHRoZSB1c2VyIGZpeCB0aGUgbGVmdCByZWN1cnNpb24gZXJyb3JzIGZpcnN0IGFuZCBvbmx5IHRoZW4gZXhhbWluZSBGdXJ0aGVyIGlzc3Vlcy5cbiAgICBpZiAoZXZlcnkobGVmdFJlY3Vyc2lvbkVycm9ycywgaXNFbXB0eSkpIHtcbiAgICAgICAgZW1wdHlBbHRFcnJvcnMgPSBtYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUVtcHR5T3JBbHRlcm5hdGl2ZShjdXJyVG9wUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYW1iaWd1b3VzQWx0c0Vycm9ycyA9IG1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJyVG9wUnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMoY3VyclRvcFJ1bGUsIGdsb2JhbE1heExvb2thaGVhZCwgaWdub3JlZElzc3VlcywgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1wdHlSZXBldGl0aW9uRXJyb3JzID0gdmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoKHRvcExldmVscywgZ2xvYmFsTWF4TG9va2FoZWFkLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfVxuICAgIHZhciB0ZXJtc05hbWVzcGFjZUNvbmZsaWN0RXJyb3JzID0gY2hlY2tUZXJtaW5hbEFuZE5vbmVUZXJtaW5hbHNOYW1lU3BhY2UodG9wTGV2ZWxzLCB0b2tlblR5cGVzLCBlcnJNc2dQcm92aWRlcik7XG4gICAgdmFyIHRva2VuTmFtZUVycm9ycyA9IHV0aWxzLm1hcCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlVG9rZW5OYW1lKGN1cnJUb2tUeXBlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfSk7XG4gICAgdmFyIG5lc3RlZFJ1bGVzTmFtZUVycm9ycyA9IHZhbGlkYXRlTmVzdGVkUnVsZXNOYW1lcyh0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB2YXIgbmVzdGVkUnVsZXNEdXBsaWNhdGVFcnJvcnMgPSB2YWxpZGF0ZUR1cGxpY2F0ZU5lc3RlZFJ1bGVzKHRvcExldmVscywgZXJyTXNnUHJvdmlkZXIpO1xuICAgIHZhciB0b29NYW55QWx0c0Vycm9ycyA9IG1hcCh0b3BMZXZlbHMsIGZ1bmN0aW9uIChjdXJSdWxlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVRvb01hbnlBbHRzKGN1clJ1bGUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICB9KTtcbiAgICB2YXIgcnVsZU5hbWVFcnJvcnMgPSBtYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyUnVsZSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVSdWxlTmFtZShjdXJSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfSk7XG4gICAgdmFyIGR1cGxpY2F0ZVJ1bGVzRXJyb3IgPSBtYXAodG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyUnVsZSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdChjdXJSdWxlLCB0b3BMZXZlbHMsIGdyYW1tYXJOYW1lLCBlcnJNc2dQcm92aWRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuICh1dGlscy5mbGF0dGVuKGR1cGxpY2F0ZUVycm9ycy5jb25jYXQodG9rZW5OYW1lRXJyb3JzLCBuZXN0ZWRSdWxlc05hbWVFcnJvcnMsIG5lc3RlZFJ1bGVzRHVwbGljYXRlRXJyb3JzLCBlbXB0eVJlcGV0aXRpb25FcnJvcnMsIGxlZnRSZWN1cnNpb25FcnJvcnMsIGVtcHR5QWx0RXJyb3JzLCBhbWJpZ3VvdXNBbHRzRXJyb3JzLCB0ZXJtc05hbWVzcGFjZUNvbmZsaWN0RXJyb3JzLCB0b29NYW55QWx0c0Vycm9ycywgcnVsZU5hbWVFcnJvcnMsIGR1cGxpY2F0ZVJ1bGVzRXJyb3IpKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU5lc3RlZFJ1bGVzTmFtZXModG9wTGV2ZWxzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3JFYWNoKHRvcExldmVscywgZnVuY3Rpb24gKGN1clRvcExldmVsKSB7XG4gICAgICAgIHZhciBuYW1lZENvbGxlY3RvclZpc2l0b3IgPSBuZXcgTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcihcIlwiKTtcbiAgICAgICAgY3VyVG9wTGV2ZWwuYWNjZXB0KG5hbWVkQ29sbGVjdG9yVmlzaXRvcik7XG4gICAgICAgIHZhciBuZXN0ZWRQcm9kcyA9IG1hcChuYW1lZENvbGxlY3RvclZpc2l0b3IucmVzdWx0LCBmdW5jdGlvbiAoY3Vyckl0ZW0pIHsgcmV0dXJuIGN1cnJJdGVtLm9yZ1Byb2Q7IH0pO1xuICAgICAgICByZXN1bHQucHVzaChtYXAobmVzdGVkUHJvZHMsIGZ1bmN0aW9uIChjdXJyTmVzdGVkUHJvZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTmVzdGVkUnVsZU5hbWUoY3VyVG9wTGV2ZWwsIGN1cnJOZXN0ZWRQcm9kLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmxhdHRlbihyZXN1bHQpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEdXBsaWNhdGVQcm9kdWN0aW9ucyh0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgIHZhciBhbGxSdWxlUHJvZHVjdGlvbnMgPSBjb2xsZWN0b3JWaXNpdG9yLmFsbFByb2R1Y3Rpb25zO1xuICAgIHZhciBwcm9kdWN0aW9uR3JvdXBzID0gdXRpbHMuZ3JvdXBCeShhbGxSdWxlUHJvZHVjdGlvbnMsIGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXMpO1xuICAgIHZhciBkdXBsaWNhdGVzID0gdXRpbHMucGljayhwcm9kdWN0aW9uR3JvdXBzLCBmdW5jdGlvbiAoY3Vyckdyb3VwKSB7XG4gICAgICAgIHJldHVybiBjdXJyR3JvdXAubGVuZ3RoID4gMTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gdXRpbHMubWFwKHV0aWxzLnZhbHVlcyhkdXBsaWNhdGVzKSwgZnVuY3Rpb24gKGN1cnJEdXBsaWNhdGVzKSB7XG4gICAgICAgIHZhciBmaXJzdFByb2QgPSB1dGlscy5maXJzdChjdXJyRHVwbGljYXRlcyk7XG4gICAgICAgIHZhciBtc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZUZvdW5kRXJyb3IodG9wTGV2ZWxSdWxlLCBjdXJyRHVwbGljYXRlcyk7XG4gICAgICAgIHZhciBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZmlyc3RQcm9kKTtcbiAgICAgICAgdmFyIGRlZkVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUFJPRFVDVElPTlMsXG4gICAgICAgICAgICBydWxlTmFtZTogdG9wTGV2ZWxSdWxlLm5hbWUsXG4gICAgICAgICAgICBkc2xOYW1lOiBkc2xOYW1lLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogZmlyc3RQcm9kLmlkeFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyYW0gPSBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChmaXJzdFByb2QpO1xuICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgIGRlZkVycm9yLnBhcmFtZXRlciA9IHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZFcnJvcjtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXMocHJvZCkge1xuICAgIHJldHVybiBnZXRQcm9kdWN0aW9uRHNsTmFtZShwcm9kKSArIFwiXyNfXCIgKyBwcm9kLmlkeCArIFwiXyNfXCIgKyBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChwcm9kKTtcbn1cbmZ1bmN0aW9uIGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpIHtcbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBwcm9kLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb2Qubm9uVGVybWluYWxOYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxudmFyIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmFsbFByb2R1Y3Rpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAoc3VicnVsZSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goc3VicnVsZSk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChvcHRpb24pO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAoYXRMZWFzdE9uZVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3Rvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH07XG4gICAgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb24gPSBmdW5jdGlvbiAob3IpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG9yKTtcbiAgICB9O1xuICAgIE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0ZXJtaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3I7XG59KEdBc3RWaXNpdG9yKSk7XG5leHBvcnQgeyBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciB9O1xuZXhwb3J0IHZhciB2YWxpZFRlcm1zUGF0dGVybiA9IC9eW2EtekEtWl9dXFx3KiQvO1xuZXhwb3J0IHZhciB2YWxpZE5lc3RlZFJ1bGVOYW1lID0gbmV3IFJlZ0V4cCh2YWxpZFRlcm1zUGF0dGVybi5zb3VyY2UucmVwbGFjZShcIl5cIiwgXCJeXFxcXCRcIikpO1xuLy8gVE9ETzogcmVtb3ZlIHRoaXMgbGltaXRhdGlvbiBub3cgdGhhdCB3ZSB1c2UgcmVjb3JkZXJzXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSdWxlTmFtZShydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgcnVsZU5hbWUgPSBydWxlLm5hbWU7XG4gICAgaWYgKCFydWxlTmFtZS5tYXRjaCh2YWxpZFRlcm1zUGF0dGVybikpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnUHJvdmlkZXIuYnVpbGRJbnZhbGlkUnVsZU5hbWVFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkUGF0dGVybjogdmFsaWRUZXJtc1BhdHRlcm5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1JVTEVfTkFNRSxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlTmFtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIFRPRE86IGRpZCB0aGUgbmVzdGVkIHJ1bGUgbmFtZSByZWdFeHAgbm93IGNoYW5nZT9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU5lc3RlZFJ1bGVOYW1lKHRvcExldmVsLCBuZXN0ZWRQcm9kLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgZXJyTXNnO1xuICAgIGlmICghbmVzdGVkUHJvZC5uYW1lLm1hdGNoKHZhbGlkTmVzdGVkUnVsZU5hbWUpKSB7XG4gICAgICAgIGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkSW52YWxpZE5lc3RlZFJ1bGVOYW1lRXJyb3IodG9wTGV2ZWwsIG5lc3RlZFByb2QpO1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfTkVTVEVEX1JVTEVfTkFNRSxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbC5uYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgbGltaXRhdGlvbiBub3cgdGhhdCB3ZSB1c2UgcmVjb3JkZXJzXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbk5hbWUodG9rZW5UeXBlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdG9rVHlwZU5hbWUgPSB0b2tlblR5cGUubmFtZTtcbiAgICBpZiAoIXRva1R5cGVOYW1lLm1hdGNoKHZhbGlkVGVybXNQYXR0ZXJuKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZFRva2VuTmFtZUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHRva2VuVHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZFBhdHRlcm46IHZhbGlkVGVybXNQYXR0ZXJuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9UT0tFTl9OQU1FXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3QocnVsZSwgYWxsUnVsZXMsIGNsYXNzTmFtZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIG9jY3VycmVuY2VzID0gcmVkdWNlKGFsbFJ1bGVzLCBmdW5jdGlvbiAocmVzdWx0LCBjdXJSdWxlKSB7XG4gICAgICAgIGlmIChjdXJSdWxlLm5hbWUgPT09IHJ1bGUubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCAwKTtcbiAgICBpZiAob2NjdXJyZW5jZXMgPiAxKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgZ3JhbW1hck5hbWU6IGNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIFRPRE86IGlzIHRoZXJlIGFueXdheSB0byBnZXQgb25seSB0aGUgcnVsZSBuYW1lcyBvZiBydWxlcyBpbmhlcml0ZWQgZnJvbSB0aGUgc3VwZXIgZ3JhbW1hcnM/XG4vLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBJR3JhbW1hckVycm9yUHJvdmlkZXIgYmVjYXVzZSB0aGUgdmFsaWRhdGlvbiBjYW5ub3QgYmUgcGVyZm9ybWVkIG9uXG4vLyBUaGUgZ3JhbW1hciBzdHJ1Y3R1cmUsIG9ubHkgYXQgcnVudGltZS5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4ocnVsZU5hbWUsIGRlZmluZWRSdWxlc05hbWVzLCBjbGFzc05hbWUpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIGVyck1zZztcbiAgICBpZiAoIXV0aWxzLmNvbnRhaW5zKGRlZmluZWRSdWxlc05hbWVzLCBydWxlTmFtZSkpIHtcbiAgICAgICAgZXJyTXNnID1cbiAgICAgICAgICAgIFwiSW52YWxpZCBydWxlIG92ZXJyaWRlLCBydWxlOiAtPlwiICsgcnVsZU5hbWUgKyBcIjwtIGNhbm5vdCBiZSBvdmVycmlkZGVuIGluIHRoZSBncmFtbWFyOiAtPlwiICsgY2xhc3NOYW1lICsgXCI8LVwiICtcbiAgICAgICAgICAgICAgICBcImFzIGl0IGlzIG5vdCBkZWZpbmVkIGluIGFueSBvZiB0aGUgc3VwZXIgZ3JhbW1hcnMgXCI7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9SVUxFX09WRVJSSURFLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKHRvcFJ1bGUsIGN1cnJSdWxlLCBlcnJNc2dQcm92aWRlciwgcGF0aCkge1xuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFtdOyB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBuZXh0Tm9uVGVybWluYWxzID0gZ2V0Rmlyc3ROb25lVGVybWluYWwoY3VyclJ1bGUuZGVmaW5pdGlvbik7XG4gICAgaWYgKHV0aWxzLmlzRW1wdHkobmV4dE5vblRlcm1pbmFscykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gdG9wUnVsZS5uYW1lO1xuICAgICAgICB2YXIgZm91bmRMZWZ0UmVjdXJzaW9uID0gdXRpbHMuY29udGFpbnMobmV4dE5vblRlcm1pbmFscywgdG9wUnVsZSk7XG4gICAgICAgIGlmIChmb3VuZExlZnRSZWN1cnNpb24pIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZExlZnRSZWN1cnNpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJlY3Vyc2lvblBhdGg6IHBhdGhcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFRlRfUkVDVVJTSU9OLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgYXJlIG9ubHkgbG9va2luZyBmb3IgY3ljbGljIHBhdGhzIGxlYWRpbmcgYmFjayB0byB0aGUgc3BlY2lmaWMgdG9wUnVsZVxuICAgICAgICAvLyBvdGhlciBjeWNsaWMgcGF0aHMgYXJlIGlnbm9yZWQsIHdlIHN0aWxsIG5lZWQgdGhpcyBkaWZmZXJlbmNlIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLi4uXG4gICAgICAgIHZhciB2YWxpZE5leHRTdGVwcyA9IHV0aWxzLmRpZmZlcmVuY2UobmV4dE5vblRlcm1pbmFscywgcGF0aC5jb25jYXQoW3RvcFJ1bGVdKSk7XG4gICAgICAgIHZhciBlcnJvcnNGcm9tTmV4dFN0ZXBzID0gdXRpbHMubWFwKHZhbGlkTmV4dFN0ZXBzLCBmdW5jdGlvbiAoY3VyclJlZlJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID0gdXRpbHMuY2xvbmVBcnIocGF0aCk7XG4gICAgICAgICAgICBuZXdQYXRoLnB1c2goY3VyclJlZlJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKHRvcFJ1bGUsIGN1cnJSZWZSdWxlLCBlcnJNc2dQcm92aWRlciwgbmV3UGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh1dGlscy5mbGF0dGVuKGVycm9yc0Zyb21OZXh0U3RlcHMpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3ROb25lVGVybWluYWwoZGVmaW5pdGlvbikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAodXRpbHMuaXNFbXB0eShkZWZpbml0aW9uKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2YXIgZmlyc3RQcm9kID0gdXRpbHMuZmlyc3QoZGVmaW5pdGlvbik7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZmlyc3RQcm9kLnJlZmVyZW5jZWRSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgRmxhdCB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBPcHRpb24gfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZ2V0Rmlyc3ROb25lVGVybWluYWwoZmlyc3RQcm9kLmRlZmluaXRpb24pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgLy8gZWFjaCBzdWIgZGVmaW5pdGlvbiBpbiBhbHRlcm5hdGlvbiBpcyBhIEZMQVRcbiAgICAgICAgcmVzdWx0ID0gdXRpbHMuZmxhdHRlbih1dGlscy5tYXAoZmlyc3RQcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChjdXJyU3ViRGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Rmlyc3ROb25lVGVybWluYWwoY3VyclN1YkRlZi5kZWZpbml0aW9uKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIHNlZSwgbW92ZSBhbG9uZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG4gICAgdmFyIGlzRmlyc3RPcHRpb25hbCA9IGlzT3B0aW9uYWxQcm9kKGZpcnN0UHJvZCk7XG4gICAgdmFyIGhhc01vcmUgPSBkZWZpbml0aW9uLmxlbmd0aCA+IDE7XG4gICAgaWYgKGlzRmlyc3RPcHRpb25hbCAmJiBoYXNNb3JlKSB7XG4gICAgICAgIHZhciByZXN0ID0gdXRpbHMuZHJvcChkZWZpbml0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoZ2V0Rmlyc3ROb25lVGVybWluYWwocmVzdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG52YXIgT3JDb2xsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9yQ29sbGVjdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9yQ29sbGVjdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWx0ZXJuYXRpb25zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT3JDb2xsZWN0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmFsdGVybmF0aW9ucy5wdXNoKG5vZGUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9yQ29sbGVjdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICB2YXIgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIHZhciBlcnJvcnMgPSB1dGlscy5yZWR1Y2Uob3JzLCBmdW5jdGlvbiAoZXJyb3JzLCBjdXJyT3IpIHtcbiAgICAgICAgdmFyIGV4Y2VwdExhc3QgPSB1dGlscy5kcm9wUmlnaHQoY3Vyck9yLmRlZmluaXRpb24pO1xuICAgICAgICB2YXIgY3VyckVycm9ycyA9IHV0aWxzLm1hcChleGNlcHRMYXN0LCBmdW5jdGlvbiAoY3VyckFsdGVybmF0aXZlLCBjdXJyQWx0SWR4KSB7XG4gICAgICAgICAgICB2YXIgcG9zc2libGVGaXJzdEluQWx0ID0gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW2N1cnJBbHRlcm5hdGl2ZV0sIFtdLCBudWxsLCAxKTtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0VtcHR5KHBvc3NpYmxlRmlyc3RJbkFsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHRvcExldmVsUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uOiBjdXJyT3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eUNob2ljZUlkeDogY3VyckFsdElkeFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT05FX0xBU1RfRU1QVFlfQUxULFxuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZTogdG9wTGV2ZWxSdWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IGN1cnJPci5pZHgsXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBjdXJyQWx0SWR4ICsgMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMuY29uY2F0KHV0aWxzLmNvbXBhY3QoY3VyckVycm9ycykpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXModG9wTGV2ZWxSdWxlLCBnbG9iYWxNYXhMb29rYWhlYWQsIGlnbm9yZWRJc3N1ZXMsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIG9yQ29sbGVjdG9yID0gbmV3IE9yQ29sbGVjdG9yKCk7XG4gICAgdG9wTGV2ZWxSdWxlLmFjY2VwdChvckNvbGxlY3Rvcik7XG4gICAgdmFyIG9ycyA9IG9yQ29sbGVjdG9yLmFsdGVybmF0aW9ucztcbiAgICAvLyBUT0RPOiB0aGlzIGZpbHRlcmluZyBzaG91bGQgYmUgZGVwcmVjYXRlZCBvbmNlIHdlIHJlbW92ZSB0aGUgaWdub3JlZElzc3Vlc1xuICAgIC8vICBJUGFyc2VyQ29uZmlnIHByb3BlcnR5XG4gICAgdmFyIGlnbm9yZWRJc3N1ZXNGb3JDdXJyZW50UnVsZSA9IGlnbm9yZWRJc3N1ZXNbdG9wTGV2ZWxSdWxlLm5hbWVdO1xuICAgIGlmIChpZ25vcmVkSXNzdWVzRm9yQ3VycmVudFJ1bGUpIHtcbiAgICAgICAgb3JzID0gcmVqZWN0KG9ycywgZnVuY3Rpb24gKGN1cnJPcikge1xuICAgICAgICAgICAgcmV0dXJuIGlnbm9yZWRJc3N1ZXNGb3JDdXJyZW50UnVsZVtnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyT3IpICtcbiAgICAgICAgICAgICAgICAoY3Vyck9yLmlkeCA9PT0gMCA/IFwiXCIgOiBjdXJyT3IuaWR4KV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOZXcgSGFuZGxpbmcgb2YgaWdub3JpbmcgYW1iaWd1aXRpZXNcbiAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9TQVAvY2hldnJvdGFpbi9pc3N1ZXMvODY5XG4gICAgb3JzID0gcmVqZWN0KG9ycywgZnVuY3Rpb24gKGN1cnJPcikgeyByZXR1cm4gY3Vyck9yLmlnbm9yZUFtYmlndWl0aWVzID09PSB0cnVlOyB9KTtcbiAgICB2YXIgZXJyb3JzID0gdXRpbHMucmVkdWNlKG9ycywgZnVuY3Rpb24gKHJlc3VsdCwgY3Vyck9yKSB7XG4gICAgICAgIHZhciBjdXJyT2NjdXJyZW5jZSA9IGN1cnJPci5pZHg7XG4gICAgICAgIHZhciBhY3R1YWxNYXhMb29rYWhlYWQgPSBjdXJyT3IubWF4TG9va2FoZWFkIHx8IGdsb2JhbE1heExvb2thaGVhZDtcbiAgICAgICAgdmFyIGFsdGVybmF0aXZlcyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3IoY3Vyck9jY3VycmVuY2UsIHRvcExldmVsUnVsZSwgYWN0dWFsTWF4TG9va2FoZWFkLCBjdXJyT3IpO1xuICAgICAgICB2YXIgYWx0c0FtYmlndWl0eUVycm9ycyA9IGNoZWNrQWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBjdXJyT3IsIHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICB2YXIgYWx0c1ByZWZpeEFtYmlndWl0eUVycm9ycyA9IGNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBjdXJyT3IsIHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChhbHRzQW1iaWd1aXR5RXJyb3JzLCBhbHRzUHJlZml4QW1iaWd1aXR5RXJyb3JzKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbnZhciBSZXBldGlvbkNvbGxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVwZXRpb25Db2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZXRpb25Db2xsZWN0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbGxQcm9kdWN0aW9ucyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlcGV0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG1hbnlTZXApIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnlTZXApO1xuICAgIH07XG4gICAgUmVwZXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSA9IGZ1bmN0aW9uIChhdExlYXN0T25lKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lKTtcbiAgICB9O1xuICAgIFJlcGV0aW9uQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXApIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmVTZXApO1xuICAgIH07XG4gICAgUmVwZXRpb25Db2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChtYW55KSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChtYW55KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXBldGlvbkNvbGxlY3Rvcjtcbn0oR0FzdFZpc2l0b3IpKTtcbmV4cG9ydCB7IFJlcGV0aW9uQ29sbGVjdG9yIH07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUb29NYW55QWx0cyh0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIG9yQ29sbGVjdG9yID0gbmV3IE9yQ29sbGVjdG9yKCk7XG4gICAgdG9wTGV2ZWxSdWxlLmFjY2VwdChvckNvbGxlY3Rvcik7XG4gICAgdmFyIG9ycyA9IG9yQ29sbGVjdG9yLmFsdGVybmF0aW9ucztcbiAgICB2YXIgZXJyb3JzID0gdXRpbHMucmVkdWNlKG9ycywgZnVuY3Rpb24gKGVycm9ycywgY3Vyck9yKSB7XG4gICAgICAgIGlmIChjdXJyT3IuZGVmaW5pdGlvbi5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZFRvb01hbnlBbHRlcm5hdGl2ZXNFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wTGV2ZWxSdWxlLFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbjogY3Vyck9yXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5UT09fTUFOWV9BTFRTLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlOiBjdXJyT3IuaWR4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aCh0b3BMZXZlbFJ1bGVzLCBtYXhMb29rYWhlYWQsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGZvckVhY2godG9wTGV2ZWxSdWxlcywgZnVuY3Rpb24gKGN1cnJUb3BSdWxlKSB7XG4gICAgICAgIHZhciBjb2xsZWN0b3JWaXNpdG9yID0gbmV3IFJlcGV0aW9uQ29sbGVjdG9yKCk7XG4gICAgICAgIGN1cnJUb3BSdWxlLmFjY2VwdChjb2xsZWN0b3JWaXNpdG9yKTtcbiAgICAgICAgdmFyIGFsbFJ1bGVQcm9kdWN0aW9ucyA9IGNvbGxlY3RvclZpc2l0b3IuYWxsUHJvZHVjdGlvbnM7XG4gICAgICAgIGZvckVhY2goYWxsUnVsZVByb2R1Y3Rpb25zLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgIHZhciBwcm9kVHlwZSA9IGdldFByb2RUeXBlKGN1cnJQcm9kKTtcbiAgICAgICAgICAgIHZhciBhY3R1YWxNYXhMb29rYWhlYWQgPSBjdXJyUHJvZC5tYXhMb29rYWhlYWQgfHwgbWF4TG9va2FoZWFkO1xuICAgICAgICAgICAgdmFyIGN1cnJPY2N1cnJlbmNlID0gY3VyclByb2QuaWR4O1xuICAgICAgICAgICAgdmFyIHBhdGhzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QoY3Vyck9jY3VycmVuY2UsIGN1cnJUb3BSdWxlLCBwcm9kVHlwZSwgYWN0dWFsTWF4TG9va2FoZWFkKTtcbiAgICAgICAgICAgIHZhciBwYXRoc0luc2lkZVByb2R1Y3Rpb24gPSBwYXRoc1swXTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGZsYXR0ZW4ocGF0aHNJbnNpZGVQcm9kdWN0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyTXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRFbXB0eVJlcGV0aXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogY3VyclRvcFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcGV0aXRpb246IGN1cnJQcm9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTk9OX0VNUFRZX0xPT0tBSEVBRCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWU6IGN1cnJUb3BSdWxlLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGNoZWNrQWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBhbHRlcm5hdGlvbiwgcnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZm91bmRBbWJpZ3VvdXNQYXRocyA9IFtdO1xuICAgIHZhciBpZGVudGljYWxBbWJpZ3VpdGllcyA9IHJlZHVjZShhbHRlcm5hdGl2ZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJBbHQsIGN1cnJBbHRJZHgpIHtcbiAgICAgICAgLy8gaWdub3JlIChza2lwKSBhbWJpZ3VpdGllcyB3aXRoIHRoaXMgYWx0ZXJuYXRpdmVcbiAgICAgICAgaWYgKGFsdGVybmF0aW9uLmRlZmluaXRpb25bY3VyckFsdElkeF0uaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaChjdXJyQWx0LCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgICAgIHZhciBhbHRzQ3VyclBhdGhBcHBlYXJzSW4gPSBbY3VyckFsdElkeF07XG4gICAgICAgICAgICBmb3JFYWNoKGFsdGVybmF0aXZlcywgZnVuY3Rpb24gKGN1cnJPdGhlckFsdCwgY3Vyck90aGVyQWx0SWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJBbHRJZHggIT09IGN1cnJPdGhlckFsdElkeCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluc1BhdGgoY3Vyck90aGVyQWx0LCBjdXJyUGF0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIChza2lwKSBhbWJpZ3VpdGllcyB3aXRoIHRoaXMgXCJvdGhlclwiIGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uLmRlZmluaXRpb25bY3Vyck90aGVyQWx0SWR4XVxuICAgICAgICAgICAgICAgICAgICAgICAgLmlnbm9yZUFtYmlndWl0aWVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdHNDdXJyUGF0aEFwcGVhcnNJbi5wdXNoKGN1cnJPdGhlckFsdElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWx0c0N1cnJQYXRoQXBwZWFyc0luLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgICAgICAhY29udGFpbnNQYXRoKGZvdW5kQW1iaWd1b3VzUGF0aHMsIGN1cnJQYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kQW1iaWd1b3VzUGF0aHMucHVzaChjdXJyUGF0aCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhbHRzOiBhbHRzQ3VyclBhdGhBcHBlYXJzSW4sXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN1cnJQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgY3VyckVycm9ycyA9IHV0aWxzLm1hcChpZGVudGljYWxBbWJpZ3VpdGllcywgZnVuY3Rpb24gKGN1cnJBbWJEZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBhbWJnSW5kaWNlcyA9IG1hcChjdXJyQW1iRGVzY3JpcHRvci5hbHRzLCBmdW5jdGlvbiAoY3VyckFsdElkeCkgeyByZXR1cm4gY3VyckFsdElkeCArIDE7IH0pO1xuICAgICAgICB2YXIgY3Vyck1lc3NhZ2UgPSBlcnJNc2dQcm92aWRlci5idWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IGFsdGVybmF0aW9uLFxuICAgICAgICAgICAgYW1iaWd1aXR5SW5kaWNlczogYW1iZ0luZGljZXMsXG4gICAgICAgICAgICBwcmVmaXhQYXRoOiBjdXJyQW1iRGVzY3JpcHRvci5wYXRoXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogY3Vyck1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19BTFRTLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IGFsdGVybmF0aW9uLmlkeCxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlczogW2N1cnJBbWJEZXNjcmlwdG9yLmFsdHNdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1cnJFcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGFsdGVybmF0aW9uLCBydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAvLyBmbGF0dGVuXG4gICAgdmFyIHBhdGhzQW5kSW5kaWNlcyA9IHJlZHVjZShhbHRlcm5hdGl2ZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJBbHQsIGlkeCkge1xuICAgICAgICB2YXIgY3VyclBhdGhzQW5kSWR4ID0gbWFwKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWR4OiBpZHgsIHBhdGg6IGN1cnJQYXRoIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJyUGF0aHNBbmRJZHgpO1xuICAgIH0sIFtdKTtcbiAgICBmb3JFYWNoKHBhdGhzQW5kSW5kaWNlcywgZnVuY3Rpb24gKGN1cnJQYXRoQW5kSWR4KSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZUdhc3QgPSBhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJQYXRoQW5kSWR4LmlkeF07XG4gICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIGFsdGVybmF0aXZlXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZUdhc3QuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0SWR4ID0gY3VyclBhdGhBbmRJZHguaWR4O1xuICAgICAgICB2YXIgdGFyZ2V0UGF0aCA9IGN1cnJQYXRoQW5kSWR4LnBhdGg7XG4gICAgICAgIHZhciBwcmVmaXhBbWJpZ3VpdGllc1BhdGhzQW5kSW5kaWNlcyA9IGZpbmRBbGwocGF0aHNBbmRJbmRpY2VzLCBmdW5jdGlvbiAoc2VhcmNoUGF0aEFuZElkeCkge1xuICAgICAgICAgICAgLy8gcHJlZml4IGFtYmlndWl0eSBjYW4gb25seSBiZSBjcmVhdGVkIGZyb20gbG93ZXIgaWR4IChoaWdoZXIgcHJpb3JpdHkpIHBhdGhcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBcIm90aGVyXCIgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIGFsdGVybmF0aW9uLmRlZmluaXRpb25bc2VhcmNoUGF0aEFuZElkeC5pZHhdXG4gICAgICAgICAgICAgICAgLmlnbm9yZUFtYmlndWl0aWVzICE9PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgc2VhcmNoUGF0aEFuZElkeC5pZHggPCB0YXJnZXRJZHggJiZcbiAgICAgICAgICAgICAgICAvLyBjaGVja2luZyBmb3Igc3RyaWN0IHByZWZpeCBiZWNhdXNlIGlkZW50aWNhbCBsb29rYWhlYWRzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBiZSBkZXRlY3RlZCB1c2luZyBhIGRpZmZlcmVudCB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgICAgIGlzU3RyaWN0UHJlZml4T2ZQYXRoKHNlYXJjaFBhdGhBbmRJZHgucGF0aCwgdGFyZ2V0UGF0aCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGN1cnJQYXRoUHJlZml4RXJyb3JzID0gbWFwKHByZWZpeEFtYmlndWl0aWVzUGF0aHNBbmRJbmRpY2VzLCBmdW5jdGlvbiAoY3VyckFtYlBhdGhBbmRJZHgpIHtcbiAgICAgICAgICAgIHZhciBhbWJnSW5kaWNlcyA9IFtjdXJyQW1iUGF0aEFuZElkeC5pZHggKyAxLCB0YXJnZXRJZHggKyAxXTtcbiAgICAgICAgICAgIHZhciBvY2N1cnJlbmNlID0gYWx0ZXJuYXRpb24uaWR4ID09PSAwID8gXCJcIiA6IGFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpb246IGFsdGVybmF0aW9uLFxuICAgICAgICAgICAgICAgIGFtYmlndWl0eUluZGljZXM6IGFtYmdJbmRpY2VzLFxuICAgICAgICAgICAgICAgIHByZWZpeFBhdGg6IGN1cnJBbWJQYXRoQW5kSWR4LnBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQU1CSUdVT1VTX1BSRUZJWF9BTFRTLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogb2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IGFtYmdJbmRpY2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChjdXJyUGF0aFByZWZpeEVycm9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGNoZWNrVGVybWluYWxBbmROb25lVGVybWluYWxzTmFtZVNwYWNlKHRvcExldmVscywgdG9rZW5UeXBlcywgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgdmFyIHRva2VuTmFtZXMgPSBtYXAodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUb2tlbikgeyByZXR1cm4gY3VyclRva2VuLm5hbWU7IH0pO1xuICAgIGZvckVhY2godG9wTGV2ZWxzLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHtcbiAgICAgICAgdmFyIGN1cnJSdWxlTmFtZSA9IGN1cnJSdWxlLm5hbWU7XG4gICAgICAgIGlmIChjb250YWlucyh0b2tlbk5hbWVzLCBjdXJyUnVsZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yKGN1cnJSdWxlKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBjdXJyUnVsZU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRHVwbGljYXRlTmVzdGVkUnVsZXModG9wTGV2ZWxSdWxlcywgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZm9yRWFjaCh0b3BMZXZlbFJ1bGVzLCBmdW5jdGlvbiAoY3VyclRvcFJ1bGUpIHtcbiAgICAgICAgdmFyIG5hbWVkQ29sbGVjdG9yVmlzaXRvciA9IG5ldyBOYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKFwiXCIpO1xuICAgICAgICBjdXJyVG9wUnVsZS5hY2NlcHQobmFtZWRDb2xsZWN0b3JWaXNpdG9yKTtcbiAgICAgICAgdmFyIHByb2RzQnlHcm91cCA9IGdyb3VwQnkobmFtZWRDb2xsZWN0b3JWaXNpdG9yLnJlc3VsdCwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubmFtZTsgfSk7XG4gICAgICAgIHZhciBkdXBsaWNhdGVzID0gcGljayhwcm9kc0J5R3JvdXAsIGZ1bmN0aW9uIChjdXJyR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyR3JvdXAubGVuZ3RoID4gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvckVhY2godmFsdWVzKGR1cGxpY2F0ZXMpLCBmdW5jdGlvbiAoY3VyckR1cEdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgY3VyckR1cFByb2RzID0gbWFwKGN1cnJEdXBHcm91cCwgZnVuY3Rpb24gKGR1cEdyb3VwKSB7IHJldHVybiBkdXBHcm91cC5vcmdQcm9kOyB9KTtcbiAgICAgICAgICAgIHZhciBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZU5lc3RlZFJ1bGVOYW1lRXJyb3IoY3VyclRvcFJ1bGUsIGN1cnJEdXBQcm9kcyk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX05FU1RFRF9OQU1FLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBjdXJyVG9wUnVsZS5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js ***!
  \********************************************************************/
/*! exports provided: first, firstForSequence, firstForBranching, firstForTerminal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"first\", function() { return first; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstForSequence\", function() { return firstForSequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstForBranching\", function() { return firstForBranching; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstForTerminal\", function() { return firstForTerminal; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast/gast */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\nfunction first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"]) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]) {\n        return firstForTerminal(prod);\n    }\n    else if (Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"isSequenceProd\"])(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"isBranchingProd\"])(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction firstForSequence(prod) {\n    var firstSet = [];\n    var seq = prod.definition;\n    var nextSubProdIdx = 0;\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    var currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    var isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = Object(_gast_gast__WEBPACK_IMPORTED_MODULE_2__[\"isOptionalProd\"])(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"uniq\"])(firstSet);\n}\nfunction firstForBranching(prod) {\n    var allAlternativesFirsts = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(prod.definition, function (innerProd) {\n        return first(innerProd);\n    });\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"uniq\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(allAlternativesFirsts));\n}\nfunction firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2ZpcnN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZ3JhbW1hci9maXJzdC5qcz8xNTU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVuaXEsIG1hcCwgZmxhdHRlbiB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTm9uVGVybWluYWwsIFRlcm1pbmFsIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3B1YmxpY1wiO1xuaW1wb3J0IHsgaXNCcmFuY2hpbmdQcm9kLCBpc09wdGlvbmFsUHJvZCwgaXNTZXF1ZW5jZVByb2QgfSBmcm9tIFwiLi9nYXN0L2dhc3RcIjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdChwcm9kKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgaW4gdGhlb3J5IGNhdXNlIGluZmluaXRlIGxvb3BzIGlmXG4gICAgICAgIC8vICgxKSBwcm9kIEEgcmVmcyBwcm9kIEIuXG4gICAgICAgIC8vICgyKSBwcm9kIEIgcmVmcyBwcm9kIEFcbiAgICAgICAgLy8gKDMpIEFCIGNhbiBtYXRjaCB0aGUgZW1wdHkgc2V0XG4gICAgICAgIC8vIGluIG90aGVyIHdvcmRzIGEgY3ljbGUgd2hlcmUgZXZlcnl0aGluZyBpcyBvcHRpb25hbCBzbyB0aGUgZmlyc3Qgd2lsbCBrZWVwXG4gICAgICAgIC8vIGxvb2tpbmcgYWhlYWQgZm9yIHRoZSBuZXh0IG9wdGlvbmFsIHBhcnQgYW5kIHdpbGwgbmV2ZXIgZXhpdFxuICAgICAgICAvLyBjdXJyZW50bHkgdGhlcmUgaXMgbm8gc2FmZWd1YXJkIGZvciB0aGlzIHVuaXF1ZSBlZGdlIGNhc2UgYmVjYXVzZVxuICAgICAgICAvLyAoMSkgbm90IHN1cmUgYSBncmFtbWFyIGluIHdoaWNoIHRoaXMgY2FuIGhhcHBlbiBpcyB1c2VmdWwgZm9yIGFueXRoaW5nIChwcm9kdWN0aXZlKVxuICAgICAgICByZXR1cm4gZmlyc3QocHJvZC5yZWZlcmVuY2VkUnVsZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JUZXJtaW5hbChwcm9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXF1ZW5jZVByb2QocHJvZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rm9yU2VxdWVuY2UocHJvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnJhbmNoaW5nUHJvZChwcm9kKSkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JCcmFuY2hpbmcocHJvZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdEZvclNlcXVlbmNlKHByb2QpIHtcbiAgICB2YXIgZmlyc3RTZXQgPSBbXTtcbiAgICB2YXIgc2VxID0gcHJvZC5kZWZpbml0aW9uO1xuICAgIHZhciBuZXh0U3ViUHJvZElkeCA9IDA7XG4gICAgdmFyIGhhc0lubmVyUHJvZHNSZW1haW5pbmcgPSBzZXEubGVuZ3RoID4gbmV4dFN1YlByb2RJZHg7XG4gICAgdmFyIGN1cnJTdWJQcm9kO1xuICAgIC8vIHNvIHdlIGVudGVyIHRoZSBsb29wIGF0IGxlYXN0IG9uY2UgKGlmIHRoZSBkZWZpbml0aW9uIGlzIG5vdCBlbXB0eVxuICAgIHZhciBpc0xhc3RJbm5lclByb2RPcHRpb25hbCA9IHRydWU7XG4gICAgLy8gc2NhbiBhIHNlcXVlbmNlIHVudGlsIGl0J3MgZW5kIG9yIHVudGlsIHdlIGhhdmUgZm91bmQgYSBOT05FIG9wdGlvbmFsIHByb2R1Y3Rpb24gaW4gaXRcbiAgICB3aGlsZSAoaGFzSW5uZXJQcm9kc1JlbWFpbmluZyAmJiBpc0xhc3RJbm5lclByb2RPcHRpb25hbCkge1xuICAgICAgICBjdXJyU3ViUHJvZCA9IHNlcVtuZXh0U3ViUHJvZElkeF07XG4gICAgICAgIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsID0gaXNPcHRpb25hbFByb2QoY3VyclN1YlByb2QpO1xuICAgICAgICBmaXJzdFNldCA9IGZpcnN0U2V0LmNvbmNhdChmaXJzdChjdXJyU3ViUHJvZCkpO1xuICAgICAgICBuZXh0U3ViUHJvZElkeCA9IG5leHRTdWJQcm9kSWR4ICsgMTtcbiAgICAgICAgaGFzSW5uZXJQcm9kc1JlbWFpbmluZyA9IHNlcS5sZW5ndGggPiBuZXh0U3ViUHJvZElkeDtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXEoZmlyc3RTZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yQnJhbmNoaW5nKHByb2QpIHtcbiAgICB2YXIgYWxsQWx0ZXJuYXRpdmVzRmlyc3RzID0gbWFwKHByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGlubmVyUHJvZCkge1xuICAgICAgICByZXR1cm4gZmlyc3QoaW5uZXJQcm9kKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKGFsbEFsdGVybmF0aXZlc0ZpcnN0cykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yVGVybWluYWwodGVybWluYWwpIHtcbiAgICByZXR1cm4gW3Rlcm1pbmFsLnRlcm1pbmFsVHlwZV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js ***!
  \*********************************************************************/
/*! exports provided: ResyncFollowsWalker, computeAllProdsFollows, buildBetweenProdsFollowPrefix, buildInProdFollowPrefix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResyncFollowsWalker\", function() { return ResyncFollowsWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeAllProdsFollows\", function() { return computeAllProdsFollows; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildBetweenProdsFollowPrefix\", function() { return buildBetweenProdsFollowPrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildInProdFollowPrefix\", function() { return buildInProdFollowPrefix; });\n/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\");\n/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./first */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ \"./node_modules/chevrotain/lib_esm/src/parse/constants.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nvar ResyncFollowsWalker = /** @class */ (function (_super) {\n    __extends(ResyncFollowsWalker, _super);\n    function ResyncFollowsWalker(topProd) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.follows = {};\n        return _this;\n    }\n    ResyncFollowsWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.follows;\n    };\n    ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    };\n    ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        var fullRest = currRest.concat(prevRest);\n        var restProd = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"Flat\"]({ definition: fullRest });\n        var t_in_topProd_follows = Object(_first__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    };\n    return ResyncFollowsWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_0__[\"RestWalker\"]));\n\nfunction computeAllProdsFollows(topProductions) {\n    var reSyncFollows = {};\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(topProductions, function (topProd) {\n        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"assign\"])(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + _constants__WEBPACK_IMPORTED_MODULE_3__[\"IN\"];\n}\nfunction buildInProdFollowPrefix(terminal) {\n    var terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + _constants__WEBPACK_IMPORTED_MODULE_3__[\"IN\"];\n}\n//# sourceMappingURL=follow.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2ZvbGxvdy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZm9sbG93LmpzP2NjNjgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdFwiO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi9maXJzdFwiO1xuaW1wb3J0IHsgYXNzaWduLCBmb3JFYWNoIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBJTiB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IEZsYXQgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG4vLyBUaGlzIFJlc3luY0ZvbGxvd3NXYWxrZXIgY29tcHV0ZXMgYWxsIG9mIHRoZSBmb2xsb3dzIHJlcXVpcmVkIGZvciBSRVNZTkNcbi8vIChza2lwcGluZyByZWZlcmVuY2UgcHJvZHVjdGlvbikuXG52YXIgUmVzeW5jRm9sbG93c1dhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzeW5jRm9sbG93c1dhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9wUHJvZCA9IHRvcFByb2Q7XG4gICAgICAgIF90aGlzLmZvbGxvd3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXN5bmNGb2xsb3dzV2Fsa2VyLnByb3RvdHlwZS5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpO1xuICAgICAgICByZXR1cm4gdGhpcy5mb2xsb3dzO1xuICAgIH07XG4gICAgUmVzeW5jRm9sbG93c1dhbGtlci5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsID0gZnVuY3Rpb24gKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZyEganVzdCBsaWtlIGluIHRoZSBwdWJsaWMgc2VjdG9yIGFmdGVyIDEzOjAwXG4gICAgfTtcbiAgICBSZXN5bmNGb2xsb3dzV2Fsa2VyLnByb3RvdHlwZS53YWxrUHJvZFJlZiA9IGZ1bmN0aW9uIChyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgdmFyIGZvbGxvd05hbWUgPSBidWlsZEJldHdlZW5Qcm9kc0ZvbGxvd1ByZWZpeChyZWZQcm9kLnJlZmVyZW5jZWRSdWxlLCByZWZQcm9kLmlkeCkgK1xuICAgICAgICAgICAgdGhpcy50b3BQcm9kLm5hbWU7XG4gICAgICAgIHZhciBmdWxsUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHZhciByZXN0UHJvZCA9IG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogZnVsbFJlc3QgfSk7XG4gICAgICAgIHZhciB0X2luX3RvcFByb2RfZm9sbG93cyA9IGZpcnN0KHJlc3RQcm9kKTtcbiAgICAgICAgdGhpcy5mb2xsb3dzW2ZvbGxvd05hbWVdID0gdF9pbl90b3BQcm9kX2ZvbGxvd3M7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzeW5jRm9sbG93c1dhbGtlcjtcbn0oUmVzdFdhbGtlcikpO1xuZXhwb3J0IHsgUmVzeW5jRm9sbG93c1dhbGtlciB9O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModG9wUHJvZHVjdGlvbnMpIHtcbiAgICB2YXIgcmVTeW5jRm9sbG93cyA9IHt9O1xuICAgIGZvckVhY2godG9wUHJvZHVjdGlvbnMsIGZ1bmN0aW9uICh0b3BQcm9kKSB7XG4gICAgICAgIHZhciBjdXJyUmVmc0ZvbGxvdyA9IG5ldyBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICBhc3NpZ24ocmVTeW5jRm9sbG93cywgY3VyclJlZnNGb2xsb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiByZVN5bmNGb2xsb3dzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KGlubmVyLCBvY2N1cmVuY2VJblBhcmVudCkge1xuICAgIHJldHVybiBpbm5lci5uYW1lICsgb2NjdXJlbmNlSW5QYXJlbnQgKyBJTjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEluUHJvZEZvbGxvd1ByZWZpeCh0ZXJtaW5hbCkge1xuICAgIHZhciB0ZXJtaW5hbE5hbWUgPSB0ZXJtaW5hbC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICByZXR1cm4gdGVybWluYWxOYW1lICsgdGVybWluYWwuaWR4ICsgSU47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2xsb3cuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js ***!
  \************************************************************************/
/*! exports provided: isSequenceProd, isOptionalProd, isBranchingProd, getProductionDslName, DslMethodsCollectorVisitor, collectMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSequenceProd\", function() { return isSequenceProd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isOptionalProd\", function() { return isOptionalProd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBranchingProd\", function() { return isBranchingProd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getProductionDslName\", function() { return getProductionDslName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DslMethodsCollectorVisitor\", function() { return DslMethodsCollectorVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"collectMethods\", function() { return collectMethods; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast_visitor_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nfunction isSequenceProd(prod) {\n    return (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Flat\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Repetition\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatory\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatoryWithSeparator\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionWithSeparator\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Rule\"]);\n}\nfunction isOptionalProd(prod, alreadyVisited) {\n    if (alreadyVisited === void 0) { alreadyVisited = []; }\n    var isDirectlyOptional = prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Repetition\"] ||\n        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionWithSeparator\"];\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Alternation\"]) {\n        // for OR its enough for just one of the alternatives to be optional\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"some\"])(prod.definition, function (subProd) {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"] && Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"AbstractProduction\"]) {\n        if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"]) {\n            alreadyVisited.push(prod);\n        }\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(prod.definition, function (subProd) {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nfunction isBranchingProd(prod) {\n    return prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Alternation\"];\n}\nfunction getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"]) {\n        return \"SUBRULE\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"]) {\n        return \"OPTION\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Alternation\"]) {\n        return \"OR\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatory\"]) {\n        return \"AT_LEAST_ONE\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatoryWithSeparator\"]) {\n        return \"AT_LEAST_ONE_SEP\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionWithSeparator\"]) {\n        return \"MANY_SEP\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Repetition\"]) {\n        return \"MANY\";\n    }\n    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]) {\n        return \"CONSUME\";\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nvar DslMethodsCollectorVisitor = /** @class */ (function (_super) {\n    __extends(DslMethodsCollectorVisitor, _super);\n    function DslMethodsCollectorVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // A minus is never valid in an identifier name\n        _this.separator = \"-\";\n        _this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n        return _this;\n    }\n    DslMethodsCollectorVisitor.prototype.reset = function () {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n        };\n    };\n    DslMethodsCollectorVisitor.prototype.visitTerminal = function (terminal) {\n        var key = terminal.terminalType.name + this.separator + \"Terminal\";\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(this.dslMethods, key)) {\n            this.dslMethods[key] = [];\n        }\n        this.dslMethods[key].push(terminal);\n    };\n    DslMethodsCollectorVisitor.prototype.visitNonTerminal = function (subrule) {\n        var key = subrule.nonTerminalName + this.separator + \"Terminal\";\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(this.dslMethods, key)) {\n            this.dslMethods[key] = [];\n        }\n        this.dslMethods[key].push(subrule);\n    };\n    DslMethodsCollectorVisitor.prototype.visitOption = function (option) {\n        this.dslMethods.option.push(option);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    };\n    DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {\n        this.dslMethods.repetition.push(many);\n    };\n    DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {\n        this.dslMethods.alternation.push(or);\n    };\n    return DslMethodsCollectorVisitor;\n}(_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__[\"GAstVisitor\"]));\n\nvar collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    var dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=gast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0LmpzP2ExNWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBjb250YWlucywgZXZlcnksIGhhcywgc29tZSB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RQcm9kdWN0aW9uLCBBbHRlcm5hdGlvbiwgRmxhdCwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCB9IGZyb20gXCIuL2dhc3RfcHVibGljXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL2dhc3RfdmlzaXRvcl9wdWJsaWNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1NlcXVlbmNlUHJvZChwcm9kKSB7XG4gICAgcmV0dXJuIChwcm9kIGluc3RhbmNlb2YgRmxhdCB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgT3B0aW9uIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSdWxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09wdGlvbmFsUHJvZChwcm9kLCBhbHJlYWR5VmlzaXRlZCkge1xuICAgIGlmIChhbHJlYWR5VmlzaXRlZCA9PT0gdm9pZCAwKSB7IGFscmVhZHlWaXNpdGVkID0gW107IH1cbiAgICB2YXIgaXNEaXJlY3RseU9wdGlvbmFsID0gcHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG4gICAgaWYgKGlzRGlyZWN0bHlPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbm90ZSB0aGF0IHRoaXMgY2FuIGNhdXNlIGluZmluaXRlIGxvb3AgaWYgb25lIG9wdGlvbmFsIGVtcHR5IFRPUCBwcm9kdWN0aW9uIGhhcyBhIGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggYW5vdGhlclxuICAgIC8vIGVtcHR5IG9wdGlvbmFsIHRvcCBydWxlXG4gICAgLy8gbWF5IGJlIGluZGlyZWN0bHkgb3B0aW9uYWwgKChBP0I/Qz8pIHwgKEQ/RT9GPykpXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAvLyBmb3IgT1IgaXRzIGVub3VnaCBmb3IganVzdCBvbmUgb2YgdGhlIGFsdGVybmF0aXZlcyB0byBiZSBvcHRpb25hbFxuICAgICAgICByZXR1cm4gc29tZShwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChzdWJQcm9kKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPcHRpb25hbFByb2Qoc3ViUHJvZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsICYmIGNvbnRhaW5zKGFscmVhZHlWaXNpdGVkLCBwcm9kKSkge1xuICAgICAgICAvLyBhdm9pZGluZyBzdGFjayBvdmVyZmxvdyBkdWUgdG8gaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFic3RyYWN0UHJvZHVjdGlvbikge1xuICAgICAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICBhbHJlYWR5VmlzaXRlZC5wdXNoKHByb2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVyeShwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChzdWJQcm9kKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPcHRpb25hbFByb2Qoc3ViUHJvZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCcmFuY2hpbmdQcm9kKHByb2QpIHtcbiAgICByZXR1cm4gcHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2R1Y3Rpb25Ec2xOYW1lKHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiU1VCUlVMRVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9QVElPTlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiT1JcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJBVF9MRUFTVF9PTkVfU0VQXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gXCJDT05TVU1FXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbnZhciBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBBIG1pbnVzIGlzIG5ldmVyIHZhbGlkIGluIGFuIGlkZW50aWZpZXIgbmFtZVxuICAgICAgICBfdGhpcy5zZXBhcmF0b3IgPSBcIi1cIjtcbiAgICAgICAgX3RoaXMuZHNsTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbjogW10sXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnk6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMgPSB7XG4gICAgICAgICAgICBvcHRpb246IFtdLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uV2l0aFNlcGFyYXRvcjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5OiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwpIHtcbiAgICAgICAgdmFyIGtleSA9IHRlcm1pbmFsLnRlcm1pbmFsVHlwZS5uYW1lICsgdGhpcy5zZXBhcmF0b3IgKyBcIlRlcm1pbmFsXCI7XG4gICAgICAgIGlmICghaGFzKHRoaXMuZHNsTWV0aG9kcywga2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kc2xNZXRob2RzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRzbE1ldGhvZHNba2V5XS5wdXNoKHRlcm1pbmFsKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsID0gZnVuY3Rpb24gKHN1YnJ1bGUpIHtcbiAgICAgICAgdmFyIGtleSA9IHN1YnJ1bGUubm9uVGVybWluYWxOYW1lICsgdGhpcy5zZXBhcmF0b3IgKyBcIlRlcm1pbmFsXCI7XG4gICAgICAgIGlmICghaGFzKHRoaXMuZHNsTWV0aG9kcywga2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kc2xNZXRob2RzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRzbE1ldGhvZHNba2V5XS5wdXNoKHN1YnJ1bGUpO1xuICAgIH07XG4gICAgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IucHJvdG90eXBlLnZpc2l0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMub3B0aW9uLnB1c2gob3B0aW9uKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG1hbnlTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLnB1c2gobWFueVNlcCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5ID0gZnVuY3Rpb24gKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnkucHVzaChhdExlYXN0T25lKTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfTtcbiAgICBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG1hbnkpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb24ucHVzaChtYW55KTtcbiAgICB9O1xuICAgIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uID0gZnVuY3Rpb24gKG9yKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5hbHRlcm5hdGlvbi5wdXNoKG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcjtcbn0oR0FzdFZpc2l0b3IpKTtcbmV4cG9ydCB7IERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yIH07XG52YXIgY29sbGVjdG9yVmlzaXRvciA9IG5ldyBEc2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcigpO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RNZXRob2RzKHJ1bGUpIHtcbiAgICBjb2xsZWN0b3JWaXNpdG9yLnJlc2V0KCk7XG4gICAgcnVsZS5hY2NlcHQoY29sbGVjdG9yVmlzaXRvcik7XG4gICAgdmFyIGRzbE1ldGhvZHMgPSBjb2xsZWN0b3JWaXNpdG9yLmRzbE1ldGhvZHM7XG4gICAgLy8gYXZvaWQgdW5jbGVhbmVkIHJlZmVyZW5jZXNcbiAgICBjb2xsZWN0b3JWaXNpdG9yLnJlc2V0KCk7XG4gICAgcmV0dXJuIGRzbE1ldGhvZHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXN0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js ***!
  \*******************************************************************************/
/*! exports provided: AbstractProduction, NonTerminal, Rule, Flat, Option, RepetitionMandatory, RepetitionMandatoryWithSeparator, Repetition, RepetitionWithSeparator, Alternation, Terminal, serializeGrammar, serializeProduction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractProduction\", function() { return AbstractProduction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NonTerminal\", function() { return NonTerminal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rule\", function() { return Rule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Flat\", function() { return Flat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Option\", function() { return Option; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepetitionMandatory\", function() { return RepetitionMandatory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepetitionMandatoryWithSeparator\", function() { return RepetitionMandatoryWithSeparator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Repetition\", function() { return Repetition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RepetitionWithSeparator\", function() { return RepetitionWithSeparator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Alternation\", function() { return Alternation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Terminal\", function() { return Terminal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializeGrammar\", function() { return serializeGrammar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"serializeProduction\", function() { return serializeProduction; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar AbstractProduction = /** @class */ (function () {\n    function AbstractProduction(definition) {\n        this.definition = definition;\n    }\n    AbstractProduction.prototype.accept = function (visitor) {\n        visitor.visit(this);\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(this.definition, function (prod) {\n            prod.accept(visitor);\n        });\n    };\n    return AbstractProduction;\n}());\n\nvar NonTerminal = /** @class */ (function (_super) {\n    __extends(NonTerminal, _super);\n    function NonTerminal(options) {\n        var _this = _super.call(this, []) || this;\n        _this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    Object.defineProperty(NonTerminal.prototype, \"definition\", {\n        get: function () {\n            if (this.referencedRule !== undefined) {\n                return this.referencedRule.definition;\n            }\n            return [];\n        },\n        set: function (definition) {\n            // immutable\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NonTerminal.prototype.accept = function (visitor) {\n        visitor.visit(this);\n        // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    };\n    return NonTerminal;\n}(AbstractProduction));\n\nvar Rule = /** @class */ (function (_super) {\n    __extends(Rule, _super);\n    function Rule(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.orgText = \"\";\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Rule;\n}(AbstractProduction));\n\n// TODO: is this only used in an Alternation?\n//       Perhaps `Flat` should be renamed to `Alternative`?\nvar Flat = /** @class */ (function (_super) {\n    __extends(Flat, _super);\n    // A named Flat production is used to indicate a Nested Rule in an alternation\n    function Flat(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.ignoreAmbiguities = false;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Flat;\n}(AbstractProduction));\n\nvar Option = /** @class */ (function (_super) {\n    __extends(Option, _super);\n    function Option(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Option;\n}(AbstractProduction));\n\nvar RepetitionMandatory = /** @class */ (function (_super) {\n    __extends(RepetitionMandatory, _super);\n    function RepetitionMandatory(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return RepetitionMandatory;\n}(AbstractProduction));\n\nvar RepetitionMandatoryWithSeparator = /** @class */ (function (_super) {\n    __extends(RepetitionMandatoryWithSeparator, _super);\n    function RepetitionMandatoryWithSeparator(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return RepetitionMandatoryWithSeparator;\n}(AbstractProduction));\n\nvar Repetition = /** @class */ (function (_super) {\n    __extends(Repetition, _super);\n    function Repetition(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Repetition;\n}(AbstractProduction));\n\nvar RepetitionWithSeparator = /** @class */ (function (_super) {\n    __extends(RepetitionWithSeparator, _super);\n    function RepetitionWithSeparator(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return RepetitionWithSeparator;\n}(AbstractProduction));\n\nvar Alternation = /** @class */ (function (_super) {\n    __extends(Alternation, _super);\n    function Alternation(options) {\n        var _this = _super.call(this, options.definition) || this;\n        _this.idx = 1;\n        _this.ignoreAmbiguities = false;\n        _this.hasPredicates = false;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(_this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n        return _this;\n    }\n    return Alternation;\n}(AbstractProduction));\n\nvar Terminal = /** @class */ (function () {\n    function Terminal(options) {\n        this.idx = 1;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"assign\"])(this, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"pick\"])(options, function (v) { return v !== undefined; }));\n    }\n    Terminal.prototype.accept = function (visitor) {\n        visitor.visit(this);\n    };\n    return Terminal;\n}());\n\nfunction serializeGrammar(topRules) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(topRules, serializeProduction);\n}\nfunction serializeProduction(node) {\n    function convertDefinition(definition) {\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n        return {\n            type: \"NonTerminal\",\n            name: node.nonTerminalName,\n            idx: node.idx\n        };\n    }\n    else if (node instanceof Flat) {\n        return {\n            type: \"Flat\",\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: \"Option\",\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: \"RepetitionMandatory\",\n            name: node.name,\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: \"RepetitionMandatoryWithSeparator\",\n            name: node.name,\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: \"RepetitionWithSeparator\",\n            name: node.name,\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: \"Repetition\",\n            name: node.name,\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: \"Alternation\",\n            name: node.name,\n            idx: node.idx,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else if (node instanceof Terminal) {\n        var serializedTerminal = {\n            type: \"Terminal\",\n            name: node.terminalType.name,\n            label: Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_1__[\"tokenLabel\"])(node.terminalType),\n            idx: node.idx\n        };\n        var pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isRegExp\"])(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: \"Rule\",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition)\n        };\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\n//# sourceMappingURL=gast_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9wdWJsaWMuanM/ZmIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IGFzc2lnbiwgZm9yRWFjaCwgaXNSZWdFeHAsIG1hcCwgcGljayB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgdG9rZW5MYWJlbCB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWNcIjtcbnZhciBBYnN0cmFjdFByb2R1Y3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RQcm9kdWN0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgQWJzdHJhY3RQcm9kdWN0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgICAgICBmb3JFYWNoKHRoaXMuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKHByb2QpIHtcbiAgICAgICAgICAgIHByb2QuYWNjZXB0KHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdFByb2R1Y3Rpb247XG59KCkpO1xuZXhwb3J0IHsgQWJzdHJhY3RQcm9kdWN0aW9uIH07XG52YXIgTm9uVGVybWluYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vblRlcm1pbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vblRlcm1pbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgW10pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vblRlcm1pbmFsLnByb3RvdHlwZSwgXCJkZWZpbml0aW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VkUnVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlZFJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgLy8gaW1tdXRhYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE5vblRlcm1pbmFsLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgICAgICAvLyBkb24ndCB2aXNpdCBjaGlsZHJlbiBvZiBhIHJlZmVyZW5jZSwgd2Ugd2lsbCBnZXQgY3ljbGljIGluZmluaXRlIGxvb3BzIGlmIHdlIGRvIHNvXG4gICAgfTtcbiAgICByZXR1cm4gTm9uVGVybWluYWw7XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgTm9uVGVybWluYWwgfTtcbnZhciBSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSdWxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJ1bGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9yZ1RleHQgPSBcIlwiO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSdWxlO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IFJ1bGUgfTtcbi8vIFRPRE86IGlzIHRoaXMgb25seSB1c2VkIGluIGFuIEFsdGVybmF0aW9uP1xuLy8gICAgICAgUGVyaGFwcyBgRmxhdGAgc2hvdWxkIGJlIHJlbmFtZWQgdG8gYEFsdGVybmF0aXZlYD9cbnZhciBGbGF0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbGF0LCBfc3VwZXIpO1xuICAgIC8vIEEgbmFtZWQgRmxhdCBwcm9kdWN0aW9uIGlzIHVzZWQgdG8gaW5kaWNhdGUgYSBOZXN0ZWQgUnVsZSBpbiBhbiBhbHRlcm5hdGlvblxuICAgIGZ1bmN0aW9uIEZsYXQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLmRlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlnbm9yZUFtYmlndWl0aWVzID0gZmFsc2U7XG4gICAgICAgIGFzc2lnbihfdGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZsYXQ7XG59KEFic3RyYWN0UHJvZHVjdGlvbikpO1xuZXhwb3J0IHsgRmxhdCB9O1xudmFyIE9wdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3B0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9wdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMuZGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gT3B0aW9uO1xufShBYnN0cmFjdFByb2R1Y3Rpb24pKTtcbmV4cG9ydCB7IE9wdGlvbiB9O1xudmFyIFJlcGV0aXRpb25NYW5kYXRvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGV0aXRpb25NYW5kYXRvcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZXRpdGlvbk1hbmRhdG9yeShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMuZGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVwZXRpdGlvbk1hbmRhdG9yeTtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBSZXBldGl0aW9uTWFuZGF0b3J5IH07XG52YXIgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcjtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB9O1xudmFyIFJlcGV0aXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGV0aXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVwZXRpdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMuZGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKF90aGlzLCBwaWNrKG9wdGlvbnMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVwZXRpdGlvbjtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBSZXBldGl0aW9uIH07XG52YXIgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5kZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcjtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciB9O1xudmFyIEFsdGVybmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbHRlcm5hdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbHRlcm5hdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMuZGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaWR4ID0gMTtcbiAgICAgICAgX3RoaXMuaWdub3JlQW1iaWd1aXRpZXMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaGFzUHJlZGljYXRlcyA9IGZhbHNlO1xuICAgICAgICBhc3NpZ24oX3RoaXMsIHBpY2sob3B0aW9ucywgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBbHRlcm5hdGlvbjtcbn0oQWJzdHJhY3RQcm9kdWN0aW9uKSk7XG5leHBvcnQgeyBBbHRlcm5hdGlvbiB9O1xudmFyIFRlcm1pbmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlcm1pbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGljayhvcHRpb25zLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9KSk7XG4gICAgfVxuICAgIFRlcm1pbmFsLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlcm1pbmFsO1xufSgpKTtcbmV4cG9ydCB7IFRlcm1pbmFsIH07XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplR3JhbW1hcih0b3BSdWxlcykge1xuICAgIHJldHVybiBtYXAodG9wUnVsZXMsIHNlcmlhbGl6ZVByb2R1Y3Rpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVByb2R1Y3Rpb24obm9kZSkge1xuICAgIGZ1bmN0aW9uIGNvbnZlcnREZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG1hcChkZWZpbml0aW9uLCBzZXJpYWxpemVQcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk5vblRlcm1pbmFsXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5vblRlcm1pbmFsTmFtZSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEZsYXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRmxhdFwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk9wdGlvblwiLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgc2VwYXJhdG9yOiAoc2VyaWFsaXplUHJvZHVjdGlvbihuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IG5vZGUuc2VwYXJhdG9yIH0pKSksXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uV2l0aFNlcGFyYXRvclwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIHNlcGFyYXRvcjogKHNlcmlhbGl6ZVByb2R1Y3Rpb24obmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiBub2RlLnNlcGFyYXRvciB9KSkpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQWx0ZXJuYXRpb25cIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICB2YXIgc2VyaWFsaXplZFRlcm1pbmFsID0ge1xuICAgICAgICAgICAgdHlwZTogXCJUZXJtaW5hbFwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS50ZXJtaW5hbFR5cGUubmFtZSxcbiAgICAgICAgICAgIGxhYmVsOiB0b2tlbkxhYmVsKG5vZGUudGVybWluYWxUeXBlKSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHhcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBub2RlLnRlcm1pbmFsVHlwZS5QQVRURVJOO1xuICAgICAgICBpZiAobm9kZS50ZXJtaW5hbFR5cGUuUEFUVEVSTikge1xuICAgICAgICAgICAgc2VyaWFsaXplZFRlcm1pbmFsLnBhdHRlcm4gPSBpc1JlZ0V4cChwYXR0ZXJuKVxuICAgICAgICAgICAgICAgID8gcGF0dGVybi5zb3VyY2VcbiAgICAgICAgICAgICAgICA6IHBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRUZXJtaW5hbDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgb3JnVGV4dDogbm9kZS5vcmdUZXh0LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXN0X3B1YmxpYy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js ***!
  \****************************************************************************************/
/*! exports provided: resolveGrammar, validateGrammar, assignOccurrenceIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolveGrammar\", function() { return resolveGrammar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateGrammar\", function() { return validateGrammar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assignOccurrenceIndices\", function() { return assignOccurrenceIndices; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _resolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../resolver */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js\");\n/* harmony import */ var _checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../checks */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\");\n/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors_public */ \"./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gast */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\n\n\nfunction resolveGrammar(options) {\n    options = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"])(options, {\n        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__[\"defaultGrammarResolverErrorProvider\"]\n    });\n    var topRulesTable = {};\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(options.rules, function (rule) {\n        topRulesTable[rule.name] = rule;\n    });\n    return Object(_resolver__WEBPACK_IMPORTED_MODULE_1__[\"resolveGrammar\"])(topRulesTable, options.errMsgProvider);\n}\nfunction validateGrammar(options) {\n    options = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"defaults\"])(options, {\n        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__[\"defaultGrammarValidatorErrorProvider\"],\n        ignoredIssues: {}\n    });\n    return Object(_checks__WEBPACK_IMPORTED_MODULE_2__[\"validateGrammar\"])(options.rules, options.maxLookahead, options.tokenTypes, options.ignoredIssues, options.errMsgProvider, options.grammarName);\n}\nfunction assignOccurrenceIndices(options) {\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(options.rules, function (currRule) {\n        var methodsCollector = new _gast__WEBPACK_IMPORTED_MODULE_4__[\"DslMethodsCollectorVisitor\"]();\n        currRule.accept(methodsCollector);\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(methodsCollector.dslMethods, function (methods) {\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(methods, function (currMethod, arrIdx) {\n                currMethod.idx = arrIdx + 1;\n            });\n        });\n    });\n}\n//# sourceMappingURL=gast_resolver_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9yZXNvbHZlcl9wdWJsaWMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9yZXNvbHZlcl9wdWJsaWMuanM/ZDk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZhdWx0cywgZm9yRWFjaCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgcmVzb2x2ZUdyYW1tYXIgYXMgb3JnUmVzb2x2ZUdyYW1tYXIgfSBmcm9tIFwiLi4vcmVzb2x2ZXJcIjtcbmltcG9ydCB7IHZhbGlkYXRlR3JhbW1hciBhcyBvcmdWYWxpZGF0ZUdyYW1tYXIgfSBmcm9tIFwiLi4vY2hlY2tzXCI7XG5pbXBvcnQgeyBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlciwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4uLy4uL2Vycm9yc19wdWJsaWNcIjtcbmltcG9ydCB7IERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yIH0gZnJvbSBcIi4vZ2FzdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVHcmFtbWFyKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBlcnJNc2dQcm92aWRlcjogZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXJcbiAgICB9KTtcbiAgICB2YXIgdG9wUnVsZXNUYWJsZSA9IHt9O1xuICAgIGZvckVhY2gob3B0aW9ucy5ydWxlcywgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdG9wUnVsZXNUYWJsZVtydWxlLm5hbWVdID0gcnVsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3JnUmVzb2x2ZUdyYW1tYXIodG9wUnVsZXNUYWJsZSwgb3B0aW9ucy5lcnJNc2dQcm92aWRlcik7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVHcmFtbWFyKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBlcnJNc2dQcm92aWRlcjogZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLFxuICAgICAgICBpZ25vcmVkSXNzdWVzOiB7fVxuICAgIH0pO1xuICAgIHJldHVybiBvcmdWYWxpZGF0ZUdyYW1tYXIob3B0aW9ucy5ydWxlcywgb3B0aW9ucy5tYXhMb29rYWhlYWQsIG9wdGlvbnMudG9rZW5UeXBlcywgb3B0aW9ucy5pZ25vcmVkSXNzdWVzLCBvcHRpb25zLmVyck1zZ1Byb3ZpZGVyLCBvcHRpb25zLmdyYW1tYXJOYW1lKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25PY2N1cnJlbmNlSW5kaWNlcyhvcHRpb25zKSB7XG4gICAgZm9yRWFjaChvcHRpb25zLnJ1bGVzLCBmdW5jdGlvbiAoY3VyclJ1bGUpIHtcbiAgICAgICAgdmFyIG1ldGhvZHNDb2xsZWN0b3IgPSBuZXcgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoKTtcbiAgICAgICAgY3VyclJ1bGUuYWNjZXB0KG1ldGhvZHNDb2xsZWN0b3IpO1xuICAgICAgICBmb3JFYWNoKG1ldGhvZHNDb2xsZWN0b3IuZHNsTWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgICAgICAgICAgIGZvckVhY2gobWV0aG9kcywgZnVuY3Rpb24gKGN1cnJNZXRob2QsIGFycklkeCkge1xuICAgICAgICAgICAgICAgIGN1cnJNZXRob2QuaWR4ID0gYXJySWR4ICsgMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfcmVzb2x2ZXJfcHVibGljLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js ***!
  \***************************************************************************************/
/*! exports provided: GAstVisitor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GAstVisitor\", function() { return GAstVisitor; });\n/* harmony import */ var _gast_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\nvar GAstVisitor = /** @class */ (function () {\n    function GAstVisitor() {\n    }\n    GAstVisitor.prototype.visit = function (node) {\n        var nodeAny = node;\n        switch (nodeAny.constructor) {\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"NonTerminal\"]:\n                return this.visitNonTerminal(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"Flat\"]:\n                return this.visitFlat(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"Option\"]:\n                return this.visitOption(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"RepetitionMandatory\"]:\n                return this.visitRepetitionMandatory(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"RepetitionMandatoryWithSeparator\"]:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"RepetitionWithSeparator\"]:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"Repetition\"]:\n                return this.visitRepetition(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"Alternation\"]:\n                return this.visitAlternation(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"Terminal\"]:\n                return this.visitTerminal(nodeAny);\n            case _gast_public__WEBPACK_IMPORTED_MODULE_0__[\"Rule\"]:\n                return this.visitRule(nodeAny);\n            /* istanbul ignore next */\n            default:\n                throw Error(\"non exhaustive match\");\n        }\n    };\n    GAstVisitor.prototype.visitNonTerminal = function (node) { };\n    GAstVisitor.prototype.visitFlat = function (node) { };\n    GAstVisitor.prototype.visitOption = function (node) { };\n    GAstVisitor.prototype.visitRepetition = function (node) { };\n    GAstVisitor.prototype.visitRepetitionMandatory = function (node) { };\n    GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) { };\n    GAstVisitor.prototype.visitRepetitionWithSeparator = function (node) { };\n    GAstVisitor.prototype.visitAlternation = function (node) { };\n    GAstVisitor.prototype.visitTerminal = function (node) { };\n    GAstVisitor.prototype.visitRule = function (node) { };\n    return GAstVisitor;\n}());\n\n//# sourceMappingURL=gast_visitor_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF92aXNpdG9yX3B1YmxpYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljLmpzPzA1OTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwgfSBmcm9tIFwiLi9nYXN0X3B1YmxpY1wiO1xudmFyIEdBc3RWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdBc3RWaXNpdG9yKCkge1xuICAgIH1cbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbm9kZUFueSA9IG5vZGU7XG4gICAgICAgIHN3aXRjaCAobm9kZUFueS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBOb25UZXJtaW5hbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdE5vblRlcm1pbmFsKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBGbGF0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0RmxhdChub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgT3B0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0T3B0aW9uKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSZXBldGl0aW9uTWFuZGF0b3J5OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeShub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb24obm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIEFsdGVybmF0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWx0ZXJuYXRpb24obm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0VGVybWluYWwobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJ1bGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSdWxlKG5vZGVBbnkpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWwgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZsYXQgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE9wdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeSA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHsgfTtcbiAgICBHQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7IH07XG4gICAgR0FzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVybWluYWwgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIEdBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJ1bGUgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIHJldHVybiBHQXN0VmlzaXRvcjtcbn0oKSk7XG5leHBvcnQgeyBHQXN0VmlzaXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF92aXNpdG9yX3B1YmxpYy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js":
/*!**************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js ***!
  \**************************************************************************/
/*! exports provided: AbstractNextPossibleTokensWalker, NextAfterTokenWalker, AbstractNextTerminalAfterProductionWalker, NextTerminalAfterManyWalker, NextTerminalAfterManySepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterAtLeastOneSepWalker, possiblePathsFrom, nextPossibleTokensAfter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractNextPossibleTokensWalker\", function() { return AbstractNextPossibleTokensWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NextAfterTokenWalker\", function() { return NextAfterTokenWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractNextTerminalAfterProductionWalker\", function() { return AbstractNextTerminalAfterProductionWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NextTerminalAfterManyWalker\", function() { return NextTerminalAfterManyWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NextTerminalAfterManySepWalker\", function() { return NextTerminalAfterManySepWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NextTerminalAfterAtLeastOneWalker\", function() { return NextTerminalAfterAtLeastOneWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NextTerminalAfterAtLeastOneSepWalker\", function() { return NextTerminalAfterAtLeastOneSepWalker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"possiblePathsFrom\", function() { return possiblePathsFrom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nextPossibleTokensAfter\", function() { return nextPossibleTokensAfter; });\n/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./first */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/first.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_0__[\"RestWalker\"]));\n\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Flat\"]({ definition: fullRest });\n            this.possibleTokTypes = Object(_first__WEBPACK_IMPORTED_MODULE_2__[\"first\"])(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_0__[\"RestWalker\"]));\n\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(currRest.concat(prevRest));\n            this.result.isEndOfRule =\n                firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]) {\n                this.result.token =\n                    firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\n\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Flat\"]) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"NonTerminal\"]) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Option\"]) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"RepetitionMandatory\"]) {\n            var newDef = prod.definition.concat([\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"RepetitionMandatoryWithSeparator\"]) {\n            var newDef = [\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Flat\"]({ definition: prod.definition }),\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                    definition: [\n                        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]({ terminalType: prod.separator })\n                    ].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"RepetitionWithSeparator\"]) {\n            var newDef = prod.definition.concat([\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                    definition: [\n                        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]({ terminalType: prod.separator })\n                    ].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]) {\n            var newDef = prod.definition.concat([\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Alternation\"]) {\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(prod.definition, function (currAlt) {\n                result = getAlternativesForProd(currAlt.definition);\n            });\n            return result;\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(targetDef, i)\n    });\n    return result;\n}\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"last\"])(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef),\n                ruleStack: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"dropRight\"])(currRuleStack),\n                occurrenceStack: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"dropRight\"])(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"NonTerminal\"]) {\n            var newRuleStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Option\"]) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"RepetitionMandatory\"]) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"RepetitionMandatoryWithSeparator\"]) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]({\n                terminalType: prod.separator\n            });\n            var secondIteration = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"RepetitionWithSeparator\"]) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Terminal\"]({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Repetition\"]({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Alternation\"]) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Flat\"]) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"drop\"])(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__[\"Rule\"]) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2ludGVycHJldGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZ3JhbW1hci9pbnRlcnByZXRlci5qcz8yMjFhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgUmVzdFdhbGtlciB9IGZyb20gXCIuL3Jlc3RcIjtcbmltcG9ydCB7IGNsb25lQXJyLCBkcm9wLCBkcm9wUmlnaHQsIGZpcnN0IGFzIF9maXJzdCwgZm9yRWFjaCwgaXNFbXB0eSwgbGFzdCB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi9maXJzdFwiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEZsYXQsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwgfSBmcm9tIFwiLi9nYXN0L2dhc3RfcHVibGljXCI7XG52YXIgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyKHRvcFByb2QsIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9wUHJvZCA9IHRvcFByb2Q7XG4gICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICBfdGhpcy5wb3NzaWJsZVRva1R5cGVzID0gW107XG4gICAgICAgIF90aGlzLm5leHRQcm9kdWN0aW9uTmFtZSA9IFwiXCI7XG4gICAgICAgIF90aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgIF90aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzQXRFbmRPZlBhdGggPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlci5wcm90b3R5cGUuc3RhcnRXYWxraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBhdGgucnVsZVN0YWNrWzBdICE9PSB0aGlzLnRvcFByb2QubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcGF0aCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSB3YWxrZXIncyB0b3AgUnVsZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1tdXRhYmxlIGZvciB0aGUgd2luXG4gICAgICAgIHRoaXMucnVsZVN0YWNrID0gY2xvbmVBcnIodGhpcy5wYXRoLnJ1bGVTdGFjaykucmV2ZXJzZSgpOyAvLyBpbnRlbGlqIGJ1ZyByZXF1aXJlcyBhc3NlcnRpb25cbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlU3RhY2sgPSBjbG9uZUFycih0aGlzLnBhdGgub2NjdXJyZW5jZVN0YWNrKS5yZXZlcnNlKCk7IC8vIGludGVsaWogYnVnIHJlcXVpcmVzIGFzc2VydGlvblxuICAgICAgICAvLyBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhlIGZpcnN0IHByb2R1Y3Rpb24gaXMgdmFsaWQsIHdlIG5vdyBzZWVrIHRoZSAybmQgcHJvZHVjdGlvblxuICAgICAgICB0aGlzLnJ1bGVTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCk7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZVRva1R5cGVzO1xuICAgIH07XG4gICAgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAocHJvZCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKHByZXZSZXN0ID09PSB2b2lkIDApIHsgcHJldlJlc3QgPSBbXTsgfVxuICAgICAgICAvLyBzdG9wIHNjYW5uaW5nIG9uY2Ugd2UgZm91bmQgdGhlIHBhdGhcbiAgICAgICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGsuY2FsbCh0aGlzLCBwcm9kLCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyLnByb3RvdHlwZS53YWxrUHJvZFJlZiA9IGZ1bmN0aW9uIChyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gZm91bmQgdGhlIG5leHQgcHJvZHVjdGlvbiwgbmVlZCB0byBrZWVwIHdhbGtpbmcgaW4gaXRcbiAgICAgICAgaWYgKHJlZlByb2QucmVmZXJlbmNlZFJ1bGUubmFtZSA9PT0gdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgJiZcbiAgICAgICAgICAgIHJlZlByb2QuaWR4ID09PSB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCk7XG4gICAgICAgICAgICB0aGlzLndhbGsocmVmUHJvZC5yZWZlcmVuY2VkUnVsZSwgZnVsbFJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlci5wcm90b3R5cGUudXBkYXRlRXhwZWN0ZWROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBuZWVkIHRvIGNvbnN1bWUgdGhlIFRlcm1pbmFsXG4gICAgICAgIGlmIChpc0VtcHR5KHRoaXMucnVsZVN0YWNrKSkge1xuICAgICAgICAgICAgLy8gbXVzdCByZXNldCBuZXh0UHJvZHVjdGlvblhYWCB0byBhdm9pZCB3YWxraW5nIGRvd24gYW5vdGhlciBUb3AgTGV2ZWwgcHJvZHVjdGlvbiB3aGlsZSB3aGF0IHdlIGFyZVxuICAgICAgICAgICAgLy8gcmVhbGx5IHNlZWtpbmcgaXMgdGhlIGxhc3QgVGVybWluYWwuLi5cbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMuaXNBdEVuZE9mUGF0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSA9IHRoaXMucnVsZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2UgPSB0aGlzLm9jY3VycmVuY2VTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyO1xufShSZXN0V2Fsa2VyKSk7XG5leHBvcnQgeyBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlciB9O1xudmFyIE5leHRBZnRlclRva2VuV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0QWZ0ZXJUb2tlbldhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0QWZ0ZXJUb2tlbldhbGtlcih0b3BQcm9kLCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRvcFByb2QsIHBhdGgpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICBfdGhpcy5uZXh0VGVybWluYWxOYW1lID0gXCJcIjtcbiAgICAgICAgX3RoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgIF90aGlzLm5leHRUZXJtaW5hbE5hbWUgPSBfdGhpcy5wYXRoLmxhc3RUb2submFtZTtcbiAgICAgICAgX3RoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSA9IF90aGlzLnBhdGgubGFzdFRva09jY3VycmVuY2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTmV4dEFmdGVyVG9rZW5XYWxrZXIucHJvdG90eXBlLndhbGtUZXJtaW5hbCA9IGZ1bmN0aW9uICh0ZXJtaW5hbCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXRFbmRPZlBhdGggJiZcbiAgICAgICAgICAgIHRlcm1pbmFsLnRlcm1pbmFsVHlwZS5uYW1lID09PSB0aGlzLm5leHRUZXJtaW5hbE5hbWUgJiZcbiAgICAgICAgICAgIHRlcm1pbmFsLmlkeCA9PT0gdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICAhdGhpcy5mb3VuZCkge1xuICAgICAgICAgICAgdmFyIGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHZhciByZXN0UHJvZCA9IG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogZnVsbFJlc3QgfSk7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlVG9rVHlwZXMgPSBmaXJzdChyZXN0UHJvZCk7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRBZnRlclRva2VuV2Fsa2VyO1xufShBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlcikpO1xuZXhwb3J0IHsgTmV4dEFmdGVyVG9rZW5XYWxrZXIgfTtcbi8qKlxuICogVGhpcyB3YWxrZXIgb25seSBcIndhbGtzXCIgYSBzaW5nbGUgXCJUT1BcIiBsZXZlbCBpbiB0aGUgR3JhbW1hciBBc3QsIHRoaXMgbWVhbnNcbiAqIGl0IG5ldmVyIFwiZm9sbG93c1wiIHByb2R1Y3Rpb24gcmVmc1xuICovXG52YXIgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyKHRvcFJ1bGUsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudG9wUnVsZSA9IHRvcFJ1bGU7XG4gICAgICAgIF90aGlzLm9jY3VycmVuY2UgPSBvY2N1cnJlbmNlO1xuICAgICAgICBfdGhpcy5yZXN1bHQgPSB7XG4gICAgICAgICAgICB0b2tlbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNFbmRPZlJ1bGU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyLnByb3RvdHlwZS5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXI7XG59KFJlc3RXYWxrZXIpKTtcbmV4cG9ydCB7IEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyIH07XG52YXIgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlci5wcm90b3R5cGUud2Fsa01hbnkgPSBmdW5jdGlvbiAobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAobWFueVByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEFmdGVyTWFueSA9IF9maXJzdChjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlck1hbnkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyTWFueSBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyTWFueS50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJNYW55LmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa01hbnkuY2FsbCh0aGlzLCBtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlcjtcbn0oQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIpKTtcbmV4cG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciB9O1xudmFyIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIucHJvdG90eXBlLndhbGtNYW55U2VwID0gZnVuY3Rpb24gKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKG1hbnlTZXBQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RBZnRlck1hbnlTZXAgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJNYW55U2VwID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlck1hbnlTZXAgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlck1hbnlTZXAudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyTWFueVNlcC5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtNYW55U2VwLmNhbGwodGhpcywgbWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXI7XG59KEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyKSk7XG5leHBvcnQgeyBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIgfTtcbnZhciBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZSA9IGZ1bmN0aW9uIChhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChhdExlYXN0T25lUHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0QWZ0ZXJBdExlYXN0T25lID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyQXRMZWFzdE9uZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJBdExlYXN0T25lIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9IGZpcnN0QWZ0ZXJBdExlYXN0T25lLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlckF0TGVhc3RPbmUuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZS5jYWxsKHRoaXMsIGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyO1xufShBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlcikpO1xuZXhwb3J0IHsgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyIH07XG4vLyBUT0RPOiByZWR1Y2UgY29kZSBkdXBsaWNhdGlvbiBpbiB0aGUgQWZ0ZXJXYWxrZXJzXG52YXIgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlci5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXAgPSBmdW5jdGlvbiAoYXRsZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoYXRsZWFzdE9uZVNlcFByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9XG4gICAgICAgICAgICAgICAgZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcC50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcC5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwLmNhbGwodGhpcywgYXRsZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXI7XG59KEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyKSk7XG5leHBvcnQgeyBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIgfTtcbmV4cG9ydCBmdW5jdGlvbiBwb3NzaWJsZVBhdGhzRnJvbSh0YXJnZXREZWYsIG1heExlbmd0aCwgY3VyclBhdGgpIHtcbiAgICBpZiAoY3VyclBhdGggPT09IHZvaWQgMCkgeyBjdXJyUGF0aCA9IFtdOyB9XG4gICAgLy8gYXZvaWQgc2lkZSBlZmZlY3RzXG4gICAgY3VyclBhdGggPSBjbG9uZUFycihjdXJyUGF0aCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICAvLyBUT0RPOiBhdm9pZCBpbm5lciBmdW5jc1xuICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1BhdGhXaXRoKG5leHREZWYpIHtcbiAgICAgICAgcmV0dXJuIG5leHREZWYuY29uY2F0KGRyb3AodGFyZ2V0RGVmLCBpICsgMSkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBhdm9pZCBpbm5lciBmdW5jc1xuICAgIGZ1bmN0aW9uIGdldEFsdGVybmF0aXZlc0ZvclByb2QoZGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gcG9zc2libGVQYXRoc0Zyb20ocmVtYWluaW5nUGF0aFdpdGgoZGVmaW5pdGlvbiksIG1heExlbmd0aCwgY3VyclBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChhbHRlcm5hdGl2ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW5kYXRvcnkgcHJvZHVjdGlvbnMgd2lsbCBoYWx0IHRoZSBsb29wIGFzIHRoZSBwYXRocyBjb21wdXRlZCBmcm9tIHRoZWlyIHJlY3Vyc2l2ZSBjYWxscyB3aWxsIGFscmVhZHkgY29udGFpbiB0aGVcbiAgICAgKiBmb2xsb3dpbmcgKHJlc3QpIG9mIHRoZSB0YXJnZXREZWYuXG4gICAgICpcbiAgICAgKiBGb3Igb3B0aW9uYWwgcHJvZHVjdGlvbnMgKE9wdGlvbi9SZXBldGl0aW9uLy4uLikgdGhlIGxvb3Agd2lsbCBjb250aW51ZSB0byByZXByZXNlbnQgdGhlIHBhdGhzIHRoYXQgZG8gbm90IGluY2x1ZGUgdGhlXG4gICAgICogdGhlIG9wdGlvbmFsIHByb2R1Y3Rpb24uXG4gICAgICovXG4gICAgd2hpbGUgKGN1cnJQYXRoLmxlbmd0aCA8IG1heExlbmd0aCAmJiBpIDwgdGFyZ2V0RGVmLmxlbmd0aCkge1xuICAgICAgICB2YXIgcHJvZCA9IHRhcmdldERlZltpXTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBGbGF0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChwcm9kLmRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QocHJvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKHByb2QuZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGVmID0gW1xuICAgICAgICAgICAgICAgIG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvciB9KVxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChwcm9kLmRlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgdmFyIG5ld0RlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW1xuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvciB9KVxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChwcm9kLmRlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb25cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGN1cnJBbHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKGN1cnJBbHQuZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICBjdXJyUGF0aC5wdXNoKHByb2QudGVybWluYWxUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHBhcnRpYWxQYXRoOiBjdXJyUGF0aCxcbiAgICAgICAgc3VmZml4RGVmOiBkcm9wKHRhcmdldERlZiwgaSlcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKGluaXRpYWxEZWYsIHRva2VuVmVjdG9yLCB0b2tNYXRjaGVyLCBtYXhMb29rQWhlYWQpIHtcbiAgICB2YXIgRVhJVF9OT05fVEVSTUlOQUwgPSBcIkVYSVRfTk9ORV9URVJNSU5BTFwiO1xuICAgIC8vIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IEFycmF5IGVhY2ggdGltZS5cbiAgICB2YXIgRVhJVF9OT05fVEVSTUlOQUxfQVJSID0gW0VYSVRfTk9OX1RFUk1JTkFMXTtcbiAgICB2YXIgRVhJVF9BTFRFUk5BVElWRSA9IFwiRVhJVF9BTFRFUk5BVElWRVwiO1xuICAgIHZhciBmb3VuZENvbXBsZXRlUGF0aCA9IGZhbHNlO1xuICAgIHZhciB0b2tlblZlY3Rvckxlbmd0aCA9IHRva2VuVmVjdG9yLmxlbmd0aDtcbiAgICB2YXIgbWluaW1hbEFsdGVybmF0aXZlc0luZGV4ID0gdG9rZW5WZWN0b3JMZW5ndGggLSBtYXhMb29rQWhlYWQgLSAxO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgcG9zc2libGVQYXRocyA9IFtdO1xuICAgIHBvc3NpYmxlUGF0aHMucHVzaCh7XG4gICAgICAgIGlkeDogLTEsXG4gICAgICAgIGRlZjogaW5pdGlhbERlZixcbiAgICAgICAgcnVsZVN0YWNrOiBbXSxcbiAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBbXVxuICAgIH0pO1xuICAgIHdoaWxlICghaXNFbXB0eShwb3NzaWJsZVBhdGhzKSkge1xuICAgICAgICB2YXIgY3VyclBhdGggPSBwb3NzaWJsZVBhdGhzLnBvcCgpO1xuICAgICAgICAvLyBza2lwIGFsdGVybmF0aXZlcyBpZiBubyBtb3JlIHJlc3VsdHMgY2FuIGJlIGZvdW5kIChhc3N1bWluZyBkZXRlcm1pbmlzdGljIGdyYW1tYXIgd2l0aCBmaXhlZCBsb29rYWhlYWQpXG4gICAgICAgIGlmIChjdXJyUGF0aCA9PT0gRVhJVF9BTFRFUk5BVElWRSkge1xuICAgICAgICAgICAgaWYgKGZvdW5kQ29tcGxldGVQYXRoICYmXG4gICAgICAgICAgICAgICAgbGFzdChwb3NzaWJsZVBhdGhzKS5pZHggPD0gbWluaW1hbEFsdGVybmF0aXZlc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGlycmVsZXZhbnQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJEZWYgPSBjdXJyUGF0aC5kZWY7XG4gICAgICAgIHZhciBjdXJySWR4ID0gY3VyclBhdGguaWR4O1xuICAgICAgICB2YXIgY3VyclJ1bGVTdGFjayA9IGN1cnJQYXRoLnJ1bGVTdGFjaztcbiAgICAgICAgdmFyIGN1cnJPY2N1cnJlbmNlU3RhY2sgPSBjdXJyUGF0aC5vY2N1cnJlbmNlU3RhY2s7XG4gICAgICAgIC8vIEZvciBFeGFtcGxlOiBhbiBlbXB0eSBwYXRoIGNvdWxkIGV4aXN0IGluIGEgdmFsaWQgZ3JhbW1hciBpbiB0aGUgY2FzZSBvZiBhbiBFTVBUWV9BTFRcbiAgICAgICAgaWYgKGlzRW1wdHkoY3VyckRlZikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9kID0gY3VyckRlZlswXTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHByb2QgPT09IEVYSVRfTk9OX1RFUk1JTkFMKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGRyb3BSaWdodChjdXJyUnVsZVN0YWNrKSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGRyb3BSaWdodChjdXJyT2NjdXJyZW5jZVN0YWNrKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGN1cnJJZHggPCB0b2tlblZlY3Rvckxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dElkeCA9IGN1cnJJZHggKyAxO1xuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxUb2tlbiA9IHRva2VuVmVjdG9yW25leHRJZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0b2tNYXRjaGVyKGFjdHVhbFRva2VuLCBwcm9kLnRlcm1pbmFsVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4OiBuZXh0SWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycklkeCA9PT0gdG9rZW5WZWN0b3JMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSUdOT1JFIEFCT1ZFIEVMU0VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlblR5cGU6IHByb2QudGVybWluYWxUeXBlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW5PY2N1cnJlbmNlOiBwcm9kLmlkeCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3VuZENvbXBsZXRlUGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgdmFyIG5ld1J1bGVTdGFjayA9IGNsb25lQXJyKGN1cnJSdWxlU3RhY2spO1xuICAgICAgICAgICAgbmV3UnVsZVN0YWNrLnB1c2gocHJvZC5ub25UZXJtaW5hbE5hbWUpO1xuICAgICAgICAgICAgdmFyIG5ld09jY3VycmVuY2VTdGFjayA9IGNsb25lQXJyKGN1cnJPY2N1cnJlbmNlU3RhY2spO1xuICAgICAgICAgICAgbmV3T2NjdXJyZW5jZVN0YWNrLnB1c2gocHJvZC5pZHgpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoRVhJVF9OT05fVEVSTUlOQUxfQVJSLCBkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IG5ld1J1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IG5ld09jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgdmFyIG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRob3V0KTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIG1hcmtlciB0byBhdm9pZCBiYWNrdHJhY2tpbmcgcGF0aHMgd2hvc2UgaGlnaGVyIHByaW9yaXR5IGFsdGVybmF0aXZlcyBhbHJlYWR5IG1hdGNoZWRcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChFWElUX0FMVEVSTkFUSVZFKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdChkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86KFRIRSBORVcgb3BlcmF0b3JzIGhlcmUgdGFrZSBhIHdoaWxlLi4uKSAoY29udmVydCBvbmNlPylcbiAgICAgICAgICAgIHZhciBzZWNvbmRJdGVyYXRpb24gPSBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtzZWNvbmRJdGVyYXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgLy8gVE9ETzooVEhFIE5FVyBvcGVyYXRvcnMgaGVyZSB0YWtlIGEgd2hpbGUuLi4pIChjb252ZXJ0IG9uY2U/KVxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckdhc3QgPSBuZXcgVGVybWluYWwoe1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNlY29uZEl0ZXJhdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbc2VwYXJhdG9yR2FzdF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW3NlY29uZEl0ZXJhdGlvbl0sIGRyb3AoY3VyckRlZikpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRob3V0ID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckdhc3QgPSBuZXcgVGVybWluYWwoe1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG50aFJlcGV0aXRpb24gPSBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogW3NlcGFyYXRvckdhc3RdLmNvbmNhdChwcm9kLmRlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtudGhSZXBldGl0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICB2YXIgbmV4dFBhdGhXaXRob3V0ID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgLy8gVE9ETzogYW4gZW1wdHkgcmVwZXRpdGlvbiB3aWxsIGNhdXNlIGluZmluaXRlIGxvb3BzIGhlcmUsIHdpbGwgdGhlIHBhcnNlciBkZXRlY3QgdGhpcyBpbiBzZWxmQW5hbHlzaXM/XG4gICAgICAgICAgICB2YXIgbnRoUmVwZXRpdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW250aFJlcGV0aXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcHJvZC5kZWZpbml0aW9uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJBbHQgPSBwcm9kLmRlZmluaXRpb25baV07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJBbHRQYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgICAgIGRlZjogY3VyckFsdC5kZWZpbml0aW9uLmNvbmNhdChkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChjdXJyQWx0UGF0aCk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBGbGF0KSB7XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgICAgIC8vIGxhc3QgYmVjYXVzZSB3ZSBzaG91bGQgb25seSBlbmNvdW50ZXIgYXQgbW9zdCBhIHNpbmdsZSBvbmUgb2YgdGhlc2UgcGVyIGludm9jYXRpb24uXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goZXhwYW5kVG9wTGV2ZWxSdWxlKHByb2QsIGN1cnJJZHgsIGN1cnJSdWxlU3RhY2ssIGN1cnJPY2N1cnJlbmNlU3RhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV4cGFuZFRvcExldmVsUnVsZSh0b3BSdWxlLCBjdXJySWR4LCBjdXJyUnVsZVN0YWNrLCBjdXJyT2NjdXJyZW5jZVN0YWNrKSB7XG4gICAgdmFyIG5ld1J1bGVTdGFjayA9IGNsb25lQXJyKGN1cnJSdWxlU3RhY2spO1xuICAgIG5ld1J1bGVTdGFjay5wdXNoKHRvcFJ1bGUubmFtZSk7XG4gICAgdmFyIG5ld0N1cnJPY2N1cnJlbmNlU3RhY2sgPSBjbG9uZUFycihjdXJyT2NjdXJyZW5jZVN0YWNrKTtcbiAgICAvLyB0b3AgcnVsZSBpcyBhbHdheXMgYXNzdW1lZCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggb2NjdXJyZW5jZSBpbmRleCAxXG4gICAgbmV3Q3Vyck9jY3VycmVuY2VTdGFjay5wdXNoKDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgZGVmOiB0b3BSdWxlLmRlZmluaXRpb24sXG4gICAgICAgIHJ1bGVTdGFjazogbmV3UnVsZVN0YWNrLFxuICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IG5ld0N1cnJPY2N1cnJlbmNlU3RhY2tcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJwcmV0ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js ***!
  \*******************************************************************/
/*! exports provided: BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, BITS_FOR_RULE_IDX, BITS_FOR_ALT_IDX, OR_IDX, OPTION_IDX, MANY_IDX, AT_LEAST_ONE_IDX, MANY_SEP_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, getKeyForAltIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BITS_FOR_METHOD_TYPE\", function() { return BITS_FOR_METHOD_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BITS_FOR_OCCURRENCE_IDX\", function() { return BITS_FOR_OCCURRENCE_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BITS_FOR_RULE_IDX\", function() { return BITS_FOR_RULE_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BITS_FOR_ALT_IDX\", function() { return BITS_FOR_ALT_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OR_IDX\", function() { return OR_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OPTION_IDX\", function() { return OPTION_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MANY_IDX\", function() { return MANY_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AT_LEAST_ONE_IDX\", function() { return AT_LEAST_ONE_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MANY_SEP_IDX\", function() { return MANY_SEP_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AT_LEAST_ONE_SEP_IDX\", function() { return AT_LEAST_ONE_SEP_IDX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getKeyForAutomaticLookahead\", function() { return getKeyForAutomaticLookahead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getKeyForAltIndex\", function() { return getKeyForAltIndex; });\n// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nvar BITS_FOR_METHOD_TYPE = 4;\nvar BITS_FOR_OCCURRENCE_IDX = 8;\nvar BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nvar BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n/* tslint:disable */\nvar OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nvar OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nvar MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nvar AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n/* tslint:enable */\n// this actually returns a number, but it is always used as a string (object prop key)\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    /* tslint:disable */\n    return occurrence | dslMethodIdx | ruleIdx;\n    /* tslint:enable */\n}\nvar BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\nfunction getKeyForAltIndex(ruleIdx, dslMethodIdx, occurrence, altIdx) {\n    /* tslint:disable */\n    // alternative indices are zero based, thus must always add one (turn on one bit) to guarantee uniqueness.\n    var altIdxBitMap = (altIdx + 1) << BITS_START_FOR_ALT_IDX;\n    return (getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) |\n        altIdxBitMap);\n    /* tslint:enable */\n}\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2tleXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2tleXMuanM/YmUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMb29rYWhlYWQga2V5cyBhcmUgMzJCaXQgaW50ZWdlcnMgaW4gdGhlIGZvcm1cbi8vIFRUVFRUVFRULVpaWlpaWlpaWlpaWi1ZWVlZLVhYWFhYWFhYXG4vLyBYWFhYIC0+IE9jY3VycmVuY2UgSW5kZXggYml0bWFwLlxuLy8gWVlZWSAtPiBEU0wgTWV0aG9kIFR5cGUgYml0bWFwLlxuLy8gWlpaWlpaWlpaWlpaWlpaIC0+IFJ1bGUgc2hvcnQgSW5kZXggYml0bWFwLlxuLy8gVFRUVFRUVFRUIC0+IGFsdGVybmF0aW9uIGFsdGVybmF0aXZlIGluZGV4IGJpdG1hcFxuZXhwb3J0IHZhciBCSVRTX0ZPUl9NRVRIT0RfVFlQRSA9IDQ7XG5leHBvcnQgdmFyIEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYID0gODtcbmV4cG9ydCB2YXIgQklUU19GT1JfUlVMRV9JRFggPSAxMjtcbi8vIFRPRE86IHZhbGlkYXRpb24sIHRoaXMgbWVhbnMgdGhhdCB0aGVyZSBtYXkgYXQgbW9zdCAyXjggLS0+IDI1NiBhbHRlcm5hdGl2ZXMgZm9yIGFuIGFsdGVybmF0aW9uLlxuZXhwb3J0IHZhciBCSVRTX0ZPUl9BTFRfSURYID0gODtcbi8vIHNob3J0IHN0cmluZyB1c2VkIGFzIHBhcnQgb2YgbWFwcGluZyBrZXlzLlxuLy8gYmVpbmcgc2hvcnQgaW1wcm92ZXMgdGhlIHBlcmZvcm1hbmNlIHdoZW4gY29tcG9zaW5nIEtFWVMgZm9yIG1hcHMgb3V0IG9mIHRoZXNlXG4vLyBUaGUgNSAtIDggYml0cyAoMTYgcG9zc2libGUgdmFsdWVzLCBhcmUgcmVzZXJ2ZWQgZm9yIHRoZSBEU0wgbWV0aG9kIGluZGljZXMpXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuZXhwb3J0IHZhciBPUl9JRFggPSAxIDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0IHZhciBPUFRJT05fSURYID0gMiA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgTUFOWV9JRFggPSAzIDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0IHZhciBBVF9MRUFTVF9PTkVfSURYID0gNCA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgTUFOWV9TRVBfSURYID0gNSA8PCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDtcbmV4cG9ydCB2YXIgQVRfTEVBU1RfT05FX1NFUF9JRFggPSA2IDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuLyogdHNsaW50OmVuYWJsZSAqL1xuLy8gdGhpcyBhY3R1YWxseSByZXR1cm5zIGEgbnVtYmVyLCBidXQgaXQgaXMgYWx3YXlzIHVzZWQgYXMgYSBzdHJpbmcgKG9iamVjdCBwcm9wIGtleSlcbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQocnVsZUlkeCwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKSB7XG4gICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICByZXR1cm4gb2NjdXJyZW5jZSB8IGRzbE1ldGhvZElkeCB8IHJ1bGVJZHg7XG4gICAgLyogdHNsaW50OmVuYWJsZSAqL1xufVxudmFyIEJJVFNfU1RBUlRfRk9SX0FMVF9JRFggPSAzMiAtIEJJVFNfRk9SX0FMVF9JRFg7XG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5Rm9yQWx0SW5kZXgocnVsZUlkeCwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlLCBhbHRJZHgpIHtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgIC8vIGFsdGVybmF0aXZlIGluZGljZXMgYXJlIHplcm8gYmFzZWQsIHRodXMgbXVzdCBhbHdheXMgYWRkIG9uZSAodHVybiBvbiBvbmUgYml0KSB0byBndWFyYW50ZWUgdW5pcXVlbmVzcy5cbiAgICB2YXIgYWx0SWR4Qml0TWFwID0gKGFsdElkeCArIDEpIDw8IEJJVFNfU1RBUlRfRk9SX0FMVF9JRFg7XG4gICAgcmV0dXJuIChnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQocnVsZUlkeCwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKSB8XG4gICAgICAgIGFsdElkeEJpdE1hcCk7XG4gICAgLyogdHNsaW50OmVuYWJsZSAqL1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5cy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js ***!
  \************************************************************************/
/*! exports provided: PROD_TYPE, getProdType, buildLookaheadFuncForOr, buildLookaheadFuncForOptionalProd, buildAlternativesLookAheadFunc, buildSingleAlternativeLookaheadFunction, lookAheadSequenceFromAlternatives, getLookaheadPathsForOr, getLookaheadPathsForOptionalProd, containsPath, isStrictPrefixOfPath, areTokenCategoriesNotUsed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PROD_TYPE\", function() { return PROD_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getProdType\", function() { return getProdType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildLookaheadFuncForOr\", function() { return buildLookaheadFuncForOr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildLookaheadFuncForOptionalProd\", function() { return buildLookaheadFuncForOptionalProd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildAlternativesLookAheadFunc\", function() { return buildAlternativesLookAheadFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildSingleAlternativeLookaheadFunction\", function() { return buildSingleAlternativeLookaheadFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lookAheadSequenceFromAlternatives\", function() { return lookAheadSequenceFromAlternatives; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLookaheadPathsForOr\", function() { return getLookaheadPathsForOr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLookaheadPathsForOptionalProd\", function() { return getLookaheadPathsForOptionalProd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"containsPath\", function() { return containsPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isStrictPrefixOfPath\", function() { return isStrictPrefixOfPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"areTokenCategoriesNotUsed\", function() { return areTokenCategoriesNotUsed; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interpreter */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rest */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\");\n/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scan/tokens */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gast/gast_visitor_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE || (PROD_TYPE = {}));\nfunction getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"Option\"]) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"Repetition\"]) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"RepetitionMandatory\"]) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"RepetitionMandatoryWithSeparator\"]) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"RepetitionWithSeparator\"]) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"Alternation\"]) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? _scan_tokens__WEBPACK_IMPORTED_MODULE_3__[\"tokenStructuredMatcherNoCategories\"]\n        : _scan_tokens__WEBPACK_IMPORTED_MODULE_3__[\"tokenStructuredMatcher\"];\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? _scan_tokens__WEBPACK_IMPORTED_MODULE_3__[\"tokenStructuredMatcherNoCategories\"]\n        : _scan_tokens__WEBPACK_IMPORTED_MODULE_3__[\"tokenStructuredMatcher\"];\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(alts, function (currAlt) {\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined &&\n                    currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(alts, function (currAlt) {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(currAlt);\n        });\n        var choiceToAlt_1 = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(singleTokenAlts, function (result, currAlt, idx) {\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(currAlt, function (currTokType) {\n                if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(alt);\n        if (singleTokensTypes.length === 1 &&\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(_rest__WEBPACK_IMPORTED_MODULE_2__[\"RestWalker\"]));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_5__[\"GAstVisitor\"]));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(altsDefs, function (currAlt) { return Object(_interpreter__WEBPACK_IMPORTED_MODULE_1__[\"possiblePathsFrom\"])([currAlt], 1); });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(partialAlts, function (currAltPaths) {\n        var dict = {};\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique ||\n                    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(suffixDef) ||\n                    currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = Object(_interpreter__WEBPACK_IMPORTED_MODULE_1__[\"possiblePathsFrom\"])(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"Flat\"]({ definition: insideDef });\n    var afterFlat = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__[\"Flat\"]({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nfunction containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !==\n                    undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(lookAheadPaths, function (singleAltPaths) {\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(singleAltPaths, function (singlePath) {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(singlePath, function (token) { return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(token.categoryMatches); });\n        });\n    });\n}\n//# sourceMappingURL=lookahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL2xvb2thaGVhZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL2dyYW1tYXIvbG9va2FoZWFkLmpzP2YzNjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgeyBtYXAsIHJlZHVjZSwgZXZlcnksIGlzRW1wdHksIGZsYXR0ZW4sIGZvckVhY2gsIGhhcyB9IGZyb20gXCIuLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgcG9zc2libGVQYXRoc0Zyb20gfSBmcm9tIFwiLi9pbnRlcnByZXRlclwiO1xuaW1wb3J0IHsgUmVzdFdhbGtlciB9IGZyb20gXCIuL3Jlc3RcIjtcbmltcG9ydCB7IHRva2VuU3RydWN0dXJlZE1hdGNoZXIsIHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXMgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBGbGF0LCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciB9IGZyb20gXCIuL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljXCI7XG5leHBvcnQgdmFyIFBST0RfVFlQRTtcbihmdW5jdGlvbiAoUFJPRF9UWVBFKSB7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIk9QVElPTlwiXSA9IDBdID0gXCJPUFRJT05cIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiUkVQRVRJVElPTlwiXSA9IDFdID0gXCJSRVBFVElUSU9OXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05fTUFOREFUT1JZXCJdID0gMl0gPSBcIlJFUEVUSVRJT05fTUFOREFUT1JZXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SXCJdID0gM10gPSBcIlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1JcIl0gPSA0XSA9IFwiUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJBTFRFUk5BVElPTlwiXSA9IDVdID0gXCJBTFRFUk5BVElPTlwiO1xufSkoUFJPRF9UWVBFIHx8IChQUk9EX1RZUEUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2RUeXBlKHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuT1BUSU9OO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5BTFRFUk5BVElPTjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBtYXhMb29rYWhlYWQsIGhhc1ByZWRpY2F0ZXMsIGR5bmFtaWNUb2tlbnNFbmFibGVkLCBsYUZ1bmNCdWlsZGVyKSB7XG4gICAgdmFyIGxvb2tBaGVhZFBhdGhzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgbWF4TG9va2FoZWFkKTtcbiAgICB2YXIgdG9rZW5NYXRjaGVyID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocylcbiAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICByZXR1cm4gbGFGdW5jQnVpbGRlcihsb29rQWhlYWRQYXRocywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG59XG4vKipcbiAqICBXaGVuIGRlYWxpbmcgd2l0aCBhbiBPcHRpb25hbCBwcm9kdWN0aW9uIChPUFRJT04vTUFOWS8ybmQgaXRlcmF0aW9uIG9mIEFUX0xFQVNUX09ORS8uLi4pIHdlIG5lZWQgdG8gY29tcGFyZVxuICogIHRoZSBsb29rYWhlYWQgXCJpbnNpZGVcIiB0aGUgcHJvZHVjdGlvbiBhbmQgdGhlIGxvb2thaGVhZCBpbW1lZGlhdGVseSBcImFmdGVyXCIgaXQgaW4gdGhlIHNhbWUgdG9wIGxldmVsIHJ1bGUgKGNvbnRleHQgZnJlZSkuXG4gKlxuICogIEV4YW1wbGU6IGdpdmVuIGEgcHJvZHVjdGlvbjpcbiAqICBBQkMoREUpP0RGXG4gKlxuICogIFRoZSBvcHRpb25hbCAnKERFKT8nIHNob3VsZCBvbmx5IGJlIGVudGVyZWQgaWYgd2Ugc2VlICdERScuIGEgc2luZ2xlIFRva2VuICdEJyBpcyBub3Qgc3VmZmljaWVudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d29cbiAqICBhbHRlcm5hdGl2ZXMuXG4gKlxuICogIEByZXR1cm5zIEEgTG9va2FoZWFkIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgSUZGIHRoZSBwYXJzZXIgc2hvdWxkIHBhcnNlIHRoZSBPcHRpb25hbCBwcm9kdWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBrLCBkeW5hbWljVG9rZW5zRW5hYmxlZCwgcHJvZFR5cGUsIGxvb2thaGVhZEJ1aWxkZXIpIHtcbiAgICB2YXIgbG9va0FoZWFkUGF0aHMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIGspO1xuICAgIHZhciB0b2tlbk1hdGNoZXIgPSBhcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkKGxvb2tBaGVhZFBhdGhzKVxuICAgICAgICA/IHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXNcbiAgICAgICAgOiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyO1xuICAgIHJldHVybiBsb29rYWhlYWRCdWlsZGVyKGxvb2tBaGVhZFBhdGhzWzBdLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMoYWx0cywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgIHZhciBudW1PZkFsdHMgPSBhbHRzLmxlbmd0aDtcbiAgICB2YXIgYXJlQWxsT25lVG9rZW5Mb29rYWhlYWQgPSBldmVyeShhbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkge1xuICAgICAgICByZXR1cm4gZXZlcnkoY3VyckFsdCwgZnVuY3Rpb24gKGN1cnJQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyclBhdGgubGVuZ3RoID09PSAxO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIHZlcnNpb24gdGFrZXMgaW50byBhY2NvdW50IHRoZSBwcmVkaWNhdGVzIGFzIHdlbGwuXG4gICAgaWYgKGhhc1ByZWRpY2F0ZXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gVGhlIGNob3NlbiBhbHRlcm5hdGl2ZSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvckFsdHMpIHtcbiAgICAgICAgICAgIC8vIHVuZm9ydHVuYXRlbHkgdGhlIHByZWRpY2F0ZXMgbXVzdCBiZSBleHRyYWN0ZWQgZXZlcnkgc2luZ2xlIHRpbWVcbiAgICAgICAgICAgIC8vIGFzIHRoZXkgY2Fubm90IGJlIGNhY2hlZCBkdWUgdG8gcmVmZXJlbmNlcyB0byBwYXJhbWV0ZXJzKHZhcnMpIHdoaWNoIGFyZSBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgaW4gdGhlIGNvbW1vbiBjYXNlIG9mIG5vIHByZWRpY2F0ZXMsIG5vIGNwdSB0aW1lIHdpbGwgYmUgd2FzdGVkIG9uIHRoaXMgKHNlZSBlbHNlIGJsb2NrKVxuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZXMgPSBtYXAob3JBbHRzLCBmdW5jdGlvbiAoY3VyckFsdCkgeyByZXR1cm4gY3VyckFsdC5HQVRFOyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtT2ZBbHRzOyB0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJOdW1PZlBhdGhzID0gY3VyckFsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJQcmVkaWNhdGUgPSBwcmVkaWNhdGVzW3RdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyUHJlZGljYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VyclByZWRpY2F0ZS5jYWxsKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJlZGljYXRlIGRvZXMgbm90IG1hdGNoIHRoZXJlIGlzIG5vIHBvaW50IGluIGNoZWNraW5nIHRoZSBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFBhdGg6IGZvciAodmFyIGogPSAwOyBqIDwgY3Vyck51bU9mUGF0aHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGggPSBjdXJyQWx0W2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMuTEEoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIGN1cnJQYXRoW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNtYXRjaCBpbiBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgbmV4dFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmdWxsIHBhdGggdGhhdCBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYWxzbyB3b3JrIGZvciBhbiBlbXB0eSBBTFQgYXMgdGhlIGxvb3Agd2lsbCBiZSBza2lwcGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBub25lIG9mIHRoZSBwYXRocyBmb3IgdGhlIGN1cnJlbnQgYWx0ZXJuYXRpdmUgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgYWx0ZXJuYXRpdmVzIGNvdWxkIGJlIG1hdGNoZWRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZUFsbE9uZVRva2VuTG9va2FoZWFkICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICAvLyBvcHRpbWl6ZWQgKGNvbW1vbikgY2FzZSBvZiBhbGwgdGhlIGxvb2thaGVhZHMgcGF0aHMgcmVxdWlyaW5nIG9ubHlcbiAgICAgICAgLy8gYSBzaW5nbGUgdG9rZW4gbG9va2FoZWFkLiBUaGVzZSBPcHRpbWl6YXRpb25zIGNhbm5vdCB3b3JrIGlmIGR5bmFtaWNhbGx5IGRlZmluZWQgVG9rZW5zIGFyZSB1c2VkLlxuICAgICAgICB2YXIgc2luZ2xlVG9rZW5BbHRzID0gbWFwKGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihjdXJyQWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjaG9pY2VUb0FsdF8xID0gcmVkdWNlKHNpbmdsZVRva2VuQWx0cywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyckFsdCwgaWR4KSB7XG4gICAgICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIGZ1bmN0aW9uIChjdXJyVG9rVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzKHJlc3VsdCwgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIGZ1bmN0aW9uIChjdXJyRXh0ZW5kaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhcyhyZXN1bHQsIGN1cnJFeHRlbmRpbmdUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdF8xW25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxvb2thaGVhZCB3aXRob3V0IG5lZWRpbmcgdG8gY2hlY2sgdGhlIHByZWRpY2F0ZXMgYXQgYWxsLlxuICAgICAgICAvLyB0aGlzIGNhdXNlcyBjb2RlIGR1cGxpY2F0aW9uIHdoaWNoIGlzIGludGVudGlvbmFsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJBbHQgPSBhbHRzW3RdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyTnVtT2ZQYXRocyA9IGN1cnJBbHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJOdW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoID0gY3VyckFsdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoTGVuZ3RoID0gY3VyclBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJQYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gd29yayBmb3IgYW4gZW1wdHkgQUxUIGFzIHRoZSBsb29wIHdpbGwgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgZm9yIHRoZSBjdXJyZW50IGFsdGVybmF0aXZlIG1hdGNoZWRcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIGFsdGVybmF0aXZlcyBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb24oYWx0LCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgdmFyIGFyZUFsbE9uZVRva2VuTG9va2FoZWFkID0gZXZlcnkoYWx0LCBmdW5jdGlvbiAoY3VyclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJQYXRoLmxlbmd0aCA9PT0gMTtcbiAgICB9KTtcbiAgICB2YXIgbnVtT2ZQYXRocyA9IGFsdC5sZW5ndGg7XG4gICAgLy8gb3B0aW1pemVkIChjb21tb24pIGNhc2Ugb2YgYWxsIHRoZSBsb29rYWhlYWRzIHBhdGhzIHJlcXVpcmluZyBvbmx5XG4gICAgLy8gYSBzaW5nbGUgdG9rZW4gbG9va2FoZWFkLlxuICAgIGlmIChhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIHNpbmdsZVRva2Vuc1R5cGVzID0gZmxhdHRlbihhbHQpO1xuICAgICAgICBpZiAoc2luZ2xlVG9rZW5zVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBpc0VtcHR5KHNpbmdsZVRva2Vuc1R5cGVzWzBdLmNhdGVnb3J5TWF0Y2hlcykpIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZFRva2VuVHlwZSA9IHNpbmdsZVRva2Vuc1R5cGVzWzBdO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVG9rZW5VbmlxdWVLZXlfMSA9IGV4cGVjdGVkVG9rZW5UeXBlLnRva2VuVHlwZUlkeDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSkudG9rZW5UeXBlSWR4ID09PSBleHBlY3RlZFRva2VuVW5pcXVlS2V5XzE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNob2ljZVRvQWx0XzIgPSByZWR1Y2Uoc2luZ2xlVG9rZW5zVHlwZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJUb2tUeXBlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIGZ1bmN0aW9uIChjdXJyRXh0ZW5kaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyckV4dGVuZGluZ1R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRfMltuZXh0VG9rZW4udG9rZW5UeXBlSWR4XSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXh0UGF0aDogZm9yICh2YXIgaiA9IDA7IGogPCBudW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGggPSBhbHRbal07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoTGVuZ3RoID0gY3VyclBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtaXNtYXRjaCBpbiBjdXJyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHBhdGhzIG1hdGNoZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG52YXIgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyKHRvcFByb2QsIHRhcmdldE9jY3VycmVuY2UsIHRhcmdldFByb2RUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvcFByb2QgPSB0b3BQcm9kO1xuICAgICAgICBfdGhpcy50YXJnZXRPY2N1cnJlbmNlID0gdGFyZ2V0T2NjdXJyZW5jZTtcbiAgICAgICAgX3RoaXMudGFyZ2V0UHJvZFR5cGUgPSB0YXJnZXRQcm9kVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUuc3RhcnRXYWxraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLndhbGsodGhpcy50b3BQcm9kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdERlZjtcbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0ID0gZnVuY3Rpb24gKG5vZGUsIGV4cGVjdGVkUHJvZFR5cGUsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAobm9kZS5pZHggPT09IHRoaXMudGFyZ2V0T2NjdXJyZW5jZSAmJlxuICAgICAgICAgICAgdGhpcy50YXJnZXRQcm9kVHlwZSA9PT0gZXhwZWN0ZWRQcm9kVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN0RGVmID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgZG8gbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIEdyYW1tYXIgYXN0IGFmdGVyIHdlIGhhdmUgZm91bmQgdGhlIHRhcmdldFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa09wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQob3B0aW9uUHJvZCwgUFJPRF9UWVBFLk9QVElPTiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgb3B0aW9uUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQoYXRMZWFzdE9uZVByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcywgYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlc3REZWZpbml0aW9uRmluZGVyV2Fsa2VyLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcCA9IGZ1bmN0aW9uIChhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KGF0TGVhc3RPbmVTZXBQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa01hbnkgPSBmdW5jdGlvbiAobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55UHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT04sIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlci5wcm90b3R5cGUud2Fsa01hbnlTZXAgPSBmdW5jdGlvbiAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55U2VwUHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsIG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXI7XG59KFJlc3RXYWxrZXIpKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiBhIHRhcmdldCBwcm9kdWN0aW9uIGluIGEgdG9wIGxldmVsIGxldmVsIHJ1bGUuXG4gKi9cbnZhciBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3IodGFyZ2V0T2NjdXJyZW5jZSwgdGFyZ2V0UHJvZFR5cGUsIHRhcmdldFJlZikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXRPY2N1cnJlbmNlID0gdGFyZ2V0T2NjdXJyZW5jZTtcbiAgICAgICAgX3RoaXMudGFyZ2V0UHJvZFR5cGUgPSB0YXJnZXRQcm9kVHlwZTtcbiAgICAgICAgX3RoaXMudGFyZ2V0UmVmID0gdGFyZ2V0UmVmO1xuICAgICAgICBfdGhpcy5yZXN1bHQgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUuY2hlY2tJc1RhcmdldCA9IGZ1bmN0aW9uIChub2RlLCBleHBlY3RlZFByb2ROYW1lKSB7XG4gICAgICAgIGlmIChub2RlLmlkeCA9PT0gdGhpcy50YXJnZXRPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID09PSBleHBlY3RlZFByb2ROYW1lICYmXG4gICAgICAgICAgICAodGhpcy50YXJnZXRSZWYgPT09IHVuZGVmaW5lZCB8fCBub2RlID09PSB0aGlzLnRhcmdldFJlZikpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbm9kZS5kZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRPcHRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLk9QVElPTik7XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZKTtcbiAgICB9O1xuICAgIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUik7XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUik7XG4gICAgfTtcbiAgICBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuQUxURVJOQVRJT04pO1xuICAgIH07XG4gICAgcmV0dXJuIEluc2lkZURlZmluaXRpb25GaW5kZXJWaXNpdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMoc2l6ZSkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEEgc29ydCBvZiBoYXNoIGZ1bmN0aW9uIGJldHdlZW4gYSBQYXRoIGluIHRoZSBncmFtbWFyIGFuZCBhIHN0cmluZy5cbiAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgbXVsdGlwbGUgXCJoYXNoZXNcIiB0byBzdXBwb3J0IHRoZSBzY2VuYXJpbyBvZiB0b2tlbiBjYXRlZ29yaWVzLlxuICogLSAgQSBzaW5nbGUgcGF0aCB3aXRoIGNhdGVnb3JpZXMgbWF5IG1hdGNoIG11bHRpcGxlICoqYWN0dWFsKiogcGF0aHMuXG4gKi9cbmZ1bmN0aW9uIHBhdGhUb0hhc2hLZXlzKHBhdGgpIHtcbiAgICB2YXIga2V5cyA9IFtcIlwiXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva1R5cGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgbG9uZ2VyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyU2hvcnRlcktleSA9IGtleXNbal07XG4gICAgICAgICAgICBsb25nZXJLZXlzLnB1c2goY3VyclNob3J0ZXJLZXkgKyBcIl9cIiArIHRva1R5cGUudG9rZW5UeXBlSWR4KTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcmllc0tleVN1ZmZpeCA9IFwiX1wiICsgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNbdF07XG4gICAgICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgY2F0ZWdvcmllc0tleVN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cyA9IGxvbmdlcktleXM7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBJbXBlcmF0aXZlIHN0eWxlIGR1ZSB0byBiZWluZyBjYWxsZWQgZnJvbSBhIGhvdCBzcG90XG4gKi9cbmZ1bmN0aW9uIGlzVW5pcXVlUHJlZml4SGFzaChhbHRLbm93blBhdGhzS2V5cywgc2VhcmNoUGF0aEtleXMsIGlkeCkge1xuICAgIGZvciAodmFyIGN1cnJBbHRJZHggPSAwOyBjdXJyQWx0SWR4IDwgYWx0S25vd25QYXRoc0tleXMubGVuZ3RoOyBjdXJyQWx0SWR4KyspIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHRlc3QgdnMgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgICAgICBpZiAoY3VyckFsdElkeCA9PT0gaWR4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJBbHRLbm93blBhdGhzS2V5cyA9IGFsdEtub3duUGF0aHNLZXlzW2N1cnJBbHRJZHhdO1xuICAgICAgICBmb3IgKHZhciBzZWFyY2hJZHggPSAwOyBzZWFyY2hJZHggPCBzZWFyY2hQYXRoS2V5cy5sZW5ndGg7IHNlYXJjaElkeCsrKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoS2V5ID0gc2VhcmNoUGF0aEtleXNbc2VhcmNoSWR4XTtcbiAgICAgICAgICAgIGlmIChvdGhlckFsdEtub3duUGF0aHNLZXlzW3NlYXJjaEtleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9uZSBvZiB0aGUgU2VhcmNoUGF0aEtleXMgd2VyZSBmb3VuZCBpbiBhbnkgb2YgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcyhhbHRzRGVmcywgaykge1xuICAgIHZhciBwYXJ0aWFsQWx0cyA9IG1hcChhbHRzRGVmcywgZnVuY3Rpb24gKGN1cnJBbHQpIHsgcmV0dXJuIHBvc3NpYmxlUGF0aHNGcm9tKFtjdXJyQWx0XSwgMSk7IH0pO1xuICAgIHZhciBmaW5hbFJlc3VsdCA9IGluaXRpYWxpemVBcnJheU9mQXJyYXlzKHBhcnRpYWxBbHRzLmxlbmd0aCk7XG4gICAgdmFyIGFsdHNIYXNoZXMgPSBtYXAocGFydGlhbEFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0UGF0aHMpIHtcbiAgICAgICAgdmFyIGRpY3QgPSB7fTtcbiAgICAgICAgZm9yRWFjaChjdXJyQWx0UGF0aHMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHBhdGhUb0hhc2hLZXlzKGl0ZW0ucGFydGlhbFBhdGgpO1xuICAgICAgICAgICAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoY3VycktleSkge1xuICAgICAgICAgICAgICAgIGRpY3RbY3VycktleV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGljdDtcbiAgICB9KTtcbiAgICB2YXIgbmV3RGF0YSA9IHBhcnRpYWxBbHRzO1xuICAgIC8vIG1heExvb2thaGVhZCBsb29wXG4gICAgZm9yICh2YXIgcGF0aExlbmd0aCA9IDE7IHBhdGhMZW5ndGggPD0gazsgcGF0aExlbmd0aCsrKSB7XG4gICAgICAgIHZhciBjdXJyRGF0YXNldCA9IG5ld0RhdGE7XG4gICAgICAgIG5ld0RhdGEgPSBpbml0aWFsaXplQXJyYXlPZkFycmF5cyhjdXJyRGF0YXNldC5sZW5ndGgpO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChhbHRJZHgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlcyA9IGN1cnJEYXRhc2V0W2FsdElkeF07XG4gICAgICAgICAgICAvLyBwYXRocyBpbiBjdXJyZW50IGFsdGVybmF0aXZlIGxvb3BcbiAgICAgICAgICAgIGZvciAodmFyIGN1cnJQYXRoSWR4ID0gMDsgY3VyclBhdGhJZHggPCBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlcy5sZW5ndGg7IGN1cnJQYXRoSWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhdGhQcmVmaXggPSBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlc1tjdXJyUGF0aElkeF0ucGFydGlhbFBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIHN1ZmZpeERlZiA9IGN1cnJBbHRQYXRoc0FuZFN1ZmZpeGVzW2N1cnJQYXRoSWR4XS5zdWZmaXhEZWY7XG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeEtleXMgPSBwYXRoVG9IYXNoS2V5cyhjdXJyUGF0aFByZWZpeCk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVW5pcXVlID0gaXNVbmlxdWVQcmVmaXhIYXNoKGFsdHNIYXNoZXMsIHByZWZpeEtleXMsIGFsdElkeCk7XG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIHRoZSBsaW5lIGZvciB0aGlzIHBhdGguXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5pcXVlIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHkoc3VmZml4RGVmKSB8fFxuICAgICAgICAgICAgICAgICAgICBjdXJyUGF0aFByZWZpeC5sZW5ndGggPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJBbHRSZXN1bHQgPSBmaW5hbFJlc3VsdFthbHRJZHhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDYW4gd2UgaW1wbGVtZW50IGEgY29udGFpbnNQYXRoIHVzaW5nIE1hcHMvRGljdGlvbmFyaWVzP1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNQYXRoKGN1cnJBbHRSZXN1bHQsIGN1cnJQYXRoUHJlZml4KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbHRSZXN1bHQucHVzaChjdXJyUGF0aFByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYWxsIG5ldyAga2V5cyBmb3IgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJlZml4S2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyS2V5ID0gcHJlZml4S2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRzSGFzaGVzW2FsdElkeF1bY3VycktleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBsb25nZXIgcGF0aHNcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzID0gcG9zc2libGVQYXRoc0Zyb20oc3VmZml4RGVmLCBwYXRoTGVuZ3RoICsgMSwgY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2FsdElkeF0gPSBuZXdEYXRhW2FsdElkeF0uY29uY2F0KG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGtleXMgZm9yIG5ldyBrbm93biBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeEtleXMgPSBwYXRoVG9IYXNoS2V5cyhpdGVtLnBhcnRpYWxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2gocHJlZml4S2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdHNIYXNoZXNbYWx0SWR4XVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGFsdGVybmF0aXZlcyBsb29wXG4gICAgICAgIGZvciAodmFyIGFsdElkeCA9IDA7IGFsdElkeCA8IGN1cnJEYXRhc2V0Lmxlbmd0aDsgYWx0SWR4KyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoYWx0SWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgaywgb3JQcm9kKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3Iob2NjdXJyZW5jZSwgUFJPRF9UWVBFLkFMVEVSTkFUSU9OLCBvclByb2QpO1xuICAgIHJ1bGVHcmFtbWFyLmFjY2VwdCh2aXNpdG9yKTtcbiAgICByZXR1cm4gbG9va0FoZWFkU2VxdWVuY2VGcm9tQWx0ZXJuYXRpdmVzKHZpc2l0b3IucmVzdWx0LCBrKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIGspIHtcbiAgICB2YXIgaW5zaWRlRGVmVmlzaXRvciA9IG5ldyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcihvY2N1cnJlbmNlLCBwcm9kVHlwZSk7XG4gICAgcnVsZUdyYW1tYXIuYWNjZXB0KGluc2lkZURlZlZpc2l0b3IpO1xuICAgIHZhciBpbnNpZGVEZWYgPSBpbnNpZGVEZWZWaXNpdG9yLnJlc3VsdDtcbiAgICB2YXIgYWZ0ZXJEZWZXYWxrZXIgPSBuZXcgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIocnVsZUdyYW1tYXIsIG9jY3VycmVuY2UsIHByb2RUeXBlKTtcbiAgICB2YXIgYWZ0ZXJEZWYgPSBhZnRlckRlZldhbGtlci5zdGFydFdhbGtpbmcoKTtcbiAgICB2YXIgaW5zaWRlRmxhdCA9IG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogaW5zaWRlRGVmIH0pO1xuICAgIHZhciBhZnRlckZsYXQgPSBuZXcgRmxhdCh7IGRlZmluaXRpb246IGFmdGVyRGVmIH0pO1xuICAgIHJldHVybiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXMoW2luc2lkZUZsYXQsIGFmdGVyRmxhdF0sIGspO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUGF0aChhbHRlcm5hdGl2ZSwgc2VhcmNoUGF0aCkge1xuICAgIGNvbXBhcmVPdGhlclBhdGg6IGZvciAodmFyIGkgPSAwOyBpIDwgYWx0ZXJuYXRpdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG90aGVyUGF0aCA9IGFsdGVybmF0aXZlW2ldO1xuICAgICAgICBpZiAob3RoZXJQYXRoLmxlbmd0aCAhPT0gc2VhcmNoUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXJQYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoVG9rID0gc2VhcmNoUGF0aFtqXTtcbiAgICAgICAgICAgIHZhciBvdGhlclRvayA9IG90aGVyUGF0aFtqXTtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ1Rva2VucyA9IHNlYXJjaFRvayA9PT0gb3RoZXJUb2sgfHxcbiAgICAgICAgICAgICAgICBvdGhlclRvay5jYXRlZ29yeU1hdGNoZXNNYXBbc2VhcmNoVG9rLnRva2VuVHlwZUlkeF0gIT09XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ1Rva2VucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBjb21wYXJlT3RoZXJQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpY3RQcmVmaXhPZlBhdGgocHJlZml4LCBvdGhlcikge1xuICAgIHJldHVybiAocHJlZml4Lmxlbmd0aCA8IG90aGVyLmxlbmd0aCAmJlxuICAgICAgICBldmVyeShwcmVmaXgsIGZ1bmN0aW9uICh0b2tUeXBlLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlclRva1R5cGUgPSBvdGhlcltpZHhdO1xuICAgICAgICAgICAgcmV0dXJuICh0b2tUeXBlID09PSBvdGhlclRva1R5cGUgfHxcbiAgICAgICAgICAgICAgICBvdGhlclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzTWFwW3Rva1R5cGUudG9rZW5UeXBlSWR4XSk7XG4gICAgICAgIH0pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkKGxvb2tBaGVhZFBhdGhzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5KGxvb2tBaGVhZFBhdGhzLCBmdW5jdGlvbiAoc2luZ2xlQWx0UGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIGV2ZXJ5KHNpbmdsZUFsdFBhdGhzLCBmdW5jdGlvbiAoc2luZ2xlUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZXJ5KHNpbmdsZVBhdGgsIGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gaXNFbXB0eSh0b2tlbi5jYXRlZ29yeU1hdGNoZXMpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb29rYWhlYWQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js ***!
  \***********************************************************************/
/*! exports provided: resolveGrammar, GastRefResolverVisitor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolveGrammar\", function() { return resolveGrammar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GastRefResolverVisitor\", function() { return GastRefResolverVisitor; });\n/* harmony import */ var _parser_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser/parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gast/gast_visitor_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_visitor_public.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\nfunction resolveGrammar(topLevels, errMsgProvider) {\n    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nvar GastRefResolverVisitor = /** @class */ (function (_super) {\n    __extends(GastRefResolverVisitor, _super);\n    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {\n        var _this = _super.call(this) || this;\n        _this.nameToTopRule = nameToTopRule;\n        _this.errMsgProvider = errMsgProvider;\n        _this.errors = [];\n        return _this;\n    }\n    GastRefResolverVisitor.prototype.resolveRefs = function () {\n        var _this = this;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"values\"])(this.nameToTopRule), function (prod) {\n            _this.currTopLevel = prod;\n            prod.accept(_this);\n        });\n    };\n    GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {\n        var ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: _parser_parser__WEBPACK_IMPORTED_MODULE_0__[\"ParserDefinitionErrorType\"].UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    };\n    return GastRefResolverVisitor;\n}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__[\"GAstVisitor\"]));\n\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL3Jlc29sdmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvZ3JhbW1hci9yZXNvbHZlci5qcz8zMmY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZSB9IGZyb20gXCIuLi9wYXJzZXIvcGFyc2VyXCI7XG5pbXBvcnQgeyBmb3JFYWNoLCB2YWx1ZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4vZ2FzdC9nYXN0X3Zpc2l0b3JfcHVibGljXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUdyYW1tYXIodG9wTGV2ZWxzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIHZhciByZWZSZXNvbHZlciA9IG5ldyBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yKHRvcExldmVscywgZXJyTXNnUHJvdmlkZXIpO1xuICAgIHJlZlJlc29sdmVyLnJlc29sdmVSZWZzKCk7XG4gICAgcmV0dXJuIHJlZlJlc29sdmVyLmVycm9ycztcbn1cbnZhciBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdhc3RSZWZSZXNvbHZlclZpc2l0b3IobmFtZVRvVG9wUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZVRvVG9wUnVsZSA9IG5hbWVUb1RvcFJ1bGU7XG4gICAgICAgIF90aGlzLmVyck1zZ1Byb3ZpZGVyID0gZXJyTXNnUHJvdmlkZXI7XG4gICAgICAgIF90aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdhc3RSZWZSZXNvbHZlclZpc2l0b3IucHJvdG90eXBlLnJlc29sdmVSZWZzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmb3JFYWNoKHZhbHVlcyh0aGlzLm5hbWVUb1RvcFJ1bGUpLCBmdW5jdGlvbiAocHJvZCkge1xuICAgICAgICAgICAgX3RoaXMuY3VyclRvcExldmVsID0gcHJvZDtcbiAgICAgICAgICAgIHByb2QuYWNjZXB0KF90aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMubmFtZVRvVG9wUnVsZVtub2RlLm5vblRlcm1pbmFsTmFtZV07XG4gICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gdGhpcy5lcnJNc2dQcm92aWRlci5idWlsZFJ1bGVOb3RGb3VuZEVycm9yKHRoaXMuY3VyclRvcExldmVsLCBub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOUkVTT0xWRURfU1VCUlVMRV9SRUYsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuY3VyclRvcExldmVsLm5hbWUsXG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZFJlZk5hbWU6IG5vZGUubm9uVGVybWluYWxOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlZFJ1bGUgPSByZWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHYXN0UmVmUmVzb2x2ZXJWaXNpdG9yO1xufShHQXN0VmlzaXRvcikpO1xuZXhwb3J0IHsgR2FzdFJlZlJlc29sdmVyVmlzaXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/resolver.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js ***!
  \*******************************************************************/
/*! exports provided: RestWalker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RestWalker\", function() { return RestWalker; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(prod.definition, function (subProd, index) {\n            var currRest = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"drop\"])(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"]) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Flat\"]) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"]) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatory\"]) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatoryWithSeparator\"]) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionWithSeparator\"]) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Repetition\"]) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Alternation\"]) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"]({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"]({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Flat\"]({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"]({\n            definition: [\n                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]({ terminalType: repSepProd.separator })\n            ].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL3Jlc3QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9ncmFtbWFyL3Jlc3QuanM/YzJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkcm9wLCBmb3JFYWNoIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgRmxhdCwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBUZXJtaW5hbCB9IGZyb20gXCIuL2dhc3QvZ2FzdF9wdWJsaWNcIjtcbi8qKlxuICogIEEgR3JhbW1hciBXYWxrZXIgdGhhdCBjb21wdXRlcyB0aGUgXCJyZW1haW5pbmdcIiBncmFtbWFyIFwiYWZ0ZXJcIiBhIHByb2R1Y3Rpb25zIGluIHRoZSBncmFtbWFyLlxuICovXG52YXIgUmVzdFdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN0V2Fsa2VyKCkge1xuICAgIH1cbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gKHByb2QsIHByZXZSZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwcmV2UmVzdCA9PT0gdm9pZCAwKSB7IHByZXZSZXN0ID0gW107IH1cbiAgICAgICAgZm9yRWFjaChwcm9kLmRlZmluaXRpb24sIGZ1bmN0aW9uIChzdWJQcm9kLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGN1cnJSZXN0ID0gZHJvcChwcm9kLmRlZmluaXRpb24sIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtQcm9kUmVmKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrVGVybWluYWwoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBGbGF0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa0ZsYXQoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrT3B0aW9uKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtBdExlYXN0T25lKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53YWxrQXRMZWFzdE9uZVNlcChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa01hbnlTZXAoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2Fsa01hbnkoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLndhbGtPcihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZXN0V2Fsa2VyLnByb3RvdHlwZS53YWxrVGVybWluYWwgPSBmdW5jdGlvbiAodGVybWluYWwsIGN1cnJSZXN0LCBwcmV2UmVzdCkgeyB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtQcm9kUmVmID0gZnVuY3Rpb24gKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkgeyB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtGbGF0ID0gZnVuY3Rpb24gKGZsYXRQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDREVGID0+IGFmdGVyIHRoZSBEIHRoZSByZXN0IGlzIEVGXG4gICAgICAgIHZhciBmdWxsT3JSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKGZsYXRQcm9kLCBmdWxsT3JSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyhERSk/RiA9PiBhZnRlciB0aGUgKERFKT8gdGhlIHJlc3QgaXMgRlxuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhvcHRpb25Qcm9kLCBmdWxsT3JSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKStGID0+IGFmdGVyIHRoZSAoREUpKyB0aGUgcmVzdCBpcyAoREUpP0ZcbiAgICAgICAgdmFyIGZ1bGxBdExlYXN0T25lUmVzdCA9IFtcbiAgICAgICAgICAgIG5ldyBPcHRpb24oeyBkZWZpbml0aW9uOiBhdExlYXN0T25lUHJvZC5kZWZpbml0aW9uIH0pXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhhdExlYXN0T25lUHJvZCwgZnVsbEF0TGVhc3RPbmVSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwID0gZnVuY3Rpb24gKGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDIERFKCxERSkqIEYgPT4gYWZ0ZXIgdGhlICgsREUpKyB0aGUgcmVzdCBpcyAoLERFKT9GXG4gICAgICAgIHZhciBmdWxsQXRMZWFzdE9uZVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IoYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhhdExlYXN0T25lU2VwUHJvZCwgZnVsbEF0TGVhc3RPbmVTZXBSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtNYW55ID0gZnVuY3Rpb24gKG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKSpGID0+IGFmdGVyIHRoZSAoREUpKiB0aGUgcmVzdCBpcyAoREUpP0ZcbiAgICAgICAgdmFyIGZ1bGxNYW55UmVzdCA9IFtcbiAgICAgICAgICAgIG5ldyBPcHRpb24oeyBkZWZpbml0aW9uOiBtYW55UHJvZC5kZWZpbml0aW9uIH0pXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55UHJvZCwgZnVsbE1hbnlSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtNYW55U2VwID0gZnVuY3Rpb24gKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDIChERSgsREUpKik/IEYgPT4gYWZ0ZXIgdGhlICgsREUpKiB0aGUgcmVzdCBpcyAoLERFKT9GXG4gICAgICAgIHZhciBmdWxsTWFueVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55U2VwUHJvZCwgZnVsbE1hbnlTZXBSZXN0KTtcbiAgICB9O1xuICAgIFJlc3RXYWxrZXIucHJvdG90eXBlLndhbGtPciA9IGZ1bmN0aW9uIChvclByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBQkMoRHxFfEYpRyA9PiB3aGVuIGZpbmRpbmcgdGhlIChEfEV8RikgdGhlIHJlc3QgaXMgR1xuICAgICAgICB2YXIgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIC8vIHdhbGsgYWxsIGRpZmZlcmVudCBhbHRlcm5hdGl2ZXNcbiAgICAgICAgZm9yRWFjaChvclByb2QuZGVmaW5pdGlvbiwgZnVuY3Rpb24gKGFsdCkge1xuICAgICAgICAgICAgLy8gd3JhcHBpbmcgZWFjaCBhbHRlcm5hdGl2ZSBpbiBhIHNpbmdsZSBkZWZpbml0aW9uIHdyYXBwZXJcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGVycm9ycyBpbiBjb21wdXRpbmcgdGhlIHJlc3Qgb2YgdGhhdCBhbHRlcm5hdGl2ZSBpbiB0aGUgaW52b2NhdGlvbiB0byBjb21wdXRlSW5Qcm9kRm9sbG93c1xuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBmb3IgT1IoW2FsdDEsYWx0Ml0pIGFsdDIgd2lsbCBiZSBjb25zaWRlcmVkIGluICdyZXN0JyBvZiBhbHQxXG4gICAgICAgICAgICB2YXIgcHJvZFdyYXBwZXIgPSBuZXcgRmxhdCh7IGRlZmluaXRpb246IFthbHRdIH0pO1xuICAgICAgICAgICAgX3RoaXMud2Fsayhwcm9kV3JhcHBlciwgZnVsbE9yUmVzdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3RXYWxrZXI7XG59KCkpO1xuZXhwb3J0IHsgUmVzdFdhbGtlciB9O1xuZnVuY3Rpb24gcmVzdEZvclJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKHJlcFNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgIHZhciByZXBTZXBSZXN0ID0gW1xuICAgICAgICBuZXcgT3B0aW9uKHtcbiAgICAgICAgICAgIGRlZmluaXRpb246IFtcbiAgICAgICAgICAgICAgICBuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHJlcFNlcFByb2Quc2VwYXJhdG9yIH0pXG4gICAgICAgICAgICBdLmNvbmNhdChyZXBTZXBQcm9kLmRlZmluaXRpb24pXG4gICAgICAgIH0pXG4gICAgXTtcbiAgICB2YXIgZnVsbFJlcFNlcFJlc3QgPSByZXBTZXBSZXN0LmNvbmNhdChjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgIHJldHVybiBmdWxsUmVwU2VwUmVzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3QuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/grammar/rest.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js ***!
  \********************************************************************/
/*! exports provided: END_OF_FILE, DEFAULT_PARSER_CONFIG, DEFAULT_RULE_CONFIG, ParserDefinitionErrorType, EMPTY_ALT, Parser, CstParser, EmbeddedActionsParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"END_OF_FILE\", function() { return END_OF_FILE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_PARSER_CONFIG\", function() { return DEFAULT_PARSER_CONFIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_RULE_CONFIG\", function() { return DEFAULT_RULE_CONFIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParserDefinitionErrorType\", function() { return ParserDefinitionErrorType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_ALT\", function() { return EMPTY_ALT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CstParser\", function() { return CstParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmbeddedActionsParser\", function() { return EmbeddedActionsParser; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_follow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../grammar/follow */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/follow.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cst/cst */ \"./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js\");\n/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../errors_public */ \"./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../grammar/gast/gast_resolver_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_resolver_public.js\");\n/* harmony import */ var _traits_recoverable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./traits/recoverable */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js\");\n/* harmony import */ var _traits_looksahead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./traits/looksahead */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js\");\n/* harmony import */ var _traits_tree_builder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./traits/tree_builder */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js\");\n/* harmony import */ var _traits_lexer_adapter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./traits/lexer_adapter */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js\");\n/* harmony import */ var _traits_recognizer_api__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./traits/recognizer_api */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js\");\n/* harmony import */ var _traits_recognizer_engine__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./traits/recognizer_engine */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js\");\n/* harmony import */ var _traits_error_handler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./traits/error_handler */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js\");\n/* harmony import */ var _traits_context_assist__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./traits/context_assist */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js\");\n/* harmony import */ var _traits_gast_recorder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./traits/gast_recorder */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js\");\n/* harmony import */ var _traits_perf_tracer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./traits/perf_tracer */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar END_OF_FILE = Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__[\"createTokenInstance\"])(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__[\"EOF\"], \"\", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nvar DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 4,\n    ignoredIssues: {},\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: _errors_public__WEBPACK_IMPORTED_MODULE_4__[\"defaultParserErrorProvider\"],\n    nodeLocationTracking: \"none\",\n    traceInitPerf: false,\n    skipValidations: false\n});\nvar DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: function () { return undefined; },\n    resyncEnabled: true\n});\nvar ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"INVALID_NESTED_RULE_NAME\"] = 10] = \"INVALID_NESTED_RULE_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"DUPLICATE_NESTED_NAME\"] = 11] = \"DUPLICATE_NESTED_NAME\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"NO_NON_EMPTY_LOOKAHEAD\"] = 12] = \"NO_NON_EMPTY_LOOKAHEAD\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"AMBIGUOUS_PREFIX_ALTS\"] = 13] = \"AMBIGUOUS_PREFIX_ALTS\";\n    ParserDefinitionErrorType[ParserDefinitionErrorType[\"TOO_MANY_ALTS\"] = 14] = \"TOO_MANY_ALTS\";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value) {\n    if (value === void 0) { value = undefined; }\n    return function () {\n        return value;\n    };\n}\nvar Parser = /** @class */ (function () {\n    function Parser(tokenVocabulary, config) {\n        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }\n        this.ignoredIssues = DEFAULT_PARSER_CONFIG.ignoredIssues;\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        var that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        /* istanbul ignore if - complete over-kill to test this, we should only add a test when we actually hard deprecate it and throw an error... */\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"ignoredIssues\") &&\n            config.ignoredIssues !== DEFAULT_PARSER_CONFIG.ignoredIssues) {\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"PRINT_WARNING\"])(\"The <ignoredIssues> IParserConfig property is soft-deprecated and will be removed in future versions.\\n\\t\" +\n                \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\");\n        }\n        this.ignoredIssues = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"ignoredIssues\")\n            ? config.ignoredIssues\n            : DEFAULT_PARSER_CONFIG.ignoredIssues;\n        this.skipValidations = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"skipValidations\")\n            ? config.skipValidations\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    Parser.performSelfAnalysis = function (parserInstance) {\n        ;\n        parserInstance.performSelfAnalysis();\n    };\n    Parser.prototype.performSelfAnalysis = function () {\n        var _this = this;\n        this.TRACE_INIT(\"performSelfAnalysis\", function () {\n            var defErrorsMsgs;\n            _this.selfAnalysisDone = true;\n            var className = _this.className;\n            _this.TRACE_INIT(\"toFastProps\", function () {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"toFastProperties\"])(_this);\n            });\n            _this.TRACE_INIT(\"Grammar Recording\", function () {\n                try {\n                    _this.enableRecording();\n                    // Building the GAST\n                    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(_this.definedRulesNames, function (currRuleName) {\n                        var wrappedRule = _this[currRuleName];\n                        var originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                        var recordedRuleGast = undefined;\n                        _this.TRACE_INIT(currRuleName + \" Rule\", function () {\n                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    _this.disableRecording();\n                }\n            });\n            var resolverErrors = [];\n            _this.TRACE_INIT(\"Grammar Resolving\", function () {\n                resolverErrors = Object(_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_5__[\"resolveGrammar\"])({\n                    rules: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(_this.gastProductionsCache)\n                });\n                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors); // mutability for the win?\n            });\n            _this.TRACE_INIT(\"Grammar Validations\", function () {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(resolverErrors) && _this.skipValidations === false) {\n                    var validationErrors = Object(_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_5__[\"validateGrammar\"])({\n                        rules: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(_this.gastProductionsCache),\n                        maxLookahead: _this.maxLookahead,\n                        tokenTypes: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(_this.tokensMap),\n                        ignoredIssues: _this.ignoredIssues,\n                        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_4__[\"defaultGrammarValidatorErrorProvider\"],\n                        grammarName: className\n                    });\n                    _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors); // mutability for the win?\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(_this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (_this.recoveryEnabled) {\n                    _this.TRACE_INIT(\"computeAllProdsFollows\", function () {\n                        var allFollows = Object(_grammar_follow__WEBPACK_IMPORTED_MODULE_1__[\"computeAllProdsFollows\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(_this.gastProductionsCache));\n                        _this.resyncFollows = allFollows;\n                    });\n                }\n                _this.TRACE_INIT(\"ComputeLookaheadFunctions\", function () {\n                    _this.preComputeLookaheadFunctions(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(_this.gastProductionsCache));\n                });\n            }\n            _this.TRACE_INIT(\"expandAllNestedRuleNames\", function () {\n                // TODO: is this needed for EmbeddedActionsParser?\n                var cstAnalysisResult = Object(_cst_cst__WEBPACK_IMPORTED_MODULE_3__[\"expandAllNestedRuleNames\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(_this.gastProductionsCache), _this.fullRuleNameToShort);\n                _this.allRuleNames = cstAnalysisResult.allRuleNames;\n            });\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(_this.definitionErrors)) {\n                defErrorsMsgs = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(_this.definitionErrors, function (defError) { return defError.message; });\n                throw new Error(\"Parser Definition Errors detected:\\n \" + defErrorsMsgs.join(\"\\n-------------------------------\\n\"));\n            }\n        });\n    };\n    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n    // (normally during the parser's constructor).\n    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n    // for example: duplicate rule names, referencing an unresolved subrule, ect...\n    // This flag should not be enabled during normal usage, it is used in special situations, for example when\n    // needing to display the parser definition errors in some GUI(online playground).\n    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n    return Parser;\n}());\n\nObject(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"applyMixins\"])(Parser, [\n    _traits_recoverable__WEBPACK_IMPORTED_MODULE_6__[\"Recoverable\"],\n    _traits_looksahead__WEBPACK_IMPORTED_MODULE_7__[\"LooksAhead\"],\n    _traits_tree_builder__WEBPACK_IMPORTED_MODULE_8__[\"TreeBuilder\"],\n    _traits_lexer_adapter__WEBPACK_IMPORTED_MODULE_9__[\"LexerAdapter\"],\n    _traits_recognizer_engine__WEBPACK_IMPORTED_MODULE_11__[\"RecognizerEngine\"],\n    _traits_recognizer_api__WEBPACK_IMPORTED_MODULE_10__[\"RecognizerApi\"],\n    _traits_error_handler__WEBPACK_IMPORTED_MODULE_12__[\"ErrorHandler\"],\n    _traits_context_assist__WEBPACK_IMPORTED_MODULE_13__[\"ContentAssist\"],\n    _traits_gast_recorder__WEBPACK_IMPORTED_MODULE_14__[\"GastRecorder\"],\n    _traits_perf_tracer__WEBPACK_IMPORTED_MODULE_15__[\"PerformanceTracer\"]\n]);\nvar CstParser = /** @class */ (function (_super) {\n    __extends(CstParser, _super);\n    function CstParser(tokenVocabulary, config) {\n        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }\n        var _this = this;\n        var configClone = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"cloneObj\"])(config);\n        configClone.outputCst = true;\n        _this = _super.call(this, tokenVocabulary, configClone) || this;\n        return _this;\n    }\n    return CstParser;\n}(Parser));\n\nvar EmbeddedActionsParser = /** @class */ (function (_super) {\n    __extends(EmbeddedActionsParser, _super);\n    function EmbeddedActionsParser(tokenVocabulary, config) {\n        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }\n        var _this = this;\n        var configClone = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"cloneObj\"])(config);\n        configClone.outputCst = false;\n        _this = _super.call(this, tokenVocabulary, configClone) || this;\n        return _this;\n    }\n    return EmbeddedActionsParser;\n}(Parser));\n\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvcGFyc2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3BhcnNlci5qcz9mMTBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgYXBwbHlNaXhpbnMsIGNsb25lT2JqLCBmb3JFYWNoLCBoYXMsIGlzRW1wdHksIG1hcCwgUFJJTlRfV0FSTklORywgdG9GYXN0UHJvcGVydGllcywgdmFsdWVzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWxsUHJvZHNGb2xsb3dzIH0gZnJvbSBcIi4uL2dyYW1tYXIvZm9sbG93XCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljXCI7XG5pbXBvcnQgeyBleHBhbmRBbGxOZXN0ZWRSdWxlTmFtZXMgfSBmcm9tIFwiLi4vY3N0L2NzdFwiO1xuaW1wb3J0IHsgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLCBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi9lcnJvcnNfcHVibGljXCI7XG5pbXBvcnQgeyByZXNvbHZlR3JhbW1hciwgdmFsaWRhdGVHcmFtbWFyIH0gZnJvbSBcIi4uL2dyYW1tYXIvZ2FzdC9nYXN0X3Jlc29sdmVyX3B1YmxpY1wiO1xuaW1wb3J0IHsgUmVjb3ZlcmFibGUgfSBmcm9tIFwiLi90cmFpdHMvcmVjb3ZlcmFibGVcIjtcbmltcG9ydCB7IExvb2tzQWhlYWQgfSBmcm9tIFwiLi90cmFpdHMvbG9va3NhaGVhZFwiO1xuaW1wb3J0IHsgVHJlZUJ1aWxkZXIgfSBmcm9tIFwiLi90cmFpdHMvdHJlZV9idWlsZGVyXCI7XG5pbXBvcnQgeyBMZXhlckFkYXB0ZXIgfSBmcm9tIFwiLi90cmFpdHMvbGV4ZXJfYWRhcHRlclwiO1xuaW1wb3J0IHsgUmVjb2duaXplckFwaSB9IGZyb20gXCIuL3RyYWl0cy9yZWNvZ25pemVyX2FwaVwiO1xuaW1wb3J0IHsgUmVjb2duaXplckVuZ2luZSB9IGZyb20gXCIuL3RyYWl0cy9yZWNvZ25pemVyX2VuZ2luZVwiO1xuaW1wb3J0IHsgRXJyb3JIYW5kbGVyIH0gZnJvbSBcIi4vdHJhaXRzL2Vycm9yX2hhbmRsZXJcIjtcbmltcG9ydCB7IENvbnRlbnRBc3Npc3QgfSBmcm9tIFwiLi90cmFpdHMvY29udGV4dF9hc3Npc3RcIjtcbmltcG9ydCB7IEdhc3RSZWNvcmRlciB9IGZyb20gXCIuL3RyYWl0cy9nYXN0X3JlY29yZGVyXCI7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZVRyYWNlciB9IGZyb20gXCIuL3RyYWl0cy9wZXJmX3RyYWNlclwiO1xuZXhwb3J0IHZhciBFTkRfT0ZfRklMRSA9IGNyZWF0ZVRva2VuSW5zdGFuY2UoRU9GLCBcIlwiLCBOYU4sIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbk9iamVjdC5mcmVlemUoRU5EX09GX0ZJTEUpO1xuZXhwb3J0IHZhciBERUZBVUxUX1BBUlNFUl9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWNvdmVyeUVuYWJsZWQ6IGZhbHNlLFxuICAgIG1heExvb2thaGVhZDogNCxcbiAgICBpZ25vcmVkSXNzdWVzOiB7fSxcbiAgICBkeW5hbWljVG9rZW5zRW5hYmxlZDogZmFsc2UsXG4gICAgb3V0cHV0Q3N0OiB0cnVlLFxuICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcixcbiAgICBub2RlTG9jYXRpb25UcmFja2luZzogXCJub25lXCIsXG4gICAgdHJhY2VJbml0UGVyZjogZmFsc2UsXG4gICAgc2tpcFZhbGlkYXRpb25zOiBmYWxzZVxufSk7XG5leHBvcnQgdmFyIERFRkFVTFRfUlVMRV9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcbiAgICByZWNvdmVyeVZhbHVlRnVuYzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxuICAgIHJlc3luY0VuYWJsZWQ6IHRydWVcbn0pO1xuZXhwb3J0IHZhciBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlKSB7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9SVUxFX05BTUVcIl0gPSAwXSA9IFwiSU5WQUxJRF9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUlVMRV9OQU1FXCJdID0gMV0gPSBcIkRVUExJQ0FURV9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIl0gPSAyXSA9IFwiSU5WQUxJRF9SVUxFX09WRVJSSURFXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRFVQTElDQVRFX1BST0RVQ1RJT05TXCJdID0gM10gPSBcIkRVUExJQ0FURV9QUk9EVUNUSU9OU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVTT0xWRURfU1VCUlVMRV9SRUZcIl0gPSA0XSA9IFwiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFRlRfUkVDVVJTSU9OXCJdID0gNV0gPSBcIkxFRlRfUkVDVVJTSU9OXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9ORV9MQVNUX0VNUFRZX0FMVFwiXSA9IDZdID0gXCJOT05FX0xBU1RfRU1QVFlfQUxUXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQU1CSUdVT1VTX0FMVFNcIl0gPSA3XSA9IFwiQU1CSUdVT1VTX0FMVFNcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJDT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFXCJdID0gOF0gPSBcIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1RPS0VOX05BTUVcIl0gPSA5XSA9IFwiSU5WQUxJRF9UT0tFTl9OQU1FXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9ORVNURURfUlVMRV9OQU1FXCJdID0gMTBdID0gXCJJTlZBTElEX05FU1RFRF9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfTkVTVEVEX05BTUVcIl0gPSAxMV0gPSBcIkRVUExJQ0FURV9ORVNURURfTkFNRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk5PX05PTl9FTVBUWV9MT09LQUhFQURcIl0gPSAxMl0gPSBcIk5PX05PTl9FTVBUWV9MT09LQUhFQURcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJBTUJJR1VPVVNfUFJFRklYX0FMVFNcIl0gPSAxM10gPSBcIkFNQklHVU9VU19QUkVGSVhfQUxUU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlRPT19NQU5ZX0FMVFNcIl0gPSAxNF0gPSBcIlRPT19NQU5ZX0FMVFNcIjtcbn0pKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgfHwgKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIEVNUFRZX0FMVCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gREVGQVVMVF9QQVJTRVJfQ09ORklHOyB9XG4gICAgICAgIHRoaXMuaWdub3JlZElzc3VlcyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5pZ25vcmVkSXNzdWVzO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxmQW5hbHlzaXNEb25lID0gZmFsc2U7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhhdC5pbml0RXJyb3JIYW5kbGVyKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdExleGVyQWRhcHRlcigpO1xuICAgICAgICB0aGF0LmluaXRMb29rc0FoZWFkKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdFJlY29nbml6ZXJFbmdpbmUodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRSZWNvdmVyYWJsZShjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRUcmVlQnVpbGRlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRDb250ZW50QXNzaXN0KCk7XG4gICAgICAgIHRoYXQuaW5pdEdhc3RSZWNvcmRlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRQZXJmb3JtYW5jZVRyYWNlcihjb25maWcpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBjb21wbGV0ZSBvdmVyLWtpbGwgdG8gdGVzdCB0aGlzLCB3ZSBzaG91bGQgb25seSBhZGQgYSB0ZXN0IHdoZW4gd2UgYWN0dWFsbHkgaGFyZCBkZXByZWNhdGUgaXQgYW5kIHRocm93IGFuIGVycm9yLi4uICovXG4gICAgICAgIGlmIChoYXMoY29uZmlnLCBcImlnbm9yZWRJc3N1ZXNcIikgJiZcbiAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkSXNzdWVzICE9PSBERUZBVUxUX1BBUlNFUl9DT05GSUcuaWdub3JlZElzc3Vlcykge1xuICAgICAgICAgICAgUFJJTlRfV0FSTklORyhcIlRoZSA8aWdub3JlZElzc3Vlcz4gSVBhcnNlckNvbmZpZyBwcm9wZXJ0eSBpcyBzb2Z0LWRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0aGUgPElHTk9SRV9BTUJJR1VJVElFUz4gZmxhZyBvbiB0aGUgcmVsZXZhbnQgRFNMIG1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlnbm9yZWRJc3N1ZXMgPSBoYXMoY29uZmlnLCBcImlnbm9yZWRJc3N1ZXNcIilcbiAgICAgICAgICAgID8gY29uZmlnLmlnbm9yZWRJc3N1ZXNcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLmlnbm9yZWRJc3N1ZXM7XG4gICAgICAgIHRoaXMuc2tpcFZhbGlkYXRpb25zID0gaGFzKGNvbmZpZywgXCJza2lwVmFsaWRhdGlvbnNcIilcbiAgICAgICAgICAgID8gY29uZmlnLnNraXBWYWxpZGF0aW9uc1xuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcuc2tpcFZhbGlkYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQGRlcHJlY2F0ZWQgdXNlIHRoZSAqKmluc3RhbmNlKiogbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZSBpbnN0ZWFkXG4gICAgICovXG4gICAgUGFyc2VyLnBlcmZvcm1TZWxmQW5hbHlzaXMgPSBmdW5jdGlvbiAocGFyc2VySW5zdGFuY2UpIHtcbiAgICAgICAgO1xuICAgICAgICBwYXJzZXJJbnN0YW5jZS5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBlcmZvcm1TZWxmQW5hbHlzaXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcInBlcmZvcm1TZWxmQW5hbHlzaXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlZkVycm9yc01zZ3M7XG4gICAgICAgICAgICBfdGhpcy5zZWxmQW5hbHlzaXNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfdGhpcy5jbGFzc05hbWU7XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwidG9GYXN0UHJvcHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyB2b29kb28gbWFnaWMgdGhlIHBhcnNlciB3b3VsZCBiZSB4My14NCBzbG93ZXJcbiAgICAgICAgICAgICAgICAvLyBJdCBzZWVtcyBpdCBpcyBiZXR0ZXIgdG8gaW52b2tlIGB0b0Zhc3RQcm9wZXJ0aWVzYCAqKmJlZm9yZSoqXG4gICAgICAgICAgICAgICAgLy8gQW55IG1hbmlwdWxhdGlvbnMgb2YgdGhlIGB0aGlzYCBvYmplY3QgZG9uZSBkdXJpbmcgdGhlIHJlY29yZGluZyBwaGFzZS5cbiAgICAgICAgICAgICAgICB0b0Zhc3RQcm9wZXJ0aWVzKF90aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkdyYW1tYXIgUmVjb3JkaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmFibGVSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgdGhlIEdBU1RcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChfdGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgZnVuY3Rpb24gKGN1cnJSdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRSdWxlID0gX3RoaXNbY3VyclJ1bGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEdyYW1tYXJBY3Rpb24gPSB3cmFwcGVkUnVsZVtcIm9yaWdpbmFsR3JhbW1hckFjdGlvblwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRlZFJ1bGVHYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChjdXJyUnVsZU5hbWUgKyBcIiBSdWxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZFJ1bGVHYXN0ID0gX3RoaXMudG9wTGV2ZWxSdWxlUmVjb3JkKGN1cnJSdWxlTmFtZSwgb3JpZ2luYWxHcmFtbWFyQWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGVbY3VyclJ1bGVOYW1lXSA9IHJlY29yZGVkUnVsZUdhc3Q7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzYWJsZVJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlc29sdmVyRXJyb3JzID0gW107XG4gICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiR3JhbW1hciBSZXNvbHZpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyRXJyb3JzID0gcmVzb2x2ZUdyYW1tYXIoe1xuICAgICAgICAgICAgICAgICAgICBydWxlczogdmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseShfdGhpcy5kZWZpbml0aW9uRXJyb3JzLCByZXNvbHZlckVycm9ycyk7IC8vIG11dGFiaWxpdHkgZm9yIHRoZSB3aW4/XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFZhbGlkYXRpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWRkaXRpb25hbCBncmFtbWFyIHZhbGlkYXRpb25zIElGRiBubyByZXNvbHZpbmcgZXJyb3JzIGhhdmUgb2NjdXJyZWQuXG4gICAgICAgICAgICAgICAgLy8gYXMgdW5yZXNvbHZlZCBncmFtbWFyIG1heSBsZWFkIHRvIHVuaGFuZGxlZCBydW50aW1lIGV4Y2VwdGlvbnMgaW4gdGhlIGZvbGxvdyB1cCB2YWxpZGF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShyZXNvbHZlckVycm9ycykgJiYgX3RoaXMuc2tpcFZhbGlkYXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlR3JhbW1hcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlczogdmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heExvb2thaGVhZDogX3RoaXMubWF4TG9va2FoZWFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogdmFsdWVzKF90aGlzLnRva2Vuc01hcCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkSXNzdWVzOiBfdGhpcy5pZ25vcmVkSXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyTXNnUHJvdmlkZXI6IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW1tYXJOYW1lOiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseShfdGhpcy5kZWZpbml0aW9uRXJyb3JzLCB2YWxpZGF0aW9uRXJyb3JzKTsgLy8gbXV0YWJpbGl0eSBmb3IgdGhlIHdpbj9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgYW5hbHlzaXMgbWF5IGZhaWwgaWYgdGhlIGdyYW1tYXIgaXMgbm90IHBlcmZlY3RseSB2YWxpZFxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoX3RoaXMuZGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0cyBvZiB0aGVzZSBjb21wdXRhdGlvbnMgYXJlIG5vdCBuZWVkZWQgdW5sZXNzIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwiY29tcHV0ZUFsbFByb2RzRm9sbG93c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsRm9sbG93cyA9IGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModmFsdWVzKF90aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXN5bmNGb2xsb3dzID0gYWxsRm9sbG93cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyh2YWx1ZXMoX3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJleHBhbmRBbGxOZXN0ZWRSdWxlTmFtZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgbmVlZGVkIGZvciBFbWJlZGRlZEFjdGlvbnNQYXJzZXI/XG4gICAgICAgICAgICAgICAgdmFyIGNzdEFuYWx5c2lzUmVzdWx0ID0gZXhwYW5kQWxsTmVzdGVkUnVsZU5hbWVzKHZhbHVlcyhfdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksIF90aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFsbFJ1bGVOYW1lcyA9IGNzdEFuYWx5c2lzUmVzdWx0LmFsbFJ1bGVOYW1lcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFQYXJzZXIuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkcgJiZcbiAgICAgICAgICAgICAgICAhaXNFbXB0eShfdGhpcy5kZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGRlZkVycm9yc01zZ3MgPSBtYXAoX3RoaXMuZGVmaW5pdGlvbkVycm9ycywgZnVuY3Rpb24gKGRlZkVycm9yKSB7IHJldHVybiBkZWZFcnJvci5tZXNzYWdlOyB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgRGVmaW5pdGlvbiBFcnJvcnMgZGV0ZWN0ZWQ6XFxuIFwiICsgZGVmRXJyb3JzTXNncy5qb2luKFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gU2V0IHRoaXMgZmxhZyB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBQYXJzZXIgdG8gdGhyb3cgZXJyb3Igd2hlbiBwcm9ibGVtcyBpbiBpdCdzIGRlZmluaXRpb24gYXJlIGRldGVjdGVkLlxuICAgIC8vIChub3JtYWxseSBkdXJpbmcgdGhlIHBhcnNlcidzIGNvbnN0cnVjdG9yKS5cbiAgICAvLyBUaGlzIGlzIGEgZGVzaWduIHRpbWUgZmxhZywgaXQgd2lsbCBub3QgYWZmZWN0IHRoZSBydW50aW1lIGVycm9yIGhhbmRsaW5nIG9mIHRoZSBwYXJzZXIsIGp1c3QgZGVzaWduIHRpbWUgZXJyb3JzLFxuICAgIC8vIGZvciBleGFtcGxlOiBkdXBsaWNhdGUgcnVsZSBuYW1lcywgcmVmZXJlbmNpbmcgYW4gdW5yZXNvbHZlZCBzdWJydWxlLCBlY3QuLi5cbiAgICAvLyBUaGlzIGZsYWcgc2hvdWxkIG5vdCBiZSBlbmFibGVkIGR1cmluZyBub3JtYWwgdXNhZ2UsIGl0IGlzIHVzZWQgaW4gc3BlY2lhbCBzaXR1YXRpb25zLCBmb3IgZXhhbXBsZSB3aGVuXG4gICAgLy8gbmVlZGluZyB0byBkaXNwbGF5IHRoZSBwYXJzZXIgZGVmaW5pdGlvbiBlcnJvcnMgaW4gc29tZSBHVUkob25saW5lIHBsYXlncm91bmQpLlxuICAgIFBhcnNlci5ERUZFUl9ERUZJTklUSU9OX0VSUk9SU19IQU5ETElORyA9IGZhbHNlO1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuZXhwb3J0IHsgUGFyc2VyIH07XG5hcHBseU1peGlucyhQYXJzZXIsIFtcbiAgICBSZWNvdmVyYWJsZSxcbiAgICBMb29rc0FoZWFkLFxuICAgIFRyZWVCdWlsZGVyLFxuICAgIExleGVyQWRhcHRlcixcbiAgICBSZWNvZ25pemVyRW5naW5lLFxuICAgIFJlY29nbml6ZXJBcGksXG4gICAgRXJyb3JIYW5kbGVyLFxuICAgIENvbnRlbnRBc3Npc3QsXG4gICAgR2FzdFJlY29yZGVyLFxuICAgIFBlcmZvcm1hbmNlVHJhY2VyXG5dKTtcbnZhciBDc3RQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENzdFBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDc3RQYXJzZXIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRzsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnQ2xvbmUgPSBjbG9uZU9iaihjb25maWcpO1xuICAgICAgICBjb25maWdDbG9uZS5vdXRwdXRDc3QgPSB0cnVlO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnQ2xvbmUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENzdFBhcnNlcjtcbn0oUGFyc2VyKSk7XG5leHBvcnQgeyBDc3RQYXJzZXIgfTtcbnZhciBFbWJlZGRlZEFjdGlvbnNQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtYmVkZGVkQWN0aW9uc1BhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbWJlZGRlZEFjdGlvbnNQYXJzZXIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRzsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29uZmlnQ2xvbmUgPSBjbG9uZU9iaihjb25maWcpO1xuICAgICAgICBjb25maWdDbG9uZS5vdXRwdXRDc3QgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0b2tlblZvY2FidWxhcnksIGNvbmZpZ0Nsb25lKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBFbWJlZGRlZEFjdGlvbnNQYXJzZXI7XG59KFBhcnNlcikpO1xuZXhwb3J0IHsgRW1iZWRkZWRBY3Rpb25zUGFyc2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js ***!
  \***********************************************************************************/
/*! exports provided: ContentAssist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContentAssist\", function() { return ContentAssist; });\n/* harmony import */ var _grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../grammar/interpreter */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\n\nvar ContentAssist = /** @class */ (function () {\n    function ContentAssist() {\n    }\n    ContentAssist.prototype.initContentAssist = function () { };\n    ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {\n        var startRuleGast = this.gastProductionsCache[startRuleName];\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(startRuleGast)) {\n            throw Error(\"Rule ->\" + startRuleName + \"<- does not exist in this grammar.\");\n        }\n        return Object(_grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__[\"nextPossibleTokensAfter\"])([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    };\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {\n        var topRuleName = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"first\"])(grammarPath.ruleStack);\n        var gastProductions = this.getGAstProductions();\n        var topProduction = gastProductions[topRuleName];\n        var nextPossibleTokenTypes = new _grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__[\"NextAfterTokenWalker\"](topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    };\n    return ContentAssist;\n}());\n\n//# sourceMappingURL=context_assist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2NvbnRleHRfYXNzaXN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9jb250ZXh0X2Fzc2lzdC5qcz8zNjRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRBZnRlclRva2VuV2Fsa2VyLCBuZXh0UG9zc2libGVUb2tlbnNBZnRlciB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2ludGVycHJldGVyXCI7XG5pbXBvcnQgeyBmaXJzdCwgaXNVbmRlZmluZWQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbnZhciBDb250ZW50QXNzaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRlbnRBc3Npc3QoKSB7XG4gICAgfVxuICAgIENvbnRlbnRBc3Npc3QucHJvdG90eXBlLmluaXRDb250ZW50QXNzaXN0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENvbnRlbnRBc3Npc3QucHJvdG90eXBlLmNvbXB1dGVDb250ZW50QXNzaXN0ID0gZnVuY3Rpb24gKHN0YXJ0UnVsZU5hbWUsIHByZWNlZGluZ0lucHV0KSB7XG4gICAgICAgIHZhciBzdGFydFJ1bGVHYXN0ID0gdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZVtzdGFydFJ1bGVOYW1lXTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHN0YXJ0UnVsZUdhc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJ1bGUgLT5cIiArIHN0YXJ0UnVsZU5hbWUgKyBcIjwtIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgZ3JhbW1hci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKFtzdGFydFJ1bGVHYXN0XSwgcHJlY2VkaW5nSW5wdXQsIHRoaXMudG9rZW5NYXRjaGVyLCB0aGlzLm1heExvb2thaGVhZCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBhIG1lbWJlciBtZXRob2Qgb3IgYSB1dGlsaXR5PyBpdCBkb2VzIG5vdCBoYXZlIGFueSBzdGF0ZSBvciB1c2FnZSBvZiAndGhpcycuLi5cbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBtb3JlIGV4cGxpY2l0bHkgcGFydCBvZiB0aGUgcHVibGljIEFQST9cbiAgICBDb250ZW50QXNzaXN0LnByb3RvdHlwZS5nZXROZXh0UG9zc2libGVUb2tlblR5cGVzID0gZnVuY3Rpb24gKGdyYW1tYXJQYXRoKSB7XG4gICAgICAgIHZhciB0b3BSdWxlTmFtZSA9IGZpcnN0KGdyYW1tYXJQYXRoLnJ1bGVTdGFjayk7XG4gICAgICAgIHZhciBnYXN0UHJvZHVjdGlvbnMgPSB0aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpO1xuICAgICAgICB2YXIgdG9wUHJvZHVjdGlvbiA9IGdhc3RQcm9kdWN0aW9uc1t0b3BSdWxlTmFtZV07XG4gICAgICAgIHZhciBuZXh0UG9zc2libGVUb2tlblR5cGVzID0gbmV3IE5leHRBZnRlclRva2VuV2Fsa2VyKHRvcFByb2R1Y3Rpb24sIGdyYW1tYXJQYXRoKS5zdGFydFdhbGtpbmcoKTtcbiAgICAgICAgcmV0dXJuIG5leHRQb3NzaWJsZVRva2VuVHlwZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udGVudEFzc2lzdDtcbn0oKSk7XG5leHBvcnQgeyBDb250ZW50QXNzaXN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0X2Fzc2lzdC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/context_assist.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js ***!
  \**********************************************************************************/
/*! exports provided: ErrorHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ErrorHandler\", function() { return ErrorHandler; });\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../exceptions_public */ \"./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../grammar/lookahead */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n    }\n    ErrorHandler.prototype.initErrorHandler = function (config) {\n        this._errors = [];\n        this.errorMessageProvider = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"defaults\"])(config.errorMessageProvider, _parser__WEBPACK_IMPORTED_MODULE_3__[\"DEFAULT_PARSER_CONFIG\"].errorMessageProvider);\n    };\n    ErrorHandler.prototype.SAVE_ERROR = function (error) {\n        if (Object(_exceptions_public__WEBPACK_IMPORTED_MODULE_0__[\"isRecognitionException\"])(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    };\n    Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n        // TODO: extract these methods to ErrorHandler Trait?\n        get: function () {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(this._errors);\n        },\n        set: function (newErrors) {\n            this._errors = newErrors;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        var lookAheadPathsPerAlternative = Object(_grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__[\"getLookaheadPathsForOptionalProd\"])(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        var insideProdPaths = lookAheadPathsPerAlternative[0];\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_0__[\"EarlyExitException\"](msg, this.LA(1), this.LA(0)));\n    };\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        var lookAheadPathsPerAlternative = Object(_grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__[\"getLookaheadPathsForOr\"])(occurrence, ruleGrammar, this.maxLookahead);\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var previousToken = this.LA(0);\n        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_0__[\"NoViableAltException\"](errMsg, this.LA(1), previousToken));\n    };\n    return ErrorHandler;\n}());\n\n//# sourceMappingURL=error_handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2Vycm9yX2hhbmRsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2Vycm9yX2hhbmRsZXIuanM/NTFiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFYXJseUV4aXRFeGNlcHRpb24sIGlzUmVjb2duaXRpb25FeGNlcHRpb24sIE5vVmlhYmxlQWx0RXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljXCI7XG5pbXBvcnQgeyBjbG9uZUFyciwgZGVmYXVsdHMgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kLCBnZXRMb29rYWhlYWRQYXRoc0Zvck9yIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvbG9va2FoZWFkXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGZvciBydW50aW1lIHBhcnNpbmcgZXJyb3JzLlxuICovXG52YXIgRXJyb3JIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcigpIHtcbiAgICB9XG4gICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5pbml0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlciA9IGRlZmF1bHRzKGNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlciwgREVGQVVMVF9QQVJTRVJfQ09ORklHLmVycm9yTWVzc2FnZVByb3ZpZGVyKTtcbiAgICB9O1xuICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuU0FWRV9FUlJPUiA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlcnJvcikpIHtcbiAgICAgICAgICAgIGVycm9yLmNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiB0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSxcbiAgICAgICAgICAgICAgICBydWxlT2NjdXJyZW5jZVN0YWNrOiBjbG9uZUFycih0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRyeWluZyB0byBzYXZlIGFuIEVycm9yIHdoaWNoIGlzIG5vdCBhIFJlY29nbml0aW9uRXhjZXB0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JIYW5kbGVyLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAvLyBUT0RPOiBleHRyYWN0IHRoZXNlIG1ldGhvZHMgdG8gRXJyb3JIYW5kbGVyIFRyYWl0P1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZUFycih0aGlzLl9lcnJvcnMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdFcnJvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IG5ld0Vycm9ycztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgY2FjaGluZyB0aGUgZXJyb3IgbWVzc2FnZSBjb21wdXRlZCBpbmZvcm1hdGlvblxuICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUucmFpc2VFYXJseUV4aXRFeGNlcHRpb24gPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgcHJvZFR5cGUsIHVzZXJEZWZpbmVkRXJyTXNnKSB7XG4gICAgICAgIHZhciBydWxlTmFtZSA9IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO1xuICAgICAgICB2YXIgcnVsZUdyYW1tYXIgPSB0aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpW3J1bGVOYW1lXTtcbiAgICAgICAgdmFyIGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmUgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICAgICAgdmFyIGluc2lkZVByb2RQYXRocyA9IGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmVbMF07XG4gICAgICAgIHZhciBhY3R1YWxUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5tYXhMb29rYWhlYWQ7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsVG9rZW5zLnB1c2godGhpcy5MQShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKHtcbiAgICAgICAgICAgIGV4cGVjdGVkSXRlcmF0aW9uUGF0aHM6IGluc2lkZVByb2RQYXRocyxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuTEEoMCksXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IHVzZXJEZWZpbmVkRXJyTXNnLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IEVhcmx5RXhpdEV4Y2VwdGlvbihtc2csIHRoaXMuTEEoMSksIHRoaXMuTEEoMCkpKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGNvbnNpZGVyIGNhY2hpbmcgdGhlIGVycm9yIG1lc3NhZ2UgY29tcHV0ZWQgaW5mb3JtYXRpb25cbiAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJhaXNlTm9BbHRFeGNlcHRpb24gPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgZXJyTXNnVHlwZXMpIHtcbiAgICAgICAgdmFyIHJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIHZhciBydWxlR3JhbW1hciA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKClbcnVsZU5hbWVdO1xuICAgICAgICAvLyBUT0RPOiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yIGNhbiBiZSBzbG93IGZvciBsYXJnZSBlbm91Z2ggbWF4TG9va2FoZWFkIGFuZCBjZXJ0YWluIGdyYW1tYXJzLCBjb25zaWRlciBjYWNoaW5nID9cbiAgICAgICAgdmFyIGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmUgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCB0aGlzLm1heExvb2thaGVhZCk7XG4gICAgICAgIHZhciBhY3R1YWxUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdGhpcy5tYXhMb29rYWhlYWQ7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsVG9rZW5zLnB1c2godGhpcy5MQShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzVG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICB2YXIgZXJyTXNnID0gdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vVmlhYmxlQWx0TWVzc2FnZSh7XG4gICAgICAgICAgICBleHBlY3RlZFBhdGhzUGVyQWx0OiBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlLFxuICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWxUb2tlbnMsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNUb2tlbixcbiAgICAgICAgICAgIGN1c3RvbVVzZXJEZXNjcmlwdGlvbjogZXJyTXNnVHlwZXMsXG4gICAgICAgICAgICBydWxlTmFtZTogdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24oZXJyTXNnLCB0aGlzLkxBKDEpLCBwcmV2aW91c1Rva2VuKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xufSgpKTtcbmV4cG9ydCB7IEVycm9ySGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfaGFuZGxlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/error_handler.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js ***!
  \**********************************************************************************/
/*! exports provided: GastRecorder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GastRecorder\", function() { return GastRecorder; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../grammar/gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n/* harmony import */ var _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scan/lexer_public */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scan/tokens */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../grammar/keys */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n\n\n\n\n\n\n\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, _grammar_keys__WEBPACK_IMPORTED_MODULE_6__[\"BITS_FOR_OCCURRENCE_IDX\"]) - 1;\nvar RFT = Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__[\"createToken\"])({ name: \"RECORDING_PHASE_TOKEN\", pattern: _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__[\"Lexer\"].NA });\nObject(_scan_tokens__WEBPACK_IMPORTED_MODULE_3__[\"augmentTokenTypes\"])([RFT]);\nvar RECORDING_PHASE_TOKEN = Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__[\"createTokenInstance\"])(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\" + idx] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\" + idx] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\" + idx] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\" + idx] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete _this[\"CONSUME\" + idx];\n                delete _this[\"SUBRULE\" + idx];\n                delete _this[\"OPTION\" + idx];\n                delete _this[\"OR\" + idx];\n                delete _this[\"MANY\" + idx];\n                delete _this[\"MANY_SEP\" + idx];\n                delete _this[\"AT_LEAST_ONE\" + idx];\n                delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n            }\n            delete _this[\"consume\"];\n            delete _this[\"subrule\"];\n            delete _this[\"option\"];\n            delete _this[\"or\"];\n            delete _this[\"many\"];\n            delete _this[\"atLeastOne\"];\n            delete _this.ACTION;\n            delete _this.BACKTRACK;\n            delete _this.LA;\n        });\n    };\n    // TODO: is there any way to use this method to check no\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n        return;\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return _parser__WEBPACK_IMPORTED_MODULE_5__[\"END_OF_FILE\"];\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Rule\"]({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Option\"], actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatory\"], actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionMandatoryWithSeparator\"], options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Repetition\"], actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"RepetitionWithSeparator\"], options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"peek\"])(this.recordingProdStack);\n        var ruleName = ruleToCall[\"ruleName\"];\n        var newNoneTerminal = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"NonTerminal\"]({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!Object(_scan_tokens__WEBPACK_IMPORTED_MODULE_3__[\"hasShortKeyProperty\"])(tokType)) {\n            var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"peek\"])(this.recordingProdStack);\n        var newNoneTerminal = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Terminal\"]({\n            idx: occurrence,\n            terminalType: tokType\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\n\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"peek\"])(this.recordingProdStack);\n    var grammarAction = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(mainProdArg)\n        ? mainProdArg\n        : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(mainProdArg, \"NAME\")) {\n        newProd.name = mainProdArg.NAME;\n    }\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"peek\"])(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Alternation\"]({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(mainProdArg, \"NAME\")) {\n        newOrProd.name = mainProdArg.NAME;\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"some\"])(alts, function (currAlt) { return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(alts, function (currAlt) {\n        var currAltFlat = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__[\"Flat\"]({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(currAlt, \"NAME\")) {\n            currAltFlat.name = currAlt.NAME;\n        }\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" +\n            (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX +\n                1)));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2dhc3RfcmVjb3JkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2dhc3RfcmVjb3JkZXIuanM/MDkwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRnVuY3Rpb24sIHBlZWssIHNvbWUgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBGbGF0LCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJ1bGUsIFRlcm1pbmFsIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpY1wiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi9sZXhlcl9wdWJsaWNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzLCBoYXNTaG9ydEtleVByb3BlcnR5IH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zXCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbiwgY3JlYXRlVG9rZW5JbnN0YW5jZSB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWNcIjtcbmltcG9ydCB7IEVORF9PRl9GSUxFIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuaW1wb3J0IHsgQklUU19GT1JfT0NDVVJSRU5DRV9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzXCI7XG52YXIgUkVDT1JESU5HX05VTExfT0JKRUNUID0ge1xuICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgT2JqZWN0IGluZGljYXRlcyB0aGUgUGFyc2VyIGlzIGR1cmluZyBSZWNvcmRpbmcgUGhhc2VcIlxufTtcbk9iamVjdC5mcmVlemUoUkVDT1JESU5HX05VTExfT0JKRUNUKTtcbnZhciBIQU5ETEVfU0VQQVJBVE9SID0gdHJ1ZTtcbnZhciBNQVhfTUVUSE9EX0lEWCA9IE1hdGgucG93KDIsIEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYKSAtIDE7XG52YXIgUkZUID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIlJFQ09SRElOR19QSEFTRV9UT0tFTlwiLCBwYXR0ZXJuOiBMZXhlci5OQSB9KTtcbmF1Z21lbnRUb2tlblR5cGVzKFtSRlRdKTtcbnZhciBSRUNPUkRJTkdfUEhBU0VfVE9LRU4gPSBjcmVhdGVUb2tlbkluc3RhbmNlKFJGVCwgXCJUaGlzIElUb2tlbiBpbmRpY2F0ZXMgdGhlIFBhcnNlciBpcyBpbiBSZWNvcmRpbmcgUGhhc2VcXG5cXHRcIiArXG4gICAgXCJcIiArXG4gICAgXCJTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIiwgXG4vLyBVc2luZyBcIi0xXCIgaW5zdGVhZCBvZiBOYU4gKGFzIGluIEVPRikgYmVjYXVzZSBhbiBhY3R1YWwgbnVtYmVyIGlzIGxlc3MgbGlrZWx5IHRvXG4vLyBjYXVzZSBlcnJvcnMgaWYgdGhlIG91dHB1dCBvZiBMQSBvciBDT05TVU1FIHdvdWxkIGJlIChpbmNvcnJlY3RseSkgdXNlZCBkdXJpbmcgdGhlIHJlY29yZGluZyBwaGFzZS5cbi0xLCAtMSwgLTEsIC0xLCAtMSwgLTEpO1xuT2JqZWN0LmZyZWV6ZShSRUNPUkRJTkdfUEhBU0VfVE9LRU4pO1xudmFyIFJFQ09SRElOR19QSEFTRV9DU1ROT0RFID0ge1xuICAgIG5hbWU6IFwiVGhpcyBDU1ROb2RlIGluZGljYXRlcyB0aGUgUGFyc2VyIGlzIGluIFJlY29yZGluZyBQaGFzZVxcblxcdFwiICtcbiAgICAgICAgXCJTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIixcbiAgICBjaGlsZHJlbjoge31cbn07XG4vKipcbiAqIFRoaXMgdHJhaXQgaGFuZGxlcyB0aGUgY3JlYXRpb24gb2YgdGhlIEdBU1Qgc3RydWN0dXJlIGZvciBDaGV2cm90YWluIEdyYW1tYXJzXG4gKi9cbnZhciBHYXN0UmVjb3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2FzdFJlY29yZGVyKCkge1xuICAgIH1cbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmluaXRHYXN0UmVjb3JkZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuUkVDT1JESU5HX1BIQVNFID0gZmFsc2U7XG4gICAgfTtcbiAgICBHYXN0UmVjb3JkZXIucHJvdG90eXBlLmVuYWJsZVJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5SRUNPUkRJTkdfUEhBU0UgPSB0cnVlO1xuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJFbmFibGUgUmVjb3JkaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gaSA+IDAgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIkNPTlNVTUVcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWxSZWNvcmQoYXJnMSwgaSwgYXJnMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIlNVQlJVTEVcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWxSZWNvcmQoYXJnMSwgaSwgYXJnMik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIk9QVElPTlwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsUmVjb3JkKGFyZzEsIGkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJPUlwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWxSZWNvcmQoYXJnMSwgaSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpc1tcIk1BTllcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiTUFOWV9TRVBcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXNbXCJBVF9MRUFTVF9PTkVcIiArIGlkeF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzW1wiQVRfTEVBU1RfT05FX1NFUFwiICsgaWR4XSA9IGZ1bmN0aW9uIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdhcm5pbmcgRGFyayBWb29kb28gTWFnaWMgdXBjb21pbmchXG4gICAgICAgICAgICAgKiBXZSBhcmUgXCJyZXBsYWNpbmdcIiB0aGUgcHVibGljIHBhcnNpbmcgRFNMIG1ldGhvZHMgQVBJXG4gICAgICAgICAgICAgKiBXaXRoICoqbmV3KiogYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb25zIG9uIHRoZSBQYXJzZXIgKippbnN0YW5jZSoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU28gZmFyIHRoaXMgaXMgdGhlIG9ubHkgd2F5IEkndmUgZm91bmQgdG8gYXZvaWQgcGVyZm9ybWFuY2UgcmVncmVzc2lvbnMgZHVyaW5nIHBhcnNpbmcgdGltZS5cbiAgICAgICAgICAgICAqIC0gQXBwcm94IDMwJSBwZXJmb3JtYW5jZSByZWdyZXNzaW9uIHdhcyBtZWFzdXJlZCBvbiBDaHJvbWUgNzUgQ2FuYXJ5IHdoZW4gYXR0ZW1wdGluZyB0byByZXBsYWNlIHRoZSBcImludGVybmFsXCJcbiAgICAgICAgICAgICAqICAgaW1wbGVtZW50YXRpb25zIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEU0wgbWV0aG9kcyB3aXRoIHRoZSBpZHgoc3VmZml4KSBhcyBhbiBhcmd1bWVudFxuICAgICAgICAgICAgX3RoaXNbXCJjb25zdW1lXCJdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgsIGFyZzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wic3VicnVsZVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4LCBhcmcyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpc1tcIm9wdGlvblwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wib3JcIl0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wibWFueVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzW1wiYXRMZWFzdE9uZVwiXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLkFDVElPTiA9IF90aGlzLkFDVElPTl9SRUNPUkQ7XG4gICAgICAgICAgICBfdGhpcy5CQUNLVFJBQ0sgPSBfdGhpcy5CQUNLVFJBQ0tfUkVDT1JEO1xuICAgICAgICAgICAgX3RoaXMuTEEgPSBfdGhpcy5MQV9SRUNPUkQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5kaXNhYmxlUmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgICAgICAvLyBCeSBkZWxldGluZyB0aGVzZSAqKmluc3RhbmNlKiogcHJvcGVydGllcywgYW55IGZ1dHVyZSBpbnZvY2F0aW9uXG4gICAgICAgIC8vIHdpbGwgYmUgZGVmZXJyZWQgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZHMgb24gdGhlICoqcHJvdG90eXBlKiogb2JqZWN0XG4gICAgICAgIC8vIFRoaXMgc2VlbXMgdG8gZ2V0IHJpZCBvZiBhbnkgaW5jb3JyZWN0IG9wdGltaXphdGlvbnMgdGhhdCBWOCBtYXlcbiAgICAgICAgLy8gZG8gZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkRlbGV0aW5nIFJlY29yZGluZyBtZXRob2RzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBpID4gMCA/IGkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcIkNPTlNVTUVcIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiU1VCUlVMRVwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJPUFRJT05cIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiT1JcIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiTUFOWVwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJNQU5ZX1NFUFwiICsgaWR4XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJBVF9MRUFTVF9PTkVcIiArIGlkeF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiQVRfTEVBU1RfT05FX1NFUFwiICsgaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpc1tcImNvbnN1bWVcIl07XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJzdWJydWxlXCJdO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wib3B0aW9uXCJdO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wib3JcIl07XG4gICAgICAgICAgICBkZWxldGUgX3RoaXNbXCJtYW55XCJdO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzW1wiYXRMZWFzdE9uZVwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5BQ1RJT047XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuQkFDS1RSQUNLO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLkxBO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGlzIHRoZXJlIGFueSB3YXkgdG8gdXNlIHRoaXMgbWV0aG9kIHRvIGNoZWNrIG5vXG4gICAgLy8gICBQYXJzZXIgbWV0aG9kcyBhcmUgY2FsbGVkIGluc2lkZSBhbiBBQ1RJT04/XG4gICAgLy8gICBNYXliZSB0cnkvY2F0Y2gvZmluYWxseSBvbiBBQ1RJT05TIHdoaWxlIGRpc2FibGluZyB0aGUgcmVjb3JkZXJzIHN0YXRlIGNoYW5nZXM/XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5BQ1RJT05fUkVDT1JEID0gZnVuY3Rpb24gKGltcGwpIHtcbiAgICAgICAgLy8gTk8tT1AgZHVyaW5nIHJlY29yZGluZ1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvLyBFeGVjdXRpbmcgYmFja3RyYWNraW5nIGxvZ2ljIHdpbGwgYnJlYWsgb3VyIHJlY29yZGluZyBsb2dpYyBhc3N1bXB0aW9uc1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuQkFDS1RSQUNLX1JFQ09SRCA9IGZ1bmN0aW9uIChncmFtbWFyUnVsZSwgYXJncykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICB9O1xuICAgIC8vIExBIGlzIHBhcnQgb2YgdGhlIG9mZmljaWFsIEFQSSBhbmQgbWF5IGJlIHVzZWQgZm9yIGN1c3RvbSBsb29rYWhlYWQgbG9naWNcbiAgICAvLyBieSBlbmQgdXNlcnMgd2hvIG1heSBmb3JnZXQgdG8gd3JhcCBpdCBpbiBBQ1RJT04gb3IgaW5zaWRlIGEgR0FURVxuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuTEFfUkVDT1JEID0gZnVuY3Rpb24gKGhvd011Y2gpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSB0aGUgUkVDT1JEX1BIQVNFX1RPS0VOIGhlcmUgYmVjYXVzZSBzb21lb25lIG1heSBkZXBlbmRcbiAgICAgICAgLy8gT24gTEEgcmV0dXJuIEVPRiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBzbyBhbiBpbmZpbml0ZSBsb29wIG1heSBvY2N1ci5cbiAgICAgICAgcmV0dXJuIEVORF9PRl9GSUxFO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS50b3BMZXZlbFJ1bGVSZWNvcmQgPSBmdW5jdGlvbiAobmFtZSwgZGVmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbmV3VG9wTGV2ZWxSdWxlID0gbmV3IFJ1bGUoeyBkZWZpbml0aW9uOiBbXSwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIG5ld1RvcExldmVsUnVsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3VG9wTGV2ZWxSdWxlKTtcbiAgICAgICAgICAgIGRlZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9wTGV2ZWxSdWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG5cXHQgVGhpcyBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgXCJncmFtbWFyIHJlY29yZGluZyBwaGFzZVwiIEZvciBtb3JlIGluZm8gc2VlOlxcblxcdCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9pbnRlcm5hbHMuaHRtbCNncmFtbWFyLXJlY29yZGluZ1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAobXV0YWJpbGl0eUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG1heSBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIG9yaWdpbmFsIGVycm9yIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG9yaWdpbmFsRXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIHBhcnNpbmcgRFNMXG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5vcHRpb25JbnRlcm5hbFJlY29yZCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSkge1xuICAgICAgICByZXR1cm4gcmVjb3JkUHJvZC5jYWxsKHRoaXMsIE9wdGlvbiwgYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25NYW5kYXRvcnksIGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICByZWNvcmRQcm9kLmNhbGwodGhpcywgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIG9wdGlvbnMsIG9jY3VycmVuY2UsIEhBTkRMRV9TRVBBUkFUT1IpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5tYW55SW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb24sIGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIEdhc3RSZWNvcmRlci5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAob2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICByZWNvcmRQcm9kLmNhbGwodGhpcywgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIG9wdGlvbnMsIG9jY3VycmVuY2UsIEhBTkRMRV9TRVBBUkFUT1IpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5vckludGVybmFsUmVjb3JkID0gZnVuY3Rpb24gKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZE9yUHJvZC5jYWxsKHRoaXMsIGFsdHNPck9wdHMsIG9jY3VycmVuY2UpO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5zdWJydWxlSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgICAgICBpZiAoIXJ1bGVUb0NhbGwgfHwgaGFzKHJ1bGVUb0NhbGwsIFwicnVsZU5hbWVcIikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCI8U1VCUlVMRVwiICsgZ2V0SWR4U3VmZml4KG9jY3VycmVuY2UpICsgXCI+IGFyZ3VtZW50IGlzIGludmFsaWRcIiArXG4gICAgICAgICAgICAgICAgKFwiIGV4cGVjdGluZyBhIFBhcnNlciBtZXRob2QgcmVmZXJlbmNlIGJ1dCBnb3Q6IDxcIiArIEpTT04uc3RyaW5naWZ5KHJ1bGVUb0NhbGwpICsgXCI+XCIpICtcbiAgICAgICAgICAgICAgICAoXCJcXG4gaW5zaWRlIHRvcCBsZXZlbCBydWxlOiA8XCIgKyB0aGlzLnJlY29yZGluZ1Byb2RTdGFja1swXS5uYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICAgIGVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SID0gdHJ1ZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgICAgICB2YXIgcnVsZU5hbWUgPSBydWxlVG9DYWxsW1wicnVsZU5hbWVcIl07XG4gICAgICAgIHZhciBuZXdOb25lVGVybWluYWwgPSBuZXcgTm9uVGVybWluYWwoe1xuICAgICAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgbm9uVGVybWluYWxOYW1lOiBydWxlTmFtZSxcbiAgICAgICAgICAgIC8vIFRoZSByZXNvbHZpbmcgb2YgdGhlIGByZWZlcmVuY2VkUnVsZWAgcHJvcGVydHkgd2lsbCBiZSBkb25lIG9uY2UgYWxsIHRoZSBSdWxlJ3MgR0FTVHMgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgIHJlZmVyZW5jZWRSdWxlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdOb25lVGVybWluYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRDc3RcbiAgICAgICAgICAgID8gUkVDT1JESU5HX1BIQVNFX0NTVE5PREVcbiAgICAgICAgICAgIDogUkVDT1JESU5HX05VTExfT0JKRUNUO1xuICAgIH07XG4gICAgR2FzdFJlY29yZGVyLnByb3RvdHlwZS5jb25zdW1lSW50ZXJuYWxSZWNvcmQgPSBmdW5jdGlvbiAodG9rVHlwZSwgb2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgICAgICBpZiAoIWhhc1Nob3J0S2V5UHJvcGVydHkodG9rVHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIjxDT05TVU1FXCIgKyBnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSkgKyBcIj4gYXJndW1lbnQgaXMgaW52YWxpZFwiICtcbiAgICAgICAgICAgICAgICAoXCIgZXhwZWN0aW5nIGEgVG9rZW5UeXBlIHJlZmVyZW5jZSBidXQgZ290OiA8XCIgKyBKU09OLnN0cmluZ2lmeSh0b2tUeXBlKSArIFwiPlwiKSArXG4gICAgICAgICAgICAgICAgKFwiXFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPFwiICsgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2tbMF0ubmFtZSArIFwiPlwiKSk7XG4gICAgICAgICAgICBlcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldlByb2QgPSBwZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICAgICAgdmFyIG5ld05vbmVUZXJtaW5hbCA9IG5ldyBUZXJtaW5hbCh7XG4gICAgICAgICAgICBpZHg6IG9jY3VycmVuY2UsXG4gICAgICAgICAgICB0ZXJtaW5hbFR5cGU6IHRva1R5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdOb25lVGVybWluYWwpO1xuICAgICAgICByZXR1cm4gUkVDT1JESU5HX1BIQVNFX1RPS0VOO1xuICAgIH07XG4gICAgcmV0dXJuIEdhc3RSZWNvcmRlcjtcbn0oKSk7XG5leHBvcnQgeyBHYXN0UmVjb3JkZXIgfTtcbmZ1bmN0aW9uIHJlY29yZFByb2QocHJvZENvbnN0cnVjdG9yLCBtYWluUHJvZEFyZywgb2NjdXJyZW5jZSwgaGFuZGxlU2VwKSB7XG4gICAgaWYgKGhhbmRsZVNlcCA9PT0gdm9pZCAwKSB7IGhhbmRsZVNlcCA9IGZhbHNlOyB9XG4gICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICB2YXIgcHJldlByb2QgPSBwZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICB2YXIgZ3JhbW1hckFjdGlvbiA9IGlzRnVuY3Rpb24obWFpblByb2RBcmcpXG4gICAgICAgID8gbWFpblByb2RBcmdcbiAgICAgICAgOiBtYWluUHJvZEFyZy5ERUY7XG4gICAgdmFyIG5ld1Byb2QgPSBuZXcgcHJvZENvbnN0cnVjdG9yKHsgZGVmaW5pdGlvbjogW10sIGlkeDogb2NjdXJyZW5jZSB9KTtcbiAgICBpZiAoaGFzKG1haW5Qcm9kQXJnLCBcIk5BTUVcIikpIHtcbiAgICAgICAgbmV3UHJvZC5uYW1lID0gbWFpblByb2RBcmcuTkFNRTtcbiAgICB9XG4gICAgaWYgKGhhbmRsZVNlcCkge1xuICAgICAgICBuZXdQcm9kLnNlcGFyYXRvciA9IG1haW5Qcm9kQXJnLlNFUDtcbiAgICB9XG4gICAgaWYgKGhhcyhtYWluUHJvZEFyZywgXCJNQVhfTE9PS0FIRUFEXCIpKSB7XG4gICAgICAgIG5ld1Byb2QubWF4TG9va2FoZWFkID0gbWFpblByb2RBcmcuTUFYX0xPT0tBSEVBRDtcbiAgICB9XG4gICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChuZXdQcm9kKTtcbiAgICBncmFtbWFyQWN0aW9uLmNhbGwodGhpcyk7XG4gICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld1Byb2QpO1xuICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG59XG5mdW5jdGlvbiByZWNvcmRPclByb2QobWFpblByb2RBcmcsIG9jY3VycmVuY2UpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGFzc2VydE1ldGhvZElkeElzVmFsaWQob2NjdXJyZW5jZSk7XG4gICAgdmFyIHByZXZQcm9kID0gcGVlayh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayk7XG4gICAgLy8gT25seSBhbiBhcnJheSBvZiBhbHRlcm5hdGl2ZXNcbiAgICB2YXIgaGFzT3B0aW9ucyA9IGlzQXJyYXkobWFpblByb2RBcmcpID09PSBmYWxzZTtcbiAgICB2YXIgYWx0cyA9IGhhc09wdGlvbnMgPT09IGZhbHNlID8gbWFpblByb2RBcmcgOiBtYWluUHJvZEFyZy5ERUY7XG4gICAgdmFyIG5ld09yUHJvZCA9IG5ldyBBbHRlcm5hdGlvbih7XG4gICAgICAgIGRlZmluaXRpb246IFtdLFxuICAgICAgICBpZHg6IG9jY3VycmVuY2UsXG4gICAgICAgIGlnbm9yZUFtYmlndWl0aWVzOiBoYXNPcHRpb25zICYmIG1haW5Qcm9kQXJnLklHTk9SRV9BTUJJR1VJVElFUyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChoYXMobWFpblByb2RBcmcsIFwiTkFNRVwiKSkge1xuICAgICAgICBuZXdPclByb2QubmFtZSA9IG1haW5Qcm9kQXJnLk5BTUU7XG4gICAgfVxuICAgIGlmIChoYXMobWFpblByb2RBcmcsIFwiTUFYX0xPT0tBSEVBRFwiKSkge1xuICAgICAgICBuZXdPclByb2QubWF4TG9va2FoZWFkID0gbWFpblByb2RBcmcuTUFYX0xPT0tBSEVBRDtcbiAgICB9XG4gICAgdmFyIGhhc1ByZWRpY2F0ZXMgPSBzb21lKGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7IHJldHVybiBpc0Z1bmN0aW9uKGN1cnJBbHQuR0FURSk7IH0pO1xuICAgIG5ld09yUHJvZC5oYXNQcmVkaWNhdGVzID0gaGFzUHJlZGljYXRlcztcbiAgICBwcmV2UHJvZC5kZWZpbml0aW9uLnB1c2gobmV3T3JQcm9kKTtcbiAgICBmb3JFYWNoKGFsdHMsIGZ1bmN0aW9uIChjdXJyQWx0KSB7XG4gICAgICAgIHZhciBjdXJyQWx0RmxhdCA9IG5ldyBGbGF0KHsgZGVmaW5pdGlvbjogW10gfSk7XG4gICAgICAgIG5ld09yUHJvZC5kZWZpbml0aW9uLnB1c2goY3VyckFsdEZsYXQpO1xuICAgICAgICBpZiAoaGFzKGN1cnJBbHQsIFwiTkFNRVwiKSkge1xuICAgICAgICAgICAgY3VyckFsdEZsYXQubmFtZSA9IGN1cnJBbHQuTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzKGN1cnJBbHQsIFwiSUdOT1JFX0FNQklHVUlUSUVTXCIpKSB7XG4gICAgICAgICAgICBjdXJyQWx0RmxhdC5pZ25vcmVBbWJpZ3VpdGllcyA9IGN1cnJBbHQuSUdOT1JFX0FNQklHVUlUSUVTO1xuICAgICAgICB9XG4gICAgICAgIC8vICoqaW1wbGljaXQqKiBpZ25vcmVBbWJpZ3VpdGllcyBkdWUgdG8gdXNhZ2Ugb2YgZ2F0ZVxuICAgICAgICBlbHNlIGlmIChoYXMoY3VyckFsdCwgXCJHQVRFXCIpKSB7XG4gICAgICAgICAgICBjdXJyQWx0RmxhdC5pZ25vcmVBbWJpZ3VpdGllcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2goY3VyckFsdEZsYXQpO1xuICAgICAgICBjdXJyQWx0LkFMVC5jYWxsKF90aGlzKTtcbiAgICAgICAgX3RoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnBvcCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG59XG5mdW5jdGlvbiBnZXRJZHhTdWZmaXgoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA9PT0gMCA/IFwiXCIgOiBcIlwiICsgaWR4O1xufVxuZnVuY3Rpb24gYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMCB8fCBpZHggPiBNQVhfTUVUSE9EX0lEWCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRoZSBzdGFjayB0cmFjZSB3aWxsIGNvbnRhaW4gYWxsIHRoZSBuZWVkZWQgZGV0YWlsc1xuICAgICAgICBcIkludmFsaWQgRFNMIE1ldGhvZCBpZHggdmFsdWU6IDxcIiArIGlkeCArIFwiPlxcblxcdFwiICtcbiAgICAgICAgICAgIChcIklkeCB2YWx1ZSBtdXN0IGJlIGEgbm9uZSBuZWdhdGl2ZSB2YWx1ZSBzbWFsbGVyIHRoYW4gXCIgKyAoTUFYX01FVEhPRF9JRFggK1xuICAgICAgICAgICAgICAgIDEpKSk7XG4gICAgICAgIGVycm9yLktOT1dOX1JFQ09SREVSX0VSUk9SID0gdHJ1ZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9yZWNvcmRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/gast_recorder.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js ***!
  \**********************************************************************************/
/*! exports provided: LexerAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LexerAdapter\", function() { return LexerAdapter; });\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nvar LexerAdapter = /** @class */ (function () {\n    function LexerAdapter() {\n    }\n    LexerAdapter.prototype.initLexerAdapter = function () {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    };\n    Object.defineProperty(LexerAdapter.prototype, \"input\", {\n        get: function () {\n            return this.tokVector;\n        },\n        set: function (newInput) {\n            if (this.selfAnalysisDone !== true) {\n                throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n            }\n            this.reset();\n            this.tokVector = newInput;\n            this.tokVectorLength = newInput.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // skips a token and returns the next token\n    LexerAdapter.prototype.SKIP_TOKEN = function () {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return _parser__WEBPACK_IMPORTED_MODULE_0__[\"END_OF_FILE\"];\n        }\n    };\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LexerAdapter.prototype.LA = function (howMuch) {\n        var soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return _parser__WEBPACK_IMPORTED_MODULE_0__[\"END_OF_FILE\"];\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    };\n    LexerAdapter.prototype.consumeToken = function () {\n        this.currIdx++;\n    };\n    LexerAdapter.prototype.exportLexerState = function () {\n        return this.currIdx;\n    };\n    LexerAdapter.prototype.importLexerState = function (newState) {\n        this.currIdx = newState;\n    };\n    LexerAdapter.prototype.resetLexerState = function () {\n        this.currIdx = -1;\n    };\n    LexerAdapter.prototype.moveToTerminatedState = function () {\n        this.currIdx = this.tokVector.length - 1;\n    };\n    LexerAdapter.prototype.getLexerPosition = function () {\n        return this.exportLexerState();\n    };\n    return LexerAdapter;\n}());\n\n//# sourceMappingURL=lexer_adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xleGVyX2FkYXB0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xleGVyX2FkYXB0ZXIuanM/MzUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTkRfT0ZfRklMRSB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgYWJzdHJhY3Rpbmcgb3ZlciB0aGUgaW50ZXJhY3Rpb24gd2l0aCBMZXhlciBvdXRwdXQgKFRva2VuIHZlY3RvcikuXG4gKlxuICogVGhpcyBjb3VsZCBiZSBnZW5lcmFsaXplZCB0byBzdXBwb3J0IG90aGVyIGtpbmRzIG9mIGxleGVycywgZS5nLlxuICogLSBKdXN0IGluIFRpbWUgTGV4aW5nIC8gTGV4ZXItTGVzcyBwYXJzaW5nLlxuICogLSBTdHJlYW1pbmcgTGV4ZXIuXG4gKi9cbnZhciBMZXhlckFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXJBZGFwdGVyKCkge1xuICAgIH1cbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmluaXRMZXhlckFkYXB0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG9rVmVjdG9yID0gW107XG4gICAgICAgIHRoaXMudG9rVmVjdG9yTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gLTE7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXJBZGFwdGVyLnByb3RvdHlwZSwgXCJpbnB1dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rVmVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdJbnB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWlzc2luZyA8cGVyZm9ybVNlbGZBbmFseXNpcz4gaW52b2NhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBQYXJzZXIncyBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnRva1ZlY3RvciA9IG5ld0lucHV0O1xuICAgICAgICAgICAgdGhpcy50b2tWZWN0b3JMZW5ndGggPSBuZXdJbnB1dC5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIHNraXBzIGEgdG9rZW4gYW5kIHJldHVybnMgdGhlIG5leHQgdG9rZW5cbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLlNLSVBfVE9LRU4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJJZHggPD0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEVORF9PRl9GSUxFO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBMZXhlciAoYWNjZXNzaW5nIFRva2VuIHZlY3RvcikgcmVsYXRlZCBtZXRob2RzIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIHRvIGltcGxlbWVudCBsYXp5IGxleGVyc1xuICAgIC8vIG9yIGxleGVycyBkZXBlbmRlbnQgb24gcGFyc2VyIGNvbnRleHQuXG4gICAgTGV4ZXJBZGFwdGVyLnByb3RvdHlwZS5MQSA9IGZ1bmN0aW9uIChob3dNdWNoKSB7XG4gICAgICAgIHZhciBzb3VnaHRJZHggPSB0aGlzLmN1cnJJZHggKyBob3dNdWNoO1xuICAgICAgICBpZiAoc291Z2h0SWR4IDwgMCB8fCB0aGlzLnRva1ZlY3Rvckxlbmd0aCA8PSBzb3VnaHRJZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBFTkRfT0ZfRklMRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva1ZlY3Rvcltzb3VnaHRJZHhdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmNvbnN1bWVUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4Kys7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmV4cG9ydExleGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJJZHg7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLmltcG9ydExleGVyU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLnJlc2V0TGV4ZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gLTE7XG4gICAgfTtcbiAgICBMZXhlckFkYXB0ZXIucHJvdG90eXBlLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jdXJySWR4ID0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMTtcbiAgICB9O1xuICAgIExleGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0TGV4ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyQWRhcHRlcjtcbn0oKSk7XG5leHBvcnQgeyBMZXhlckFkYXB0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyX2FkYXB0ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js ***!
  \*******************************************************************************/
/*! exports provided: LooksAhead */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LooksAhead\", function() { return LooksAhead; });\n/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../grammar/lookahead */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/keys */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n/* harmony import */ var _grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../grammar/gast/gast */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast.js\");\n\n\n\n\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */ (function () {\n    function LooksAhead() {\n    }\n    LooksAhead.prototype.initLooksAhead = function (config) {\n        this.dynamicTokensEnabled = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"has\"])(config, \"dynamicTokensEnabled\")\n            ? config.dynamicTokensEnabled\n            : _parser__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_PARSER_CONFIG\"].dynamicTokensEnabled;\n        this.maxLookahead = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"has\"])(config, \"maxLookahead\")\n            ? config.maxLookahead\n            : _parser__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_PARSER_CONFIG\"].maxLookahead;\n        /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n        this.lookAheadFuncsCache = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isES2015MapSupported\"])() ? new Map() : [];\n        // Performance optimization on newer engines that support ES6 Map\n        // For larger Maps this is slightly faster than using a plain object (array in our case).\n        /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isES2015MapSupported\"])()) {\n            this.getLaFuncFromCache = this.getLaFuncFromMap;\n            this.setLaFuncCache = this.setLaFuncCacheUsingMap;\n        }\n        else {\n            this.getLaFuncFromCache = this.getLaFuncFromObj;\n            this.setLaFuncCache = this.setLaFuncUsingObj;\n        }\n    };\n    LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n        var _this = this;\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(rules, function (currRule) {\n            _this.TRACE_INIT(currRule.name + \" Rule Lookahead\", function () {\n                var _a = Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"collectMethods\"])(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(alternation, function (currProd) {\n                    var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                    _this.TRACE_INIT(\"\" + Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"getProductionDslName\"])(currProd) + prodIdx, function () {\n                        var laFunc = Object(_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"buildLookaheadFuncForOr\"])(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);\n                        var key = Object(_grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"getKeyForAutomaticLookahead\"])(_this.fullRuleNameToShort[currRule.name], _grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"OR_IDX\"], currProd.idx);\n                        _this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(repetition, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"MANY_IDX\"], _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"PROD_TYPE\"].REPETITION, currProd.maxLookahead, Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"getProductionDslName\"])(currProd));\n                });\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(option, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"OPTION_IDX\"], _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"PROD_TYPE\"].OPTION, currProd.maxLookahead, Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"getProductionDslName\"])(currProd));\n                });\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(repetitionMandatory, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"AT_LEAST_ONE_IDX\"], _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"PROD_TYPE\"].REPETITION_MANDATORY, currProd.maxLookahead, Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"getProductionDslName\"])(currProd));\n                });\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(repetitionMandatoryWithSeparator, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"AT_LEAST_ONE_SEP_IDX\"], _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"PROD_TYPE\"].REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"getProductionDslName\"])(currProd));\n                });\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(repetitionWithSeparator, function (currProd) {\n                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"MANY_SEP_IDX\"], _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"PROD_TYPE\"].REPETITION_WITH_SEPARATOR, currProd.maxLookahead, Object(_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__[\"getProductionDslName\"])(currProd));\n                });\n            });\n        });\n    };\n    LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        var _this = this;\n        this.TRACE_INIT(\"\" + dslMethodName + (prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n            var laFunc = Object(_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"buildLookaheadFuncForOptionalProd\"])(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);\n            var key = Object(_grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"getKeyForAutomaticLookahead\"])(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            _this.setLaFuncCache(key, laFunc);\n        });\n    };\n    LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {\n        return Object(_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"buildSingleAlternativeLookaheadFunction\"])(alt, tokenMatcher, dynamicTokensEnabled);\n    };\n    LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n        return Object(_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__[\"buildAlternativesLookAheadFunc\"])(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n    };\n    // this actually returns a number, but it is always used as a string (object prop key)\n    LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        return Object(_grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"getKeyForAutomaticLookahead\"])(currRuleShortName, dslMethodIdx, occurrence);\n    };\n    /* istanbul ignore next */\n    LooksAhead.prototype.getLaFuncFromCache = function (key) {\n        return undefined;\n    };\n    LooksAhead.prototype.getLaFuncFromMap = function (key) {\n        return this.lookAheadFuncsCache.get(key);\n    };\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    LooksAhead.prototype.getLaFuncFromObj = function (key) {\n        return this.lookAheadFuncsCache[key];\n    };\n    /* istanbul ignore next */\n    LooksAhead.prototype.setLaFuncCache = function (key, value) { };\n    LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    };\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {\n        this.lookAheadFuncsCache[key] = value;\n    };\n    return LooksAhead;\n}());\n\n//# sourceMappingURL=looksahead.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xvb2tzYWhlYWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xvb2tzYWhlYWQuanM/MGYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMsIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZCwgYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IsIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbiwgUFJPRF9UWVBFIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvbG9va2FoZWFkXCI7XG5pbXBvcnQgeyBmb3JFYWNoLCBoYXMsIGlzRVMyMDE1TWFwU3VwcG9ydGVkIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBBVF9MRUFTVF9PTkVfSURYLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkLCBNQU5ZX0lEWCwgTUFOWV9TRVBfSURYLCBPUFRJT05fSURYLCBPUl9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzXCI7XG5pbXBvcnQgeyBjb2xsZWN0TWV0aG9kcywgZ2V0UHJvZHVjdGlvbkRzbE5hbWUgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9nYXN0L2dhc3RcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHRoZSBsb29rYWhlYWQgcmVsYXRlZCB1dGlsaXRpZXMgYW5kIG9wdGltaXphdGlvbnMuXG4gKi9cbnZhciBMb29rc0FoZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvb2tzQWhlYWQoKSB7XG4gICAgfVxuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLmluaXRMb29rc0FoZWFkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkID0gaGFzKGNvbmZpZywgXCJkeW5hbWljVG9rZW5zRW5hYmxlZFwiKVxuICAgICAgICAgICAgPyBjb25maWcuZHluYW1pY1Rva2Vuc0VuYWJsZWRcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLmR5bmFtaWNUb2tlbnNFbmFibGVkO1xuICAgICAgICB0aGlzLm1heExvb2thaGVhZCA9IGhhcyhjb25maWcsIFwibWF4TG9va2FoZWFkXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5tYXhMb29rYWhlYWRcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLm1heExvb2thaGVhZDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBVc2luZyBwbGFpbiBhcnJheSBhcyBkaWN0aW9uYXJ5IHdpbGwgYmUgdGVzdGVkIG9uIG9sZGVyIG5vZGUuanMgdmVyc2lvbnMgYW5kIElFMTEgKi9cbiAgICAgICAgdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlID0gaXNFUzIwMTVNYXBTdXBwb3J0ZWQoKSA/IG5ldyBNYXAoKSA6IFtdO1xuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gb24gbmV3ZXIgZW5naW5lcyB0aGF0IHN1cHBvcnQgRVM2IE1hcFxuICAgICAgICAvLyBGb3IgbGFyZ2VyIE1hcHMgdGhpcyBpcyBzbGlnaHRseSBmYXN0ZXIgdGhhbiB1c2luZyBhIHBsYWluIG9iamVjdCAoYXJyYXkgaW4gb3VyIGNhc2UpLlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIFRoZSBlbHNlIGJyYW5jaCB3aWxsIGJlIHRlc3RlZCBvbiBvbGRlciBub2RlLmpzIHZlcnNpb25zIGFuZCBJRTExICovXG4gICAgICAgIGlmIChpc0VTMjAxNU1hcFN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldExhRnVuY0Zyb21DYWNoZSA9IHRoaXMuZ2V0TGFGdW5jRnJvbU1hcDtcbiAgICAgICAgICAgIHRoaXMuc2V0TGFGdW5jQ2FjaGUgPSB0aGlzLnNldExhRnVuY0NhY2hlVXNpbmdNYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldExhRnVuY0Zyb21DYWNoZSA9IHRoaXMuZ2V0TGFGdW5jRnJvbU9iajtcbiAgICAgICAgICAgIHRoaXMuc2V0TGFGdW5jQ2FjaGUgPSB0aGlzLnNldExhRnVuY1VzaW5nT2JqO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5wcmVDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZvckVhY2gocnVsZXMsIGZ1bmN0aW9uIChjdXJyUnVsZSkge1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChjdXJyUnVsZS5uYW1lICsgXCIgUnVsZSBMb29rYWhlYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvbGxlY3RNZXRob2RzKGN1cnJSdWxlKSwgYWx0ZXJuYXRpb24gPSBfYS5hbHRlcm5hdGlvbiwgcmVwZXRpdGlvbiA9IF9hLnJlcGV0aXRpb24sIG9wdGlvbiA9IF9hLm9wdGlvbiwgcmVwZXRpdGlvbk1hbmRhdG9yeSA9IF9hLnJlcGV0aXRpb25NYW5kYXRvcnksIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yID0gX2EucmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yID0gX2EucmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChhbHRlcm5hdGlvbiwgZnVuY3Rpb24gKGN1cnJQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9kSWR4ID0gY3VyclByb2QuaWR4ID09PSAwID8gXCJcIiA6IGN1cnJQcm9kLmlkeDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIlwiICsgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpICsgcHJvZElkeCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhRnVuYyA9IGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yKGN1cnJQcm9kLmlkeCwgY3VyclJ1bGUsIGN1cnJQcm9kLm1heExvb2thaGVhZCB8fCBfdGhpcy5tYXhMb29rYWhlYWQsIGN1cnJQcm9kLmhhc1ByZWRpY2F0ZXMsIF90aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLCBfdGhpcy5sb29rQWhlYWRCdWlsZGVyRm9yQWx0ZXJuYXRpdmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoX3RoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtjdXJyUnVsZS5uYW1lXSwgT1JfSURYLCBjdXJyUHJvZC5pZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0TGFGdW5jQ2FjaGUoa2V5LCBsYUZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb24sIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBNQU5ZX0lEWCwgUFJPRF9UWVBFLlJFUEVUSVRJT04sIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKG9wdGlvbiwgZnVuY3Rpb24gKGN1cnJQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVMb29rYWhlYWRGdW5jKGN1cnJSdWxlLCBjdXJyUHJvZC5pZHgsIE9QVElPTl9JRFgsIFBST0RfVFlQRS5PUFRJT04sIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25NYW5kYXRvcnksIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBBVF9MRUFTVF9PTkVfSURYLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBmdW5jdGlvbiAoY3VyclByb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgQVRfTEVBU1RfT05FX1NFUF9JRFgsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvckVhY2gocmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIGZ1bmN0aW9uIChjdXJyUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBNQU5ZX1NFUF9JRFgsIFBST0RfVFlQRS5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5jb21wdXRlTG9va2FoZWFkRnVuYyA9IGZ1bmN0aW9uIChydWxlLCBwcm9kT2NjdXJyZW5jZSwgcHJvZEtleSwgcHJvZFR5cGUsIHByb2RNYXhMb29rYWhlYWQsIGRzbE1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiXCIgKyBkc2xNZXRob2ROYW1lICsgKHByb2RPY2N1cnJlbmNlID09PSAwID8gXCJcIiA6IHByb2RPY2N1cnJlbmNlKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxhRnVuYyA9IGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZChwcm9kT2NjdXJyZW5jZSwgcnVsZSwgcHJvZE1heExvb2thaGVhZCB8fCBfdGhpcy5tYXhMb29rYWhlYWQsIF90aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLCBwcm9kVHlwZSwgX3RoaXMubG9va0FoZWFkQnVpbGRlckZvck9wdGlvbmFsKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoX3RoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtydWxlLm5hbWVdLCBwcm9kS2V5LCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRMYUZ1bmNDYWNoZShrZXksIGxhRnVuYyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUubG9va0FoZWFkQnVpbGRlckZvck9wdGlvbmFsID0gZnVuY3Rpb24gKGFsdCwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uKGFsdCwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG4gICAgfTtcbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5sb29rQWhlYWRCdWlsZGVyRm9yQWx0ZXJuYXRpdmVzID0gZnVuY3Rpb24gKGFsdHMsIGhhc1ByZWRpY2F0ZXMsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyhhbHRzLCBoYXNQcmVkaWNhdGVzLCB0b2tlbk1hdGNoZXIsIGR5bmFtaWNUb2tlbnNFbmFibGVkKTtcbiAgICB9O1xuICAgIC8vIHRoaXMgYWN0dWFsbHkgcmV0dXJucyBhIG51bWJlciwgYnV0IGl0IGlzIGFsd2F5cyB1c2VkIGFzIGEgc3RyaW5nIChvYmplY3QgcHJvcCBrZXkpXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkID0gZnVuY3Rpb24gKGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSkge1xuICAgICAgICB2YXIgY3VyclJ1bGVTaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChjdXJyUnVsZVNob3J0TmFtZSwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKTtcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbUNhY2hlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbU1hcCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5nZXQoa2V5KTtcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gVXNpbmcgcGxhaW4gYXJyYXkgYXMgZGljdGlvbmFyeSB3aWxsIGJlIHRlc3RlZCBvbiBvbGRlciBub2RlLmpzIHZlcnNpb25zIGFuZCBJRTExICovXG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuZ2V0TGFGdW5jRnJvbU9iaiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZVtrZXldO1xuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBMb29rc0FoZWFkLnByb3RvdHlwZS5zZXRMYUZ1bmNDYWNoZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7IH07XG4gICAgTG9va3NBaGVhZC5wcm90b3R5cGUuc2V0TGFGdW5jQ2FjaGVVc2luZ01hcCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFVzaW5nIHBsYWluIGFycmF5IGFzIGRpY3Rpb25hcnkgd2lsbCBiZSB0ZXN0ZWQgb24gb2xkZXIgbm9kZS5qcyB2ZXJzaW9ucyBhbmQgSUUxMSAqL1xuICAgIExvb2tzQWhlYWQucHJvdG90eXBlLnNldExhRnVuY1VzaW5nT2JqID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBMb29rc0FoZWFkO1xufSgpKTtcbmV4cG9ydCB7IExvb2tzQWhlYWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb2tzYWhlYWQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/looksahead.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js ***!
  \********************************************************************************/
/*! exports provided: PerformanceTracer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PerformanceTracer\", function() { return PerformanceTracer; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar PerformanceTracer = /** @class */ (function () {\n    function PerformanceTracer() {\n    }\n    PerformanceTracer.prototype.initPerformanceTracer = function (config) {\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"traceInitPerf\")) {\n            var userTraceInitPerf = config.traceInitPerf;\n            var traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf;\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = _parser__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_PARSER_CONFIG\"].traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    };\n    PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"timer\"])(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    return PerformanceTracer;\n}());\n\n//# sourceMappingURL=perf_tracer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3BlcmZfdHJhY2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9wZXJmX3RyYWNlci5qcz84MGE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhcywgdGltZXIgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHJ1bnRpbWUgcGFyc2luZyBlcnJvcnMuXG4gKi9cbnZhciBQZXJmb3JtYW5jZVRyYWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZXJmb3JtYW5jZVRyYWNlcigpIHtcbiAgICB9XG4gICAgUGVyZm9ybWFuY2VUcmFjZXIucHJvdG90eXBlLmluaXRQZXJmb3JtYW5jZVRyYWNlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKGhhcyhjb25maWcsIFwidHJhY2VJbml0UGVyZlwiKSkge1xuICAgICAgICAgICAgdmFyIHVzZXJUcmFjZUluaXRQZXJmID0gY29uZmlnLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgICAgICB2YXIgdHJhY2VJc051bWJlciA9IHR5cGVvZiB1c2VyVHJhY2VJbml0UGVyZiA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZlxuICAgICAgICAgICAgICAgIDogSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZiA+IDBcbiAgICAgICAgICAgICAgICA6IHVzZXJUcmFjZUluaXRQZXJmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRNYXhJZGVudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSBERUZBVUxUX1BBUlNFUl9DT05GSUcudHJhY2VJbml0UGVyZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCA9IC0xO1xuICAgIH07XG4gICAgUGVyZm9ybWFuY2VUcmFjZXIucHJvdG90eXBlLlRSQUNFX0lOSVQgPSBmdW5jdGlvbiAocGhhc2VEZXNjLCBwaGFzZUltcGwpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBvcHRpbWl6ZSB0aGlzIHVzaW5nIE5PT1AgcGF0dGVybiBiZWNhdXNlXG4gICAgICAgIC8vIEl0IGlzIG5vdCBjYWxsZWQgaW4gYSBob3Qgc3BvdC4uLlxuICAgICAgICBpZiAodGhpcy50cmFjZUluaXRQZXJmID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCsrO1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IG5ldyBBcnJheSh0aGlzLnRyYWNlSW5pdEluZGVudCArIDEpLmpvaW4oXCJcXHRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRJbmRlbnQgPCB0aGlzLnRyYWNlSW5pdE1heElkZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50ICsgXCItLT4gPFwiICsgcGhhc2VEZXNjICsgXCI+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gdGltZXIocGhhc2VJbXBsKSwgdGltZSA9IF9hLnRpbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIERpZmZpY3VsdCB0byByZXByb2R1Y2Ugc3BlY2lmaWMgcGVyZm9ybWFuY2UgYmVoYXZpb3IgKD4xMG1zKSBpbiB0ZXN0cyAqL1xuICAgICAgICAgICAgdmFyIHRyYWNlTWV0aG9kID0gdGltZSA+IDEwID8gY29uc29sZS53YXJuIDogY29uc29sZS5sb2c7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRJbmRlbnQgPCB0aGlzLnRyYWNlSW5pdE1heElkZW50KSB7XG4gICAgICAgICAgICAgICAgdHJhY2VNZXRob2QoaW5kZW50ICsgXCI8LS0gPFwiICsgcGhhc2VEZXNjICsgXCI+IHRpbWU6IFwiICsgdGltZSArIFwibXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudC0tO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBoYXNlSW1wbCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGVyZm9ybWFuY2VUcmFjZXI7XG59KCkpO1xuZXhwb3J0IHsgUGVyZm9ybWFuY2VUcmFjZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZfdHJhY2VyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/perf_tracer.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js ***!
  \***********************************************************************************/
/*! exports provided: RecognizerApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecognizerApi\", function() { return RecognizerApi; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../exceptions_public */ \"./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors_public */ \"./node_modules/chevrotain/lib_esm/src/parse/errors_public.js\");\n/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../grammar/checks */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/checks.js\");\n/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../grammar/gast/gast_public */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/gast/gast_public.js\");\n\n\n\n\n\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nvar RecognizerApi = /** @class */ (function () {\n    function RecognizerApi() {\n    }\n    RecognizerApi.prototype.ACTION = function (impl) {\n        return impl.call(this);\n    };\n    RecognizerApi.prototype.consume = function (idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    };\n    RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    };\n    RecognizerApi.prototype.option = function (idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    };\n    RecognizerApi.prototype.or = function (idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    };\n    RecognizerApi.prototype.many = function (idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    };\n    RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    };\n    RecognizerApi.prototype.CONSUME = function (tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    };\n    RecognizerApi.prototype.CONSUME1 = function (tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    };\n    RecognizerApi.prototype.CONSUME2 = function (tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    };\n    RecognizerApi.prototype.CONSUME3 = function (tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    };\n    RecognizerApi.prototype.CONSUME4 = function (tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    };\n    RecognizerApi.prototype.CONSUME5 = function (tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    };\n    RecognizerApi.prototype.CONSUME6 = function (tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    };\n    RecognizerApi.prototype.CONSUME7 = function (tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    };\n    RecognizerApi.prototype.CONSUME8 = function (tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    };\n    RecognizerApi.prototype.CONSUME9 = function (tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    };\n    RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    };\n    RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    };\n    RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    };\n    RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    };\n    RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    };\n    RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    };\n    RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    };\n    RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    };\n    RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    };\n    RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    };\n    RecognizerApi.prototype.OPTION = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    };\n    RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    };\n    RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    };\n    RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    };\n    RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    };\n    RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    };\n    RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    };\n    RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    };\n    RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    };\n    RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    };\n    RecognizerApi.prototype.OR = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    };\n    RecognizerApi.prototype.OR1 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    };\n    RecognizerApi.prototype.OR2 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    };\n    RecognizerApi.prototype.OR3 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    };\n    RecognizerApi.prototype.OR4 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    };\n    RecognizerApi.prototype.OR5 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    };\n    RecognizerApi.prototype.OR6 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    };\n    RecognizerApi.prototype.OR7 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    };\n    RecognizerApi.prototype.OR8 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    };\n    RecognizerApi.prototype.OR9 = function (altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    };\n    RecognizerApi.prototype.MANY = function (actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    };\n    RecognizerApi.prototype.MANY_SEP = function (options) {\n        this.manySepFirstInternal(0, options);\n    };\n    RecognizerApi.prototype.MANY_SEP1 = function (options) {\n        this.manySepFirstInternal(1, options);\n    };\n    RecognizerApi.prototype.MANY_SEP2 = function (options) {\n        this.manySepFirstInternal(2, options);\n    };\n    RecognizerApi.prototype.MANY_SEP3 = function (options) {\n        this.manySepFirstInternal(3, options);\n    };\n    RecognizerApi.prototype.MANY_SEP4 = function (options) {\n        this.manySepFirstInternal(4, options);\n    };\n    RecognizerApi.prototype.MANY_SEP5 = function (options) {\n        this.manySepFirstInternal(5, options);\n    };\n    RecognizerApi.prototype.MANY_SEP6 = function (options) {\n        this.manySepFirstInternal(6, options);\n    };\n    RecognizerApi.prototype.MANY_SEP7 = function (options) {\n        this.manySepFirstInternal(7, options);\n    };\n    RecognizerApi.prototype.MANY_SEP8 = function (options) {\n        this.manySepFirstInternal(8, options);\n    };\n    RecognizerApi.prototype.MANY_SEP9 = function (options) {\n        this.manySepFirstInternal(9, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    };\n    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    };\n    RecognizerApi.prototype.RULE = function (name, implementation, config) {\n        if (config === void 0) { config = _parser__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_RULE_CONFIG\"]; }\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(this.definedRulesNames, name)) {\n            var errMsg = _errors_public__WEBPACK_IMPORTED_MODULE_3__[\"defaultGrammarValidatorErrorProvider\"].buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className\n            });\n            var error = {\n                message: errMsg,\n                type: _parser__WEBPACK_IMPORTED_MODULE_2__[\"ParserDefinitionErrorType\"].DUPLICATE_RULE_NAME,\n                ruleName: name\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        var ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    };\n    RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {\n        if (config === void 0) { config = _parser__WEBPACK_IMPORTED_MODULE_2__[\"DEFAULT_RULE_CONFIG\"]; }\n        var ruleErrors = [];\n        ruleErrors = ruleErrors.concat(Object(_grammar_checks__WEBPACK_IMPORTED_MODULE_4__[\"validateRuleIsOverridden\"])(name, this.definedRulesNames, this.className));\n        this.definitionErrors.push.apply(this.definitionErrors, ruleErrors); // mutability for the win\n        var ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    };\n    RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            var orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if (Object(_exceptions_public__WEBPACK_IMPORTED_MODULE_1__[\"isRecognitionException\"])(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    };\n    // GAST export APIs\n    RecognizerApi.prototype.getGAstProductions = function () {\n        return this.gastProductionsCache;\n    };\n    RecognizerApi.prototype.getSerializedGastProductions = function () {\n        return Object(_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_5__[\"serializeGrammar\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(this.gastProductionsCache));\n    };\n    return RecognizerApi;\n}());\n\n//# sourceMappingURL=recognizer_api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY29nbml6ZXJfYXBpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvZ25pemVyX2FwaS5qcz9kZDY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbnRhaW5zLCB2YWx1ZXMgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvdXRpbHNcIjtcbmltcG9ydCB7IGlzUmVjb2duaXRpb25FeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uc19wdWJsaWNcIjtcbmltcG9ydCB7IERFRkFVTFRfUlVMRV9DT05GSUcsIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG5pbXBvcnQgeyBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi4vLi4vZXJyb3JzX3B1YmxpY1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvY2hlY2tzXCI7XG5pbXBvcnQgeyBzZXJpYWxpemVHcmFtbWFyIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvZ2FzdC9nYXN0X3B1YmxpY1wiO1xuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgdGhlIHB1YmxpYyBBUElcbiAqIGZvciBkZWZpbmluZyBDaGV2cm90YWluIHBhcnNlcnMsIGkuZTpcbiAqIC0gQ09OU1VNRVxuICogLSBSVUxFXG4gKiAtIE9QVElPTlxuICogLSAuLi5cbiAqL1xudmFyIFJlY29nbml6ZXJBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjb2duaXplckFwaSgpIHtcbiAgICB9XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQUNUSU9OID0gZnVuY3Rpb24gKGltcGwpIHtcbiAgICAgICAgcmV0dXJuIGltcGwuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAoaWR4LCB0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCBpZHgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuc3VicnVsZSA9IGZ1bmN0aW9uIChpZHgsIHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIGlkeCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgaWR4KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKGlkeCwgYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIGlkeCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5tYW55ID0gZnVuY3Rpb24gKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFueUludGVybmFsKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuYXRMZWFzdE9uZSA9IGZ1bmN0aW9uIChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUUgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FMSA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAxLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUUyID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTMgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FNCA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU1ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTYgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5DT05TVU1FNyA9IGZ1bmN0aW9uICh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA3LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkNPTlNVTUU4ID0gZnVuY3Rpb24gKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQ09OU1VNRTkgPSBmdW5jdGlvbiAodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgOSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDAsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTEgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFMiA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEUzID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTQgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFNSA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA1LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU2ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDYsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuU1VCUlVMRTcgPSBmdW5jdGlvbiAocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5TVUJSVUxFOCA9IGZ1bmN0aW9uIChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlNVQlJVTEU5ID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAwKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjEgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDEpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OMiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT04zID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAzKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjQgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDQpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9ONSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT042ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA2KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9QVElPTjcgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDcpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1BUSU9OOCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgOCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUFRJT045ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA5KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAwKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SMSA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgMSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjIgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDIpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1IzID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAzKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SNCA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgNCk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjUgPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDUpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I2ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA2KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9SNyA9IGZ1bmN0aW9uIChhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgNyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5PUjggPSBmdW5jdGlvbiAoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDgpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuT1I5ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA5KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTlkgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoMCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTEgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoMSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTIgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoMiwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTMgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoMywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTQgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTUgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTYgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNiwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTcgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTggPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoOCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWTkgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoOSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDAsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVAxID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgxLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQMiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMiwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQNSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDYgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDYsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuTUFOWV9TRVA3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg3LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk1BTllfU0VQOCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoOCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5NQU5ZX1NFUDkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDAsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTEgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDEsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTIgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMiwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FMyA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgzLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU0ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDQsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTUgPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FNiA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg2LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkU3ID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDcsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORTggPSBmdW5jdGlvbiAoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoOCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH07XG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuQVRfTEVBU1RfT05FOSA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg5LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgwLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAxID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgxLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVAzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA1ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg1LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA2ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg2LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg3LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLlJVTEUgPSBmdW5jdGlvbiAobmFtZSwgaW1wbGVtZW50YXRpb24sIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gREVGQVVMVF9SVUxFX0NPTkZJRzsgfVxuICAgICAgICBpZiAoY29udGFpbnModGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBlcnJNc2cgPSBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIuYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZ3JhbW1hck5hbWU6IHRoaXMuY2xhc3NOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgdmFyIHJ1bGVJbXBsZW1lbnRhdGlvbiA9IHRoaXMuZGVmaW5lUnVsZShuYW1lLCBpbXBsZW1lbnRhdGlvbiwgY29uZmlnKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLk9WRVJSSURFX1JVTEUgPSBmdW5jdGlvbiAobmFtZSwgaW1wbCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBERUZBVUxUX1JVTEVfQ09ORklHOyB9XG4gICAgICAgIHZhciBydWxlRXJyb3JzID0gW107XG4gICAgICAgIHJ1bGVFcnJvcnMgPSBydWxlRXJyb3JzLmNvbmNhdCh2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4obmFtZSwgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgdGhpcy5jbGFzc05hbWUpKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2guYXBwbHkodGhpcy5kZWZpbml0aW9uRXJyb3JzLCBydWxlRXJyb3JzKTsgLy8gbXV0YWJpbGl0eSBmb3IgdGhlIHdpblxuICAgICAgICB2YXIgcnVsZUltcGxlbWVudGF0aW9uID0gdGhpcy5kZWZpbmVSdWxlKG5hbWUsIGltcGwsIGNvbmZpZyk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBydWxlSW1wbGVtZW50YXRpb247XG4gICAgICAgIHJldHVybiBydWxlSW1wbGVtZW50YXRpb247XG4gICAgfTtcbiAgICBSZWNvZ25pemVyQXBpLnByb3RvdHlwZS5CQUNLVFJBQ0sgPSBmdW5jdGlvbiAoZ3JhbW1hclJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgb3JnIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucHVzaCgxKTtcbiAgICAgICAgICAgIHZhciBvcmdTdGF0ZSA9IHRoaXMuc2F2ZVJlY29nU3RhdGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ3JhbW1hclJ1bGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gZXhjZXB0aW9uIHdhcyB0aHJvd24gd2UgaGF2ZSBzdWNjZWVkIHBhcnNpbmcgdGhlIHJ1bGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29nbml0aW9uRXhjZXB0aW9uKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxvYWRSZWNvZ1N0YXRlKG9yZ1N0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBHQVNUIGV4cG9ydCBBUElzXG4gICAgUmVjb2duaXplckFwaS5wcm90b3R5cGUuZ2V0R0FzdFByb2R1Y3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJBcGkucHJvdG90eXBlLmdldFNlcmlhbGl6ZWRHYXN0UHJvZHVjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVHcmFtbWFyKHZhbHVlcyh0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjb2duaXplckFwaTtcbn0oKSk7XG5leHBvcnQgeyBSZWNvZ25pemVyQXBpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvZ25pemVyX2FwaS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_api.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js ***!
  \**************************************************************************************/
/*! exports provided: RecognizerEngine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecognizerEngine\", function() { return RecognizerEngine; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../grammar/keys */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../exceptions_public */ \"./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/lookahead */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/lookahead.js\");\n/* harmony import */ var _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../grammar/interpreter */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/interpreter.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n/* harmony import */ var _recoverable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./recoverable */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js\");\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../scan/tokens */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _lang_lang_extensions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../lang/lang_extensions */ \"./node_modules/chevrotain/lib_esm/src/lang/lang_extensions.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = Object(_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_9__[\"classNameFromInstance\"])(this);\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = _scan_tokens__WEBPACK_IMPORTED_MODULE_8__[\"tokenStructuredMatcherNoCategories\"];\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.allRuleNames = [];\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(tokenVocabulary)) {\n            this.tokensMap = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(tokenVocabulary, \"modes\") &&\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(tokenVocabulary.modes)), _scan_tokens__WEBPACK_IMPORTED_MODULE_8__[\"isTokenType\"])) {\n            var allTokenTypes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(tokenVocabulary.modes));\n            var uniqueTokens = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"uniq\"])(allTokenTypes);\n            this.tokensMap = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"reduce\"])(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isObject\"])(tokenVocabulary)) {\n            this.tokensMap = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"cloneObj\"])(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        /* tslint:disable */\n        this.tokensMap[\"EOF\"] = _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__[\"EOF\"];\n        // TODO: This check may not be accurate for multi mode lexers\n        var noTokenCategoriesUsed = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"every\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(tokenVocabulary), function (tokenConstructor) { return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(tokenConstructor.categoryMatches); });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? _scan_tokens__WEBPACK_IMPORTED_MODULE_8__[\"tokenStructuredMatcherNoCategories\"]\n            : _scan_tokens__WEBPACK_IMPORTED_MODULE_8__[\"tokenStructuredMatcher\"];\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        Object(_scan_tokens__WEBPACK_IMPORTED_MODULE_8__[\"augmentTokenTypes\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"values\"])(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"resyncEnabled\")\n            ? config.resyncEnabled\n            : _parser__WEBPACK_IMPORTED_MODULE_5__[\"DEFAULT_RULE_CONFIG\"].resyncEnabled;\n        var recoveryValueFunc = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc\n            : _parser__WEBPACK_IMPORTED_MODULE_5__[\"DEFAULT_RULE_CONFIG\"].recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        /* tslint:disable */\n        var shortName = this.ruleShortNameIdx <<\n            (_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"BITS_FOR_METHOD_TYPE\"] + _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"BITS_FOR_OCCURRENCE_IDX\"]);\n        /* tslint:enable */\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        function invokeRuleWithTry(args) {\n            try {\n                if (this.outputCst === true) {\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                else {\n                    return impl.apply(this, args);\n                }\n            }\n            catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            }\n            finally {\n                this.ruleFinallyStateUpdate();\n            }\n        }\n        var wrappedGrammarRule;\n        wrappedGrammarRule = function (idxInCallingRule, args) {\n            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }\n            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n            return invokeRuleWithTry.call(this, args);\n        };\n        var ruleNamePropName = \"ruleName\";\n        wrappedGrammarRule[ruleNamePropName] = ruleName;\n        wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig &&\n            !this.isBackTracking() &&\n            this.recoveryEnabled;\n        if (Object(_exceptions_public__WEBPACK_IMPORTED_MODULE_2__[\"isRecognitionException\"])(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OPTION_IDX\"], occurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);\n        try {\n            return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(key, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OPTION_IDX\"], occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_1.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_IDX\"], prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n        try {\n            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_IDX\"], prodOccurrence);\n        this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_2.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"PROD_TYPE\"].REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_IDX\"], prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__[\"NextTerminalAfterAtLeastOneWalker\"]);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_SEP_IDX\"], prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(options, laKey);\n        try {\n            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_SEP_IDX\"], prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__[\"NextTerminalAfterAtLeastOneSepWalker\"]\n            ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_SEP_IDX\"], prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__[\"NextTerminalAfterAtLeastOneSepWalker\"]);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__[\"PROD_TYPE\"].REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_IDX\"], prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);\n        try {\n            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_IDX\"], prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return (predicate.call(_this) && orgLookaheadFunction_3.call(_this));\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_IDX\"], prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__[\"NextTerminalAfterManyWalker\"], \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_SEP_IDX\"], prodOccurrence);\n        var nestedName = this.nestedRuleBeforeClause(options, laKey);\n        try {\n            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_SEP_IDX\"], prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__[\"NextTerminalAfterManySepWalker\"]\n            ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"MANY_SEP_IDX\"], prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__[\"NextTerminalAfterManySepWalker\"]);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"AT_LEAST_ONE_SEP_IDX\"], prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {\n        var alts = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(altsOrOpts)\n            ? altsOrOpts\n            : altsOrOpts.DEF;\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OR_IDX\"], occurrence);\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OR_IDX\"], occurrence);\n        var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);\n        try {\n            var alts = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(altsOrOpts)\n                ? altsOrOpts\n                : altsOrOpts.DEF;\n            var laFunc = this.getLaFuncFromCache(laKey);\n            var altIdxToTake = laFunc.call(this, alts);\n            if (altIdxToTake !== undefined) {\n                var chosenAlternative = alts[altIdxToTake];\n                var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__[\"OR_IDX\"], altIdxToTake);\n                try {\n                    return chosenAlternative.ALT.call(this);\n                }\n                finally {\n                    if (nestedAltBeforeClauseResult !== undefined) {\n                        this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);\n                    }\n                }\n            }\n            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n        }\n        finally {\n            if (nestedName !== undefined) {\n                this.nestedRuleFinallyClause(laKey, nestedName);\n            }\n        }\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__[\"NotAllInputParsedException\"](errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            ruleResult = ruleToCall.call(this, idx, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if (Object(_exceptions_public__WEBPACK_IMPORTED_MODULE_2__[\"isRecognitionException\"])(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__[\"MismatchedTokenException\"](msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === _recoverable__WEBPACK_IMPORTED_MODULE_6__[\"IN_RULE_RECOVERY_EXCEPTION\"]) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"cloneArr\"])(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n            LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName, shortName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__[\"EOF\"]);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        this.LAST_EXPLICIT_RULE_STACK = [];\n        // TODO: extract a specific rest for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\n\n//# sourceMappingURL=recognizer_engine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY29nbml6ZXJfZW5naW5lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvZ25pemVyX2VuZ2luZS5qcz84ZWM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNsb25lQXJyLCBjbG9uZU9iaiwgZXZlcnksIGZsYXR0ZW4sIGhhcywgaXNBcnJheSwgaXNFbXB0eSwgaXNPYmplY3QsIHJlZHVjZSwgdW5pcSwgdmFsdWVzIH0gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL3V0aWxzXCI7XG5pbXBvcnQgeyBBVF9MRUFTVF9PTkVfSURYLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgQklUU19GT1JfTUVUSE9EX1RZUEUsIEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYLCBNQU5ZX0lEWCwgTUFOWV9TRVBfSURYLCBPUFRJT05fSURYLCBPUl9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzXCI7XG5pbXBvcnQgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24sIE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljXCI7XG5pbXBvcnQgeyBQUk9EX1RZUEUgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9sb29rYWhlYWRcIjtcbmltcG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyLCBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIsIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2ludGVycHJldGVyXCI7XG5pbXBvcnQgeyBERUZBVUxUX1JVTEVfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuaW1wb3J0IHsgSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04gfSBmcm9tIFwiLi9yZWNvdmVyYWJsZVwiO1xuaW1wb3J0IHsgRU9GIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpY1wiO1xuaW1wb3J0IHsgYXVnbWVudFRva2VuVHlwZXMsIGlzVG9rZW5UeXBlLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zXCI7XG5pbXBvcnQgeyBjbGFzc05hbWVGcm9tSW5zdGFuY2UgfSBmcm9tIFwiLi4vLi4vLi4vbGFuZy9sYW5nX2V4dGVuc2lvbnNcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJ1bnRpbWUgcGFyc2luZyBlbmdpbmVcbiAqIFVzZWQgYnkgdGhlIG9mZmljaWFsIEFQSSAocmVjb2duaXplcl9hcGkudHMpXG4gKi9cbnZhciBSZWNvZ25pemVyRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY29nbml6ZXJFbmdpbmUoKSB7XG4gICAgfVxuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmluaXRSZWNvZ25pemVyRW5naW5lID0gZnVuY3Rpb24gKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgICAgICAvLyBUT0RPOiB3b3VsZCB1c2luZyBhbiBFUzYgTWFwIG9yIHBsYWluIG9iamVjdCBiZSBmYXN0ZXIgKENTVCBidWlsZGluZyBzY2VuYXJpbylcbiAgICAgICAgdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsID0ge307XG4gICAgICAgIHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydCA9IHt9O1xuICAgICAgICB0aGlzLnJ1bGVTaG9ydE5hbWVJZHggPSAyNTY7XG4gICAgICAgIHRoaXMudG9rZW5NYXRjaGVyID0gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcztcbiAgICAgICAgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLnRva2Vuc01hcCA9IHt9O1xuICAgICAgICB0aGlzLmFsbFJ1bGVOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gW107XG4gICAgICAgIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLID0gW107XG4gICAgICAgIHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKGhhcyhjb25maWcsIFwic2VyaWFsaXplZEdyYW1tYXJcIikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIFBhcnNlcidzIGNvbmZpZ3VyYXRpb24gY2FuIG5vIGxvbmdlciBjb250YWluIGEgPHNlcmlhbGl6ZWRHcmFtbWFyPiBwcm9wZXJ0eS5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzYtMC0wXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IGNoZWNrcyBmb3IgVG9rZW4gdm9jYWJ1bGFyaWVzIHByb3ZpZGVkIGFzIGFycmF5cy5cbiAgICAgICAgICAgIC8vIFRoYXQgaXMgZ29vZCBlbm91Z2ggYmVjYXVzZSB0aGUgbWFpbiBvYmplY3RpdmUgaXMgdG8gZGV0ZWN0IHVzZXJzIG9mIHByZS1WNC4wIEFQSXNcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFsbCBlZGdlIGNhc2VzIG9mIGVtcHR5IFRva2VuIHZvY2FidWxhcmllcy5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgVG9rZW4gVm9jYWJ1bGFyeSBjYW5ub3QgYmUgZW1wdHkuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdE5vdGUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBwYXJzZXIgY29uc3RydWN0b3JcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0aXMgbm8gbG9uZ2VyIGEgVG9rZW4gdmVjdG9yIChzaW5jZSB2NC4wKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuVm9jYWJ1bGFyeVswXS5zdGFydE9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIFBhcnNlciBjb25zdHJ1Y3RvciBubyBsb25nZXIgYWNjZXB0cyBhIHRva2VuIHZlY3RvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNC0wLTBcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSByZWR1Y2UodG9rZW5Wb2NhYnVsYXJ5LCBmdW5jdGlvbiAoYWNjLCB0b2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgYWNjW3Rva1R5cGUubmFtZV0gPSB0b2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzKHRva2VuVm9jYWJ1bGFyeSwgXCJtb2Rlc1wiKSAmJlxuICAgICAgICAgICAgZXZlcnkoZmxhdHRlbih2YWx1ZXModG9rZW5Wb2NhYnVsYXJ5Lm1vZGVzKSksIGlzVG9rZW5UeXBlKSkge1xuICAgICAgICAgICAgdmFyIGFsbFRva2VuVHlwZXMgPSBmbGF0dGVuKHZhbHVlcyh0b2tlblZvY2FidWxhcnkubW9kZXMpKTtcbiAgICAgICAgICAgIHZhciB1bmlxdWVUb2tlbnMgPSB1bmlxKGFsbFRva2VuVHlwZXMpO1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSByZWR1Y2UodW5pcXVlVG9rZW5zLCBmdW5jdGlvbiAoYWNjLCB0b2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgYWNjW3Rva1R5cGUubmFtZV0gPSB0b2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSBjbG9uZU9iaih0b2tlblZvY2FidWxhcnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPHRva2Vuc0RpY3Rpb25hcnk+IGFyZ3VtZW50IG11c3QgYmUgQW4gQXJyYXkgb2YgVG9rZW4gY29uc3RydWN0b3JzLFwiICtcbiAgICAgICAgICAgICAgICBcIiBBIGRpY3Rpb25hcnkgb2YgVG9rZW4gY29uc3RydWN0b3JzIG9yIGFuIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWx3YXlzIGFkZCBFT0YgdG8gdGhlIHRva2VuTmFtZXMgLT4gY29uc3RydWN0b3JzIG1hcC4gaXQgaXMgdXNlZnVsIHRvIGFzc3VyZSBhbGwgdGhlIGlucHV0IGhhcyBiZWVuXG4gICAgICAgIC8vIHBhcnNlZCB3aXRoIGEgY2xlYXIgZXJyb3IgbWVzc2FnZSAoXCJleHBlY3RpbmcgRU9GIGJ1dCBmb3VuZCAuLi5cIilcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGUgKi9cbiAgICAgICAgdGhpcy50b2tlbnNNYXBbXCJFT0ZcIl0gPSBFT0Y7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgbWF5IG5vdCBiZSBhY2N1cmF0ZSBmb3IgbXVsdGkgbW9kZSBsZXhlcnNcbiAgICAgICAgdmFyIG5vVG9rZW5DYXRlZ29yaWVzVXNlZCA9IGV2ZXJ5KHZhbHVlcyh0b2tlblZvY2FidWxhcnkpLCBmdW5jdGlvbiAodG9rZW5Db25zdHJ1Y3RvcikgeyByZXR1cm4gaXNFbXB0eSh0b2tlbkNvbnN0cnVjdG9yLmNhdGVnb3J5TWF0Y2hlcyk7IH0pO1xuICAgICAgICB0aGlzLnRva2VuTWF0Y2hlciA9IG5vVG9rZW5DYXRlZ29yaWVzVXNlZFxuICAgICAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgICAgICA6IHRva2VuU3RydWN0dXJlZE1hdGNoZXI7XG4gICAgICAgIC8vIEJlY2F1c2UgRVMyMDE1KyBzeW50YXggc2hvdWxkIGJlIHN1cHBvcnRlZCBmb3IgY3JlYXRpbmcgVG9rZW4gY2xhc3Nlc1xuICAgICAgICAvLyBXZSBjYW5ub3QgYXNzdW1lIHRoYXQgdGhlIFRva2VuIGNsYXNzZXMgd2VyZSBjcmVhdGVkIHVzaW5nIHRoZSBcImV4dGVuZFRva2VuXCIgdXRpbGl0aWVzXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGF1Z21lbnQgdGhlIFRva2VuIGNsYXNzZXMgYm90aCBvbiBMZXhlciBpbml0aWFsaXphdGlvbiBhbmQgb24gUGFyc2VyIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGF1Z21lbnRUb2tlblR5cGVzKHZhbHVlcyh0aGlzLnRva2Vuc01hcCkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuZGVmaW5lUnVsZSA9IGZ1bmN0aW9uIChydWxlTmFtZSwgaW1wbCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGZBbmFseXNpc0RvbmUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiR3JhbW1hciBydWxlIDxcIiArIHJ1bGVOYW1lICsgXCI+IG1heSBub3QgYmUgZGVmaW5lZCBhZnRlciB0aGUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQnXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoYXQgYWxsIGdyYW1tYXIgcnVsZSBkZWZpbml0aW9ucyBhcmUgZG9uZSBiZWZvcmUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIGlzIGNhbGxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3luY0VuYWJsZWQgPSBoYXMoY29uZmlnLCBcInJlc3luY0VuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlc3luY0VuYWJsZWRcbiAgICAgICAgICAgIDogREVGQVVMVF9SVUxFX0NPTkZJRy5yZXN5bmNFbmFibGVkO1xuICAgICAgICB2YXIgcmVjb3ZlcnlWYWx1ZUZ1bmMgPSBoYXMoY29uZmlnLCBcInJlY292ZXJ5VmFsdWVGdW5jXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5yZWNvdmVyeVZhbHVlRnVuY1xuICAgICAgICAgICAgOiBERUZBVUxUX1JVTEVfQ09ORklHLnJlY292ZXJ5VmFsdWVGdW5jO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFVzZSBzbWFsbCBpbnRlZ2VycyBhcyBrZXlzIGZvciB0aGUgbG9uZ2VyIGh1bWFuIHJlYWRhYmxlIFwiZnVsbFwiIHJ1bGUgbmFtZXMuXG4gICAgICAgIC8vIHRoaXMgZ3JlYXRseSBpbXByb3ZlcyBNYXAgYWNjZXNzIHRpbWUgKGFzIG11Y2ggYXMgOCUgZm9yIHNvbWUgcGVyZm9ybWFuY2UgYmVuY2htYXJrcykuXG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSB0aGlzLnJ1bGVTaG9ydE5hbWVJZHggPDxcbiAgICAgICAgICAgIChCSVRTX0ZPUl9NRVRIT0RfVFlQRSArIEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICB0aGlzLnJ1bGVTaG9ydE5hbWVJZHgrKztcbiAgICAgICAgdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3Nob3J0TmFtZV0gPSBydWxlTmFtZTtcbiAgICAgICAgdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W3J1bGVOYW1lXSA9IHNob3J0TmFtZTtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlUnVsZVdpdGhUcnkoYXJncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlKGNzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZVJ1bGVDYXRjaChlLCByZXN5bmNFbmFibGVkLCByZWNvdmVyeVZhbHVlRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcHBlZEdyYW1tYXJSdWxlO1xuICAgICAgICB3cmFwcGVkR3JhbW1hclJ1bGUgPSBmdW5jdGlvbiAoaWR4SW5DYWxsaW5nUnVsZSwgYXJncykge1xuICAgICAgICAgICAgaWYgKGlkeEluQ2FsbGluZ1J1bGUgPT09IHZvaWQgMCkgeyBpZHhJbkNhbGxpbmdSdWxlID0gMDsgfVxuICAgICAgICAgICAgdGhpcy5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlKHNob3J0TmFtZSwgcnVsZU5hbWUsIGlkeEluQ2FsbGluZ1J1bGUpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZVJ1bGVXaXRoVHJ5LmNhbGwodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBydWxlTmFtZVByb3BOYW1lID0gXCJydWxlTmFtZVwiO1xuICAgICAgICB3cmFwcGVkR3JhbW1hclJ1bGVbcnVsZU5hbWVQcm9wTmFtZV0gPSBydWxlTmFtZTtcbiAgICAgICAgd3JhcHBlZEdyYW1tYXJSdWxlW1wib3JpZ2luYWxHcmFtbWFyQWN0aW9uXCJdID0gaW1wbDtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRHcmFtbWFyUnVsZTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmludm9rZVJ1bGVDYXRjaCA9IGZ1bmN0aW9uIChlLCByZXN5bmNFbmFibGVkQ29uZmlnLCByZWNvdmVyeVZhbHVlRnVuYykge1xuICAgICAgICB2YXIgaXNGaXJzdEludm9rZWRSdWxlID0gdGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgLy8gbm90ZSB0aGUgcmVTeW5jIGlzIGFsd2F5cyBlbmFibGVkIGZvciB0aGUgZmlyc3QgcnVsZSBpbnZvY2F0aW9uLCBiZWNhdXNlIHdlIG11c3QgYWx3YXlzIGJlIGFibGUgdG9cbiAgICAgICAgLy8gcmVTeW5jIHdpdGggRU9GIGFuZCBqdXN0IG91dHB1dCBzb21lIElOVkFMSUQgUGFyc2VUcmVlXG4gICAgICAgIC8vIGR1cmluZyBiYWNrdHJhY2tpbmcgcmVTeW5jIHJlY292ZXJ5IGlzIGRpc2FibGVkLCBvdGhlcndpc2Ugd2UgY2FuJ3QgYmUgY2VydGFpbiB0aGUgYmFja3RyYWNraW5nXG4gICAgICAgIC8vIHBhdGggaXMgcmVhbGx5IHRoZSBtb3N0IHZhbGlkIG9uZVxuICAgICAgICB2YXIgcmVTeW5jRW5hYmxlZCA9IHJlc3luY0VuYWJsZWRDb25maWcgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQmFja1RyYWNraW5nKCkgJiZcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnlFbmFibGVkO1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgICAgdmFyIHJlY29nRXJyb3IgPSBlO1xuICAgICAgICAgICAgaWYgKHJlU3luY0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVTeW5jVG9rVHlwZSA9IHRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldChyZVN5bmNUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZWNvZ0Vycm9yLnJlc3luY2VkVG9rZW5zID0gdGhpcy5yZVN5bmNUbyhyZVN5bmNUb2tUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbENzdFJlc3VsdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbENzdFJlc3VsdC5yZWNvdmVyZWROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dENzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxDc3RSZXN1bHQgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxDc3RSZXN1bHQucmVjb3ZlcmVkTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvZ0Vycm9yLnBhcnRpYWxDc3RSZXN1bHQgPSBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGhhbmRsZWQgRnVydGhlciB1cCB0aGUgY2FsbCBzdGFja1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWNvZ0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RJbnZva2VkUnVsZSkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhIFJlZHVuZGFudCBpbnB1dCBlcnJvciB3aWxsIGJlIGNyZWF0ZWQgYXMgd2VsbCBhbmQgd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgaW5kZWVkIHRoZSBjYXNlXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9UZXJtaW5hdGVkU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFyc2VyIHNob3VsZCBuZXZlciB0aHJvdyBvbmUgb2YgaXRzIG93biBlcnJvcnMgb3V0c2lkZSBpdHMgZmxvdy5cbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGVycm9yIHJlY292ZXJ5IGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0byBiZSByZWNvdmVyZWQgRnVydGhlciB1cCB0aGUgY2FsbCBzdGFja1xuICAgICAgICAgICAgICAgIHRocm93IHJlY29nRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzb21lIG90aGVyIEVycm9yIHR5cGUgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlIChmb3IgZXhhbXBsZSBhIGJ1aWx0IGluIEphdmFTY3JpcHQgRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBwYXJzaW5nIERTTFxuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLm9wdGlvbkludGVybmFsID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChPUFRJT05fSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSB0aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoYWN0aW9uT1JNZXRob2REZWYsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKG5lc3RlZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2Uoa2V5LCBuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3B0aW9uSW50ZXJuYWxOb0NzdCA9IGZ1bmN0aW9uIChhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoT1BUSU9OX0lEWCwgb2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsTG9naWMoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UsIGtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5vcHRpb25JbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2tBaGVhZEZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICB2YXIgYWN0aW9uO1xuICAgICAgICB2YXIgcHJlZGljYXRlO1xuICAgICAgICBpZiAoYWN0aW9uT1JNZXRob2REZWYuREVGICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmLkRFRjtcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbk9STWV0aG9kRGVmLkdBVEU7XG4gICAgICAgICAgICAvLyBwcmVkaWNhdGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzEgPSBsb29rQWhlYWRGdW5jO1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJlZGljYXRlLmNhbGwoX3RoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzEuY2FsbChfdGhpcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdmFyIGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoQVRfTEVBU1RfT05FX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAobmVzdGVkTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShsYUtleSwgbmVzdGVkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbE5vQ3N0ID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoQVRfTEVBU1RfT05FX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwga2V5KTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb29rQWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKGFjdGlvbk9STWV0aG9kRGVmLkRFRiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8yID0gbG9va0FoZWFkRnVuYztcbiAgICAgICAgICAgICAgICBsb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHByZWRpY2F0ZS5jYWxsKF90aGlzKSAmJiBvcmdMb29rYWhlYWRGdW5jdGlvbl8yLmNhbGwoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24ocHJvZE9jY3VycmVuY2UsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgYWN0aW9uT1JNZXRob2REZWYuRVJSX01TRyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZSB0aGF0IHdoaWxlIGl0IG1heSBzZWVtIHRoYXQgdGhpcyBjYW4gY2F1c2UgYW4gZXJyb3IgYmVjYXVzZSBieSB1c2luZyBhIHJlY3Vyc2l2ZSBjYWxsIHRvXG4gICAgICAgIC8vIEFUX0xFQVNUX09ORSB3ZSBjaGFuZ2UgdGhlIGdyYW1tYXIgdG8gQVRfTEVBU1RfVFdPLCBBVF9MRUFTVF9USFJFRSAuLi4gLCB0aGUgcG9zc2libGUgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgLy8gZnJvbSB0aGUgdHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkoLi4uKSB3aWxsIG9ubHkgaGFwcGVuIElGRiB0aGVyZSByZWFsbHkgYXJlIFRXTy9USFJFRS8uLi4uIGl0ZW1zLlxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5hdExlYXN0T25lSW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKEFUX0xFQVNUX09ORV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBuZXN0ZWROYW1lID0gdGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKG9wdGlvbnMsIGxhS2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKG5lc3RlZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobGFLZXksIG5lc3RlZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbE5vQ3N0ID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKEFUX0xFQVNUX09ORV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywga2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3Rpb24gPSBvcHRpb25zLkRFRjtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IG9wdGlvbnMuU0VQO1xuICAgICAgICB2YXIgZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgLy8gMXN0IGl0ZXJhdGlvblxuICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gIFRPRE86IE9wdGltaXphdGlvbiBjYW4gbW92ZSB0aGlzIGZ1bmN0aW9uIGNvbnN0cnVjdGlvbiBpbnRvIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIGl0IGlzIG9ubHkgbmVlZGVkIGluIGVycm9yIHJlY292ZXJ5IHNjZW5hcmlvcy5cbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JMb29rQWhlYWRGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hdGNoZXIoX3RoaXMuTEEoMSksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMm5kLi5udGggaXRlcmF0aW9uc1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHNlcGFyYXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhpcyBDT05TVU1FIHdpbGwgbmV2ZXIgZW50ZXIgcmVjb3ZlcnkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0b3JMb29rQWhlYWRGdW5jIGNoZWNrcyB0aGF0IHRoZSBzZXBhcmF0b3IgcmVhbGx5IGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICAgICAgcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlclxuICAgICAgICAgICAgXSwgc2VwYXJhdG9yTG9va0FoZWFkRnVuYywgQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbihwcm9kT2NjdXJyZW5jZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLCBvcHRpb25zLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55SW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBuZXN0ZWROYW1lID0gdGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW55SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYsIGxhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChuZXN0ZWROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKGxhS2V5LCBuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueUludGVybmFsTm9Dc3QgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnlJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueUludGVybmFsTG9naWMgPSBmdW5jdGlvbiAocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvb2thaGVhZEZ1bmN0aW9uID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgdmFyIHByZWRpY2F0ZTtcbiAgICAgICAgaWYgKGFjdGlvbk9STWV0aG9kRGVmLkRFRiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmdMb29rYWhlYWRGdW5jdGlvbl8zID0gbG9va2FoZWFkRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgbG9va2FoZWFkRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocHJlZGljYXRlLmNhbGwoX3RoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uXzMuY2FsbChfdGhpcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm90U3R1Y2sgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobG9va2FoZWFkRnVuY3Rpb24uY2FsbCh0aGlzKSA9PT0gdHJ1ZSAmJiBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm90U3R1Y2sgPSB0aGlzLmRvU2luZ2xlUmVwZXRpdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIiB3aWxsIGJlIGRlZmluZWQgYXMgTk9PUCB1bmxlc3MgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLm1hbnlJbnRlcm5hbCwgW3Byb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZl0sIGxvb2thaGVhZEZ1bmN0aW9uLCBNQU5ZX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciwgXG4gICAgICAgIC8vIFRoZSBub3RTdHVjayBwYXJhbWV0ZXIgaXMgb25seSByZWxldmFudCB3aGVuIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgLy8gaXMgaW52b2tlZCBmcm9tIG1hbnlJbnRlcm5hbCwgaW4gdGhlIE1BTllfU0VQIGNhc2UgYW5kIEFUX0xFQVNUX09ORVtfU0VQXVxuICAgICAgICAvLyBBbiBpbmZpbml0ZSBsb29wIGNhbm5vdCBvY2N1ciBhczpcbiAgICAgICAgLy8gLSBFaXRoZXIgdGhlIGxvb2thaGVhZCBpcyBndWFyYW50ZWVkIHRvIGNvbnN1bWUgc29tZXRoaW5nIChTaW5nbGUgVG9rZW4gU2VwYXJhdG9yKVxuICAgICAgICAvLyAtIEFUX0xFQVNUX09ORSBieSBkZWZpbml0aW9uIGlzIGd1YXJhbnRlZWQgdG8gY29uc3VtZSBzb21ldGhpbmcgKG9yIGVycm9yIG91dCkuXG4gICAgICAgIG5vdFN0dWNrKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE1BTllfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShvcHRpb25zLCBsYUtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMsIGxhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChuZXN0ZWROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKGxhS2V5LCBuZXN0ZWROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWxOb0NzdCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChNQU5ZX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBsYUtleSk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljID0gZnVuY3Rpb24gKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFjdGlvbiA9IG9wdGlvbnMuREVGO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0aW9ucy5TRVA7XG4gICAgICAgIHZhciBmaXJzdEl0ZXJhdGlvbkxhRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIC8vIDFzdCBpdGVyYXRpb25cbiAgICAgICAgaWYgKGZpcnN0SXRlcmF0aW9uTGFGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRva2VuTWF0Y2hlcihfdGhpcy5MQSgxKSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAybmQuLm50aCBpdGVyYXRpb25zXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgc2VwYXJhdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgY2hlY2tzIHRoYXQgdGhlIHNlcGFyYXRvciByZWFsbHkgZG9lcyBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLkNPTlNVTUUoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIGZvciBjaGVja2luZyBpbmZpbml0ZSBsb29wIGhlcmUgZHVlIHRvIGNvbnN1bWluZyB0aGUgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCwgW1xuICAgICAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXJcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIE1BTllfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCA9IGZ1bmN0aW9uIChwcm9kT2NjdXJyZW5jZSwgc2VwYXJhdG9yLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBhY3Rpb24sIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKSB7XG4gICAgICAgIHdoaWxlIChzZXBhcmF0b3JMb29rQWhlYWRGdW5jKCkpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBjYW4gb25seSBhcnJpdmUgdG8gdGhpcyBmdW5jdGlvbiBhZnRlciBhbiBlcnJvclxuICAgICAgICAvLyBoYXMgb2NjdXJyZWQgKGhlbmNlIHRoZSBuYW1lICdzZWNvbmQnKSBzbyB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIElGIHdpbGwgYWx3YXlzIGJlIGVudGVyZWQsIGl0cyBwb3NzaWJsZSB0byByZW1vdmUgaXQuLi5cbiAgICAgICAgLy8gaG93ZXZlciBpdCBpcyBrZXB0IHRvIGF2b2lkIGNvbmZ1c2lvbiBhbmQgYmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBuZXh0VGVybWluYWxBZnRlcldhbGtlclxuICAgICAgICBdLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmRvU2luZ2xlUmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGJlZm9yZUl0ZXJhdGlvbiA9IHRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO1xuICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGFmdGVySXRlcmF0aW9uID0gdGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7XG4gICAgICAgIC8vIFRoaXMgYm9vbGVhbiB3aWxsIGluZGljYXRlIGlmIHRoaXMgcmVwZXRpdGlvbiBwcm9ncmVzc2VkXG4gICAgICAgIC8vIG9yIGlmIHdlIGFyZSBcInN0dWNrXCIgKHBvdGVudGlhbCBpbmZpbml0ZSBsb29wIGluIHRoZSByZXBldGl0aW9uKS5cbiAgICAgICAgcmV0dXJuIGFmdGVySXRlcmF0aW9uID4gYmVmb3JlSXRlcmF0aW9uO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUub3JJbnRlcm5hbE5vQ3N0ID0gZnVuY3Rpb24gKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGFsdHMgPSBpc0FycmF5KGFsdHNPck9wdHMpXG4gICAgICAgICAgICA/IGFsdHNPck9wdHNcbiAgICAgICAgICAgIDogYWx0c09yT3B0cy5ERUY7XG4gICAgICAgIHZhciBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE9SX0lEWCwgb2NjdXJyZW5jZSk7XG4gICAgICAgIHZhciBsYUZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShsYUtleSk7XG4gICAgICAgIHZhciBhbHRJZHhUb1Rha2UgPSBsYUZ1bmMuY2FsbCh0aGlzLCBhbHRzKTtcbiAgICAgICAgaWYgKGFsdElkeFRvVGFrZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY2hvc2VuQWx0ZXJuYXRpdmUgPSBhbHRzW2FsdElkeFRvVGFrZV07XG4gICAgICAgICAgICByZXR1cm4gY2hvc2VuQWx0ZXJuYXRpdmUuQUxULmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYWlzZU5vQWx0RXhjZXB0aW9uKG9jY3VycmVuY2UsIGFsdHNPck9wdHMuRVJSX01TRyk7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5vckludGVybmFsID0gZnVuY3Rpb24gKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgdmFyIGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoT1JfSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSB0aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoYWx0c09yT3B0cywgbGFLZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGFsdHMgPSBpc0FycmF5KGFsdHNPck9wdHMpXG4gICAgICAgICAgICAgICAgPyBhbHRzT3JPcHRzXG4gICAgICAgICAgICAgICAgOiBhbHRzT3JPcHRzLkRFRjtcbiAgICAgICAgICAgIHZhciBsYUZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShsYUtleSk7XG4gICAgICAgICAgICB2YXIgYWx0SWR4VG9UYWtlID0gbGFGdW5jLmNhbGwodGhpcywgYWx0cyk7XG4gICAgICAgICAgICBpZiAoYWx0SWR4VG9UYWtlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hvc2VuQWx0ZXJuYXRpdmUgPSBhbHRzW2FsdElkeFRvVGFrZV07XG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdCA9IHRoaXMubmVzdGVkQWx0QmVmb3JlQ2xhdXNlKGNob3NlbkFsdGVybmF0aXZlLCBvY2N1cnJlbmNlLCBPUl9JRFgsIGFsdElkeFRvVGFrZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNob3NlbkFsdGVybmF0aXZlLkFMVC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdC5zaG9ydE5hbWUsIG5lc3RlZEFsdEJlZm9yZUNsYXVzZVJlc3VsdC5uZXN0ZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFpc2VOb0FsdEV4Y2VwdGlvbihvY2N1cnJlbmNlLCBhbHRzT3JPcHRzLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKG5lc3RlZE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobGFLZXksIG5lc3RlZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5ydWxlRmluYWxseVN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sucG9wKCk7XG4gICAgICAgIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnBvcCgpO1xuICAgICAgICAvLyBOT09QIHdoZW4gY3N0IGlzIGRpc2FibGVkXG4gICAgICAgIHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLlJVTEVfU1RBQ0subGVuZ3RoID09PSAwICYmIHRoaXMuaXNBdEVuZE9mSW5wdXQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFJlZHVuZGFudFRvayA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZmlyc3RSZWR1bmRhbnQ6IGZpcnN0UmVkdW5kYW50VG9rLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlNBVkVfRVJST1IobmV3IE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uKGVyck1zZywgZmlyc3RSZWR1bmRhbnRUb2spKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc3VicnVsZUludGVybmFsID0gZnVuY3Rpb24gKHJ1bGVUb0NhbGwsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcnVsZVJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5BUkdTIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcnVsZVJlc3VsdCA9IHJ1bGVUb0NhbGwuY2FsbCh0aGlzLCBpZHgsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwocnVsZVJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZVRvQ2FsbC5ydWxlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcnVsZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJydWxlSW50ZXJuYWxFcnJvcihlLCBvcHRpb25zLCBydWxlVG9DYWxsLnJ1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc3VicnVsZUludGVybmFsRXJyb3IgPSBmdW5jdGlvbiAoZSwgb3B0aW9ucywgcnVsZU5hbWUpIHtcbiAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkgJiYgZS5wYXJ0aWFsQ3N0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKGUucGFydGlhbENzdFJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZU5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGUucGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsID0gZnVuY3Rpb24gKHRva1R5cGUsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29uc3VtZWRUb2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdG9rVHlwZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVJbnRlcm5hbEVycm9yKHRva1R5cGUsIG5leHRUb2tlbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVGcm9tQ29uc3VtcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY292ZXJ5KHRva1R5cGUsIGlkeCwgZUZyb21Db25zdW1wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBvcHRpb25zLkxBQkVMXG4gICAgICAgICAgICA6IHRva1R5cGUubmFtZSwgY29uc3VtZWRUb2tlbik7XG4gICAgICAgIHJldHVybiBjb25zdW1lZFRva2VuO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsRXJyb3IgPSBmdW5jdGlvbiAodG9rVHlwZSwgbmV4dFRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtc2c7XG4gICAgICAgIHZhciBwcmV2aW91c1Rva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkVSUl9NU0cpIHtcbiAgICAgICAgICAgIG1zZyA9IG9wdGlvbnMuRVJSX01TRztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRva1R5cGUsXG4gICAgICAgICAgICAgICAgYWN0dWFsOiBuZXh0VG9rZW4sXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihtc2csIG5leHRUb2tlbiwgcHJldmlvdXNUb2tlbikpO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuY29uc3VtZUludGVybmFsUmVjb3ZlcnkgPSBmdW5jdGlvbiAodG9rVHlwZSwgaWR4LCBlRnJvbUNvbnN1bXB0aW9uKSB7XG4gICAgICAgIC8vIG5vIHJlY292ZXJ5IGFsbG93ZWQgZHVyaW5nIGJhY2t0cmFja2luZywgb3RoZXJ3aXNlIGJhY2t0cmFja2luZyBtYXkgcmVjb3ZlciBpbnZhbGlkIHN5bnRheCBhbmQgYWNjZXB0IGl0XG4gICAgICAgIC8vIGJ1dCB0aGUgb3JpZ2luYWwgc3ludGF4IGNvdWxkIGhhdmUgYmVlbiBwYXJzZWQgc3VjY2Vzc2Z1bGx5IHdpdGhvdXQgYW55IGJhY2t0cmFja2luZyArIHJlY292ZXJ5XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCAmJlxuICAgICAgICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgY2hlY2tpbmcgb2YgdGhlIGV4Y2VwdGlvbiB0eXBlLiBQZXJoYXBzIFR5cGVzY3JpcHQgZXh0ZW5kaW5nIGV4cHJlc3Npb25zP1xuICAgICAgICAgICAgZUZyb21Db25zdW1wdGlvbi5uYW1lID09PSBcIk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvblwiICYmXG4gICAgICAgICAgICAhdGhpcy5pc0JhY2tUcmFja2luZygpKSB7XG4gICAgICAgICAgICB2YXIgZm9sbG93cyA9IHRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHRva1R5cGUsIGlkeCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeUluUnVsZVJlY292ZXJ5KHRva1R5cGUsIGZvbGxvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVGcm9tSW5SdWxlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZUZyb21JblJ1bGVSZWNvdmVyeS5uYW1lID09PSBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgaW4gUnVsZVJlY292ZXJ5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gb3JkZXIgdG8gdHJpZ2dlciByZVN5bmMgZXJyb3IgcmVjb3ZlcnlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZUZyb21Db25zdW1wdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVGcm9tSW5SdWxlUmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZUZyb21Db25zdW1wdGlvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc2F2ZVJlY29nU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVycm9ycyBpcyBhIGdldHRlciB3aGljaCB3aWxsIGNsb25lIHRoZSBlcnJvcnMgYXJyYXlcbiAgICAgICAgdmFyIHNhdmVkRXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgIHZhciBzYXZlZFJ1bGVTdGFjayA9IGNsb25lQXJyKHRoaXMuUlVMRV9TVEFDSyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IHNhdmVkRXJyb3JzLFxuICAgICAgICAgICAgbGV4ZXJTdGF0ZTogdGhpcy5leHBvcnRMZXhlclN0YXRlKCksXG4gICAgICAgICAgICBSVUxFX1NUQUNLOiBzYXZlZFJ1bGVTdGFjayxcbiAgICAgICAgICAgIENTVF9TVEFDSzogdGhpcy5DU1RfU1RBQ0ssXG4gICAgICAgICAgICBMQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0s6IHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5yZWxvYWRSZWNvZ1N0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbmV3U3RhdGUuZXJyb3JzO1xuICAgICAgICB0aGlzLmltcG9ydExleGVyU3RhdGUobmV3U3RhdGUubGV4ZXJTdGF0ZSk7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSyA9IG5ld1N0YXRlLlJVTEVfU1RBQ0s7XG4gICAgfTtcbiAgICBSZWNvZ25pemVyRW5naW5lLnByb3RvdHlwZS5ydWxlSW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKHNob3J0TmFtZSwgZnVsbE5hbWUsIGlkeEluQ2FsbGluZ1J1bGUpIHtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaChpZHhJbkNhbGxpbmdSdWxlKTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnB1c2goc2hvcnROYW1lKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZShmdWxsTmFtZSwgc2hvcnROYW1lKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmlzQmFja1RyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLmxlbmd0aCAhPT0gMDtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmdldEN1cnJSdWxlRnVsbE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdO1xuICAgIH07XG4gICAgUmVjb2duaXplckVuZ2luZS5wcm90b3R5cGUuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoc2hvcnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbc2hvcnROYW1lXTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLmlzQXRFbmRPZklucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgRU9GKTtcbiAgICB9O1xuICAgIFJlY29nbml6ZXJFbmdpbmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gW107XG4gICAgICAgIHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLID0gW107XG4gICAgICAgIC8vIFRPRE86IGV4dHJhY3QgYSBzcGVjaWZpYyByZXN0IGZvciBUcmVlQnVpbGRlciB0cmFpdFxuICAgICAgICB0aGlzLkNTVF9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29nbml6ZXJFbmdpbmU7XG59KCkpO1xuZXhwb3J0IHsgUmVjb2duaXplckVuZ2luZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb2duaXplcl9lbmdpbmUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recognizer_engine.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js ***!
  \********************************************************************************/
/*! exports provided: EOF_FOLLOW_KEY, IN_RULE_RECOVERY_EXCEPTION, InRuleRecoveryException, Recoverable, attemptInRepetitionRecovery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EOF_FOLLOW_KEY\", function() { return EOF_FOLLOW_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IN_RULE_RECOVERY_EXCEPTION\", function() { return IN_RULE_RECOVERY_EXCEPTION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InRuleRecoveryException\", function() { return InRuleRecoveryException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Recoverable\", function() { return Recoverable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"attemptInRepetitionRecovery\", function() { return attemptInRepetitionRecovery; });\n/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scan/tokens_public */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../exceptions_public */ \"./node_modules/chevrotain/lib_esm/src/parse/exceptions_public.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants */ \"./node_modules/chevrotain/lib_esm/src/parse/constants.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n\n\n\nvar EOF_FOLLOW_KEY = {};\nvar IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nfunction InRuleRecoveryException(message) {\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n    this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"has\"])(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled\n            : _parser__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_PARSER_CONFIG\"].recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = Object(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"createTokenInstance\"])(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__[\"MismatchedTokenException\"](msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"dropRight\"])(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // arguments to try and perform resync into the next iteration of the many are missing\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"find\"])(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"contains\"])(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var nextTokenType = nextToken.tokenType;\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"contains\"])(allPossibleReSyncTokTypes, nextTokenType)) {\n                return nextTokenType;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(this.LAST_EXPLICIT_RULE_STACK)) {\n            explicitRuleStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_STACK[idx]; });\n            explicitOccurrenceStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_OCCURRENCE_STACK[idx]; });\n        }\n        // TODO: only iterate over explicit rules here\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"flatten\"])(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"EOF\"]];\n        }\n        var followName = followKey.ruleName +\n            followKey.idxInCallingRule +\n            _constants__WEBPACK_IMPORTED_MODULE_3__[\"IN\"] +\n            followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"EOF\"])) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"dropRight\"])(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(this.LAST_EXPLICIT_RULE_STACK)) {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {\n                return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);\n            });\n        }\n        else {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(this.RULE_STACK, function (currShortName) {\n                return _this.shortRuleNameToFullName(currShortName);\n            });\n        }\n    };\n    return Recoverable;\n}());\n\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__[\"EOF\"];\n        nextTokIdx = 1;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY292ZXJhYmxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvdmVyYWJsZS5qcz8wZWZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVRva2VuSW5zdGFuY2UsIEVPRiB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWNcIjtcbmltcG9ydCB7IGNsb25lQXJyLCBjb250YWlucywgZHJvcFJpZ2h0LCBmaW5kLCBmbGF0dGVuLCBoYXMsIGlzRW1wdHksIG1hcCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljXCI7XG5pbXBvcnQgeyBJTiB9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbmV4cG9ydCB2YXIgRU9GX0ZPTExPV19LRVkgPSB7fTtcbmV4cG9ydCB2YXIgSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04gPSBcIkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uXCI7XG5leHBvcnQgZnVuY3Rpb24gSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9IElOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5JblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBlcnJvciByZWNvdmVyeSBhbmQgZmF1bHQgdG9sZXJhbnQgbG9naWNcbiAqL1xudmFyIFJlY292ZXJhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY292ZXJhYmxlKCkge1xuICAgIH1cbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuaW5pdFJlY292ZXJhYmxlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZXN5bmNGb2xsb3dzID0ge307XG4gICAgICAgIHRoaXMucmVjb3ZlcnlFbmFibGVkID0gaGFzKGNvbmZpZywgXCJyZWNvdmVyeUVuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlY292ZXJ5RW5hYmxlZFxuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcucmVjb3ZlcnlFbmFibGVkO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIE5PT1Agd2lsbCBiZSBpbmxpbmVkIHdoaWNoXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IG1lYW5zIHRoYXQgdGhpcyBvcHRpb25hbCBmZWF0dXJlIGRvZXMgbm90IGV4aXN0XG4gICAgICAgIC8vIHdoZW4gbm90IHVzZWQuXG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkgPSBhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3Zlcnk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5nZXRUb2tlblRvSW5zZXJ0ID0gZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgICAgICAgdmFyIHRva1RvSW5zZXJ0ID0gY3JlYXRlVG9rZW5JbnN0YW5jZSh0b2tUeXBlLCBcIlwiLCBOYU4sIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbiAgICAgICAgdG9rVG9JbnNlcnQuaXNJbnNlcnRlZEluUmVjb3ZlcnkgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdG9rVG9JbnNlcnQ7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkgPSBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS50cnlJblJlcGV0aXRpb25SZWNvdmVyeSA9IGZ1bmN0aW9uIChncmFtbWFyUnVsZSwgZ3JhbW1hclJ1bGVBcmdzLCBsb29rQWhlYWRGdW5jLCBleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVE9ETzogY2FuIHRoZSByZXN5bmNUb2tlblR5cGUgYmUgY2FjaGVkP1xuICAgICAgICB2YXIgcmVTeW5jVG9rVHlwZSA9IHRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpO1xuICAgICAgICB2YXIgc2F2ZWRMZXhlclN0YXRlID0gdGhpcy5leHBvcnRMZXhlclN0YXRlKCk7XG4gICAgICAgIHZhciByZXN5bmNlZFRva2VucyA9IFtdO1xuICAgICAgICB2YXIgcGFzc2VkUmVzeW5jUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG5leHRUb2tlbldpdGhvdXRSZXN5bmMgPSB0aGlzLkxBKDEpO1xuICAgICAgICB2YXIgY3VyclRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgdmFyIGdlbmVyYXRlRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzVG9rZW4gPSBfdGhpcy5MQSgwKTtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBwcmVlbXB0aXZlbHkgcmUtc3luY2luZyBiZWZvcmUgYW4gZXJyb3IgaGFzIGJlZW4gZGV0ZWN0ZWQsIHRoZXJlZm9yIHdlIG11c3QgcmVwcm9kdWNlXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgdGhhdCB3b3VsZCBoYXZlIGJlZW4gdGhyb3duXG4gICAgICAgICAgICB2YXIgbXNnID0gX3RoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkVG9rVHlwZSxcbiAgICAgICAgICAgICAgICBhY3R1YWw6IG5leHRUb2tlbldpdGhvdXRSZXN5bmMsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IF90aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKG1zZywgbmV4dFRva2VuV2l0aG91dFJlc3luYywgX3RoaXMuTEEoMCkpO1xuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHRva2VuIGhlcmUgd2lsbCBiZSB0aGUgb3JpZ2luYWwgY2F1c2Ugb2YgdGhlIGVycm9yLCB0aGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSByZXN5bmNlZFRva2VucyBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGVycm9yLnJlc3luY2VkVG9rZW5zID0gZHJvcFJpZ2h0KHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgICAgIF90aGlzLlNBVkVfRVJST1IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoIXBhc3NlZFJlc3luY1BvaW50KSB7XG4gICAgICAgICAgICAvLyByZS1zeW5jZWQgdG8gYSBwb2ludCB3aGVyZSB3ZSBjYW4gc2FmZWx5IGV4aXQgdGhlIHJlcGV0aXRpb24vXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbk1hdGNoZXIoY3VyclRva2VuLCBleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG11c3QgcmV0dXJuIGhlcmUgdG8gYXZvaWQgcmV2ZXJ0aW5nIHRoZSBpbnB1dElkeFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2tpcHBlZCBlbm91Z2ggdG9rZW5zIHNvIHdlIGNhbiByZXN5bmMgcmlnaHQgYmFjayBpbnRvIGFub3RoZXIgaXRlcmF0aW9uIG9mIHRoZSByZXBldGl0aW9uIGdyYW1tYXIgcnVsZVxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXJyb3JNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGludm9jYXRpb24gaW4gb3RoZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSByZS1zeW5jcyBpbiB0aGUgc2FtZSB0b3AgbGV2ZWwgcmVwZXRpdGlvbiBncmFtbWFyIHJ1bGVcbiAgICAgICAgICAgICAgICBncmFtbWFyUnVsZS5hcHBseSh0aGlzLCBncmFtbWFyUnVsZUFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbXVzdCByZXR1cm4gaGVyZSB0byBhdm9pZCByZXZlcnRpbmcgdGhlIGlucHV0SWR4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRva2VuTWF0Y2hlcihjdXJyVG9rZW4sIHJlU3luY1Rva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkUmVzeW5jUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyclRva2VuID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhjdXJyVG9rZW4sIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3ZXJlIHVuYWJsZSB0byBmaW5kIGEgQ0xPU0VSIHBvaW50IHRvIHJlc3luYyBpbnNpZGUgdGhlIFJlcGV0aXRpb24sIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGhlIHBhcnNpbmcgZXhjZXB0aW9uIHdlIHdlcmUgdHJ5aW5nIHRvIHByZXZlbnQgd2lsbCBoYXBwZW4gaW4gdGhlIE5FWFQgcGFyc2luZyBzdGVwLiBpdCBtYXkgYmUgaGFuZGxlZCBieVxuICAgICAgICAvLyBcImJldHdlZW4gcnVsZXNcIiByZXN5bmMgcmVjb3ZlcnkgbGF0ZXIgaW4gdGhlIGZsb3cuXG4gICAgICAgIHRoaXMuaW1wb3J0TGV4ZXJTdGF0ZShzYXZlZExleGVyU3RhdGUpO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLnNob3VsZEluUmVwZXRpdGlvblJlY292ZXJ5QmVUcmllZCA9IGZ1bmN0aW9uIChleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgbmV4dFRva0lkeCwgbm90U3R1Y2spIHtcbiAgICAgICAgLy8gRWRnZSBjYXNlIG9mIGFycml2aW5nIGZyb20gYSBNQU5ZIHJlcGV0aXRpb24gd2hpY2ggaXMgc3R1Y2tcbiAgICAgICAgLy8gQXR0ZW1wdGluZyByZWNvdmVyeSBpbiB0aGlzIGNhc2UgY291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICBpZiAobm90U3R1Y2sgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJndW1lbnRzIHRvIHRyeSBhbmQgcGVyZm9ybSByZXN5bmMgaW50byB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIG1hbnkgYXJlIG1pc3NpbmdcbiAgICAgICAgaWYgKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID09PSB1bmRlZmluZWQgfHwgbmV4dFRva0lkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gbmVlZCB0byByZWNvdmVyLCBuZXh0IHRva2VuIGlzIHdoYXQgd2UgZXhwZWN0Li4uXG4gICAgICAgIGlmICh0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLCBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlcnJvciByZWNvdmVyeSBpcyBkaXNhYmxlZCBkdXJpbmcgYmFja3RyYWNraW5nIGFzIGl0IGNhbiBtYWtlIHRoZSBwYXJzZXIgaWdub3JlIGEgdmFsaWQgZ3JhbW1hciBwYXRoXG4gICAgICAgIC8vIGFuZCBwcmVmZXIgc29tZSBiYWNrdHJhY2tpbmcgcGF0aCB0aGF0IGluY2x1ZGVzIHJlY292ZXJlZCBlcnJvcnMuXG4gICAgICAgIGlmICh0aGlzLmlzQmFja1RyYWNraW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBjYW4gcGVyZm9ybSBpblJ1bGUgcmVjb3ZlcnkgKHNpbmdsZSB0b2tlbiBpbnNlcnRpb24gb3IgZGVsZXRpb24pIHdlIGFsd2F5cyBwcmVmZXIgdGhhdCByZWNvdmVyeSBhbGdvcml0aG1cbiAgICAgICAgLy8gYmVjYXVzZSBpZiBpdCB3b3JrcywgaXQgbWFrZXMgdGhlIGxlYXN0IGFtb3VudCBvZiBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBzdHJlYW0gKGdyZWVkeSBhbGdvcml0aG0pXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIFJlZHVuZGFudElmU3RhdGVtZW50SlNcbiAgICAgICAgaWYgKHRoaXMuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5KGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCB0aGlzLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeShleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgbmV4dFRva0lkeCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBFcnJvciBSZWNvdmVyeSBmdW5jdGlvbmFsaXR5XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeSA9IGZ1bmN0aW9uICh0b2tUeXBlLCB0b2tJZHhJblJ1bGUpIHtcbiAgICAgICAgdmFyIGdyYW1tYXJQYXRoID0gdGhpcy5nZXRDdXJyZW50R3JhbW1hclBhdGgodG9rVHlwZSwgdG9rSWR4SW5SdWxlKTtcbiAgICAgICAgdmFyIGZvbGxvd3MgPSB0aGlzLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXMoZ3JhbW1hclBhdGgpO1xuICAgICAgICByZXR1cm4gZm9sbG93cztcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS50cnlJblJ1bGVSZWNvdmVyeSA9IGZ1bmN0aW9uIChleHBlY3RlZFRva1R5cGUsIGZvbGxvd3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbihleHBlY3RlZFRva1R5cGUsIGZvbGxvd3MpKSB7XG4gICAgICAgICAgICB2YXIgdG9rVG9JbnNlcnQgPSB0aGlzLmdldFRva2VuVG9JbnNlcnQoZXhwZWN0ZWRUb2tUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24oZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgdmFyIG5leHRUb2sgPSB0aGlzLlNLSVBfVE9LRU4oKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZVRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFRvaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24oXCJzYWQgc2FkIHBhbmRhXCIpO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeSA9IGZ1bmN0aW9uIChleHBlY3RlZFRva2VuLCBmb2xsb3dzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKGV4cGVjdGVkVG9rZW4sIGZvbGxvd3MpIHx8XG4gICAgICAgICAgICB0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva2VuKSk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbiA9IGZ1bmN0aW9uIChleHBlY3RlZFRva1R5cGUsIGZvbGxvd3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmNhblRva2VuVHlwZUJlSW5zZXJ0ZWRJblJlY292ZXJ5KGV4cGVjdGVkVG9rVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtdXN0IGtub3cgdGhlIHBvc3NpYmxlIGZvbGxvd2luZyB0b2tlbnMgdG8gcGVyZm9ybSBzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uXG4gICAgICAgIGlmIChpc0VtcHR5KGZvbGxvd3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pc21hdGNoZWRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICB2YXIgaXNNaXNNYXRjaGVkVG9rSW5Gb2xsb3dzID0gZmluZChmb2xsb3dzLCBmdW5jdGlvbiAocG9zc2libGVGb2xsb3dzVG9rVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRva2VuTWF0Y2hlcihtaXNtYXRjaGVkVG9rLCBwb3NzaWJsZUZvbGxvd3NUb2tUeXBlKTtcbiAgICAgICAgfSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzTWlzTWF0Y2hlZFRva0luRm9sbG93cztcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24gPSBmdW5jdGlvbiAoZXhwZWN0ZWRUb2tUeXBlKSB7XG4gICAgICAgIHZhciBpc05leHRUb2tlbldoYXRJc0V4cGVjdGVkID0gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgyKSwgZXhwZWN0ZWRUb2tUeXBlKTtcbiAgICAgICAgcmV0dXJuIGlzTmV4dFRva2VuV2hhdElzRXhwZWN0ZWQ7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0ID0gZnVuY3Rpb24gKHRva2VuVHlwZUlkeCkge1xuICAgICAgICB2YXIgZm9sbG93S2V5ID0gdGhpcy5nZXRDdXJyRm9sbG93S2V5KCk7XG4gICAgICAgIHZhciBjdXJyZW50UnVsZVJlU3luY1NldCA9IHRoaXMuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleShmb2xsb3dLZXkpO1xuICAgICAgICByZXR1cm4gY29udGFpbnMoY3VycmVudFJ1bGVSZVN5bmNTZXQsIHRva2VuVHlwZUlkeCk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZmluZFJlU3luY1Rva2VuVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbFBvc3NpYmxlUmVTeW5jVG9rVHlwZXMgPSB0aGlzLmZsYXR0ZW5Gb2xsb3dTZXQoKTtcbiAgICAgICAgLy8gdGhpcyBsb29wIHdpbGwgYWx3YXlzIHRlcm1pbmF0ZSBhcyBFT0YgaXMgYWx3YXlzIGluIHRoZSBmb2xsb3cgc3RhY2sgYW5kIGFsc28gYWx3YXlzICh2aXJ0dWFsbHkpIGluIHRoZSBpbnB1dFxuICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgdmFyIGsgPSAyO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5leHRUb2tlblR5cGUgPSBuZXh0VG9rZW4udG9rZW5UeXBlO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGFsbFBvc3NpYmxlUmVTeW5jVG9rVHlwZXMsIG5leHRUb2tlblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRUb2tlblR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0VG9rZW4gPSB0aGlzLkxBKGspO1xuICAgICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0Q3VyckZvbGxvd0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBpcyBhdCBsZWFzdCBvbmUgYXMgd2UgYWx3YXlzIGFkZCB0aGUgcnVsZU5hbWUgdG8gdGhlIHN0YWNrIGJlZm9yZSBpbnZva2luZyB0aGUgcnVsZS5cbiAgICAgICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBFT0ZfRk9MTE9XX0tFWTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyclJ1bGVTaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgdmFyIGN1cnJSdWxlSWR4ID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4KCk7XG4gICAgICAgIHZhciBwcmV2UnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGN1cnJSdWxlU2hvcnROYW1lKSxcbiAgICAgICAgICAgIGlkeEluQ2FsbGluZ1J1bGU6IGN1cnJSdWxlSWR4LFxuICAgICAgICAgICAgaW5SdWxlOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHByZXZSdWxlU2hvcnROYW1lKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmJ1aWxkRnVsbEZvbGxvd0tleVN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwbGljaXRSdWxlU3RhY2sgPSB0aGlzLlJVTEVfU1RBQ0s7XG4gICAgICAgIHZhciBleHBsaWNpdE9jY3VycmVuY2VTdGFjayA9IHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO1xuICAgICAgICBpZiAoIWlzRW1wdHkodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0spKSB7XG4gICAgICAgICAgICBleHBsaWNpdFJ1bGVTdGFjayA9IG1hcCh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSywgZnVuY3Rpb24gKGlkeCkgeyByZXR1cm4gX3RoaXMuUlVMRV9TVEFDS1tpZHhdOyB9KTtcbiAgICAgICAgICAgIGV4cGxpY2l0T2NjdXJyZW5jZVN0YWNrID0gbWFwKHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLCBmdW5jdGlvbiAoaWR4KSB7IHJldHVybiBfdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0tbaWR4XTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogb25seSBpdGVyYXRlIG92ZXIgZXhwbGljaXQgcnVsZXMgaGVyZVxuICAgICAgICByZXR1cm4gbWFwKGV4cGxpY2l0UnVsZVN0YWNrLCBmdW5jdGlvbiAocnVsZU5hbWUsIGlkeCkge1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFT0ZfRk9MTE9XX0tFWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IF90aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHJ1bGVOYW1lKSxcbiAgICAgICAgICAgICAgICBpZHhJbkNhbGxpbmdSdWxlOiBleHBsaWNpdE9jY3VycmVuY2VTdGFja1tpZHhdLFxuICAgICAgICAgICAgICAgIGluUnVsZTogX3RoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoZXhwbGljaXRSdWxlU3RhY2tbaWR4IC0gMV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5mbGF0dGVuRm9sbG93U2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZm9sbG93U3RhY2sgPSBtYXAodGhpcy5idWlsZEZ1bGxGb2xsb3dLZXlTdGFjaygpLCBmdW5jdGlvbiAoY3VycktleSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkoY3VycktleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxhdHRlbihmb2xsb3dTdGFjayk7XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleSA9IGZ1bmN0aW9uIChmb2xsb3dLZXkpIHtcbiAgICAgICAgaWYgKGZvbGxvd0tleSA9PT0gRU9GX0ZPTExPV19LRVkpIHtcbiAgICAgICAgICAgIHJldHVybiBbRU9GXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9sbG93TmFtZSA9IGZvbGxvd0tleS5ydWxlTmFtZSArXG4gICAgICAgICAgICBmb2xsb3dLZXkuaWR4SW5DYWxsaW5nUnVsZSArXG4gICAgICAgICAgICBJTiArXG4gICAgICAgICAgICBmb2xsb3dLZXkuaW5SdWxlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN5bmNGb2xsb3dzW2ZvbGxvd05hbWVdO1xuICAgIH07XG4gICAgLy8gSXQgZG9lcyBub3QgbWFrZSBhbnkgc2Vuc2UgdG8gaW5jbHVkZSBhIHZpcnR1YWwgRU9GIHRva2VuIGluIHRoZSBsaXN0IG9mIHJlc3luY2VkIHRva2Vuc1xuICAgIC8vIGFzIEVPRiBkb2VzIG5vdCByZWFsbHkgZXhpc3QgYW5kIHRodXMgZG9lcyBub3QgY29udGFpbiBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIChsaW5lL2NvbHVtbiBudW1iZXJzKVxuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5hZGRUb1Jlc3luY1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbiwgcmVzeW5jVG9rZW5zKSB7XG4gICAgICAgIGlmICghdGhpcy50b2tlbk1hdGNoZXIodG9rZW4sIEVPRikpIHtcbiAgICAgICAgICAgIHJlc3luY1Rva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzeW5jVG9rZW5zO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLnJlU3luY1RvID0gZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgICAgICAgdmFyIHJlc3luY2VkVG9rZW5zID0gW107XG4gICAgICAgIHZhciBuZXh0VG9rID0gdGhpcy5MQSgxKTtcbiAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5NYXRjaGVyKG5leHRUb2ssIHRva1R5cGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbmV4dFRvayA9IHRoaXMuU0tJUF9UT0tFTigpO1xuICAgICAgICAgICAgdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhuZXh0VG9rLCByZXN5bmNlZFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3QgdG9rZW4gaXMgbm90IHBhcnQgb2YgdGhlIGVycm9yLlxuICAgICAgICByZXR1cm4gZHJvcFJpZ2h0KHJlc3luY2VkVG9rZW5zKTtcbiAgICB9O1xuICAgIFJlY292ZXJhYmxlLnByb3RvdHlwZS5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkgPSBmdW5jdGlvbiAocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGRzbE1ldGhvZElkeCwgcHJvZE9jY3VycmVuY2UsIG5leHRUb2tzV2Fsa2VyLCBub3RTdHVjaykge1xuICAgICAgICAvLyBieSBkZWZhdWx0IHRoaXMgaXMgYSBOTy1PUFxuICAgICAgICAvLyBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIHdpdGggdGhlIGZ1bmN0aW9uKG5vdCBtZXRob2QpIGJlbG93XG4gICAgfTtcbiAgICBSZWNvdmVyYWJsZS5wcm90b3R5cGUuZ2V0Q3VycmVudEdyYW1tYXJQYXRoID0gZnVuY3Rpb24gKHRva1R5cGUsIHRva0lkeEluUnVsZSkge1xuICAgICAgICB2YXIgcGF0aFJ1bGVTdGFjayA9IHRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpO1xuICAgICAgICB2YXIgcGF0aE9jY3VycmVuY2VTdGFjayA9IGNsb25lQXJyKHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLKTtcbiAgICAgICAgdmFyIGdyYW1tYXJQYXRoID0ge1xuICAgICAgICAgICAgcnVsZVN0YWNrOiBwYXRoUnVsZVN0YWNrLFxuICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBwYXRoT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgbGFzdFRvazogdG9rVHlwZSxcbiAgICAgICAgICAgIGxhc3RUb2tPY2N1cnJlbmNlOiB0b2tJZHhJblJ1bGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGdyYW1tYXJQYXRoO1xuICAgIH07XG4gICAgUmVjb3ZlcmFibGUucHJvdG90eXBlLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eSh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSykpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0ssIGZ1bmN0aW9uIChjdXJySWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKF90aGlzLlJVTEVfU1RBQ0tbY3VycklkeF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwKHRoaXMuUlVMRV9TVEFDSywgZnVuY3Rpb24gKGN1cnJTaG9ydE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoY3VyclNob3J0TmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlY292ZXJhYmxlO1xufSgpKTtcbmV4cG9ydCB7IFJlY292ZXJhYmxlIH07XG5leHBvcnQgZnVuY3Rpb24gYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHByb2RGdW5jLCBhcmdzLCBsb29rYWhlYWRGdW5jLCBkc2xNZXRob2RJZHgsIHByb2RPY2N1cnJlbmNlLCBuZXh0VG9rc1dhbGtlciwgbm90U3R1Y2spIHtcbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgdmFyIGZpcnN0QWZ0ZXJSZXBJbmZvID0gdGhpcy5maXJzdEFmdGVyUmVwTWFwW2tleV07XG4gICAgaWYgKGZpcnN0QWZ0ZXJSZXBJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGN1cnJSdWxlTmFtZSA9IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO1xuICAgICAgICB2YXIgcnVsZUdyYW1tYXIgPSB0aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpW2N1cnJSdWxlTmFtZV07XG4gICAgICAgIHZhciB3YWxrZXIgPSBuZXcgbmV4dFRva3NXYWxrZXIocnVsZUdyYW1tYXIsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgZmlyc3RBZnRlclJlcEluZm8gPSB3YWxrZXIuc3RhcnRXYWxraW5nKCk7XG4gICAgICAgIHRoaXMuZmlyc3RBZnRlclJlcE1hcFtrZXldID0gZmlyc3RBZnRlclJlcEluZm87XG4gICAgfVxuICAgIHZhciBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IGZpcnN0QWZ0ZXJSZXBJbmZvLnRva2VuO1xuICAgIHZhciBuZXh0VG9rSWR4ID0gZmlyc3RBZnRlclJlcEluZm8ub2NjdXJyZW5jZTtcbiAgICB2YXIgaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyUmVwSW5mby5pc0VuZE9mUnVsZTtcbiAgICAvLyBzcGVjaWFsIGVkZ2UgY2FzZSBvZiBhIFRPUCBtb3N0IHJlcGV0aXRpb24gYWZ0ZXIgd2hpY2ggdGhlIGlucHV0IHNob3VsZCBFTkQuXG4gICAgLy8gdGhpcyB3aWxsIGZvcmNlIGFuIGF0dGVtcHQgZm9yIGluUnVsZSByZWNvdmVyeSBpbiB0aGF0IHNjZW5hcmlvLlxuICAgIGlmICh0aGlzLlJVTEVfU1RBQ0subGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlzRW5kT2ZSdWxlICYmXG4gICAgICAgIGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPSBFT0Y7XG4gICAgICAgIG5leHRUb2tJZHggPSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgsIG5vdFN0dWNrKSkge1xuICAgICAgICAvLyBUT0RPOiBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGluc3RlYWQgb2YgcGFzc2luZyB0aGUgb3JpZ2luYWwgYXJncyBoZXJlLCB3ZSBtb2RpZnlcbiAgICAgICAgLy8gdGhlIGFyZ3MgcGFyYW0gKG9yIGNyZWF0ZSBhIG5ldyBvbmUpIGFuZCBtYWtlIHN1cmUgdGhlIGxvb2thaGVhZCBmdW5jIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWRcbiAgICAgICAgLy8gdG8gYXZvaWQgc2VhcmNoaW5nIHRoZSBjYWNoZSBmb3IgaXQgb25jZSBtb3JlLlxuICAgICAgICB0aGlzLnRyeUluUmVwZXRpdGlvblJlY292ZXJ5KHByb2RGdW5jLCBhcmdzLCBsb29rYWhlYWRGdW5jLCBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVjb3ZlcmFibGUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/recoverable.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js ***!
  \*********************************************************************************/
/*! exports provided: TreeBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeBuilder\", function() { return TreeBuilder; });\n/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../cst/cst */ \"./node_modules/chevrotain/lib_esm/src/parse/cst/cst.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../cst/cst_visitor */ \"./node_modules/chevrotain/lib_esm/src/parse/cst/cst_visitor.js\");\n/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/keys */ \"./node_modules/chevrotain/lib_esm/src/parse/grammar/keys.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser */ \"./node_modules/chevrotain/lib_esm/src/parse/parser/parser.js\");\n\n\n\n\n\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.LAST_EXPLICIT_RULE_STACK = [];\n        this.CST_STACK = [];\n        this.outputCst = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"has\"])(config, \"outputCst\")\n            ? config.outputCst\n            : _parser__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_PARSER_CONFIG\"].outputCst;\n        this.nodeLocationTracking = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"has\"])(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking\n            : _parser__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_PARSER_CONFIG\"].nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n            this.cstFinallyStateUpdate = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n            this.cstPostTerminal = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n            this.cstPostNonTerminal = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n            this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n            this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;\n            this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;\n            this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;\n            this.manyInternal = this.manyInternalNoCst;\n            this.orInternal = this.orInternalNoCst;\n            this.optionInternal = this.optionInternalNoCst;\n            this.atLeastOneInternal = this.atLeastOneInternalNoCst;\n            this.manySepFirstInternal = this.manySepFirstInternalNoCst;\n            this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = _cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"setNodeLocationFull\"];\n                    this.setNodeLocationFromNode = _cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"setNodeLocationFull\"];\n                    this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = (_cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"setNodeLocationOnlyOffset\"]);\n                    this.setNodeLocationFromNode = (_cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"setNodeLocationOnlyOffset\"]);\n                    this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                this.setInitialNodeLocation = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    // CST\n    TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {\n        var cstNode = {\n            name: nestedName,\n            fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] +\n                nestedName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);\n        var cstNode = {\n            name: fullRuleName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.LAST_EXPLICIT_RULE_STACK.pop();\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {\n        var lastCstNode = this.CST_STACK.pop();\n        // TODO: the naming is bad, this should go directly to the\n        //       (correct) cstLocation update method\n        //       e.g if we put other logic in postRule...\n        this.cstPostRule(lastCstNode);\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode or its nested children.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode or its nested children.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        Object(_cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"addTerminalToCst\"])(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        // Avoid side effects due to back tracking\n        // TODO: This costs a 2-3% in performance, A flag on IParserConfig\n        //   could be used to get rid of this conditional, but not sure its worth the effort\n        //   and API complexity.\n        if (this.isBackTracking() !== true) {\n            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n            Object(_cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"addNoneTerminalToCst\"])(preCstNode, ruleName, ruleCstResult);\n            // This is only used when **both** error recovery and CST Output are enabled.\n            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n        }\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = Object(_cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__[\"createBaseSemanticVisitorConstructor\"])(this.className, this.allRuleNames);\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = Object(_cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__[\"createBaseVisitorConstructorWithDefaults\"])(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {\n        var nestedName;\n        if (methodOpts.NAME !== undefined) {\n            nestedName = methodOpts.NAME;\n            this.nestedRuleInvocationStateUpdate(nestedName, laKey);\n            return nestedName;\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {\n        var ruleIdx = this.getLastExplicitRuleShortName();\n        var shortName = Object(_grammar_keys__WEBPACK_IMPORTED_MODULE_3__[\"getKeyForAltIndex\"])(ruleIdx, methodKeyIdx, occurrence, altIdx);\n        var nestedName;\n        if (methodOpts.NAME !== undefined) {\n            nestedName = methodOpts.NAME;\n            this.nestedRuleInvocationStateUpdate(nestedName, shortName);\n            return {\n                shortName: shortName,\n                nestedName: nestedName\n            };\n        }\n        else {\n            return undefined;\n        }\n    };\n    TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {\n        var cstStack = this.CST_STACK;\n        var nestedRuleCst = cstStack[cstStack.length - 1];\n        this.nestedRuleFinallyStateUpdate();\n        // this return a different result than the previous invocation because \"nestedRuleFinallyStateUpdate\" pops the cst stack\n        var parentCstNode = cstStack[cstStack.length - 1];\n        Object(_cst_cst__WEBPACK_IMPORTED_MODULE_0__[\"addNoneTerminalToCst\"])(parentCstNode, nestedName, nestedRuleCst);\n        this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n        return this.RULE_STACK[lastExplictIndex];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];\n        return this.RULE_STACK[lastExplicitIndex];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n        return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {\n        this.RULE_OCCURRENCE_STACK.push(1);\n        this.RULE_STACK.push(shortNameKey);\n        this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);\n    };\n    TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstNestedFinallyStateUpdate();\n    };\n    return TreeBuilder;\n}());\n\n//# sourceMappingURL=tree_builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3RyZWVfYnVpbGRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvdHJlZV9idWlsZGVyLmpzPzJiMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkTm9uZVRlcm1pbmFsVG9Dc3QsIGFkZFRlcm1pbmFsVG9Dc3QsIHNldE5vZGVMb2NhdGlvbkZ1bGwsIHNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQgfSBmcm9tIFwiLi4vLi4vY3N0L2NzdFwiO1xuaW1wb3J0IHsgaGFzLCBpc1VuZGVmaW5lZCwgTk9PUCB9IGZyb20gXCIuLi8uLi8uLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yLCBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzIH0gZnJvbSBcIi4uLy4uL2NzdC9jc3RfdmlzaXRvclwiO1xuaW1wb3J0IHsgZ2V0S2V5Rm9yQWx0SW5kZXggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyXCI7XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBDU1QgYnVpbGRpbmcgbG9naWMuXG4gKi9cbnZhciBUcmVlQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmVlQnVpbGRlcigpIHtcbiAgICB9XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmluaXRUcmVlQnVpbGRlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRDc3QgPSBoYXMoY29uZmlnLCBcIm91dHB1dENzdFwiKVxuICAgICAgICAgICAgPyBjb25maWcub3V0cHV0Q3N0XG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5vdXRwdXRDc3Q7XG4gICAgICAgIHRoaXMubm9kZUxvY2F0aW9uVHJhY2tpbmcgPSBoYXMoY29uZmlnLCBcIm5vZGVMb2NhdGlvblRyYWNraW5nXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5ub2RlTG9jYXRpb25UcmFja2luZ1xuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcubm9kZUxvY2F0aW9uVHJhY2tpbmc7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlID0gTk9PUDtcbiAgICAgICAgICAgIHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlID0gTk9PUDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdFRlcm1pbmFsID0gTk9PUDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsID0gTk9PUDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBOT09QO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZU5vQ3N0O1xuICAgICAgICAgICAgdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4ID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4Tm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCA9IHRoaXMubWFueUludGVybmFsTm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLm9ySW50ZXJuYWwgPSB0aGlzLm9ySW50ZXJuYWxOb0NzdDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uSW50ZXJuYWwgPSB0aGlzLm9wdGlvbkludGVybmFsTm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCA9IHRoaXMuYXRMZWFzdE9uZUludGVybmFsTm9Dc3Q7XG4gICAgICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsID0gdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbE5vQ3N0O1xuICAgICAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCA9IHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxOb0NzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgvZnVsbC9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBzZXROb2RlTG9jYXRpb25GdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gc2V0Tm9kZUxvY2F0aW9uRnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IE5PT1A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9IHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWNvdmVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IE5PT1A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSB0aGlzLmNzdFBvc3RSdWxlRnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlZ3VsYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL29ubHlPZmZzZXQvaS50ZXN0KHRoaXMubm9kZUxvY2F0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbVRva2VuID0gKHNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gKHNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBOT09QO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IHRoaXMuY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvbm9uZS9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IE5PT1A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IE5PT1A7XG4gICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IE5PT1A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gTk9PUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCA8bm9kZUxvY2F0aW9uVHJhY2tpbmc+IGNvbmZpZyBvcHRpb246IFxcXCJcIiArIGNvbmZpZy5ub2RlTG9jYXRpb25UcmFja2luZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3ZlcnkgPSBmdW5jdGlvbiAoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbk9ubHlPZmZzZXRSZWd1bGFyID0gZnVuY3Rpb24gKGNzdE5vZGUpIHtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgZXJyb3IgcmVjb3ZlcnkgdGhlIHN0YXJ0aW5nIExvY2F0aW9uIG9mIGEgbmV3IENzdE5vZGUgaXMgZ3VhcmFudGVlZFxuICAgICAgICAgICAgLy8gVG8gYmUgdGhlIG5leHQgVG9rZW4ncyBzdGFydE9mZnNldCAoZm9yIHZhbGlkIGlucHV0cykuXG4gICAgICAgICAgICAvLyBGb3IgaW52YWxpZCBpbnB1dHMgdGhlcmUgd29uJ3QgYmUgYW55IENTVE91dHB1dCBzbyB0aGlzIHBvdGVudGlhbFxuICAgICAgICAgICAgLy8gaW5hY2N1cmFjeSBkb2VzIG5vdCBtYXR0ZXJcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiB0aGlzLkxBKDEpLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5ID0gZnVuY3Rpb24gKGNzdE5vZGUpIHtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBzdGFydExpbmU6IE5hTixcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBOYU4sXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZExpbmU6IE5hTixcbiAgICAgICAgICAgIGVuZENvbHVtbjogTmFOXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgQHNlZSBzZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIgZm9yIGV4cGxhbmF0aW9uIHdoeSB0aGlzIHdvcmtcblxuICAgICAqIEBwYXJhbSBjc3ROb2RlXG4gICAgICovXG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVndWxhciA9IGZ1bmN0aW9uIChjc3ROb2RlKSB7XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG5leHRUb2tlbi5zdGFydE9mZnNldCxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogbmV4dFRva2VuLnN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBuZXh0VG9rZW4uc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZExpbmU6IE5hTixcbiAgICAgICAgICAgIGVuZENvbHVtbjogTmFOXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBDU1RcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0TmVzdGVkSW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKG5lc3RlZE5hbWUsIHNob3J0TmFtZSkge1xuICAgICAgICB2YXIgY3N0Tm9kZSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5lc3RlZE5hbWUsXG4gICAgICAgICAgICBmdWxsTmFtZTogdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3RoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpXSArXG4gICAgICAgICAgICAgICAgbmVzdGVkTmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24oY3N0Tm9kZSk7XG4gICAgICAgIHRoaXMuQ1NUX1NUQUNLLnB1c2goY3N0Tm9kZSk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKGZ1bGxSdWxlTmFtZSwgc2hvcnROYW1lKSB7XG4gICAgICAgIHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLnB1c2godGhpcy5SVUxFX1NUQUNLLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgY3N0Tm9kZSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGZ1bGxSdWxlTmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24oY3N0Tm9kZSk7XG4gICAgICAgIHRoaXMuQ1NUX1NUQUNLLnB1c2goY3N0Tm9kZSk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0RmluYWxseVN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5wb3AoKTtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sucG9wKCk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0TmVzdGVkRmluYWxseVN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFzdENzdE5vZGUgPSB0aGlzLkNTVF9TVEFDSy5wb3AoKTtcbiAgICAgICAgLy8gVE9ETzogdGhlIG5hbWluZyBpcyBiYWQsIHRoaXMgc2hvdWxkIGdvIGRpcmVjdGx5IHRvIHRoZVxuICAgICAgICAvLyAgICAgICAoY29ycmVjdCkgY3N0TG9jYXRpb24gdXBkYXRlIG1ldGhvZFxuICAgICAgICAvLyAgICAgICBlLmcgaWYgd2UgcHV0IG90aGVyIGxvZ2ljIGluIHBvc3RSdWxlLi4uXG4gICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUobGFzdENzdE5vZGUpO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmNzdFBvc3RSdWxlRnVsbCA9IGZ1bmN0aW9uIChydWxlQ3N0Tm9kZSkge1xuICAgICAgICB2YXIgcHJldlRva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgdmFyIGxvYyA9IHJ1bGVDc3ROb2RlLmxvY2F0aW9uO1xuICAgICAgICAvLyBJZiB0aGlzIGNvbmRpdGlvbiBpcyB0cnVlIGl0IG1lYW5zIHdlIGNvbnN1bWVkIGF0IGxlYXN0IG9uZSBUb2tlblxuICAgICAgICAvLyBJbiB0aGlzIENzdE5vZGUgb3IgaXRzIG5lc3RlZCBjaGlsZHJlbi5cbiAgICAgICAgaWYgKGxvYy5zdGFydE9mZnNldCA8PSBwcmV2VG9rZW4uc3RhcnRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBwcmV2VG9rZW4uZW5kT2Zmc2V0O1xuICAgICAgICAgICAgbG9jLmVuZExpbmUgPSBwcmV2VG9rZW4uZW5kTGluZTtcbiAgICAgICAgICAgIGxvYy5lbmRDb2x1bW4gPSBwcmV2VG9rZW4uZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiZW1wdHlcIiBDc3ROb2RlIGVkZ2UgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5zdGFydE9mZnNldCA9IE5hTjtcbiAgICAgICAgICAgIGxvYy5zdGFydExpbmUgPSBOYU47XG4gICAgICAgICAgICBsb2Muc3RhcnRDb2x1bW4gPSBOYU47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RQb3N0UnVsZU9ubHlPZmZzZXQgPSBmdW5jdGlvbiAocnVsZUNzdE5vZGUpIHtcbiAgICAgICAgdmFyIHByZXZUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIHZhciBsb2MgPSBydWxlQ3N0Tm9kZS5sb2NhdGlvbjtcbiAgICAgICAgLy8gSWYgdGhpcyBjb25kaXRpb24gaXMgdHJ1ZSBpdCBtZWFucyB3ZSBjb25zdW1lZCBhdCBsZWFzdCBvbmUgVG9rZW5cbiAgICAgICAgLy8gSW4gdGhpcyBDc3ROb2RlIG9yIGl0cyBuZXN0ZWQgY2hpbGRyZW4uXG4gICAgICAgIGlmIChsb2Muc3RhcnRPZmZzZXQgPD0gcHJldlRva2VuLnN0YXJ0T2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2MuZW5kT2Zmc2V0ID0gcHJldlRva2VuLmVuZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBcImVtcHR5XCIgQ3N0Tm9kZSBlZGdlIGNhc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2Muc3RhcnRPZmZzZXQgPSBOYU47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5jc3RQb3N0VGVybWluYWwgPSBmdW5jdGlvbiAoa2V5LCBjb25zdW1lZFRva2VuKSB7XG4gICAgICAgIHZhciByb290Q3N0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIGFkZFRlcm1pbmFsVG9Dc3Qocm9vdENzdCwgY29uc3VtZWRUb2tlbiwga2V5KTtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4ocm9vdENzdC5sb2NhdGlvbiwgY29uc3VtZWRUb2tlbik7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuY3N0UG9zdE5vblRlcm1pbmFsID0gZnVuY3Rpb24gKHJ1bGVDc3RSZXN1bHQsIHJ1bGVOYW1lKSB7XG4gICAgICAgIC8vIEF2b2lkIHNpZGUgZWZmZWN0cyBkdWUgdG8gYmFjayB0cmFja2luZ1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNvc3RzIGEgMi0zJSBpbiBwZXJmb3JtYW5jZSwgQSBmbGFnIG9uIElQYXJzZXJDb25maWdcbiAgICAgICAgLy8gICBjb3VsZCBiZSB1c2VkIHRvIGdldCByaWQgb2YgdGhpcyBjb25kaXRpb25hbCwgYnV0IG5vdCBzdXJlIGl0cyB3b3J0aCB0aGUgZWZmb3J0XG4gICAgICAgIC8vICAgYW5kIEFQSSBjb21wbGV4aXR5LlxuICAgICAgICBpZiAodGhpcy5pc0JhY2tUcmFja2luZygpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcHJlQ3N0Tm9kZSA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgYWRkTm9uZVRlcm1pbmFsVG9Dc3QocHJlQ3N0Tm9kZSwgcnVsZU5hbWUsIHJ1bGVDc3RSZXN1bHQpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUocHJlQ3N0Tm9kZS5sb2NhdGlvbiwgcnVsZUNzdFJlc3VsdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgdmFyIG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IodGhpcy5jbGFzc05hbWUsIHRoaXMuYWxsUnVsZU5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvciA9IG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgbmV3Q29uc3RydWN0b3IgPSBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKHRoaXMuY2xhc3NOYW1lLCB0aGlzLmFsbFJ1bGVOYW1lcywgdGhpcy5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKCkpO1xuICAgICAgICAgICAgdGhpcy5iYXNlQ3N0VmlzaXRvcldpdGhEZWZhdWx0c0NvbnN0cnVjdG9yID0gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gbmV3Q29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3RvcjtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlID0gZnVuY3Rpb24gKG1ldGhvZE9wdHMsIGxhS2V5KSB7XG4gICAgICAgIHZhciBuZXN0ZWROYW1lO1xuICAgICAgICBpZiAobWV0aG9kT3B0cy5OQU1FICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5lc3RlZE5hbWUgPSBtZXRob2RPcHRzLk5BTUU7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUobmVzdGVkTmFtZSwgbGFLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIG5lc3RlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUubmVzdGVkQWx0QmVmb3JlQ2xhdXNlID0gZnVuY3Rpb24gKG1ldGhvZE9wdHMsIG9jY3VycmVuY2UsIG1ldGhvZEtleUlkeCwgYWx0SWR4KSB7XG4gICAgICAgIHZhciBydWxlSWR4ID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHZhciBzaG9ydE5hbWUgPSBnZXRLZXlGb3JBbHRJbmRleChydWxlSWR4LCBtZXRob2RLZXlJZHgsIG9jY3VycmVuY2UsIGFsdElkeCk7XG4gICAgICAgIHZhciBuZXN0ZWROYW1lO1xuICAgICAgICBpZiAobWV0aG9kT3B0cy5OQU1FICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5lc3RlZE5hbWUgPSBtZXRob2RPcHRzLk5BTUU7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZFJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUobmVzdGVkTmFtZSwgc2hvcnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2hvcnROYW1lOiBzaG9ydE5hbWUsXG4gICAgICAgICAgICAgICAgbmVzdGVkTmFtZTogbmVzdGVkTmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZSA9IGZ1bmN0aW9uIChsYUtleSwgbmVzdGVkTmFtZSkge1xuICAgICAgICB2YXIgY3N0U3RhY2sgPSB0aGlzLkNTVF9TVEFDSztcbiAgICAgICAgdmFyIG5lc3RlZFJ1bGVDc3QgPSBjc3RTdGFja1tjc3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5uZXN0ZWRSdWxlRmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgICAgIC8vIHRoaXMgcmV0dXJuIGEgZGlmZmVyZW50IHJlc3VsdCB0aGFuIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uIGJlY2F1c2UgXCJuZXN0ZWRSdWxlRmluYWxseVN0YXRlVXBkYXRlXCIgcG9wcyB0aGUgY3N0IHN0YWNrXG4gICAgICAgIHZhciBwYXJlbnRDc3ROb2RlID0gY3N0U3RhY2tbY3N0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGFkZE5vbmVUZXJtaW5hbFRvQ3N0KHBhcmVudENzdE5vZGUsIG5lc3RlZE5hbWUsIG5lc3RlZFJ1bGVDc3QpO1xuICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlKHBhcmVudENzdE5vZGUubG9jYXRpb24sIG5lc3RlZFJ1bGVDc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXN0RXhwbGljdEluZGV4ID0gdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0tbdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB0aGlzLlJVTEVfU1RBQ0tbbGFzdEV4cGxpY3RJbmRleF07XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZU5vQ3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnVsZVN0YWNrID0gdGhpcy5SVUxFX1NUQUNLO1xuICAgICAgICByZXR1cm4gcnVsZVN0YWNrW3J1bGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3RFeHBsaWNpdEluZGV4ID0gdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0tbdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0subGVuZ3RoIC0gMl07XG4gICAgICAgIHJldHVybiB0aGlzLlJVTEVfU1RBQ0tbbGFzdEV4cGxpY2l0SW5kZXhdO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydWxlU3RhY2sgPSB0aGlzLlJVTEVfU1RBQ0s7XG4gICAgICAgIHJldHVybiBydWxlU3RhY2tbcnVsZVN0YWNrLmxlbmd0aCAtIDJdO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXN0RXhwbGljaXRJbmRleCA9IHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLW3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0tbbGFzdEV4cGxpY2l0SW5kZXhdO1xuICAgIH07XG4gICAgVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXhOb0NzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9jY3VycmVuY2VTdGFjayA9IHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO1xuICAgICAgICByZXR1cm4gb2NjdXJyZW5jZVN0YWNrW29jY3VycmVuY2VTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFRyZWVCdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWRSdWxlSW52b2NhdGlvblN0YXRlVXBkYXRlID0gZnVuY3Rpb24gKG5lc3RlZFJ1bGVOYW1lLCBzaG9ydE5hbWVLZXkpIHtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaCgxKTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnB1c2goc2hvcnROYW1lS2V5KTtcbiAgICAgICAgdGhpcy5jc3ROZXN0ZWRJbnZvY2F0aW9uU3RhdGVVcGRhdGUobmVzdGVkUnVsZU5hbWUsIHNob3J0TmFtZUtleSk7XG4gICAgfTtcbiAgICBUcmVlQnVpbGRlci5wcm90b3R5cGUubmVzdGVkUnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnBvcCgpO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wb3AoKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdE5lc3RlZEZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyZWVCdWlsZGVyO1xufSgpKTtcbmV4cG9ydCB7IFRyZWVCdWlsZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmVlX2J1aWxkZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/parse/parser/traits/tree_builder.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/lexer.js":
/*!***********************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/lexer.js ***!
  \***********************************************************/
/*! exports provided: DEFAULT_MODE, MODES, SUPPORT_STICKY, disableSticky, enableSticky, analyzeTokenTypes, validatePatterns, findMissingPatterns, findInvalidPatterns, findEndOfInputAnchor, findEmptyMatchRegExps, findStartOfInputAnchor, findUnsupportedFlags, findDuplicatePatterns, findInvalidGroupType, findModesThatDoNotExist, findUnreachablePatterns, addStartOfInput, addStickyFlag, performRuntimeChecks, performWarningRuntimeChecks, cloneEmptyGroups, isCustomPattern, isShortPattern, LineTerminatorOptimizedTester, buildLineBreakIssueMessage, minOptimizationVal, charCodeToOptimizedIndex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_MODE\", function() { return DEFAULT_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MODES\", function() { return MODES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SUPPORT_STICKY\", function() { return SUPPORT_STICKY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"disableSticky\", function() { return disableSticky; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableSticky\", function() { return enableSticky; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeTokenTypes\", function() { return analyzeTokenTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validatePatterns\", function() { return validatePatterns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findMissingPatterns\", function() { return findMissingPatterns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findInvalidPatterns\", function() { return findInvalidPatterns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findEndOfInputAnchor\", function() { return findEndOfInputAnchor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findEmptyMatchRegExps\", function() { return findEmptyMatchRegExps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findStartOfInputAnchor\", function() { return findStartOfInputAnchor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findUnsupportedFlags\", function() { return findUnsupportedFlags; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findDuplicatePatterns\", function() { return findDuplicatePatterns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findInvalidGroupType\", function() { return findInvalidGroupType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findModesThatDoNotExist\", function() { return findModesThatDoNotExist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findUnreachablePatterns\", function() { return findUnreachablePatterns; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addStartOfInput\", function() { return addStartOfInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addStickyFlag\", function() { return addStickyFlag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"performRuntimeChecks\", function() { return performRuntimeChecks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"performWarningRuntimeChecks\", function() { return performWarningRuntimeChecks; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneEmptyGroups\", function() { return cloneEmptyGroups; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCustomPattern\", function() { return isCustomPattern; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isShortPattern\", function() { return isShortPattern; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LineTerminatorOptimizedTester\", function() { return LineTerminatorOptimizedTester; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildLineBreakIssueMessage\", function() { return buildLineBreakIssueMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minOptimizationVal\", function() { return minOptimizationVal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"charCodeToOptimizedIndex\", function() { return charCodeToOptimizedIndex; });\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regexp-to-ast */ \"./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexer_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer_public */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _reg_exp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reg_exp */ \"./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js\");\n/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reg_exp_parser */ \"./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar PATTERN = \"PATTERN\";\nvar DEFAULT_MODE = \"defaultMode\";\nvar MODES = \"modes\";\nvar SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\nfunction disableSticky() {\n    SUPPORT_STICKY = false;\n}\nfunction enableSticky() {\n    SUPPORT_STICKY = true;\n}\nfunction analyzeTokenTypes(tokenTypes, options) {\n    options = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"defaults\"])(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function (msg, action) { return action(); }\n    });\n    var tracer = options.tracer;\n    tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n    });\n    var onlyRelevantTypes;\n    tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"reject\"])(tokenTypes, function (currType) {\n            return currType[PATTERN] === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].NA;\n        });\n    });\n    var hasCustom = false;\n    var allTransformedPatterns;\n    tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (currType) {\n            var currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(currPattern)) {\n                var regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== \"^\" &&\n                    regExpSource !== \"$\" &&\n                    regExpSource !== \".\") {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === \"\\\\\" &&\n                    // not a meta character\n                    !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"contains\"])([\n                        \"d\",\n                        \"D\",\n                        \"s\",\n                        \"S\",\n                        \"t\",\n                        \"r\",\n                        \"n\",\n                        \"t\",\n                        \"0\",\n                        \"c\",\n                        \"b\",\n                        \"B\",\n                        \"f\",\n                        \"v\",\n                        \"w\",\n                        \"W\"\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping \"\\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(currPattern, \"exec\")) {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === \"string\") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                    var wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    });\n    var patternIdxToType;\n    var patternIdxToGroup;\n    var patternIdxToLongerAltIdx;\n    var patternIdxToPushMode;\n    var patternIdxToPopMode;\n    tracer(\"misc mapping\", function () {\n        patternIdxToType = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });\n        patternIdxToGroup = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (clazz) {\n            var groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].SKIPPED) {\n                return undefined;\n            }\n            else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(groupName)) {\n                return groupName;\n            }\n            else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isUndefined\"])(groupName)) {\n                return false;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n        patternIdxToLongerAltIdx = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (clazz) {\n            var longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                var longerAltIdx = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"indexOf\"])(onlyRelevantTypes, longerAltType);\n                return longerAltIdx;\n            }\n        });\n        patternIdxToPushMode = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });\n        patternIdxToPopMode = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (clazz) {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(clazz, \"POP_MODE\");\n        });\n    });\n    var patternIdxToCanLineTerminator;\n    tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (tokType) { return false; });\n        if (options.positionTracking !== \"onlyOffset\") {\n            patternIdxToCanLineTerminator = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, function (tokType) {\n                if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(tokType, \"LINE_BREAKS\")) {\n                    return tokType.LINE_BREAKS;\n                }\n                else {\n                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {\n                        return Object(_reg_exp__WEBPACK_IMPORTED_MODULE_3__[\"canMatchCharCode\"])(lineTerminatorCharCodes, tokType.PATTERN);\n                    }\n                }\n            });\n        }\n    });\n    var patternIdxToIsCustom;\n    var patternIdxToShort;\n    var emptyGroups;\n    var patternIdxToConfig;\n    tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(allTransformedPatterns, isShortPattern);\n        emptyGroups = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"reduce\"])(onlyRelevantTypes, function (acc, clazz) {\n            var groupName = clazz.GROUP;\n            if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(groupName) && !(groupName === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(allTransformedPatterns, function (x, idx) {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdx[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx]\n            };\n        });\n    });\n    var canBeOptimized = true;\n    var charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n            charCodeToPatternIdxToConfig = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"reduce\"])(onlyRelevantTypes, function (result, currTokType, idx) {\n                if (typeof currTokType.PATTERN === \"string\") {\n                    var charCode = currTokType.PATTERN.charCodeAt(0);\n                    var optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isArray\"])(currTokType.START_CHARS_HINT)) {\n                    var lastOptimizedIdx_1;\n                    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(currTokType.START_CHARS_HINT, function (charOrInt) {\n                        var charCode = typeof charOrInt === \"string\"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {\n                            lastOptimizedIdx_1 = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"PRINT_ERROR\"])(\"\" + _reg_exp__WEBPACK_IMPORTED_MODULE_3__[\"failedOptimizationPrefixMsg\"] +\n                                (\"\\tUnable to analyze < \" + currTokType.PATTERN.toString() + \" > pattern.\\n\") +\n                                \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                                \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                                \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");\n                        }\n                    }\n                    else {\n                        var optimizedCodes = Object(_reg_exp__WEBPACK_IMPORTED_MODULE_3__[\"getOptimizedStartCodesIndices\"])(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isEmpty\"])(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(optimizedCodes, function (code) {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"PRINT_ERROR\"])(\"\" + _reg_exp__WEBPACK_IMPORTED_MODULE_3__[\"failedOptimizationPrefixMsg\"] +\n                            (\"\\tTokenType: <\" + currTokType.name + \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\") +\n                            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    tracer(\"ArrayPacking\", function () {\n        charCodeToPatternIdxToConfig = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"packArray\"])(charCodeToPatternIdxToConfig);\n    });\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n    };\n}\nfunction validatePatterns(tokenTypes, validModesNames) {\n    var errors = [];\n    var missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    var invalidResult = findInvalidPatterns(missingResult.valid);\n    var validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    var errors = [];\n    var withRegExpPatterns = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currTokType) {\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(currTokType[PATTERN]);\n    });\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n    var tokenTypesWithMissingPattern = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currType) {\n        return !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(currType, PATTERN);\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(tokenTypesWithMissingPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- missing static 'PATTERN' property\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].MISSING_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"difference\"])(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors: errors, valid: valid };\n}\nfunction findInvalidPatterns(tokenTypes) {\n    var tokenTypesWithInvalidPattern = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(pattern) &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(pattern) &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(pattern, \"exec\") &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(pattern));\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' can only be a RegExp, a\" +\n                \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].INVALID_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    var valid = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"difference\"])(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors: errors, valid: valid };\n}\nvar end_of_input = /[^\\\\][\\$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n    var EndAnchorFinder = /** @class */ (function (_super) {\n        __extends(EndAnchorFinder, _super);\n        function EndAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        EndAnchorFinder.prototype.visitEndAnchor = function (node) {\n            this.found = true;\n        };\n        return EndAnchorFinder;\n    }(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__[\"BaseRegExpVisitor\"]));\n    var invalidRegex = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = Object(_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__[\"getRegExpAst\"])(pattern);\n            var endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n                \"\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].EOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nfunction findEmptyMatchRegExps(tokenTypes) {\n    var matchesEmptyString = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern.test(\"\");\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(matchesEmptyString, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' must not match an empty string\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nvar start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n    var StartAnchorFinder = /** @class */ (function (_super) {\n        __extends(StartAnchorFinder, _super);\n        function StartAnchorFinder() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.found = false;\n            return _this;\n        }\n        StartAnchorFinder.prototype.visitStartAnchor = function (node) {\n            this.found = true;\n        };\n        return StartAnchorFinder;\n    }(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__[\"BaseRegExpVisitor\"]));\n    var invalidRegex = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        try {\n            var regexpAst = Object(_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__[\"getRegExpAst\"])(pattern);\n            var startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(invalidRegex, function (currType) {\n        return {\n            message: \"Unexpected RegExp Anchor Error:\\n\" +\n                \"\\tToken Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n                \"\\tfor details.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].SOI_ANCHOR_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nfunction findUnsupportedFlags(tokenTypes) {\n    var invalidFlags = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return (pattern instanceof RegExp && (pattern.multiline || pattern.global));\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(invalidFlags, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nfunction findDuplicatePatterns(tokenTypes) {\n    var found = [];\n    var identicalPatterns = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(tokenTypes, function (outerType) {\n        return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"reduce\"])(tokenTypes, function (result, innerType) {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"contains\"])(found, innerType) &&\n                innerType.PATTERN !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"compact\"])(identicalPatterns);\n    var duplicatePatterns = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(setOfIdentical, function (currType) {\n            return currType.name;\n        });\n        var dupPatternSrc = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"first\"])(setOfIdentical).PATTERN;\n        return {\n            message: \"The same RegExp pattern ->\" + dupPatternSrc + \"<-\" +\n                (\"has been used in all of the following Token Types: \" + tokenTypeNames.join(\", \") + \" <-\"),\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical\n        };\n    });\n    return errors;\n}\nfunction findInvalidGroupType(tokenTypes) {\n    var invalidTypes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (clazz) {\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(clazz, \"GROUP\")) {\n            return false;\n        }\n        var group = clazz.GROUP;\n        return group !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].SKIPPED && group !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].NA && !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(group);\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(invalidTypes, function (currType) {\n        return {\n            message: \"Token Type: ->\" +\n                currType.name +\n                \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType]\n        };\n    });\n    return errors;\n}\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n    var invalidModes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"filter\"])(tokenTypes, function (clazz) {\n        return (clazz.PUSH_MODE !== undefined &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"contains\"])(validModes, clazz.PUSH_MODE));\n    });\n    var errors = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\" + tokType.name + \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\" + tokType.PUSH_MODE + \"<-\" +\n            \"which does not exist\";\n        return {\n            message: msg,\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType]\n        };\n    });\n    return errors;\n}\nfunction findUnreachablePatterns(tokenTypes) {\n    var errors = [];\n    var canBeTested = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"reduce\"])(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(pattern)) {\n            result.push({ str: pattern, idx: idx, tokenType: tokType });\n        }\n        else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx: idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(tokenTypes, function (tokType, testIdx) {\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(canBeTested, function (_a) {\n            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                var msg = \"Token: ->\" + tokenType.name + \"<- can never be matched.\\n\" +\n                    (\"Because it appears AFTER the Token Type ->\" + tokType.name + \"<-\") +\n                    \"in the lexer's definition.\\n\" +\n                    \"See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";\n                errors.push({\n                    message: msg,\n                    type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType]\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(pattern, \"exec\")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === \"string\") {\n        return pattern === str;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    var metaChars = [\n        \".\",\n        \"\\\\\",\n        \"[\",\n        \"]\",\n        \"|\",\n        \"^\",\n        \"$\",\n        \"(\",\n        \")\",\n        \"?\",\n        \"*\",\n        \"+\",\n        \"{\"\n    ];\n    return (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"find\"])(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) ===\n        undefined);\n}\nfunction addStartOfInput(pattern) {\n    var flags = pattern.ignoreCase ? \"i\" : \"\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"^(?:\" + pattern.source + \")\", flags);\n}\nfunction addStickyFlag(pattern) {\n    var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(\"\" + pattern.source, flags);\n}\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var errors = [];\n    // some run time checks to help the end users.\n    if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                DEFAULT_MODE +\n                \"> property in its definition\\n\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n    }\n    if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(lexerDefinition, MODES)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized without a <\" +\n                MODES +\n                \"> property in its definition\\n\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(lexerDefinition, MODES) &&\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(lexerDefinition, DEFAULT_MODE) &&\n        !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: \"A MultiMode Lexer cannot be initialized with a \" + DEFAULT_MODE + \": <\" + lexerDefinition.defaultMode + \">\" +\n                \"which does not exist\\n\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(lexerDefinition, MODES)) {\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(lexerDefinition.modes, function (currModeValue, currModeName) {\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(currModeValue, function (currTokType, currIdx) {\n                if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isUndefined\"])(currTokType)) {\n                    errors.push({\n                        message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:\" +\n                            (\"<\" + currModeName + \"> at index: <\" + currIdx + \">\\n\"),\n                        type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    var warnings = [];\n    var hasAnyLineBreak = false;\n    var allTokenTypes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"compact\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"flatten\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"mapValues\"])(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));\n    var concreteTokenTypes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"reject\"])(allTokenTypes, function (currType) { return currType[PATTERN] === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].NA; });\n    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(concreteTokenTypes, function (tokType) {\n            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                var message = buildLineBreakIssueMessage(tokType, currIssue);\n                var warningDescriptor = {\n                    message: message,\n                    type: currIssue.issue,\n                    tokenType: tokType\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n                if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(tokType, \"LINE_BREAKS\")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (Object(_reg_exp__WEBPACK_IMPORTED_MODULE_3__[\"canMatchCharCode\"])(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: \"Warning: No LINE_BREAKS Found.\\n\" +\n                \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n                \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n                \"\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n                \"\\tfor details.\",\n            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].NO_LINE_BREAKS_FLAGS\n        });\n    }\n    return warnings;\n}\nfunction cloneEmptyGroups(emptyGroups) {\n    var clonedResult = {};\n    var groupKeys = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"keys\"])(emptyGroups);\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"forEach\"])(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isArray\"])(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nfunction isCustomPattern(tokenType) {\n    var pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(pattern)) {\n        return false;\n    }\n    else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isFunction\"])(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(pattern, \"exec\")) {\n        // ICustomPattern\n        return true;\n    }\n    else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(pattern)) {\n        return false;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction isShortPattern(pattern) {\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nvar LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        var len = text.length;\n        for (var i = this.lastIndex; i < len; i++) {\n            var c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"has\"])(tokType, \"LINE_BREAKS\")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isRegExp\"])(tokType.PATTERN)) {\n            try {\n                Object(_reg_exp__WEBPACK_IMPORTED_MODULE_3__[\"canMatchCharCode\"])(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].IDENTIFY_TERMINATOR,\n                    errMsg: e.message\n                };\n            }\n            return false;\n        }\n        else if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].IDENTIFY_TERMINATOR) {\n        return (\"Warning: unable to identify line terminator usage in pattern.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            (\"\\t Root cause: \" + details.errMsg + \".\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n    }\n    else if (details.issue === _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"LexerDefinitionErrorType\"].CUSTOM_LINE_BREAK) {\n        return (\"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n            (\"\\tThe problem is in the <\" + tokType.name + \"> Token Type\\n\") +\n            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    var charCodes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"map\"])(charsOrCodes, function (numOrString) {\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isString\"])(numOrString) && numOrString.length > 0) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nvar minOptimizationVal = 256;\n/**\n * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nfunction charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nvar charCodeToOptimizedIdxMap = [];\nfunction initCharCodeToOptimizedIndexMap() {\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_2__[\"isEmpty\"])(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var i = 0; i < 65536; i++) {\n            /* tslint:disable */\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n            /* tslint:enable */\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL2xleGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvc2Nhbi9sZXhlci5qcz8yMmQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgQmFzZVJlZ0V4cFZpc2l0b3IgfSBmcm9tIFwicmVnZXhwLXRvLWFzdFwiO1xuaW1wb3J0IHsgTGV4ZXIsIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSB9IGZyb20gXCIuL2xleGVyX3B1YmxpY1wiO1xuaW1wb3J0IHsgY29tcGFjdCwgY29udGFpbnMsIGRlZmF1bHRzLCBkaWZmZXJlbmNlLCBmaWx0ZXIsIGZpbmQsIGZpcnN0LCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGluZGV4T2YsIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzUmVnRXhwLCBpc1N0cmluZywgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgbWFwVmFsdWVzLCBwYWNrQXJyYXksIFBSSU5UX0VSUk9SLCByZWR1Y2UsIHJlamVjdCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgY2FuTWF0Y2hDaGFyQ29kZSwgZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnLCBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyB9IGZyb20gXCIuL3JlZ19leHBcIjtcbmltcG9ydCB7IGdldFJlZ0V4cEFzdCB9IGZyb20gXCIuL3JlZ19leHBfcGFyc2VyXCI7XG52YXIgUEFUVEVSTiA9IFwiUEFUVEVSTlwiO1xuZXhwb3J0IHZhciBERUZBVUxUX01PREUgPSBcImRlZmF1bHRNb2RlXCI7XG5leHBvcnQgdmFyIE1PREVTID0gXCJtb2Rlc1wiO1xuZXhwb3J0IHZhciBTVVBQT1JUX1NUSUNLWSA9IHR5cGVvZiBuZXcgUmVnRXhwKFwiKD86KVwiKS5zdGlja3kgPT09IFwiYm9vbGVhblwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTdGlja3koKSB7XG4gICAgU1VQUE9SVF9TVElDS1kgPSBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVTdGlja3koKSB7XG4gICAgU1VQUE9SVF9TVElDS1kgPSB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVUb2tlblR5cGVzKHRva2VuVHlwZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICB1c2VTdGlja3k6IFNVUFBPUlRfU1RJQ0tZLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIHNhZmVNb2RlOiBmYWxzZSxcbiAgICAgICAgcG9zaXRpb25UcmFja2luZzogXCJmdWxsXCIsXG4gICAgICAgIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczogW1wiXFxyXCIsIFwiXFxuXCJdLFxuICAgICAgICB0cmFjZXI6IGZ1bmN0aW9uIChtc2csIGFjdGlvbikgeyByZXR1cm4gYWN0aW9uKCk7IH1cbiAgICB9KTtcbiAgICB2YXIgdHJhY2VyID0gb3B0aW9ucy50cmFjZXI7XG4gICAgdHJhY2VyKFwiaW5pdENoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleE1hcFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXRDaGFyQ29kZVRvT3B0aW1pemVkSW5kZXhNYXAoKTtcbiAgICB9KTtcbiAgICB2YXIgb25seVJlbGV2YW50VHlwZXM7XG4gICAgdHJhY2VyKFwiUmVqZWN0IExleGVyLk5BXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25seVJlbGV2YW50VHlwZXMgPSByZWplY3QodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyclR5cGVbUEFUVEVSTl0gPT09IExleGVyLk5BO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgaGFzQ3VzdG9tID0gZmFsc2U7XG4gICAgdmFyIGFsbFRyYW5zZm9ybWVkUGF0dGVybnM7XG4gICAgdHJhY2VyKFwiVHJhbnNmb3JtIFBhdHRlcm5zXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFzQ3VzdG9tID0gZmFsc2U7XG4gICAgICAgIGFsbFRyYW5zZm9ybWVkUGF0dGVybnMgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJQYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKGN1cnJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdFeHBTb3VyY2UgPSBjdXJyUGF0dGVybi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ0V4cFNvdXJjZS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGVzZSByZWdFeHAgbWV0YSBjaGFyYWN0ZXJzIHdoaWNoIGNhbiBhcHBlYXIgaW4gYSBsZW5ndGggb25lIHJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2UgIT09IFwiXlwiICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZSAhPT0gXCIkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlICE9PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnRXhwU291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWdFeHBTb3VyY2UubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZVswXSA9PT0gXCJcXFxcXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGEgbWV0YSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgIWNvbnRhaW5zKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiV1wiXG4gICAgICAgICAgICAgICAgICAgIF0sIHJlZ0V4cFNvdXJjZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlZCBtZXRhIENoYXJhY3RlcnM6IC9cXCsvIC9cXFsvXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlZHVuZGFudCBlc2NhcGluZzogL1xcYS9cbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCB0aGUgZXNjYXBpbmcgXCJcXFwiXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBTb3VyY2VbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy51c2VTdGlja3lcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkU3RpY2t5RmxhZyhjdXJyUGF0dGVybilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkU3RhcnRPZklucHV0KGN1cnJQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGN1cnJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGhhc0N1c3RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQ3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jIC0gY3VzdG9tIHBhdHRlcm5zIGRvIG5vdCByZXF1aXJlIGFueSB0cmFuc2Zvcm1hdGlvbnMsIG9ubHkgd3JhcHBpbmcgaW4gYSBSZWdFeHAgTGlrZSBvYmplY3RcbiAgICAgICAgICAgICAgICByZXR1cm4geyBleGVjOiBjdXJyUGF0dGVybiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzKGN1cnJQYXR0ZXJuLCBcImV4ZWNcIikpIHtcbiAgICAgICAgICAgICAgICBoYXNDdXN0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIElDdXN0b21QYXR0ZXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJQYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGN1cnJQYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJQYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VyclBhdHRlcm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlZFJlZ0V4cFN0cmluZyA9IGN1cnJQYXR0ZXJuLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZWRSZWdFeHAgPSBuZXcgUmVnRXhwKGVzY2FwZWRSZWdFeHBTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy51c2VTdGlja3lcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkU3RpY2t5RmxhZyh3cmFwcGVkUmVnRXhwKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRTdGFydE9mSW5wdXQod3JhcHBlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIHBhdHRlcm5JZHhUb1R5cGU7XG4gICAgdmFyIHBhdHRlcm5JZHhUb0dyb3VwO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHg7XG4gICAgdmFyIHBhdHRlcm5JZHhUb1B1c2hNb2RlO1xuICAgIHZhciBwYXR0ZXJuSWR4VG9Qb3BNb2RlO1xuICAgIHRyYWNlcihcIm1pc2MgbWFwcGluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdHRlcm5JZHhUb1R5cGUgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkgeyByZXR1cm4gY3VyclR5cGUudG9rZW5UeXBlSWR4OyB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvR3JvdXAgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGNsYXp6LkdST1VQO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChncm91cE5hbWUgPT09IExleGVyLlNLSVBQRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmaW5lZChncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhdHRlcm5JZHhUb0xvbmdlckFsdElkeCA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgICAgICB2YXIgbG9uZ2VyQWx0VHlwZSA9IGNsYXp6LkxPTkdFUl9BTFQ7XG4gICAgICAgICAgICBpZiAobG9uZ2VyQWx0VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb25nZXJBbHRJZHggPSBpbmRleE9mKG9ubHlSZWxldmFudFR5cGVzLCBsb25nZXJBbHRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9uZ2VyQWx0SWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvUHVzaE1vZGUgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uIChjbGF6eikgeyByZXR1cm4gY2xhenouUFVTSF9NT0RFOyB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvUG9wTW9kZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzKGNsYXp6LCBcIlBPUF9NT0RFXCIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3I7XG4gICAgdHJhY2VyKFwiTGluZSBUZXJtaW5hdG9yIEhhbmRsaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzID0gZ2V0Q2hhckNvZGVzKG9wdGlvbnMubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKTtcbiAgICAgICAgcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3IgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIGZ1bmN0aW9uICh0b2tUeXBlKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uVHJhY2tpbmcgIT09IFwib25seU9mZnNldFwiKSB7XG4gICAgICAgICAgICBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvciA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKHRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzKHRva1R5cGUsIFwiTElORV9CUkVBS1NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva1R5cGUuTElORV9CUkVBS1M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tMaW5lQnJlYWtzSXNzdWVzKHRva1R5cGUsIGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5NYXRjaENoYXJDb2RlKGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzLCB0b2tUeXBlLlBBVFRFUk4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcGF0dGVybklkeFRvSXNDdXN0b207XG4gICAgdmFyIHBhdHRlcm5JZHhUb1Nob3J0O1xuICAgIHZhciBlbXB0eUdyb3VwcztcbiAgICB2YXIgcGF0dGVybklkeFRvQ29uZmlnO1xuICAgIHRyYWNlcihcIk1pc2MgTWFwcGluZyAjMlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhdHRlcm5JZHhUb0lzQ3VzdG9tID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBpc0N1c3RvbVBhdHRlcm4pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9TaG9ydCA9IG1hcChhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zLCBpc1Nob3J0UGF0dGVybik7XG4gICAgICAgIGVtcHR5R3JvdXBzID0gcmVkdWNlKG9ubHlSZWxldmFudFR5cGVzLCBmdW5jdGlvbiAoYWNjLCBjbGF6eikge1xuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGNsYXp6LkdST1VQO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGdyb3VwTmFtZSkgJiYgIShncm91cE5hbWUgPT09IExleGVyLlNLSVBQRUQpKSB7XG4gICAgICAgICAgICAgICAgYWNjW2dyb3VwTmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gbWFwKGFsbFRyYW5zZm9ybWVkUGF0dGVybnMsIGZ1bmN0aW9uICh4LCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogYWxsVHJhbnNmb3JtZWRQYXR0ZXJuc1tpZHhdLFxuICAgICAgICAgICAgICAgIGxvbmdlckFsdDogcGF0dGVybklkeFRvTG9uZ2VyQWx0SWR4W2lkeF0sXG4gICAgICAgICAgICAgICAgY2FuTGluZVRlcm1pbmF0b3I6IHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yW2lkeF0sXG4gICAgICAgICAgICAgICAgaXNDdXN0b206IHBhdHRlcm5JZHhUb0lzQ3VzdG9tW2lkeF0sXG4gICAgICAgICAgICAgICAgc2hvcnQ6IHBhdHRlcm5JZHhUb1Nob3J0W2lkeF0sXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHBhdHRlcm5JZHhUb0dyb3VwW2lkeF0sXG4gICAgICAgICAgICAgICAgcHVzaDogcGF0dGVybklkeFRvUHVzaE1vZGVbaWR4XSxcbiAgICAgICAgICAgICAgICBwb3A6IHBhdHRlcm5JZHhUb1BvcE1vZGVbaWR4XSxcbiAgICAgICAgICAgICAgICB0b2tlblR5cGVJZHg6IHBhdHRlcm5JZHhUb1R5cGVbaWR4XSxcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IG9ubHlSZWxldmFudFR5cGVzW2lkeF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBjYW5CZU9wdGltaXplZCA9IHRydWU7XG4gICAgdmFyIGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICBpZiAoIW9wdGlvbnMuc2FmZU1vZGUpIHtcbiAgICAgICAgdHJhY2VyKFwiRmlyc3QgQ2hhciBPcHRpbWl6YXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IHJlZHVjZShvbmx5UmVsZXZhbnRUeXBlcywgZnVuY3Rpb24gKHJlc3VsdCwgY3VyclRva1R5cGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyclRva1R5cGUuUEFUVEVSTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBjdXJyVG9rVHlwZS5QQVRURVJOLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb01hcE9mQXJyYXlzKHJlc3VsdCwgb3B0aW1pemVkSWR4LCBwYXR0ZXJuSWR4VG9Db25maWdbaWR4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoY3VyclRva1R5cGUuU1RBUlRfQ0hBUlNfSElOVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RPcHRpbWl6ZWRJZHhfMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5TVEFSVF9DSEFSU19ISU5ULCBmdW5jdGlvbiAoY2hhck9ySW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB0eXBlb2YgY2hhck9ySW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGFyT3JJbnQuY2hhckNvZGVBdCgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2hhck9ySW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJPcHRpbWl6ZWRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYWRkaW5nIHRoZSBjb25maWcgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0T3B0aW1pemVkSWR4XzEgIT09IGN1cnJPcHRpbWl6ZWRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0T3B0aW1pemVkSWR4XzEgPSBjdXJyT3B0aW1pemVkSWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvTWFwT2ZBcnJheXMocmVzdWx0LCBjdXJyT3B0aW1pemVkSWR4LCBwYXR0ZXJuSWR4VG9Db25maWdbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChjdXJyVG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclRva1R5cGUuUEFUVEVSTi51bmljb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5CZU9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBSSU5UX0VSUk9SKFwiXCIgKyBmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2cgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXHRVbmFibGUgdG8gYW5hbHl6ZSA8IFwiICsgY3VyclRva1R5cGUuUEFUVEVSTi50b1N0cmluZygpICsgXCIgPiBwYXR0ZXJuLlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhlIHJlZ2V4cCB1bmljb2RlIGZsYWcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeS5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1VOSUNPREVfT1BUSU1JWkVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW1pemVkQ29kZXMgPSBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyhjdXJyVG9rVHlwZS5QQVRURVJOLCBvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBjb2RlIHdpbGwgb25seSBiZSBlbXB0eSBnaXZlbiBhbiBlbXB0eSByZWdFeHAgb3IgZmFpbHVyZSBvZiByZWdleHAtdG8tYXN0IGxpYnJhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBzaG91bGQgYmUgYSBkaWZmZXJlbnQgdmFsaWRhdGlvbiBhbmQgdGhlIHNlY29uZCBjYW5ub3QgYmUgdGVzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkob3B0aW1pemVkQ29kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHVuZGVyc3RhbmQgd2hhdCBjb2RlcyBtYXkgc3RhcnQgcG9zc2libGUgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcHRpbWl6YXRpb24gY29ycmVjdG5lc3MgcmVxdWlyZXMga25vd2luZyBzdGFydCBjb2RlcyBmb3IgQUxMIHBhdHRlcm5zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhY3R1YWxseSBzdXJlIHRoaXMgaXMgYW4gZXJyb3IsIG5vIGRlYnVnIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZU9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChvcHRpbWl6ZWRDb2RlcywgZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb01hcE9mQXJyYXlzKHJlc3VsdCwgY29kZSwgcGF0dGVybklkeFRvQ29uZmlnW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBSSU5UX0VSUk9SKFwiXCIgKyBmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2cgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlxcdFRva2VuVHlwZTogPFwiICsgY3VyclRva1R5cGUubmFtZSArIFwiPiBpcyB1c2luZyBhIGN1c3RvbSB0b2tlbiBwYXR0ZXJuIHdpdGhvdXQgcHJvdmlkaW5nIDxzdGFydF9jaGFyc19oaW50PiBwYXJhbWV0ZXIuXFxuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NVU1RPTV9PUFRJTUlaRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW5CZU9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2VyKFwiQXJyYXlQYWNraW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IHBhY2tBcnJheShjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbXB0eUdyb3VwczogZW1wdHlHcm91cHMsXG4gICAgICAgIHBhdHRlcm5JZHhUb0NvbmZpZzogcGF0dGVybklkeFRvQ29uZmlnLFxuICAgICAgICBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnOiBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnLFxuICAgICAgICBoYXNDdXN0b206IGhhc0N1c3RvbSxcbiAgICAgICAgY2FuQmVPcHRpbWl6ZWQ6IGNhbkJlT3B0aW1pemVkXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5zKHRva2VuVHlwZXMsIHZhbGlkTW9kZXNOYW1lcykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgbWlzc2luZ1Jlc3VsdCA9IGZpbmRNaXNzaW5nUGF0dGVybnModG9rZW5UeXBlcyk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChtaXNzaW5nUmVzdWx0LmVycm9ycyk7XG4gICAgdmFyIGludmFsaWRSZXN1bHQgPSBmaW5kSW52YWxpZFBhdHRlcm5zKG1pc3NpbmdSZXN1bHQudmFsaWQpO1xuICAgIHZhciB2YWxpZFRva2VuVHlwZXMgPSBpbnZhbGlkUmVzdWx0LnZhbGlkO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoaW52YWxpZFJlc3VsdC5lcnJvcnMpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHZhbGlkVG9rZW5UeXBlcykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZEludmFsaWRHcm91cFR5cGUodmFsaWRUb2tlblR5cGVzKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kTW9kZXNUaGF0RG9Ob3RFeGlzdCh2YWxpZFRva2VuVHlwZXMsIHZhbGlkTW9kZXNOYW1lcykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZFVucmVhY2hhYmxlUGF0dGVybnModmFsaWRUb2tlblR5cGVzKSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVnRXhwUGF0dGVybih0b2tlblR5cGVzKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB3aXRoUmVnRXhwUGF0dGVybnMgPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7XG4gICAgICAgIHJldHVybiBpc1JlZ0V4cChjdXJyVG9rVHlwZVtQQVRURVJOXSk7XG4gICAgfSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kRW5kT2ZJbnB1dEFuY2hvcih3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRTdGFydE9mSW5wdXRBbmNob3Iod2l0aFJlZ0V4cFBhdHRlcm5zKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kVW5zdXBwb3J0ZWRGbGFncyh3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmREdXBsaWNhdGVQYXR0ZXJucyh3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRFbXB0eU1hdGNoUmVnRXhwcyh3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNaXNzaW5nUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIHZhciB0b2tlblR5cGVzV2l0aE1pc3NpbmdQYXR0ZXJuID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4gIWhhcyhjdXJyVHlwZSwgUEFUVEVSTik7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcCh0b2tlblR5cGVzV2l0aE1pc3NpbmdQYXR0ZXJuLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBtaXNzaW5nIHN0YXRpYyAnUEFUVEVSTicgcHJvcGVydHlcIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NSVNTSU5HX1BBVFRFUk4sXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHZhbGlkID0gZGlmZmVyZW5jZSh0b2tlblR5cGVzLCB0b2tlblR5cGVzV2l0aE1pc3NpbmdQYXR0ZXJuKTtcbiAgICByZXR1cm4geyBlcnJvcnM6IGVycm9ycywgdmFsaWQ6IHZhbGlkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEludmFsaWRQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgdmFyIHRva2VuVHlwZXNXaXRoSW52YWxpZFBhdHRlcm4gPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgIHJldHVybiAoIWlzUmVnRXhwKHBhdHRlcm4pICYmXG4gICAgICAgICAgICAhaXNGdW5jdGlvbihwYXR0ZXJuKSAmJlxuICAgICAgICAgICAgIWhhcyhwYXR0ZXJuLCBcImV4ZWNcIikgJiZcbiAgICAgICAgICAgICFpc1N0cmluZyhwYXR0ZXJuKSk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcCh0b2tlblR5cGVzV2l0aEludmFsaWRQYXR0ZXJuLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbiBvbmx5IGJlIGEgUmVnRXhwLCBhXCIgK1xuICAgICAgICAgICAgICAgIFwiIEZ1bmN0aW9uIG1hdGNoaW5nIHRoZSB7Q3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jfSB0eXBlIG9yIGFuIE9iamVjdCBtYXRjaGluZyB0aGUge0lDdXN0b21QYXR0ZXJufSBpbnRlcmZhY2UuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciB2YWxpZCA9IGRpZmZlcmVuY2UodG9rZW5UeXBlcywgdG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybik7XG4gICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcnMsIHZhbGlkOiB2YWxpZCB9O1xufVxudmFyIGVuZF9vZl9pbnB1dCA9IC9bXlxcXFxdW1xcJF0vO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbmRPZklucHV0QW5jaG9yKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgRW5kQW5jaG9yRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRW5kQW5jaG9yRmluZGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbmRBbmNob3JGaW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRW5kQW5jaG9yRmluZGVyLnByb3RvdHlwZS52aXNpdEVuZEFuY2hvciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVuZEFuY2hvckZpbmRlcjtcbiAgICB9KEJhc2VSZWdFeHBWaXNpdG9yKSk7XG4gICAgdmFyIGludmFsaWRSZWdleCA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZWdleHBBc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgICAgICB2YXIgZW5kQW5jaG9yVmlzaXRvciA9IG5ldyBFbmRBbmNob3JGaW5kZXIoKTtcbiAgICAgICAgICAgIGVuZEFuY2hvclZpc2l0b3IudmlzaXQocmVnZXhwQXN0KTtcbiAgICAgICAgICAgIHJldHVybiBlbmRBbmNob3JWaXNpdG9yLmZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBvbGQgYmVoYXZpb3IgaW4gY2FzZSBvZiBydW50aW1lIGV4Y2VwdGlvbnMgd2l0aCByZWdleHAtdG8tYXN0LlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBjYW5ub3QgZW5zdXJlIGFuIGVycm9yIGluIHJlZ2V4cC10by1hc3QqL1xuICAgICAgICAgICAgcmV0dXJuIGVuZF9vZl9pbnB1dC50ZXN0KHBhdHRlcm4uc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoaW52YWxpZFJlZ2V4LCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBlbmQgb2YgaW5wdXQgYW5jaG9yICckJ1xcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZSBzYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1wiICtcbiAgICAgICAgICAgICAgICBcIlxcdGZvciBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVPSV9BTkNIT1JfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRW1wdHlNYXRjaFJlZ0V4cHModG9rZW5UeXBlcykge1xuICAgIHZhciBtYXRjaGVzRW1wdHlTdHJpbmcgPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoXCJcIik7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChtYXRjaGVzRW1wdHlTdHJpbmcsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgbXVzdCBub3QgbWF0Y2ggYW4gZW1wdHkgc3RyaW5nXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuRU1QVFlfTUFUQ0hfUEFUVEVSTixcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxudmFyIHN0YXJ0X29mX2lucHV0ID0gL1teXFxcXFtdW1xcXl18XlxcXi87XG5leHBvcnQgZnVuY3Rpb24gZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcih0b2tlblR5cGVzKSB7XG4gICAgdmFyIFN0YXJ0QW5jaG9yRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoU3RhcnRBbmNob3JGaW5kZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFN0YXJ0QW5jaG9yRmluZGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIFN0YXJ0QW5jaG9yRmluZGVyLnByb3RvdHlwZS52aXNpdFN0YXJ0QW5jaG9yID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RhcnRBbmNob3JGaW5kZXI7XG4gICAgfShCYXNlUmVnRXhwVmlzaXRvcikpO1xuICAgIHZhciBpbnZhbGlkUmVnZXggPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhwQXN0ID0gZ2V0UmVnRXhwQXN0KHBhdHRlcm4pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5jaG9yVmlzaXRvciA9IG5ldyBTdGFydEFuY2hvckZpbmRlcigpO1xuICAgICAgICAgICAgc3RhcnRBbmNob3JWaXNpdG9yLnZpc2l0KHJlZ2V4cEFzdCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRBbmNob3JWaXNpdG9yLmZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBvbGQgYmVoYXZpb3IgaW4gY2FzZSBvZiBydW50aW1lIGV4Y2VwdGlvbnMgd2l0aCByZWdleHAtdG8tYXN0LlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBjYW5ub3QgZW5zdXJlIGFuIGVycm9yIGluIHJlZ2V4cC10by1hc3QqL1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0X29mX2lucHV0LnRlc3QocGF0dGVybi5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChpbnZhbGlkUmVnZXgsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0VG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbm5vdCBjb250YWluIHN0YXJ0IG9mIGlucHV0IGFuY2hvciAnXidcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1wiICtcbiAgICAgICAgICAgICAgICBcIlxcdGZvciBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlNPSV9BTkNIT1JfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVW5zdXBwb3J0ZWRGbGFncyh0b2tlblR5cGVzKSB7XG4gICAgdmFyIGludmFsaWRGbGFncyA9IGZpbHRlcih0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgcmV0dXJuIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwICYmIChwYXR0ZXJuLm11bHRpbGluZSB8fCBwYXR0ZXJuLmdsb2JhbCkpO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoaW52YWxpZEZsYWdzLCBmdW5jdGlvbiAoY3VyclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG1heSBOT1QgY29udGFpbiBnbG9iYWwoJ2cnKSBvciBtdWx0aWxpbmUoJ20nKVwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG4vLyBUaGlzIGNhbiBvbmx5IHRlc3QgZm9yIGlkZW50aWNhbCBkdXBsaWNhdGUgUmVnRXhwcywgbm90IHNlbWFudGljYWxseSBlcXVpdmFsZW50IG9uZXMuXG5leHBvcnQgZnVuY3Rpb24gZmluZER1cGxpY2F0ZVBhdHRlcm5zKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgZm91bmQgPSBbXTtcbiAgICB2YXIgaWRlbnRpY2FsUGF0dGVybnMgPSBtYXAodG9rZW5UeXBlcywgZnVuY3Rpb24gKG91dGVyVHlwZSkge1xuICAgICAgICByZXR1cm4gcmVkdWNlKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChyZXN1bHQsIGlubmVyVHlwZSkge1xuICAgICAgICAgICAgaWYgKG91dGVyVHlwZS5QQVRURVJOLnNvdXJjZSA9PT0gaW5uZXJUeXBlLlBBVFRFUk4uc291cmNlICYmXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKGZvdW5kLCBpbm5lclR5cGUpICYmXG4gICAgICAgICAgICAgICAgaW5uZXJUeXBlLlBBVFRFUk4gIT09IExleGVyLk5BKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhdm9pZHMgZHVwbGljYXRlcyBpbiB0aGUgcmVzdWx0LCBlYWNoIFRva2VuIFR5cGUgbWF5IG9ubHkgYXBwZWFyIGluIG9uZSBcInNldFwiXG4gICAgICAgICAgICAgICAgLy8gaW4gZXNzZW5jZSB3ZSBhcmUgY3JlYXRpbmcgRXF1aXZhbGVuY2UgY2xhc3NlcyBvbiBlcXVhbGl0eSByZWxhdGlvbi5cbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKGlubmVyVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5uZXJUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgW10pO1xuICAgIH0pO1xuICAgIGlkZW50aWNhbFBhdHRlcm5zID0gY29tcGFjdChpZGVudGljYWxQYXR0ZXJucyk7XG4gICAgdmFyIGR1cGxpY2F0ZVBhdHRlcm5zID0gZmlsdGVyKGlkZW50aWNhbFBhdHRlcm5zLCBmdW5jdGlvbiAoY3VycklkZW50aWNhbFNldCkge1xuICAgICAgICByZXR1cm4gY3VycklkZW50aWNhbFNldC5sZW5ndGggPiAxO1xuICAgIH0pO1xuICAgIHZhciBlcnJvcnMgPSBtYXAoZHVwbGljYXRlUGF0dGVybnMsIGZ1bmN0aW9uIChzZXRPZklkZW50aWNhbCkge1xuICAgICAgICB2YXIgdG9rZW5UeXBlTmFtZXMgPSBtYXAoc2V0T2ZJZGVudGljYWwsIGZ1bmN0aW9uIChjdXJyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJUeXBlLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZHVwUGF0dGVyblNyYyA9IGZpcnN0KHNldE9mSWRlbnRpY2FsKS5QQVRURVJOO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUaGUgc2FtZSBSZWdFeHAgcGF0dGVybiAtPlwiICsgZHVwUGF0dGVyblNyYyArIFwiPC1cIiArXG4gICAgICAgICAgICAgICAgKFwiaGFzIGJlZW4gdXNlZCBpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBUb2tlbiBUeXBlczogXCIgKyB0b2tlblR5cGVOYW1lcy5qb2luKFwiLCBcIikgKyBcIiA8LVwiKSxcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBzZXRPZklkZW50aWNhbFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEludmFsaWRHcm91cFR5cGUodG9rZW5UeXBlcykge1xuICAgIHZhciBpbnZhbGlkVHlwZXMgPSBmaWx0ZXIodG9rZW5UeXBlcywgZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgIGlmICghaGFzKGNsYXp6LCBcIkdST1VQXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gY2xhenouR1JPVVA7XG4gICAgICAgIHJldHVybiBncm91cCAhPT0gTGV4ZXIuU0tJUFBFRCAmJiBncm91cCAhPT0gTGV4ZXIuTkEgJiYgIWlzU3RyaW5nKGdyb3VwKTtcbiAgICB9KTtcbiAgICB2YXIgZXJyb3JzID0gbWFwKGludmFsaWRUeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdHUk9VUCcgY2FuIG9ubHkgYmUgTGV4ZXIuU0tJUFBFRC9MZXhlci5OQS9BIFN0cmluZ1wiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfR1JPVVBfVFlQRV9GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNb2Rlc1RoYXREb05vdEV4aXN0KHRva2VuVHlwZXMsIHZhbGlkTW9kZXMpIHtcbiAgICB2YXIgaW52YWxpZE1vZGVzID0gZmlsdGVyKHRva2VuVHlwZXMsIGZ1bmN0aW9uIChjbGF6eikge1xuICAgICAgICByZXR1cm4gKGNsYXp6LlBVU0hfTU9ERSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhY29udGFpbnModmFsaWRNb2RlcywgY2xhenouUFVTSF9NT0RFKSk7XG4gICAgfSk7XG4gICAgdmFyIGVycm9ycyA9IG1hcChpbnZhbGlkTW9kZXMsIGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIlRva2VuIFR5cGU6IC0+XCIgKyB0b2tUeXBlLm5hbWUgKyBcIjwtIHN0YXRpYyAnUFVTSF9NT0RFJyB2YWx1ZSBjYW5ub3QgcmVmZXIgdG8gYSBMZXhlciBNb2RlIC0+XCIgKyB0b2tUeXBlLlBVU0hfTU9ERSArIFwiPC1cIiArXG4gICAgICAgICAgICBcIndoaWNoIGRvZXMgbm90IGV4aXN0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNULFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW3Rva1R5cGVdXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVW5yZWFjaGFibGVQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciBjYW5CZVRlc3RlZCA9IHJlZHVjZSh0b2tlblR5cGVzLCBmdW5jdGlvbiAocmVzdWx0LCB0b2tUeXBlLCBpZHgpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tUeXBlLlBBVFRFUk47XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSBMZXhlci5OQSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhIG1vcmUgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIGZvciBhbGwgZm9ybXMgb2YgcmVnRXhwcyB3b3VsZCByZXF1aXJlXG4gICAgICAgIC8vIGRlZXBlciByZWdFeHAgYW5hbHlzaXMgY2FwYWJpbGl0aWVzXG4gICAgICAgIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdHI6IHBhdHRlcm4sIGlkeDogaWR4LCB0b2tlblR5cGU6IHRva1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikgJiYgbm9NZXRhQ2hhcihwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdHI6IHBhdHRlcm4uc291cmNlLCBpZHg6IGlkeCwgdG9rZW5UeXBlOiB0b2tUeXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICAgIGZvckVhY2godG9rZW5UeXBlcywgZnVuY3Rpb24gKHRva1R5cGUsIHRlc3RJZHgpIHtcbiAgICAgICAgZm9yRWFjaChjYW5CZVRlc3RlZCwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gX2Euc3RyLCBpZHggPSBfYS5pZHgsIHRva2VuVHlwZSA9IF9hLnRva2VuVHlwZTtcbiAgICAgICAgICAgIGlmICh0ZXN0SWR4IDwgaWR4ICYmIHRlc3RUb2tlblR5cGUoc3RyLCB0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IFwiVG9rZW46IC0+XCIgKyB0b2tlblR5cGUubmFtZSArIFwiPC0gY2FuIG5ldmVyIGJlIG1hdGNoZWQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJCZWNhdXNlIGl0IGFwcGVhcnMgQUZURVIgdGhlIFRva2VuIFR5cGUgLT5cIiArIHRva1R5cGUubmFtZSArIFwiPC1cIikgK1xuICAgICAgICAgICAgICAgICAgICBcImluIHRoZSBsZXhlcidzIGRlZmluaXRpb24uXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTlJFQUNIQUJMRVwiO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRUFDSEFCTEVfUEFUVEVSTixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogW3Rva1R5cGUsIHRva2VuVHlwZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHRlc3RUb2tlblR5cGUoc3RyLCBwYXR0ZXJuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgdmFyIHJlZ0V4cEFycmF5ID0gcGF0dGVybi5leGVjKHN0cik7XG4gICAgICAgIHJldHVybiByZWdFeHBBcnJheSAhPT0gbnVsbCAmJiByZWdFeHBBcnJheS5pbmRleCA9PT0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwYXR0ZXJuKSkge1xuICAgICAgICAvLyBtYWludGFpbiB0aGUgQVBJIG9mIGN1c3RvbSBwYXR0ZXJuc1xuICAgICAgICByZXR1cm4gcGF0dGVybihzdHIsIDAsIFtdLCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhcyhwYXR0ZXJuLCBcImV4ZWNcIikpIHtcbiAgICAgICAgLy8gbWFpbnRhaW4gdGhlIEFQSSBvZiBjdXN0b20gcGF0dGVybnNcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uZXhlYyhzdHIsIDAsIFtdLCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuID09PSBzdHI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vTWV0YUNoYXIocmVnRXhwKSB7XG4gICAgLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcbiAgICB2YXIgbWV0YUNoYXJzID0gW1xuICAgICAgICBcIi5cIixcbiAgICAgICAgXCJcXFxcXCIsXG4gICAgICAgIFwiW1wiLFxuICAgICAgICBcIl1cIixcbiAgICAgICAgXCJ8XCIsXG4gICAgICAgIFwiXlwiLFxuICAgICAgICBcIiRcIixcbiAgICAgICAgXCIoXCIsXG4gICAgICAgIFwiKVwiLFxuICAgICAgICBcIj9cIixcbiAgICAgICAgXCIqXCIsXG4gICAgICAgIFwiK1wiLFxuICAgICAgICBcIntcIlxuICAgIF07XG4gICAgcmV0dXJuIChmaW5kKG1ldGFDaGFycywgZnVuY3Rpb24gKGNoYXIpIHsgcmV0dXJuIHJlZ0V4cC5zb3VyY2UuaW5kZXhPZihjaGFyKSAhPT0gLTE7IH0pID09PVxuICAgICAgICB1bmRlZmluZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFN0YXJ0T2ZJbnB1dChwYXR0ZXJuKSB7XG4gICAgdmFyIGZsYWdzID0gcGF0dGVybi5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiO1xuICAgIC8vIGFsd2F5cyB3cmFwcGluZyBpbiBhIG5vbmUgY2FwdHVyaW5nIGdyb3VwIHByZWNlZGVkIGJ5ICdeJyB0byBtYWtlIHN1cmUgbWF0Y2hpbmcgY2FuIG9ubHkgd29yayBvbiBzdGFydCBvZiBpbnB1dC5cbiAgICAvLyBkdXBsaWNhdGUvcmVkdW5kYW50IHN0YXJ0IG9mIGlucHV0IG1hcmtlcnMgaGF2ZSBubyBtZWFuaW5nICgvXl5eXkEvID09PSAvXkEvKVxuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgcGF0dGVybi5zb3VyY2UgKyBcIilcIiwgZmxhZ3MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFN0aWNreUZsYWcocGF0dGVybikge1xuICAgIHZhciBmbGFncyA9IHBhdHRlcm4uaWdub3JlQ2FzZSA/IFwiaXlcIiA6IFwieVwiO1xuICAgIC8vIGFsd2F5cyB3cmFwcGluZyBpbiBhIG5vbmUgY2FwdHVyaW5nIGdyb3VwIHByZWNlZGVkIGJ5ICdeJyB0byBtYWtlIHN1cmUgbWF0Y2hpbmcgY2FuIG9ubHkgd29yayBvbiBzdGFydCBvZiBpbnB1dC5cbiAgICAvLyBkdXBsaWNhdGUvcmVkdW5kYW50IHN0YXJ0IG9mIGlucHV0IG1hcmtlcnMgaGF2ZSBubyBtZWFuaW5nICgvXl5eXkEvID09PSAvXkEvKVxuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXCIgKyBwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlcmZvcm1SdW50aW1lQ2hlY2tzKGxleGVyRGVmaW5pdGlvbiwgdHJhY2tMaW5lcywgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIC8vIHNvbWUgcnVuIHRpbWUgY2hlY2tzIHRvIGhlbHAgdGhlIGVuZCB1c2Vycy5cbiAgICBpZiAoIWhhcyhsZXhlckRlZmluaXRpb24sIERFRkFVTFRfTU9ERSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIiArXG4gICAgICAgICAgICAgICAgREVGQVVMVF9NT0RFICtcbiAgICAgICAgICAgICAgICBcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWhhcyhsZXhlckRlZmluaXRpb24sIE1PREVTKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRob3V0IGEgPFwiICtcbiAgICAgICAgICAgICAgICBNT0RFUyArXG4gICAgICAgICAgICAgICAgXCI+IHByb3BlcnR5IGluIGl0cyBkZWZpbml0aW9uXFxuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzKGxleGVyRGVmaW5pdGlvbiwgTU9ERVMpICYmXG4gICAgICAgIGhhcyhsZXhlckRlZmluaXRpb24sIERFRkFVTFRfTU9ERSkgJiZcbiAgICAgICAgIWhhcyhsZXhlckRlZmluaXRpb24ubW9kZXMsIGxleGVyRGVmaW5pdGlvbi5kZWZhdWx0TW9kZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIFwiICsgREVGQVVMVF9NT0RFICsgXCI6IDxcIiArIGxleGVyRGVmaW5pdGlvbi5kZWZhdWx0TW9kZSArIFwiPlwiICtcbiAgICAgICAgICAgICAgICBcIndoaWNoIGRvZXMgbm90IGV4aXN0XFxuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoYXMobGV4ZXJEZWZpbml0aW9uLCBNT0RFUykpIHtcbiAgICAgICAgZm9yRWFjaChsZXhlckRlZmluaXRpb24ubW9kZXMsIGZ1bmN0aW9uIChjdXJyTW9kZVZhbHVlLCBjdXJyTW9kZU5hbWUpIHtcbiAgICAgICAgICAgIGZvckVhY2goY3Vyck1vZGVWYWx1ZSwgZnVuY3Rpb24gKGN1cnJUb2tUeXBlLCBjdXJySWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkEgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHVzaW5nIGFuIHVuZGVmaW5lZCBUb2tlbiBUeXBlLiBNb2RlOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCI8XCIgKyBjdXJyTW9kZU5hbWUgKyBcIj4gYXQgaW5kZXg6IDxcIiArIGN1cnJJZHggKyBcIj5cXG5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcyhsZXhlckRlZmluaXRpb24sIHRyYWNrTGluZXMsIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgIHZhciBoYXNBbnlMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICB2YXIgYWxsVG9rZW5UeXBlcyA9IGNvbXBhY3QoZmxhdHRlbihtYXBWYWx1ZXMobGV4ZXJEZWZpbml0aW9uLm1vZGVzLCBmdW5jdGlvbiAodG9rVHlwZXMpIHsgcmV0dXJuIHRva1R5cGVzOyB9KSkpO1xuICAgIHZhciBjb25jcmV0ZVRva2VuVHlwZXMgPSByZWplY3QoYWxsVG9rZW5UeXBlcywgZnVuY3Rpb24gKGN1cnJUeXBlKSB7IHJldHVybiBjdXJyVHlwZVtQQVRURVJOXSA9PT0gTGV4ZXIuTkE7IH0pO1xuICAgIHZhciB0ZXJtaW5hdG9yQ2hhckNvZGVzID0gZ2V0Q2hhckNvZGVzKGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyk7XG4gICAgaWYgKHRyYWNrTGluZXMpIHtcbiAgICAgICAgZm9yRWFjaChjb25jcmV0ZVRva2VuVHlwZXMsIGZ1bmN0aW9uICh0b2tUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY3Vycklzc3VlID0gY2hlY2tMaW5lQnJlYWtzSXNzdWVzKHRva1R5cGUsIHRlcm1pbmF0b3JDaGFyQ29kZXMpO1xuICAgICAgICAgICAgaWYgKGN1cnJJc3N1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGJ1aWxkTGluZUJyZWFrSXNzdWVNZXNzYWdlKHRva1R5cGUsIGN1cnJJc3N1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHdhcm5pbmdEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjdXJySXNzdWUuaXNzdWUsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZTogdG9rVHlwZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2FybmluZ3MucHVzaCh3YXJuaW5nRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGF0dGVtcHQgdG8gc2NhbiBpZiB0aGUgdXNlciBleHBsaWNpdGx5IHNwZWNpZmllZCB0aGUgbGluZV9icmVha3Mgb3B0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChoYXModG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rVHlwZS5MSU5FX0JSRUFLUyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQW55TGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbk1hdGNoQ2hhckNvZGUodGVybWluYXRvckNoYXJDb2RlcywgdG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQW55TGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0cmFja0xpbmVzICYmICFoYXNBbnlMaW5lQnJlYWspIHtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIldhcm5pbmc6IE5vIExJTkVfQlJFQUtTIEZvdW5kLlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRoaXMgTGV4ZXIgaGFzIGJlZW4gZGVmaW5lZCB0byB0cmFjayBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24sXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0QnV0IG5vbmUgb2YgdGhlIFRva2VuIFR5cGVzIGNhbiBiZSBpZGVudGlmaWVkIGFzIG1hdGNoaW5nIGEgbGluZSB0ZXJtaW5hdG9yLlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNMSU5FX0JSRUFLUyBcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19MSU5FX0JSRUFLU19GTEFHU1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdhcm5pbmdzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRW1wdHlHcm91cHMoZW1wdHlHcm91cHMpIHtcbiAgICB2YXIgY2xvbmVkUmVzdWx0ID0ge307XG4gICAgdmFyIGdyb3VwS2V5cyA9IGtleXMoZW1wdHlHcm91cHMpO1xuICAgIGZvckVhY2goZ3JvdXBLZXlzLCBmdW5jdGlvbiAoY3VycktleSkge1xuICAgICAgICB2YXIgY3Vyckdyb3VwVmFsdWUgPSBlbXB0eUdyb3Vwc1tjdXJyS2V5XTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzQXJyYXkoY3Vyckdyb3VwVmFsdWUpKSB7XG4gICAgICAgICAgICBjbG9uZWRSZXN1bHRbY3VycktleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmVkUmVzdWx0O1xufVxuLy8gVE9ETzogcmVmYWN0b3IgdG8gYXZvaWQgZHVwbGljYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBpc0N1c3RvbVBhdHRlcm4odG9rZW5UeXBlKSB7XG4gICAgdmFyIHBhdHRlcm4gPSB0b2tlblR5cGUuUEFUVEVSTjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGF0dGVybikpIHtcbiAgICAgICAgLy8gQ3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jIC0gY3VzdG9tIHBhdHRlcm5zIGRvIG5vdCByZXF1aXJlIGFueSB0cmFuc2Zvcm1hdGlvbnMsIG9ubHkgd3JhcHBpbmcgaW4gYSBSZWdFeHAgTGlrZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhcyhwYXR0ZXJuLCBcImV4ZWNcIikpIHtcbiAgICAgICAgLy8gSUN1c3RvbVBhdHRlcm5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2hvcnRQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICBpZiAoaXNTdHJpbmcocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEZhc3RlciB0aGFuIHVzaW5nIGEgUmVnRXhwIGZvciBkZWZhdWx0IG5ld2xpbmUgZGV0ZWN0aW9uIGR1cmluZyBsZXhpbmcuXG4gKi9cbmV4cG9ydCB2YXIgTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXIgPSB7XG4gICAgLy8gaW1wbGVtZW50cyAvXFxufFxcclxcbj8vZy50ZXN0XG4gICAgdGVzdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sYXN0SW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBpICsgMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGxhc3RJbmRleDogMFxufTtcbmZ1bmN0aW9uIGNoZWNrTGluZUJyZWFrc0lzc3Vlcyh0b2tUeXBlLCBsaW5lVGVybWluYXRvckNoYXJDb2Rlcykge1xuICAgIGlmIChoYXModG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGRlY2xhcmVkIHRoZSBsaW5lX2JyZWFrcyBvcHRpb24gd2Ugd2lsbCByZXNwZWN0IHRoZWlyIGNob2ljZVxuICAgICAgICAvLyBhbmQgYXNzdW1lIGl0IGlzIGNvcnJlY3QuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc1JlZ0V4cCh0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbk1hdGNoQ2hhckNvZGUobGluZVRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gdG8gdGVzdCB0aGlzIHdlIHdvdWxkIGhhdmUgdG8gbW9jayA8Y2FuTWF0Y2hDaGFyQ29kZT4gdG8gdGhyb3cgYW4gZXJyb3IgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IsXG4gICAgICAgICAgICAgICAgICAgIGVyck1zZzogZS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbCBwYXR0ZXJucyBjYW4gYWx3YXlzIGJlIGFuYWx5emVkIHRvIGRldGVjdCBsaW5lIHRlcm1pbmF0b3IgdXNhZ2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0N1c3RvbVBhdHRlcm4odG9rVHlwZSkpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbSB0b2tlbiB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNzdWU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTElORV9CUkVBSyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExpbmVCcmVha0lzc3VlTWVzc2FnZSh0b2tUeXBlLCBkZXRhaWxzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZGV0YWlscy5pc3N1ZSA9PT0gTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IpIHtcbiAgICAgICAgcmV0dXJuIChcIldhcm5pbmc6IHVuYWJsZSB0byBpZGVudGlmeSBsaW5lIHRlcm1pbmF0b3IgdXNhZ2UgaW4gcGF0dGVybi5cXG5cIiArXG4gICAgICAgICAgICAoXCJcXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPFwiICsgdG9rVHlwZS5uYW1lICsgXCI+IFRva2VuIFR5cGVcXG5cIikgK1xuICAgICAgICAgICAgKFwiXFx0IFJvb3QgY2F1c2U6IFwiICsgZGV0YWlscy5lcnJNc2cgKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0lERU5USUZZX1RFUk1JTkFUT1JcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRldGFpbHMuaXNzdWUgPT09IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTElORV9CUkVBSykge1xuICAgICAgICByZXR1cm4gKFwiV2FybmluZzogQSBDdXN0b20gVG9rZW4gUGF0dGVybiBzaG91bGQgc3BlY2lmeSB0aGUgPGxpbmVfYnJlYWtzPiBvcHRpb24uXFxuXCIgK1xuICAgICAgICAgICAgKFwiXFx0VGhlIHByb2JsZW0gaXMgaW4gdGhlIDxcIiArIHRva1R5cGUubmFtZSArIFwiPiBUb2tlbiBUeXBlXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fTElORV9CUkVBS1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hhckNvZGVzKGNoYXJzT3JDb2Rlcykge1xuICAgIHZhciBjaGFyQ29kZXMgPSBtYXAoY2hhcnNPckNvZGVzLCBmdW5jdGlvbiAobnVtT3JTdHJpbmcpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKG51bU9yU3RyaW5nKSAmJiBudW1PclN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtT3JTdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1PclN0cmluZztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjaGFyQ29kZXM7XG59XG5mdW5jdGlvbiBhZGRUb01hcE9mQXJyYXlzKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChtYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1hcFtrZXldID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcFtrZXldLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgbWluT3B0aW1pemF0aW9uVmFsID0gMjU2O1xuLyoqXG4gKiBXZSBhZSBtYXBwaW5nIGNoYXJDb2RlIGFib3ZlIEFTQ0kgKDI1NikgaW50byBidWNrZXRzIGVhY2ggaW4gdGhlIHNpemUgb2YgMjU2LlxuICogVGhpcyBpcyBiZWNhdXNlIEFTQ0kgYXJlIHRoZSBtb3N0IGNvbW1vbiBzdGFydCBjaGFycyBzbyBlYWNoIG9uZSBvZiB0aG9zZSB3aWxsIGdldCBpdHMgb3duXG4gKiBwb3NzaWJsZSB0b2tlbiBjb25maWdzIHZlY3Rvci5cbiAqXG4gKiBUb2tlbnMgc3RhcnRpbmcgd2l0aCBjaGFyQ29kZXMgXCJhYm92ZVwiIEFTQ0kgYXJlIHVuY29tbW9uLCBzbyB3ZSBjYW4gXCJhZmZvcmRcIlxuICogdG8gcGxhY2UgdGhlc2UgaW50byBidWNrZXRzIG9mIHBvc3NpYmxlIHRva2VuIGNvbmZpZ3MsIFdoYXQgd2UgZ2FpbiBmcm9tXG4gKiB0aGlzIGlzIGF2b2lkaW5nIHRoZSBjYXNlIG9mIGNyZWF0aW5nIGFuIG9wdGltaXphdGlvbiAnY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZydcbiAqIHdoaWNoIHdvdWxkIGNvbnRhaW4gMTAsMDAwKyBhcnJheXMgb2Ygc21hbGwgc2l6ZSAoZS5nIHVuaWNvZGUgSWRlbnRpZmllcnMgc2NlbmFyaW8pLlxuICogT3VyICdjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnJyBtYXggc2l6ZSB3aWxsIG5vdyBiZTpcbiAqIDI1NiArICgyXjE2IC8gMl44KSAtIDEgPT09IDUxMVxuICpcbiAqIG5vdGUgdGhlIGhhY2sgZm9yIGZhc3QgZGl2aXNpb24gaW50ZWdlciBwYXJ0IGV4dHJhY3Rpb25cbiAqIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQyMjg1MjhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSkge1xuICAgIHJldHVybiBjaGFyQ29kZSA8IG1pbk9wdGltaXphdGlvblZhbFxuICAgICAgICA/IGNoYXJDb2RlXG4gICAgICAgIDogY2hhckNvZGVUb09wdGltaXplZElkeE1hcFtjaGFyQ29kZV07XG59XG4vKipcbiAqIFRoaXMgaXMgYSBjb21wcm9taXNlIGJldHdlZW4gY29sZCBzdGFydCAvIGhvdCBydW5uaW5nIHBlcmZvcm1hbmNlXG4gKiBDcmVhdGluZyB0aGlzIGFycmF5IHRha2VzIH4zbXMgb24gYSBtb2Rlcm4gbWFjaGluZSxcbiAqIEJ1dCBpZiB3ZSBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBhdCBydW50aW1lIGFzIG5lZWRlZCB0aGUgQ1NTIExleGVyIGJlbmNobWFya1xuICogcGVyZm9ybWFuY2UgZGVncmFkZXMgYnkgfjEwJVxuICpcbiAqIFRPRE86IFBlcmhhcHMgaXQgc2hvdWxkIGJlIGxhenkgaW5pdGlhbGl6ZWQgb25seSBpZiBhIGNoYXJDb2RlID4gMjU1IGlzIHVzZWQuXG4gKi9cbnZhciBjaGFyQ29kZVRvT3B0aW1pemVkSWR4TWFwID0gW107XG5mdW5jdGlvbiBpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwKCkge1xuICAgIGlmIChpc0VtcHR5KGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXApKSB7XG4gICAgICAgIGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXAgPSBuZXcgQXJyYXkoNjU1MzYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlICovXG4gICAgICAgICAgICBjaGFyQ29kZVRvT3B0aW1pemVkSWR4TWFwW2ldID0gaSA+IDI1NSA/IDI1NSArIH5+KGkgLyAyNTUpIDogaTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGUgKi9cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/lexer.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js":
/*!*************************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js ***!
  \*************************************************************************/
/*! exports provided: defaultLexerErrorProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultLexerErrorProvider\", function() { return defaultLexerErrorProvider; });\nvar defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage: function (token) {\n        return \"Unable to pop Lexer Mode after encountering Token ->\" + token.image + \"<- The Mode Stack is empty\";\n    },\n    buildUnexpectedCharactersMessage: function (fullText, startOffset, length, line, column) {\n        return (\"unexpected character: ->\" + fullText.charAt(startOffset) + \"<- at offset: \" + startOffset + \",\" + (\" skipped \" + length + \" characters.\"));\n    }\n};\n//# sourceMappingURL=lexer_errors_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWMuanM/ZjFhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgPSB7XG4gICAgYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2U6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gXCJVbmFibGUgdG8gcG9wIExleGVyIE1vZGUgYWZ0ZXIgZW5jb3VudGVyaW5nIFRva2VuIC0+XCIgKyB0b2tlbi5pbWFnZSArIFwiPC0gVGhlIE1vZGUgU3RhY2sgaXMgZW1wdHlcIjtcbiAgICB9LFxuICAgIGJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlOiBmdW5jdGlvbiAoZnVsbFRleHQsIHN0YXJ0T2Zmc2V0LCBsZW5ndGgsIGxpbmUsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gKFwidW5leHBlY3RlZCBjaGFyYWN0ZXI6IC0+XCIgKyBmdWxsVGV4dC5jaGFyQXQoc3RhcnRPZmZzZXQpICsgXCI8LSBhdCBvZmZzZXQ6IFwiICsgc3RhcnRPZmZzZXQgKyBcIixcIiArIChcIiBza2lwcGVkIFwiICsgbGVuZ3RoICsgXCIgY2hhcmFjdGVycy5cIikpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9lcnJvcnNfcHVibGljLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js":
/*!******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js ***!
  \******************************************************************/
/*! exports provided: LexerDefinitionErrorType, Lexer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LexerDefinitionErrorType\", function() { return LexerDefinitionErrorType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer.js\");\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n/* harmony import */ var _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scan/lexer_errors_public */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer_errors_public.js\");\n/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reg_exp_parser */ \"./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\");\n\n\n\n\n\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_3__[\"defaultLexerErrorProvider\"],\n    traceInitPerf: false,\n    skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        var _this = this;\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.config = undefined;\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"merge\"])(DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = _lexer__WEBPACK_IMPORTED_MODULE_0__[\"LineTerminatorOptimizedTester\"];\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isArray\"])(lexerDefinition)) {\n                    actualDefinition = { modes: {} };\n                    actualDefinition.modes[_lexer__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_MODE\"]] = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneArr\"])(lexerDefinition);\n                    actualDefinition[_lexer__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_MODE\"]] = _lexer__WEBPACK_IMPORTED_MODULE_0__[\"DEFAULT_MODE\"];\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"cloneObj\"])((lexerDefinition));\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"performRuntimeChecks\"])(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat(Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"performWarningRuntimeChecks\"])(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"reject\"])(currModeValue, function (currTokType) { return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(currTokType); });\n            });\n            var allModeNames = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"keys\"])(actualDefinition.modes);\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\" + currModName + \"> processing\", function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat(Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"validatePatterns\"])(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(_this.lexerDefinitionErrors)) {\n                        Object(_tokens__WEBPACK_IMPORTED_MODULE_2__[\"augmentTokenTypes\"])(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"analyzeTokenTypes\"])(currModDef, {\n                                lineTerminatorCharacters: _this.config\n                                    .lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT.bind(_this)\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"merge\"])(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom =\n                            currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" +\n                    allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"PRINT_WARNING\"])(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (_lexer__WEBPACK_IMPORTED_MODULE_0__[\"SUPPORT_STICKY\"]) {\n                    _this.chopInput = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"IDENTITY\"];\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"IDENTITY\"];\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = _utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"NOOP\"];\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\" + _this.config.positionTracking + \"\\\"\");\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"reduce\"])(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \" + unOptimizedModes.join(\", \") + \" > cannot be optimized.\\n\" +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                Object(_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__[\"clearRegExpParserCache\"])();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"toFastProperties\"])(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isEmpty\"])(this.lexerDefinitionErrors)) {\n            var allErrMessages = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"map\"])(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        var lexResult = this.tokenizeInternal(text, initialMode);\n        return lexResult;\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"cloneEmptyGroups\"])(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns = undefined;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = Object(_lexer__WEBPACK_IMPORTED_MODULE_0__[\"charCodeToOptimizedIndex\"])(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine !== undefined\n                        ? popToken.startLine\n                        : undefined,\n                    column: popToken.startColumn !== undefined\n                        ? popToken.startColumn\n                        : undefined,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"last\"])(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig = _this\n                    .charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] &&\n                    _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this\n                .charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] &&\n                this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAltIdx = currConfig.longerAlt;\n                    if (longerAltIdx !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltConfig = patternIdxToConfig[longerAltIdx];\n                        var longerAltPattern = longerAltConfig.pattern;\n                        altPayload = null;\n                        // single Char can never be a longer alt so no need to test it.\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        if (longerAltConfig.isCustom === true) {\n                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                            if (match !== null) {\n                                matchAltImage = match[0];\n                                if (match.payload !== undefined) {\n                                    altPayload = match.payload;\n                                }\n                            }\n                            else {\n                                matchAltImage = null;\n                            }\n                        }\n                        else {\n                            this.updateLastIndex(longerAltPattern, offset);\n                            matchAltImage = this.match(longerAltPattern, text, offset);\n                        }\n                        if (matchAltImage &&\n                            matchAltImage.length > matchedImage.length) {\n                            matchedImage = matchAltImage;\n                            payload = altPayload;\n                            currConfig = longerAltConfig;\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true &&\n                    currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset =\n                                lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = false;\n                while (!foundResyncPoint && offset < orgLength) {\n                    // drop chars until we succeed in matching something\n                    droppedChar = orgText.charCodeAt(offset);\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.createTokenInstance = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return null;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {\n        return 666;\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n    /* istanbul ignore next - place holder */\n    Lexer.prototype.handlePayload = function (token, payload) { };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */\n    Lexer.prototype.match = function (pattern, text, offset) {\n        return null;\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : regExpArray;\n    };\n    // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(indent + \"--> <\" + phaseDesc + \">\");\n            }\n            var _a = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"timer\"])(phaseImpl), time = _a.time, value = _a.value;\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(indent + \"<-- <\" + phaseDesc + \"> time: \" + time + \"ms\");\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\n\n//# sourceMappingURL=lexer_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL2xleGVyX3B1YmxpYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vbGV4ZXJfcHVibGljLmpzPzJkOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYW5hbHl6ZVRva2VuVHlwZXMsIGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCwgY2xvbmVFbXB0eUdyb3VwcywgREVGQVVMVF9NT0RFLCBMaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlciwgcGVyZm9ybVJ1bnRpbWVDaGVja3MsIHBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcywgU1VQUE9SVF9TVElDS1ksIHZhbGlkYXRlUGF0dGVybnMgfSBmcm9tIFwiLi9sZXhlclwiO1xuaW1wb3J0IHsgY2xvbmVBcnIsIGNsb25lT2JqLCBmb3JFYWNoLCBJREVOVElUWSwgaXNBcnJheSwgaXNFbXB0eSwgaXNVbmRlZmluZWQsIGtleXMsIGxhc3QsIG1hcCwgbWVyZ2UsIE5PT1AsIFBSSU5UX1dBUk5JTkcsIHJlZHVjZSwgcmVqZWN0LCB0aW1lciwgdG9GYXN0UHJvcGVydGllcyB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgYXVnbWVudFRva2VuVHlwZXMgfSBmcm9tIFwiLi90b2tlbnNcIjtcbmltcG9ydCB7IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi4vc2Nhbi9sZXhlcl9lcnJvcnNfcHVibGljXCI7XG5pbXBvcnQgeyBjbGVhclJlZ0V4cFBhcnNlckNhY2hlIH0gZnJvbSBcIi4vcmVnX2V4cF9wYXJzZXJcIjtcbmV4cG9ydCB2YXIgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChMZXhlckRlZmluaXRpb25FcnJvclR5cGUpIHtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTUlTU0lOR19QQVRURVJOXCJdID0gMF0gPSBcIk1JU1NJTkdfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1BBVFRFUk5cIl0gPSAxXSA9IFwiSU5WQUxJRF9QQVRURVJOXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkVPSV9BTkNIT1JfRk9VTkRcIl0gPSAyXSA9IFwiRU9JX0FOQ0hPUl9GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJVTlNVUFBPUlRFRF9GTEFHU19GT1VORFwiXSA9IDNdID0gXCJVTlNVUFBPUlRFRF9GTEFHU19GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkRcIl0gPSA0XSA9IFwiRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfR1JPVVBfVFlQRV9GT1VORFwiXSA9IDVdID0gXCJJTlZBTElEX0dST1VQX1RZUEVfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNUXCJdID0gNl0gPSBcIlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFXCJdID0gN10gPSBcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXCJdID0gOF0gPSBcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWVwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVFwiXSA9IDldID0gXCJNVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJMRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiXSA9IDEwXSA9IFwiTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiU09JX0FOQ0hPUl9GT1VORFwiXSA9IDExXSA9IFwiU09JX0FOQ0hPUl9GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJFTVBUWV9NQVRDSF9QQVRURVJOXCJdID0gMTJdID0gXCJFTVBUWV9NQVRDSF9QQVRURVJOXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk5PX0xJTkVfQlJFQUtTX0ZMQUdTXCJdID0gMTNdID0gXCJOT19MSU5FX0JSRUFLU19GTEFHU1wiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJVTlJFQUNIQUJMRV9QQVRURVJOXCJdID0gMTRdID0gXCJVTlJFQUNIQUJMRV9QQVRURVJOXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklERU5USUZZX1RFUk1JTkFUT1JcIl0gPSAxNV0gPSBcIklERU5USUZZX1RFUk1JTkFUT1JcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQ1VTVE9NX0xJTkVfQlJFQUtcIl0gPSAxNl0gPSBcIkNVU1RPTV9MSU5FX0JSRUFLXCI7XG59KShMZXhlckRlZmluaXRpb25FcnJvclR5cGUgfHwgKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSA9IHt9KSk7XG52YXIgREVGQVVMVF9MRVhFUl9DT05GSUcgPSB7XG4gICAgZGVmZXJEZWZpbml0aW9uRXJyb3JzSGFuZGxpbmc6IGZhbHNlLFxuICAgIHBvc2l0aW9uVHJhY2tpbmc6IFwiZnVsbFwiLFxuICAgIGxpbmVUZXJtaW5hdG9yc1BhdHRlcm46IC9cXG58XFxyXFxuPy9nLFxuICAgIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczogW1wiXFxuXCIsIFwiXFxyXCJdLFxuICAgIGVuc3VyZU9wdGltaXphdGlvbnM6IGZhbHNlLFxuICAgIHNhZmVNb2RlOiBmYWxzZSxcbiAgICBlcnJvck1lc3NhZ2VQcm92aWRlcjogZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcixcbiAgICB0cmFjZUluaXRQZXJmOiBmYWxzZSxcbiAgICBza2lwVmFsaWRhdGlvbnM6IGZhbHNlXG59O1xuT2JqZWN0LmZyZWV6ZShERUZBVUxUX0xFWEVSX0NPTkZJRyk7XG52YXIgTGV4ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXIobGV4ZXJEZWZpbml0aW9uLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IERFRkFVTFRfTEVYRVJfQ09ORklHOyB9XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uID0gbGV4ZXJEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuSWR4VG9Db25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0ge307XG4gICAgICAgIHRoaXMubW9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbXB0eUdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmFja1N0YXJ0TGluZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYWNrRW5kTGluZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc0N1c3RvbSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbk1vZGVCZU9wdGltaXplZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGV4ZXIgY29uc3RydWN0b3IgaXMgbm93IGFuIElMZXhlckNvbmZpZyBPYmplY3QuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiYSBib29sZWFuIDJuZCBhcmd1bWVudCBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IGRlZmF1bHRzIGZ1bmM/XG4gICAgICAgIHRoaXMuY29uZmlnID0gbWVyZ2UoREVGQVVMVF9MRVhFUl9DT05GSUcsIGNvbmZpZyk7XG4gICAgICAgIHZhciB0cmFjZUluaXRWYWwgPSB0aGlzLmNvbmZpZy50cmFjZUluaXRQZXJmO1xuICAgICAgICBpZiAodHJhY2VJbml0VmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0cmFjZUluaXRWYWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUluaXRWYWw7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50ID0gLTE7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkxleGVyIENvbnN0cnVjdG9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEZWZpbml0aW9uO1xuICAgICAgICAgICAgdmFyIGhhc09ubHlTaW5nbGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJMZXhlciBDb25maWcgaGFuZGxpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybiA9PT1cbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9MRVhFUl9DT05GSUcubGluZVRlcm1pbmF0b3JzUGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgYnVpbHQtaW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBkZWZhdWx0cyBkZWZpbml0aW9uIG9mIGxpbmVUZXJtaW5hdG9yc1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybiA9IExpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0xFWEVSX0NPTkZJRy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3I6IE1pc3NpbmcgPGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycz4gcHJvcGVydHkgb24gdGhlIExleGVyIGNvbmZpZy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI01JU1NJTkdfTElORV9URVJNX0NIQVJTXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2FmZU1vZGUgJiYgY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wic2FmZU1vZGVcIiBhbmQgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2tTdGFydExpbmVzID0gL2Z1bGx8b25seVN0YXJ0L2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyk7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhY2tFbmRMaW5lcyA9IC9mdWxsL2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyk7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBTaW5nbGVNb2RlTGV4ZXJEZWZpbml0aW9uIGludG8gYSBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGxleGVyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbiA9IHsgbW9kZXM6IHt9IH07XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24ubW9kZXNbREVGQVVMVF9NT0RFXSA9IGNsb25lQXJyKGxleGVyRGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb25bREVGQVVMVF9NT0RFXSA9IERFRkFVTFRfTU9ERTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbnZlcnNpb24gbmVlZGVkLCBpbnB1dCBzaG91bGQgYWxyZWFkeSBiZSBhIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaGFzT25seVNpbmdsZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbiA9IGNsb25lT2JqKChsZXhlckRlZmluaXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuc2tpcFZhbGlkYXRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJwZXJmb3JtUnVudGltZUNoZWNrc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyA9IF90aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycy5jb25jYXQocGVyZm9ybVJ1bnRpbWVDaGVja3MoYWN0dWFsRGVmaW5pdGlvbiwgX3RoaXMudHJhY2tTdGFydExpbmVzLCBfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcgPSBfdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nLmNvbmNhdChwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MoYWN0dWFsRGVmaW5pdGlvbiwgX3RoaXMudHJhY2tTdGFydExpbmVzLCBfdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgZXh0cmEgcm9idXN0bmVzcyB0byBhdm9pZCB0aHJvd2luZyBhbiBub25lIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24ubW9kZXMgPSBhY3R1YWxEZWZpbml0aW9uLm1vZGVzXG4gICAgICAgICAgICAgICAgPyBhY3R1YWxEZWZpbml0aW9uLm1vZGVzXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIG9mIHVuZGVmaW5lZCBUb2tlblR5cGVzIHdpbGwgYmUgZGV0ZWN0ZWQgaW4gXCJwZXJmb3JtUnVudGltZUNoZWNrc1wiIGFib3ZlLlxuICAgICAgICAgICAgLy8gdGhpcyB0cmFuc2Zvcm1hdGlvbiBpcyB0byBpbmNyZWFzZSByb2J1c3RuZXNzIGluIHRoZSBjYXNlIG9mIHBhcnRpYWxseSBpbnZhbGlkIGxleGVyIGRlZmluaXRpb24uXG4gICAgICAgICAgICBmb3JFYWNoKGFjdHVhbERlZmluaXRpb24ubW9kZXMsIGZ1bmN0aW9uIChjdXJyTW9kZVZhbHVlLCBjdXJyTW9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uLm1vZGVzW2N1cnJNb2RlTmFtZV0gPSByZWplY3QoY3Vyck1vZGVWYWx1ZSwgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7IHJldHVybiBpc1VuZGVmaW5lZChjdXJyVG9rVHlwZSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYWxsTW9kZU5hbWVzID0ga2V5cyhhY3R1YWxEZWZpbml0aW9uLm1vZGVzKTtcbiAgICAgICAgICAgIGZvckVhY2goYWN0dWFsRGVmaW5pdGlvbi5tb2RlcywgZnVuY3Rpb24gKGN1cnJNb2REZWYsIGN1cnJNb2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIk1vZGU6IDxcIiArIGN1cnJNb2ROYW1lICsgXCI+IHByb2Nlc3NpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb2Rlcy5wdXNoKGN1cnJNb2ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5za2lwVmFsaWRhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5UUkFDRV9JTklUKFwidmFsaWRhdGVQYXR0ZXJuc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzID0gX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdCh2YWxpZGF0ZVBhdHRlcm5zKGN1cnJNb2REZWYsIGFsbE1vZGVOYW1lcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVmaW5pdGlvbiBlcnJvcnMgd2VyZSBlbmNvdW50ZXJlZCwgdGhlIGFuYWx5c2lzIHBoYXNlIG1heSBmYWlsIHVuZXhwZWN0ZWRseS9cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgYSBsZXhlciB3aXRoIGRlZmluaXRpb24gZXJyb3JzIG1heSBuZXZlciBiZSB1c2VkLCB0aGVyZSBpcyBubyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBwZXJmb3JtaW5nIHRoZSBhbmFseXNpcyBhbnlob3cuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoX3RoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVnbWVudFRva2VuVHlwZXMoY3Vyck1vZERlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckFuYWx5emVSZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJhbmFseXplVG9rZW5UeXBlc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHRfMSA9IGFuYWx5emVUb2tlblR5cGVzKGN1cnJNb2REZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBfdGhpcy5jb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5saW5lVGVybWluYXRvckNoYXJhY3RlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVHJhY2tpbmc6IGNvbmZpZy5wb3NpdGlvblRyYWNraW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnN1cmVPcHRpbWl6YXRpb25zOiBjb25maWcuZW5zdXJlT3B0aW1pemF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FmZU1vZGU6IGNvbmZpZy5zYWZlTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VyOiBfdGhpcy5UUkFDRV9JTklULmJpbmQoX3RoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tjdXJyTW9kTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0XzEucGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tjdXJyTW9kTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0XzEuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtcHR5R3JvdXBzID0gbWVyZ2UoX3RoaXMuZW1wdHlHcm91cHMsIGN1cnJBbmFseXplUmVzdWx0XzEuZW1wdHlHcm91cHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFzQ3VzdG9tID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xLmhhc0N1c3RvbSB8fCBfdGhpcy5oYXNDdXN0b207XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbY3Vyck1vZE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdF8xLmNhbkJlT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmRlZmF1bHRNb2RlID0gYWN0dWFsRGVmaW5pdGlvbi5kZWZhdWx0TW9kZTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eShfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLmNvbmZpZy5kZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlcyA9IG1hcChfdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgYWxsRXJyTWVzc2FnZXNTdHJpbmcgPSBhbGxFcnJNZXNzYWdlcy5qb2luKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHByaW50IHdhcm5pbmcgaWYgdGhlcmUgYXJlIG5vIGVycm9ycywgVGhpcyB3aWxsIGF2b2lkIHBsXG4gICAgICAgICAgICBmb3JFYWNoKF90aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcsIGZ1bmN0aW9uICh3YXJuaW5nRGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIFBSSU5UX1dBUk5JTkcod2FybmluZ0Rlc2NyaXB0b3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLlRSQUNFX0lOSVQoXCJDaG9vc2luZyBzdWItbWV0aG9kcyBpbXBsZW1lbnRhdGlvbnNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgcmVsZXZhbnQgaW50ZXJuYWwgaW1wbGVtZW50YXRpb25zIGZvciB0aGlzIHNwZWNpZmljIHBhcnNlci5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGJlIGluLWxpbmVkIGJ5IHRoZSBKYXZhU2NyaXB0IGVuZ2luZVxuICAgICAgICAgICAgICAgIC8vIHRvIHByb3ZpZGUgb3B0aW1hbCBwZXJmb3JtYW5jZSBpbiBlYWNoIHNjZW5hcmlvLlxuICAgICAgICAgICAgICAgIGlmIChTVVBQT1JUX1NUSUNLWSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaG9wSW5wdXQgPSBJREVOVElUWTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF0Y2ggPSBfdGhpcy5tYXRjaFdpdGhUZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlTGFzdEluZGV4ID0gTk9PUDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWF0Y2ggPSBfdGhpcy5tYXRjaFdpdGhFeGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzT25seVNpbmdsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9kZXMgPSBOT09QO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJhY2tTdGFydExpbmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlTmV3Q29sdW1uID0gSURFTlRJVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmFja0VuZExpbmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbiA9IE5PT1A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvZnVsbC9pLnRlc3QoX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBfdGhpcy5jcmVhdGVGdWxsVG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5U3RhcnQvaS50ZXN0KF90aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlID0gX3RoaXMuY3JlYXRlU3RhcnRPbmx5VG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9vbmx5T2Zmc2V0L2kudGVzdChfdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IF90aGlzLmNyZWF0ZU9mZnNldE9ubHlUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCA8cG9zaXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXFxcIlwiICsgX3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5oYXNDdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkVG9rZW4gPSBfdGhpcy5hZGRUb2tlblVzaW5nUHVzaDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGF5bG9hZCA9IF90aGlzLmhhbmRsZVBheWxvYWRXaXRoQ3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkVG9rZW4gPSBfdGhpcy5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYXlsb2FkID0gX3RoaXMuaGFuZGxlUGF5bG9hZE5vQ3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcIkZhaWxlZCBPcHRpbWl6YXRpb24gV2FybmluZ3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB1bk9wdGltaXplZE1vZGVzID0gcmVkdWNlKF90aGlzLmNhbk1vZGVCZU9wdGltaXplZCwgZnVuY3Rpb24gKGNhbm5vdEJlT3B0aW1pemVkLCBjYW5CZU9wdGltaXplZCwgbW9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkJlT3B0aW1pemVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Fubm90QmVPcHRpbWl6ZWQucHVzaChtb2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbm5vdEJlT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMgJiYgIWlzRW1wdHkodW5PcHRpbWl6ZWRNb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJMZXhlciBNb2RlczogPCBcIiArIHVuT3B0aW1pemVkTW9kZXMuam9pbihcIiwgXCIpICsgXCIgPiBjYW5ub3QgYmUgb3B0aW1pemVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXHQgRGlzYWJsZSB0aGUgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgbGV4ZXIgY29uZmlnIGZsYWcgdG8gc2lsZW50bHkgaWdub3JlIHRoaXMgYW5kIHJ1biB0aGUgbGV4ZXIgaW4gYW4gdW4tb3B0aW1pemVkIG1vZGUuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdCBPciBpbnNwZWN0IHRoZSBjb25zb2xlIGxvZyBmb3IgZGV0YWlscyBvbiBob3cgdG8gcmVzb2x2ZSB0aGVzZSBpc3N1ZXMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcImNsZWFyUmVnRXhwUGFyc2VyQ2FjaGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BlcnRpZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRvRmFzdFByb3BlcnRpZXMoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBMZXhlci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAodGV4dCwgaW5pdGlhbE1vZGUpIHtcbiAgICAgICAgaWYgKGluaXRpYWxNb2RlID09PSB2b2lkIDApIHsgaW5pdGlhbE1vZGUgPSB0aGlzLmRlZmF1bHRNb2RlOyB9XG4gICAgICAgIGlmICghaXNFbXB0eSh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlcyA9IG1hcCh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxFcnJNZXNzYWdlc1N0cmluZyA9IGFsbEVyck1lc3NhZ2VzLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBUb2tlbml6ZSBiZWNhdXNlIEVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiICtcbiAgICAgICAgICAgICAgICBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxleFJlc3VsdCA9IHRoaXMudG9rZW5pemVJbnRlcm5hbCh0ZXh0LCBpbml0aWFsTW9kZSk7XG4gICAgICAgIHJldHVybiBsZXhSZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBUaGVyZSBpcyBxdWl0ZSBhIGJpdCBvZiBkdXBsaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIFwidG9rZW5pemVJbnRlcm5hbExhenlcIlxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgZHVlIHRvIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb25zLlxuICAgIExleGVyLnByb3RvdHlwZS50b2tlbml6ZUludGVybmFsID0gZnVuY3Rpb24gKHRleHQsIGluaXRpYWxNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpLCBqLCBtYXRjaEFsdEltYWdlLCBsb25nZXJBbHRJZHgsIG1hdGNoZWRJbWFnZSwgcGF5bG9hZCwgYWx0UGF5bG9hZCwgaW1hZ2VMZW5ndGgsIGdyb3VwLCB0b2tUeXBlLCBuZXdUb2tlbiwgZXJyTGVuZ3RoLCBkcm9wcGVkQ2hhciwgbXNnLCBtYXRjaDtcbiAgICAgICAgdmFyIG9yZ1RleHQgPSB0ZXh0O1xuICAgICAgICB2YXIgb3JnTGVuZ3RoID0gb3JnVGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbWF0Y2hlZFRva2Vuc0luZGV4ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSB0b2tlbnNBcnJheSB0byB0aGUgXCJndWVzc2VkXCIgc2l6ZS5cbiAgICAgICAgLy8gZ3Vlc3NpbmcgdG9vIGxpdHRsZSB3aWxsIHN0aWxsIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGFycmF5IHJlLXNpemVzIG9uIHB1c2hlcy5cbiAgICAgICAgLy8gZ3Vlc3NpbmcgdG9vIGxhcmdlIChUZXN0ZWQgYnkgZ3Vlc3NpbmcgeDQgdG9vIGxhcmdlKSBtYXkgY29zdCBhIGJpdCBtb3JlIG9mIG1lbW9yeVxuICAgICAgICAvLyBidXQgd291bGQgc3RpbGwgaGF2ZSBhIGZhc3RlciBydW50aW1lIGJ5IGF2b2lkaW5nIChBbGwgYnV0IG9uZSkgYXJyYXkgcmVzaXppbmcuXG4gICAgICAgIHZhciBndWVzc2VkTnVtYmVyT2ZUb2tlbnMgPSB0aGlzLmhhc0N1c3RvbVxuICAgICAgICAgICAgPyAwIC8vIHdpbGwgYnJlYWsgY3VzdG9tIHRva2VuIHBhdHRlcm4gQVBJcyB0aGUgbWF0Y2hlZFRva2VucyBhcnJheSB3aWxsIGNvbnRhaW4gdW5kZWZpbmVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoIC8gMTApO1xuICAgICAgICB2YXIgbWF0Y2hlZFRva2VucyA9IG5ldyBBcnJheShndWVzc2VkTnVtYmVyT2ZUb2tlbnMpO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy50cmFja1N0YXJ0TGluZXMgPyAxIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy50cmFja1N0YXJ0TGluZXMgPyAxIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZ3JvdXBzID0gY2xvbmVFbXB0eUdyb3Vwcyh0aGlzLmVtcHR5R3JvdXBzKTtcbiAgICAgICAgdmFyIHRyYWNrTGluZXMgPSB0aGlzLnRyYWNrU3RhcnRMaW5lcztcbiAgICAgICAgdmFyIGxpbmVUZXJtaW5hdG9yUGF0dGVybiA9IHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm47XG4gICAgICAgIHZhciBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHBhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgICAgICB2YXIgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICAgICAgdmFyIG1vZGVTdGFjayA9IFtdO1xuICAgICAgICB2YXIgZW1wdHlBcnJheSA9IFtdO1xuICAgICAgICBPYmplY3QuZnJlZXplKGVtcHR5QXJyYXkpO1xuICAgICAgICB2YXIgZ2V0UG9zc2libGVQYXR0ZXJucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3coKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKTtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZVBhdHRlcm5zID0gY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbb3B0aW1pemVkQ2hhcklkeF07XG4gICAgICAgICAgICBpZiAocG9zc2libGVQYXR0ZXJucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQYXR0ZXJucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9wX21vZGUgPSBmdW5jdGlvbiAocG9wVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHBlcmhhcHMgYXZvaWQgdGhpcyBlcnJvciBpbiB0aGUgZWRnZSBjYXNlIHRoZXJlIGlzIG5vIG1vcmUgaW5wdXQ/XG4gICAgICAgICAgICBpZiAobW9kZVN0YWNrLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYm90aCBhIFBPUF9NT0RFIGFuZCBhIFBVU0hfTU9ERSB0aGlzIGlzIGluLWZhY3QgYSBcInRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgIC8vIFNvIG5vIGVycm9yIHNob3VsZCBvY2N1ci5cbiAgICAgICAgICAgICAgICBwb3BUb2tlbi50b2tlblR5cGUuUFVTSF9NT0RFID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSB0cnkgdG8gcG9wIHRoZSBsYXN0IG1vZGUgdGhlcmUgbGV4ZXIgd2lsbCBubyBsb25nZXIgaGF2ZSBBTlkgbW9kZS5cbiAgICAgICAgICAgICAgICAvLyB0aHVzIHRoZSBwb3AgaXMgaWdub3JlZCwgYW4gZXJyb3Igd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgbGV4ZXIgd2lsbCBjb250aW51ZSBwYXJzaW5nIGluIHRoZSBwcmV2aW91cyBtb2RlLlxuICAgICAgICAgICAgICAgIHZhciBtc2dfMSA9IF90aGlzLmNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZShwb3BUb2tlbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvcFRva2VuLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBwb3BUb2tlbi5zdGFydExpbmUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwb3BUb2tlbi5zdGFydExpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHBvcFRva2VuLnN0YXJ0Q29sdW1uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcG9wVG9rZW4uc3RhcnRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHBvcFRva2VuLmltYWdlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnXzFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TW9kZSA9IGxhc3QobW9kZVN0YWNrKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSBfdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICAgICAgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZUNhbkJlT3B0aW1pemVkID0gX3RoaXMuY2FuTW9kZUJlT3B0aW1pemVkW25ld01vZGVdICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpZy5zYWZlTW9kZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnICYmIG1vZGVDYW5CZU9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc09wdGltaXplZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zU2xvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHB1c2hfbW9kZShuZXdNb2RlKSB7XG4gICAgICAgICAgICBtb2RlU3RhY2sucHVzaChuZXdNb2RlKTtcbiAgICAgICAgICAgIGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gdGhpc1xuICAgICAgICAgICAgICAgIC5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG1vZGVDYW5CZU9wdGltaXplZCA9IHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkW25ld01vZGVdICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuc2FmZU1vZGUgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnICYmIG1vZGVDYW5CZU9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zT3B0aW1pemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNTbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgcGF0dGVybiBzZWVtcyB0byBhdm9pZCBhIFY4IGRlLW9wdGltaXphdGlvbiwgYWx0aG91Z2ggdGhhdCBkZS1vcHRpbWl6YXRpb24gZG9lcyBub3RcbiAgICAgICAgLy8gc2VlbSB0byBtYXR0ZXIgcGVyZm9ybWFuY2Ugd2lzZS5cbiAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgaW5pdGlhbE1vZGUpO1xuICAgICAgICB2YXIgY3VyckNvbmZpZztcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG9yZ0xlbmd0aCkge1xuICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhckNvZGUgPSBvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIHZhciBjaG9zZW5QYXR0ZXJuSWR4VG9Db25maWcgPSBnZXRQb3NzaWJsZVBhdHRlcm5zKG5leHRDaGFyQ29kZSk7XG4gICAgICAgICAgICB2YXIgY2hvc2VuUGF0dGVybnNMZW5ndGggPSBjaG9zZW5QYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNob3NlblBhdHRlcm5zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyQ29uZmlnID0gY2hvc2VuUGF0dGVybklkeFRvQ29uZmlnW2ldO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0dGVybiA9IGN1cnJDb25maWcucGF0dGVybjtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZUNoYXJDb2RlID0gY3VyckNvbmZpZy5zaG9ydDtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlQ2hhckNvZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhckNvZGUgPT09IHNpbmdsZUNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gY3VyclBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyckNvbmZpZy5pc0N1c3RvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGN1cnJQYXR0ZXJuLmV4ZWMob3JnVGV4dCwgb2Zmc2V0LCBtYXRjaGVkVG9rZW5zLCBncm91cHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBtYXRjaC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXgoY3VyclBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IHRoaXMubWF0Y2goY3VyclBhdHRlcm4sIHRleHQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkSW1hZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhpcyBwYXR0ZXJuIG1hdGNoZWQgd2UgbXVzdCB0cnkgYSBhbm90aGVyIGxvbmdlciBhbHRlcm5hdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gYmUgdXNlZCB0byBwcmlvcml0aXplIGtleXdvcmRzIG92ZXIgaWRlbnRpZmllcnNcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VyQWx0SWR4ID0gY3VyckNvbmZpZy5sb25nZXJBbHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb25nZXJBbHRJZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbWljcm8gb3B0aW1pemUsIGF2b2lkIGV4dHJhIHByb3AgYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBzYXZpbmcvbGlua2luZyBsb25nZXJBbHQgb24gdGhlIG9yaWdpbmFsIGNvbmZpZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb25nZXJBbHRDb25maWcgPSBwYXR0ZXJuSWR4VG9Db25maWdbbG9uZ2VyQWx0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb25nZXJBbHRQYXR0ZXJuID0gbG9uZ2VyQWx0Q29uZmlnLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRQYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBDaGFyIGNhbiBuZXZlciBiZSBhIGxvbmdlciBhbHQgc28gbm8gbmVlZCB0byB0ZXN0IGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdlckFsdENvbmZpZy5pc0N1c3RvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbG9uZ2VyQWx0UGF0dGVybi5leGVjKG9yZ1RleHQsIG9mZnNldCwgbWF0Y2hlZFRva2VucywgZ3JvdXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRQYXlsb2FkID0gbWF0Y2gucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXgobG9uZ2VyQWx0UGF0dGVybiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFsdEltYWdlID0gdGhpcy5tYXRjaChsb25nZXJBbHRQYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoQWx0SW1hZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFsdEltYWdlLmxlbmd0aCA+IG1hdGNoZWRJbWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBtYXRjaEFsdEltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBhbHRQYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJDb25maWcgPSBsb25nZXJBbHRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoZWRJbWFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltYWdlTGVuZ3RoID0gbWF0Y2hlZEltYWdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBncm91cCA9IGN1cnJDb25maWcuZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rVHlwZSA9IGN1cnJDb25maWcudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBcIm9mZnNldCArIGltYWdlTGVuZ3RoXCIgYW5kIHRoZSBuZXcgY29sdW1uIG1heSBiZSBjb21wdXRlZCB0d2ljZSBpbiBjYXNlIG9mIFwiZnVsbFwiIGxvY2F0aW9uIGluZm9ybWF0aW9uIGluc2lkZVxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVGdWxsVG9rZW4gbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIG5ld1Rva2VuID0gdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlKG1hdGNoZWRJbWFnZSwgb2Zmc2V0LCB0b2tUeXBlLCBjdXJyQ29uZmlnLnRva2VuVHlwZSwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGF5bG9hZChuZXdUb2tlbiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIE5PT1AgaW4gY2FzZSB0aGVyZSBhcmUgbm8gc3BlY2lhbCBncm91cHM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRUb2tlbnNJbmRleCA9IHRoaXMuYWRkVG9rZW4obWF0Y2hlZFRva2VucywgbWF0Y2hlZFRva2Vuc0luZGV4LCBuZXdUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBdLnB1c2gobmV3VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmNob3BJbnB1dCh0ZXh0LCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgaW1hZ2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2l0aCBuZXdsaW5lcyB0aGUgY29sdW1uIG1heSBiZSBhc3NpZ25lZCB0d2ljZVxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuY29tcHV0ZU5ld0NvbHVtbihjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tMaW5lcyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyQ29uZmlnLmNhbkxpbmVUZXJtaW5hdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1PZkxUc0luTWF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRUZXJtaW5hdG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdExURW5kT2Zmc2V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvclBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRUZXJtaW5hdG9yID0gbGluZVRlcm1pbmF0b3JQYXR0ZXJuLnRlc3QobWF0Y2hlZEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFRlcm1pbmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TFRFbmRPZmZzZXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvclBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1PZkxUc0luTWF0Y2grKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZm91bmRUZXJtaW5hdG9yID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bU9mTFRzSW5NYXRjaCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUgKyBudW1PZkxUc0luTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBpbWFnZUxlbmd0aCAtIGxhc3RMVEVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24obmV3VG9rZW4sIGdyb3VwLCBsYXN0TFRFbmRPZmZzZXQsIG51bU9mTFRzSW5NYXRjaCwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBOT09QIGlmIG5vIG1vZGVzIHByZXNlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vZGVzKGN1cnJDb25maWcsIHBvcF9tb2RlLCBwdXNoX21vZGUsIG5ld1Rva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIHJlY292ZXJ5LCBkcm9wIGNoYXJhY3RlcnMgdW50aWwgd2UgaWRlbnRpZnkgYSB2YWxpZCB0b2tlbidzIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yU3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yQ29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZFJlc3luY1BvaW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFmb3VuZFJlc3luY1BvaW50ICYmIG9mZnNldCA8IG9yZ0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIGNoYXJzIHVudGlsIHdlIHN1Y2NlZWQgaW4gbWF0Y2hpbmcgc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGRyb3BwZWRDaGFyID0gb3JnVGV4dC5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElkZW50aXR5IEZ1bmMgKHdoZW4gc3RpY2t5IGZsYWcgaXMgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2hvcElucHV0KHRleHQsIDEpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJNb2RlUGF0dGVybnNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJDb25maWdfMSA9IHBhdHRlcm5JZHhUb0NvbmZpZ1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyUGF0dGVybiA9IGN1cnJDb25maWdfMS5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbmdsZUNoYXJDb2RlID0gY3VyckNvbmZpZ18xLnNob3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZUNoYXJDb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PT0gc2luZ2xlQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyckNvbmZpZ18xLmlzQ3VzdG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJQYXR0ZXJuLmV4ZWMob3JnVGV4dCwgb2Zmc2V0LCBtYXRjaGVkVG9rZW5zLCBncm91cHMpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXgoY3VyclBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9IGN1cnJQYXR0ZXJuLmV4ZWModGV4dCkgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRSZXN5bmNQb2ludCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVyckxlbmd0aCA9IG9mZnNldCAtIGVycm9yU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBlaXRoZXIgcmUtc3luY2VkIG9yIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgdGV4dFxuICAgICAgICAgICAgICAgIG1zZyA9IHRoaXMuY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlKG9yZ1RleHQsIGVycm9yU3RhcnRPZmZzZXQsIGVyckxlbmd0aCwgZXJyb3JMaW5lLCBlcnJvckNvbHVtbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGVycm9yU3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVycm9yTGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlcnJvckNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBlcnJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRvIGhhdmUgY3VzdG9tIHBhdHRlcm5zIHdoaWNoIHB1c2ggZGlyZWN0bHkgaW50byB0aGVcbiAgICAgICAgLy8gVE9ETzogY3VzdG9tIHRva2VucyBzaG91bGQgbm90IHB1c2ggZGlyZWN0bHk/P1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ3VzdG9tKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBndWVzc2VkIGEgdG9vIGxhcmdlIHNpemUgZm9yIHRoZSB0b2tlbnMgYXJyYXkgdGhpcyB3aWxsIHNocmluayBpdCB0byB0aGUgcmlnaHQgc2l6ZS5cbiAgICAgICAgICAgIG1hdGNoZWRUb2tlbnMubGVuZ3RoID0gbWF0Y2hlZFRva2Vuc0luZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IG1hdGNoZWRUb2tlbnMsXG4gICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlTW9kZXMgPSBmdW5jdGlvbiAoY29uZmlnLCBwb3BfbW9kZSwgcHVzaF9tb2RlLCBuZXdUb2tlbikge1xuICAgICAgICBpZiAoY29uZmlnLnBvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byBzYXZlIHRoZSBQVVNIX01PREUgcHJvcGVydHkgYXMgaWYgdGhlIG1vZGUgaXMgcG9wcGVkXG4gICAgICAgICAgICAvLyBwYXR0ZXJuSWR4VG9Qb3BNb2RlIGlzIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGUgbmV3IG1vZGUgYWZ0ZXIgcG9wcGluZyB0aGUgc3RhY2tcbiAgICAgICAgICAgIHZhciBwdXNoTW9kZSA9IGNvbmZpZy5wdXNoO1xuICAgICAgICAgICAgcG9wX21vZGUobmV3VG9rZW4pO1xuICAgICAgICAgICAgaWYgKHB1c2hNb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBwdXNoTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLnB1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgY29uZmlnLnB1c2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuY2hvcElucHV0ID0gZnVuY3Rpb24gKHRleHQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcobGVuZ3RoKTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS51cGRhdGVMYXN0SW5kZXggPSBmdW5jdGlvbiAocmVnRXhwLCBuZXdMYXN0SW5kZXgpIHtcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IG5ld0xhc3RJbmRleDtcbiAgICB9O1xuICAgIC8vIFRPRE86IGRlY3JlYXNlIHRoaXMgdW5kZXIgNjAwIGNoYXJhY3RlcnM/IGluc3BlY3Qgc3RyaXBwaW5nIGNvbW1lbnRzIG9wdGlvbiBpbiBUU0MgY29tcGlsZXJcbiAgICBMZXhlci5wcm90b3R5cGUudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24gPSBmdW5jdGlvbiAobmV3VG9rZW4sIGdyb3VwLCBsYXN0TFRJZHgsIG51bU9mTFRzSW5NYXRjaCwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICB2YXIgbGFzdENoYXJJc0xULCBmaXhGb3JFbmRpbmdJbkxUO1xuICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYSBub25lIHNraXBwZWQgbXVsdGkgbGluZSBUb2tlbiwgbmVlZCB0byB1cGRhdGUgZW5kTGluZS9lbmRDb2x1bW5cbiAgICAgICAgICAgIGxhc3RDaGFySXNMVCA9IGxhc3RMVElkeCA9PT0gaW1hZ2VMZW5ndGggLSAxO1xuICAgICAgICAgICAgZml4Rm9yRW5kaW5nSW5MVCA9IGxhc3RDaGFySXNMVCA/IC0xIDogMDtcbiAgICAgICAgICAgIGlmICghKG51bU9mTFRzSW5NYXRjaCA9PT0gMSAmJiBsYXN0Q2hhcklzTFQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSB0b2tlbiBlbmRzIGluIGEgTFQgdGhhdCBsYXN0IExUIG9ubHkgYWZmZWN0cyB0aGUgbGluZSBudW1iZXJpbmcgb2YgZm9sbG93aW5nIFRva2Vuc1xuICAgICAgICAgICAgICAgIG5ld1Rva2VuLmVuZExpbmUgPSBsaW5lICsgZml4Rm9yRW5kaW5nSW5MVDtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBMVCBpbiBhIHRva2VuIGRvZXMgbm90IGFmZmVjdCB0aGUgZW5kQ29sdW1uIGVpdGhlciBhcyB0aGUgW2NvbHVtblN0YXJ0IC4uLiBjb2x1bW5FbmQpXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVzaXZlIHRvIGV4Y2x1c2l2ZSByYW5nZS5cbiAgICAgICAgICAgICAgICBuZXdUb2tlbi5lbmRDb2x1bW4gPSBjb2x1bW4gLSAxICsgLWZpeEZvckVuZGluZ0luTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHNpbmdsZSBMVCBpbiB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB0b2tlbiwgbm8gbmVlZCB0byBtb2RpZnkgdGhlIGVuZExpbmUvRW5kQ29sdW1uXG4gICAgICAgIH1cbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jb21wdXRlTmV3Q29sdW1uID0gZnVuY3Rpb24gKG9sZENvbHVtbiwgaW1hZ2VMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9sZENvbHVtbiArIGltYWdlTGVuZ3RoO1xuICAgIH07XG4gICAgLy8gUGxhY2UgaG9sZGVyLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjb3JyZWN0IHZhcmlhbnQgYWNjb3JkaW5nIHRvIHRoZSBsb2NhdGlvblRyYWNraW5nIG9wdGlvbiBhdCBydW50aW1lLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gcGxhY2UgaG9sZGVyICovXG4gICAgTGV4ZXIucHJvdG90eXBlLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuY3JlYXRlT2Zmc2V0T25seVRva2VuID0gZnVuY3Rpb24gKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeDogdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jcmVhdGVTdGFydE9ubHlUb2tlbiA9IGZ1bmN0aW9uIChpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydENvbHVtbixcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeDogdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0b2tlblR5cGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5jcmVhdGVGdWxsVG9rZW4gPSBmdW5jdGlvbiAoaW1hZ2UsIHN0YXJ0T2Zmc2V0LCB0b2tlblR5cGVJZHgsIHRva2VuVHlwZSwgc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgaW1hZ2VMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogc3RhcnRPZmZzZXQgKyBpbWFnZUxlbmd0aCAtIDEsXG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBzdGFydENvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogc3RhcnRDb2x1bW4gKyBpbWFnZUxlbmd0aCAtIDEsXG4gICAgICAgICAgICB0b2tlblR5cGVJZHg6IHRva2VuVHlwZUlkeCxcbiAgICAgICAgICAgIHRva2VuVHlwZTogdG9rZW5UeXBlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBQbGFjZSBob2xkZXIsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvcnJlY3QgdmFyaWFudCBhY2NvcmRpbmcgdG8gdGhlIGxvY2F0aW9uVHJhY2tpbmcgb3B0aW9uIGF0IHJ1bnRpbWUuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBwbGFjZSBob2xkZXIgKi9cbiAgICBMZXhlci5wcm90b3R5cGUuYWRkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHJldHVybiA2NjY7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuYWRkVG9rZW5Vc2luZ1B1c2ggPSBmdW5jdGlvbiAodG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHRva2VuVmVjdG9yLnB1c2godG9rZW5Ub0FkZCk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzID0gZnVuY3Rpb24gKHRva2VuVmVjdG9yLCBpbmRleCwgdG9rZW5Ub0FkZCkge1xuICAgICAgICB0b2tlblZlY3RvcltpbmRleF0gPSB0b2tlblRvQWRkO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICAvLyBQbGFjZSBob2xkZXIsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvcnJlY3QgdmFyaWFudCBhY2NvcmRpbmcgdG8gdGhlIGhhc0N1c3RvbSBmbGFnIG9wdGlvbiBhdCBydW50aW1lLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gcGxhY2UgaG9sZGVyICovXG4gICAgTGV4ZXIucHJvdG90eXBlLmhhbmRsZVBheWxvYWQgPSBmdW5jdGlvbiAodG9rZW4sIHBheWxvYWQpIHsgfTtcbiAgICBMZXhlci5wcm90b3R5cGUuaGFuZGxlUGF5bG9hZE5vQ3VzdG9tID0gZnVuY3Rpb24gKHRva2VuLCBwYXlsb2FkKSB7IH07XG4gICAgTGV4ZXIucHJvdG90eXBlLmhhbmRsZVBheWxvYWRXaXRoQ3VzdG9tID0gZnVuY3Rpb24gKHRva2VuLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbi5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBwbGFjZSBob2xkZXIgdG8gYmUgcmVwbGFjZWQgd2l0aCBjaG9zZW4gYWx0ZXJuYXRpdmUgYXQgcnVudGltZSAqL1xuICAgIExleGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMZXhlci5wcm90b3R5cGUubWF0Y2hXaXRoVGVzdCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gcGF0dGVybi50ZXN0KHRleHQpO1xuICAgICAgICBpZiAoZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhvZmZzZXQsIHBhdHRlcm4ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExleGVyLnByb3RvdHlwZS5tYXRjaFdpdGhFeGVjID0gZnVuY3Rpb24gKHBhdHRlcm4sIHRleHQpIHtcbiAgICAgICAgdmFyIHJlZ0V4cEFycmF5ID0gcGF0dGVybi5leGVjKHRleHQpO1xuICAgICAgICByZXR1cm4gcmVnRXhwQXJyYXkgIT09IG51bGwgPyByZWdFeHBBcnJheVswXSA6IHJlZ0V4cEFycmF5O1xuICAgIH07XG4gICAgLy8gRHVwbGljYXRlZCBmcm9tIHRoZSBwYXJzZXIncyBwZXJmIHRyYWNlIHRyYWl0IHRvIGFsbG93IGZ1dHVyZSBleHRyYWN0aW9uXG4gICAgLy8gb2YgdGhlIGxleGVyIHRvIGEgc2VwYXJhdGUgcGFja2FnZS5cbiAgICBMZXhlci5wcm90b3R5cGUuVFJBQ0VfSU5JVCA9IGZ1bmN0aW9uIChwaGFzZURlc2MsIHBoYXNlSW1wbCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIG9wdGltaXplIHRoaXMgdXNpbmcgTk9PUCBwYXR0ZXJuIGJlY2F1c2VcbiAgICAgICAgLy8gSXQgaXMgbm90IGNhbGxlZCBpbiBhIGhvdCBzcG90Li4uXG4gICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdFBlcmYgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50Kys7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gbmV3IEFycmF5KHRoaXMudHJhY2VJbml0SW5kZW50ICsgMSkuam9pbihcIlxcdFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQgKyBcIi0tPiA8XCIgKyBwaGFzZURlc2MgKyBcIj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2EgPSB0aW1lcihwaGFzZUltcGwpLCB0aW1lID0gX2EudGltZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gRGlmZmljdWx0IHRvIHJlcHJvZHVjZSBzcGVjaWZpYyBwZXJmb3JtYW5jZSBiZWhhdmlvciAoPjEwbXMpIGluIHRlc3RzICovXG4gICAgICAgICAgICB2YXIgdHJhY2VNZXRob2QgPSB0aW1lID4gMTAgPyBjb25zb2xlLndhcm4gOiBjb25zb2xlLmxvZztcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICB0cmFjZU1ldGhvZChpbmRlbnQgKyBcIjwtLSA8XCIgKyBwaGFzZURlc2MgKyBcIj4gdGltZTogXCIgKyB0aW1lICsgXCJtc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50LS07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGhhc2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExleGVyLlNLSVBQRUQgPSBcIlRoaXMgbWFya3MgYSBza2lwcGVkIFRva2VuIHBhdHRlcm4sIHRoaXMgbWVhbnMgZWFjaCB0b2tlbiBpZGVudGlmaWVkIGJ5IGl0IHdpbGxcIiArXG4gICAgICAgIFwiYmUgY29uc3VtZWQgYW5kIHRoZW4gdGhyb3duIGludG8gb2JsaXZpb24sIHRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yIGV4YW1wbGUgdG8gY29tcGxldGVseSBpZ25vcmUgd2hpdGVzcGFjZS5cIjtcbiAgICBMZXhlci5OQSA9IC9OT1RfQVBQTElDQUJMRS87XG4gICAgcmV0dXJuIExleGVyO1xufSgpKTtcbmV4cG9ydCB7IExleGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9wdWJsaWMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js":
/*!*************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js ***!
  \*************************************************************/
/*! exports provided: failedOptimizationPrefixMsg, getOptimizedStartCodesIndices, firstCharOptimizedIndices, canMatchCharCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"failedOptimizationPrefixMsg\", function() { return failedOptimizationPrefixMsg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOptimizedStartCodesIndices\", function() { return getOptimizedStartCodesIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstCharOptimizedIndices\", function() { return firstCharOptimizedIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canMatchCharCode\", function() { return canMatchCharCode; });\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regexp-to-ast */ \"./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reg_exp_parser */ \"./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\");\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lexer */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer.js\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nvar failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\n    try {\n        var ast = Object(_reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__[\"getRegExpAst\"])(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"PRINT_WARNING\"])(\"\" + failedOptimizationPrefixMsg +\n                    (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            var msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"PRINT_ERROR\"])(failedOptimizationPrefixMsg + \"\\n\" +\n                (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") +\n                (\"\\tUsing the regexp-to-ast library version: \" + regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"] + \"\\n\") +\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (var i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            var terms = ast.value;\n            for (var i = 0; i < terms.length; i++) {\n                var term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                var atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(atom.value, function (code) {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                var range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (var rangeCode = range.from; rangeCode <= range.to &&\n                                        rangeCode < _lexer__WEBPACK_IMPORTED_MODULE_3__[\"minOptimizationVal\"]; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= _lexer__WEBPACK_IMPORTED_MODULE_3__[\"minOptimizationVal\"]) {\n                                        var minUnOptVal = range.from >= _lexer__WEBPACK_IMPORTED_MODULE_3__[\"minOptimizationVal\"]\n                                            ? range.from\n                                            : _lexer__WEBPACK_IMPORTED_MODULE_3__[\"minOptimizationVal\"];\n                                        var maxUnOptVal = range.to;\n                                        var minOptIdx = Object(_lexer__WEBPACK_IMPORTED_MODULE_3__[\"charCodeToOptimizedIndex\"])(minUnOptVal);\n                                        var maxOptIdx = Object(_lexer__WEBPACK_IMPORTED_MODULE_3__[\"charCodeToOptimizedIndex\"])(maxUnOptVal);\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                var isOptionalQuantifier = atom.quantifier !== undefined &&\n                    atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" &&\n                    isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"values\"])(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    var optimizedCharIdx = Object(_lexer__WEBPACK_IMPORTED_MODULE_3__[\"charCodeToOptimizedIndex\"])(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    var char = String.fromCharCode(code);\n    var upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        var optimizedCharIdx = Object(_lexer__WEBPACK_IMPORTED_MODULE_3__[\"charCodeToOptimizedIndex\"])(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            var optimizedCharIdx = Object(_lexer__WEBPACK_IMPORTED_MODULE_3__[\"charCodeToOptimizedIndex\"])(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"find\"])(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"contains\"])(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            var range_1 = codeOrRange;\n            return (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"find\"])(targetCharCodes, function (targetCode) {\n                return range_1.from <= targetCode && targetCode <= range_1.to;\n            }) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"isArray\"])(ast.value)\n        ? Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"every\"])(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */ (function (_super) {\n    __extends(CharCodeFinder, _super);\n    function CharCodeFinder(targetCharCodes) {\n        var _this = _super.call(this) || this;\n        _this.targetCharCodes = targetCharCodes;\n        _this.found = false;\n        return _this;\n    }\n    CharCodeFinder.prototype.visitChildren = function (node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        _super.prototype.visitChildren.call(this, node);\n    };\n    CharCodeFinder.prototype.visitCharacter = function (node) {\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"contains\"])(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    };\n    CharCodeFinder.prototype.visitSet = function (node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    };\n    return CharCodeFinder;\n}(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__[\"BaseRegExpVisitor\"]));\nfunction canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        var ast = Object(_reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__[\"getRegExpAst\"])(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"find\"])(pattern, function (char) {\n            return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_1__[\"contains\"])(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3JlZ19leHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3JlZ19leHAuanM/YWRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IFZFUlNJT04sIEJhc2VSZWdFeHBWaXNpdG9yIH0gZnJvbSBcInJlZ2V4cC10by1hc3RcIjtcbmltcG9ydCB7IGZvckVhY2gsIGNvbnRhaW5zLCBQUklOVF9FUlJPUiwgUFJJTlRfV0FSTklORywgZmluZCwgaXNBcnJheSwgZXZlcnksIHZhbHVlcyB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0UmVnRXhwQXN0IH0gZnJvbSBcIi4vcmVnX2V4cF9wYXJzZXJcIjtcbmltcG9ydCB7IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCwgbWluT3B0aW1pemF0aW9uVmFsIH0gZnJvbSBcIi4vbGV4ZXJcIjtcbnZhciBjb21wbGVtZW50RXJyb3JNZXNzYWdlID0gXCJDb21wbGVtZW50IFNldHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9uXCI7XG5leHBvcnQgdmFyIGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyA9ICdVbmFibGUgdG8gdXNlIFwiZmlyc3QgY2hhclwiIGxleGVyIG9wdGltaXphdGlvbnM6XFxuJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyhyZWdFeHAsIGVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucyA9PT0gdm9pZCAwKSB7IGVuc3VyZU9wdGltaXphdGlvbnMgPSBmYWxzZTsgfVxuICAgIHRyeSB7XG4gICAgICAgIHZhciBhc3QgPSBnZXRSZWdFeHBBc3QocmVnRXhwKTtcbiAgICAgICAgdmFyIGZpcnN0Q2hhcnMgPSBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGFzdC52YWx1ZSwge30sIGFzdC5mbGFncy5pZ25vcmVDYXNlKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2hhcnM7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIC8vIFRlc3RpbmcgdGhpcyByZWxpZXMgb24gdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeSBoYXZpbmcgYSBidWcuLi4gKi9cbiAgICAgICAgLy8gVE9ETzogb25seSB0aGUgZWxzZSBicmFuY2ggbmVlZHMgdG8gYmUgaWdub3JlZCwgdHJ5IHRvIGZpeCB3aXRoIG5ld2VyIHByZXR0aWVyIC8gdHNjXG4gICAgICAgIGlmIChlLm1lc3NhZ2UgPT09IGNvbXBsZW1lbnRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChlbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgUFJJTlRfV0FSTklORyhcIlwiICsgZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnICtcbiAgICAgICAgICAgICAgICAgICAgKFwiXFx0VW5hYmxlIHRvIG9wdGltaXplOiA8IFwiICsgcmVnRXhwLnRvU3RyaW5nKCkgKyBcIiA+XFxuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRDb21wbGVtZW50IFNldHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ09NUExFTUVOVCBmb3IgZGV0YWlscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXNnU3VmZml4ID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChlbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgbXNnU3VmZml4ID1cbiAgICAgICAgICAgICAgICAgICAgXCJcXG5cXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1JFR0VYUF9QQVJTSU5HIGZvciBkZXRhaWxzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUFJJTlRfRVJST1IoZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnICsgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgKFwiXFx0RmFpbGVkIHBhcnNpbmc6IDwgXCIgKyByZWdFeHAudG9TdHJpbmcoKSArIFwiID5cXG5cIikgK1xuICAgICAgICAgICAgICAgIChcIlxcdFVzaW5nIHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkgdmVyc2lvbjogXCIgKyBWRVJTSU9OICsgXCJcXG5cIikgK1xuICAgICAgICAgICAgICAgIFwiXFx0UGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZDgyL3JlZ2V4cC10by1hc3QvaXNzdWVzXCIgK1xuICAgICAgICAgICAgICAgIG1zZ1N1ZmZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXN0LCByZXN1bHQsIGlnbm9yZUNhc2UpIHtcbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJEaXNqdW5jdGlvblwiOlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3QudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGFzdC52YWx1ZVtpXSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQWx0ZXJuYXRpdmVcIjpcbiAgICAgICAgICAgIHZhciB0ZXJtcyA9IGFzdC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVybSA9IHRlcm1zW2ldO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdGVybXMgdGhhdCBjYW5ub3QgZWZmZWN0IHRoZSBmaXJzdCBjaGFyIHJlc3VsdHNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRlcm0udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRW5kQW5jaG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgZ3JvdXAgYmFjayByZWZlcmVuY2UgY2Fubm90IGFmZmVjdCBwb3RlbnRpYWwgc3RhcnRpbmcgY2hhci5cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpZiBhIGJhY2sgcmVmZXJlbmNlIGlzIHRoZSBmaXJzdCBwcm9kdWN0aW9uIHRoYW4gYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZ3JvdXAgYmVpbmcgcmVmZXJlbmNlZCBoYXMgaGFkIHRvIGNvbWUgQkVGT1JFIHNvIGl0cyBjb2RlcyBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBCYWNrUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2VydGlvbnMgZG8gbm90IGFmZmVjdCBwb3RlbnRpYWwgc3RhcnRpbmcgY29kZXNcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTmVnYXRpdmVMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlN0YXJ0QW5jaG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJXb3JkQm91bmRhcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk5vbldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhdG9tID0gdGVybTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0b20udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQ2hhcmFjdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChhdG9tLnZhbHVlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdG9tLmNvbXBsZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihjb21wbGVtZW50RXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2goYXRvbS52YWx1ZSwgZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoY29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbm5vdCBvcHRpbWl6ZSB3aGVuIGlnbm9yZUNhc2UgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUNhc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJhbmdlQ29kZSA9IHJhbmdlLmZyb207IHJhbmdlQ29kZSA8PSByYW5nZS50bzsgcmFuZ2VDb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChyYW5nZUNvZGUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uICgyIG9yZGVycyBvZiBtYWduaXR1ZGUgbGVzcyB3b3JrIGZvciB2ZXJ5IGxhcmdlIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdW5vcHRpbWl6ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByYW5nZUNvZGUgPSByYW5nZS5mcm9tOyByYW5nZUNvZGUgPD0gcmFuZ2UudG8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZUNvZGUgPCBtaW5PcHRpbWl6YXRpb25WYWw7IHJhbmdlQ29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQocmFuZ2VDb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVzcyBjb21tb24gY2hhckNvZGUgd2hlcmUgd2Ugb3B0aW1pemUgZm9yIGZhc3RlciBpbml0IHRpbWUsIGJ5IHVzaW5nIGxhcmdlciBcImJ1Y2tldHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvID49IG1pbk9wdGltaXphdGlvblZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5Vbk9wdFZhbCA9IHJhbmdlLmZyb20gPj0gbWluT3B0aW1pemF0aW9uVmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmFuZ2UuZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1pbk9wdGltaXphdGlvblZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VW5PcHRWYWwgPSByYW5nZS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluT3B0SWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KG1pblVuT3B0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4T3B0SWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KG1heFVuT3B0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjdXJyT3B0SWR4ID0gbWluT3B0SWR4OyBjdXJyT3B0SWR4IDw9IG1heE9wdElkeDsgY3Vyck9wdElkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyT3B0SWR4XSA9IGN1cnJPcHRJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGF0b20udmFsdWUsIHJlc3VsdCwgaWdub3JlQ2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm9uIEV4aGF1c3RpdmUgTWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgYSBtYW5kYXRvcnkgcHJvZHVjdGlvbiwgbm8gbW9yZSAqKnN0YXJ0KiogY29kZXMgY2FuIGJlIGZvdW5kIG9uIHRoaXMgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICB2YXIgaXNPcHRpb25hbFF1YW50aWZpZXIgPSBhdG9tLnF1YW50aWZpZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBhdG9tLnF1YW50aWZpZXIuYXRMZWFzdCA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gQSBncm91cCBtYXkgYmUgb3B0aW9uYWwgZHVlIHRvIGVtcHR5IGNvbnRlbnRzIC8oPzopL1xuICAgICAgICAgICAgICAgIC8vIG9yIGlmIGV2ZXJ5dGhpbmcgaW5zaWRlIGl0IGlzIG9wdGlvbmFsIC8oKGEpPykvXG4gICAgICAgICAgICAgICAgKGF0b20udHlwZSA9PT0gXCJHcm91cFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGlzV2hvbGVPcHRpb25hbChhdG9tKSA9PT0gZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgdGVybSBpcyBub3QgYSBncm91cCBpdCBtYXkgb25seSBiZSBvcHRpb25hbCBpZiBpdCBoYXMgYW4gb3B0aW9uYWwgcXVhbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAoYXRvbS50eXBlICE9PSBcIkdyb3VwXCIgJiYgaXNPcHRpb25hbFF1YW50aWZpZXIgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2ghXCIpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aClcbiAgICByZXR1cm4gdmFsdWVzKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChjb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpIHtcbiAgICB2YXIgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjb2RlKTtcbiAgICByZXN1bHRbb3B0aW1pemVkQ2hhcklkeF0gPSBvcHRpbWl6ZWRDaGFySWR4O1xuICAgIGlmIChpZ25vcmVDYXNlID09PSB0cnVlKSB7XG4gICAgICAgIGhhbmRsZUlnbm9yZUNhc2UoY29kZSwgcmVzdWx0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVJZ25vcmVDYXNlKGNvZGUsIHJlc3VsdCkge1xuICAgIHZhciBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB2YXIgdXBwZXJDaGFyID0gY2hhci50b1VwcGVyQ2FzZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHVwcGVyQ2hhciAhPT0gY2hhcikge1xuICAgICAgICB2YXIgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCh1cHBlckNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbG93ZXJDaGFyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJDaGFyICE9PSBjaGFyKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChsb3dlckNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICByZXN1bHRbb3B0aW1pemVkQ2hhcklkeF0gPSBvcHRpbWl6ZWRDaGFySWR4O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENvZGUoc2V0Tm9kZSwgdGFyZ2V0Q2hhckNvZGVzKSB7XG4gICAgcmV0dXJuIGZpbmQoc2V0Tm9kZS52YWx1ZSwgZnVuY3Rpb24gKGNvZGVPclJhbmdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZU9yUmFuZ2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyh0YXJnZXRDaGFyQ29kZXMsIGNvZGVPclJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB2YXIgcmFuZ2VfMSA9IGNvZGVPclJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuIChmaW5kKHRhcmdldENoYXJDb2RlcywgZnVuY3Rpb24gKHRhcmdldENvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VfMS5mcm9tIDw9IHRhcmdldENvZGUgJiYgdGFyZ2V0Q29kZSA8PSByYW5nZV8xLnRvO1xuICAgICAgICAgICAgfSkgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzV2hvbGVPcHRpb25hbChhc3QpIHtcbiAgICBpZiAoYXN0LnF1YW50aWZpZXIgJiYgYXN0LnF1YW50aWZpZXIuYXRMZWFzdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhc3QudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheShhc3QudmFsdWUpXG4gICAgICAgID8gZXZlcnkoYXN0LnZhbHVlLCBpc1dob2xlT3B0aW9uYWwpXG4gICAgICAgIDogaXNXaG9sZU9wdGlvbmFsKGFzdC52YWx1ZSk7XG59XG52YXIgQ2hhckNvZGVGaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENoYXJDb2RlRmluZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYXJDb2RlRmluZGVyKHRhcmdldENoYXJDb2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXRDaGFyQ29kZXMgPSB0YXJnZXRDaGFyQ29kZXM7XG4gICAgICAgIF90aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2hhckNvZGVGaW5kZXIucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGtlZXAgbG9va2luZy4uLlxuICAgICAgICBpZiAodGhpcy5mb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCBsb29rYWhlYWRzIGFzIHRoZXkgZG8gbm90IGFjdHVhbGx5IGNvbnN1bWUgYW55IGNoYXJhY3RlcnMgdGh1c1xuICAgICAgICAvLyBmaW5kaW5nIGEgY2hhckNvZGUgYXQgbG9va2FoZWFkIGNvbnRleHQgZG9lcyBub3QgbWVhbiB0aGF0IHJlZ2V4cCBjYW4gYWN0dWFsbHkgY29udGFpbiBpdCBpbiBhIG1hdGNoLlxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRMb29rYWhlYWQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdE5lZ2F0aXZlTG9va2FoZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4uY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuICAgIENoYXJDb2RlRmluZGVyLnByb3RvdHlwZS52aXNpdENoYXJhY3RlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChjb250YWlucyh0aGlzLnRhcmdldENoYXJDb2Rlcywgbm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFyQ29kZUZpbmRlci5wcm90b3R5cGUudmlzaXRTZXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jb21wbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZmluZENvZGUobm9kZSwgdGhpcy50YXJnZXRDaGFyQ29kZXMpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaW5kQ29kZShub2RlLCB0aGlzLnRhcmdldENoYXJDb2RlcykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhckNvZGVGaW5kZXI7XG59KEJhc2VSZWdFeHBWaXNpdG9yKSk7XG5leHBvcnQgZnVuY3Rpb24gY2FuTWF0Y2hDaGFyQ29kZShjaGFyQ29kZXMsIHBhdHRlcm4pIHtcbiAgICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICB2YXIgYXN0ID0gZ2V0UmVnRXhwQXN0KHBhdHRlcm4pO1xuICAgICAgICB2YXIgY2hhckNvZGVGaW5kZXIgPSBuZXcgQ2hhckNvZGVGaW5kZXIoY2hhckNvZGVzKTtcbiAgICAgICAgY2hhckNvZGVGaW5kZXIudmlzaXQoYXN0KTtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlRmluZGVyLmZvdW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChmaW5kKHBhdHRlcm4sIGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnMoY2hhckNvZGVzLCBjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICB9KSAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdfZXhwLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/reg_exp.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js ***!
  \********************************************************************/
/*! exports provided: getRegExpAst, clearRegExpParserCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRegExpAst\", function() { return getRegExpAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearRegExpParserCache\", function() { return clearRegExpParserCache; });\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regexp-to-ast */ \"./node_modules/regexp-to-ast/lib/regexp-to-ast.js\");\n/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);\n\nvar regExpAstCache = {};\nvar regExpParser = new regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__[\"RegExpParser\"]();\nfunction getRegExpAst(regExp) {\n    var regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        var regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nfunction clearRegExpParserCache() {\n    regExpAstCache = {};\n}\n//# sourceMappingURL=reg_exp_parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3JlZ19leHBfcGFyc2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvc2Nhbi9yZWdfZXhwX3BhcnNlci5qcz8wNDc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZ0V4cFBhcnNlciB9IGZyb20gXCJyZWdleHAtdG8tYXN0XCI7XG52YXIgcmVnRXhwQXN0Q2FjaGUgPSB7fTtcbnZhciByZWdFeHBQYXJzZXIgPSBuZXcgUmVnRXhwUGFyc2VyKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVnRXhwQXN0KHJlZ0V4cCkge1xuICAgIHZhciByZWdFeHBTdHIgPSByZWdFeHAudG9TdHJpbmcoKTtcbiAgICBpZiAocmVnRXhwQXN0Q2FjaGUuaGFzT3duUHJvcGVydHkocmVnRXhwU3RyKSkge1xuICAgICAgICByZXR1cm4gcmVnRXhwQXN0Q2FjaGVbcmVnRXhwU3RyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZWdFeHBBc3QgPSByZWdFeHBQYXJzZXIucGF0dGVybihyZWdFeHBTdHIpO1xuICAgICAgICByZWdFeHBBc3RDYWNoZVtyZWdFeHBTdHJdID0gcmVnRXhwQXN0O1xuICAgICAgICByZXR1cm4gcmVnRXhwQXN0O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclJlZ0V4cFBhcnNlckNhY2hlKCkge1xuICAgIHJlZ0V4cEFzdENhY2hlID0ge307XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdfZXhwX3BhcnNlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/reg_exp_parser.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/tokens.js":
/*!************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/tokens.js ***!
  \************************************************************/
/*! exports provided: tokenStructuredMatcher, tokenStructuredMatcherNoCategories, tokenShortNameIdx, tokenIdxToClass, augmentTokenTypes, expandCategories, assignTokenDefaultProps, assignCategoriesTokensProp, assignCategoriesMapProp, singleAssignCategoriesToksMap, hasShortKeyProperty, hasCategoriesProperty, hasExtendingTokensTypesProperty, hasExtendingTokensTypesMapProperty, isTokenType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenStructuredMatcher\", function() { return tokenStructuredMatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenStructuredMatcherNoCategories\", function() { return tokenStructuredMatcherNoCategories; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenShortNameIdx\", function() { return tokenShortNameIdx; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenIdxToClass\", function() { return tokenIdxToClass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"augmentTokenTypes\", function() { return augmentTokenTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"expandCategories\", function() { return expandCategories; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assignTokenDefaultProps\", function() { return assignTokenDefaultProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assignCategoriesTokensProp\", function() { return assignCategoriesTokensProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assignCategoriesMapProp\", function() { return assignCategoriesMapProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"singleAssignCategoriesToksMap\", function() { return singleAssignCategoriesToksMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasShortKeyProperty\", function() { return hasShortKeyProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasCategoriesProperty\", function() { return hasCategoriesProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasExtendingTokensTypesProperty\", function() { return hasExtendingTokensTypesProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasExtendingTokensTypesMapProperty\", function() { return hasExtendingTokensTypesMapProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTokenType\", function() { return isTokenType; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nvar tokenShortNameIdx = 1;\nvar tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nfunction expandCategories(tokenTypes) {\n    var result = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"cloneArr\"])(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"compact\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"flatten\"])(Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"difference\"])(categories, result);\n        result = result.concat(newCategories);\n        if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isEmpty\"])(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nfunction assignTokenDefaultProps(tokenTypes) {\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isArray\"])(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nfunction assignCategoriesTokensProp(tokenTypes) {\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nfunction assignCategoriesMapProp(tokenTypes) {\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"forEach\"])(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"contains\"])(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nfunction hasShortKeyProperty(tokType) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(tokType, \"tokenTypeIdx\");\n}\nfunction hasCategoriesProperty(tokType) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(tokType, \"CATEGORIES\");\n}\nfunction hasExtendingTokensTypesProperty(tokType) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(tokType, \"categoryMatches\");\n}\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(tokType, \"categoryMatchesMap\");\n}\nfunction isTokenType(tokType) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3Rva2Vucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3NjYW4vdG9rZW5zLmpzPzViYTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVBcnIsIGNvbXBhY3QsIGNvbnRhaW5zLCBkaWZmZXJlbmNlLCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRW1wdHksIG1hcCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rSW5zdGFuY2UsIHRva0NvbnN0cnVjdG9yKSB7XG4gICAgdmFyIGluc3RhbmNlVHlwZSA9IHRva0luc3RhbmNlLnRva2VuVHlwZUlkeDtcbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSB0b2tDb25zdHJ1Y3Rvci50b2tlblR5cGVJZHgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRva0NvbnN0cnVjdG9yLmlzUGFyZW50ID09PSB0cnVlICYmXG4gICAgICAgICAgICB0b2tDb25zdHJ1Y3Rvci5jYXRlZ29yeU1hdGNoZXNNYXBbaW5zdGFuY2VUeXBlXSA9PT0gdHJ1ZSk7XG4gICAgfVxufVxuLy8gT3B0aW1pemVkIHRva2VuTWF0Y2hlciBpbiBjYXNlIG91ciBncmFtbWFyIGRvZXMgbm90IHVzZSB0b2tlbiBjYXRlZ29yaWVzXG4vLyBCZWluZyBzbyB0aW55IGl0IGlzIG11Y2ggbW9yZSBsaWtlbHkgdG8gYmUgaW4tbGluZWQgYW5kIHRoaXMgYXZvaWQgdGhlIGZ1bmN0aW9uIGNhbGwgb3ZlcmhlYWRcbmV4cG9ydCBmdW5jdGlvbiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzKHRva2VuLCB0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva2VuLnRva2VuVHlwZUlkeCA9PT0gdG9rVHlwZS50b2tlblR5cGVJZHg7XG59XG5leHBvcnQgdmFyIHRva2VuU2hvcnROYW1lSWR4ID0gMTtcbmV4cG9ydCB2YXIgdG9rZW5JZHhUb0NsYXNzID0ge307XG5leHBvcnQgZnVuY3Rpb24gYXVnbWVudFRva2VuVHlwZXModG9rZW5UeXBlcykge1xuICAgIC8vIGNvbGxlY3QgdGhlIHBhcmVudCBUb2tlbiBUeXBlcyBhcyB3ZWxsLlxuICAgIHZhciB0b2tlblR5cGVzQW5kUGFyZW50cyA9IGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcyk7XG4gICAgLy8gYWRkIHJlcXVpcmVkIHRva2VuVHlwZSBhbmQgY2F0ZWdvcnlNYXRjaGVzIHByb3BlcnRpZXNcbiAgICBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzQW5kUGFyZW50cyk7XG4gICAgLy8gZmlsbCB1cCB0aGUgY2F0ZWdvcnlNYXRjaGVzXG4gICAgYXNzaWduQ2F0ZWdvcmllc01hcFByb3AodG9rZW5UeXBlc0FuZFBhcmVudHMpO1xuICAgIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXNBbmRQYXJlbnRzKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXNBbmRQYXJlbnRzLCBmdW5jdGlvbiAodG9rVHlwZSkge1xuICAgICAgICB0b2tUeXBlLmlzUGFyZW50ID0gdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRDYXRlZ29yaWVzKHRva2VuVHlwZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVBcnIodG9rZW5UeXBlcyk7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSB0b2tlblR5cGVzO1xuICAgIHZhciBzZWFyY2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChzZWFyY2hpbmcpIHtcbiAgICAgICAgY2F0ZWdvcmllcyA9IGNvbXBhY3QoZmxhdHRlbihtYXAoY2F0ZWdvcmllcywgZnVuY3Rpb24gKGN1cnJUb2tUeXBlKSB7IHJldHVybiBjdXJyVG9rVHlwZS5DQVRFR09SSUVTOyB9KSkpO1xuICAgICAgICB2YXIgbmV3Q2F0ZWdvcmllcyA9IGRpZmZlcmVuY2UoY2F0ZWdvcmllcywgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChuZXdDYXRlZ29yaWVzKTtcbiAgICAgICAgaWYgKGlzRW1wdHkobmV3Q2F0ZWdvcmllcykpIHtcbiAgICAgICAgICAgIHNlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IG5ld0NhdGVnb3JpZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgaWYgKCFoYXNTaG9ydEtleVByb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgdG9rZW5JZHhUb0NsYXNzW3Rva2VuU2hvcnROYW1lSWR4XSA9IGN1cnJUb2tUeXBlO1xuICAgICAgICAgICAgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4ID0gdG9rZW5TaG9ydE5hbWVJZHgrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBDQVRFR09SSUVTPyA6IFRva2VuVHlwZSB8IFRva2VuVHlwZVtdXG4gICAgICAgIGlmIChoYXNDYXRlZ29yaWVzUHJvcGVydHkoY3VyclRva1R5cGUpICYmXG4gICAgICAgICAgICAhaXNBcnJheShjdXJyVG9rVHlwZS5DQVRFR09SSUVTKVxuICAgICAgICAvLyAmJlxuICAgICAgICAvLyAhaXNVbmRlZmluZWQoY3VyclRva1R5cGUuQ0FURUdPUklFUy5QQVRURVJOKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMgPSBbY3VyclRva1R5cGUuQ0FURUdPUklFU107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDYXRlZ29yaWVzUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5DQVRFR09SSUVTID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5KGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzTWFwID0ge307XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DYXRlZ29yaWVzVG9rZW5zUHJvcCh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRpb25zXG4gICAgICAgIGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcyA9IFtdO1xuICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlc01hcCwgZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMucHVzaCh0b2tlbklkeFRvQ2xhc3Nba2V5XS50b2tlblR5cGVJZHgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DYXRlZ29yaWVzTWFwUHJvcCh0b2tlblR5cGVzKSB7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCBmdW5jdGlvbiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAoW10sIGN1cnJUb2tUeXBlKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcChwYXRoLCBuZXh0Tm9kZSkge1xuICAgIGZvckVhY2gocGF0aCwgZnVuY3Rpb24gKHBhdGhOb2RlKSB7XG4gICAgICAgIG5leHROb2RlLmNhdGVnb3J5TWF0Y2hlc01hcFtwYXRoTm9kZS50b2tlblR5cGVJZHhdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKG5leHROb2RlLkNBVEVHT1JJRVMsIGZ1bmN0aW9uIChuZXh0Q2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIG5ld1BhdGggPSBwYXRoLmNvbmNhdChuZXh0Tm9kZSk7XG4gICAgICAgIC8vIGF2b2lkcyBpbmZpbml0ZSBsb29wcyBkdWUgdG8gY3ljbGljIGNhdGVnb3JpZXMuXG4gICAgICAgIGlmICghY29udGFpbnMobmV3UGF0aCwgbmV4dENhdGVnb3J5KSkge1xuICAgICAgICAgICAgc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXAobmV3UGF0aCwgbmV4dENhdGVnb3J5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Nob3J0S2V5UHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQ2F0ZWdvcmllc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiQ0FURUdPUklFU1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc1Byb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiY2F0ZWdvcnlNYXRjaGVzXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHkodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJjYXRlZ29yeU1hdGNoZXNNYXBcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlblR5cGUodG9rVHlwZSkge1xuICAgIHJldHVybiBoYXModG9rVHlwZSwgXCJ0b2tlblR5cGVJZHhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/tokens.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js ***!
  \*******************************************************************/
/*! exports provided: tokenLabel, tokenName, hasTokenLabel, createToken, EOF, createTokenInstance, tokenMatcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenLabel\", function() { return tokenLabel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenName\", function() { return tokenName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasTokenLabel\", function() { return hasTokenLabel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createToken\", function() { return createToken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EOF\", function() { return EOF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTokenInstance\", function() { return createTokenInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenMatcher\", function() { return tokenMatcher; });\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ \"./node_modules/chevrotain/lib_esm/src/utils/utils.js\");\n/* harmony import */ var _lexer_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer_public */ \"./node_modules/chevrotain/lib_esm/src/scan/lexer_public.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens */ \"./node_modules/chevrotain/lib_esm/src/scan/tokens.js\");\n\n\n\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nfunction tokenName(tokType) {\n    return tokType.name;\n}\nfunction hasTokenLabel(obj) {\n    return Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isString\"])(obj.LABEL) && obj.LABEL !== \"\";\n}\nvar PARENT = \"parent\";\nvar CATEGORIES = \"categories\";\nvar LABEL = \"label\";\nvar GROUP = \"group\";\nvar PUSH_MODE = \"push_mode\";\nvar POP_MODE = \"pop_mode\";\nvar LONGER_ALT = \"longer_alt\";\nvar LINE_BREAKS = \"line_breaks\";\nvar START_CHARS_HINT = \"start_chars_hint\";\nfunction createToken(config) {\n    return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n    var pattern = config.pattern;\n    var tokenType = {};\n    tokenType.name = config.name;\n    if (!Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"isUndefined\"])(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, PARENT)) {\n        throw \"The parent property is no longer supported.\\n\" +\n            \"See: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.\";\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    Object(_tokens__WEBPACK_IMPORTED_MODULE_2__[\"augmentTokenTypes\"])([tokenType]);\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if (Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__[\"has\"])(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nvar EOF = createToken({ name: \"EOF\", pattern: _lexer_public__WEBPACK_IMPORTED_MODULE_1__[\"Lexer\"].NA });\nObject(_tokens__WEBPACK_IMPORTED_MODULE_2__[\"augmentTokenTypes\"])([EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image: image,\n        startOffset: startOffset,\n        endOffset: endOffset,\n        startLine: startLine,\n        endLine: endLine,\n        startColumn: startColumn,\n        endColumn: endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType\n    };\n}\nfunction tokenMatcher(token, tokType) {\n    return Object(_tokens__WEBPACK_IMPORTED_MODULE_2__[\"tokenStructuredMatcher\"])(token, tokType);\n}\n//# sourceMappingURL=tokens_public.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3Rva2Vuc19wdWJsaWMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy9zY2FuL3Rva2Vuc19wdWJsaWMuanM/YmNhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXMsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi9sZXhlcl9wdWJsaWNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyIH0gZnJvbSBcIi4vdG9rZW5zXCI7XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5MYWJlbCh0b2tUeXBlKSB7XG4gICAgaWYgKGhhc1Rva2VuTGFiZWwodG9rVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRva1R5cGUuTEFCRUw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rVHlwZS5uYW1lO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbk5hbWUodG9rVHlwZSkge1xuICAgIHJldHVybiB0b2tUeXBlLm5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzVG9rZW5MYWJlbChvYmopIHtcbiAgICByZXR1cm4gaXNTdHJpbmcob2JqLkxBQkVMKSAmJiBvYmouTEFCRUwgIT09IFwiXCI7XG59XG52YXIgUEFSRU5UID0gXCJwYXJlbnRcIjtcbnZhciBDQVRFR09SSUVTID0gXCJjYXRlZ29yaWVzXCI7XG52YXIgTEFCRUwgPSBcImxhYmVsXCI7XG52YXIgR1JPVVAgPSBcImdyb3VwXCI7XG52YXIgUFVTSF9NT0RFID0gXCJwdXNoX21vZGVcIjtcbnZhciBQT1BfTU9ERSA9IFwicG9wX21vZGVcIjtcbnZhciBMT05HRVJfQUxUID0gXCJsb25nZXJfYWx0XCI7XG52YXIgTElORV9CUkVBS1MgPSBcImxpbmVfYnJlYWtzXCI7XG52YXIgU1RBUlRfQ0hBUlNfSElOVCA9IFwic3RhcnRfY2hhcnNfaGludFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZykge1xuICAgIHZhciBwYXR0ZXJuID0gY29uZmlnLnBhdHRlcm47XG4gICAgdmFyIHRva2VuVHlwZSA9IHt9O1xuICAgIHRva2VuVHlwZS5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgaWYgKCFpc1VuZGVmaW5lZChwYXR0ZXJuKSkge1xuICAgICAgICB0b2tlblR5cGUuUEFUVEVSTiA9IHBhdHRlcm47XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBQQVJFTlQpKSB7XG4gICAgICAgIHRocm93IFwiVGhlIHBhcmVudCBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxcblwiICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL2dpdGh1Yi5jb20vU0FQL2NoZXZyb3RhaW4vaXNzdWVzLzU2NCNpc3N1ZWNvbW1lbnQtMzQ5MDYyMzQ2IGZvciBkZXRhaWxzLlwiO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgQ0FURUdPUklFUykpIHtcbiAgICAgICAgLy8gY2FzdGluZyB0byBBTlkgYXMgdGhpcyB3aWxsIGJlIGZpeGVkIGluc2lkZSBgYXVnbWVudFRva2VuVHlwZXNgYFxuICAgICAgICB0b2tlblR5cGUuQ0FURUdPUklFUyA9IGNvbmZpZ1tDQVRFR09SSUVTXTtcbiAgICB9XG4gICAgYXVnbWVudFRva2VuVHlwZXMoW3Rva2VuVHlwZV0pO1xuICAgIGlmIChoYXMoY29uZmlnLCBMQUJFTCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLkxBQkVMID0gY29uZmlnW0xBQkVMXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIEdST1VQKSkge1xuICAgICAgICB0b2tlblR5cGUuR1JPVVAgPSBjb25maWdbR1JPVVBdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgUE9QX01PREUpKSB7XG4gICAgICAgIHRva2VuVHlwZS5QT1BfTU9ERSA9IGNvbmZpZ1tQT1BfTU9ERV07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBQVVNIX01PREUpKSB7XG4gICAgICAgIHRva2VuVHlwZS5QVVNIX01PREUgPSBjb25maWdbUFVTSF9NT0RFXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIExPTkdFUl9BTFQpKSB7XG4gICAgICAgIHRva2VuVHlwZS5MT05HRVJfQUxUID0gY29uZmlnW0xPTkdFUl9BTFRdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgTElORV9CUkVBS1MpKSB7XG4gICAgICAgIHRva2VuVHlwZS5MSU5FX0JSRUFLUyA9IGNvbmZpZ1tMSU5FX0JSRUFLU107XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBTVEFSVF9DSEFSU19ISU5UKSkge1xuICAgICAgICB0b2tlblR5cGUuU1RBUlRfQ0hBUlNfSElOVCA9IGNvbmZpZ1tTVEFSVF9DSEFSU19ISU5UXTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuVHlwZTtcbn1cbmV4cG9ydCB2YXIgRU9GID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkVPRlwiLCBwYXR0ZXJuOiBMZXhlci5OQSB9KTtcbmF1Z21lbnRUb2tlblR5cGVzKFtFT0ZdKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUb2tlbkluc3RhbmNlKHRva1R5cGUsIGltYWdlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXQsXG4gICAgICAgIHN0YXJ0TGluZTogc3RhcnRMaW5lLFxuICAgICAgICBlbmRMaW5lOiBlbmRMaW5lLFxuICAgICAgICBzdGFydENvbHVtbjogc3RhcnRDb2x1bW4sXG4gICAgICAgIGVuZENvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICB0b2tlblR5cGVJZHg6IHRva1R5cGUudG9rZW5UeXBlSWR4LFxuICAgICAgICB0b2tlblR5cGU6IHRva1R5cGVcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuTWF0Y2hlcih0b2tlbiwgdG9rVHlwZSkge1xuICAgIHJldHVybiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyKHRva2VuLCB0b2tUeXBlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2Vuc19wdWJsaWMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/scan/tokens_public.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/utils/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/utils/utils.js ***!
  \************************************************************/
/*! exports provided: isEmpty, keys, values, mapValues, map, flatten, first, last, forEach, isString, isUndefined, isFunction, drop, dropRight, filter, reject, pick, has, contains, cloneArr, cloneObj, find, findAll, reduce, compact, uniq, partial, isArray, isRegExp, isObject, every, difference, some, indexOf, sortBy, zipObject, assign, assignNoOverwrite, defaults, groupBy, merge, NOOP, IDENTITY, packArray, PRINT_ERROR, PRINT_WARNING, isES2015MapSupported, applyMixins, toFastProperties, peek, timer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEmpty\", function() { return isEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"values\", function() { return values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapValues\", function() { return mapValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flatten\", function() { return flatten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"first\", function() { return first; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"last\", function() { return last; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUndefined\", function() { return isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drop\", function() { return drop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dropRight\", function() { return dropRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filter\", function() { return filter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reject\", function() { return reject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pick\", function() { return pick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"has\", function() { return has; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contains\", function() { return contains; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneArr\", function() { return cloneArr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneObj\", function() { return cloneObj; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"find\", function() { return find; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findAll\", function() { return findAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reduce\", function() { return reduce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compact\", function() { return compact; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uniq\", function() { return uniq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"partial\", function() { return partial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRegExp\", function() { return isRegExp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObject\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"every\", function() { return every; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"difference\", function() { return difference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"some\", function() { return some; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indexOf\", function() { return indexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sortBy\", function() { return sortBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zipObject\", function() { return zipObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assignNoOverwrite\", function() { return assignNoOverwrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaults\", function() { return defaults; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"groupBy\", function() { return groupBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NOOP\", function() { return NOOP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IDENTITY\", function() { return IDENTITY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"packArray\", function() { return packArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PRINT_ERROR\", function() { return PRINT_ERROR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PRINT_WARNING\", function() { return PRINT_WARNING; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isES2015MapSupported\", function() { return isES2015MapSupported; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyMixins\", function() { return applyMixins; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFastProperties\", function() { return toFastProperties; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"peek\", function() { return peek; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timer\", function() { return timer; });\n/*\n Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.\n These utils should replace usage of lodash in the production code base. not because they are any better...\n but for the purpose of being a dependency free library.\n\n The hotspots in the code are already written in imperative style for performance reasons.\n so writing several dozen utils which may be slower than the original lodash, does not matter as much\n considering they will not be invoked in hotspots...\n */\nfunction isEmpty(arr) {\n    return arr && arr.length === 0;\n}\nfunction keys(obj) {\n    if (obj === undefined || obj === null) {\n        return [];\n    }\n    return Object.keys(obj);\n}\nfunction values(obj) {\n    var vals = [];\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n        vals.push(obj[keys[i]]);\n    }\n    return vals;\n}\nfunction mapValues(obj, callback) {\n    var result = [];\n    var objKeys = keys(obj);\n    for (var idx = 0; idx < objKeys.length; idx++) {\n        var currKey = objKeys[idx];\n        result.push(callback.call(null, obj[currKey], currKey));\n    }\n    return result;\n}\nfunction map(arr, callback) {\n    var result = [];\n    for (var idx = 0; idx < arr.length; idx++) {\n        result.push(callback.call(null, arr[idx], idx));\n    }\n    return result;\n}\nfunction flatten(arr) {\n    var result = [];\n    for (var idx = 0; idx < arr.length; idx++) {\n        var currItem = arr[idx];\n        if (Array.isArray(currItem)) {\n            result = result.concat(flatten(currItem));\n        }\n        else {\n            result.push(currItem);\n        }\n    }\n    return result;\n}\nfunction first(arr) {\n    return isEmpty(arr) ? undefined : arr[0];\n}\nfunction last(arr) {\n    var len = arr && arr.length;\n    return len ? arr[len - 1] : undefined;\n}\nfunction forEach(collection, iteratorCallback) {\n    /* istanbul ignore else */\n    if (Array.isArray(collection)) {\n        for (var i = 0; i < collection.length; i++) {\n            iteratorCallback.call(null, collection[i], i);\n        }\n    }\n    else if (isObject(collection)) {\n        var colKeys = keys(collection);\n        for (var i = 0; i < colKeys.length; i++) {\n            var key = colKeys[i];\n            var value = collection[key];\n            iteratorCallback.call(null, value, key);\n        }\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction isString(item) {\n    return typeof item === \"string\";\n}\nfunction isUndefined(item) {\n    return item === undefined;\n}\nfunction isFunction(item) {\n    return item instanceof Function;\n}\nfunction drop(arr, howMuch) {\n    if (howMuch === void 0) { howMuch = 1; }\n    return arr.slice(howMuch, arr.length);\n}\nfunction dropRight(arr, howMuch) {\n    if (howMuch === void 0) { howMuch = 1; }\n    return arr.slice(0, arr.length - howMuch);\n}\nfunction filter(arr, predicate) {\n    var result = [];\n    if (Array.isArray(arr)) {\n        for (var i = 0; i < arr.length; i++) {\n            var item = arr[i];\n            if (predicate.call(null, item)) {\n                result.push(item);\n            }\n        }\n    }\n    return result;\n}\nfunction reject(arr, predicate) {\n    return filter(arr, function (item) { return !predicate(item); });\n}\nfunction pick(obj, predicate) {\n    var keys = Object.keys(obj);\n    var result = {};\n    for (var i = 0; i < keys.length; i++) {\n        var currKey = keys[i];\n        var currItem = obj[currKey];\n        if (predicate(currItem)) {\n            result[currKey] = currItem;\n        }\n    }\n    return result;\n}\nfunction has(obj, prop) {\n    if (isObject(obj)) {\n        return obj.hasOwnProperty(prop);\n    }\n    return false;\n}\nfunction contains(arr, item) {\n    return find(arr, function (currItem) { return currItem === item; }) !== undefined ? true : false;\n}\n/**\n * shallow clone\n */\nfunction cloneArr(arr) {\n    var newArr = [];\n    for (var i = 0; i < arr.length; i++) {\n        newArr.push(arr[i]);\n    }\n    return newArr;\n}\n/**\n * shallow clone\n */\nfunction cloneObj(obj) {\n    var clonedObj = {};\n    for (var key in obj) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            clonedObj[key] = obj[key];\n        }\n    }\n    return clonedObj;\n}\nfunction find(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        if (predicate.call(null, item)) {\n            return item;\n        }\n    }\n    return undefined;\n}\nfunction findAll(arr, predicate) {\n    var found = [];\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        if (predicate.call(null, item)) {\n            found.push(item);\n        }\n    }\n    return found;\n}\nfunction reduce(arrOrObj, iterator, initial) {\n    var isArr = Array.isArray(arrOrObj);\n    var vals = isArr ? arrOrObj : values(arrOrObj);\n    var objKeys = isArr ? [] : keys(arrOrObj);\n    var accumulator = initial;\n    for (var i = 0; i < vals.length; i++) {\n        accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);\n    }\n    return accumulator;\n}\nfunction compact(arr) {\n    return reject(arr, function (item) { return item === null || item === undefined; });\n}\nfunction uniq(arr, identity) {\n    if (identity === void 0) { identity = function (item) { return item; }; }\n    var identities = [];\n    return reduce(arr, function (result, currItem) {\n        var currIdentity = identity(currItem);\n        if (contains(identities, currIdentity)) {\n            return result;\n        }\n        else {\n            identities.push(currIdentity);\n            return result.concat(currItem);\n        }\n    }, []);\n}\nfunction partial(func) {\n    var restArgs = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        restArgs[_i - 1] = arguments[_i];\n    }\n    var firstArg = [null];\n    var allArgs = firstArg.concat(restArgs);\n    return Function.bind.apply(func, allArgs);\n}\nfunction isArray(obj) {\n    return Array.isArray(obj);\n}\nfunction isRegExp(obj) {\n    return obj instanceof RegExp;\n}\nfunction isObject(obj) {\n    return obj instanceof Object;\n}\nfunction every(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (!predicate(arr[i], i)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction difference(arr, values) {\n    return reject(arr, function (item) { return contains(values, item); });\n}\nfunction some(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (predicate(arr[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction indexOf(arr, value) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === value) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction sortBy(arr, orderFunc) {\n    var result = cloneArr(arr);\n    result.sort(function (a, b) { return orderFunc(a) - orderFunc(b); });\n    return result;\n}\nfunction zipObject(keys, values) {\n    if (keys.length !== values.length) {\n        throw Error(\"can't zipObject with different number of keys and values!\");\n    }\n    var result = {};\n    for (var i = 0; i < keys.length; i++) {\n        result[keys[i]] = values[i];\n    }\n    return result;\n}\n/**\n * mutates! (and returns) target\n */\nfunction assign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; i++) {\n        var curSource = sources[i];\n        var currSourceKeys = keys(curSource);\n        for (var j = 0; j < currSourceKeys.length; j++) {\n            var currKey = currSourceKeys[j];\n            target[currKey] = curSource[currKey];\n        }\n    }\n    return target;\n}\n/**\n * mutates! (and returns) target\n */\nfunction assignNoOverwrite(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; i++) {\n        var curSource = sources[i];\n        if (isUndefined(curSource)) {\n            continue;\n        }\n        var currSourceKeys = keys(curSource);\n        for (var j = 0; j < currSourceKeys.length; j++) {\n            var currKey = currSourceKeys[j];\n            if (!has(target, currKey)) {\n                target[currKey] = curSource[currKey];\n            }\n        }\n    }\n    return target;\n}\nfunction defaults() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return assignNoOverwrite.apply(null, [{}].concat(sources));\n}\nfunction groupBy(arr, groupKeyFunc) {\n    var result = {};\n    forEach(arr, function (item) {\n        var currGroupKey = groupKeyFunc(item);\n        var currGroupArr = result[currGroupKey];\n        if (currGroupArr) {\n            currGroupArr.push(item);\n        }\n        else {\n            result[currGroupKey] = [item];\n        }\n    });\n    return result;\n}\n/**\n * Merge obj2 into obj1.\n * Will overwrite existing properties with the same name\n */\nfunction merge(obj1, obj2) {\n    var result = cloneObj(obj1);\n    var keys2 = keys(obj2);\n    for (var i = 0; i < keys2.length; i++) {\n        var key = keys2[i];\n        var value = obj2[key];\n        result[key] = value;\n    }\n    return result;\n}\nfunction NOOP() { }\nfunction IDENTITY(item) {\n    return item;\n}\n/**\n * Will return a new packed array with same values.\n */\nfunction packArray(holeyArr) {\n    var result = [];\n    for (var i = 0; i < holeyArr.length; i++) {\n        var orgValue = holeyArr[i];\n        result.push(orgValue !== undefined ? orgValue : undefined);\n    }\n    return result;\n}\nfunction PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n        console.error(\"Error: \" + msg);\n    }\n}\nfunction PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(\"Warning: \" + msg);\n    }\n}\nfunction isES2015MapSupported() {\n    return typeof Map === \"function\";\n}\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        var baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {\n            if (propName === \"constructor\") {\n                return;\n            }\n            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nfunction toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    var fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    eval(toBecomeFast);\n}\nfunction peek(arr) {\n    return arr[arr.length - 1];\n}\n/* istanbul ignore next - for performance tracing*/\nfunction timer(func) {\n    var start = new Date().getTime();\n    var val = func();\n    var end = new Date().getTime();\n    var total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy91dGlscy91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYl9lc20vc3JjL3V0aWxzL3V0aWxzLmpzPzc3YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBVdGlscyB1c2luZyBsb2Rhc2ggc3R5bGUgQVBJLiAobm90IG5lY2Vzc2FyaWx5IDEwMCUgY29tcGxpYW50KSBmb3IgZnVuY3Rpb25hbCBhbmQgb3RoZXIgdXRpbHMuXG4gVGhlc2UgdXRpbHMgc2hvdWxkIHJlcGxhY2UgdXNhZ2Ugb2YgbG9kYXNoIGluIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmFzZS4gbm90IGJlY2F1c2UgdGhleSBhcmUgYW55IGJldHRlci4uLlxuIGJ1dCBmb3IgdGhlIHB1cnBvc2Ugb2YgYmVpbmcgYSBkZXBlbmRlbmN5IGZyZWUgbGlicmFyeS5cblxuIFRoZSBob3RzcG90cyBpbiB0aGUgY29kZSBhcmUgYWxyZWFkeSB3cml0dGVuIGluIGltcGVyYXRpdmUgc3R5bGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gc28gd3JpdGluZyBzZXZlcmFsIGRvemVuIHV0aWxzIHdoaWNoIG1heSBiZSBzbG93ZXIgdGhhbiB0aGUgb3JpZ2luYWwgbG9kYXNoLCBkb2VzIG5vdCBtYXR0ZXIgYXMgbXVjaFxuIGNvbnNpZGVyaW5nIHRoZXkgd2lsbCBub3QgYmUgaW52b2tlZCBpbiBob3RzcG90cy4uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShhcnIpIHtcbiAgICByZXR1cm4gYXJyICYmIGFyci5sZW5ndGggPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICAgIHZhciB2YWxzID0gW107XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxzLnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwVmFsdWVzKG9iaiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG9iaktleXMgPSBrZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgb2JqS2V5cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBjdXJyS2V5ID0gb2JqS2V5c1tpZHhdO1xuICAgICAgICByZXN1bHQucHVzaChjYWxsYmFjay5jYWxsKG51bGwsIG9ialtjdXJyS2V5XSwgY3VycktleSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1hcChhcnIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwobnVsbCwgYXJyW2lkeF0sIGlkeCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBjdXJySXRlbSA9IGFycltpZHhdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJySXRlbSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdHRlbihjdXJySXRlbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3Vyckl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoYXJyKSB7XG4gICAgcmV0dXJuIGlzRW1wdHkoYXJyKSA/IHVuZGVmaW5lZCA6IGFyclswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsYXN0KGFycikge1xuICAgIHZhciBsZW4gPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuID8gYXJyW2xlbiAtIDFdIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0b3JDYWxsYmFjaykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVyYXRvckNhbGxiYWNrLmNhbGwobnVsbCwgY29sbGVjdGlvbltpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGNvbEtleXMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjb2xLZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICAgICAgaXRlcmF0b3JDYWxsYmFjay5jYWxsKG51bGwsIHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhpdGVtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5leHBvcnQgZnVuY3Rpb24gZHJvcChhcnIsIGhvd011Y2gpIHtcbiAgICBpZiAoaG93TXVjaCA9PT0gdm9pZCAwKSB7IGhvd011Y2ggPSAxOyB9XG4gICAgcmV0dXJuIGFyci5zbGljZShob3dNdWNoLCBhcnIubGVuZ3RoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyLCBob3dNdWNoKSB7XG4gICAgaWYgKGhvd011Y2ggPT09IHZvaWQgMCkgeyBob3dNdWNoID0gMTsgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoMCwgYXJyLmxlbmd0aCAtIGhvd011Y2gpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcihhcnIsIHByZWRpY2F0ZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFycltpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChudWxsLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVqZWN0KGFyciwgcHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZpbHRlcihhcnIsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhcHJlZGljYXRlKGl0ZW0pOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJLZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgY3Vyckl0ZW0gPSBvYmpbY3VycktleV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUoY3Vyckl0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHRbY3VycktleV0gPSBjdXJySXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhcyhvYmosIHByb3ApIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMoYXJyLCBpdGVtKSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyLCBmdW5jdGlvbiAoY3Vyckl0ZW0pIHsgcmV0dXJuIGN1cnJJdGVtID09PSBpdGVtOyB9KSAhPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xufVxuLyoqXG4gKiBzaGFsbG93IGNsb25lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFycihhcnIpIHtcbiAgICB2YXIgbmV3QXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Fycjtcbn1cbi8qKlxuICogc2hhbGxvdyBjbG9uZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVPYmoob2JqKSB7XG4gICAgdmFyIGNsb25lZE9iaiA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGNsb25lZE9ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZE9iajtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFyciwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChudWxsLCBpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQWxsKGFyciwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGZvdW5kID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChudWxsLCBpdGVtKSkge1xuICAgICAgICAgICAgZm91bmQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlKGFyck9yT2JqLCBpdGVyYXRvciwgaW5pdGlhbCkge1xuICAgIHZhciBpc0FyciA9IEFycmF5LmlzQXJyYXkoYXJyT3JPYmopO1xuICAgIHZhciB2YWxzID0gaXNBcnIgPyBhcnJPck9iaiA6IHZhbHVlcyhhcnJPck9iaik7XG4gICAgdmFyIG9iaktleXMgPSBpc0FyciA/IFtdIDoga2V5cyhhcnJPck9iaik7XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gaW5pdGlhbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRvci5jYWxsKG51bGwsIGFjY3VtdWxhdG9yLCB2YWxzW2ldLCBpc0FyciA/IGkgOiBvYmpLZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3QoYXJyKSB7XG4gICAgcmV0dXJuIHJlamVjdChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHVuZGVmaW5lZDsgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5pcShhcnIsIGlkZW50aXR5KSB7XG4gICAgaWYgKGlkZW50aXR5ID09PSB2b2lkIDApIHsgaWRlbnRpdHkgPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfTsgfVxuICAgIHZhciBpZGVudGl0aWVzID0gW107XG4gICAgcmV0dXJuIHJlZHVjZShhcnIsIGZ1bmN0aW9uIChyZXN1bHQsIGN1cnJJdGVtKSB7XG4gICAgICAgIHZhciBjdXJySWRlbnRpdHkgPSBpZGVudGl0eShjdXJySXRlbSk7XG4gICAgICAgIGlmIChjb250YWlucyhpZGVudGl0aWVzLCBjdXJySWRlbnRpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWRlbnRpdGllcy5wdXNoKGN1cnJJZGVudGl0eSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJySXRlbSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgdmFyIHJlc3RBcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcmVzdEFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBmaXJzdEFyZyA9IFtudWxsXTtcbiAgICB2YXIgYWxsQXJncyA9IGZpcnN0QXJnLmNvbmNhdChyZXN0QXJncyk7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLmJpbmQuYXBwbHkoZnVuYywgYWxsQXJncyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZWdFeHA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBldmVyeShhcnIsIHByZWRpY2F0ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKGFycltpXSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlKGFyciwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHJlamVjdChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBjb250YWlucyh2YWx1ZXMsIGl0ZW0pOyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzb21lKGFyciwgcHJlZGljYXRlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnIsIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnkoYXJyLCBvcmRlckZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVBcnIoYXJyKTtcbiAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gb3JkZXJGdW5jKGEpIC0gb3JkZXJGdW5jKGIpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJjYW4ndCB6aXBPYmplY3Qgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGtleXMgYW5kIHZhbHVlcyFcIik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2tleXNbaV1dID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBtdXRhdGVzISAoYW5kIHJldHVybnMpIHRhcmdldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJTb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICB2YXIgY3VyclNvdXJjZUtleXMgPSBrZXlzKGN1clNvdXJjZSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VyclNvdXJjZUtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyS2V5ID0gY3VyclNvdXJjZUtleXNbal07XG4gICAgICAgICAgICB0YXJnZXRbY3VycktleV0gPSBjdXJTb3VyY2VbY3VycktleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogbXV0YXRlcyEgKGFuZCByZXR1cm5zKSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbk5vT3ZlcndyaXRlKHRhcmdldCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJTb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoY3VyU291cmNlKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJTb3VyY2VLZXlzID0ga2V5cyhjdXJTb3VyY2UpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN1cnJTb3VyY2VLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY3VycktleSA9IGN1cnJTb3VyY2VLZXlzW2pdO1xuICAgICAgICAgICAgaWYgKCFoYXModGFyZ2V0LCBjdXJyS2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtjdXJyS2V5XSA9IGN1clNvdXJjZVtjdXJyS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduTm9PdmVyd3JpdGUuYXBwbHkobnVsbCwgW3t9XS5jb25jYXQoc291cmNlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnkoYXJyLCBncm91cEtleUZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBjdXJyR3JvdXBLZXkgPSBncm91cEtleUZ1bmMoaXRlbSk7XG4gICAgICAgIHZhciBjdXJyR3JvdXBBcnIgPSByZXN1bHRbY3Vyckdyb3VwS2V5XTtcbiAgICAgICAgaWYgKGN1cnJHcm91cEFycikge1xuICAgICAgICAgICAgY3Vyckdyb3VwQXJyLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbY3Vyckdyb3VwS2V5XSA9IFtpdGVtXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlIG9iajIgaW50byBvYmoxLlxuICogV2lsbCBvdmVyd3JpdGUgZXhpc3RpbmcgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKG9iajEsIG9iajIpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xvbmVPYmoob2JqMSk7XG4gICAgdmFyIGtleXMyID0ga2V5cyhvYmoyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzMltpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqMltrZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIE5PT1AoKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBJREVOVElUWShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIFdpbGwgcmV0dXJuIGEgbmV3IHBhY2tlZCBhcnJheSB3aXRoIHNhbWUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja0FycmF5KGhvbGV5QXJyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXlBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9yZ1ZhbHVlID0gaG9sZXlBcnJbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG9yZ1ZhbHVlICE9PSB1bmRlZmluZWQgPyBvcmdWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfRVJST1IobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBjYW4ndCBvdmVycmlkZSBnbG9iYWwuY29uc29sZSBpbiBub2RlLmpzICovXG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IFwiICsgbXNnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfV0FSTklORyhtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGNhbid0IG92ZXJyaWRlIGdsb2JhbC5jb25zb2xlIGluIG5vZGUuanMqL1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAvLyBUT0RPOiBtb2RpZnkgZG9jcyBhY2NvcmRpbmdseVxuICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBcIiArIG1zZyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRVMyMDE1TWFwU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3IsIGJhc2VDdG9ycykge1xuICAgIGJhc2VDdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChiYXNlQ3Rvcikge1xuICAgICAgICB2YXIgYmFzZVByb3RvID0gYmFzZUN0b3IucHJvdG90eXBlO1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlUHJvdG8pLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXNlUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VQcm90bywgcHJvcE5hbWUpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIEFjY2Vzc29yc1xuICAgICAgICAgICAgaWYgKGJhc2VQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgIChiYXNlUHJvcERlc2NyaXB0b3IuZ2V0IHx8IGJhc2VQcm9wRGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDdG9yLnByb3RvdHlwZSwgcHJvcE5hbWUsIGJhc2VQcm9wRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGVbcHJvcE5hbWVdID0gYmFzZUN0b3IucHJvdG90eXBlW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyBiYXNlIG9uOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL2Jsb2IvYjk3YzBkMmQ0ODdlOGM1MDc2ZThiZDg5N2UwZGNkNDYyMmQzMTg0Ni9zcmMvdXRpbC5qcyNMMjAxLUwyMTZcbmV4cG9ydCBmdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKHRvQmVjb21lRmFzdCkge1xuICAgIGZ1bmN0aW9uIEZha2VDb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8vIElmIG91ciBvYmplY3QgaXMgdXNlZCBhcyBhIGNvbnN0cnVjdG9yIGl0IHdvdWxkIHJlY2VpdmVcbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gdG9CZWNvbWVGYXN0O1xuICAgIHZhciBmYWtlSW5zdGFuY2UgPSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgZnVuY3Rpb24gZmFrZUFjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmYWtlSW5zdGFuY2UuYmFyO1xuICAgIH1cbiAgICAvLyBoZWxwIFY4IHVuZGVyc3RhbmQgdGhpcyBpcyBhIFwicmVhbFwiIHByb3RvdHlwZSBieSBhY3R1YWxseSB1c2luZ1xuICAgIC8vIHRoZSBmYWtlIGluc3RhbmNlLlxuICAgIGZha2VBY2Nlc3MoKTtcbiAgICBmYWtlQWNjZXNzKCk7XG4gICAgcmV0dXJuIHRvQmVjb21lRmFzdDtcbiAgICAvLyBFdmFsIHByZXZlbnRzIG9wdGltaXphdGlvbiBvZiB0aGlzIG1ldGhvZCAoZXZlbiB0aG91Z2ggdGhpcyBpcyBkZWFkIGNvZGUpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBldmFsKHRvQmVjb21lRmFzdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVlayhhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gZm9yIHBlcmZvcm1hbmNlIHRyYWNpbmcqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGZ1bmMpIHtcbiAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdmFsID0gZnVuYygpO1xuICAgIHZhciBlbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgdG90YWwgPSBlbmQgLSBzdGFydDtcbiAgICByZXR1cm4geyB0aW1lOiB0b3RhbCwgdmFsdWU6IHZhbCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/utils/utils.js\n");

/***/ }),

/***/ "./node_modules/chevrotain/lib_esm/src/version.js":
/*!********************************************************!*\
  !*** ./node_modules/chevrotain/lib_esm/src/version.js ***!
  \********************************************************/
/*! exports provided: VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nvar VERSION = \"6.5.0\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWJfZXNtL3NyYy92ZXJzaW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliX2VzbS9zcmMvdmVyc2lvbi5qcz9jZTEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG5lZWRzIGEgc2VwYXJhdGUgbW9kdWxlIGFzIHRoaXMgaXMgcmVxdWlyZWQgaW5zaWRlIGNoZXZyb3RhaW4gcHJvZHVjdGl2ZSBjb2RlXG4vLyBhbmQgYWxzbyBpbiB0aGUgZW50cnkgcG9pbnQgZm9yIHdlYnBhY2soYXBpLnRzKS5cbi8vIEEgc2VwYXJhdGUgZmlsZSBhdm9pZHMgY3ljbGljIGRlcGVuZGVuY2llcyBhbmQgd2VicGFjayBlcnJvcnMuXG5leHBvcnQgdmFyIFZFUlNJT04gPSBcIjYuNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chevrotain/lib_esm/src/version.js\n");

/***/ }),

/***/ "./node_modules/java-parser/node_modules/lodash/lodash.js":
/*!****************************************************************!*\
  !*** ./node_modules/java-parser/node_modules/lodash/lodash.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.15';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1;\n      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array == null ? 0 : array.length,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.\n      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/[\\r\\n]/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      // Like with sourceURL, we take care to not check the option's prototype,\n      // as this configuration is a code injection vector.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanM/M2E1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjE1JztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgcmVUcmltU3RhcnQgPSAvXlxccysvLFxuICAgICAgcmVUcmltRW5kID0gL1xccyskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24gJiYgbmF0aXZlSXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gICAgICAvLyB3aXRoIGxvb2t1cCAoaW4gY2FzZSBvZiBlLmcuIHByb3RvdHlwZSBwb2xsdXRpb24pLCBhbmQgc3RyaXAgbmV3bGluZXMgaWYgYW55LlxuICAgICAgLy8gQSBuZXdsaW5lIHdvdWxkbid0IGJlIGEgdmFsaWQgc291cmNlVVJMIGFueXdheSwgYW5kIGl0J2QgZW5hYmxlIGNvZGUgaW5qZWN0aW9uLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICAgICAgICA/IChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgICAgIC8vIGFzIHRoaXMgY29uZmlndXJhdGlvbiBpcyBhIGNvZGUgaW5qZWN0aW9uIHZlY3Rvci5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0EsU0FTQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/java-parser/node_modules/lodash/lodash.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/comments.js":
/*!**************************************************!*\
  !*** ./node_modules/java-parser/src/comments.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"./node_modules/java-parser/node_modules/lodash/lodash.js\");\n\n/**\n * Search where is the position of the comment in the token array by\n * using dichotomic search.\n * @param {*} tokens ordered array of tokens\n * @param {*} comment comment token\n * @return the position of the token next to the comment\n */\nfunction findUpperBoundToken(tokens, comment) {\n  let diff;\n  let i;\n  let current;\n\n  let len = tokens.length;\n  i = 0;\n\n  while (len) {\n    diff = len >>> 1;\n    current = i + diff;\n    if (tokens[current].startOffset > comment.startOffset) {\n      len = diff;\n    } else {\n      i = current + 1;\n      len -= diff + 1;\n    }\n  }\n  return i;\n}\n\nfunction isPrettierIgnoreComment(comment) {\n  return comment.image.match(\n    /(\\/\\/(\\s*)prettier-ignore(\\s*))|(\\/\\*(\\s*)prettier-ignore(\\s*)\\*\\/)/gm\n  );\n}\n\nfunction isFormatterOffOnComment(comment) {\n  return comment.image.match(\n    /(\\/\\/(\\s*)@formatter:(off|on)(\\s*))|(\\/\\*(\\s*)@formatter:(off|on)(\\s*)\\*\\/)/gm\n  );\n}\n\n/**\n * Pre-processing of tokens in order to\n * complete the parser's mostEnclosiveCstNodeByStartOffset and mostEnclosiveCstNodeByEndOffset structures.\n *\n * @param {ITokens[]} tokens - array of tokens\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n * @param {{[endOffset: number]: CSTNode}} mostEnclosiveCstNodeByEndOffset\n */\nfunction completeMostEnclosiveCSTNodeByOffset(\n  tokens,\n  mostEnclosiveCstNodeByStartOffset,\n  mostEnclosiveCstNodeByEndOffset\n) {\n  tokens.forEach(token => {\n    if (mostEnclosiveCstNodeByStartOffset[token.startOffset] === undefined) {\n      mostEnclosiveCstNodeByStartOffset[token.startOffset] = token;\n    }\n\n    if (mostEnclosiveCstNodeByEndOffset[token.endOffset] === undefined) {\n      mostEnclosiveCstNodeByEndOffset[token.endOffset] = token;\n    }\n  });\n}\n\nfunction extendRangeOffset(comments, tokens) {\n  let position;\n  comments.forEach(comment => {\n    position = findUpperBoundToken(tokens, comment);\n\n    const extendedStartOffset =\n      position - 1 < 0 ? comment.startOffset : tokens[position - 1].endOffset;\n    const extendedEndOffset =\n      position == tokens.length\n        ? comment.endOffset\n        : tokens[position].startOffset;\n    comment.extendedOffset = {\n      startOffset: extendedStartOffset,\n      endOffset: extendedEndOffset\n    };\n  });\n}\n\n/**\n * Create two data structures we use to know at which offset a comment can be attached.\n * - commentsByExtendedStartOffset: map a comment by the endOffset of the previous token.\n * - commentsByExtendedEndOffset: map a comment by the startOffset of the next token\n *\n * @param {ITokens[]} tokens - array of tokens\n *\n * @return {{commentsByExtendedStartOffset: {[extendedStartOffset: number]: Comment[]}, commentsByExtendedEndOffset: {[extendedEndOffset: number]: Comment[]}}}\n */\nfunction mapCommentsByExtendedRange(comments) {\n  const commentsByExtendedEndOffset = {};\n  const commentsByExtendedStartOffset = {};\n\n  comments.forEach(comment => {\n    const extendedStartOffset = comment.extendedOffset.startOffset;\n    const extendedEndOffset = comment.extendedOffset.endOffset;\n\n    if (commentsByExtendedEndOffset[extendedEndOffset] === undefined) {\n      commentsByExtendedEndOffset[extendedEndOffset] = [comment];\n    } else {\n      commentsByExtendedEndOffset[extendedEndOffset].push(comment);\n    }\n\n    if (commentsByExtendedStartOffset[extendedStartOffset] === undefined) {\n      commentsByExtendedStartOffset[extendedStartOffset] = [comment];\n    } else {\n      commentsByExtendedStartOffset[extendedStartOffset].push(comment);\n    }\n  });\n\n  return { commentsByExtendedEndOffset, commentsByExtendedStartOffset };\n}\n\n/**\n * Determine if a comment should be attached as a trailing comment to a specific node.\n * A comment should be trailing if it is on the same line than the previous token and\n * not on the same line than the next token\n *\n * @param {*} comment\n * @param {CSTNode} node\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n */\nfunction shouldAttachTrailingComments(\n  comment,\n  node,\n  mostEnclosiveCstNodeByStartOffset\n) {\n  if (isPrettierIgnoreComment(comment)) {\n    return false;\n  }\n\n  const nextNode =\n    mostEnclosiveCstNodeByStartOffset[comment.extendedOffset.endOffset];\n\n  // Last node of the file\n  if (nextNode === undefined) {\n    return true;\n  }\n\n  const nodeEndLine =\n    node.location !== undefined ? node.location.endLine : node.endLine;\n\n  if (comment.startLine !== nodeEndLine) {\n    return false;\n  }\n\n  const nextNodeStartLine =\n    nextNode.location !== undefined\n      ? nextNode.location.startLine\n      : nextNode.startLine;\n  return comment.endLine !== nextNodeStartLine;\n}\n\n/**\n * Attach comments to the most enclosive CSTNode (node or token)\n *\n * @param {ITokens[]} tokens\n * @param {*} comments\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n * @param {{[endOffset: number]: CSTNode}} mostEnclosiveCstNodeByEndOffset\n */\nfunction attachComments(\n  tokens,\n  comments,\n  mostEnclosiveCstNodeByStartOffset,\n  mostEnclosiveCstNodeByEndOffset\n) {\n  // Edge case: only comments in the file\n  if (tokens.length === 0) {\n    mostEnclosiveCstNodeByStartOffset[NaN].leadingComments = comments;\n    return;\n  }\n\n  // Pre-processing phase to complete the data structures we need to attach\n  // a comment to the right place\n  completeMostEnclosiveCSTNodeByOffset(\n    tokens,\n    mostEnclosiveCstNodeByStartOffset,\n    mostEnclosiveCstNodeByEndOffset\n  );\n\n  extendRangeOffset(comments, tokens);\n  const {\n    commentsByExtendedStartOffset,\n    commentsByExtendedEndOffset\n  } = mapCommentsByExtendedRange(comments);\n\n  /*\n    This set is here to ensure that we attach comments only once\n    If a comment is attached to a node or token, we remove it from this set\n  */\n  const commentsToAttach = new Set(comments);\n\n  // Attach comments as trailing comments if desirable\n  Object.keys(mostEnclosiveCstNodeByEndOffset).forEach(endOffset => {\n    // We look if some comments is directly following this node/token\n    if (commentsByExtendedStartOffset[endOffset] !== undefined) {\n      const nodeTrailingComments = commentsByExtendedStartOffset[\n        endOffset\n      ].filter(comment => {\n        return (\n          shouldAttachTrailingComments(\n            comment,\n            mostEnclosiveCstNodeByEndOffset[endOffset],\n            mostEnclosiveCstNodeByStartOffset\n          ) && commentsToAttach.has(comment)\n        );\n      });\n\n      if (nodeTrailingComments.length > 0) {\n        mostEnclosiveCstNodeByEndOffset[\n          endOffset\n        ].trailingComments = nodeTrailingComments;\n      }\n\n      nodeTrailingComments.forEach(comment => {\n        commentsToAttach.delete(comment);\n      });\n    }\n  });\n\n  // Attach rest of comments as leading comments\n  Object.keys(mostEnclosiveCstNodeByStartOffset).forEach(startOffset => {\n    // We look if some comments is directly preceding this node/token\n    if (commentsByExtendedEndOffset[startOffset] !== undefined) {\n      const nodeLeadingComments = commentsByExtendedEndOffset[\n        startOffset\n      ].filter(comment => commentsToAttach.has(comment));\n\n      if (nodeLeadingComments.length > 0) {\n        mostEnclosiveCstNodeByStartOffset[\n          startOffset\n        ].leadingComments = nodeLeadingComments;\n      }\n\n      // prettier ignore support\n      for (let i = 0; i < nodeLeadingComments.length; i++) {\n        if (isPrettierIgnoreComment(nodeLeadingComments[i])) {\n          mostEnclosiveCstNodeByStartOffset[startOffset].ignore = true;\n          break;\n        }\n      }\n    }\n  });\n}\n\n/**\n * Create pairs of formatter:off and formatter:on\n * @param comments\n * @returns pairs of formatter:off and formatter:on\n */\nfunction matchFormatterOffOnPairs(comments) {\n  const onOffComments = comments.filter(comment =>\n    isFormatterOffOnComment(comment)\n  );\n\n  let isPreviousCommentOff = false;\n  let isCurrentCommentOff = true;\n  const pairs = [];\n  let paired = {};\n  onOffComments.forEach(comment => {\n    isCurrentCommentOff = comment.image.slice(-3) === \"off\";\n\n    if (!isPreviousCommentOff) {\n      if (isCurrentCommentOff) {\n        paired.off = comment;\n      }\n    } else {\n      if (!isCurrentCommentOff) {\n        paired.on = comment;\n        pairs.push(paired);\n        paired = {};\n      }\n    }\n    isPreviousCommentOff = isCurrentCommentOff;\n  });\n\n  if (onOffComments.length > 0 && isCurrentCommentOff) {\n    paired.on = undefined;\n    pairs.push(paired);\n  }\n\n  return pairs;\n}\n\n/**\n * Check if the node is between formatter:off and formatter:on and change his ignore state\n * @param node\n * @param commentPairs\n */\nfunction shouldNotFormat(node, commentPairs) {\n  const matchingPair = _.findLast(\n    commentPairs,\n    comment => comment.off.endOffset < node.location.startOffset\n  );\n  if (\n    matchingPair !== undefined &&\n    (matchingPair.on === undefined ||\n      matchingPair.on.startOffset > node.location.endOffset)\n  ) {\n    node.ignore = true;\n  }\n}\n\nmodule.exports = {\n  matchFormatterOffOnPairs,\n  shouldNotFormat,\n  attachComments\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL2NvbW1lbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9jb21tZW50cy5qcz8zMDhkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcblxuLyoqXG4gKiBTZWFyY2ggd2hlcmUgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb21tZW50IGluIHRoZSB0b2tlbiBhcnJheSBieVxuICogdXNpbmcgZGljaG90b21pYyBzZWFyY2guXG4gKiBAcGFyYW0geyp9IHRva2VucyBvcmRlcmVkIGFycmF5IG9mIHRva2Vuc1xuICogQHBhcmFtIHsqfSBjb21tZW50IGNvbW1lbnQgdG9rZW5cbiAqIEByZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiBuZXh0IHRvIHRoZSBjb21tZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRVcHBlckJvdW5kVG9rZW4odG9rZW5zLCBjb21tZW50KSB7XG4gIGxldCBkaWZmO1xuICBsZXQgaTtcbiAgbGV0IGN1cnJlbnQ7XG5cbiAgbGV0IGxlbiA9IHRva2Vucy5sZW5ndGg7XG4gIGkgPSAwO1xuXG4gIHdoaWxlIChsZW4pIHtcbiAgICBkaWZmID0gbGVuID4+PiAxO1xuICAgIGN1cnJlbnQgPSBpICsgZGlmZjtcbiAgICBpZiAodG9rZW5zW2N1cnJlbnRdLnN0YXJ0T2Zmc2V0ID4gY29tbWVudC5zdGFydE9mZnNldCkge1xuICAgICAgbGVuID0gZGlmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IGN1cnJlbnQgKyAxO1xuICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gaXNQcmV0dGllcklnbm9yZUNvbW1lbnQoY29tbWVudCkge1xuICByZXR1cm4gY29tbWVudC5pbWFnZS5tYXRjaChcbiAgICAvKFxcL1xcLyhcXHMqKXByZXR0aWVyLWlnbm9yZShcXHMqKSl8KFxcL1xcKihcXHMqKXByZXR0aWVyLWlnbm9yZShcXHMqKVxcKlxcLykvZ21cbiAgKTtcbn1cblxuZnVuY3Rpb24gaXNGb3JtYXR0ZXJPZmZPbkNvbW1lbnQoY29tbWVudCkge1xuICByZXR1cm4gY29tbWVudC5pbWFnZS5tYXRjaChcbiAgICAvKFxcL1xcLyhcXHMqKUBmb3JtYXR0ZXI6KG9mZnxvbikoXFxzKikpfChcXC9cXCooXFxzKilAZm9ybWF0dGVyOihvZmZ8b24pKFxccyopXFwqXFwvKS9nbVxuICApO1xufVxuXG4vKipcbiAqIFByZS1wcm9jZXNzaW5nIG9mIHRva2VucyBpbiBvcmRlciB0b1xuICogY29tcGxldGUgdGhlIHBhcnNlcidzIG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldCBhbmQgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeUVuZE9mZnNldCBzdHJ1Y3R1cmVzLlxuICpcbiAqIEBwYXJhbSB7SVRva2Vuc1tdfSB0b2tlbnMgLSBhcnJheSBvZiB0b2tlbnNcbiAqIEBwYXJhbSB7e1tzdGFydE9mZnNldDogbnVtYmVyXTogQ1NUTm9kZX19IG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldFxuICogQHBhcmFtIHt7W2VuZE9mZnNldDogbnVtYmVyXTogQ1NUTm9kZX19IG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlFbmRPZmZzZXRcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVNb3N0RW5jbG9zaXZlQ1NUTm9kZUJ5T2Zmc2V0KFxuICB0b2tlbnMsXG4gIG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldCxcbiAgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeUVuZE9mZnNldFxuKSB7XG4gIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICBpZiAobW9zdEVuY2xvc2l2ZUNzdE5vZGVCeVN0YXJ0T2Zmc2V0W3Rva2VuLnN0YXJ0T2Zmc2V0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXRbdG9rZW4uc3RhcnRPZmZzZXRdID0gdG9rZW47XG4gICAgfVxuXG4gICAgaWYgKG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlFbmRPZmZzZXRbdG9rZW4uZW5kT2Zmc2V0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5RW5kT2Zmc2V0W3Rva2VuLmVuZE9mZnNldF0gPSB0b2tlbjtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHRlbmRSYW5nZU9mZnNldChjb21tZW50cywgdG9rZW5zKSB7XG4gIGxldCBwb3NpdGlvbjtcbiAgY29tbWVudHMuZm9yRWFjaChjb21tZW50ID0+IHtcbiAgICBwb3NpdGlvbiA9IGZpbmRVcHBlckJvdW5kVG9rZW4odG9rZW5zLCBjb21tZW50KTtcblxuICAgIGNvbnN0IGV4dGVuZGVkU3RhcnRPZmZzZXQgPVxuICAgICAgcG9zaXRpb24gLSAxIDwgMCA/IGNvbW1lbnQuc3RhcnRPZmZzZXQgOiB0b2tlbnNbcG9zaXRpb24gLSAxXS5lbmRPZmZzZXQ7XG4gICAgY29uc3QgZXh0ZW5kZWRFbmRPZmZzZXQgPVxuICAgICAgcG9zaXRpb24gPT0gdG9rZW5zLmxlbmd0aFxuICAgICAgICA/IGNvbW1lbnQuZW5kT2Zmc2V0XG4gICAgICAgIDogdG9rZW5zW3Bvc2l0aW9uXS5zdGFydE9mZnNldDtcbiAgICBjb21tZW50LmV4dGVuZGVkT2Zmc2V0ID0ge1xuICAgICAgc3RhcnRPZmZzZXQ6IGV4dGVuZGVkU3RhcnRPZmZzZXQsXG4gICAgICBlbmRPZmZzZXQ6IGV4dGVuZGVkRW5kT2Zmc2V0XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIHR3byBkYXRhIHN0cnVjdHVyZXMgd2UgdXNlIHRvIGtub3cgYXQgd2hpY2ggb2Zmc2V0IGEgY29tbWVudCBjYW4gYmUgYXR0YWNoZWQuXG4gKiAtIGNvbW1lbnRzQnlFeHRlbmRlZFN0YXJ0T2Zmc2V0OiBtYXAgYSBjb21tZW50IGJ5IHRoZSBlbmRPZmZzZXQgb2YgdGhlIHByZXZpb3VzIHRva2VuLlxuICogLSBjb21tZW50c0J5RXh0ZW5kZWRFbmRPZmZzZXQ6IG1hcCBhIGNvbW1lbnQgYnkgdGhlIHN0YXJ0T2Zmc2V0IG9mIHRoZSBuZXh0IHRva2VuXG4gKlxuICogQHBhcmFtIHtJVG9rZW5zW119IHRva2VucyAtIGFycmF5IG9mIHRva2Vuc1xuICpcbiAqIEByZXR1cm4ge3tjb21tZW50c0J5RXh0ZW5kZWRTdGFydE9mZnNldDoge1tleHRlbmRlZFN0YXJ0T2Zmc2V0OiBudW1iZXJdOiBDb21tZW50W119LCBjb21tZW50c0J5RXh0ZW5kZWRFbmRPZmZzZXQ6IHtbZXh0ZW5kZWRFbmRPZmZzZXQ6IG51bWJlcl06IENvbW1lbnRbXX19fVxuICovXG5mdW5jdGlvbiBtYXBDb21tZW50c0J5RXh0ZW5kZWRSYW5nZShjb21tZW50cykge1xuICBjb25zdCBjb21tZW50c0J5RXh0ZW5kZWRFbmRPZmZzZXQgPSB7fTtcbiAgY29uc3QgY29tbWVudHNCeUV4dGVuZGVkU3RhcnRPZmZzZXQgPSB7fTtcblxuICBjb21tZW50cy5mb3JFYWNoKGNvbW1lbnQgPT4ge1xuICAgIGNvbnN0IGV4dGVuZGVkU3RhcnRPZmZzZXQgPSBjb21tZW50LmV4dGVuZGVkT2Zmc2V0LnN0YXJ0T2Zmc2V0O1xuICAgIGNvbnN0IGV4dGVuZGVkRW5kT2Zmc2V0ID0gY29tbWVudC5leHRlbmRlZE9mZnNldC5lbmRPZmZzZXQ7XG5cbiAgICBpZiAoY29tbWVudHNCeUV4dGVuZGVkRW5kT2Zmc2V0W2V4dGVuZGVkRW5kT2Zmc2V0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb21tZW50c0J5RXh0ZW5kZWRFbmRPZmZzZXRbZXh0ZW5kZWRFbmRPZmZzZXRdID0gW2NvbW1lbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21tZW50c0J5RXh0ZW5kZWRFbmRPZmZzZXRbZXh0ZW5kZWRFbmRPZmZzZXRdLnB1c2goY29tbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1lbnRzQnlFeHRlbmRlZFN0YXJ0T2Zmc2V0W2V4dGVuZGVkU3RhcnRPZmZzZXRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbW1lbnRzQnlFeHRlbmRlZFN0YXJ0T2Zmc2V0W2V4dGVuZGVkU3RhcnRPZmZzZXRdID0gW2NvbW1lbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21tZW50c0J5RXh0ZW5kZWRTdGFydE9mZnNldFtleHRlbmRlZFN0YXJ0T2Zmc2V0XS5wdXNoKGNvbW1lbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29tbWVudHNCeUV4dGVuZGVkRW5kT2Zmc2V0LCBjb21tZW50c0J5RXh0ZW5kZWRTdGFydE9mZnNldCB9O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIGNvbW1lbnQgc2hvdWxkIGJlIGF0dGFjaGVkIGFzIGEgdHJhaWxpbmcgY29tbWVudCB0byBhIHNwZWNpZmljIG5vZGUuXG4gKiBBIGNvbW1lbnQgc2hvdWxkIGJlIHRyYWlsaW5nIGlmIGl0IGlzIG9uIHRoZSBzYW1lIGxpbmUgdGhhbiB0aGUgcHJldmlvdXMgdG9rZW4gYW5kXG4gKiBub3Qgb24gdGhlIHNhbWUgbGluZSB0aGFuIHRoZSBuZXh0IHRva2VuXG4gKlxuICogQHBhcmFtIHsqfSBjb21tZW50XG4gKiBAcGFyYW0ge0NTVE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7e1tzdGFydE9mZnNldDogbnVtYmVyXTogQ1NUTm9kZX19IG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldFxuICovXG5mdW5jdGlvbiBzaG91bGRBdHRhY2hUcmFpbGluZ0NvbW1lbnRzKFxuICBjb21tZW50LFxuICBub2RlLFxuICBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXRcbikge1xuICBpZiAoaXNQcmV0dGllcklnbm9yZUNvbW1lbnQoY29tbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBuZXh0Tm9kZSA9XG4gICAgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeVN0YXJ0T2Zmc2V0W2NvbW1lbnQuZXh0ZW5kZWRPZmZzZXQuZW5kT2Zmc2V0XTtcblxuICAvLyBMYXN0IG5vZGUgb2YgdGhlIGZpbGVcbiAgaWYgKG5leHROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IG5vZGVFbmRMaW5lID1cbiAgICBub2RlLmxvY2F0aW9uICE9PSB1bmRlZmluZWQgPyBub2RlLmxvY2F0aW9uLmVuZExpbmUgOiBub2RlLmVuZExpbmU7XG5cbiAgaWYgKGNvbW1lbnQuc3RhcnRMaW5lICE9PSBub2RlRW5kTGluZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG5leHROb2RlU3RhcnRMaW5lID1cbiAgICBuZXh0Tm9kZS5sb2NhdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IG5leHROb2RlLmxvY2F0aW9uLnN0YXJ0TGluZVxuICAgICAgOiBuZXh0Tm9kZS5zdGFydExpbmU7XG4gIHJldHVybiBjb21tZW50LmVuZExpbmUgIT09IG5leHROb2RlU3RhcnRMaW5lO1xufVxuXG4vKipcbiAqIEF0dGFjaCBjb21tZW50cyB0byB0aGUgbW9zdCBlbmNsb3NpdmUgQ1NUTm9kZSAobm9kZSBvciB0b2tlbilcbiAqXG4gKiBAcGFyYW0ge0lUb2tlbnNbXX0gdG9rZW5zXG4gKiBAcGFyYW0geyp9IGNvbW1lbnRzXG4gKiBAcGFyYW0ge3tbc3RhcnRPZmZzZXQ6IG51bWJlcl06IENTVE5vZGV9fSBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXRcbiAqIEBwYXJhbSB7e1tlbmRPZmZzZXQ6IG51bWJlcl06IENTVE5vZGV9fSBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5RW5kT2Zmc2V0XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaENvbW1lbnRzKFxuICB0b2tlbnMsXG4gIGNvbW1lbnRzLFxuICBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXQsXG4gIG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlFbmRPZmZzZXRcbikge1xuICAvLyBFZGdlIGNhc2U6IG9ubHkgY29tbWVudHMgaW4gdGhlIGZpbGVcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXRbTmFOXS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQcmUtcHJvY2Vzc2luZyBwaGFzZSB0byBjb21wbGV0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIHdlIG5lZWQgdG8gYXR0YWNoXG4gIC8vIGEgY29tbWVudCB0byB0aGUgcmlnaHQgcGxhY2VcbiAgY29tcGxldGVNb3N0RW5jbG9zaXZlQ1NUTm9kZUJ5T2Zmc2V0KFxuICAgIHRva2VucyxcbiAgICBtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXQsXG4gICAgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeUVuZE9mZnNldFxuICApO1xuXG4gIGV4dGVuZFJhbmdlT2Zmc2V0KGNvbW1lbnRzLCB0b2tlbnMpO1xuICBjb25zdCB7XG4gICAgY29tbWVudHNCeUV4dGVuZGVkU3RhcnRPZmZzZXQsXG4gICAgY29tbWVudHNCeUV4dGVuZGVkRW5kT2Zmc2V0XG4gIH0gPSBtYXBDb21tZW50c0J5RXh0ZW5kZWRSYW5nZShjb21tZW50cyk7XG5cbiAgLypcbiAgICBUaGlzIHNldCBpcyBoZXJlIHRvIGVuc3VyZSB0aGF0IHdlIGF0dGFjaCBjb21tZW50cyBvbmx5IG9uY2VcbiAgICBJZiBhIGNvbW1lbnQgaXMgYXR0YWNoZWQgdG8gYSBub2RlIG9yIHRva2VuLCB3ZSByZW1vdmUgaXQgZnJvbSB0aGlzIHNldFxuICAqL1xuICBjb25zdCBjb21tZW50c1RvQXR0YWNoID0gbmV3IFNldChjb21tZW50cyk7XG5cbiAgLy8gQXR0YWNoIGNvbW1lbnRzIGFzIHRyYWlsaW5nIGNvbW1lbnRzIGlmIGRlc2lyYWJsZVxuICBPYmplY3Qua2V5cyhtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5RW5kT2Zmc2V0KS5mb3JFYWNoKGVuZE9mZnNldCA9PiB7XG4gICAgLy8gV2UgbG9vayBpZiBzb21lIGNvbW1lbnRzIGlzIGRpcmVjdGx5IGZvbGxvd2luZyB0aGlzIG5vZGUvdG9rZW5cbiAgICBpZiAoY29tbWVudHNCeUV4dGVuZGVkU3RhcnRPZmZzZXRbZW5kT2Zmc2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBub2RlVHJhaWxpbmdDb21tZW50cyA9IGNvbW1lbnRzQnlFeHRlbmRlZFN0YXJ0T2Zmc2V0W1xuICAgICAgICBlbmRPZmZzZXRcbiAgICAgIF0uZmlsdGVyKGNvbW1lbnQgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNob3VsZEF0dGFjaFRyYWlsaW5nQ29tbWVudHMoXG4gICAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgICAgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeUVuZE9mZnNldFtlbmRPZmZzZXRdLFxuICAgICAgICAgICAgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeVN0YXJ0T2Zmc2V0XG4gICAgICAgICAgKSAmJiBjb21tZW50c1RvQXR0YWNoLmhhcyhjb21tZW50KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChub2RlVHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlFbmRPZmZzZXRbXG4gICAgICAgICAgZW5kT2Zmc2V0XG4gICAgICAgIF0udHJhaWxpbmdDb21tZW50cyA9IG5vZGVUcmFpbGluZ0NvbW1lbnRzO1xuICAgICAgfVxuXG4gICAgICBub2RlVHJhaWxpbmdDb21tZW50cy5mb3JFYWNoKGNvbW1lbnQgPT4ge1xuICAgICAgICBjb21tZW50c1RvQXR0YWNoLmRlbGV0ZShjb21tZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQXR0YWNoIHJlc3Qgb2YgY29tbWVudHMgYXMgbGVhZGluZyBjb21tZW50c1xuICBPYmplY3Qua2V5cyhtb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5U3RhcnRPZmZzZXQpLmZvckVhY2goc3RhcnRPZmZzZXQgPT4ge1xuICAgIC8vIFdlIGxvb2sgaWYgc29tZSBjb21tZW50cyBpcyBkaXJlY3RseSBwcmVjZWRpbmcgdGhpcyBub2RlL3Rva2VuXG4gICAgaWYgKGNvbW1lbnRzQnlFeHRlbmRlZEVuZE9mZnNldFtzdGFydE9mZnNldF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgbm9kZUxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzQnlFeHRlbmRlZEVuZE9mZnNldFtcbiAgICAgICAgc3RhcnRPZmZzZXRcbiAgICAgIF0uZmlsdGVyKGNvbW1lbnQgPT4gY29tbWVudHNUb0F0dGFjaC5oYXMoY29tbWVudCkpO1xuXG4gICAgICBpZiAobm9kZUxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldFtcbiAgICAgICAgICBzdGFydE9mZnNldFxuICAgICAgICBdLmxlYWRpbmdDb21tZW50cyA9IG5vZGVMZWFkaW5nQ29tbWVudHM7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXR0aWVyIGlnbm9yZSBzdXBwb3J0XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVMZWFkaW5nQ29tbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzUHJldHRpZXJJZ25vcmVDb21tZW50KG5vZGVMZWFkaW5nQ29tbWVudHNbaV0pKSB7XG4gICAgICAgICAgbW9zdEVuY2xvc2l2ZUNzdE5vZGVCeVN0YXJ0T2Zmc2V0W3N0YXJ0T2Zmc2V0XS5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGFpcnMgb2YgZm9ybWF0dGVyOm9mZiBhbmQgZm9ybWF0dGVyOm9uXG4gKiBAcGFyYW0gY29tbWVudHNcbiAqIEByZXR1cm5zIHBhaXJzIG9mIGZvcm1hdHRlcjpvZmYgYW5kIGZvcm1hdHRlcjpvblxuICovXG5mdW5jdGlvbiBtYXRjaEZvcm1hdHRlck9mZk9uUGFpcnMoY29tbWVudHMpIHtcbiAgY29uc3Qgb25PZmZDb21tZW50cyA9IGNvbW1lbnRzLmZpbHRlcihjb21tZW50ID0+XG4gICAgaXNGb3JtYXR0ZXJPZmZPbkNvbW1lbnQoY29tbWVudClcbiAgKTtcblxuICBsZXQgaXNQcmV2aW91c0NvbW1lbnRPZmYgPSBmYWxzZTtcbiAgbGV0IGlzQ3VycmVudENvbW1lbnRPZmYgPSB0cnVlO1xuICBjb25zdCBwYWlycyA9IFtdO1xuICBsZXQgcGFpcmVkID0ge307XG4gIG9uT2ZmQ29tbWVudHMuZm9yRWFjaChjb21tZW50ID0+IHtcbiAgICBpc0N1cnJlbnRDb21tZW50T2ZmID0gY29tbWVudC5pbWFnZS5zbGljZSgtMykgPT09IFwib2ZmXCI7XG5cbiAgICBpZiAoIWlzUHJldmlvdXNDb21tZW50T2ZmKSB7XG4gICAgICBpZiAoaXNDdXJyZW50Q29tbWVudE9mZikge1xuICAgICAgICBwYWlyZWQub2ZmID0gY29tbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc0N1cnJlbnRDb21tZW50T2ZmKSB7XG4gICAgICAgIHBhaXJlZC5vbiA9IGNvbW1lbnQ7XG4gICAgICAgIHBhaXJzLnB1c2gocGFpcmVkKTtcbiAgICAgICAgcGFpcmVkID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIGlzUHJldmlvdXNDb21tZW50T2ZmID0gaXNDdXJyZW50Q29tbWVudE9mZjtcbiAgfSk7XG5cbiAgaWYgKG9uT2ZmQ29tbWVudHMubGVuZ3RoID4gMCAmJiBpc0N1cnJlbnRDb21tZW50T2ZmKSB7XG4gICAgcGFpcmVkLm9uID0gdW5kZWZpbmVkO1xuICAgIHBhaXJzLnB1c2gocGFpcmVkKTtcbiAgfVxuXG4gIHJldHVybiBwYWlycztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbm9kZSBpcyBiZXR3ZWVuIGZvcm1hdHRlcjpvZmYgYW5kIGZvcm1hdHRlcjpvbiBhbmQgY2hhbmdlIGhpcyBpZ25vcmUgc3RhdGVcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gY29tbWVudFBhaXJzXG4gKi9cbmZ1bmN0aW9uIHNob3VsZE5vdEZvcm1hdChub2RlLCBjb21tZW50UGFpcnMpIHtcbiAgY29uc3QgbWF0Y2hpbmdQYWlyID0gXy5maW5kTGFzdChcbiAgICBjb21tZW50UGFpcnMsXG4gICAgY29tbWVudCA9PiBjb21tZW50Lm9mZi5lbmRPZmZzZXQgPCBub2RlLmxvY2F0aW9uLnN0YXJ0T2Zmc2V0XG4gICk7XG4gIGlmIChcbiAgICBtYXRjaGluZ1BhaXIgIT09IHVuZGVmaW5lZCAmJlxuICAgIChtYXRjaGluZ1BhaXIub24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgbWF0Y2hpbmdQYWlyLm9uLnN0YXJ0T2Zmc2V0ID4gbm9kZS5sb2NhdGlvbi5lbmRPZmZzZXQpXG4gICkge1xuICAgIG5vZGUuaWdub3JlID0gdHJ1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2hGb3JtYXR0ZXJPZmZPblBhaXJzLFxuICBzaG91bGROb3RGb3JtYXQsXG4gIGF0dGFjaENvbW1lbnRzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/comments.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/java-parser/src/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst JavaLexer = __webpack_require__(/*! ./lexer */ \"./node_modules/java-parser/src/lexer.js\");\nconst JavaParser = __webpack_require__(/*! ./parser */ \"./node_modules/java-parser/src/parser.js\");\nconst { attachComments, matchFormatterOffOnPairs } = __webpack_require__(/*! ./comments */ \"./node_modules/java-parser/src/comments.js\");\n\nconst parser = new JavaParser();\n\nconst BaseJavaCstVisitor = parser.getBaseCstVisitorConstructor();\nconst BaseJavaCstVisitorWithDefaults = parser.getBaseCstVisitorConstructorWithDefaults();\n\nfunction parse(inputText, entryPoint = \"compilationUnit\") {\n  // Lex\n  const lexResult = JavaLexer.tokenize(inputText);\n\n  if (lexResult.errors.length > 0) {\n    const firstError = lexResult.errors[0];\n    throw Error(\n      \"Sad sad panda, lexing errors detected in line: \" +\n        firstError.line +\n        \", column: \" +\n        firstError.column +\n        \"!\\n\" +\n        firstError.message\n    );\n  }\n\n  parser.input = lexResult.tokens;\n  parser.mostEnclosiveCstNodeByStartOffset = {};\n  parser.mostEnclosiveCstNodeByEndOffset = {};\n\n  parser.setOnOffCommentPairs(\n    matchFormatterOffOnPairs(lexResult.groups.comments)\n  );\n\n  // Automatic CST created when parsing\n  const cst = parser[entryPoint]();\n\n  if (parser.errors.length > 0) {\n    const error = parser.errors[0];\n    throw Error(\n      \"Sad sad panda, parsing errors detected in line: \" +\n        error.token.startLine +\n        \", column: \" +\n        error.token.startColumn +\n        \"!\\n\" +\n        error.message +\n        \"!\\n\\t->\" +\n        error.context.ruleStack.join(\"\\n\\t->\")\n    );\n  }\n\n  attachComments(\n    lexResult.tokens,\n    lexResult.groups.comments,\n    parser.mostEnclosiveCstNodeByStartOffset,\n    parser.mostEnclosiveCstNodeByEndOffset\n  );\n\n  return cst;\n}\n\nmodule.exports = {\n  parse,\n  BaseJavaCstVisitor,\n  BaseJavaCstVisitorWithDefaults\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9pbmRleC5qcz9mN2YwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgSmF2YUxleGVyID0gcmVxdWlyZShcIi4vbGV4ZXJcIik7XG5jb25zdCBKYXZhUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuY29uc3QgeyBhdHRhY2hDb21tZW50cywgbWF0Y2hGb3JtYXR0ZXJPZmZPblBhaXJzIH0gPSByZXF1aXJlKFwiLi9jb21tZW50c1wiKTtcblxuY29uc3QgcGFyc2VyID0gbmV3IEphdmFQYXJzZXIoKTtcblxuY29uc3QgQmFzZUphdmFDc3RWaXNpdG9yID0gcGFyc2VyLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKTtcbmNvbnN0IEJhc2VKYXZhQ3N0VmlzaXRvcldpdGhEZWZhdWx0cyA9IHBhcnNlci5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzKCk7XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0VGV4dCwgZW50cnlQb2ludCA9IFwiY29tcGlsYXRpb25Vbml0XCIpIHtcbiAgLy8gTGV4XG4gIGNvbnN0IGxleFJlc3VsdCA9IEphdmFMZXhlci50b2tlbml6ZShpbnB1dFRleHQpO1xuXG4gIGlmIChsZXhSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmaXJzdEVycm9yID0gbGV4UmVzdWx0LmVycm9yc1swXTtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiU2FkIHNhZCBwYW5kYSwgbGV4aW5nIGVycm9ycyBkZXRlY3RlZCBpbiBsaW5lOiBcIiArXG4gICAgICAgIGZpcnN0RXJyb3IubGluZSArXG4gICAgICAgIFwiLCBjb2x1bW46IFwiICtcbiAgICAgICAgZmlyc3RFcnJvci5jb2x1bW4gK1xuICAgICAgICBcIiFcXG5cIiArXG4gICAgICAgIGZpcnN0RXJyb3IubWVzc2FnZVxuICAgICk7XG4gIH1cblxuICBwYXJzZXIuaW5wdXQgPSBsZXhSZXN1bHQudG9rZW5zO1xuICBwYXJzZXIubW9zdEVuY2xvc2l2ZUNzdE5vZGVCeVN0YXJ0T2Zmc2V0ID0ge307XG4gIHBhcnNlci5tb3N0RW5jbG9zaXZlQ3N0Tm9kZUJ5RW5kT2Zmc2V0ID0ge307XG5cbiAgcGFyc2VyLnNldE9uT2ZmQ29tbWVudFBhaXJzKFxuICAgIG1hdGNoRm9ybWF0dGVyT2ZmT25QYWlycyhsZXhSZXN1bHQuZ3JvdXBzLmNvbW1lbnRzKVxuICApO1xuXG4gIC8vIEF1dG9tYXRpYyBDU1QgY3JlYXRlZCB3aGVuIHBhcnNpbmdcbiAgY29uc3QgY3N0ID0gcGFyc2VyW2VudHJ5UG9pbnRdKCk7XG5cbiAgaWYgKHBhcnNlci5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGVycm9yID0gcGFyc2VyLmVycm9yc1swXTtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiU2FkIHNhZCBwYW5kYSwgcGFyc2luZyBlcnJvcnMgZGV0ZWN0ZWQgaW4gbGluZTogXCIgK1xuICAgICAgICBlcnJvci50b2tlbi5zdGFydExpbmUgK1xuICAgICAgICBcIiwgY29sdW1uOiBcIiArXG4gICAgICAgIGVycm9yLnRva2VuLnN0YXJ0Q29sdW1uICtcbiAgICAgICAgXCIhXFxuXCIgK1xuICAgICAgICBlcnJvci5tZXNzYWdlICtcbiAgICAgICAgXCIhXFxuXFx0LT5cIiArXG4gICAgICAgIGVycm9yLmNvbnRleHQucnVsZVN0YWNrLmpvaW4oXCJcXG5cXHQtPlwiKVxuICAgICk7XG4gIH1cblxuICBhdHRhY2hDb21tZW50cyhcbiAgICBsZXhSZXN1bHQudG9rZW5zLFxuICAgIGxleFJlc3VsdC5ncm91cHMuY29tbWVudHMsXG4gICAgcGFyc2VyLm1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldCxcbiAgICBwYXJzZXIubW9zdEVuY2xvc2l2ZUNzdE5vZGVCeUVuZE9mZnNldFxuICApO1xuXG4gIHJldHVybiBjc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgQmFzZUphdmFDc3RWaXNpdG9yLFxuICBCYXNlSmF2YUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/index.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/lexer.js":
/*!***********************************************!*\
  !*** ./node_modules/java-parser/src/lexer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst chevrotain = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\nconst { allTokens } = __webpack_require__(/*! ./tokens */ \"./node_modules/java-parser/src/tokens.js\");\nconst { getSkipValidations } = __webpack_require__(/*! ./utils */ \"./node_modules/java-parser/src/utils.js\");\n\nconst Lexer = chevrotain.Lexer;\nconst JavaLexer = new Lexer(allTokens, {\n  ensureOptimizations: true,\n  skipValidations: getSkipValidations()\n});\n\nmodule.exports = JavaLexer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL2xleGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9sZXhlci5qcz84YTU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgY2hldnJvdGFpbiA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xuY29uc3QgeyBhbGxUb2tlbnMgfSA9IHJlcXVpcmUoXCIuL3Rva2Vuc1wiKTtcbmNvbnN0IHsgZ2V0U2tpcFZhbGlkYXRpb25zIH0gPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxuY29uc3QgTGV4ZXIgPSBjaGV2cm90YWluLkxleGVyO1xuY29uc3QgSmF2YUxleGVyID0gbmV3IExleGVyKGFsbFRva2Vucywge1xuICBlbnN1cmVPcHRpbWl6YXRpb25zOiB0cnVlLFxuICBza2lwVmFsaWRhdGlvbnM6IGdldFNraXBWYWxpZGF0aW9ucygpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBKYXZhTGV4ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/lexer.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/parser.js":
/*!************************************************!*\
  !*** ./node_modules/java-parser/src/parser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst { Parser, isRecognitionException } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\nconst { allTokens, tokens: t } = __webpack_require__(/*! ./tokens */ \"./node_modules/java-parser/src/tokens.js\");\nconst lexicalStructure = __webpack_require__(/*! ./productions/lexical-structure */ \"./node_modules/java-parser/src/productions/lexical-structure.js\");\nconst typesValuesVariables = __webpack_require__(/*! ./productions/types-values-and-variables */ \"./node_modules/java-parser/src/productions/types-values-and-variables.js\");\nconst names = __webpack_require__(/*! ./productions/names */ \"./node_modules/java-parser/src/productions/names.js\");\nconst packagesModules = __webpack_require__(/*! ./productions/packages-and-modules */ \"./node_modules/java-parser/src/productions/packages-and-modules.js\");\nconst classes = __webpack_require__(/*! ./productions/classes */ \"./node_modules/java-parser/src/productions/classes.js\");\nconst interfaces = __webpack_require__(/*! ./productions/interfaces */ \"./node_modules/java-parser/src/productions/interfaces.js\");\nconst arrays = __webpack_require__(/*! ./productions/arrays */ \"./node_modules/java-parser/src/productions/arrays.js\");\nconst blocksStatements = __webpack_require__(/*! ./productions/blocks-and-statements */ \"./node_modules/java-parser/src/productions/blocks-and-statements.js\");\nconst expressions = __webpack_require__(/*! ./productions/expressions */ \"./node_modules/java-parser/src/productions/expressions.js\");\nconst { getSkipValidations } = __webpack_require__(/*! ./utils */ \"./node_modules/java-parser/src/utils.js\");\nconst { shouldNotFormat } = __webpack_require__(/*! ./comments */ \"./node_modules/java-parser/src/comments.js\");\n\n/**\n * This parser attempts to strongly align with the specs style at:\n * -  https://docs.oracle.com/javase/specs/jls/se11/html/jls-19.html\n *\n * Deviations from the spec will be marked.\n *\n * Note that deviations from the spec do not mean deviations from Java Grammar.\n * Rather it means an **equivalent** grammar which was written differently, e.g:\n * - LL(k) vs LR(K)\n * - Left Recursions vs Repetitions\n * - NonTerminals combined together or divided to sub-NonTerminals\n * - ...\n *\n * A special type of spec deviations are the \"super grammar\" kind.\n * This means that the parser has been defined in such a way that it accept a\n * **strict superset** of the inputs the official grammar accepts.\n *\n * This technique is used to simplify the parser when narrowing the set\n * of accepted inputs can more easily be done in a post parsing phase.\n *\n * TODO: document guide lines for using back tracking\n *\n */\nclass JavaParser extends Parser {\n  constructor() {\n    super(allTokens, {\n      maxLookahead: 1,\n      nodeLocationTracking: \"full\",\n      // traceInitPerf: 2,\n      skipValidations: getSkipValidations()\n    });\n\n    const $ = this;\n\n    this.mostEnclosiveCstNodeByStartOffset = {};\n    this.mostEnclosiveCstNodeByEndOffset = {};\n\n    // ---------------------\n    // Productions from 3 (Lexical Structure)\n    // ---------------------\n    // TODO: move this rule to the correct file\n    $.RULE(\"typeIdentifier\", () => {\n      // TODO: implement: Identifier but not var in the lexer\n      $.CONSUME(t.Identifier);\n    });\n\n    // Include the productions from all \"chapters\".\n    lexicalStructure.defineRules.call(this, $, t);\n    typesValuesVariables.defineRules.call(this, $, t);\n    names.defineRules.call(this, $, t);\n    classes.defineRules.call(this, $, t);\n    packagesModules.defineRules.call(this, $, t);\n    interfaces.defineRules.call(this, $, t);\n    arrays.defineRules.call(this, $, t);\n    blocksStatements.defineRules.call(this, $, t);\n    expressions.defineRules.call(this, $, t);\n\n    this.firstForUnaryExpressionNotPlusMinus = [];\n    this.performSelfAnalysis();\n    this.firstForUnaryExpressionNotPlusMinus = expressions.computeFirstForUnaryExpressionNotPlusMinus.call(\n      this\n    );\n  }\n\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    super.cstPostNonTerminal(ruleCstResult, ruleName);\n    if (this.isBackTracking() === false) {\n      this.mostEnclosiveCstNodeByStartOffset[\n        ruleCstResult.location.startOffset\n      ] = ruleCstResult;\n      this.mostEnclosiveCstNodeByEndOffset[\n        ruleCstResult.location.endOffset\n      ] = ruleCstResult;\n\n      shouldNotFormat(ruleCstResult, this.onOffCommentPairs);\n    }\n  }\n\n  BACKTRACK_LOOKAHEAD(production, errValue = false) {\n    return this.ACTION(() => {\n      this.isBackTrackingStack.push(1);\n      // TODO: \"saveRecogState\" does not handle the occurrence stack\n      const orgState = this.saveRecogState();\n      try {\n        // hack to enable outputting none CST values from grammar rules.\n        this.outputCst = false;\n        return production.call(this);\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return errValue;\n        }\n        throw e;\n      } finally {\n        this.outputCst = true;\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    });\n  }\n\n  setOnOffCommentPairs(onOffCommentPairs) {\n    this.onOffCommentPairs = onOffCommentPairs;\n  }\n}\n\nmodule.exports = JavaParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3BhcnNlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qYXZhLXBhcnNlci9zcmMvcGFyc2VyLmpzPzc2YzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IFBhcnNlciwgaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9ID0gcmVxdWlyZShcImNoZXZyb3RhaW5cIik7XG5jb25zdCB7IGFsbFRva2VucywgdG9rZW5zOiB0IH0gPSByZXF1aXJlKFwiLi90b2tlbnNcIik7XG5jb25zdCBsZXhpY2FsU3RydWN0dXJlID0gcmVxdWlyZShcIi4vcHJvZHVjdGlvbnMvbGV4aWNhbC1zdHJ1Y3R1cmVcIik7XG5jb25zdCB0eXBlc1ZhbHVlc1ZhcmlhYmxlcyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25zL3R5cGVzLXZhbHVlcy1hbmQtdmFyaWFibGVzXCIpO1xuY29uc3QgbmFtZXMgPSByZXF1aXJlKFwiLi9wcm9kdWN0aW9ucy9uYW1lc1wiKTtcbmNvbnN0IHBhY2thZ2VzTW9kdWxlcyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25zL3BhY2thZ2VzLWFuZC1tb2R1bGVzXCIpO1xuY29uc3QgY2xhc3NlcyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25zL2NsYXNzZXNcIik7XG5jb25zdCBpbnRlcmZhY2VzID0gcmVxdWlyZShcIi4vcHJvZHVjdGlvbnMvaW50ZXJmYWNlc1wiKTtcbmNvbnN0IGFycmF5cyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25zL2FycmF5c1wiKTtcbmNvbnN0IGJsb2Nrc1N0YXRlbWVudHMgPSByZXF1aXJlKFwiLi9wcm9kdWN0aW9ucy9ibG9ja3MtYW5kLXN0YXRlbWVudHNcIik7XG5jb25zdCBleHByZXNzaW9ucyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25zL2V4cHJlc3Npb25zXCIpO1xuY29uc3QgeyBnZXRTa2lwVmFsaWRhdGlvbnMgfSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgeyBzaG91bGROb3RGb3JtYXQgfSA9IHJlcXVpcmUoXCIuL2NvbW1lbnRzXCIpO1xuXG4vKipcbiAqIFRoaXMgcGFyc2VyIGF0dGVtcHRzIHRvIHN0cm9uZ2x5IGFsaWduIHdpdGggdGhlIHNwZWNzIHN0eWxlIGF0OlxuICogLSAgaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE5Lmh0bWxcbiAqXG4gKiBEZXZpYXRpb25zIGZyb20gdGhlIHNwZWMgd2lsbCBiZSBtYXJrZWQuXG4gKlxuICogTm90ZSB0aGF0IGRldmlhdGlvbnMgZnJvbSB0aGUgc3BlYyBkbyBub3QgbWVhbiBkZXZpYXRpb25zIGZyb20gSmF2YSBHcmFtbWFyLlxuICogUmF0aGVyIGl0IG1lYW5zIGFuICoqZXF1aXZhbGVudCoqIGdyYW1tYXIgd2hpY2ggd2FzIHdyaXR0ZW4gZGlmZmVyZW50bHksIGUuZzpcbiAqIC0gTEwoaykgdnMgTFIoSylcbiAqIC0gTGVmdCBSZWN1cnNpb25zIHZzIFJlcGV0aXRpb25zXG4gKiAtIE5vblRlcm1pbmFscyBjb21iaW5lZCB0b2dldGhlciBvciBkaXZpZGVkIHRvIHN1Yi1Ob25UZXJtaW5hbHNcbiAqIC0gLi4uXG4gKlxuICogQSBzcGVjaWFsIHR5cGUgb2Ygc3BlYyBkZXZpYXRpb25zIGFyZSB0aGUgXCJzdXBlciBncmFtbWFyXCIga2luZC5cbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgcGFyc2VyIGhhcyBiZWVuIGRlZmluZWQgaW4gc3VjaCBhIHdheSB0aGF0IGl0IGFjY2VwdCBhXG4gKiAqKnN0cmljdCBzdXBlcnNldCoqIG9mIHRoZSBpbnB1dHMgdGhlIG9mZmljaWFsIGdyYW1tYXIgYWNjZXB0cy5cbiAqXG4gKiBUaGlzIHRlY2huaXF1ZSBpcyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBwYXJzZXIgd2hlbiBuYXJyb3dpbmcgdGhlIHNldFxuICogb2YgYWNjZXB0ZWQgaW5wdXRzIGNhbiBtb3JlIGVhc2lseSBiZSBkb25lIGluIGEgcG9zdCBwYXJzaW5nIHBoYXNlLlxuICpcbiAqIFRPRE86IGRvY3VtZW50IGd1aWRlIGxpbmVzIGZvciB1c2luZyBiYWNrIHRyYWNraW5nXG4gKlxuICovXG5jbGFzcyBKYXZhUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYWxsVG9rZW5zLCB7XG4gICAgICBtYXhMb29rYWhlYWQ6IDEsXG4gICAgICBub2RlTG9jYXRpb25UcmFja2luZzogXCJmdWxsXCIsXG4gICAgICAvLyB0cmFjZUluaXRQZXJmOiAyLFxuICAgICAgc2tpcFZhbGlkYXRpb25zOiBnZXRTa2lwVmFsaWRhdGlvbnMoKVxuICAgIH0pO1xuXG4gICAgY29uc3QgJCA9IHRoaXM7XG5cbiAgICB0aGlzLm1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldCA9IHt9O1xuICAgIHRoaXMubW9zdEVuY2xvc2l2ZUNzdE5vZGVCeUVuZE9mZnNldCA9IHt9O1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvZHVjdGlvbnMgZnJvbSDCpzMgKExleGljYWwgU3RydWN0dXJlKVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBydWxlIHRvIHRoZSBjb3JyZWN0IGZpbGVcbiAgICAkLlJVTEUoXCJ0eXBlSWRlbnRpZmllclwiLCAoKSA9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQ6IElkZW50aWZpZXIgYnV0IG5vdCB2YXIgaW4gdGhlIGxleGVyXG4gICAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgICB9KTtcblxuICAgIC8vIEluY2x1ZGUgdGhlIHByb2R1Y3Rpb25zIGZyb20gYWxsIFwiY2hhcHRlcnNcIi5cbiAgICBsZXhpY2FsU3RydWN0dXJlLmRlZmluZVJ1bGVzLmNhbGwodGhpcywgJCwgdCk7XG4gICAgdHlwZXNWYWx1ZXNWYXJpYWJsZXMuZGVmaW5lUnVsZXMuY2FsbCh0aGlzLCAkLCB0KTtcbiAgICBuYW1lcy5kZWZpbmVSdWxlcy5jYWxsKHRoaXMsICQsIHQpO1xuICAgIGNsYXNzZXMuZGVmaW5lUnVsZXMuY2FsbCh0aGlzLCAkLCB0KTtcbiAgICBwYWNrYWdlc01vZHVsZXMuZGVmaW5lUnVsZXMuY2FsbCh0aGlzLCAkLCB0KTtcbiAgICBpbnRlcmZhY2VzLmRlZmluZVJ1bGVzLmNhbGwodGhpcywgJCwgdCk7XG4gICAgYXJyYXlzLmRlZmluZVJ1bGVzLmNhbGwodGhpcywgJCwgdCk7XG4gICAgYmxvY2tzU3RhdGVtZW50cy5kZWZpbmVSdWxlcy5jYWxsKHRoaXMsICQsIHQpO1xuICAgIGV4cHJlc3Npb25zLmRlZmluZVJ1bGVzLmNhbGwodGhpcywgJCwgdCk7XG5cbiAgICB0aGlzLmZpcnN0Rm9yVW5hcnlFeHByZXNzaW9uTm90UGx1c01pbnVzID0gW107XG4gICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gICAgdGhpcy5maXJzdEZvclVuYXJ5RXhwcmVzc2lvbk5vdFBsdXNNaW51cyA9IGV4cHJlc3Npb25zLmNvbXB1dGVGaXJzdEZvclVuYXJ5RXhwcmVzc2lvbk5vdFBsdXNNaW51cy5jYWxsKFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cblxuICBjc3RQb3N0Tm9uVGVybWluYWwocnVsZUNzdFJlc3VsdCwgcnVsZU5hbWUpIHtcbiAgICBzdXBlci5jc3RQb3N0Tm9uVGVybWluYWwocnVsZUNzdFJlc3VsdCwgcnVsZU5hbWUpO1xuICAgIGlmICh0aGlzLmlzQmFja1RyYWNraW5nKCkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm1vc3RFbmNsb3NpdmVDc3ROb2RlQnlTdGFydE9mZnNldFtcbiAgICAgICAgcnVsZUNzdFJlc3VsdC5sb2NhdGlvbi5zdGFydE9mZnNldFxuICAgICAgXSA9IHJ1bGVDc3RSZXN1bHQ7XG4gICAgICB0aGlzLm1vc3RFbmNsb3NpdmVDc3ROb2RlQnlFbmRPZmZzZXRbXG4gICAgICAgIHJ1bGVDc3RSZXN1bHQubG9jYXRpb24uZW5kT2Zmc2V0XG4gICAgICBdID0gcnVsZUNzdFJlc3VsdDtcblxuICAgICAgc2hvdWxkTm90Rm9ybWF0KHJ1bGVDc3RSZXN1bHQsIHRoaXMub25PZmZDb21tZW50UGFpcnMpO1xuICAgIH1cbiAgfVxuXG4gIEJBQ0tUUkFDS19MT09LQUhFQUQocHJvZHVjdGlvbiwgZXJyVmFsdWUgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLkFDVElPTigoKSA9PiB7XG4gICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucHVzaCgxKTtcbiAgICAgIC8vIFRPRE86IFwic2F2ZVJlY29nU3RhdGVcIiBkb2VzIG5vdCBoYW5kbGUgdGhlIG9jY3VycmVuY2Ugc3RhY2tcbiAgICAgIGNvbnN0IG9yZ1N0YXRlID0gdGhpcy5zYXZlUmVjb2dTdGF0ZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gaGFjayB0byBlbmFibGUgb3V0cHV0dGluZyBub25lIENTVCB2YWx1ZXMgZnJvbSBncmFtbWFyIHJ1bGVzLlxuICAgICAgICB0aGlzLm91dHB1dENzdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcHJvZHVjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5vdXRwdXRDc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbG9hZFJlY29nU3RhdGUob3JnU3RhdGUpO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRPbk9mZkNvbW1lbnRQYWlycyhvbk9mZkNvbW1lbnRQYWlycykge1xuICAgIHRoaXMub25PZmZDb21tZW50UGFpcnMgPSBvbk9mZkNvbW1lbnRQYWlycztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEphdmFQYXJzZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/parser.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/arrays.js":
/*!************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/arrays.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\n\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-10.html#jls-ArrayInitializer\n  $.RULE(\"arrayInitializer\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.variableInitializerList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-10.html#jls-VariableInitializerList\n  $.RULE(\"variableInitializerList\", () => {\n    $.SUBRULE($.variableInitializer);\n    $.MANY({\n      // The optional last \"Comma\" of an \"arrayInitializer\"\n      GATE: () => tokenMatcher(this.LA(2).tokenType, t.RCurly) === false,\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.variableInitializer);\n      }\n    });\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2FycmF5cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qYXZhLXBhcnNlci9zcmMvcHJvZHVjdGlvbnMvYXJyYXlzLmpzP2I2ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgdG9rZW5NYXRjaGVyIH0gPSByZXF1aXJlKFwiY2hldnJvdGFpblwiKTtcblxuZnVuY3Rpb24gZGVmaW5lUnVsZXMoJCwgdCkge1xuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTAuaHRtbCNqbHMtQXJyYXlJbml0aWFsaXplclxuICAkLlJVTEUoXCJhcnJheUluaXRpYWxpemVyXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5MQ3VybHkpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlSW5pdGlhbGl6ZXJMaXN0KTtcbiAgICB9KTtcbiAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlJDdXJseSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xMC5odG1sI2pscy1WYXJpYWJsZUluaXRpYWxpemVyTGlzdFxuICAkLlJVTEUoXCJ2YXJpYWJsZUluaXRpYWxpemVyTGlzdFwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQudmFyaWFibGVJbml0aWFsaXplcik7XG4gICAgJC5NQU5ZKHtcbiAgICAgIC8vIFRoZSBvcHRpb25hbCBsYXN0IFwiQ29tbWFcIiBvZiBhbiBcImFycmF5SW5pdGlhbGl6ZXJcIlxuICAgICAgR0FURTogKCkgPT4gdG9rZW5NYXRjaGVyKHRoaXMuTEEoMikudG9rZW5UeXBlLCB0LlJDdXJseSkgPT09IGZhbHNlLFxuICAgICAgREVGOiAoKSA9PiB7XG4gICAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICAgICAgJC5TVUJSVUxFMigkLnZhcmlhYmxlSW5pdGlhbGl6ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVJ1bGVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/arrays.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/blocks-and-statements.js":
/*!***************************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/blocks-and-statements.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\n\n// Spec Deviation: The \"*NoShortIf\" variations were removed as the ambiguity of\n//                 the dangling else is resolved by attaching an \"else\" block\n//                 to the nearest \"if\"\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-Block\n  $.RULE(\"block\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.blockStatements);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-BlockStatements\n  $.RULE(\"blockStatements\", () => {\n    $.SUBRULE($.blockStatement);\n    $.MANY(() => {\n      $.SUBRULE2($.blockStatement);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-BlockStatement\n  $.RULE(\"blockStatement\", () => {\n    const isLocalVariableDeclaration = this.BACKTRACK_LOOKAHEAD(\n      $.isLocalVariableDeclaration\n    );\n\n    const isClassDeclaration = this.BACKTRACK_LOOKAHEAD($.isClassDeclaration);\n\n    $.OR([\n      {\n        GATE: () => isLocalVariableDeclaration,\n        ALT: () => $.SUBRULE($.localVariableDeclarationStatement)\n      },\n      {\n        GATE: () => isClassDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      { ALT: () => $.SUBRULE($.statement) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-LocalVariableDeclaration\n  $.RULE(\"localVariableDeclarationStatement\", () => {\n    $.SUBRULE($.localVariableDeclaration);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-LocalVariableDeclaration\n  $.RULE(\"localVariableDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.SUBRULE($.variableDeclaratorList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-LocalVariableType\n  $.RULE(\"localVariableType\", () => {\n    $.OR({\n      DEF: [\n        { ALT: () => $.SUBRULE($.unannType) },\n        { ALT: () => $.CONSUME(t.Var) }\n      ],\n      IGNORE_AMBIGUITIES: true\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-Statement\n  $.RULE(\"statement\", () => {\n    $.OR({\n      DEF: [\n        { ALT: () => $.SUBRULE($.statementWithoutTrailingSubstatement) },\n        { ALT: () => $.SUBRULE($.labeledStatement) },\n        // Spec deviation: combined \"IfThenStatement\" and \"IfThenElseStatement\"\n        { ALT: () => $.SUBRULE($.ifStatement) },\n        { ALT: () => $.SUBRULE($.whileStatement) },\n        { ALT: () => $.SUBRULE($.forStatement) }\n      ],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-StatementWithoutTrailingSubstatement\n  $.RULE(\"statementWithoutTrailingSubstatement\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.block) },\n      { ALT: () => $.SUBRULE($.emptyStatement) },\n      { ALT: () => $.SUBRULE($.expressionStatement) },\n      { ALT: () => $.SUBRULE($.assertStatement) },\n      { ALT: () => $.SUBRULE($.switchStatement) },\n      { ALT: () => $.SUBRULE($.doStatement) },\n      { ALT: () => $.SUBRULE($.breakStatement) },\n      { ALT: () => $.SUBRULE($.continueStatement) },\n      { ALT: () => $.SUBRULE($.returnStatement) },\n      { ALT: () => $.SUBRULE($.synchronizedStatement) },\n      { ALT: () => $.SUBRULE($.throwStatement) },\n      { ALT: () => $.SUBRULE($.tryStatement) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-EmptyStatement\n  $.RULE(\"emptyStatement\", () => {\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-LabeledStatement\n  $.RULE(\"labeledStatement\", () => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Colon);\n    $.SUBRULE($.statement);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ExpressionStatement\n  $.RULE(\"expressionStatement\", () => {\n    $.SUBRULE($.statementExpression);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-StatementExpression\n  $.RULE(\"statementExpression\", () => {\n    // Spec deviation: The many alternatives here were replaced with\n    //                 the \"expression\" rule as it contains them all,\n    //                 and distinguishing between the alternatives cannot be done\n    //                 using a fixed lookahead.\n    // TODO: verify the resulting expression is one of the valid alternatives?\n    $.SUBRULE($.expression);\n  });\n\n  // Spec deviation: combined \"IfThenStatement\" and \"IfThenElseStatement\"\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-IfThenStatement\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-IfThenElseStatement\n  $.RULE(\"ifStatement\", () => {\n    $.CONSUME(t.If);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n    $.OPTION(() => {\n      $.CONSUME(t.Else);\n      $.SUBRULE2($.statement);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-AssertStatement\n  $.RULE(\"assertStatement\", () => {\n    $.CONSUME(t.Assert);\n    $.SUBRULE($.expression);\n    $.OPTION(() => {\n      $.CONSUME(t.Colon);\n      $.SUBRULE2($.expression);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-SwitchStatement\n  $.RULE(\"switchStatement\", () => {\n    $.CONSUME(t.Switch);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.switchBlock);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-SwitchBlock\n  $.RULE(\"switchBlock\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      // Spec Deviation: refactored \"switchBlock\" for easy post-processing\n      //                 each case and block together in the same rule.\n      $.SUBRULE($.switchCase);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  $.RULE(\"switchCase\", () => {\n    $.SUBRULE($.switchLabel);\n    $.OPTION(() => {\n      $.SUBRULE($.blockStatements);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-SwitchLabel\n  $.RULE(\"switchLabel\", () => {\n    $.OR([\n      {\n        ALT: () => {\n          $.CONSUME(t.Case);\n          $.SUBRULE($.constantExpression);\n          $.CONSUME(t.Colon);\n        }\n      },\n      // SPEC Deviation: the variant with \"enumConstantName\" was removed\n      // as it can be matched by the \"constantExpression\" variant\n      // the distinction is semantic not syntactic.\n      {\n        ALT: () => {\n          $.CONSUME(t.Default);\n          $.CONSUME3(t.Colon);\n        }\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-EnumConstantName\n  $.RULE(\"enumConstantName\", () => {\n    $.CONSUME(t.Identifier);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-WhileStatement\n  $.RULE(\"whileStatement\", () => {\n    $.CONSUME(t.While);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-DoStatement\n  $.RULE(\"doStatement\", () => {\n    $.CONSUME(t.Do);\n    $.SUBRULE($.statement);\n    $.CONSUME(t.While);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.CONSUME(t.Semicolon);\n  });\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ForStatement\n  $.RULE(\"forStatement\", () => {\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isBasicForStatement),\n        ALT: () => $.SUBRULE($.basicForStatement)\n      },\n      { ALT: () => $.SUBRULE($.enhancedForStatement) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-BasicForStatement\n  $.RULE(\"basicForStatement\", () => {\n    $.CONSUME(t.For);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.forInit);\n    });\n    $.CONSUME(t.Semicolon);\n    $.OPTION2(() => {\n      $.SUBRULE($.expression);\n    });\n    $.CONSUME2(t.Semicolon);\n    $.OPTION3(() => {\n      $.SUBRULE($.forUpdate);\n    });\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ForInit\n  $.RULE(\"forInit\", () => {\n    $.OR([\n      {\n        GATE: () => $.BACKTRACK_LOOKAHEAD($.isLocalVariableDeclaration),\n        ALT: () => $.SUBRULE($.localVariableDeclaration)\n      },\n      { ALT: () => $.SUBRULE($.statementExpressionList) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ForUpdate\n  $.RULE(\"forUpdate\", () => {\n    $.SUBRULE($.statementExpressionList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-StatementExpressionList\n  $.RULE(\"statementExpressionList\", () => {\n    $.SUBRULE($.statementExpression);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.statementExpression);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-EnhancedForStatement\n  $.RULE(\"enhancedForStatement\", () => {\n    $.CONSUME(t.For);\n    $.CONSUME(t.LBrace);\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.SUBRULE($.variableDeclaratorId);\n    $.CONSUME(t.Colon);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.statement);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-BreakStatement\n  $.RULE(\"breakStatement\", () => {\n    $.CONSUME(t.Break);\n    $.OPTION(() => {\n      $.CONSUME(t.Identifier);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ContinueStatement\n  $.RULE(\"continueStatement\", () => {\n    $.CONSUME(t.Continue);\n    $.OPTION(() => {\n      $.CONSUME(t.Identifier);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ReturnStatement\n  $.RULE(\"returnStatement\", () => {\n    $.CONSUME(t.Return);\n    $.OPTION(() => {\n      $.SUBRULE($.expression);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ThrowStatement\n  $.RULE(\"throwStatement\", () => {\n    $.CONSUME(t.Throw);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-SynchronizedStatement\n  $.RULE(\"synchronizedStatement\", () => {\n    $.CONSUME(t.Synchronized);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.block);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-TryStatement\n  $.RULE(\"tryStatement\", () => {\n    $.OR({\n      DEF: [\n        {\n          ALT: () => {\n            $.CONSUME(t.Try);\n            $.SUBRULE($.block);\n            $.OR2([\n              {\n                ALT: () => {\n                  $.SUBRULE($.catches);\n                  $.OPTION(() => {\n                    $.SUBRULE($.finally);\n                  });\n                }\n              },\n              { ALT: () => $.SUBRULE2($.finally) }\n            ]);\n          }\n        },\n        { ALT: () => $.SUBRULE($.tryWithResourcesStatement) }\n      ],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-Catches\n  $.RULE(\"catches\", () => {\n    $.SUBRULE($.catchClause);\n    $.MANY(() => {\n      $.SUBRULE2($.catchClause);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-CatchClause\n  $.RULE(\"catchClause\", () => {\n    $.CONSUME(t.Catch);\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.catchFormalParameter);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.block);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-CatchFormalParameter\n  $.RULE(\"catchFormalParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.catchType);\n    $.SUBRULE($.variableDeclaratorId);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-CatchType\n  $.RULE(\"catchType\", () => {\n    $.SUBRULE($.unannClassType);\n    $.MANY(() => {\n      $.CONSUME(t.Or);\n      $.SUBRULE2($.classType);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-Finally\n  $.RULE(\"finally\", () => {\n    $.CONSUME(t.Finally);\n    $.SUBRULE($.block);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-TryWithResourcesStatement\n  $.RULE(\"tryWithResourcesStatement\", () => {\n    $.CONSUME(t.Try);\n    $.SUBRULE($.resourceSpecification);\n    $.SUBRULE($.block);\n    $.OPTION(() => {\n      $.SUBRULE($.catches);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.finally);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ResourceSpecification\n  $.RULE(\"resourceSpecification\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.resourceList);\n    $.OPTION(() => {\n      $.CONSUME(t.Semicolon);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-ResourceList\n  $.RULE(\"resourceList\", () => {\n    $.SUBRULE($.resource);\n    $.MANY({\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RBrace) === false,\n      DEF: () => {\n        $.CONSUME(t.Semicolon);\n        $.SUBRULE2($.resource);\n      }\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-Resource\n  $.RULE(\"resource\", () => {\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.resourceInit),\n        // Spec Deviation: extracted this alternative to \"resourceInit\"\n        //                 to enable backtracking.\n        ALT: () => $.SUBRULE($.resourceInit)\n      },\n      { ALT: () => $.SUBRULE($.variableAccess) }\n    ]);\n  });\n\n  // Spec Deviation: extracted from \"resource\"\n  $.RULE(\"resourceInit\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Equals);\n    $.SUBRULE($.expression);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-VariableAccess\n  $.RULE(\"variableAccess\", () => {\n    // Spec Deviation: both \"expressionName\" and \"fieldAccess\" can be parsed\n    //                 by the \"primary\" rule\n    // TODO: verify that the primary is a fieldAccess or an expressionName.\n    $.SUBRULE($.primary);\n  });\n\n  // ------------------------------------\n  // Special optimized backtracking rules.\n  // ------------------------------------\n  $.RULE(\"isBasicForStatement\", () => {\n    $.CONSUME(t.For);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.forInit);\n    });\n    $.CONSUME(t.Semicolon);\n    // consuming the first semiColon distinguishes between\n    // \"basic\" and \"enhanced\" for statements\n    return true;\n  });\n\n  $.RULE(\"isLocalVariableDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.localVariableType);\n    $.SUBRULE($.variableDeclaratorId);\n\n    const nextTokenType = this.LA(1).tokenType;\n    switch (nextTokenType) {\n      // Int x;\n      case t.Semicolon:\n      // Int x, y, z;\n      case t.Comma:\n      // Int x = 5;\n      case t.Equals:\n        return true;\n      default:\n        return false;\n    }\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2Jsb2Nrcy1hbmQtc3RhdGVtZW50cy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qYXZhLXBhcnNlci9zcmMvcHJvZHVjdGlvbnMvYmxvY2tzLWFuZC1zdGF0ZW1lbnRzLmpzPzc3NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgdG9rZW5NYXRjaGVyIH0gPSByZXF1aXJlKFwiY2hldnJvdGFpblwiKTtcblxuLy8gU3BlYyBEZXZpYXRpb246IFRoZSBcIipOb1Nob3J0SWZcIiB2YXJpYXRpb25zIHdlcmUgcmVtb3ZlZCBhcyB0aGUgYW1iaWd1aXR5IG9mXG4vLyAgICAgICAgICAgICAgICAgdGhlIGRhbmdsaW5nIGVsc2UgaXMgcmVzb2x2ZWQgYnkgYXR0YWNoaW5nIGFuIFwiZWxzZVwiIGJsb2NrXG4vLyAgICAgICAgICAgICAgICAgdG8gdGhlIG5lYXJlc3QgXCJpZlwiXG5mdW5jdGlvbiBkZWZpbmVSdWxlcygkLCB0KSB7XG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1CbG9ja1xuICAkLlJVTEUoXCJibG9ja1wiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTEN1cmx5KTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5ibG9ja1N0YXRlbWVudHMpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlJDdXJseSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1CbG9ja1N0YXRlbWVudHNcbiAgJC5SVUxFKFwiYmxvY2tTdGF0ZW1lbnRzXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5ibG9ja1N0YXRlbWVudCk7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRTIoJC5ibG9ja1N0YXRlbWVudCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1CbG9ja1N0YXRlbWVudFxuICAkLlJVTEUoXCJibG9ja1N0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgY29uc3QgaXNMb2NhbFZhcmlhYmxlRGVjbGFyYXRpb24gPSB0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoXG4gICAgICAkLmlzTG9jYWxWYXJpYWJsZURlY2xhcmF0aW9uXG4gICAgKTtcblxuICAgIGNvbnN0IGlzQ2xhc3NEZWNsYXJhdGlvbiA9IHRoaXMuQkFDS1RSQUNLX0xPT0tBSEVBRCgkLmlzQ2xhc3NEZWNsYXJhdGlvbik7XG5cbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gaXNMb2NhbFZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQubG9jYWxWYXJpYWJsZURlY2xhcmF0aW9uU3RhdGVtZW50KVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gaXNDbGFzc0RlY2xhcmF0aW9uLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmNsYXNzRGVjbGFyYXRpb24pXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnN0YXRlbWVudCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtTG9jYWxWYXJpYWJsZURlY2xhcmF0aW9uXG4gICQuUlVMRShcImxvY2FsVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQubG9jYWxWYXJpYWJsZURlY2xhcmF0aW9uKTtcbiAgICAkLkNPTlNVTUUodC5TZW1pY29sb24pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtTG9jYWxWYXJpYWJsZURlY2xhcmF0aW9uXG4gICQuUlVMRShcImxvY2FsVmFyaWFibGVEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLmxvY2FsVmFyaWFibGVUeXBlKTtcbiAgICAkLlNVQlJVTEUoJC52YXJpYWJsZURlY2xhcmF0b3JMaXN0KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLUxvY2FsVmFyaWFibGVUeXBlXG4gICQuUlVMRShcImxvY2FsVmFyaWFibGVUeXBlXCIsICgpID0+IHtcbiAgICAkLk9SKHtcbiAgICAgIERFRjogW1xuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudW5hbm5UeXBlKSB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVmFyKSB9XG4gICAgICBdLFxuICAgICAgSUdOT1JFX0FNQklHVUlUSUVTOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1TdGF0ZW1lbnRcbiAgJC5SVUxFKFwic3RhdGVtZW50XCIsICgpID0+IHtcbiAgICAkLk9SKHtcbiAgICAgIERFRjogW1xuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuc3RhdGVtZW50V2l0aG91dFRyYWlsaW5nU3Vic3RhdGVtZW50KSB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQubGFiZWxlZFN0YXRlbWVudCkgfSxcbiAgICAgICAgLy8gU3BlYyBkZXZpYXRpb246IGNvbWJpbmVkIFwiSWZUaGVuU3RhdGVtZW50XCIgYW5kIFwiSWZUaGVuRWxzZVN0YXRlbWVudFwiXG4gICAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5pZlN0YXRlbWVudCkgfSxcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLndoaWxlU3RhdGVtZW50KSB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuZm9yU3RhdGVtZW50KSB9XG4gICAgICBdLFxuICAgICAgTUFYX0xPT0tBSEVBRDogMlxuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtU3RhdGVtZW50V2l0aG91dFRyYWlsaW5nU3Vic3RhdGVtZW50XG4gICQuUlVMRShcInN0YXRlbWVudFdpdGhvdXRUcmFpbGluZ1N1YnN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYmxvY2spIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuZW1wdHlTdGF0ZW1lbnQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuZXhwcmVzc2lvblN0YXRlbWVudCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hc3NlcnRTdGF0ZW1lbnQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuc3dpdGNoU3RhdGVtZW50KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmRvU3RhdGVtZW50KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmJyZWFrU3RhdGVtZW50KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmNvbnRpbnVlU3RhdGVtZW50KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnJldHVyblN0YXRlbWVudCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5zeW5jaHJvbml6ZWRTdGF0ZW1lbnQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudGhyb3dTdGF0ZW1lbnQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudHJ5U3RhdGVtZW50KSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1FbXB0eVN0YXRlbWVudFxuICAkLlJVTEUoXCJlbXB0eVN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuU2VtaWNvbG9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLUxhYmVsZWRTdGF0ZW1lbnRcbiAgJC5SVUxFKFwibGFiZWxlZFN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5DT05TVU1FKHQuQ29sb24pO1xuICAgICQuU1VCUlVMRSgkLnN0YXRlbWVudCk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1FeHByZXNzaW9uU3RhdGVtZW50XG4gICQuUlVMRShcImV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnN0YXRlbWVudEV4cHJlc3Npb24pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1TdGF0ZW1lbnRFeHByZXNzaW9uXG4gICQuUlVMRShcInN0YXRlbWVudEV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgZGV2aWF0aW9uOiBUaGUgbWFueSBhbHRlcm5hdGl2ZXMgaGVyZSB3ZXJlIHJlcGxhY2VkIHdpdGhcbiAgICAvLyAgICAgICAgICAgICAgICAgdGhlIFwiZXhwcmVzc2lvblwiIHJ1bGUgYXMgaXQgY29udGFpbnMgdGhlbSBhbGwsXG4gICAgLy8gICAgICAgICAgICAgICAgIGFuZCBkaXN0aW5ndWlzaGluZyBiZXR3ZWVuIHRoZSBhbHRlcm5hdGl2ZXMgY2Fubm90IGJlIGRvbmVcbiAgICAvLyAgICAgICAgICAgICAgICAgdXNpbmcgYSBmaXhlZCBsb29rYWhlYWQuXG4gICAgLy8gVE9ETzogdmVyaWZ5IHRoZSByZXN1bHRpbmcgZXhwcmVzc2lvbiBpcyBvbmUgb2YgdGhlIHZhbGlkIGFsdGVybmF0aXZlcz9cbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgfSk7XG5cbiAgLy8gU3BlYyBkZXZpYXRpb246IGNvbWJpbmVkIFwiSWZUaGVuU3RhdGVtZW50XCIgYW5kIFwiSWZUaGVuRWxzZVN0YXRlbWVudFwiXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1JZlRoZW5TdGF0ZW1lbnRcbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLUlmVGhlbkVsc2VTdGF0ZW1lbnRcbiAgJC5SVUxFKFwiaWZTdGF0ZW1lbnRcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LklmKTtcbiAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICAgICQuQ09OU1VNRSh0LlJCcmFjZSk7XG4gICAgJC5TVUJSVUxFKCQuc3RhdGVtZW50KTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5FbHNlKTtcbiAgICAgICQuU1VCUlVMRTIoJC5zdGF0ZW1lbnQpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtQXNzZXJ0U3RhdGVtZW50XG4gICQuUlVMRShcImFzc2VydFN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuQXNzZXJ0KTtcbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db2xvbik7XG4gICAgICAkLlNVQlJVTEUyKCQuZXhwcmVzc2lvbik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuU2VtaWNvbG9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLVN3aXRjaFN0YXRlbWVudFxuICAkLlJVTEUoXCJzd2l0Y2hTdGF0ZW1lbnRcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LlN3aXRjaCk7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLnN3aXRjaEJsb2NrKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLVN3aXRjaEJsb2NrXG4gICQuUlVMRShcInN3aXRjaEJsb2NrXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5MQ3VybHkpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAvLyBTcGVjIERldmlhdGlvbjogcmVmYWN0b3JlZCBcInN3aXRjaEJsb2NrXCIgZm9yIGVhc3kgcG9zdC1wcm9jZXNzaW5nXG4gICAgICAvLyAgICAgICAgICAgICAgICAgZWFjaCBjYXNlIGFuZCBibG9jayB0b2dldGhlciBpbiB0aGUgc2FtZSBydWxlLlxuICAgICAgJC5TVUJSVUxFKCQuc3dpdGNoQ2FzZSk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUkN1cmx5KTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwic3dpdGNoQ2FzZVwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQuc3dpdGNoTGFiZWwpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmJsb2NrU3RhdGVtZW50cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1Td2l0Y2hMYWJlbFxuICAkLlJVTEUoXCJzd2l0Y2hMYWJlbFwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICQuQ09OU1VNRSh0LkNhc2UpO1xuICAgICAgICAgICQuU1VCUlVMRSgkLmNvbnN0YW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgJC5DT05TVU1FKHQuQ29sb24pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gU1BFQyBEZXZpYXRpb246IHRoZSB2YXJpYW50IHdpdGggXCJlbnVtQ29uc3RhbnROYW1lXCIgd2FzIHJlbW92ZWRcbiAgICAgIC8vIGFzIGl0IGNhbiBiZSBtYXRjaGVkIGJ5IHRoZSBcImNvbnN0YW50RXhwcmVzc2lvblwiIHZhcmlhbnRcbiAgICAgIC8vIHRoZSBkaXN0aW5jdGlvbiBpcyBzZW1hbnRpYyBub3Qgc3ludGFjdGljLlxuICAgICAge1xuICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICAkLkNPTlNVTUUodC5EZWZhdWx0KTtcbiAgICAgICAgICAkLkNPTlNVTUUzKHQuQ29sb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1FbnVtQ29uc3RhbnROYW1lXG4gICQuUlVMRShcImVudW1Db25zdGFudE5hbWVcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtV2hpbGVTdGF0ZW1lbnRcbiAgJC5SVUxFKFwid2hpbGVTdGF0ZW1lbnRcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LldoaWxlKTtcbiAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICAgICQuQ09OU1VNRSh0LlJCcmFjZSk7XG4gICAgJC5TVUJSVUxFKCQuc3RhdGVtZW50KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLURvU3RhdGVtZW50XG4gICQuUlVMRShcImRvU3RhdGVtZW50XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5Ebyk7XG4gICAgJC5TVUJSVUxFKCQuc3RhdGVtZW50KTtcbiAgICAkLkNPTlNVTUUodC5XaGlsZSk7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtRm9yU3RhdGVtZW50XG4gICQuUlVMRShcImZvclN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+IHRoaXMuQkFDS1RSQUNLX0xPT0tBSEVBRCgkLmlzQmFzaWNGb3JTdGF0ZW1lbnQpLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmJhc2ljRm9yU3RhdGVtZW50KVxuICAgICAgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5lbmhhbmNlZEZvclN0YXRlbWVudCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtQmFzaWNGb3JTdGF0ZW1lbnRcbiAgJC5SVUxFKFwiYmFzaWNGb3JTdGF0ZW1lbnRcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkZvcik7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5mb3JJbml0KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5TZW1pY29sb24pO1xuICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUyKHQuU2VtaWNvbG9uKTtcbiAgICAkLk9QVElPTjMoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuZm9yVXBkYXRlKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLnN0YXRlbWVudCk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1Gb3JJbml0XG4gICQuUlVMRShcImZvckluaXRcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiAkLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc0xvY2FsVmFyaWFibGVEZWNsYXJhdGlvbiksXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQubG9jYWxWYXJpYWJsZURlY2xhcmF0aW9uKVxuICAgICAgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5zdGF0ZW1lbnRFeHByZXNzaW9uTGlzdCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtRm9yVXBkYXRlXG4gICQuUlVMRShcImZvclVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQuc3RhdGVtZW50RXhwcmVzc2lvbkxpc3QpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtU3RhdGVtZW50RXhwcmVzc2lvbkxpc3RcbiAgJC5SVUxFKFwic3RhdGVtZW50RXhwcmVzc2lvbkxpc3RcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnN0YXRlbWVudEV4cHJlc3Npb24pO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgICAkLlNVQlJVTEUyKCQuc3RhdGVtZW50RXhwcmVzc2lvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1FbmhhbmNlZEZvclN0YXRlbWVudFxuICAkLlJVTEUoXCJlbmhhbmNlZEZvclN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuRm9yKTtcbiAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC52YXJpYWJsZU1vZGlmaWVyKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5sb2NhbFZhcmlhYmxlVHlwZSk7XG4gICAgJC5TVUJSVUxFKCQudmFyaWFibGVEZWNsYXJhdG9ySWQpO1xuICAgICQuQ09OU1VNRSh0LkNvbG9uKTtcbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLnN0YXRlbWVudCk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1CcmVha1N0YXRlbWVudFxuICAkLlJVTEUoXCJicmVha1N0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuQnJlYWspO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1Db250aW51ZVN0YXRlbWVudFxuICAkLlJVTEUoXCJjb250aW51ZVN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuQ29udGludWUpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1SZXR1cm5TdGF0ZW1lbnRcbiAgJC5SVUxFKFwicmV0dXJuU3RhdGVtZW50XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5SZXR1cm4pO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1UaHJvd1N0YXRlbWVudFxuICAkLlJVTEUoXCJ0aHJvd1N0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuVGhyb3cpO1xuICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1TeW5jaHJvbml6ZWRTdGF0ZW1lbnRcbiAgJC5SVUxFKFwic3luY2hyb25pemVkU3RhdGVtZW50XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5TeW5jaHJvbml6ZWQpO1xuICAgICQuQ09OU1VNRSh0LkxCcmFjZSk7XG4gICAgJC5TVUJSVUxFKCQuZXhwcmVzc2lvbik7XG4gICAgJC5DT05TVU1FKHQuUkJyYWNlKTtcbiAgICAkLlNVQlJVTEUoJC5ibG9jayk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1UcnlTdGF0ZW1lbnRcbiAgJC5SVUxFKFwidHJ5U3RhdGVtZW50XCIsICgpID0+IHtcbiAgICAkLk9SKHtcbiAgICAgIERFRjogW1xuICAgICAgICB7XG4gICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICAkLkNPTlNVTUUodC5UcnkpO1xuICAgICAgICAgICAgJC5TVUJSVUxFKCQuYmxvY2spO1xuICAgICAgICAgICAgJC5PUjIoW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAkLlNVQlJVTEUoJC5jYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJC5TVUJSVUxFKCQuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUyKCQuZmluYWxseSkgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudHJ5V2l0aFJlc291cmNlc1N0YXRlbWVudCkgfVxuICAgICAgXSxcbiAgICAgIE1BWF9MT09LQUhFQUQ6IDJcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLUNhdGNoZXNcbiAgJC5SVUxFKFwiY2F0Y2hlc1wiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQuY2F0Y2hDbGF1c2UpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUyKCQuY2F0Y2hDbGF1c2UpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtQ2F0Y2hDbGF1c2VcbiAgJC5SVUxFKFwiY2F0Y2hDbGF1c2VcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkNhdGNoKTtcbiAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLmNhdGNoRm9ybWFsUGFyYW1ldGVyKTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLmJsb2NrKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLUNhdGNoRm9ybWFsUGFyYW1ldGVyXG4gICQuUlVMRShcImNhdGNoRm9ybWFsUGFyYW1ldGVyXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudmFyaWFibGVNb2RpZmllcik7XG4gICAgfSk7XG4gICAgJC5TVUJSVUxFKCQuY2F0Y2hUeXBlKTtcbiAgICAkLlNVQlJVTEUoJC52YXJpYWJsZURlY2xhcmF0b3JJZCk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1DYXRjaFR5cGVcbiAgJC5SVUxFKFwiY2F0Y2hUeXBlXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC51bmFubkNsYXNzVHlwZSk7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0Lk9yKTtcbiAgICAgICQuU1VCUlVMRTIoJC5jbGFzc1R5cGUpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtRmluYWxseVxuICAkLlJVTEUoXCJmaW5hbGx5XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5GaW5hbGx5KTtcbiAgICAkLlNVQlJVTEUoJC5ibG9jayk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1UcnlXaXRoUmVzb3VyY2VzU3RhdGVtZW50XG4gICQuUlVMRShcInRyeVdpdGhSZXNvdXJjZXNTdGF0ZW1lbnRcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LlRyeSk7XG4gICAgJC5TVUJSVUxFKCQucmVzb3VyY2VTcGVjaWZpY2F0aW9uKTtcbiAgICAkLlNVQlJVTEUoJC5ibG9jayk7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuY2F0Y2hlcyk7XG4gICAgfSk7XG4gICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmZpbmFsbHkpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtUmVzb3VyY2VTcGVjaWZpY2F0aW9uXG4gICQuUlVMRShcInJlc291cmNlU3BlY2lmaWNhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLlNVQlJVTEUoJC5yZXNvdXJjZUxpc3QpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUkJyYWNlKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE0Lmh0bWwjamxzLVJlc291cmNlTGlzdFxuICAkLlJVTEUoXCJyZXNvdXJjZUxpc3RcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnJlc291cmNlKTtcbiAgICAkLk1BTlkoe1xuICAgICAgR0FURTogKCkgPT4gdG9rZW5NYXRjaGVyKCQuTEEoMikudG9rZW5UeXBlLCB0LlJCcmFjZSkgPT09IGZhbHNlLFxuICAgICAgREVGOiAoKSA9PiB7XG4gICAgICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gICAgICAgICQuU1VCUlVMRTIoJC5yZXNvdXJjZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNC5odG1sI2pscy1SZXNvdXJjZVxuICAkLlJVTEUoXCJyZXNvdXJjZVwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICQuQkFDS1RSQUNLKCQucmVzb3VyY2VJbml0KSxcbiAgICAgICAgLy8gU3BlYyBEZXZpYXRpb246IGV4dHJhY3RlZCB0aGlzIGFsdGVybmF0aXZlIHRvIFwicmVzb3VyY2VJbml0XCJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRvIGVuYWJsZSBiYWNrdHJhY2tpbmcuXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQucmVzb3VyY2VJbml0KVxuICAgICAgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC52YXJpYWJsZUFjY2VzcykgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBTcGVjIERldmlhdGlvbjogZXh0cmFjdGVkIGZyb20gXCJyZXNvdXJjZVwiXG4gICQuUlVMRShcInJlc291cmNlSW5pdFwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLmxvY2FsVmFyaWFibGVUeXBlKTtcbiAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgICAkLkNPTlNVTUUodC5FcXVhbHMpO1xuICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTQuaHRtbCNqbHMtVmFyaWFibGVBY2Nlc3NcbiAgJC5SVUxFKFwidmFyaWFibGVBY2Nlc3NcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBib3RoIFwiZXhwcmVzc2lvbk5hbWVcIiBhbmQgXCJmaWVsZEFjY2Vzc1wiIGNhbiBiZSBwYXJzZWRcbiAgICAvLyAgICAgICAgICAgICAgICAgYnkgdGhlIFwicHJpbWFyeVwiIHJ1bGVcbiAgICAvLyBUT0RPOiB2ZXJpZnkgdGhhdCB0aGUgcHJpbWFyeSBpcyBhIGZpZWxkQWNjZXNzIG9yIGFuIGV4cHJlc3Npb25OYW1lLlxuICAgICQuU1VCUlVMRSgkLnByaW1hcnkpO1xuICB9KTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3BlY2lhbCBvcHRpbWl6ZWQgYmFja3RyYWNraW5nIHJ1bGVzLlxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgJC5SVUxFKFwiaXNCYXNpY0ZvclN0YXRlbWVudFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuRm9yKTtcbiAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmZvckluaXQpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gICAgLy8gY29uc3VtaW5nIHRoZSBmaXJzdCBzZW1pQ29sb24gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuXG4gICAgLy8gXCJiYXNpY1wiIGFuZCBcImVuaGFuY2VkXCIgZm9yIHN0YXRlbWVudHNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiaXNMb2NhbFZhcmlhYmxlRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC52YXJpYWJsZU1vZGlmaWVyKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5sb2NhbFZhcmlhYmxlVHlwZSk7XG4gICAgJC5TVUJSVUxFKCQudmFyaWFibGVEZWNsYXJhdG9ySWQpO1xuXG4gICAgY29uc3QgbmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuICAgIHN3aXRjaCAobmV4dFRva2VuVHlwZSkge1xuICAgICAgLy8gSW50IHg7XG4gICAgICBjYXNlIHQuU2VtaWNvbG9uOlxuICAgICAgLy8gSW50IHgsIHksIHo7XG4gICAgICBjYXNlIHQuQ29tbWE6XG4gICAgICAvLyBJbnQgeCA9IDU7XG4gICAgICBjYXNlIHQuRXF1YWxzOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmaW5lUnVsZXNcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/blocks-and-statements.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/classes.js":
/*!*************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/classes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { isRecognitionException, tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\n\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ClassDeclaration\n  $.RULE(\"classDeclaration\", () => {\n    // Spec Deviation: extracted common \"{classModifier}\" prefix\n    //      extraction is safe because there are no other references to\n    //      \"normalClassDeclaration\" and \"enumDeclaration\"\n    $.MANY(() => {\n      $.SUBRULE($.classModifier);\n    });\n    $.OR([\n      { ALT: () => $.SUBRULE($.normalClassDeclaration) },\n      { ALT: () => $.SUBRULE($.enumDeclaration) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-NormalClassDeclaration\n  $.RULE(\"normalClassDeclaration\", () => {\n    // Spec Deviation: extracted common \"{classModifier}\" to \"classDeclaration\"\n    $.CONSUME(t.Class);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.superclass);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.superinterfaces);\n    });\n    $.SUBRULE($.classBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ClassModifier\n  $.RULE(\"classModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-TypeParameters\n  $.RULE(\"typeParameters\", () => {\n    $.CONSUME(t.Less);\n    $.SUBRULE($.typeParameterList);\n    $.CONSUME(t.Greater);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-TypeParameterList\n  $.RULE(\"typeParameterList\", () => {\n    $.SUBRULE($.typeParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.typeParameter);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-Superclass\n  $.RULE(\"superclass\", () => {\n    $.CONSUME(t.Extends);\n    $.SUBRULE($.classType);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-Superinterfaces\n  $.RULE(\"superinterfaces\", () => {\n    $.CONSUME(t.Implements);\n    $.SUBRULE($.interfaceTypeList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-InterfaceTypeList\n  $.RULE(\"interfaceTypeList\", () => {\n    $.SUBRULE($.interfaceType);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.interfaceType);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ClassBody\n  $.RULE(\"classBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.classBodyDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  const classBodyTypes = {\n    unknown: 0,\n    fieldDeclaration: 1,\n    methodDeclaration: 2,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5,\n    instanceInitializer: 6,\n    staticInitializer: 7,\n    constructorDeclaration: 8\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ClassBodyDeclaration\n  $.RULE(\"classBodyDeclaration\", () => {\n    const nextRuleType = $.BACKTRACK_LOOKAHEAD(\n      $.identifyClassBodyDeclarationType\n    );\n\n    $.OR([\n      {\n        GATE: () =>\n          nextRuleType >= classBodyTypes.fieldDeclaration &&\n          nextRuleType <= classBodyTypes.semiColon,\n        ALT: () => $.SUBRULE($.classMemberDeclaration, { ARGS: [nextRuleType] })\n      },\n      // no gate needed for the initializers because these are LL(1) rules.\n      { ALT: () => $.SUBRULE($.instanceInitializer) },\n      { ALT: () => $.SUBRULE($.staticInitializer) },\n      {\n        GATE: () =>\n          tokenMatcher(nextRuleType, classBodyTypes.constructorDeclaration),\n        ALT: () => $.SUBRULE($.constructorDeclaration)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ClassMemberDeclaration\n  $.RULE(\"classMemberDeclaration\", nextRuleType => {\n    $.OR([\n      {\n        GATE: () => nextRuleType === classBodyTypes.fieldDeclaration,\n        ALT: () => $.SUBRULE($.fieldDeclaration)\n      },\n      {\n        GATE: () => nextRuleType === classBodyTypes.methodDeclaration,\n        ALT: () => $.SUBRULE($.methodDeclaration)\n      },\n      {\n        GATE: () => nextRuleType === classBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => nextRuleType === classBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  });\n\n  // // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-FieldDeclaration\n  $.RULE(\"fieldDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.fieldModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorList);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-FieldModifier\n  $.RULE(\"fieldModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) },\n      { ALT: () => $.CONSUME(t.Transient) },\n      { ALT: () => $.CONSUME(t.Volatile) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-VariableDeclaratorList\n  $.RULE(\"variableDeclaratorList\", () => {\n    $.SUBRULE($.variableDeclarator);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.variableDeclarator);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-VariableDeclarator\n  $.RULE(\"variableDeclarator\", () => {\n    $.SUBRULE($.variableDeclaratorId);\n    $.OPTION(() => {\n      $.CONSUME(t.Equals);\n      $.SUBRULE($.variableInitializer);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-VariableDeclaratorId\n  $.RULE(\"variableDeclaratorId\", () => {\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-VariableInitializer\n  $.RULE(\"variableInitializer\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.expression) },\n      { ALT: () => $.SUBRULE($.arrayInitializer) }\n    ]);\n  });\n\n  // // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-UnannType\n  $.RULE(\"unannType\", () => {\n    $.OR([\n      // Spec Deviation: The array type \"dims\" suffix was extracted to this rule\n      // to avoid backtracking for performance reasons.\n      {\n        ALT: () => {\n          $.SUBRULE($.unannPrimitiveType);\n          $.OPTION({\n            GATE: () => this.BACKTRACK_LOOKAHEAD($.isDims),\n            DEF: () => $.SUBRULE2($.dims)\n          });\n        }\n      },\n      { ALT: () => $.SUBRULE($.unannReferenceType) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-UnannPrimitiveType\n  $.RULE(\"unannPrimitiveType\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.numericType) },\n      { ALT: () => $.CONSUME(t.Boolean) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-UnannReferenceType\n  $.RULE(\"unannReferenceType\", () => {\n    $.SUBRULE($.unannClassOrInterfaceType);\n    $.OPTION({\n      GATE: () => this.BACKTRACK_LOOKAHEAD($.isDims),\n      DEF: () => $.SUBRULE2($.dims)\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-UnannClassType\n  $.RULE(\"unannClassOrInterfaceType\", () => {\n    // Spec Deviation: The spec says: \"UnannClassType  | UnannInterfaceType\" but \"UnannInterfaceType\"\n    //                 is not mentioned in the parser because it is identical to \"UnannClassType\"\n    //                 The distinction is **semantic** not syntactic.\n    $.SUBRULE($.unannClassType);\n  });\n\n  $.RULE(\"unannClassType\", () => {\n    // Spec Deviation: Refactored left recursion and alternation to iterations\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      // TODO: Semantic Check: This Identifier cannot be \"var\"\n      $.CONSUME2(t.Identifier);\n      $.OPTION2(() => {\n        $.SUBRULE2($.typeArguments);\n      });\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-UnannInterfaceType\n  $.RULE(\"unannInterfaceType\", () => {\n    $.SUBRULE($.unannClassType);\n  });\n\n  $.RULE(\"unannTypeVariable\", () => {\n    // TODO: Semantic Check: This Identifier cannot be \"var\"\n    // TODO: or define as token type?\n    $.CONSUME(t.Identifier);\n  });\n\n  // // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-MethodDeclaration\n  $.RULE(\"methodDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.methodModifier);\n    });\n    $.SUBRULE($.methodHeader);\n    $.SUBRULE($.methodBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-MethodModifier\n  $.RULE(\"methodModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) },\n      { ALT: () => $.CONSUME(t.Synchronized) },\n      { ALT: () => $.CONSUME(t.Native) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-MethodHeader\n  $.RULE(\"methodHeader\", () => {\n    // Spec Deviation: extracted common prefix from both alternatives\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n      $.MANY(() => {\n        $.SUBRULE($.annotation);\n      });\n    });\n    $.SUBRULE($.result);\n    $.SUBRULE($.methodDeclarator);\n    $.OPTION2(() => {\n      $.SUBRULE($.throws);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-Result\n  $.RULE(\"result\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.unannType) },\n      { ALT: () => $.CONSUME(t.Void) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-MethodDeclarator\n  $.RULE(\"methodDeclarator\", () => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.formalParameterList);\n    });\n    $.CONSUME(t.RBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.dims);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ReceiverParameter\n  $.RULE(\"receiverParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.SUBRULE($.unannType);\n    $.OPTION(() => {\n      $.CONSUME(t.Identifier);\n      $.CONSUME(t.Dot);\n    });\n    $.CONSUME(t.This);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-FormalParameterList\n  $.RULE(\"formalParameterList\", () => {\n    $.SUBRULE($.formalParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.formalParameter);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-FormalParameter\n  $.RULE(\"formalParameter\", () => {\n    $.OR([\n      // Spec Deviation: extracted to \"variableParaRegularParameter\"\n      {\n        GATE: $.BACKTRACK($.variableParaRegularParameter),\n        ALT: () => $.SUBRULE($.variableParaRegularParameter)\n      },\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\n    ]);\n  });\n\n  // Spec Deviation: extracted from \"formalParameter\"\n  $.RULE(\"variableParaRegularParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorId);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-VariableArityParameter\n  $.RULE(\"variableArityParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.MANY2(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.DotDotDot);\n    $.CONSUME(t.Identifier);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-VariableModifier\n  $.RULE(\"variableModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Final) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-Throws\n  $.RULE(\"throws\", () => {\n    $.CONSUME(t.Throws);\n    $.SUBRULE($.exceptionTypeList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ExceptionTypeList\n  $.RULE(\"exceptionTypeList\", () => {\n    $.SUBRULE($.exceptionType);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.exceptionType);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ExceptionType\n  $.RULE(\"exceptionType\", () => {\n    // Spec Deviation: \"typeVariable\" alternative is missing because\n    //                 it is contained in classType.\n    $.SUBRULE($.classType);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-MethodBody\n  $.RULE(\"methodBody\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.block) },\n      { ALT: () => $.CONSUME(t.Semicolon) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-InstanceInitializer\n  $.RULE(\"instanceInitializer\", () => {\n    $.SUBRULE($.block);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-StaticInitializer\n  $.RULE(\"staticInitializer\", () => {\n    $.CONSUME(t.Static);\n    $.SUBRULE($.block);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ConstructorDeclaration\n  $.RULE(\"constructorDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.constructorModifier);\n    });\n    $.SUBRULE($.constructorDeclarator);\n    $.OPTION(() => {\n      $.SUBRULE($.throws);\n    });\n    $.SUBRULE($.constructorBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ConstructorModifier\n  $.RULE(\"constructorModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ConstructorDeclarator\n  $.RULE(\"constructorDeclarator\", () => {\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.SUBRULE($.simpleTypeName);\n    $.CONSUME(t.LBrace);\n    $.OPTION2({\n      // a \"formalParameterList\" and a \"receiverParameter\"\n      // cannot be distinguished using fixed lookahead.\n      GATE: $.BACKTRACK($.receiverParameter),\n      DEF: () => {\n        $.SUBRULE($.receiverParameter);\n        $.CONSUME(t.Comma);\n      }\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.formalParameterList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-SimpleTypeName\n  $.RULE(\"simpleTypeName\", () => {\n    // TODO: implement: Identifier but not var\n    $.CONSUME(t.Identifier);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ConstructorBody\n  $.RULE(\"constructorBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION({\n      GATE: $.BACKTRACK($.explicitConstructorInvocation),\n      DEF: () => {\n        $.SUBRULE($.explicitConstructorInvocation);\n      }\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.blockStatements);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-ExplicitConstructorInvocation\n  $.RULE(\"explicitConstructorInvocation\", () => {\n    // Spec Deviation: split into two separate sub rules.\n    $.OR([\n      { ALT: () => $.SUBRULE($.unqualifiedExplicitConstructorInvocation) },\n      { ALT: () => $.SUBRULE($.qualifiedExplicitConstructorInvocation) }\n    ]);\n  });\n\n  $.RULE(\"unqualifiedExplicitConstructorInvocation\", () => {\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.OR([\n      {\n        ALT: () => $.CONSUME(t.This)\n      },\n      {\n        ALT: () => $.CONSUME(t.Super)\n      }\n    ]);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.CONSUME(t.Semicolon);\n  });\n\n  $.RULE(\"qualifiedExplicitConstructorInvocation\", () => {\n    // Spec Deviation: According to the spec the prefix may be a \"primary' as well,\n    //                 however, most primary variants don't make sense here\n    // TODO: discover which primary forms could be valid here\n    //       and handle only those specific cases.\n    //       It is best if we avoid referencing \"primary\" rule from\n    //       outside the expressions rules as the expressions rules are not aligned\n    //       to the spec style, so we want the smallest possible \"external api\"\n    //       for the expressions rules.\n    $.SUBRULE($.expressionName);\n    $.CONSUME(t.Dot);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.CONSUME(t.Super);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-EnumDeclaration\n  $.RULE(\"enumDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.classModifier);\n    });\n    $.CONSUME(t.Enum);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.superinterfaces);\n    });\n    $.SUBRULE($.enumBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-EnumBody\n  $.RULE(\"enumBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.enumConstantList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.enumBodyDeclarations);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-EnumConstantList\n  $.RULE(\"enumConstantList\", () => {\n    $.SUBRULE($.enumConstant);\n    $.MANY({\n      GATE: () => {\n        const nextToken = $.LA(2);\n        return (\n          tokenMatcher(nextToken, t.Identifier) || tokenMatcher(nextToken, t.At)\n        );\n      },\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.enumConstant);\n      }\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-EnumConstant\n  $.RULE(\"enumConstant\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.enumConstantModifier);\n    });\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.CONSUME(t.LBrace);\n      $.OPTION2(() => {\n        $.SUBRULE($.argumentList);\n      });\n      $.CONSUME(t.RBrace);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.classBody);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-EnumConstantModifier\n  $.RULE(\"enumConstantModifier\", () => {\n    $.SUBRULE($.annotation);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-EnumBodyDeclarations\n  $.RULE(\"enumBodyDeclarations\", () => {\n    $.CONSUME(t.Semicolon);\n    $.MANY(() => {\n      $.SUBRULE($.classBodyDeclaration);\n    });\n  });\n\n  $.RULE(\"isClassDeclaration\", () => {\n    let isEmptyTypeDeclaration = false;\n\n    if (\n      $.OPTION(() => {\n        $.CONSUME(t.Semicolon);\n      })\n    ) {\n      // an empty \"TypeDeclaration\"\n      isEmptyTypeDeclaration = true;\n    }\n\n    try {\n      // The {classModifier} is a super grammar of the \"interfaceModifier\"\n      // So we must parse all the \"{classModifier}\" before we can distinguish\n      // between the alternatives.\n      $.MANY({\n        GATE: () =>\n          (tokenMatcher($.LA(1).tokenType, t.At) &&\n            tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n        DEF: () => {\n          $.SUBRULE($.classModifier);\n        }\n      });\n    } catch (e) {\n      if (isRecognitionException(e)) {\n        // TODO: add original syntax error?\n        throw \"Cannot Identify if the <TypeDeclaration> is a <ClassDeclaration> or an <InterfaceDeclaration>\";\n      } else {\n        throw e;\n      }\n    }\n\n    if (isEmptyTypeDeclaration) {\n      return false;\n    }\n\n    const nextTokenType = this.LA(1).tokenType;\n    return (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    );\n  });\n\n  $.RULE(\"identifyClassBodyDeclarationType\", () => {\n    try {\n      let nextTokenType = this.LA(1).tokenType;\n      let nextNextTokenType = this.LA(2).tokenType;\n\n      switch (nextTokenType) {\n        case t.Semicolon:\n          return classBodyTypes.semiColon;\n        case t.LCurly:\n          return classBodyTypes.instanceInitializer;\n        case t.Static:\n          switch (nextNextTokenType) {\n            case t.LCurly:\n              return classBodyTypes.staticInitializer;\n          }\n      }\n\n      // We have to look beyond the modifiers to distinguish between the declaration types.\n      $.MANY({\n        GATE: () =>\n          (tokenMatcher($.LA(1).tokenType, t.At) &&\n            tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n        DEF: () => {\n          // This alternation includes all possible modifiers for all types of \"ClassBodyDeclaration\"\n          // Certain combinations are syntactically invalid, this is **not** checked here,\n          // Invalid combinations will cause a descriptive parsing error message to be\n          // Created inside the relevant parsing rules **after** this lookahead\n          // analysis.\n          $.OR([\n            {\n              GATE: () =>\n                (tokenMatcher($.LA(1).tokenType, t.At) &&\n                  tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n              ALT: () => $.SUBRULE($.annotation)\n            },\n            { ALT: () => $.CONSUME(t.Public) },\n            { ALT: () => $.CONSUME(t.Protected) },\n            { ALT: () => $.CONSUME(t.Private) },\n            { ALT: () => $.CONSUME(t.Abstract) },\n            { ALT: () => $.CONSUME(t.Static) },\n            { ALT: () => $.CONSUME(t.Final) },\n            { ALT: () => $.CONSUME(t.Transient) },\n            { ALT: () => $.CONSUME(t.Volatile) },\n            { ALT: () => $.CONSUME(t.Synchronized) },\n            { ALT: () => $.CONSUME(t.Native) },\n            { ALT: () => $.CONSUME(t.Strictfp) }\n          ]);\n        }\n      });\n\n      nextTokenType = this.LA(1).tokenType;\n      nextNextTokenType = this.LA(2).tokenType;\n      if (\n        tokenMatcher(nextTokenType, t.Identifier) &&\n        tokenMatcher(nextNextTokenType, t.LBrace)\n      ) {\n        return classBodyTypes.constructorDeclaration;\n      }\n\n      if (\n        tokenMatcher(nextTokenType, t.Class) ||\n        tokenMatcher(nextTokenType, t.Enum)\n      ) {\n        return classBodyTypes.classDeclaration;\n      }\n\n      if (\n        tokenMatcher(nextTokenType, t.Interface) ||\n        tokenMatcher(nextTokenType, t.At)\n      ) {\n        return classBodyTypes.interfaceDeclaration;\n      }\n\n      if (tokenMatcher(nextTokenType, t.Void)) {\n        // method with result type \"void\"\n        return classBodyTypes.methodDeclaration;\n      }\n\n      // Type Arguments common prefix\n      if (tokenMatcher(nextTokenType, t.Less)) {\n        this.SUBRULE($.typeParameters);\n        const nextTokenType = this.LA(1).tokenType;\n        const nextNextTokenType = this.LA(2).tokenType;\n        // \"<T> foo(\" -> constructor\n        if (\n          tokenMatcher(nextTokenType, t.Identifier) &&\n          tokenMatcher(nextNextTokenType, t.LBrace)\n        ) {\n          return classBodyTypes.constructorDeclaration;\n        }\n        // typeParameters can only appear in method or constructor\n        // declarations, so if it is not a constructor it must be a method\n        return classBodyTypes.methodDeclaration;\n      }\n\n      // Only field or method declarations may be valid at this point.\n      // All other alternatives should have been attempted.\n      // **both** start with \"unannType\"\n      this.SUBRULE($.unannType);\n\n      const nextToken = this.LA(1);\n      nextNextTokenType = this.LA(2).tokenType;\n      // \"foo(...\" --> look like method start\n      if (\n        tokenMatcher(nextToken, t.Identifier) &&\n        tokenMatcher(nextNextTokenType, t.LBrace)\n      ) {\n        return classBodyTypes.methodDeclaration;\n      }\n\n      // a valid field\n      // TODO: because we use token categories we should use tokenMatcher everywhere.\n      if (tokenMatcher(nextToken, t.Identifier)) {\n        return classBodyTypes.fieldDeclaration;\n      }\n\n      return classBodyTypes.unknown;\n    } catch (e) {\n      // TODO: add info from the original error\n      throw Error(\"Cannot Identify the type of a <classBodyDeclaration>\");\n    }\n  });\n\n  $.RULE(\"isDims\", () => {\n    $.MANY($.annotation);\n    return (\n      tokenMatcher(this.LA(1).tokenType, t.LSquare) &&\n      tokenMatcher(this.LA(2).tokenType, t.RSquare)\n    );\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2NsYXNzZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2NsYXNzZXMuanM/NjBhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCB0b2tlbk1hdGNoZXIgfSA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xuXG5mdW5jdGlvbiBkZWZpbmVSdWxlcygkLCB0KSB7XG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUNsYXNzRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwiY2xhc3NEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IGV4dHJhY3RlZCBjb21tb24gXCJ7Y2xhc3NNb2RpZmllcn1cIiBwcmVmaXhcbiAgICAvLyAgICAgIGV4dHJhY3Rpb24gaXMgc2FmZSBiZWNhdXNlIHRoZXJlIGFyZSBubyBvdGhlciByZWZlcmVuY2VzIHRvXG4gICAgLy8gICAgICBcIm5vcm1hbENsYXNzRGVjbGFyYXRpb25cIiBhbmQgXCJlbnVtRGVjbGFyYXRpb25cIlxuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5jbGFzc01vZGlmaWVyKTtcbiAgICB9KTtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5ub3JtYWxDbGFzc0RlY2xhcmF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmVudW1EZWNsYXJhdGlvbikgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1Ob3JtYWxDbGFzc0RlY2xhcmF0aW9uXG4gICQuUlVMRShcIm5vcm1hbENsYXNzRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBleHRyYWN0ZWQgY29tbW9uIFwie2NsYXNzTW9kaWZpZXJ9XCIgdG8gXCJjbGFzc0RlY2xhcmF0aW9uXCJcbiAgICAkLkNPTlNVTUUodC5DbGFzcyk7XG4gICAgJC5TVUJSVUxFKCQudHlwZUlkZW50aWZpZXIpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICB9KTtcbiAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuc3VwZXJjbGFzcyk7XG4gICAgfSk7XG4gICAgJC5PUFRJT04zKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnN1cGVyaW50ZXJmYWNlcyk7XG4gICAgfSk7XG4gICAgJC5TVUJSVUxFKCQuY2xhc3NCb2R5KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtQ2xhc3NNb2RpZmllclxuICAkLlJVTEUoXCJjbGFzc01vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlB1YmxpYykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcm90ZWN0ZWQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHJpdmF0ZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5BYnN0cmFjdCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TdGF0aWMpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRmluYWwpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU3RyaWN0ZnApIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtVHlwZVBhcmFtZXRlcnNcbiAgJC5SVUxFKFwidHlwZVBhcmFtZXRlcnNcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0Lkxlc3MpO1xuICAgICQuU1VCUlVMRSgkLnR5cGVQYXJhbWV0ZXJMaXN0KTtcbiAgICAkLkNPTlNVTUUodC5HcmVhdGVyKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtVHlwZVBhcmFtZXRlckxpc3RcbiAgJC5SVUxFKFwidHlwZVBhcmFtZXRlckxpc3RcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnR5cGVQYXJhbWV0ZXIpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgICAkLlNVQlJVTEUyKCQudHlwZVBhcmFtZXRlcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVN1cGVyY2xhc3NcbiAgJC5SVUxFKFwic3VwZXJjbGFzc1wiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuRXh0ZW5kcyk7XG4gICAgJC5TVUJSVUxFKCQuY2xhc3NUeXBlKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtU3VwZXJpbnRlcmZhY2VzXG4gICQuUlVMRShcInN1cGVyaW50ZXJmYWNlc1wiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuSW1wbGVtZW50cyk7XG4gICAgJC5TVUJSVUxFKCQuaW50ZXJmYWNlVHlwZUxpc3QpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1JbnRlcmZhY2VUeXBlTGlzdFxuICAkLlJVTEUoXCJpbnRlcmZhY2VUeXBlTGlzdFwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQuaW50ZXJmYWNlVHlwZSk7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICAgICQuU1VCUlVMRTIoJC5pbnRlcmZhY2VUeXBlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtQ2xhc3NCb2R5XG4gICQuUlVMRShcImNsYXNzQm9keVwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTEN1cmx5KTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuY2xhc3NCb2R5RGVjbGFyYXRpb24pO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlJDdXJseSk7XG4gIH0pO1xuXG4gIGNvbnN0IGNsYXNzQm9keVR5cGVzID0ge1xuICAgIHVua25vd246IDAsXG4gICAgZmllbGREZWNsYXJhdGlvbjogMSxcbiAgICBtZXRob2REZWNsYXJhdGlvbjogMixcbiAgICBjbGFzc0RlY2xhcmF0aW9uOiAzLFxuICAgIGludGVyZmFjZURlY2xhcmF0aW9uOiA0LFxuICAgIHNlbWlDb2xvbjogNSxcbiAgICBpbnN0YW5jZUluaXRpYWxpemVyOiA2LFxuICAgIHN0YXRpY0luaXRpYWxpemVyOiA3LFxuICAgIGNvbnN0cnVjdG9yRGVjbGFyYXRpb246IDhcbiAgfTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1DbGFzc0JvZHlEZWNsYXJhdGlvblxuICAkLlJVTEUoXCJjbGFzc0JvZHlEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgY29uc3QgbmV4dFJ1bGVUeXBlID0gJC5CQUNLVFJBQ0tfTE9PS0FIRUFEKFxuICAgICAgJC5pZGVudGlmeUNsYXNzQm9keURlY2xhcmF0aW9uVHlwZVxuICAgICk7XG5cbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT5cbiAgICAgICAgICBuZXh0UnVsZVR5cGUgPj0gY2xhc3NCb2R5VHlwZXMuZmllbGREZWNsYXJhdGlvbiAmJlxuICAgICAgICAgIG5leHRSdWxlVHlwZSA8PSBjbGFzc0JvZHlUeXBlcy5zZW1pQ29sb24sXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuY2xhc3NNZW1iZXJEZWNsYXJhdGlvbiwgeyBBUkdTOiBbbmV4dFJ1bGVUeXBlXSB9KVxuICAgICAgfSxcbiAgICAgIC8vIG5vIGdhdGUgbmVlZGVkIGZvciB0aGUgaW5pdGlhbGl6ZXJzIGJlY2F1c2UgdGhlc2UgYXJlIExMKDEpIHJ1bGVzLlxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmluc3RhbmNlSW5pdGlhbGl6ZXIpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuc3RhdGljSW5pdGlhbGl6ZXIpIH0sXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+XG4gICAgICAgICAgdG9rZW5NYXRjaGVyKG5leHRSdWxlVHlwZSwgY2xhc3NCb2R5VHlwZXMuY29uc3RydWN0b3JEZWNsYXJhdGlvbiksXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuY29uc3RydWN0b3JEZWNsYXJhdGlvbilcbiAgICAgIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtQ2xhc3NNZW1iZXJEZWNsYXJhdGlvblxuICAkLlJVTEUoXCJjbGFzc01lbWJlckRlY2xhcmF0aW9uXCIsIG5leHRSdWxlVHlwZSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+IG5leHRSdWxlVHlwZSA9PT0gY2xhc3NCb2R5VHlwZXMuZmllbGREZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5maWVsZERlY2xhcmF0aW9uKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gbmV4dFJ1bGVUeXBlID09PSBjbGFzc0JvZHlUeXBlcy5tZXRob2REZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5tZXRob2REZWNsYXJhdGlvbilcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+IG5leHRSdWxlVHlwZSA9PT0gY2xhc3NCb2R5VHlwZXMuY2xhc3NEZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5jbGFzc0RlY2xhcmF0aW9uKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gbmV4dFJ1bGVUeXBlID09PSBjbGFzc0JvZHlUeXBlcy5pbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5pbnRlcmZhY2VEZWNsYXJhdGlvbilcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIE5vIEdBVEUgaXMgbmVlZGVkIGFzIHRoaXMgaXMgTEwoMSlcbiAgICAgICAgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TZW1pY29sb24pXG4gICAgICB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUZpZWxkRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwiZmllbGREZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmZpZWxkTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLnVuYW5uVHlwZSk7XG4gICAgJC5TVUJSVUxFKCQudmFyaWFibGVEZWNsYXJhdG9yTGlzdCk7XG4gICAgJC5DT05TVU1FKHQuU2VtaWNvbG9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtRmllbGRNb2RpZmllclxuICAkLlJVTEUoXCJmaWVsZE1vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlB1YmxpYykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcm90ZWN0ZWQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHJpdmF0ZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TdGF0aWMpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRmluYWwpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVHJhbnNpZW50KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlZvbGF0aWxlKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVZhcmlhYmxlRGVjbGFyYXRvckxpc3RcbiAgJC5SVUxFKFwidmFyaWFibGVEZWNsYXJhdG9yTGlzdFwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQudmFyaWFibGVEZWNsYXJhdG9yKTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgICAgJC5TVUJSVUxFMigkLnZhcmlhYmxlRGVjbGFyYXRvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVZhcmlhYmxlRGVjbGFyYXRvclxuICAkLlJVTEUoXCJ2YXJpYWJsZURlY2xhcmF0b3JcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlRGVjbGFyYXRvcklkKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5FcXVhbHMpO1xuICAgICAgJC5TVUJSVUxFKCQudmFyaWFibGVJbml0aWFsaXplcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVZhcmlhYmxlRGVjbGFyYXRvcklkXG4gICQuUlVMRShcInZhcmlhYmxlRGVjbGFyYXRvcklkXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5kaW1zKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtVmFyaWFibGVJbml0aWFsaXplclxuICAkLlJVTEUoXCJ2YXJpYWJsZUluaXRpYWxpemVyXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5leHByZXNzaW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFycmF5SW5pdGlhbGl6ZXIpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtVW5hbm5UeXBlXG4gICQuUlVMRShcInVuYW5uVHlwZVwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICAvLyBTcGVjIERldmlhdGlvbjogVGhlIGFycmF5IHR5cGUgXCJkaW1zXCIgc3VmZml4IHdhcyBleHRyYWN0ZWQgdG8gdGhpcyBydWxlXG4gICAgICAvLyB0byBhdm9pZCBiYWNrdHJhY2tpbmcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICB7XG4gICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICQuU1VCUlVMRSgkLnVuYW5uUHJpbWl0aXZlVHlwZSk7XG4gICAgICAgICAgJC5PUFRJT04oe1xuICAgICAgICAgICAgR0FURTogKCkgPT4gdGhpcy5CQUNLVFJBQ0tfTE9PS0FIRUFEKCQuaXNEaW1zKSxcbiAgICAgICAgICAgIERFRjogKCkgPT4gJC5TVUJSVUxFMigkLmRpbXMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudW5hbm5SZWZlcmVuY2VUeXBlKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVVuYW5uUHJpbWl0aXZlVHlwZVxuICAkLlJVTEUoXCJ1bmFublByaW1pdGl2ZVR5cGVcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLm51bWVyaWNUeXBlKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkJvb2xlYW4pIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtVW5hbm5SZWZlcmVuY2VUeXBlXG4gICQuUlVMRShcInVuYW5uUmVmZXJlbmNlVHlwZVwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQudW5hbm5DbGFzc09ySW50ZXJmYWNlVHlwZSk7XG4gICAgJC5PUFRJT04oe1xuICAgICAgR0FURTogKCkgPT4gdGhpcy5CQUNLVFJBQ0tfTE9PS0FIRUFEKCQuaXNEaW1zKSxcbiAgICAgIERFRjogKCkgPT4gJC5TVUJSVUxFMigkLmRpbXMpXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVVuYW5uQ2xhc3NUeXBlXG4gICQuUlVMRShcInVuYW5uQ2xhc3NPckludGVyZmFjZVR5cGVcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBUaGUgc3BlYyBzYXlzOiBcIlVuYW5uQ2xhc3NUeXBlICB8IFVuYW5uSW50ZXJmYWNlVHlwZVwiIGJ1dCBcIlVuYW5uSW50ZXJmYWNlVHlwZVwiXG4gICAgLy8gICAgICAgICAgICAgICAgIGlzIG5vdCBtZW50aW9uZWQgaW4gdGhlIHBhcnNlciBiZWNhdXNlIGl0IGlzIGlkZW50aWNhbCB0byBcIlVuYW5uQ2xhc3NUeXBlXCJcbiAgICAvLyAgICAgICAgICAgICAgICAgVGhlIGRpc3RpbmN0aW9uIGlzICoqc2VtYW50aWMqKiBub3Qgc3ludGFjdGljLlxuICAgICQuU1VCUlVMRSgkLnVuYW5uQ2xhc3NUeXBlKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwidW5hbm5DbGFzc1R5cGVcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBSZWZhY3RvcmVkIGxlZnQgcmVjdXJzaW9uIGFuZCBhbHRlcm5hdGlvbiB0byBpdGVyYXRpb25zXG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudHlwZUFyZ3VtZW50cyk7XG4gICAgfSk7XG4gICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5NQU5ZMygoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRTIoJC5hbm5vdGF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogU2VtYW50aWMgQ2hlY2s6IFRoaXMgSWRlbnRpZmllciBjYW5ub3QgYmUgXCJ2YXJcIlxuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFMigkLnR5cGVBcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVVuYW5uSW50ZXJmYWNlVHlwZVxuICAkLlJVTEUoXCJ1bmFubkludGVyZmFjZVR5cGVcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnVuYW5uQ2xhc3NUeXBlKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwidW5hbm5UeXBlVmFyaWFibGVcIiwgKCkgPT4ge1xuICAgIC8vIFRPRE86IFNlbWFudGljIENoZWNrOiBUaGlzIElkZW50aWZpZXIgY2Fubm90IGJlIFwidmFyXCJcbiAgICAvLyBUT0RPOiBvciBkZWZpbmUgYXMgdG9rZW4gdHlwZT9cbiAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgfSk7XG5cbiAgLy8gLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtTWV0aG9kRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwibWV0aG9kRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5tZXRob2RNb2RpZmllcik7XG4gICAgfSk7XG4gICAgJC5TVUJSVUxFKCQubWV0aG9kSGVhZGVyKTtcbiAgICAkLlNVQlJVTEUoJC5tZXRob2RCb2R5KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtTWV0aG9kTW9kaWZpZXJcbiAgJC5SVUxFKFwibWV0aG9kTW9kaWZpZXJcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFubm90YXRpb24pIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHVibGljKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlByb3RlY3RlZCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcml2YXRlKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkFic3RyYWN0KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0YXRpYykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5GaW5hbCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TeW5jaHJvbml6ZWQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuTmF0aXZlKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0cmljdGZwKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLU1ldGhvZEhlYWRlclxuICAkLlJVTEUoXCJtZXRob2RIZWFkZXJcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBleHRyYWN0ZWQgY29tbW9uIHByZWZpeCBmcm9tIGJvdGggYWx0ZXJuYXRpdmVzXG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5yZXN1bHQpO1xuICAgICQuU1VCUlVMRSgkLm1ldGhvZERlY2xhcmF0b3IpO1xuICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC50aHJvd3MpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1SZXN1bHRcbiAgJC5SVUxFKFwicmVzdWx0XCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC51bmFublR5cGUpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVm9pZCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlOC9odG1sL2pscy04Lmh0bWwjamxzLU1ldGhvZERlY2xhcmF0b3JcbiAgJC5SVUxFKFwibWV0aG9kRGVjbGFyYXRvclwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5mb3JtYWxQYXJhbWV0ZXJMaXN0KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5kaW1zKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtUmVjZWl2ZXJQYXJhbWV0ZXJcbiAgJC5SVUxFKFwicmVjZWl2ZXJQYXJhbWV0ZXJcIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC51bmFublR5cGUpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5UaGlzKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtRm9ybWFsUGFyYW1ldGVyTGlzdFxuICAkLlJVTEUoXCJmb3JtYWxQYXJhbWV0ZXJMaXN0XCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5mb3JtYWxQYXJhbWV0ZXIpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgICAkLlNVQlJVTEUyKCQuZm9ybWFsUGFyYW1ldGVyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtRm9ybWFsUGFyYW1ldGVyXG4gICQuUlVMRShcImZvcm1hbFBhcmFtZXRlclwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICAvLyBTcGVjIERldmlhdGlvbjogZXh0cmFjdGVkIHRvIFwidmFyaWFibGVQYXJhUmVndWxhclBhcmFtZXRlclwiXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICQuQkFDS1RSQUNLKCQudmFyaWFibGVQYXJhUmVndWxhclBhcmFtZXRlciksXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudmFyaWFibGVQYXJhUmVndWxhclBhcmFtZXRlcilcbiAgICAgIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudmFyaWFibGVBcml0eVBhcmFtZXRlcikgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBTcGVjIERldmlhdGlvbjogZXh0cmFjdGVkIGZyb20gXCJmb3JtYWxQYXJhbWV0ZXJcIlxuICAkLlJVTEUoXCJ2YXJpYWJsZVBhcmFSZWd1bGFyUGFyYW1ldGVyXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudmFyaWFibGVNb2RpZmllcik7XG4gICAgfSk7XG4gICAgJC5TVUJSVUxFKCQudW5hbm5UeXBlKTtcbiAgICAkLlNVQlJVTEUoJC52YXJpYWJsZURlY2xhcmF0b3JJZCk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLVZhcmlhYmxlQXJpdHlQYXJhbWV0ZXJcbiAgJC5SVUxFKFwidmFyaWFibGVBcml0eVBhcmFtZXRlclwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLnVuYW5uVHlwZSk7XG4gICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5Eb3REb3REb3QpO1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1WYXJpYWJsZU1vZGlmaWVyXG4gICQuUlVMRShcInZhcmlhYmxlTW9kaWZpZXJcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFubm90YXRpb24pIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRmluYWwpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtVGhyb3dzXG4gICQuUlVMRShcInRocm93c1wiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuVGhyb3dzKTtcbiAgICAkLlNVQlJVTEUoJC5leGNlcHRpb25UeXBlTGlzdCk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUV4Y2VwdGlvblR5cGVMaXN0XG4gICQuUlVMRShcImV4Y2VwdGlvblR5cGVMaXN0XCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5leGNlcHRpb25UeXBlKTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgICAgJC5TVUJSVUxFMigkLmV4Y2VwdGlvblR5cGUpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1FeGNlcHRpb25UeXBlXG4gICQuUlVMRShcImV4Y2VwdGlvblR5cGVcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBcInR5cGVWYXJpYWJsZVwiIGFsdGVybmF0aXZlIGlzIG1pc3NpbmcgYmVjYXVzZVxuICAgIC8vICAgICAgICAgICAgICAgICBpdCBpcyBjb250YWluZWQgaW4gY2xhc3NUeXBlLlxuICAgICQuU1VCUlVMRSgkLmNsYXNzVHlwZSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLU1ldGhvZEJvZHlcbiAgJC5SVUxFKFwibWV0aG9kQm9keVwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYmxvY2spIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU2VtaWNvbG9uKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUluc3RhbmNlSW5pdGlhbGl6ZXJcbiAgJC5SVUxFKFwiaW5zdGFuY2VJbml0aWFsaXplclwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQuYmxvY2spO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1TdGF0aWNJbml0aWFsaXplclxuICAkLlJVTEUoXCJzdGF0aWNJbml0aWFsaXplclwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuU3RhdGljKTtcbiAgICAkLlNVQlJVTEUoJC5ibG9jayk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUNvbnN0cnVjdG9yRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwiY29uc3RydWN0b3JEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmNvbnN0cnVjdG9yTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLmNvbnN0cnVjdG9yRGVjbGFyYXRvcik7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudGhyb3dzKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5jb25zdHJ1Y3RvckJvZHkpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1Db25zdHJ1Y3Rvck1vZGlmaWVyXG4gICQuUlVMRShcImNvbnN0cnVjdG9yTW9kaWZpZXJcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFubm90YXRpb24pIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHVibGljKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlByb3RlY3RlZCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcml2YXRlKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUNvbnN0cnVjdG9yRGVjbGFyYXRvclxuICAkLlJVTEUoXCJjb25zdHJ1Y3RvckRlY2xhcmF0b3JcIiwgKCkgPT4ge1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5zaW1wbGVUeXBlTmFtZSk7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLk9QVElPTjIoe1xuICAgICAgLy8gYSBcImZvcm1hbFBhcmFtZXRlckxpc3RcIiBhbmQgYSBcInJlY2VpdmVyUGFyYW1ldGVyXCJcbiAgICAgIC8vIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIHVzaW5nIGZpeGVkIGxvb2thaGVhZC5cbiAgICAgIEdBVEU6ICQuQkFDS1RSQUNLKCQucmVjZWl2ZXJQYXJhbWV0ZXIpLFxuICAgICAgREVGOiAoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRSgkLnJlY2VpdmVyUGFyYW1ldGVyKTtcbiAgICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuT1BUSU9OMygoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5mb3JtYWxQYXJhbWV0ZXJMaXN0KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1TaW1wbGVUeXBlTmFtZVxuICAkLlJVTEUoXCJzaW1wbGVUeXBlTmFtZVwiLCAoKSA9PiB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50OiBJZGVudGlmaWVyIGJ1dCBub3QgdmFyXG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUNvbnN0cnVjdG9yQm9keVxuICAkLlJVTEUoXCJjb25zdHJ1Y3RvckJvZHlcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxDdXJseSk7XG4gICAgJC5PUFRJT04oe1xuICAgICAgR0FURTogJC5CQUNLVFJBQ0soJC5leHBsaWNpdENvbnN0cnVjdG9ySW52b2NhdGlvbiksXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFKCQuZXhwbGljaXRDb25zdHJ1Y3Rvckludm9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5ibG9ja1N0YXRlbWVudHMpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlJDdXJseSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUV4cGxpY2l0Q29uc3RydWN0b3JJbnZvY2F0aW9uXG4gICQuUlVMRShcImV4cGxpY2l0Q29uc3RydWN0b3JJbnZvY2F0aW9uXCIsICgpID0+IHtcbiAgICAvLyBTcGVjIERldmlhdGlvbjogc3BsaXQgaW50byB0d28gc2VwYXJhdGUgc3ViIHJ1bGVzLlxuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnVucXVhbGlmaWVkRXhwbGljaXRDb25zdHJ1Y3Rvckludm9jYXRpb24pIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQucXVhbGlmaWVkRXhwbGljaXRDb25zdHJ1Y3Rvckludm9jYXRpb24pIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwidW5xdWFsaWZpZWRFeHBsaWNpdENvbnN0cnVjdG9ySW52b2NhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudHlwZUFyZ3VtZW50cyk7XG4gICAgfSk7XG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVGhpcylcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU3VwZXIpXG4gICAgICB9XG4gICAgXSk7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYXJndW1lbnRMaXN0KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gICQuUlVMRShcInF1YWxpZmllZEV4cGxpY2l0Q29uc3RydWN0b3JJbnZvY2F0aW9uXCIsICgpID0+IHtcbiAgICAvLyBTcGVjIERldmlhdGlvbjogQWNjb3JkaW5nIHRvIHRoZSBzcGVjIHRoZSBwcmVmaXggbWF5IGJlIGEgXCJwcmltYXJ5JyBhcyB3ZWxsLFxuICAgIC8vICAgICAgICAgICAgICAgICBob3dldmVyLCBtb3N0IHByaW1hcnkgdmFyaWFudHMgZG9uJ3QgbWFrZSBzZW5zZSBoZXJlXG4gICAgLy8gVE9ETzogZGlzY292ZXIgd2hpY2ggcHJpbWFyeSBmb3JtcyBjb3VsZCBiZSB2YWxpZCBoZXJlXG4gICAgLy8gICAgICAgYW5kIGhhbmRsZSBvbmx5IHRob3NlIHNwZWNpZmljIGNhc2VzLlxuICAgIC8vICAgICAgIEl0IGlzIGJlc3QgaWYgd2UgYXZvaWQgcmVmZXJlbmNpbmcgXCJwcmltYXJ5XCIgcnVsZSBmcm9tXG4gICAgLy8gICAgICAgb3V0c2lkZSB0aGUgZXhwcmVzc2lvbnMgcnVsZXMgYXMgdGhlIGV4cHJlc3Npb25zIHJ1bGVzIGFyZSBub3QgYWxpZ25lZFxuICAgIC8vICAgICAgIHRvIHRoZSBzcGVjIHN0eWxlLCBzbyB3ZSB3YW50IHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBcImV4dGVybmFsIGFwaVwiXG4gICAgLy8gICAgICAgZm9yIHRoZSBleHByZXNzaW9ucyBydWxlcy5cbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uTmFtZSk7XG4gICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC50eXBlQXJndW1lbnRzKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5TdXBlcik7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYXJndW1lbnRMaXN0KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUVudW1EZWNsYXJhdGlvblxuICAkLlJVTEUoXCJlbnVtRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5jbGFzc01vZGlmaWVyKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5FbnVtKTtcbiAgICAkLlNVQlJVTEUoJC50eXBlSWRlbnRpZmllcik7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuc3VwZXJpbnRlcmZhY2VzKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5lbnVtQm9keSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUVudW1Cb2R5XG4gICQuUlVMRShcImVudW1Cb2R5XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5MQ3VybHkpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmVudW1Db25zdGFudExpc3QpO1xuICAgIH0pO1xuICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgfSk7XG4gICAgJC5PUFRJT04zKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmVudW1Cb2R5RGVjbGFyYXRpb25zKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQ3VybHkpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOC5odG1sI2pscy1FbnVtQ29uc3RhbnRMaXN0XG4gICQuUlVMRShcImVudW1Db25zdGFudExpc3RcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLmVudW1Db25zdGFudCk7XG4gICAgJC5NQU5ZKHtcbiAgICAgIEdBVEU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuID0gJC5MQSgyKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0b2tlbk1hdGNoZXIobmV4dFRva2VuLCB0LklkZW50aWZpZXIpIHx8IHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIHQuQXQpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgREVGOiAoKSA9PiB7XG4gICAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICAgICAgJC5TVUJSVUxFMigkLmVudW1Db25zdGFudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUVudW1Db25zdGFudFxuICAkLlJVTEUoXCJlbnVtQ29uc3RhbnRcIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5lbnVtQ29uc3RhbnRNb2RpZmllcik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRSgkLmFyZ3VtZW50TGlzdCk7XG4gICAgICB9KTtcbiAgICAgICQuQ09OU1VNRSh0LlJCcmFjZSk7XG4gICAgfSk7XG4gICAgJC5PUFRJT04zKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmNsYXNzQm9keSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy04Lmh0bWwjamxzLUVudW1Db25zdGFudE1vZGlmaWVyXG4gICQuUlVMRShcImVudW1Db25zdGFudE1vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTguaHRtbCNqbHMtRW51bUJvZHlEZWNsYXJhdGlvbnNcbiAgJC5SVUxFKFwiZW51bUJvZHlEZWNsYXJhdGlvbnNcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmNsYXNzQm9keURlY2xhcmF0aW9uKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiaXNDbGFzc0RlY2xhcmF0aW9uXCIsICgpID0+IHtcbiAgICBsZXQgaXNFbXB0eVR5cGVEZWNsYXJhdGlvbiA9IGZhbHNlO1xuXG4gICAgaWYgKFxuICAgICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgICAkLkNPTlNVTUUodC5TZW1pY29sb24pO1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIC8vIGFuIGVtcHR5IFwiVHlwZURlY2xhcmF0aW9uXCJcbiAgICAgIGlzRW1wdHlUeXBlRGVjbGFyYXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBUaGUge2NsYXNzTW9kaWZpZXJ9IGlzIGEgc3VwZXIgZ3JhbW1hciBvZiB0aGUgXCJpbnRlcmZhY2VNb2RpZmllclwiXG4gICAgICAvLyBTbyB3ZSBtdXN0IHBhcnNlIGFsbCB0aGUgXCJ7Y2xhc3NNb2RpZmllcn1cIiBiZWZvcmUgd2UgY2FuIGRpc3Rpbmd1aXNoXG4gICAgICAvLyBiZXR3ZWVuIHRoZSBhbHRlcm5hdGl2ZXMuXG4gICAgICAkLk1BTlkoe1xuICAgICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAgICh0b2tlbk1hdGNoZXIoJC5MQSgxKS50b2tlblR5cGUsIHQuQXQpICYmXG4gICAgICAgICAgICB0b2tlbk1hdGNoZXIoJC5MQSgyKS50b2tlblR5cGUsIHQuSW50ZXJmYWNlKSkgPT09IGZhbHNlLFxuICAgICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgICAkLlNVQlJVTEUoJC5jbGFzc01vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkpIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIG9yaWdpbmFsIHN5bnRheCBlcnJvcj9cbiAgICAgICAgdGhyb3cgXCJDYW5ub3QgSWRlbnRpZnkgaWYgdGhlIDxUeXBlRGVjbGFyYXRpb24+IGlzIGEgPENsYXNzRGVjbGFyYXRpb24+IG9yIGFuIDxJbnRlcmZhY2VEZWNsYXJhdGlvbj5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRW1wdHlUeXBlRGVjbGFyYXRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG4gICAgcmV0dXJuIChcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkNsYXNzKSB8fFxuICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuRW51bSlcbiAgICApO1xuICB9KTtcblxuICAkLlJVTEUoXCJpZGVudGlmeUNsYXNzQm9keURlY2xhcmF0aW9uVHlwZVwiLCAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBuZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG4gICAgICBsZXQgbmV4dE5leHRUb2tlblR5cGUgPSB0aGlzLkxBKDIpLnRva2VuVHlwZTtcblxuICAgICAgc3dpdGNoIChuZXh0VG9rZW5UeXBlKSB7XG4gICAgICAgIGNhc2UgdC5TZW1pY29sb246XG4gICAgICAgICAgcmV0dXJuIGNsYXNzQm9keVR5cGVzLnNlbWlDb2xvbjtcbiAgICAgICAgY2FzZSB0LkxDdXJseTpcbiAgICAgICAgICByZXR1cm4gY2xhc3NCb2R5VHlwZXMuaW5zdGFuY2VJbml0aWFsaXplcjtcbiAgICAgICAgY2FzZSB0LlN0YXRpYzpcbiAgICAgICAgICBzd2l0Y2ggKG5leHROZXh0VG9rZW5UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIHQuTEN1cmx5OlxuICAgICAgICAgICAgICByZXR1cm4gY2xhc3NCb2R5VHlwZXMuc3RhdGljSW5pdGlhbGl6ZXI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBoYXZlIHRvIGxvb2sgYmV5b25kIHRoZSBtb2RpZmllcnMgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVjbGFyYXRpb24gdHlwZXMuXG4gICAgICAkLk1BTlkoe1xuICAgICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAgICh0b2tlbk1hdGNoZXIoJC5MQSgxKS50b2tlblR5cGUsIHQuQXQpICYmXG4gICAgICAgICAgICB0b2tlbk1hdGNoZXIoJC5MQSgyKS50b2tlblR5cGUsIHQuSW50ZXJmYWNlKSkgPT09IGZhbHNlLFxuICAgICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgICAvLyBUaGlzIGFsdGVybmF0aW9uIGluY2x1ZGVzIGFsbCBwb3NzaWJsZSBtb2RpZmllcnMgZm9yIGFsbCB0eXBlcyBvZiBcIkNsYXNzQm9keURlY2xhcmF0aW9uXCJcbiAgICAgICAgICAvLyBDZXJ0YWluIGNvbWJpbmF0aW9ucyBhcmUgc3ludGFjdGljYWxseSBpbnZhbGlkLCB0aGlzIGlzICoqbm90KiogY2hlY2tlZCBoZXJlLFxuICAgICAgICAgIC8vIEludmFsaWQgY29tYmluYXRpb25zIHdpbGwgY2F1c2UgYSBkZXNjcmlwdGl2ZSBwYXJzaW5nIGVycm9yIG1lc3NhZ2UgdG8gYmVcbiAgICAgICAgICAvLyBDcmVhdGVkIGluc2lkZSB0aGUgcmVsZXZhbnQgcGFyc2luZyBydWxlcyAqKmFmdGVyKiogdGhpcyBsb29rYWhlYWRcbiAgICAgICAgICAvLyBhbmFseXNpcy5cbiAgICAgICAgICAkLk9SKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgR0FURTogKCkgPT5cbiAgICAgICAgICAgICAgICAodG9rZW5NYXRjaGVyKCQuTEEoMSkudG9rZW5UeXBlLCB0LkF0KSAmJlxuICAgICAgICAgICAgICAgICAgdG9rZW5NYXRjaGVyKCQuTEEoMikudG9rZW5UeXBlLCB0LkludGVyZmFjZSkpID09PSBmYWxzZSxcbiAgICAgICAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5QdWJsaWMpIH0sXG4gICAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHJvdGVjdGVkKSB9LFxuICAgICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlByaXZhdGUpIH0sXG4gICAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuQWJzdHJhY3QpIH0sXG4gICAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU3RhdGljKSB9LFxuICAgICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkZpbmFsKSB9LFxuICAgICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlRyYW5zaWVudCkgfSxcbiAgICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Wb2xhdGlsZSkgfSxcbiAgICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TeW5jaHJvbml6ZWQpIH0sXG4gICAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuTmF0aXZlKSB9LFxuICAgICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0cmljdGZwKSB9XG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBuZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG4gICAgICBuZXh0TmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMikudG9rZW5UeXBlO1xuICAgICAgaWYgKFxuICAgICAgICB0b2tlbk1hdGNoZXIobmV4dFRva2VuVHlwZSwgdC5JZGVudGlmaWVyKSAmJlxuICAgICAgICB0b2tlbk1hdGNoZXIobmV4dE5leHRUb2tlblR5cGUsIHQuTEJyYWNlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHlUeXBlcy5jb25zdHJ1Y3RvckRlY2xhcmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkNsYXNzKSB8fFxuICAgICAgICB0b2tlbk1hdGNoZXIobmV4dFRva2VuVHlwZSwgdC5FbnVtKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHlUeXBlcy5jbGFzc0RlY2xhcmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkludGVyZmFjZSkgfHxcbiAgICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuQXQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzQm9keVR5cGVzLmludGVyZmFjZURlY2xhcmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuVm9pZCkpIHtcbiAgICAgICAgLy8gbWV0aG9kIHdpdGggcmVzdWx0IHR5cGUgXCJ2b2lkXCJcbiAgICAgICAgcmV0dXJuIGNsYXNzQm9keVR5cGVzLm1ldGhvZERlY2xhcmF0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBUeXBlIEFyZ3VtZW50cyBjb21tb24gcHJlZml4XG4gICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuTGVzcykpIHtcbiAgICAgICAgdGhpcy5TVUJSVUxFKCQudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICBjb25zdCBuZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG4gICAgICAgIGNvbnN0IG5leHROZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgyKS50b2tlblR5cGU7XG4gICAgICAgIC8vIFwiPFQ+IGZvbyhcIiAtPiBjb25zdHJ1Y3RvclxuICAgICAgICBpZiAoXG4gICAgICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuSWRlbnRpZmllcikgJiZcbiAgICAgICAgICB0b2tlbk1hdGNoZXIobmV4dE5leHRUb2tlblR5cGUsIHQuTEJyYWNlKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gY2xhc3NCb2R5VHlwZXMuY29uc3RydWN0b3JEZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlUGFyYW1ldGVycyBjYW4gb25seSBhcHBlYXIgaW4gbWV0aG9kIG9yIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIGRlY2xhcmF0aW9ucywgc28gaWYgaXQgaXMgbm90IGEgY29uc3RydWN0b3IgaXQgbXVzdCBiZSBhIG1ldGhvZFxuICAgICAgICByZXR1cm4gY2xhc3NCb2R5VHlwZXMubWV0aG9kRGVjbGFyYXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgZmllbGQgb3IgbWV0aG9kIGRlY2xhcmF0aW9ucyBtYXkgYmUgdmFsaWQgYXQgdGhpcyBwb2ludC5cbiAgICAgIC8vIEFsbCBvdGhlciBhbHRlcm5hdGl2ZXMgc2hvdWxkIGhhdmUgYmVlbiBhdHRlbXB0ZWQuXG4gICAgICAvLyAqKmJvdGgqKiBzdGFydCB3aXRoIFwidW5hbm5UeXBlXCJcbiAgICAgIHRoaXMuU1VCUlVMRSgkLnVuYW5uVHlwZSk7XG5cbiAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICBuZXh0TmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMikudG9rZW5UeXBlO1xuICAgICAgLy8gXCJmb28oLi4uXCIgLS0+IGxvb2sgbGlrZSBtZXRob2Qgc3RhcnRcbiAgICAgIGlmIChcbiAgICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdC5JZGVudGlmaWVyKSAmJlxuICAgICAgICB0b2tlbk1hdGNoZXIobmV4dE5leHRUb2tlblR5cGUsIHQuTEJyYWNlKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHlUeXBlcy5tZXRob2REZWNsYXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gYSB2YWxpZCBmaWVsZFxuICAgICAgLy8gVE9ETzogYmVjYXVzZSB3ZSB1c2UgdG9rZW4gY2F0ZWdvcmllcyB3ZSBzaG91bGQgdXNlIHRva2VuTWF0Y2hlciBldmVyeXdoZXJlLlxuICAgICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIHQuSWRlbnRpZmllcikpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzQm9keVR5cGVzLmZpZWxkRGVjbGFyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGFzc0JvZHlUeXBlcy51bmtub3duO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBpbmZvIGZyb20gdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCBJZGVudGlmeSB0aGUgdHlwZSBvZiBhIDxjbGFzc0JvZHlEZWNsYXJhdGlvbj5cIik7XG4gICAgfVxuICB9KTtcblxuICAkLlJVTEUoXCJpc0RpbXNcIiwgKCkgPT4ge1xuICAgICQuTUFOWSgkLmFubm90YXRpb24pO1xuICAgIHJldHVybiAoXG4gICAgICB0b2tlbk1hdGNoZXIodGhpcy5MQSgxKS50b2tlblR5cGUsIHQuTFNxdWFyZSkgJiZcbiAgICAgIHRva2VuTWF0Y2hlcih0aGlzLkxBKDIpLnRva2VuVHlwZSwgdC5SU3F1YXJlKVxuICAgICk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmaW5lUnVsZXNcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/classes.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/expressions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/expressions.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst { tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\nfunction defineRules($, t) {\n  $.RULE(\"constantExpression\", () => {\n    $.SUBRULE($.expression);\n  });\n\n  $.RULE(\"expression\", () => {\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n        ALT: () => $.SUBRULE($.lambdaExpression)\n      },\n      { ALT: () => $.SUBRULE($.ternaryExpression) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-LambdaExpression\n  $.RULE(\"lambdaExpression\", () => {\n    $.SUBRULE($.lambdaParameters);\n    $.CONSUME(t.Arrow);\n    $.SUBRULE($.lambdaBody);\n  });\n\n  $.RULE(\"lambdaParameters\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.lambdaParametersWithBraces) },\n      { ALT: () => $.CONSUME(t.Identifier) }\n    ]);\n  });\n\n  $.RULE(\"lambdaParametersWithBraces\", () => {\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.lambdaParameterList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  $.RULE(\"lambdaParameterList\", () => {\n    $.OR([\n      {\n        GATE: () => {\n          const nextTokType = this.LA(1).tokenType;\n          const nextNextTokType = this.LA(2).tokenType;\n          return (\n            tokenMatcher(nextTokType, t.Identifier) &&\n            (tokenMatcher(nextNextTokType, t.RBrace) ||\n              tokenMatcher(nextNextTokType, t.Comma))\n          );\n        },\n        ALT: () => $.SUBRULE($.inferredLambdaParameterList)\n      },\n      { ALT: () => $.SUBRULE($.explicitLambdaParameterList) }\n    ]);\n  });\n\n  $.RULE(\"inferredLambdaParameterList\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n\n  $.RULE(\"explicitLambdaParameterList\", () => {\n    $.SUBRULE($.lambdaParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.lambdaParameter);\n    });\n  });\n\n  $.RULE(\"lambdaParameter\", () => {\n    // TODO: performance, investigate the performance boost that could\n    //       be gained by refactoring out the backtracking.\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.regularLambdaParameter),\n        ALT: () => $.SUBRULE($.regularLambdaParameter)\n      },\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\n    ]);\n  });\n\n  $.RULE(\"regularLambdaParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.lambdaParameterType);\n    $.SUBRULE($.variableDeclaratorId);\n  });\n\n  $.RULE(\"lambdaParameterType\", () => {\n    $.OR({\n      DEF: [\n        { ALT: () => $.SUBRULE($.unannType) },\n        { ALT: () => $.CONSUME(t.Var) }\n      ],\n      IGNORE_AMBIGUITIES: true\n    });\n  });\n\n  $.RULE(\"lambdaBody\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.expression) },\n      { ALT: () => $.SUBRULE($.block) }\n    ]);\n  });\n\n  $.RULE(\"ternaryExpression\", () => {\n    $.SUBRULE($.binaryExpression);\n    $.OPTION(() => {\n      $.CONSUME(t.QuestionMark);\n      $.SUBRULE($.expression);\n      $.CONSUME(t.Colon);\n      // TODO: in the grammar this is limited to \"lambdaExpression: or \"conditionalExpression\"\n      $.SUBRULE2($.expression);\n    });\n  });\n\n  $.RULE(\"binaryExpression\", () => {\n    $.SUBRULE($.unaryExpression);\n    $.MANY(() => {\n      $.OR({\n        DEF: [\n          {\n            ALT: () => {\n              $.CONSUME(t.Instanceof);\n              $.SUBRULE($.referenceType);\n            }\n          },\n          {\n            ALT: () => {\n              $.CONSUME(t.AssignmentOperator);\n              $.SUBRULE2($.expression);\n            }\n          },\n          // This is an example of why Java does not have a well designed grammar\n          // See: https://manas.tech/blog/2008/10/12/why-java-generics-dont-have-problems-with-right-shift-operator.html\n          // TODO: ensure the LT/GT sequences have no whitespace between each other.\n          {\n            // TODO: this is a bug in Chevrotain lookahead calculation. the \"BinaryOperator\" token can match \"Less\" or \"Greater\"\n            //   as well, but because it is a **token Category** Chevrotain does not understand it need to looks two tokens ahead.\n            GATE: () =>\n              tokenMatcher($.LA(2).tokenType, t.Less) ||\n              tokenMatcher($.LA(2).tokenType, t.Greater),\n            ALT: () => {\n              $.OR2([\n                {\n                  GATE: () => $.LA(1).startOffset + 1 === $.LA(2).startOffset,\n                  ALT: () => {\n                    $.CONSUME(t.Less);\n                    $.CONSUME2(t.Less);\n                  }\n                },\n                {\n                  GATE: () => $.LA(1).startOffset + 1 === $.LA(2).startOffset,\n                  ALT: () => {\n                    $.CONSUME(t.Greater);\n                    $.CONSUME2(t.Greater);\n                    $.OPTION({\n                      GATE: () =>\n                        $.LA(0).startOffset + 1 === $.LA(1).startOffset,\n                      DEF: () => $.CONSUME3(t.Greater)\n                    });\n                  }\n                }\n              ]);\n              $.SUBRULE2($.unaryExpression);\n            }\n          },\n          {\n            ALT: () => {\n              $.CONSUME(t.BinaryOperator);\n              $.SUBRULE3($.unaryExpression);\n            }\n          }\n        ],\n        IGNORE_AMBIGUITIES: true // the ambiguity between 1 and 4 options is resolved by the order (instanceOf is first)\n      });\n    });\n  });\n\n  $.RULE(\"unaryExpression\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperator);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  });\n\n  $.RULE(\"unaryExpressionNotPlusMinus\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperatorNotPlusMinus);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  });\n\n  $.RULE(\"primary\", () => {\n    $.SUBRULE($.primaryPrefix);\n    $.MANY(() => {\n      $.SUBRULE($.primarySuffix);\n    });\n  });\n\n  $.RULE(\"primaryPrefix\", () => {\n    let isCastExpression = false;\n    if (tokenMatcher($.LA(1).tokenType, t.LBrace)) {\n      isCastExpression = this.BACKTRACK_LOOKAHEAD($.isCastExpression);\n    }\n\n    $.OR([\n      { ALT: () => $.SUBRULE($.literal) },\n      { ALT: () => $.CONSUME(t.This) },\n      { ALT: () => $.CONSUME(t.Void) },\n      // should be extracted to primitive type with optional dims suffix?\n      { ALT: () => $.SUBRULE($.numericType) },\n      { ALT: () => $.CONSUME(t.Boolean) },\n      { ALT: () => $.SUBRULE($.fqnOrRefType) },\n      {\n        GATE: () => isCastExpression,\n        ALT: () => $.SUBRULE($.castExpression)\n      },\n      { ALT: () => $.SUBRULE($.parenthesisExpression) },\n      { ALT: () => $.SUBRULE($.newExpression) }\n    ]);\n  });\n\n  $.RULE(\"primarySuffix\", () => {\n    $.OR({\n      DEF: [\n        {\n          ALT: () => {\n            $.CONSUME(t.Dot);\n            $.OR2([\n              { ALT: () => $.CONSUME(t.This) },\n              {\n                ALT: () =>\n                  $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n              },\n              {\n                ALT: () => {\n                  $.OPTION(() => {\n                    $.SUBRULE($.typeArguments);\n                  });\n                  $.CONSUME(t.Identifier);\n                }\n              }\n            ]);\n          }\n        },\n        { ALT: () => $.SUBRULE($.methodInvocationSuffix) },\n        { ALT: () => $.SUBRULE($.classLiteralSuffix) },\n        { ALT: () => $.SUBRULE($.arrayAccessSuffix) },\n        { ALT: () => $.SUBRULE($.methodReferenceSuffix) }\n      ],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  // See https://github.com/jhipster/prettier-java/pull/154 to understand\n  // why fqnOrRefTypePart is split in two rules (First and Rest)\n  $.RULE(\"fqnOrRefType\", () => {\n    $.SUBRULE($.fqnOrRefTypePartFirst);\n\n    $.MANY2({\n      // \".class\" is a classLiteralSuffix\n      GATE: () =>\n        // avoids ambiguity with \".this\" and \".new\" which are parsed as a primary suffix.\n        tokenMatcher(this.LA(2).tokenType, t.Class) === false &&\n        tokenMatcher(this.LA(2).tokenType, t.This) === false &&\n        tokenMatcher(this.LA(2).tokenType, t.New) === false,\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.SUBRULE2($.fqnOrRefTypePartRest);\n      }\n    });\n\n    // in case of an arrayType\n    $.OPTION({\n      // it is not enough to check only the opening \"[\", we must avoid conflict with\n      // arrayAccessSuffix\n      GATE: () =>\n        tokenMatcher($.LA(1).tokenType, t.At) ||\n        tokenMatcher($.LA(2).tokenType, t.RSquare),\n      DEF: () => {\n        $.SUBRULE($.dims);\n      }\n    });\n  });\n\n  // TODO: validation:\n  //       1. \"annotation\" cannot be mixed with \"methodTypeArguments\" or \"Super\".\n  //       2. \"methodTypeArguments\" cannot be mixed with \"classTypeArguments\" or \"annotation\".\n  //       3. \"Super\" cannot be mixed with \"classTypeArguments\" or \"annotation\".\n  //       4. At most one \"Super\" may be used.\n  //       5. \"Super\" may be last or one before last (last may also be first if there is only a single part).\n  $.RULE(\"fqnOrRefTypePartRest\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n\n    $.OPTION({\n      NAME: \"$methodTypeArguments\",\n      DEF: () => {\n        $.SUBRULE2($.typeArguments);\n      }\n    });\n\n    $.SUBRULE($.fqnOrRefTypePartCommon);\n  });\n\n  $.RULE(\"fqnOrRefTypePartCommon\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Identifier) },\n      { ALT: () => $.CONSUME(t.Super) }\n    ]);\n\n    let isRefTypeInMethodRef = false;\n    // Performance optimization, only perform this backtracking when a '<' is found\n    // TODO: performance optimization evaluation: avoid doing this backtracking for every \"<\" encountered.\n    //       we could do it once (using global state) per \"fqnOrRefType\"\n    // We could do it only once for\n    if (tokenMatcher($.LA(1).tokenType, t.Less)) {\n      isRefTypeInMethodRef = this.BACKTRACK_LOOKAHEAD($.isRefTypeInMethodRef);\n    }\n\n    $.OPTION2({\n      NAME: \"$classTypeArguments\",\n      // unrestricted typeArguments here would create an ambiguity with \"LessThan\" operator\n      // e.g: \"var x = a < b;\"\n      // The \"<\" would be parsed as the beginning of a \"typeArguments\"\n      // and we will get an error: \"expecting '>' but found: ';'\"\n      GATE: () => isRefTypeInMethodRef,\n      DEF: () => {\n        $.SUBRULE3($.typeArguments);\n      }\n    });\n  });\n\n  $.RULE(\"fqnOrRefTypePartFirst\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n\n    $.SUBRULE($.fqnOrRefTypePartCommon);\n  });\n\n  $.RULE(\"parenthesisExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n  });\n\n  $.RULE(\"castExpression\", () => {\n    $.OR([\n      {\n        // TODO: performance: can avoid backtracking again here, parent rule could have this information\n        //       when it checks isCastExpression (refactor needed)\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression),\n        ALT: () => $.SUBRULE($.primitiveCastExpression)\n      },\n      { ALT: () => $.SUBRULE($.referenceTypeCastExpression) }\n    ]);\n  });\n\n  $.RULE(\"primitiveCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.unaryExpression);\n  });\n\n  $.RULE(\"referenceTypeCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n        ALT: () => $.SUBRULE($.lambdaExpression)\n      },\n      { ALT: () => $.SUBRULE($.unaryExpressionNotPlusMinus) }\n    ]);\n  });\n\n  const newExpressionTypes = {\n    arrayCreationExpression: 1,\n    unqualifiedClassInstanceCreationExpression: 2\n  };\n  $.RULE(\"newExpression\", () => {\n    const type = this.BACKTRACK_LOOKAHEAD($.identifyNewExpressionType);\n\n    $.OR([\n      {\n        GATE: () => type === newExpressionTypes.arrayCreationExpression,\n        ALT: () => $.SUBRULE($.arrayCreationExpression)\n      },\n      {\n        GATE: () =>\n          type ===\n          newExpressionTypes.unqualifiedClassInstanceCreationExpression,\n        ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-UnqualifiedClassInstanceCreationExpression\n  $.RULE(\"unqualifiedClassInstanceCreationExpression\", () => {\n    $.CONSUME(t.New);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.OPTION3(() => {\n      $.SUBRULE($.classBody);\n    });\n  });\n\n  $.RULE(\"classOrInterfaceTypeToInstantiate\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      $.CONSUME2(t.Identifier);\n    });\n    $.OPTION(() => {\n      $.SUBRULE($.typeArgumentsOrDiamond);\n    });\n  });\n\n  $.RULE(\"typeArgumentsOrDiamond\", () => {\n    $.OR({\n      DEF: [\n        { ALT: () => $.SUBRULE($.diamond) },\n        { ALT: () => $.SUBRULE($.typeArguments) }\n      ],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  $.RULE(\"diamond\", () => {\n    $.CONSUME(t.Less);\n    $.CONSUME(t.Greater);\n  });\n\n  $.RULE(\"methodInvocationSuffix\", () => {\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  $.RULE(\"argumentList\", () => {\n    $.SUBRULE($.expression);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.expression);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.10.1\n  $.RULE(\"arrayCreationExpression\", () => {\n    $.CONSUME(t.New);\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.primitiveType),\n        ALT: () => $.SUBRULE($.primitiveType)\n      },\n      { ALT: () => $.SUBRULE($.classOrInterfaceType) }\n    ]);\n\n    $.OR2([\n      {\n        GATE: $.BACKTRACK($.arrayCreationDefaultInitSuffix),\n        ALT: () => $.SUBRULE($.arrayCreationDefaultInitSuffix)\n      },\n      { ALT: () => $.SUBRULE($.arrayCreationExplicitInitSuffix) }\n    ]);\n  });\n\n  $.RULE(\"arrayCreationDefaultInitSuffix\", () => {\n    $.SUBRULE($.dimExprs);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n  });\n\n  $.RULE(\"arrayCreationExplicitInitSuffix\", () => {\n    $.SUBRULE($.dims);\n    $.SUBRULE($.arrayInitializer);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-DimExprs\n  $.RULE(\"dimExprs\", () => {\n    $.SUBRULE($.dimExpr);\n    $.MANY({\n      // The GATE is to distinguish DimExpr from Dims :\n      // the only difference between these two is the presence of an expression in the DimExpr\n      // Example: If the GATE is not present double[3][] won't be parsed as the parser will try to parse \"[]\"\n      // as a dimExpr instead of a dims\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RSquare) === false,\n      DEF: () => $.SUBRULE2($.dimExpr)\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-DimExpr\n  $.RULE(\"dimExpr\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  });\n\n  $.RULE(\"classLiteralSuffix\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.LSquare);\n      $.CONSUME(t.RSquare);\n    });\n    $.CONSUME(t.Dot);\n    $.CONSUME(t.Class);\n  });\n\n  $.RULE(\"arrayAccessSuffix\", () => {\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  });\n\n  $.RULE(\"methodReferenceSuffix\", () => {\n    $.CONSUME(t.ColonColon);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n\n    $.OR([\n      { ALT: () => $.CONSUME(t.Identifier) },\n      // TODO: a constructor method reference (\"new\") can only be used\n      //   in specific contexts, but perhaps this verification is best left\n      //   for a semantic analysis phase\n      { ALT: () => $.CONSUME(t.New) }\n    ]);\n  });\n\n  // backtracking lookahead logic\n  $.RULE(\"identifyNewExpressionType\", () => {\n    $.CONSUME(t.New);\n    const firstTokenAfterNew = this.LA(1).tokenType;\n\n    // not an array initialization due to the prefix \"TypeArguments\"\n    if (tokenMatcher(firstTokenAfterNew, t.Less)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    try {\n      $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    } catch (e) {\n      // if it is not a \"classOrInterfaceTypeToInstantiate\" then\n      // (assuming a valid input) we are looking at an \"arrayCreationExpression\"\n      return newExpressionTypes.arrayCreationExpression;\n    }\n\n    const firstTokenAfterClassType = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokenAfterClassType, t.LBrace)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    // The LBrace above is mandatory in \"classInstanceCreation...\" so\n    // it must be an \"arrayCreationExp\" (if the input is valid)\n    // TODO: upgrade the logic to return \"unknown\" type if at this\n    //       point it does not match \"arrayCreation\" either.\n    //   - This will provide a better error message to the user\n    //     in case of invalid inputs\n    return newExpressionTypes.arrayCreationExpression;\n  });\n\n  // Optimized backtracking, only scan ahead until the arrow(\"->\").\n  $.RULE(\"isLambdaExpression\", () => {\n    // TODO: this check of next two tokens is probably redundant as the normal lookahead should take care of this.\n    const firstTokenType = this.LA(1).tokenType;\n    const secondTokenType = this.LA(2).tokenType;\n    // no parent lambda \"x -> x * 2\"\n    if (\n      tokenMatcher(firstTokenType, t.Identifier) &&\n      tokenMatcher(secondTokenType, t.Arrow)\n    ) {\n      return true;\n    }\n    // Performance optimizations, fail fast if it is not a LBrace.\n    else if (tokenMatcher(firstTokenType, t.LBrace)) {\n      $.SUBRULE($.lambdaParametersWithBraces);\n      const followedByArrow = tokenMatcher(this.LA(1).tokenType, t.Arrow);\n      return followedByArrow;\n    }\n    return false;\n  });\n\n  $.RULE(\"isCastExpression\", () => {\n    if (this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression)) {\n      return true;\n    }\n    return this.BACKTRACK_LOOKAHEAD($.isReferenceTypeCastExpression);\n  });\n\n  $.RULE(\"isPrimitiveCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    // No dims so this is not a reference Type\n    $.CONSUME(t.RBrace);\n    return true;\n  });\n\n  $.RULE(\"isReferenceTypeCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    const firstTokTypeAfterRBrace = this.LA(1).tokenType;\n\n    return (\n      this.firstForUnaryExpressionNotPlusMinus.find(tokType =>\n        tokenMatcher(firstTokTypeAfterRBrace, tokType)\n      ) !== undefined\n    );\n  });\n\n  $.RULE(\"isRefTypeInMethodRef\", () => {\n    let result = undefined;\n    $.SUBRULE($.typeArguments);\n\n    // arrayType\n    const hasDims = $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n\n    const firstTokTypeAfterTypeArgs = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokTypeAfterTypeArgs, t.ColonColon)) {\n      result = true;\n    }\n    // we must be at the end of a \"referenceType\" if \"dims\" were encountered\n    // So there is not point to check farther\n    else if (hasDims) {\n      result = false;\n    }\n\n    // in the middle of a \"classReferenceType\"\n    $.OPTION2(() => {\n      $.CONSUME(t.Dot);\n      $.SUBRULE($.classOrInterfaceType);\n    });\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    const firstTokTypeAfterRefType = this.LA(1).tokenType;\n    return tokenMatcher(firstTokTypeAfterRefType, t.ColonColon);\n  });\n}\n\nfunction computeFirstForUnaryExpressionNotPlusMinus() {\n  const firstUnaryExpressionNotPlusMinus = this.computeContentAssist(\n    \"unaryExpressionNotPlusMinus\",\n    []\n  );\n  const nextTokTypes = firstUnaryExpressionNotPlusMinus.map(\n    x => x.nextTokenType\n  );\n  // uniq\n  return nextTokTypes.filter((v, i, a) => a.indexOf(v) === i);\n}\n\nmodule.exports = {\n  defineRules,\n  computeFirstForUnaryExpressionNotPlusMinus\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2V4cHJlc3Npb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9wcm9kdWN0aW9ucy9leHByZXNzaW9ucy5qcz9mOWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyB0b2tlbk1hdGNoZXIgfSA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xuZnVuY3Rpb24gZGVmaW5lUnVsZXMoJCwgdCkge1xuICAkLlJVTEUoXCJjb25zdGFudEV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICB9KTtcblxuICAkLlJVTEUoXCJleHByZXNzaW9uXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gdGhpcy5CQUNLVFJBQ0tfTE9PS0FIRUFEKCQuaXNMYW1iZGFFeHByZXNzaW9uKSxcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5sYW1iZGFFeHByZXNzaW9uKVxuICAgICAgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC50ZXJuYXJ5RXhwcmVzc2lvbikgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTUuaHRtbCNqbHMtTGFtYmRhRXhwcmVzc2lvblxuICAkLlJVTEUoXCJsYW1iZGFFeHByZXNzaW9uXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5sYW1iZGFQYXJhbWV0ZXJzKTtcbiAgICAkLkNPTlNVTUUodC5BcnJvdyk7XG4gICAgJC5TVUJSVUxFKCQubGFtYmRhQm9keSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImxhbWJkYVBhcmFtZXRlcnNcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmxhbWJkYVBhcmFtZXRlcnNXaXRoQnJhY2VzKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LklkZW50aWZpZXIpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwibGFtYmRhUGFyYW1ldGVyc1dpdGhCcmFjZXNcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxCcmFjZSk7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQubGFtYmRhUGFyYW1ldGVyTGlzdCk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUkJyYWNlKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwibGFtYmRhUGFyYW1ldGVyTGlzdFwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXh0VG9rVHlwZSA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuICAgICAgICAgIGNvbnN0IG5leHROZXh0VG9rVHlwZSA9IHRoaXMuTEEoMikudG9rZW5UeXBlO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b2tlbk1hdGNoZXIobmV4dFRva1R5cGUsIHQuSWRlbnRpZmllcikgJiZcbiAgICAgICAgICAgICh0b2tlbk1hdGNoZXIobmV4dE5leHRUb2tUeXBlLCB0LlJCcmFjZSkgfHxcbiAgICAgICAgICAgICAgdG9rZW5NYXRjaGVyKG5leHROZXh0VG9rVHlwZSwgdC5Db21tYSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5pbmZlcnJlZExhbWJkYVBhcmFtZXRlckxpc3QpXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmV4cGxpY2l0TGFtYmRhUGFyYW1ldGVyTGlzdCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAkLlJVTEUoXCJpbmZlcnJlZExhbWJkYVBhcmFtZXRlckxpc3RcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgICAkLkNPTlNVTUUyKHQuSWRlbnRpZmllcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImV4cGxpY2l0TGFtYmRhUGFyYW1ldGVyTGlzdFwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQubGFtYmRhUGFyYW1ldGVyKTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgICAgJC5TVUJSVUxFMigkLmxhbWJkYVBhcmFtZXRlcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImxhbWJkYVBhcmFtZXRlclwiLCAoKSA9PiB7XG4gICAgLy8gVE9ETzogcGVyZm9ybWFuY2UsIGludmVzdGlnYXRlIHRoZSBwZXJmb3JtYW5jZSBib29zdCB0aGF0IGNvdWxkXG4gICAgLy8gICAgICAgYmUgZ2FpbmVkIGJ5IHJlZmFjdG9yaW5nIG91dCB0aGUgYmFja3RyYWNraW5nLlxuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAkLkJBQ0tUUkFDSygkLnJlZ3VsYXJMYW1iZGFQYXJhbWV0ZXIpLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnJlZ3VsYXJMYW1iZGFQYXJhbWV0ZXIpXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnZhcmlhYmxlQXJpdHlQYXJhbWV0ZXIpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwicmVndWxhckxhbWJkYVBhcmFtZXRlclwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLmxhbWJkYVBhcmFtZXRlclR5cGUpO1xuICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlRGVjbGFyYXRvcklkKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwibGFtYmRhUGFyYW1ldGVyVHlwZVwiLCAoKSA9PiB7XG4gICAgJC5PUih7XG4gICAgICBERUY6IFtcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnVuYW5uVHlwZSkgfSxcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlZhcikgfVxuICAgICAgXSxcbiAgICAgIElHTk9SRV9BTUJJR1VJVElFUzogdHJ1ZVxuICAgIH0pO1xuICB9KTtcblxuICAkLlJVTEUoXCJsYW1iZGFCb2R5XCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5leHByZXNzaW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmJsb2NrKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInRlcm5hcnlFeHByZXNzaW9uXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5iaW5hcnlFeHByZXNzaW9uKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5RdWVzdGlvbk1hcmspO1xuICAgICAgJC5TVUJSVUxFKCQuZXhwcmVzc2lvbik7XG4gICAgICAkLkNPTlNVTUUodC5Db2xvbik7XG4gICAgICAvLyBUT0RPOiBpbiB0aGUgZ3JhbW1hciB0aGlzIGlzIGxpbWl0ZWQgdG8gXCJsYW1iZGFFeHByZXNzaW9uOiBvciBcImNvbmRpdGlvbmFsRXhwcmVzc2lvblwiXG4gICAgICAkLlNVQlJVTEUyKCQuZXhwcmVzc2lvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImJpbmFyeUV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnVuYXJ5RXhwcmVzc2lvbik7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuT1Ioe1xuICAgICAgICBERUY6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgJC5DT05TVU1FKHQuSW5zdGFuY2VvZik7XG4gICAgICAgICAgICAgICQuU1VCUlVMRSgkLnJlZmVyZW5jZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICAgICQuQ09OU1VNRSh0LkFzc2lnbm1lbnRPcGVyYXRvcik7XG4gICAgICAgICAgICAgICQuU1VCUlVMRTIoJC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZXhhbXBsZSBvZiB3aHkgSmF2YSBkb2VzIG5vdCBoYXZlIGEgd2VsbCBkZXNpZ25lZCBncmFtbWFyXG4gICAgICAgICAgLy8gU2VlOiBodHRwczovL21hbmFzLnRlY2gvYmxvZy8yMDA4LzEwLzEyL3doeS1qYXZhLWdlbmVyaWNzLWRvbnQtaGF2ZS1wcm9ibGVtcy13aXRoLXJpZ2h0LXNoaWZ0LW9wZXJhdG9yLmh0bWxcbiAgICAgICAgICAvLyBUT0RPOiBlbnN1cmUgdGhlIExUL0dUIHNlcXVlbmNlcyBoYXZlIG5vIHdoaXRlc3BhY2UgYmV0d2VlbiBlYWNoIG90aGVyLlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgYSBidWcgaW4gQ2hldnJvdGFpbiBsb29rYWhlYWQgY2FsY3VsYXRpb24uIHRoZSBcIkJpbmFyeU9wZXJhdG9yXCIgdG9rZW4gY2FuIG1hdGNoIFwiTGVzc1wiIG9yIFwiR3JlYXRlclwiXG4gICAgICAgICAgICAvLyAgIGFzIHdlbGwsIGJ1dCBiZWNhdXNlIGl0IGlzIGEgKip0b2tlbiBDYXRlZ29yeSoqIENoZXZyb3RhaW4gZG9lcyBub3QgdW5kZXJzdGFuZCBpdCBuZWVkIHRvIGxvb2tzIHR3byB0b2tlbnMgYWhlYWQuXG4gICAgICAgICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAgICAgICB0b2tlbk1hdGNoZXIoJC5MQSgyKS50b2tlblR5cGUsIHQuTGVzcykgfHxcbiAgICAgICAgICAgICAgdG9rZW5NYXRjaGVyKCQuTEEoMikudG9rZW5UeXBlLCB0LkdyZWF0ZXIpLFxuICAgICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICAgICQuT1IyKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBHQVRFOiAoKSA9PiAkLkxBKDEpLnN0YXJ0T2Zmc2V0ICsgMSA9PT0gJC5MQSgyKS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAkLkNPTlNVTUUodC5MZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgJC5DT05TVU1FMih0Lkxlc3MpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgR0FURTogKCkgPT4gJC5MQSgxKS5zdGFydE9mZnNldCArIDEgPT09ICQuTEEoMikuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJC5DT05TVU1FKHQuR3JlYXRlcik7XG4gICAgICAgICAgICAgICAgICAgICQuQ09OU1VNRTIodC5HcmVhdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgJC5PUFRJT04oe1xuICAgICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAkLkxBKDApLnN0YXJ0T2Zmc2V0ICsgMSA9PT0gJC5MQSgxKS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICBERUY6ICgpID0+ICQuQ09OU1VNRTModC5HcmVhdGVyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAkLlNVQlJVTEUyKCQudW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICAgICAkLkNPTlNVTUUodC5CaW5hcnlPcGVyYXRvcik7XG4gICAgICAgICAgICAgICQuU1VCUlVMRTMoJC51bmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgSUdOT1JFX0FNQklHVUlUSUVTOiB0cnVlIC8vIHRoZSBhbWJpZ3VpdHkgYmV0d2VlbiAxIGFuZCA0IG9wdGlvbnMgaXMgcmVzb2x2ZWQgYnkgdGhlIG9yZGVyIChpbnN0YW5jZU9mIGlzIGZpcnN0KVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInVuYXJ5RXhwcmVzc2lvblwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LlVuYXJ5UHJlZml4T3BlcmF0b3IpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLnByaW1hcnkpO1xuICAgICQuTUFOWTIoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuVW5hcnlTdWZmaXhPcGVyYXRvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInVuYXJ5RXhwcmVzc2lvbk5vdFBsdXNNaW51c1wiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LlVuYXJ5UHJlZml4T3BlcmF0b3JOb3RQbHVzTWludXMpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLnByaW1hcnkpO1xuICAgICQuTUFOWTIoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuVW5hcnlTdWZmaXhPcGVyYXRvcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInByaW1hcnlcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnByaW1hcnlQcmVmaXgpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5wcmltYXJ5U3VmZml4KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwicHJpbWFyeVByZWZpeFwiLCAoKSA9PiB7XG4gICAgbGV0IGlzQ2FzdEV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICBpZiAodG9rZW5NYXRjaGVyKCQuTEEoMSkudG9rZW5UeXBlLCB0LkxCcmFjZSkpIHtcbiAgICAgIGlzQ2FzdEV4cHJlc3Npb24gPSB0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc0Nhc3RFeHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5saXRlcmFsKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlRoaXMpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVm9pZCkgfSxcbiAgICAgIC8vIHNob3VsZCBiZSBleHRyYWN0ZWQgdG8gcHJpbWl0aXZlIHR5cGUgd2l0aCBvcHRpb25hbCBkaW1zIHN1ZmZpeD9cbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5udW1lcmljVHlwZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Cb29sZWFuKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmZxbk9yUmVmVHlwZSkgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gaXNDYXN0RXhwcmVzc2lvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5jYXN0RXhwcmVzc2lvbilcbiAgICAgIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQucGFyZW50aGVzaXNFeHByZXNzaW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLm5ld0V4cHJlc3Npb24pIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwicHJpbWFyeVN1ZmZpeFwiLCAoKSA9PiB7XG4gICAgJC5PUih7XG4gICAgICBERUY6IFtcbiAgICAgICAge1xuICAgICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAgICAgICAgICQuT1IyKFtcbiAgICAgICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlRoaXMpIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBTFQ6ICgpID0+XG4gICAgICAgICAgICAgICAgICAkLlNVQlJVTEUoJC51bnF1YWxpZmllZENsYXNzSW5zdGFuY2VDcmVhdGlvbkV4cHJlc3Npb24pXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBBTFQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJC5TVUJSVUxFKCQudHlwZUFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQubWV0aG9kSW52b2NhdGlvblN1ZmZpeCkgfSxcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmNsYXNzTGl0ZXJhbFN1ZmZpeCkgfSxcbiAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFycmF5QWNjZXNzU3VmZml4KSB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQubWV0aG9kUmVmZXJlbmNlU3VmZml4KSB9XG4gICAgICBdLFxuICAgICAgTUFYX0xPT0tBSEVBRDogMlxuICAgIH0pO1xuICB9KTtcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2poaXBzdGVyL3ByZXR0aWVyLWphdmEvcHVsbC8xNTQgdG8gdW5kZXJzdGFuZFxuICAvLyB3aHkgZnFuT3JSZWZUeXBlUGFydCBpcyBzcGxpdCBpbiB0d28gcnVsZXMgKEZpcnN0IGFuZCBSZXN0KVxuICAkLlJVTEUoXCJmcW5PclJlZlR5cGVcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLmZxbk9yUmVmVHlwZVBhcnRGaXJzdCk7XG5cbiAgICAkLk1BTlkyKHtcbiAgICAgIC8vIFwiLmNsYXNzXCIgaXMgYSBjbGFzc0xpdGVyYWxTdWZmaXhcbiAgICAgIEdBVEU6ICgpID0+XG4gICAgICAgIC8vIGF2b2lkcyBhbWJpZ3VpdHkgd2l0aCBcIi50aGlzXCIgYW5kIFwiLm5ld1wiIHdoaWNoIGFyZSBwYXJzZWQgYXMgYSBwcmltYXJ5IHN1ZmZpeC5cbiAgICAgICAgdG9rZW5NYXRjaGVyKHRoaXMuTEEoMikudG9rZW5UeXBlLCB0LkNsYXNzKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgdG9rZW5NYXRjaGVyKHRoaXMuTEEoMikudG9rZW5UeXBlLCB0LlRoaXMpID09PSBmYWxzZSAmJlxuICAgICAgICB0b2tlbk1hdGNoZXIodGhpcy5MQSgyKS50b2tlblR5cGUsIHQuTmV3KSA9PT0gZmFsc2UsXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAgICAgJC5TVUJSVUxFMigkLmZxbk9yUmVmVHlwZVBhcnRSZXN0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGluIGNhc2Ugb2YgYW4gYXJyYXlUeXBlXG4gICAgJC5PUFRJT04oe1xuICAgICAgLy8gaXQgaXMgbm90IGVub3VnaCB0byBjaGVjayBvbmx5IHRoZSBvcGVuaW5nIFwiW1wiLCB3ZSBtdXN0IGF2b2lkIGNvbmZsaWN0IHdpdGhcbiAgICAgIC8vIGFycmF5QWNjZXNzU3VmZml4XG4gICAgICBHQVRFOiAoKSA9PlxuICAgICAgICB0b2tlbk1hdGNoZXIoJC5MQSgxKS50b2tlblR5cGUsIHQuQXQpIHx8XG4gICAgICAgIHRva2VuTWF0Y2hlcigkLkxBKDIpLnRva2VuVHlwZSwgdC5SU3F1YXJlKSxcbiAgICAgIERFRjogKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUoJC5kaW1zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gVE9ETzogdmFsaWRhdGlvbjpcbiAgLy8gICAgICAgMS4gXCJhbm5vdGF0aW9uXCIgY2Fubm90IGJlIG1peGVkIHdpdGggXCJtZXRob2RUeXBlQXJndW1lbnRzXCIgb3IgXCJTdXBlclwiLlxuICAvLyAgICAgICAyLiBcIm1ldGhvZFR5cGVBcmd1bWVudHNcIiBjYW5ub3QgYmUgbWl4ZWQgd2l0aCBcImNsYXNzVHlwZUFyZ3VtZW50c1wiIG9yIFwiYW5ub3RhdGlvblwiLlxuICAvLyAgICAgICAzLiBcIlN1cGVyXCIgY2Fubm90IGJlIG1peGVkIHdpdGggXCJjbGFzc1R5cGVBcmd1bWVudHNcIiBvciBcImFubm90YXRpb25cIi5cbiAgLy8gICAgICAgNC4gQXQgbW9zdCBvbmUgXCJTdXBlclwiIG1heSBiZSB1c2VkLlxuICAvLyAgICAgICA1LiBcIlN1cGVyXCIgbWF5IGJlIGxhc3Qgb3Igb25lIGJlZm9yZSBsYXN0IChsYXN0IG1heSBhbHNvIGJlIGZpcnN0IGlmIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgcGFydCkuXG4gICQuUlVMRShcImZxbk9yUmVmVHlwZVBhcnRSZXN0XCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgfSk7XG5cbiAgICAkLk9QVElPTih7XG4gICAgICBOQU1FOiBcIiRtZXRob2RUeXBlQXJndW1lbnRzXCIsXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFMigkLnR5cGVBcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5TVUJSVUxFKCQuZnFuT3JSZWZUeXBlUGFydENvbW1vbik7XG4gIH0pO1xuXG4gICQuUlVMRShcImZxbk9yUmVmVHlwZVBhcnRDb21tb25cIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LklkZW50aWZpZXIpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU3VwZXIpIH1cbiAgICBdKTtcblxuICAgIGxldCBpc1JlZlR5cGVJbk1ldGhvZFJlZiA9IGZhbHNlO1xuICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgb25seSBwZXJmb3JtIHRoaXMgYmFja3RyYWNraW5nIHdoZW4gYSAnPCcgaXMgZm91bmRcbiAgICAvLyBUT0RPOiBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gZXZhbHVhdGlvbjogYXZvaWQgZG9pbmcgdGhpcyBiYWNrdHJhY2tpbmcgZm9yIGV2ZXJ5IFwiPFwiIGVuY291bnRlcmVkLlxuICAgIC8vICAgICAgIHdlIGNvdWxkIGRvIGl0IG9uY2UgKHVzaW5nIGdsb2JhbCBzdGF0ZSkgcGVyIFwiZnFuT3JSZWZUeXBlXCJcbiAgICAvLyBXZSBjb3VsZCBkbyBpdCBvbmx5IG9uY2UgZm9yXG4gICAgaWYgKHRva2VuTWF0Y2hlcigkLkxBKDEpLnRva2VuVHlwZSwgdC5MZXNzKSkge1xuICAgICAgaXNSZWZUeXBlSW5NZXRob2RSZWYgPSB0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc1JlZlR5cGVJbk1ldGhvZFJlZik7XG4gICAgfVxuXG4gICAgJC5PUFRJT04yKHtcbiAgICAgIE5BTUU6IFwiJGNsYXNzVHlwZUFyZ3VtZW50c1wiLFxuICAgICAgLy8gdW5yZXN0cmljdGVkIHR5cGVBcmd1bWVudHMgaGVyZSB3b3VsZCBjcmVhdGUgYW4gYW1iaWd1aXR5IHdpdGggXCJMZXNzVGhhblwiIG9wZXJhdG9yXG4gICAgICAvLyBlLmc6IFwidmFyIHggPSBhIDwgYjtcIlxuICAgICAgLy8gVGhlIFwiPFwiIHdvdWxkIGJlIHBhcnNlZCBhcyB0aGUgYmVnaW5uaW5nIG9mIGEgXCJ0eXBlQXJndW1lbnRzXCJcbiAgICAgIC8vIGFuZCB3ZSB3aWxsIGdldCBhbiBlcnJvcjogXCJleHBlY3RpbmcgJz4nIGJ1dCBmb3VuZDogJzsnXCJcbiAgICAgIEdBVEU6ICgpID0+IGlzUmVmVHlwZUluTWV0aG9kUmVmLFxuICAgICAgREVGOiAoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRTMoJC50eXBlQXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiZnFuT3JSZWZUeXBlUGFydEZpcnN0XCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgfSk7XG5cbiAgICAkLlNVQlJVTEUoJC5mcW5PclJlZlR5cGVQYXJ0Q29tbW9uKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwicGFyZW50aGVzaXNFeHByZXNzaW9uXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pO1xuICAgICQuQ09OU1VNRSh0LlJCcmFjZSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImNhc3RFeHByZXNzaW9uXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcGVyZm9ybWFuY2U6IGNhbiBhdm9pZCBiYWNrdHJhY2tpbmcgYWdhaW4gaGVyZSwgcGFyZW50IHJ1bGUgY291bGQgaGF2ZSB0aGlzIGluZm9ybWF0aW9uXG4gICAgICAgIC8vICAgICAgIHdoZW4gaXQgY2hlY2tzIGlzQ2FzdEV4cHJlc3Npb24gKHJlZmFjdG9yIG5lZWRlZClcbiAgICAgICAgR0FURTogKCkgPT4gdGhpcy5CQUNLVFJBQ0tfTE9PS0FIRUFEKCQuaXNQcmltaXRpdmVDYXN0RXhwcmVzc2lvbiksXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQucHJpbWl0aXZlQ2FzdEV4cHJlc3Npb24pXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnJlZmVyZW5jZVR5cGVDYXN0RXhwcmVzc2lvbikgfVxuICAgIF0pO1xuICB9KTtcblxuICAkLlJVTEUoXCJwcmltaXRpdmVDYXN0RXhwcmVzc2lvblwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLlNVQlJVTEUoJC5wcmltaXRpdmVUeXBlKTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuU1VCUlVMRSgkLnVuYXJ5RXhwcmVzc2lvbik7XG4gIH0pO1xuXG4gICQuUlVMRShcInJlZmVyZW5jZVR5cGVDYXN0RXhwcmVzc2lvblwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLlNVQlJVTEUoJC5yZWZlcmVuY2VUeXBlKTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYWRkaXRpb25hbEJvdW5kKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiB0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc0xhbWJkYUV4cHJlc3Npb24pLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmxhbWJkYUV4cHJlc3Npb24pXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnVuYXJ5RXhwcmVzc2lvbk5vdFBsdXNNaW51cykgfVxuICAgIF0pO1xuICB9KTtcblxuICBjb25zdCBuZXdFeHByZXNzaW9uVHlwZXMgPSB7XG4gICAgYXJyYXlDcmVhdGlvbkV4cHJlc3Npb246IDEsXG4gICAgdW5xdWFsaWZpZWRDbGFzc0luc3RhbmNlQ3JlYXRpb25FeHByZXNzaW9uOiAyXG4gIH07XG4gICQuUlVMRShcIm5ld0V4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pZGVudGlmeU5ld0V4cHJlc3Npb25UeXBlKTtcblxuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiB0eXBlID09PSBuZXdFeHByZXNzaW9uVHlwZXMuYXJyYXlDcmVhdGlvbkV4cHJlc3Npb24sXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYXJyYXlDcmVhdGlvbkV4cHJlc3Npb24pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAgIHR5cGUgPT09XG4gICAgICAgICAgbmV3RXhwcmVzc2lvblR5cGVzLnVucXVhbGlmaWVkQ2xhc3NJbnN0YW5jZUNyZWF0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC51bnF1YWxpZmllZENsYXNzSW5zdGFuY2VDcmVhdGlvbkV4cHJlc3Npb24pXG4gICAgICB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0xNS5odG1sI2pscy1VbnF1YWxpZmllZENsYXNzSW5zdGFuY2VDcmVhdGlvbkV4cHJlc3Npb25cbiAgJC5SVUxFKFwidW5xdWFsaWZpZWRDbGFzc0luc3RhbmNlQ3JlYXRpb25FeHByZXNzaW9uXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5OZXcpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnR5cGVBcmd1bWVudHMpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLmNsYXNzT3JJbnRlcmZhY2VUeXBlVG9JbnN0YW50aWF0ZSk7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYXJndW1lbnRMaXN0KTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuT1BUSU9OMygoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5jbGFzc0JvZHkpO1xuICAgIH0pO1xuICB9KTtcblxuICAkLlJVTEUoXCJjbGFzc09ySW50ZXJmYWNlVHlwZVRvSW5zdGFudGlhdGVcIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgICAkLk1BTlkyKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LkRvdCk7XG4gICAgICAkLk1BTlkzKCgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFMigkLmFubm90YXRpb24pO1xuICAgICAgfSk7XG4gICAgICAkLkNPTlNVTUUyKHQuSWRlbnRpZmllcik7XG4gICAgfSk7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudHlwZUFyZ3VtZW50c09yRGlhbW9uZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInR5cGVBcmd1bWVudHNPckRpYW1vbmRcIiwgKCkgPT4ge1xuICAgICQuT1Ioe1xuICAgICAgREVGOiBbXG4gICAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5kaWFtb25kKSB9LFxuICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQudHlwZUFyZ3VtZW50cykgfVxuICAgICAgXSxcbiAgICAgIE1BWF9MT09LQUhFQUQ6IDJcbiAgICB9KTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiZGlhbW9uZFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTGVzcyk7XG4gICAgJC5DT05TVU1FKHQuR3JlYXRlcik7XG4gIH0pO1xuXG4gICQuUlVMRShcIm1ldGhvZEludm9jYXRpb25TdWZmaXhcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxCcmFjZSk7XG4gICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmFyZ3VtZW50TGlzdCk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUkJyYWNlKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiYXJndW1lbnRMaXN0XCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgICAgJC5TVUJSVUxFMigkLmV4cHJlc3Npb24pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTUuaHRtbCNqbHMtMTUuMTAuMVxuICAkLlJVTEUoXCJhcnJheUNyZWF0aW9uRXhwcmVzc2lvblwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuTmV3KTtcbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgR0FURTogJC5CQUNLVFJBQ0soJC5wcmltaXRpdmVUeXBlKSxcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5wcmltaXRpdmVUeXBlKVxuICAgICAgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5jbGFzc09ySW50ZXJmYWNlVHlwZSkgfVxuICAgIF0pO1xuXG4gICAgJC5PUjIoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAkLkJBQ0tUUkFDSygkLmFycmF5Q3JlYXRpb25EZWZhdWx0SW5pdFN1ZmZpeCksXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYXJyYXlDcmVhdGlvbkRlZmF1bHRJbml0U3VmZml4KVxuICAgICAgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hcnJheUNyZWF0aW9uRXhwbGljaXRJbml0U3VmZml4KSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImFycmF5Q3JlYXRpb25EZWZhdWx0SW5pdFN1ZmZpeFwiLCAoKSA9PiB7XG4gICAgJC5TVUJSVUxFKCQuZGltRXhwcnMpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmRpbXMpO1xuICAgIH0pO1xuICB9KTtcblxuICAkLlJVTEUoXCJhcnJheUNyZWF0aW9uRXhwbGljaXRJbml0U3VmZml4XCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5kaW1zKTtcbiAgICAkLlNVQlJVTEUoJC5hcnJheUluaXRpYWxpemVyKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTE1Lmh0bWwjamxzLURpbUV4cHJzXG4gICQuUlVMRShcImRpbUV4cHJzXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5kaW1FeHByKTtcbiAgICAkLk1BTlkoe1xuICAgICAgLy8gVGhlIEdBVEUgaXMgdG8gZGlzdGluZ3Vpc2ggRGltRXhwciBmcm9tIERpbXMgOlxuICAgICAgLy8gdGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZXNlIHR3byBpcyB0aGUgcHJlc2VuY2Ugb2YgYW4gZXhwcmVzc2lvbiBpbiB0aGUgRGltRXhwclxuICAgICAgLy8gRXhhbXBsZTogSWYgdGhlIEdBVEUgaXMgbm90IHByZXNlbnQgZG91YmxlWzNdW10gd29uJ3QgYmUgcGFyc2VkIGFzIHRoZSBwYXJzZXIgd2lsbCB0cnkgdG8gcGFyc2UgXCJbXVwiXG4gICAgICAvLyBhcyBhIGRpbUV4cHIgaW5zdGVhZCBvZiBhIGRpbXNcbiAgICAgIEdBVEU6ICgpID0+IHRva2VuTWF0Y2hlcigkLkxBKDIpLnRva2VuVHlwZSwgdC5SU3F1YXJlKSA9PT0gZmFsc2UsXG4gICAgICBERUY6ICgpID0+ICQuU1VCUlVMRTIoJC5kaW1FeHByKVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMTUuaHRtbCNqbHMtRGltRXhwclxuICAkLlJVTEUoXCJkaW1FeHByXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuTFNxdWFyZSk7XG4gICAgJC5TVUJSVUxFKCQuZXhwcmVzc2lvbik7XG4gICAgJC5DT05TVU1FKHQuUlNxdWFyZSk7XG4gIH0pO1xuXG4gICQuUlVMRShcImNsYXNzTGl0ZXJhbFN1ZmZpeFwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LkxTcXVhcmUpO1xuICAgICAgJC5DT05TVU1FKHQuUlNxdWFyZSk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAkLkNPTlNVTUUodC5DbGFzcyk7XG4gIH0pO1xuXG4gICQuUlVMRShcImFycmF5QWNjZXNzU3VmZml4XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5MU3F1YXJlKTtcbiAgICAkLlNVQlJVTEUoJC5leHByZXNzaW9uKTtcbiAgICAkLkNPTlNVTUUodC5SU3F1YXJlKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwibWV0aG9kUmVmZXJlbmNlU3VmZml4XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5Db2xvbkNvbG9uKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC50eXBlQXJndW1lbnRzKTtcbiAgICB9KTtcblxuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LklkZW50aWZpZXIpIH0sXG4gICAgICAvLyBUT0RPOiBhIGNvbnN0cnVjdG9yIG1ldGhvZCByZWZlcmVuY2UgKFwibmV3XCIpIGNhbiBvbmx5IGJlIHVzZWRcbiAgICAgIC8vICAgaW4gc3BlY2lmaWMgY29udGV4dHMsIGJ1dCBwZXJoYXBzIHRoaXMgdmVyaWZpY2F0aW9uIGlzIGJlc3QgbGVmdFxuICAgICAgLy8gICBmb3IgYSBzZW1hbnRpYyBhbmFseXNpcyBwaGFzZVxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0Lk5ldykgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBiYWNrdHJhY2tpbmcgbG9va2FoZWFkIGxvZ2ljXG4gICQuUlVMRShcImlkZW50aWZ5TmV3RXhwcmVzc2lvblR5cGVcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0Lk5ldyk7XG4gICAgY29uc3QgZmlyc3RUb2tlbkFmdGVyTmV3ID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG5cbiAgICAvLyBub3QgYW4gYXJyYXkgaW5pdGlhbGl6YXRpb24gZHVlIHRvIHRoZSBwcmVmaXggXCJUeXBlQXJndW1lbnRzXCJcbiAgICBpZiAodG9rZW5NYXRjaGVyKGZpcnN0VG9rZW5BZnRlck5ldywgdC5MZXNzKSkge1xuICAgICAgcmV0dXJuIG5ld0V4cHJlc3Npb25UeXBlcy51bnF1YWxpZmllZENsYXNzSW5zdGFuY2VDcmVhdGlvbkV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICQuU1VCUlVMRSgkLmNsYXNzT3JJbnRlcmZhY2VUeXBlVG9JbnN0YW50aWF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgaXQgaXMgbm90IGEgXCJjbGFzc09ySW50ZXJmYWNlVHlwZVRvSW5zdGFudGlhdGVcIiB0aGVuXG4gICAgICAvLyAoYXNzdW1pbmcgYSB2YWxpZCBpbnB1dCkgd2UgYXJlIGxvb2tpbmcgYXQgYW4gXCJhcnJheUNyZWF0aW9uRXhwcmVzc2lvblwiXG4gICAgICByZXR1cm4gbmV3RXhwcmVzc2lvblR5cGVzLmFycmF5Q3JlYXRpb25FeHByZXNzaW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0VG9rZW5BZnRlckNsYXNzVHlwZSA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuICAgIGlmICh0b2tlbk1hdGNoZXIoZmlyc3RUb2tlbkFmdGVyQ2xhc3NUeXBlLCB0LkxCcmFjZSkpIHtcbiAgICAgIHJldHVybiBuZXdFeHByZXNzaW9uVHlwZXMudW5xdWFsaWZpZWRDbGFzc0luc3RhbmNlQ3JlYXRpb25FeHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8vIFRoZSBMQnJhY2UgYWJvdmUgaXMgbWFuZGF0b3J5IGluIFwiY2xhc3NJbnN0YW5jZUNyZWF0aW9uLi4uXCIgc29cbiAgICAvLyBpdCBtdXN0IGJlIGFuIFwiYXJyYXlDcmVhdGlvbkV4cFwiIChpZiB0aGUgaW5wdXQgaXMgdmFsaWQpXG4gICAgLy8gVE9ETzogdXBncmFkZSB0aGUgbG9naWMgdG8gcmV0dXJuIFwidW5rbm93blwiIHR5cGUgaWYgYXQgdGhpc1xuICAgIC8vICAgICAgIHBvaW50IGl0IGRvZXMgbm90IG1hdGNoIFwiYXJyYXlDcmVhdGlvblwiIGVpdGhlci5cbiAgICAvLyAgIC0gVGhpcyB3aWxsIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB0byB0aGUgdXNlclxuICAgIC8vICAgICBpbiBjYXNlIG9mIGludmFsaWQgaW5wdXRzXG4gICAgcmV0dXJuIG5ld0V4cHJlc3Npb25UeXBlcy5hcnJheUNyZWF0aW9uRXhwcmVzc2lvbjtcbiAgfSk7XG5cbiAgLy8gT3B0aW1pemVkIGJhY2t0cmFja2luZywgb25seSBzY2FuIGFoZWFkIHVudGlsIHRoZSBhcnJvdyhcIi0+XCIpLlxuICAkLlJVTEUoXCJpc0xhbWJkYUV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgIC8vIFRPRE86IHRoaXMgY2hlY2sgb2YgbmV4dCB0d28gdG9rZW5zIGlzIHByb2JhYmx5IHJlZHVuZGFudCBhcyB0aGUgbm9ybWFsIGxvb2thaGVhZCBzaG91bGQgdGFrZSBjYXJlIG9mIHRoaXMuXG4gICAgY29uc3QgZmlyc3RUb2tlblR5cGUgPSB0aGlzLkxBKDEpLnRva2VuVHlwZTtcbiAgICBjb25zdCBzZWNvbmRUb2tlblR5cGUgPSB0aGlzLkxBKDIpLnRva2VuVHlwZTtcbiAgICAvLyBubyBwYXJlbnQgbGFtYmRhIFwieCAtPiB4ICogMlwiXG4gICAgaWYgKFxuICAgICAgdG9rZW5NYXRjaGVyKGZpcnN0VG9rZW5UeXBlLCB0LklkZW50aWZpZXIpICYmXG4gICAgICB0b2tlbk1hdGNoZXIoc2Vjb25kVG9rZW5UeXBlLCB0LkFycm93KVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnMsIGZhaWwgZmFzdCBpZiBpdCBpcyBub3QgYSBMQnJhY2UuXG4gICAgZWxzZSBpZiAodG9rZW5NYXRjaGVyKGZpcnN0VG9rZW5UeXBlLCB0LkxCcmFjZSkpIHtcbiAgICAgICQuU1VCUlVMRSgkLmxhbWJkYVBhcmFtZXRlcnNXaXRoQnJhY2VzKTtcbiAgICAgIGNvbnN0IGZvbGxvd2VkQnlBcnJvdyA9IHRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLnRva2VuVHlwZSwgdC5BcnJvdyk7XG4gICAgICByZXR1cm4gZm9sbG93ZWRCeUFycm93O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuXG4gICQuUlVMRShcImlzQ2FzdEV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgIGlmICh0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc1ByaW1pdGl2ZUNhc3RFeHByZXNzaW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc1JlZmVyZW5jZVR5cGVDYXN0RXhwcmVzc2lvbik7XG4gIH0pO1xuXG4gICQuUlVMRShcImlzUHJpbWl0aXZlQ2FzdEV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxCcmFjZSk7XG4gICAgJC5TVUJSVUxFKCQucHJpbWl0aXZlVHlwZSk7XG4gICAgLy8gTm8gZGltcyBzbyB0aGlzIGlzIG5vdCBhIHJlZmVyZW5jZSBUeXBlXG4gICAgJC5DT05TVU1FKHQuUkJyYWNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiaXNSZWZlcmVuY2VUeXBlQ2FzdEV4cHJlc3Npb25cIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxCcmFjZSk7XG4gICAgJC5TVUJSVUxFKCQucmVmZXJlbmNlVHlwZSk7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmFkZGl0aW9uYWxCb3VuZCk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUkJyYWNlKTtcbiAgICBjb25zdCBmaXJzdFRva1R5cGVBZnRlclJCcmFjZSA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZmlyc3RGb3JVbmFyeUV4cHJlc3Npb25Ob3RQbHVzTWludXMuZmluZCh0b2tUeXBlID0+XG4gICAgICAgIHRva2VuTWF0Y2hlcihmaXJzdFRva1R5cGVBZnRlclJCcmFjZSwgdG9rVHlwZSlcbiAgICAgICkgIT09IHVuZGVmaW5lZFxuICAgICk7XG4gIH0pO1xuXG4gICQuUlVMRShcImlzUmVmVHlwZUluTWV0aG9kUmVmXCIsICgpID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICQuU1VCUlVMRSgkLnR5cGVBcmd1bWVudHMpO1xuXG4gICAgLy8gYXJyYXlUeXBlXG4gICAgY29uc3QgaGFzRGltcyA9ICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmRpbXMpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZmlyc3RUb2tUeXBlQWZ0ZXJUeXBlQXJncyA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuICAgIGlmICh0b2tlbk1hdGNoZXIoZmlyc3RUb2tUeXBlQWZ0ZXJUeXBlQXJncywgdC5Db2xvbkNvbG9uKSkge1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gd2UgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgXCJyZWZlcmVuY2VUeXBlXCIgaWYgXCJkaW1zXCIgd2VyZSBlbmNvdW50ZXJlZFxuICAgIC8vIFNvIHRoZXJlIGlzIG5vdCBwb2ludCB0byBjaGVjayBmYXJ0aGVyXG4gICAgZWxzZSBpZiAoaGFzRGltcykge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaW4gdGhlIG1pZGRsZSBvZiBhIFwiY2xhc3NSZWZlcmVuY2VUeXBlXCJcbiAgICAkLk9QVElPTjIoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAgICQuU1VCUlVMRSgkLmNsYXNzT3JJbnRlcmZhY2VUeXBlKTtcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFRva1R5cGVBZnRlclJlZlR5cGUgPSB0aGlzLkxBKDEpLnRva2VuVHlwZTtcbiAgICByZXR1cm4gdG9rZW5NYXRjaGVyKGZpcnN0VG9rVHlwZUFmdGVyUmVmVHlwZSwgdC5Db2xvbkNvbG9uKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGaXJzdEZvclVuYXJ5RXhwcmVzc2lvbk5vdFBsdXNNaW51cygpIHtcbiAgY29uc3QgZmlyc3RVbmFyeUV4cHJlc3Npb25Ob3RQbHVzTWludXMgPSB0aGlzLmNvbXB1dGVDb250ZW50QXNzaXN0KFxuICAgIFwidW5hcnlFeHByZXNzaW9uTm90UGx1c01pbnVzXCIsXG4gICAgW11cbiAgKTtcbiAgY29uc3QgbmV4dFRva1R5cGVzID0gZmlyc3RVbmFyeUV4cHJlc3Npb25Ob3RQbHVzTWludXMubWFwKFxuICAgIHggPT4geC5uZXh0VG9rZW5UeXBlXG4gICk7XG4gIC8vIHVuaXFcbiAgcmV0dXJuIG5leHRUb2tUeXBlcy5maWx0ZXIoKHYsIGksIGEpID0+IGEuaW5kZXhPZih2KSA9PT0gaSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWZpbmVSdWxlcyxcbiAgY29tcHV0ZUZpcnN0Rm9yVW5hcnlFeHByZXNzaW9uTm90UGx1c01pbnVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/expressions.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/interfaces.js":
/*!****************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/interfaces.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst { tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\n\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceDeclaration\n  $.RULE(\"interfaceDeclaration\", () => {\n    // Spec Deviation: extracted the common \"interfaceModifier\" prefix to avoid backtracking.\n    $.MANY({\n      DEF: () => {\n        $.SUBRULE($.interfaceModifier);\n      },\n      MAX_LOOKAHEAD: 2\n    });\n\n    $.OR([\n      { ALT: () => $.SUBRULE($.normalInterfaceDeclaration) },\n      { ALT: () => $.SUBRULE($.annotationTypeDeclaration) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-NormalInterfaceDeclaration\n  $.RULE(\"normalInterfaceDeclaration\", () => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.extendsInterfaces);\n    });\n    $.SUBRULE($.interfaceBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceModifier\n  $.RULE(\"interfaceModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ExtendsInterfaces\n  $.RULE(\"extendsInterfaces\", () => {\n    $.CONSUME(t.Extends);\n    $.SUBRULE($.interfaceTypeList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceBody\n  $.RULE(\"interfaceBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  const InterfaceBodyTypes = {\n    unknown: 0,\n    constantDeclaration: 1,\n    interfaceMethodDeclaration: 2,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceMemberDeclaration\n  $.RULE(\"interfaceMemberDeclaration\", () => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\n      $.identifyInterfaceBodyDeclarationType\n    );\n\n    $.OR([\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.constantDeclaration,\n        ALT: () => $.SUBRULE($.constantDeclaration)\n      },\n      {\n        GATE: () =>\n          detectedType === InterfaceBodyTypes.interfaceMethodDeclaration,\n        ALT: () => $.SUBRULE($.interfaceMethodDeclaration)\n      },\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ConstantDeclaration\n  $.RULE(\"constantDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.constantModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorList);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ConstantModifier\n  $.RULE(\"constantModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceMethodDeclaration\n  $.RULE(\"interfaceMethodDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMethodModifier);\n    });\n    $.SUBRULE($.methodHeader);\n    $.SUBRULE($.methodBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceMethodModifier\n  $.RULE(\"interfaceMethodModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Default) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-AnnotationTypeDeclaration\n  $.RULE(\"annotationTypeDeclaration\", () => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.At);\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.SUBRULE($.annotationTypeBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-AnnotationTypeBody\n  $.RULE(\"annotationTypeBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  const AnnotationBodyTypes = {\n    unknown: 0,\n    annotationTypeElementDeclaration: 2,\n    constantDeclaration: 1,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-InterfaceMemberDeclaration\n  $.RULE(\"annotationTypeMemberDeclaration\", () => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\n      $.identifyAnnotationBodyDeclarationType\n    );\n\n    $.OR([\n      {\n        GATE: () =>\n          detectedType === AnnotationBodyTypes.annotationTypeElementDeclaration,\n        ALT: () => $.SUBRULE($.annotationTypeElementDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.constantDeclaration,\n        ALT: () => $.SUBRULE($.constantDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-AnnotationTypeElementDeclaration\n  $.RULE(\"annotationTypeElementDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeElementModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.LBrace);\n    $.CONSUME(t.RBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.defaultValue);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-AnnotationTypeElementModifier\n  $.RULE(\"annotationTypeElementModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Abstract) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-DefaultValue\n  $.RULE(\"defaultValue\", () => {\n    $.CONSUME(t.Default);\n    $.SUBRULE($.elementValue);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-Annotation\n  $.RULE(\"annotation\", () => {\n    // Spec Deviation: The common prefix for all three annotation types was extracted to this rule.\n    // This was done to avoid the use of backtracking for performance reasons.\n    $.CONSUME(t.At);\n    $.SUBRULE($.typeName);\n\n    // If this optional grammar was not invoked we have a markerAnnotation\n    // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-MarkerAnnotation\n    $.OPTION(() => {\n      $.CONSUME(t.LBrace);\n      $.OR({\n        DEF: [\n          // normal annotation - https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-NormalAnnotation\n          { ALT: () => $.SUBRULE($.elementValuePairList) },\n          // Single Element Annotation - https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-SingleElementAnnotation\n          {\n            ALT: () => $.SUBRULE($.elementValue)\n          },\n          {\n            ALT: () => {\n              /* empty normal annotation contents */\n            }\n          }\n        ],\n        IGNORE_AMBIGUITIES: true,\n        MAX_LOOKAHEAD: 2\n      });\n      $.CONSUME(t.RBrace);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ElementValuePairList\n  $.RULE(\"elementValuePairList\", () => {\n    $.SUBRULE($.elementValuePair);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.elementValuePair);\n    });\n  });\n\n  $.RULE(\"elementValuePair\", () => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Equals);\n    $.SUBRULE($.elementValue);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ElementValue\n  $.RULE(\"elementValue\", () => {\n    const isSimpleElementValueAnnotation = this.BACKTRACK_LOOKAHEAD(\n      $.isSimpleElementValueAnnotation\n    );\n\n    $.OR([\n      // Spec Deviation: \"conditionalExpression\" replaced with \"expression\"\n      // Because we cannot differentiate between the two using fixed lookahead.\n      {\n        GATE: () => isSimpleElementValueAnnotation === false,\n        ALT: () => $.SUBRULE($.expression)\n      },\n      { ALT: () => $.SUBRULE($.elementValueArrayInitializer) },\n      {\n        GATE: () => isSimpleElementValueAnnotation === true,\n        ALT: () => $.SUBRULE($.annotation)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ElementValueArrayInitializer\n  $.RULE(\"elementValueArrayInitializer\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.elementValueList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-ElementValueList\n  $.RULE(\"elementValueList\", () => {\n    $.SUBRULE($.elementValue);\n    $.MANY({\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RCurly) === false,\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.elementValue);\n      }\n    });\n  });\n\n  // ------------------------------------\n  // Special optimized backtracking rules.\n  // ------------------------------------\n  $.RULE(\"identifyInterfaceBodyDeclarationType\", () => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return InterfaceBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () =>\n        (tokenMatcher($.LA(1).tokenType, t.At) &&\n          tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"interfaceMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([\n          { ALT: () => $.SUBRULE($.annotation) },\n          { ALT: () => $.CONSUME(t.Public) },\n          { ALT: () => $.CONSUME(t.Protected) },\n          { ALT: () => $.CONSUME(t.Private) },\n          { ALT: () => $.CONSUME(t.Static) },\n          { ALT: () => $.CONSUME(t.Final) },\n          { ALT: () => $.CONSUME(t.Abstract) },\n          { ALT: () => $.CONSUME(t.Default) },\n          { ALT: () => $.CONSUME(t.Strictfp) }\n        ]);\n      }\n    });\n\n    nextTokenType = this.LA(1).tokenType;\n    if (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    ) {\n      return InterfaceBodyTypes.classDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Interface) ||\n      tokenMatcher(nextTokenType, t.At)\n    ) {\n      return InterfaceBodyTypes.interfaceDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Void) ||\n      tokenMatcher(nextTokenType, t.Less)\n    ) {\n      // method with result type \"void\"\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n\n    // Only constant or interfaceMethod declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n\n    const nextToken = this.LA(1);\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like method start\n    if (\n      tokenMatcher(nextToken, t.Identifier) &&\n      tokenMatcher(nextNextTokenType, t.LBrace)\n    ) {\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextToken, t.Identifier)) {\n      return InterfaceBodyTypes.constantDeclaration;\n    }\n    return InterfaceBodyTypes.unknown;\n  });\n\n  $.RULE(\"identifyAnnotationBodyDeclarationType\", () => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return AnnotationBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () =>\n        (tokenMatcher($.LA(1).tokenType, t.At) &&\n          tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"annotationTypeMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([\n          { ALT: () => $.SUBRULE($.annotation) },\n          { ALT: () => $.CONSUME(t.Public) },\n          { ALT: () => $.CONSUME(t.Protected) },\n          { ALT: () => $.CONSUME(t.Private) },\n          { ALT: () => $.CONSUME(t.Abstract) },\n          { ALT: () => $.CONSUME(t.Static) },\n          { ALT: () => $.CONSUME(t.Final) },\n          { ALT: () => $.CONSUME(t.Strictfp) }\n        ]);\n      }\n    });\n\n    nextTokenType = this.LA(1).tokenType;\n    if (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    ) {\n      return AnnotationBodyTypes.classDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Interface) ||\n      tokenMatcher(nextTokenType, t.At)\n    ) {\n      return AnnotationBodyTypes.interfaceDeclaration;\n    }\n\n    // Only constant or annotationTypeElement declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n\n    nextTokenType = this.LA(1).tokenType;\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like annotationTypeElement start\n    if (\n      tokenMatcher(nextTokenType, t.Identifier) &&\n      tokenMatcher(nextNextTokenType, t.LBrace)\n    ) {\n      return AnnotationBodyTypes.annotationTypeElementDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextTokenType, t.Identifier)) {\n      return AnnotationBodyTypes.constantDeclaration;\n    }\n    return AnnotationBodyTypes.unknown;\n  });\n\n  $.RULE(\"isSimpleElementValueAnnotation\", () => {\n    $.SUBRULE($.annotation);\n    const nextTokenType = this.LA(1).tokenType;\n    switch (nextTokenType) {\n      // annotation in \"ElementValue\" would be followed by one of those\n      // any other TokenType would indicate it is an annotation in a \"referenceType\"\n      // as part of a \"methodReference\" in \"primary\"\n      case t.Comma:\n      case t.Semicolon:\n      case t.RCurly:\n      case t.RBrace:\n        return true;\n      default:\n        return false;\n    }\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2ludGVyZmFjZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2ludGVyZmFjZXMuanM/ZmQ3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHsgdG9rZW5NYXRjaGVyIH0gPSByZXF1aXJlKFwiY2hldnJvdGFpblwiKTtcblxuZnVuY3Rpb24gZGVmaW5lUnVsZXMoJCwgdCkge1xuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1JbnRlcmZhY2VEZWNsYXJhdGlvblxuICAkLlJVTEUoXCJpbnRlcmZhY2VEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IGV4dHJhY3RlZCB0aGUgY29tbW9uIFwiaW50ZXJmYWNlTW9kaWZpZXJcIiBwcmVmaXggdG8gYXZvaWQgYmFja3RyYWNraW5nLlxuICAgICQuTUFOWSh7XG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFKCQuaW50ZXJmYWNlTW9kaWZpZXIpO1xuICAgICAgfSxcbiAgICAgIE1BWF9MT09LQUhFQUQ6IDJcbiAgICB9KTtcblxuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLm5vcm1hbEludGVyZmFjZURlY2xhcmF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFubm90YXRpb25UeXBlRGVjbGFyYXRpb24pIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTkuaHRtbCNqbHMtTm9ybWFsSW50ZXJmYWNlRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwibm9ybWFsSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBUaGUgXCJpbnRlcmZhY2VNb2RpZmllclwiIHByZWZpeCB3YXMgZXh0cmFjdGVkIHRvIHRoZSBcImludGVyZmFjZURlY2xhcmF0aW9uXCJcbiAgICAkLkNPTlNVTUUodC5JbnRlcmZhY2UpO1xuICAgICQuU1VCUlVMRSgkLnR5cGVJZGVudGlmaWVyKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC50eXBlUGFyYW1ldGVycyk7XG4gICAgfSk7XG4gICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmV4dGVuZHNJbnRlcmZhY2VzKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5pbnRlcmZhY2VCb2R5KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTkuaHRtbCNqbHMtSW50ZXJmYWNlTW9kaWZpZXJcbiAgJC5SVUxFKFwiaW50ZXJmYWNlTW9kaWZpZXJcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmFubm90YXRpb24pIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHVibGljKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlByb3RlY3RlZCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcml2YXRlKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkFic3RyYWN0KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0YXRpYykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TdHJpY3RmcCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1FeHRlbmRzSW50ZXJmYWNlc1xuICAkLlJVTEUoXCJleHRlbmRzSW50ZXJmYWNlc1wiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuRXh0ZW5kcyk7XG4gICAgJC5TVUJSVUxFKCQuaW50ZXJmYWNlVHlwZUxpc3QpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1JbnRlcmZhY2VCb2R5XG4gICQuUlVMRShcImludGVyZmFjZUJvZHlcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxDdXJseSk7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmludGVyZmFjZU1lbWJlckRlY2xhcmF0aW9uKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQ3VybHkpO1xuICB9KTtcblxuICBjb25zdCBJbnRlcmZhY2VCb2R5VHlwZXMgPSB7XG4gICAgdW5rbm93bjogMCxcbiAgICBjb25zdGFudERlY2xhcmF0aW9uOiAxLFxuICAgIGludGVyZmFjZU1ldGhvZERlY2xhcmF0aW9uOiAyLFxuICAgIGNsYXNzRGVjbGFyYXRpb246IDMsXG4gICAgaW50ZXJmYWNlRGVjbGFyYXRpb246IDQsXG4gICAgc2VtaUNvbG9uOiA1XG4gIH07XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTkuaHRtbCNqbHMtSW50ZXJmYWNlTWVtYmVyRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwiaW50ZXJmYWNlTWVtYmVyRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgIGNvbnN0IGRldGVjdGVkVHlwZSA9IHRoaXMuQkFDS1RSQUNLX0xPT0tBSEVBRChcbiAgICAgICQuaWRlbnRpZnlJbnRlcmZhY2VCb2R5RGVjbGFyYXRpb25UeXBlXG4gICAgKTtcblxuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiBkZXRlY3RlZFR5cGUgPT09IEludGVyZmFjZUJvZHlUeXBlcy5jb25zdGFudERlY2xhcmF0aW9uLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmNvbnN0YW50RGVjbGFyYXRpb24pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAgIGRldGVjdGVkVHlwZSA9PT0gSW50ZXJmYWNlQm9keVR5cGVzLmludGVyZmFjZU1ldGhvZERlY2xhcmF0aW9uLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmludGVyZmFjZU1ldGhvZERlY2xhcmF0aW9uKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gZGV0ZWN0ZWRUeXBlID09PSBJbnRlcmZhY2VCb2R5VHlwZXMuY2xhc3NEZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5jbGFzc0RlY2xhcmF0aW9uKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gZGV0ZWN0ZWRUeXBlID09PSBJbnRlcmZhY2VCb2R5VHlwZXMuaW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuaW50ZXJmYWNlRGVjbGFyYXRpb24pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBObyBHQVRFIGlzIG5lZWRlZCBhcyB0aGlzIGlzIExMKDEpXG4gICAgICAgIEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU2VtaWNvbG9uKVxuICAgICAgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1Db25zdGFudERlY2xhcmF0aW9uXG4gICQuUlVMRShcImNvbnN0YW50RGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5jb25zdGFudE1vZGlmaWVyKTtcbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC51bmFublR5cGUpO1xuICAgICQuU1VCUlVMRSgkLnZhcmlhYmxlRGVjbGFyYXRvckxpc3QpO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUNvbnN0YW50TW9kaWZpZXJcbiAgJC5SVUxFKFwiY29uc3RhbnRNb2RpZmllclwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYW5ub3RhdGlvbikgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5QdWJsaWMpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU3RhdGljKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkZpbmFsKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUludGVyZmFjZU1ldGhvZERlY2xhcmF0aW9uXG4gICQuUlVMRShcImludGVyZmFjZU1ldGhvZERlY2xhcmF0aW9uXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuaW50ZXJmYWNlTWV0aG9kTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLm1ldGhvZEhlYWRlcik7XG4gICAgJC5TVUJSVUxFKCQubWV0aG9kQm9keSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUludGVyZmFjZU1ldGhvZE1vZGlmaWVyXG4gICQuUlVMRShcImludGVyZmFjZU1ldGhvZE1vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlB1YmxpYykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcml2YXRlKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkFic3RyYWN0KSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkRlZmF1bHQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuU3RhdGljKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0cmljdGZwKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUFubm90YXRpb25UeXBlRGVjbGFyYXRpb25cbiAgJC5SVUxFKFwiYW5ub3RhdGlvblR5cGVEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IFRoZSBcImludGVyZmFjZU1vZGlmaWVyXCIgcHJlZml4IHdhcyBleHRyYWN0ZWQgdG8gdGhlIFwiaW50ZXJmYWNlRGVjbGFyYXRpb25cIlxuICAgICQuQ09OU1VNRSh0LkF0KTtcbiAgICAkLkNPTlNVTUUodC5JbnRlcmZhY2UpO1xuICAgICQuU1VCUlVMRSgkLnR5cGVJZGVudGlmaWVyKTtcbiAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uVHlwZUJvZHkpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1Bbm5vdGF0aW9uVHlwZUJvZHlcbiAgJC5SVUxFKFwiYW5ub3RhdGlvblR5cGVCb2R5XCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5MQ3VybHkpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uVHlwZU1lbWJlckRlY2xhcmF0aW9uKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQ3VybHkpO1xuICB9KTtcblxuICBjb25zdCBBbm5vdGF0aW9uQm9keVR5cGVzID0ge1xuICAgIHVua25vd246IDAsXG4gICAgYW5ub3RhdGlvblR5cGVFbGVtZW50RGVjbGFyYXRpb246IDIsXG4gICAgY29uc3RhbnREZWNsYXJhdGlvbjogMSxcbiAgICBjbGFzc0RlY2xhcmF0aW9uOiAzLFxuICAgIGludGVyZmFjZURlY2xhcmF0aW9uOiA0LFxuICAgIHNlbWlDb2xvbjogNVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUludGVyZmFjZU1lbWJlckRlY2xhcmF0aW9uXG4gICQuUlVMRShcImFubm90YXRpb25UeXBlTWVtYmVyRGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgIGNvbnN0IGRldGVjdGVkVHlwZSA9IHRoaXMuQkFDS1RSQUNLX0xPT0tBSEVBRChcbiAgICAgICQuaWRlbnRpZnlBbm5vdGF0aW9uQm9keURlY2xhcmF0aW9uVHlwZVxuICAgICk7XG5cbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT5cbiAgICAgICAgICBkZXRlY3RlZFR5cGUgPT09IEFubm90YXRpb25Cb2R5VHlwZXMuYW5ub3RhdGlvblR5cGVFbGVtZW50RGVjbGFyYXRpb24sXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYW5ub3RhdGlvblR5cGVFbGVtZW50RGVjbGFyYXRpb24pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiBkZXRlY3RlZFR5cGUgPT09IEFubm90YXRpb25Cb2R5VHlwZXMuY29uc3RhbnREZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5jb25zdGFudERlY2xhcmF0aW9uKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gZGV0ZWN0ZWRUeXBlID09PSBBbm5vdGF0aW9uQm9keVR5cGVzLmNsYXNzRGVjbGFyYXRpb24sXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuY2xhc3NEZWNsYXJhdGlvbilcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+IGRldGVjdGVkVHlwZSA9PT0gQW5ub3RhdGlvbkJvZHlUeXBlcy5pbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5pbnRlcmZhY2VEZWNsYXJhdGlvbilcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIE5vIEdBVEUgaXMgbmVlZGVkIGFzIHRoaXMgaXMgTEwoMSlcbiAgICAgICAgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TZW1pY29sb24pXG4gICAgICB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUFubm90YXRpb25UeXBlRWxlbWVudERlY2xhcmF0aW9uXG4gICQuUlVMRShcImFubm90YXRpb25UeXBlRWxlbWVudERlY2xhcmF0aW9uXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvblR5cGVFbGVtZW50TW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLnVuYW5uVHlwZSk7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5DT05TVU1FKHQuTEJyYWNlKTtcbiAgICAkLkNPTlNVTUUodC5SQnJhY2UpO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmRpbXMpO1xuICAgIH0pO1xuICAgICQuT1BUSU9OMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5kZWZhdWx0VmFsdWUpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUFubm90YXRpb25UeXBlRWxlbWVudE1vZGlmaWVyXG4gICQuUlVMRShcImFubm90YXRpb25UeXBlRWxlbWVudE1vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlB1YmxpYykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5BYnN0cmFjdCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1EZWZhdWx0VmFsdWVcbiAgJC5SVUxFKFwiZGVmYXVsdFZhbHVlXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5EZWZhdWx0KTtcbiAgICAkLlNVQlJVTEUoJC5lbGVtZW50VmFsdWUpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1Bbm5vdGF0aW9uXG4gICQuUlVMRShcImFubm90YXRpb25cIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBUaGUgY29tbW9uIHByZWZpeCBmb3IgYWxsIHRocmVlIGFubm90YXRpb24gdHlwZXMgd2FzIGV4dHJhY3RlZCB0byB0aGlzIHJ1bGUuXG4gICAgLy8gVGhpcyB3YXMgZG9uZSB0byBhdm9pZCB0aGUgdXNlIG9mIGJhY2t0cmFja2luZyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAkLkNPTlNVTUUodC5BdCk7XG4gICAgJC5TVUJSVUxFKCQudHlwZU5hbWUpO1xuXG4gICAgLy8gSWYgdGhpcyBvcHRpb25hbCBncmFtbWFyIHdhcyBub3QgaW52b2tlZCB3ZSBoYXZlIGEgbWFya2VyQW5ub3RhdGlvblxuICAgIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLU1hcmtlckFubm90YXRpb25cbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5MQnJhY2UpO1xuICAgICAgJC5PUih7XG4gICAgICAgIERFRjogW1xuICAgICAgICAgIC8vIG5vcm1hbCBhbm5vdGF0aW9uIC0gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTkuaHRtbCNqbHMtTm9ybWFsQW5ub3RhdGlvblxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5lbGVtZW50VmFsdWVQYWlyTGlzdCkgfSxcbiAgICAgICAgICAvLyBTaW5nbGUgRWxlbWVudCBBbm5vdGF0aW9uIC0gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTkuaHRtbCNqbHMtU2luZ2xlRWxlbWVudEFubm90YXRpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmVsZW1lbnRWYWx1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICAgICAvKiBlbXB0eSBub3JtYWwgYW5ub3RhdGlvbiBjb250ZW50cyAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgSUdOT1JFX0FNQklHVUlUSUVTOiB0cnVlLFxuICAgICAgICBNQVhfTE9PS0FIRUFEOiAyXG4gICAgICB9KTtcbiAgICAgICQuQ09OU1VNRSh0LlJCcmFjZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUVsZW1lbnRWYWx1ZVBhaXJMaXN0XG4gICQuUlVMRShcImVsZW1lbnRWYWx1ZVBhaXJMaXN0XCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5lbGVtZW50VmFsdWVQYWlyKTtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKHQuQ29tbWEpO1xuICAgICAgJC5TVUJSVUxFMigkLmVsZW1lbnRWYWx1ZVBhaXIpO1xuICAgIH0pO1xuICB9KTtcblxuICAkLlJVTEUoXCJlbGVtZW50VmFsdWVQYWlyXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgICAkLkNPTlNVTUUodC5FcXVhbHMpO1xuICAgICQuU1VCUlVMRSgkLmVsZW1lbnRWYWx1ZSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy05Lmh0bWwjamxzLUVsZW1lbnRWYWx1ZVxuICAkLlJVTEUoXCJlbGVtZW50VmFsdWVcIiwgKCkgPT4ge1xuICAgIGNvbnN0IGlzU2ltcGxlRWxlbWVudFZhbHVlQW5ub3RhdGlvbiA9IHRoaXMuQkFDS1RSQUNLX0xPT0tBSEVBRChcbiAgICAgICQuaXNTaW1wbGVFbGVtZW50VmFsdWVBbm5vdGF0aW9uXG4gICAgKTtcblxuICAgICQuT1IoW1xuICAgICAgLy8gU3BlYyBEZXZpYXRpb246IFwiY29uZGl0aW9uYWxFeHByZXNzaW9uXCIgcmVwbGFjZWQgd2l0aCBcImV4cHJlc3Npb25cIlxuICAgICAgLy8gQmVjYXVzZSB3ZSBjYW5ub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB0d28gdXNpbmcgZml4ZWQgbG9va2FoZWFkLlxuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiBpc1NpbXBsZUVsZW1lbnRWYWx1ZUFubm90YXRpb24gPT09IGZhbHNlLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmV4cHJlc3Npb24pXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmVsZW1lbnRWYWx1ZUFycmF5SW5pdGlhbGl6ZXIpIH0sXG4gICAgICB7XG4gICAgICAgIEdBVEU6ICgpID0+IGlzU2ltcGxlRWxlbWVudFZhbHVlQW5ub3RhdGlvbiA9PT0gdHJ1ZSxcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKVxuICAgICAgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1FbGVtZW50VmFsdWVBcnJheUluaXRpYWxpemVyXG4gICQuUlVMRShcImVsZW1lbnRWYWx1ZUFycmF5SW5pdGlhbGl6ZXJcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LkxDdXJseSk7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuZWxlbWVudFZhbHVlTGlzdCk7XG4gICAgfSk7XG4gICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICB9KTtcbiAgICAkLkNPTlNVTUUodC5SQ3VybHkpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtOS5odG1sI2pscy1FbGVtZW50VmFsdWVMaXN0XG4gICQuUlVMRShcImVsZW1lbnRWYWx1ZUxpc3RcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLmVsZW1lbnRWYWx1ZSk7XG4gICAgJC5NQU5ZKHtcbiAgICAgIEdBVEU6ICgpID0+IHRva2VuTWF0Y2hlcigkLkxBKDIpLnRva2VuVHlwZSwgdC5SQ3VybHkpID09PSBmYWxzZSxcbiAgICAgIERFRjogKCkgPT4ge1xuICAgICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgICAgICQuU1VCUlVMRTIoJC5lbGVtZW50VmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gU3BlY2lhbCBvcHRpbWl6ZWQgYmFja3RyYWNraW5nIHJ1bGVzLlxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgJC5SVUxFKFwiaWRlbnRpZnlJbnRlcmZhY2VCb2R5RGVjbGFyYXRpb25UeXBlXCIsICgpID0+IHtcbiAgICBsZXQgbmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuVHlwZSwgdC5TZW1pY29sb24pKSB7XG4gICAgICByZXR1cm4gSW50ZXJmYWNlQm9keVR5cGVzLnNlbWlDb2xvbjtcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIHRvIGxvb2sgYmV5b25kIHRoZSBtb2RpZmllcnMgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVjbGFyYXRpb24gdHlwZXMuXG4gICAgJC5NQU5ZKHtcbiAgICAgIC8vIFRvIGF2b2lkIGFtYmlndWl0eSB3aXRoIEBpbnRlcmZhY2UgKFwiQW5ub3RhdGlvblR5cGVEZWNsYXJhdGlvblwiIHZzIFwiQW5ub3RhaW9uXCIpXG4gICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAodG9rZW5NYXRjaGVyKCQuTEEoMSkudG9rZW5UeXBlLCB0LkF0KSAmJlxuICAgICAgICAgIHRva2VuTWF0Y2hlcigkLkxBKDIpLnRva2VuVHlwZSwgdC5JbnRlcmZhY2UpKSA9PT0gZmFsc2UsXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgLy8gVGhpcyBhbHRlcm5hdGlvbiBpbmNsdWRlcyBhbGwgcG9zc2libGUgbW9kaWZpZXJzIGZvciBhbGwgdHlwZXMgb2YgXCJpbnRlcmZhY2VNZW1iZXJEZWNsYXJhdGlvblwiXG4gICAgICAgIC8vIENlcnRhaW4gY29tYmluYXRpb25zIGFyZSBzeW50YWN0aWNhbGx5IGludmFsaWQsIHRoaXMgaXMgKipub3QqKiBjaGVja2VkIGhlcmUsXG4gICAgICAgIC8vIEludmFsaWQgY29tYmluYXRpb25zIHdpbGwgY2F1c2UgYSBkZXNjcmlwdGl2ZSBwYXJzaW5nIGVycm9yIG1lc3NhZ2UgdG8gYmVcbiAgICAgICAgLy8gQ3JlYXRlZCBpbnNpZGUgdGhlIHJlbGV2YW50IHBhcnNpbmcgcnVsZXMgKiphZnRlcioqIHRoaXMgbG9va2FoZWFkXG4gICAgICAgIC8vIGFuYWx5c2lzLlxuICAgICAgICAkLk9SKFtcbiAgICAgICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuYW5ub3RhdGlvbikgfSxcbiAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHVibGljKSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Qcm90ZWN0ZWQpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlByaXZhdGUpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0YXRpYykgfSxcbiAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRmluYWwpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkFic3RyYWN0KSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5EZWZhdWx0KSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TdHJpY3RmcCkgfVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG5leHRUb2tlblR5cGUgPSB0aGlzLkxBKDEpLnRva2VuVHlwZTtcbiAgICBpZiAoXG4gICAgICB0b2tlbk1hdGNoZXIobmV4dFRva2VuVHlwZSwgdC5DbGFzcykgfHxcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkVudW0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gSW50ZXJmYWNlQm9keVR5cGVzLmNsYXNzRGVjbGFyYXRpb247XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkludGVyZmFjZSkgfHxcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkF0KVxuICAgICkge1xuICAgICAgcmV0dXJuIEludGVyZmFjZUJvZHlUeXBlcy5pbnRlcmZhY2VEZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuVm9pZCkgfHxcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0Lkxlc3MpXG4gICAgKSB7XG4gICAgICAvLyBtZXRob2Qgd2l0aCByZXN1bHQgdHlwZSBcInZvaWRcIlxuICAgICAgcmV0dXJuIEludGVyZmFjZUJvZHlUeXBlcy5pbnRlcmZhY2VNZXRob2REZWNsYXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGNvbnN0YW50IG9yIGludGVyZmFjZU1ldGhvZCBkZWNsYXJhdGlvbnMgbWF5IGJlIHZhbGlkIGF0IHRoaXMgcG9pbnQuXG4gICAgLy8gQWxsIG90aGVyIGFsdGVybmF0aXZlcyBzaG91bGQgaGF2ZSBiZWVuIGF0dGVtcHRlZC5cbiAgICAvLyAqKmJvdGgqKiBzdGFydCB3aXRoIFwidW5hbm5UeXBlXCJcbiAgICB0aGlzLlNVQlJVTEUoJC51bmFublR5cGUpO1xuXG4gICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICBjb25zdCBuZXh0TmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMikudG9rZW5UeXBlO1xuICAgIC8vIFwiZm9vKC4uLlwiIC0tPiBsb29rIGxpa2UgbWV0aG9kIHN0YXJ0XG4gICAgaWYgKFxuICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdC5JZGVudGlmaWVyKSAmJlxuICAgICAgdG9rZW5NYXRjaGVyKG5leHROZXh0VG9rZW5UeXBlLCB0LkxCcmFjZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBJbnRlcmZhY2VCb2R5VHlwZXMuaW50ZXJmYWNlTWV0aG9kRGVjbGFyYXRpb247XG4gICAgfVxuICAgIC8vIGEgdmFsaWQgY29uc3RhbnRcbiAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdC5JZGVudGlmaWVyKSkge1xuICAgICAgcmV0dXJuIEludGVyZmFjZUJvZHlUeXBlcy5jb25zdGFudERlY2xhcmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gSW50ZXJmYWNlQm9keVR5cGVzLnVua25vd247XG4gIH0pO1xuXG4gICQuUlVMRShcImlkZW50aWZ5QW5ub3RhdGlvbkJvZHlEZWNsYXJhdGlvblR5cGVcIiwgKCkgPT4ge1xuICAgIGxldCBuZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG4gICAgaWYgKHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LlNlbWljb2xvbikpIHtcbiAgICAgIHJldHVybiBBbm5vdGF0aW9uQm9keVR5cGVzLnNlbWlDb2xvbjtcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIHRvIGxvb2sgYmV5b25kIHRoZSBtb2RpZmllcnMgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgZGVjbGFyYXRpb24gdHlwZXMuXG4gICAgJC5NQU5ZKHtcbiAgICAgIC8vIFRvIGF2b2lkIGFtYmlndWl0eSB3aXRoIEBpbnRlcmZhY2UgKFwiQW5ub3RhdGlvblR5cGVEZWNsYXJhdGlvblwiIHZzIFwiQW5ub3RhaW9uXCIpXG4gICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAodG9rZW5NYXRjaGVyKCQuTEEoMSkudG9rZW5UeXBlLCB0LkF0KSAmJlxuICAgICAgICAgIHRva2VuTWF0Y2hlcigkLkxBKDIpLnRva2VuVHlwZSwgdC5JbnRlcmZhY2UpKSA9PT0gZmFsc2UsXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgLy8gVGhpcyBhbHRlcm5hdGlvbiBpbmNsdWRlcyBhbGwgcG9zc2libGUgbW9kaWZpZXJzIGZvciBhbGwgdHlwZXMgb2YgXCJhbm5vdGF0aW9uVHlwZU1lbWJlckRlY2xhcmF0aW9uXCJcbiAgICAgICAgLy8gQ2VydGFpbiBjb21iaW5hdGlvbnMgYXJlIHN5bnRhY3RpY2FsbHkgaW52YWxpZCwgdGhpcyBpcyAqKm5vdCoqIGNoZWNrZWQgaGVyZSxcbiAgICAgICAgLy8gSW52YWxpZCBjb21iaW5hdGlvbnMgd2lsbCBjYXVzZSBhIGRlc2NyaXB0aXZlIHBhcnNpbmcgZXJyb3IgbWVzc2FnZSB0byBiZVxuICAgICAgICAvLyBDcmVhdGVkIGluc2lkZSB0aGUgcmVsZXZhbnQgcGFyc2luZyBydWxlcyAqKmFmdGVyKiogdGhpcyBsb29rYWhlYWRcbiAgICAgICAgLy8gYW5hbHlzaXMuXG4gICAgICAgICQuT1IoW1xuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKSB9LFxuICAgICAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5QdWJsaWMpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlByb3RlY3RlZCkgfSxcbiAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuUHJpdmF0ZSkgfSxcbiAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuQWJzdHJhY3QpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0YXRpYykgfSxcbiAgICAgICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRmluYWwpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0cmljdGZwKSB9XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMSkudG9rZW5UeXBlO1xuICAgIGlmIChcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkNsYXNzKSB8fFxuICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuRW51bSlcbiAgICApIHtcbiAgICAgIHJldHVybiBBbm5vdGF0aW9uQm9keVR5cGVzLmNsYXNzRGVjbGFyYXRpb247XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkludGVyZmFjZSkgfHxcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0LkF0KVxuICAgICkge1xuICAgICAgcmV0dXJuIEFubm90YXRpb25Cb2R5VHlwZXMuaW50ZXJmYWNlRGVjbGFyYXRpb247XG4gICAgfVxuXG4gICAgLy8gT25seSBjb25zdGFudCBvciBhbm5vdGF0aW9uVHlwZUVsZW1lbnQgZGVjbGFyYXRpb25zIG1heSBiZSB2YWxpZCBhdCB0aGlzIHBvaW50LlxuICAgIC8vIEFsbCBvdGhlciBhbHRlcm5hdGl2ZXMgc2hvdWxkIGhhdmUgYmVlbiBhdHRlbXB0ZWQuXG4gICAgLy8gKipib3RoKiogc3RhcnQgd2l0aCBcInVuYW5uVHlwZVwiXG4gICAgdGhpcy5TVUJSVUxFKCQudW5hbm5UeXBlKTtcblxuICAgIG5leHRUb2tlblR5cGUgPSB0aGlzLkxBKDEpLnRva2VuVHlwZTtcbiAgICBjb25zdCBuZXh0TmV4dFRva2VuVHlwZSA9IHRoaXMuTEEoMikudG9rZW5UeXBlO1xuICAgIC8vIFwiZm9vKC4uLlwiIC0tPiBsb29rIGxpa2UgYW5ub3RhdGlvblR5cGVFbGVtZW50IHN0YXJ0XG4gICAgaWYgKFxuICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuSWRlbnRpZmllcikgJiZcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0TmV4dFRva2VuVHlwZSwgdC5MQnJhY2UpXG4gICAgKSB7XG4gICAgICByZXR1cm4gQW5ub3RhdGlvbkJvZHlUeXBlcy5hbm5vdGF0aW9uVHlwZUVsZW1lbnREZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgLy8gYSB2YWxpZCBjb25zdGFudFxuICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuVHlwZSwgdC5JZGVudGlmaWVyKSkge1xuICAgICAgcmV0dXJuIEFubm90YXRpb25Cb2R5VHlwZXMuY29uc3RhbnREZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIEFubm90YXRpb25Cb2R5VHlwZXMudW5rbm93bjtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiaXNTaW1wbGVFbGVtZW50VmFsdWVBbm5vdGF0aW9uXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgICBjb25zdCBuZXh0VG9rZW5UeXBlID0gdGhpcy5MQSgxKS50b2tlblR5cGU7XG4gICAgc3dpdGNoIChuZXh0VG9rZW5UeXBlKSB7XG4gICAgICAvLyBhbm5vdGF0aW9uIGluIFwiRWxlbWVudFZhbHVlXCIgd291bGQgYmUgZm9sbG93ZWQgYnkgb25lIG9mIHRob3NlXG4gICAgICAvLyBhbnkgb3RoZXIgVG9rZW5UeXBlIHdvdWxkIGluZGljYXRlIGl0IGlzIGFuIGFubm90YXRpb24gaW4gYSBcInJlZmVyZW5jZVR5cGVcIlxuICAgICAgLy8gYXMgcGFydCBvZiBhIFwibWV0aG9kUmVmZXJlbmNlXCIgaW4gXCJwcmltYXJ5XCJcbiAgICAgIGNhc2UgdC5Db21tYTpcbiAgICAgIGNhc2UgdC5TZW1pY29sb246XG4gICAgICBjYXNlIHQuUkN1cmx5OlxuICAgICAgY2FzZSB0LlJCcmFjZTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVJ1bGVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/interfaces.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/lexical-structure.js":
/*!***********************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/lexical-structure.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-Literal\n  $.RULE(\"literal\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.integerLiteral) },\n      { ALT: () => $.SUBRULE($.floatingPointLiteral) },\n      { ALT: () => $.SUBRULE($.booleanLiteral) },\n      { ALT: () => $.CONSUME(t.CharLiteral) },\n      { ALT: () => $.CONSUME(t.StringLiteral) },\n      { ALT: () => $.CONSUME(t.Null) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-IntegerLiteral\n  $.RULE(\"integerLiteral\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.DecimalLiteral) },\n      { ALT: () => $.CONSUME(t.HexLiteral) },\n      { ALT: () => $.CONSUME(t.OctalLiteral) },\n      { ALT: () => $.CONSUME(t.BinaryLiteral) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-FloatingPointLiteral\n  $.RULE(\"floatingPointLiteral\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.FloatLiteral) },\n      { ALT: () => $.CONSUME(t.HexFloatLiteral) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-BooleanLiteral\n  $.RULE(\"booleanLiteral\", () => {\n    $.OR([{ ALT: () => $.CONSUME(t.True) }, { ALT: () => $.CONSUME(t.False) }]);\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL2xleGljYWwtc3RydWN0dXJlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9wcm9kdWN0aW9ucy9sZXhpY2FsLXN0cnVjdHVyZS5qcz81OTQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gZGVmaW5lUnVsZXMoJCwgdCkge1xuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMy5odG1sI2pscy1MaXRlcmFsXG4gICQuUlVMRShcImxpdGVyYWxcIiwgKCkgPT4ge1xuICAgICQuT1IoW1xuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmludGVnZXJMaXRlcmFsKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmZsb2F0aW5nUG9pbnRMaXRlcmFsKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmJvb2xlYW5MaXRlcmFsKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkNoYXJMaXRlcmFsKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlN0cmluZ0xpdGVyYWwpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuTnVsbCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMy5odG1sI2pscy1JbnRlZ2VyTGl0ZXJhbFxuICAkLlJVTEUoXCJpbnRlZ2VyTGl0ZXJhbFwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRGVjaW1hbExpdGVyYWwpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuSGV4TGl0ZXJhbCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5PY3RhbExpdGVyYWwpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuQmluYXJ5TGl0ZXJhbCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMy5odG1sI2pscy1GbG9hdGluZ1BvaW50TGl0ZXJhbFxuICAkLlJVTEUoXCJmbG9hdGluZ1BvaW50TGl0ZXJhbFwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRmxvYXRMaXRlcmFsKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LkhleEZsb2F0TGl0ZXJhbCkgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMy5odG1sI2pscy1Cb29sZWFuTGl0ZXJhbFxuICAkLlJVTEUoXCJib29sZWFuTGl0ZXJhbFwiLCAoKSA9PiB7XG4gICAgJC5PUihbeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlRydWUpIH0sIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5GYWxzZSkgfV0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVJ1bGVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/lexical-structure.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/names.js":
/*!***********************************************************!*\
  !*** ./node_modules/java-parser/src/productions/names.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst { tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-ModuleName\n  $.RULE(\"moduleName\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-PackageName\n  $.RULE(\"packageName\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-TypeName\n  $.RULE(\"typeName\", () => {\n    // Spec Deviation: The last Identifier in a \"typeName\" may not be be \"var\"\n    //                 But the parser does not check for that.\n    // TODO: post parsing semantic check: last \"Identifier\" in a \"typeName\"\n    //                                    cannot be the \"var\" keyword\n    // TODO: option 2 implement \"Not Var\" Ident using token categories?\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-ExpressionName\n  $.RULE(\"expressionName\", () => {\n    // Spec Deviation: in-lined \"ambiguousName\" to be LL(K)\n    $.CONSUME(t.Identifier);\n    $.MANY({\n      // expressionName could be called by \"qualifiedExplicitConstructorInvocation\"\n      // in that case it may be followed by \".super\" so we need to look two tokens\n      // ahead.\n      GATE: () => tokenMatcher(this.LA(2).tokenType, t.Identifier),\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.CONSUME2(t.Identifier);\n      }\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-MethodName\n  $.RULE(\"methodName\", () => {\n    $.CONSUME(t.Identifier);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-PackageOrTypeName\n  $.RULE(\"packageOrTypeName\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY({\n      // In some contexts a \"Dot Star\" (.*) may appear\n      // after a \"packageOrTypeName\", by default Chevrotain will\n      // only look a single token ahead (Dot) to determine if another iteration\n      // exists which will cause a parsing error for inputs such as:\n      // \"import a.b.c.*\"\n      GATE: () => tokenMatcher(this.LA(2).tokenType, t.Star) === false,\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.CONSUME2(t.Identifier);\n      }\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-6.html#jls-AmbiguousName\n  $.RULE(\"ambiguousName\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL25hbWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9wcm9kdWN0aW9ucy9uYW1lcy5qcz9hYmY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyB0b2tlbk1hdGNoZXIgfSA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xuZnVuY3Rpb24gZGVmaW5lUnVsZXMoJCwgdCkge1xuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNi5odG1sI2pscy1Nb2R1bGVOYW1lXG4gICQuUlVMRShcIm1vZHVsZU5hbWVcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNi5odG1sI2pscy1QYWNrYWdlTmFtZVxuICAkLlJVTEUoXCJwYWNrYWdlTmFtZVwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LkRvdCk7XG4gICAgICAkLkNPTlNVTUUyKHQuSWRlbnRpZmllcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy02Lmh0bWwjamxzLVR5cGVOYW1lXG4gICQuUlVMRShcInR5cGVOYW1lXCIsICgpID0+IHtcbiAgICAvLyBTcGVjIERldmlhdGlvbjogVGhlIGxhc3QgSWRlbnRpZmllciBpbiBhIFwidHlwZU5hbWVcIiBtYXkgbm90IGJlIGJlIFwidmFyXCJcbiAgICAvLyAgICAgICAgICAgICAgICAgQnV0IHRoZSBwYXJzZXIgZG9lcyBub3QgY2hlY2sgZm9yIHRoYXQuXG4gICAgLy8gVE9ETzogcG9zdCBwYXJzaW5nIHNlbWFudGljIGNoZWNrOiBsYXN0IFwiSWRlbnRpZmllclwiIGluIGEgXCJ0eXBlTmFtZVwiXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ub3QgYmUgdGhlIFwidmFyXCIga2V5d29yZFxuICAgIC8vIFRPRE86IG9wdGlvbiAyIGltcGxlbWVudCBcIk5vdCBWYXJcIiBJZGVudCB1c2luZyB0b2tlbiBjYXRlZ29yaWVzP1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNi5odG1sI2pscy1FeHByZXNzaW9uTmFtZVxuICAkLlJVTEUoXCJleHByZXNzaW9uTmFtZVwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IGluLWxpbmVkIFwiYW1iaWd1b3VzTmFtZVwiIHRvIGJlIExMKEspXG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5NQU5ZKHtcbiAgICAgIC8vIGV4cHJlc3Npb25OYW1lIGNvdWxkIGJlIGNhbGxlZCBieSBcInF1YWxpZmllZEV4cGxpY2l0Q29uc3RydWN0b3JJbnZvY2F0aW9uXCJcbiAgICAgIC8vIGluIHRoYXQgY2FzZSBpdCBtYXkgYmUgZm9sbG93ZWQgYnkgXCIuc3VwZXJcIiBzbyB3ZSBuZWVkIHRvIGxvb2sgdHdvIHRva2Vuc1xuICAgICAgLy8gYWhlYWQuXG4gICAgICBHQVRFOiAoKSA9PiB0b2tlbk1hdGNoZXIodGhpcy5MQSgyKS50b2tlblR5cGUsIHQuSWRlbnRpZmllciksXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNi5odG1sI2pscy1NZXRob2ROYW1lXG4gICQuUlVMRShcIm1ldGhvZE5hbWVcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNi5odG1sI2pscy1QYWNrYWdlT3JUeXBlTmFtZVxuICAkLlJVTEUoXCJwYWNrYWdlT3JUeXBlTmFtZVwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5NQU5ZKHtcbiAgICAgIC8vIEluIHNvbWUgY29udGV4dHMgYSBcIkRvdCBTdGFyXCIgKC4qKSBtYXkgYXBwZWFyXG4gICAgICAvLyBhZnRlciBhIFwicGFja2FnZU9yVHlwZU5hbWVcIiwgYnkgZGVmYXVsdCBDaGV2cm90YWluIHdpbGxcbiAgICAgIC8vIG9ubHkgbG9vayBhIHNpbmdsZSB0b2tlbiBhaGVhZCAoRG90KSB0byBkZXRlcm1pbmUgaWYgYW5vdGhlciBpdGVyYXRpb25cbiAgICAgIC8vIGV4aXN0cyB3aGljaCB3aWxsIGNhdXNlIGEgcGFyc2luZyBlcnJvciBmb3IgaW5wdXRzIHN1Y2ggYXM6XG4gICAgICAvLyBcImltcG9ydCBhLmIuYy4qXCJcbiAgICAgIEdBVEU6ICgpID0+IHRva2VuTWF0Y2hlcih0aGlzLkxBKDIpLnRva2VuVHlwZSwgdC5TdGFyKSA9PT0gZmFsc2UsXG4gICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgJC5DT05TVU1FKHQuRG90KTtcbiAgICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNi5odG1sI2pscy1BbWJpZ3VvdXNOYW1lXG4gICQuUlVMRShcImFtYmlndW91c05hbWVcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0LklkZW50aWZpZXIpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVJ1bGVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/names.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/packages-and-modules.js":
/*!**************************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/packages-and-modules.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst { isRecognitionException, tokenMatcher, EOF } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\n\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#CompilationUnit\n  $.RULE(\"compilationUnit\", () => {\n    // custom optimized backtracking lookahead logic\n    const isModule = $.BACKTRACK_LOOKAHEAD($.isModuleCompilationUnit);\n\n    $.OR([\n      {\n        GATE: () => isModule === false,\n        ALT: () => $.SUBRULE($.ordinaryCompilationUnit)\n      },\n      {\n        ALT: () => $.SUBRULE($.modularCompilationUnit)\n      }\n    ]);\n    // https://github.com/jhipster/prettier-java/pull/217\n    $.CONSUME(EOF);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-OrdinaryCompilationUnit\n  $.RULE(\"ordinaryCompilationUnit\", () => {\n    $.OPTION({\n      GATE: $.BACKTRACK($.packageDeclaration),\n      DEF: () => {\n        $.SUBRULE($.packageDeclaration);\n      }\n    });\n    $.MANY(() => {\n      $.SUBRULE3($.importDeclaration);\n    });\n    $.MANY2(() => {\n      $.SUBRULE($.typeDeclaration);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-ModularCompilationUnit\n  $.RULE(\"modularCompilationUnit\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.importDeclaration);\n    });\n    $.SUBRULE($.moduleDeclaration);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-PackageDeclaration\n  $.RULE(\"packageDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.packageModifier);\n    });\n    $.CONSUME(t.Package);\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n    $.CONSUME2(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-PackageModifier\n  $.RULE(\"packageModifier\", () => {\n    $.SUBRULE($.annotation);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-ImportDeclaration\n  $.RULE(\"importDeclaration\", () => {\n    // Spec Deviation: The spec defines four different kinds of import declarations.\n    //                 Our grammar however combines those into a single rule due to difficulties\n    //                 distinguishing between the alternatives due to unbound common prefix.\n    // TODO: A post parsing step is required to align with the official specs.\n    //       The Identifier \"var\" is not allowed in all positions and variations of the importDeclaration\n    $.OR([\n      {\n        ALT: () => {\n          $.CONSUME(t.Import);\n          $.OPTION(() => {\n            $.CONSUME(t.Static);\n          });\n          $.SUBRULE($.packageOrTypeName);\n          $.OPTION2(() => {\n            $.CONSUME(t.Dot);\n            $.CONSUME(t.Star);\n          });\n          $.CONSUME(t.Semicolon);\n        }\n      },\n      // Spec Deviation: The spec do not allow empty statement in between imports.\n      //                 However Java compiler consider empty statements valid, we chose\n      //                 to support that case, thus deviate from the spec.\n      //                 See here: https://github.com/jhipster/prettier-java/pull/158\n      {\n        ALT: () => $.SUBRULE($.emptyStatement)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-TypeDeclaration\n  $.RULE(\"typeDeclaration\", () => {\n    // TODO: consider extracting the prefix modifiers here to avoid backtracking\n    const isClassDeclaration = this.BACKTRACK_LOOKAHEAD($.isClassDeclaration);\n\n    $.OR([\n      {\n        GATE: () => isClassDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      { ALT: () => $.SUBRULE($.interfaceDeclaration) },\n      { ALT: () => $.CONSUME(t.Semicolon) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-ModuleDeclaration\n  $.RULE(\"moduleDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.OPTION(() => {\n      $.CONSUME(t.Open);\n    });\n    $.CONSUME(t.Module);\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.CONSUME2(t.Identifier);\n    });\n    $.CONSUME(t.LCurly);\n    $.MANY3(() => {\n      $.SUBRULE($.moduleDirective);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-ModuleDirective\n  $.RULE(\"moduleDirective\", () => {\n    // Spec Deviation: Each of the alternatives of \"moduleDirective\" was extracted\n    //                 to its own nonTerminal, to reduce verbosity.\n    $.OR([\n      { ALT: () => $.SUBRULE($.requiresModuleDirective) },\n      { ALT: () => $.SUBRULE($.exportsModuleDirective) },\n      { ALT: () => $.SUBRULE($.opensModuleDirective) },\n      { ALT: () => $.SUBRULE($.usesModuleDirective) },\n      { ALT: () => $.SUBRULE($.providesModuleDirective) }\n    ]);\n  });\n\n  $.RULE(\"requiresModuleDirective\", () => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Requires);\n    $.MANY({\n      GATE: () => {\n        /**\n         * https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.9 -\n         *   There is one exception: immediately to the right of the character sequence `requires` in the ModuleDirective production,\n         *   the character sequence `transitive` is tokenized as a keyword unless it is followed by a separator,\n         *   in which case it is tokenized as an identifier.\n         */\n        return (\n          (tokenMatcher($.LA(1).tokenType, t.Transitive) &&\n            tokenMatcher($.LA(2).tokenType, t.Separators)) === false\n        );\n      },\n      DEF: () => {\n        $.SUBRULE($.requiresModifier);\n      }\n    });\n    $.SUBRULE($.moduleName);\n    $.CONSUME(t.Semicolon);\n  });\n\n  $.RULE(\"exportsModuleDirective\", () => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Exports);\n    $.SUBRULE($.packageName);\n    $.OPTION(() => {\n      $.CONSUME(t.To);\n      $.SUBRULE($.moduleName);\n      $.MANY(() => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.moduleName);\n      });\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  $.RULE(\"opensModuleDirective\", () => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Opens);\n    $.SUBRULE($.packageName);\n    $.OPTION(() => {\n      $.CONSUME(t.To);\n      $.SUBRULE($.moduleName);\n      $.MANY(() => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.moduleName);\n      });\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  $.RULE(\"usesModuleDirective\", () => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Uses);\n    $.SUBRULE($.typeName);\n    $.CONSUME(t.Semicolon);\n  });\n\n  $.RULE(\"providesModuleDirective\", () => {\n    // Spec Deviation: extracted from \"moduleDirective\"\n    $.CONSUME(t.Provides);\n    $.SUBRULE($.typeName);\n    $.CONSUME(t.With);\n    $.SUBRULE2($.typeName);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE3($.typeName);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-7.html#jls-RequiresModifier\n  $.RULE(\"requiresModifier\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Transitive) },\n      { ALT: () => $.CONSUME(t.Static) }\n    ]);\n  });\n\n  $.RULE(\"isModuleCompilationUnit\", () => {\n    $.OPTION(() => {\n      $.SUBRULE($.packageDeclaration);\n      // TODO: this return must be outside the OPTION at the top level rule\n      // a Java Module source code may not contain a package declaration.\n      return false;\n    });\n\n    try {\n      // the \"{importDeclaration}\" is a common prefix\n      $.MANY(() => {\n        $.SUBRULE2($.importDeclaration);\n      });\n\n      $.MANY2({\n        // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n        GATE: () =>\n          (tokenMatcher($.LA(1).tokenType, t.At) &&\n            tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n        DEF: () => {\n          $.SUBRULE($.annotation);\n        }\n      });\n    } catch (e) {\n      // This means we had a syntax error in the imports or annotations\n      // So we can't keep parsing deep enough to make the decision\n      if (isRecognitionException(e)) {\n        // TODO: add original syntax error?\n        throw \"Cannot Identify if the source code is an OrdinaryCompilationUnit or  ModularCompilationUnit\";\n      } else {\n        throw e;\n      }\n    }\n\n    const nextTokenType = this.LA(1).tokenType;\n    return (\n      tokenMatcher(nextTokenType, t.Open) ||\n      tokenMatcher(nextTokenType, t.Module)\n    );\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL3BhY2thZ2VzLWFuZC1tb2R1bGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9wcm9kdWN0aW9ucy9wYWNrYWdlcy1hbmQtbW9kdWxlcy5qcz82YmE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCB0b2tlbk1hdGNoZXIsIEVPRiB9ID0gcmVxdWlyZShcImNoZXZyb3RhaW5cIik7XG5cbmZ1bmN0aW9uIGRlZmluZVJ1bGVzKCQsIHQpIHtcbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTcuaHRtbCNDb21waWxhdGlvblVuaXRcbiAgJC5SVUxFKFwiY29tcGlsYXRpb25Vbml0XCIsICgpID0+IHtcbiAgICAvLyBjdXN0b20gb3B0aW1pemVkIGJhY2t0cmFja2luZyBsb29rYWhlYWQgbG9naWNcbiAgICBjb25zdCBpc01vZHVsZSA9ICQuQkFDS1RSQUNLX0xPT0tBSEVBRCgkLmlzTW9kdWxlQ29tcGlsYXRpb25Vbml0KTtcblxuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAoKSA9PiBpc01vZHVsZSA9PT0gZmFsc2UsXG4gICAgICAgIEFMVDogKCkgPT4gJC5TVUJSVUxFKCQub3JkaW5hcnlDb21waWxhdGlvblVuaXQpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLm1vZHVsYXJDb21waWxhdGlvblVuaXQpXG4gICAgICB9XG4gICAgXSk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2poaXBzdGVyL3ByZXR0aWVyLWphdmEvcHVsbC8yMTdcbiAgICAkLkNPTlNVTUUoRU9GKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTcuaHRtbCNqbHMtT3JkaW5hcnlDb21waWxhdGlvblVuaXRcbiAgJC5SVUxFKFwib3JkaW5hcnlDb21waWxhdGlvblVuaXRcIiwgKCkgPT4ge1xuICAgICQuT1BUSU9OKHtcbiAgICAgIEdBVEU6ICQuQkFDS1RSQUNLKCQucGFja2FnZURlY2xhcmF0aW9uKSxcbiAgICAgIERFRjogKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUoJC5wYWNrYWdlRGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUzKCQuaW1wb3J0RGVjbGFyYXRpb24pO1xuICAgIH0pO1xuICAgICQuTUFOWTIoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudHlwZURlY2xhcmF0aW9uKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTcuaHRtbCNqbHMtTW9kdWxhckNvbXBpbGF0aW9uVW5pdFxuICAkLlJVTEUoXCJtb2R1bGFyQ29tcGlsYXRpb25Vbml0XCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuaW1wb3J0RGVjbGFyYXRpb24pO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLm1vZHVsZURlY2xhcmF0aW9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTcuaHRtbCNqbHMtUGFja2FnZURlY2xhcmF0aW9uXG4gICQuUlVMRShcInBhY2thZ2VEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnBhY2thZ2VNb2RpZmllcik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUGFja2FnZSk7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRTIodC5TZW1pY29sb24pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNy5odG1sI2pscy1QYWNrYWdlTW9kaWZpZXJcbiAgJC5SVUxFKFwicGFja2FnZU1vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTcuaHRtbCNqbHMtSW1wb3J0RGVjbGFyYXRpb25cbiAgJC5SVUxFKFwiaW1wb3J0RGVjbGFyYXRpb25cIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBUaGUgc3BlYyBkZWZpbmVzIGZvdXIgZGlmZmVyZW50IGtpbmRzIG9mIGltcG9ydCBkZWNsYXJhdGlvbnMuXG4gICAgLy8gICAgICAgICAgICAgICAgIE91ciBncmFtbWFyIGhvd2V2ZXIgY29tYmluZXMgdGhvc2UgaW50byBhIHNpbmdsZSBydWxlIGR1ZSB0byBkaWZmaWN1bHRpZXNcbiAgICAvLyAgICAgICAgICAgICAgICAgZGlzdGluZ3Vpc2hpbmcgYmV0d2VlbiB0aGUgYWx0ZXJuYXRpdmVzIGR1ZSB0byB1bmJvdW5kIGNvbW1vbiBwcmVmaXguXG4gICAgLy8gVE9ETzogQSBwb3N0IHBhcnNpbmcgc3RlcCBpcyByZXF1aXJlZCB0byBhbGlnbiB3aXRoIHRoZSBvZmZpY2lhbCBzcGVjcy5cbiAgICAvLyAgICAgICBUaGUgSWRlbnRpZmllciBcInZhclwiIGlzIG5vdCBhbGxvd2VkIGluIGFsbCBwb3NpdGlvbnMgYW5kIHZhcmlhdGlvbnMgb2YgdGhlIGltcG9ydERlY2xhcmF0aW9uXG4gICAgJC5PUihbXG4gICAgICB7XG4gICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICQuQ09OU1VNRSh0LkltcG9ydCk7XG4gICAgICAgICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgICAgICAgJC5DT05TVU1FKHQuU3RhdGljKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkLlNVQlJVTEUoJC5wYWNrYWdlT3JUeXBlTmFtZSk7XG4gICAgICAgICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICAgICAgICQuQ09OU1VNRSh0LkRvdCk7XG4gICAgICAgICAgICAkLkNPTlNVTUUodC5TdGFyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkLkNPTlNVTUUodC5TZW1pY29sb24pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gU3BlYyBEZXZpYXRpb246IFRoZSBzcGVjIGRvIG5vdCBhbGxvdyBlbXB0eSBzdGF0ZW1lbnQgaW4gYmV0d2VlbiBpbXBvcnRzLlxuICAgICAgLy8gICAgICAgICAgICAgICAgIEhvd2V2ZXIgSmF2YSBjb21waWxlciBjb25zaWRlciBlbXB0eSBzdGF0ZW1lbnRzIHZhbGlkLCB3ZSBjaG9zZVxuICAgICAgLy8gICAgICAgICAgICAgICAgIHRvIHN1cHBvcnQgdGhhdCBjYXNlLCB0aHVzIGRldmlhdGUgZnJvbSB0aGUgc3BlYy5cbiAgICAgIC8vICAgICAgICAgICAgICAgICBTZWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2poaXBzdGVyL3ByZXR0aWVyLWphdmEvcHVsbC8xNThcbiAgICAgIHtcbiAgICAgICAgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5lbXB0eVN0YXRlbWVudClcbiAgICAgIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTcuaHRtbCNqbHMtVHlwZURlY2xhcmF0aW9uXG4gICQuUlVMRShcInR5cGVEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgZXh0cmFjdGluZyB0aGUgcHJlZml4IG1vZGlmaWVycyBoZXJlIHRvIGF2b2lkIGJhY2t0cmFja2luZ1xuICAgIGNvbnN0IGlzQ2xhc3NEZWNsYXJhdGlvbiA9IHRoaXMuQkFDS1RSQUNLX0xPT0tBSEVBRCgkLmlzQ2xhc3NEZWNsYXJhdGlvbik7XG5cbiAgICAkLk9SKFtcbiAgICAgIHtcbiAgICAgICAgR0FURTogKCkgPT4gaXNDbGFzc0RlY2xhcmF0aW9uLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmNsYXNzRGVjbGFyYXRpb24pXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmludGVyZmFjZURlY2xhcmF0aW9uKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRSh0LlNlbWljb2xvbikgfVxuICAgIF0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNy5odG1sI2pscy1Nb2R1bGVEZWNsYXJhdGlvblxuICAkLlJVTEUoXCJtb2R1bGVEZWNsYXJhdGlvblwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmFubm90YXRpb24pO1xuICAgIH0pO1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0Lk9wZW4pO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0Lk1vZHVsZSk7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LkxDdXJseSk7XG4gICAgJC5NQU5ZMygoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5tb2R1bGVEaXJlY3RpdmUpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlJDdXJseSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy03Lmh0bWwjamxzLU1vZHVsZURpcmVjdGl2ZVxuICAkLlJVTEUoXCJtb2R1bGVEaXJlY3RpdmVcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBFYWNoIG9mIHRoZSBhbHRlcm5hdGl2ZXMgb2YgXCJtb2R1bGVEaXJlY3RpdmVcIiB3YXMgZXh0cmFjdGVkXG4gICAgLy8gICAgICAgICAgICAgICAgIHRvIGl0cyBvd24gbm9uVGVybWluYWwsIHRvIHJlZHVjZSB2ZXJib3NpdHkuXG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQucmVxdWlyZXNNb2R1bGVEaXJlY3RpdmUpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuZXhwb3J0c01vZHVsZURpcmVjdGl2ZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5vcGVuc01vZHVsZURpcmVjdGl2ZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC51c2VzTW9kdWxlRGlyZWN0aXZlKSB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnByb3ZpZGVzTW9kdWxlRGlyZWN0aXZlKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInJlcXVpcmVzTW9kdWxlRGlyZWN0aXZlXCIsICgpID0+IHtcbiAgICAvLyBTcGVjIERldmlhdGlvbjogZXh0cmFjdGVkIGZyb20gXCJtb2R1bGVEaXJlY3RpdmVcIlxuICAgICQuQ09OU1VNRSh0LlJlcXVpcmVzKTtcbiAgICAkLk1BTlkoe1xuICAgICAgR0FURTogKCkgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTMuaHRtbCNqbHMtMy45IC1cbiAgICAgICAgICogICBUaGVyZSBpcyBvbmUgZXhjZXB0aW9uOiBpbW1lZGlhdGVseSB0byB0aGUgcmlnaHQgb2YgdGhlIGNoYXJhY3RlciBzZXF1ZW5jZSBgcmVxdWlyZXNgIGluIHRoZSBNb2R1bGVEaXJlY3RpdmUgcHJvZHVjdGlvbixcbiAgICAgICAgICogICB0aGUgY2hhcmFjdGVyIHNlcXVlbmNlIGB0cmFuc2l0aXZlYCBpcyB0b2tlbml6ZWQgYXMgYSBrZXl3b3JkIHVubGVzcyBpdCBpcyBmb2xsb3dlZCBieSBhIHNlcGFyYXRvcixcbiAgICAgICAgICogICBpbiB3aGljaCBjYXNlIGl0IGlzIHRva2VuaXplZCBhcyBhbiBpZGVudGlmaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAodG9rZW5NYXRjaGVyKCQuTEEoMSkudG9rZW5UeXBlLCB0LlRyYW5zaXRpdmUpICYmXG4gICAgICAgICAgICB0b2tlbk1hdGNoZXIoJC5MQSgyKS50b2tlblR5cGUsIHQuU2VwYXJhdG9ycykpID09PSBmYWxzZVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIERFRjogKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUoJC5yZXF1aXJlc01vZGlmaWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAkLlNVQlJVTEUoJC5tb2R1bGVOYW1lKTtcbiAgICAkLkNPTlNVTUUodC5TZW1pY29sb24pO1xuICB9KTtcblxuICAkLlJVTEUoXCJleHBvcnRzTW9kdWxlRGlyZWN0aXZlXCIsICgpID0+IHtcbiAgICAvLyBTcGVjIERldmlhdGlvbjogZXh0cmFjdGVkIGZyb20gXCJtb2R1bGVEaXJlY3RpdmVcIlxuICAgICQuQ09OU1VNRSh0LkV4cG9ydHMpO1xuICAgICQuU1VCUlVMRSgkLnBhY2thZ2VOYW1lKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Ubyk7XG4gICAgICAkLlNVQlJVTEUoJC5tb2R1bGVOYW1lKTtcbiAgICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICAgICAgJC5TVUJSVUxFMigkLm1vZHVsZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuU2VtaWNvbG9uKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwib3BlbnNNb2R1bGVEaXJlY3RpdmVcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBleHRyYWN0ZWQgZnJvbSBcIm1vZHVsZURpcmVjdGl2ZVwiXG4gICAgJC5DT05TVU1FKHQuT3BlbnMpO1xuICAgICQuU1VCUlVMRSgkLnBhY2thZ2VOYW1lKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Ubyk7XG4gICAgICAkLlNVQlJVTEUoJC5tb2R1bGVOYW1lKTtcbiAgICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICAgICAgJC5TVUJSVUxFMigkLm1vZHVsZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuU2VtaWNvbG9uKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwidXNlc01vZHVsZURpcmVjdGl2ZVwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IGV4dHJhY3RlZCBmcm9tIFwibW9kdWxlRGlyZWN0aXZlXCJcbiAgICAkLkNPTlNVTUUodC5Vc2VzKTtcbiAgICAkLlNVQlJVTEUoJC50eXBlTmFtZSk7XG4gICAgJC5DT05TVU1FKHQuU2VtaWNvbG9uKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwicHJvdmlkZXNNb2R1bGVEaXJlY3RpdmVcIiwgKCkgPT4ge1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBleHRyYWN0ZWQgZnJvbSBcIm1vZHVsZURpcmVjdGl2ZVwiXG4gICAgJC5DT05TVU1FKHQuUHJvdmlkZXMpO1xuICAgICQuU1VCUlVMRSgkLnR5cGVOYW1lKTtcbiAgICAkLkNPTlNVTUUodC5XaXRoKTtcbiAgICAkLlNVQlJVTEUyKCQudHlwZU5hbWUpO1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Db21tYSk7XG4gICAgICAkLlNVQlJVTEUzKCQudHlwZU5hbWUpO1xuICAgIH0pO1xuICAgICQuQ09OU1VNRSh0LlNlbWljb2xvbik7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy03Lmh0bWwjamxzLVJlcXVpcmVzTW9kaWZpZXJcbiAgJC5SVUxFKFwicmVxdWlyZXNNb2RpZmllclwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuVHJhbnNpdGl2ZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TdGF0aWMpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgJC5SVUxFKFwiaXNNb2R1bGVDb21waWxhdGlvblVuaXRcIiwgKCkgPT4ge1xuICAgICQuT1BUSU9OKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLnBhY2thZ2VEZWNsYXJhdGlvbik7XG4gICAgICAvLyBUT0RPOiB0aGlzIHJldHVybiBtdXN0IGJlIG91dHNpZGUgdGhlIE9QVElPTiBhdCB0aGUgdG9wIGxldmVsIHJ1bGVcbiAgICAgIC8vIGEgSmF2YSBNb2R1bGUgc291cmNlIGNvZGUgbWF5IG5vdCBjb250YWluIGEgcGFja2FnZSBkZWNsYXJhdGlvbi5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICAvLyB0aGUgXCJ7aW1wb3J0RGVjbGFyYXRpb259XCIgaXMgYSBjb21tb24gcHJlZml4XG4gICAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgICAkLlNVQlJVTEUyKCQuaW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgfSk7XG5cbiAgICAgICQuTUFOWTIoe1xuICAgICAgICAvLyBUbyBhdm9pZCBhbWJpZ3VpdHkgd2l0aCBAaW50ZXJmYWNlIChcIkFubm90YXRpb25UeXBlRGVjbGFyYXRpb25cIiB2cyBcIkFubm90YWlvblwiKVxuICAgICAgICBHQVRFOiAoKSA9PlxuICAgICAgICAgICh0b2tlbk1hdGNoZXIoJC5MQSgxKS50b2tlblR5cGUsIHQuQXQpICYmXG4gICAgICAgICAgICB0b2tlbk1hdGNoZXIoJC5MQSgyKS50b2tlblR5cGUsIHQuSW50ZXJmYWNlKSkgPT09IGZhbHNlLFxuICAgICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB3ZSBoYWQgYSBzeW50YXggZXJyb3IgaW4gdGhlIGltcG9ydHMgb3IgYW5ub3RhdGlvbnNcbiAgICAgIC8vIFNvIHdlIGNhbid0IGtlZXAgcGFyc2luZyBkZWVwIGVub3VnaCB0byBtYWtlIHRoZSBkZWNpc2lvblxuICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkpIHtcbiAgICAgICAgLy8gVE9ETzogYWRkIG9yaWdpbmFsIHN5bnRheCBlcnJvcj9cbiAgICAgICAgdGhyb3cgXCJDYW5ub3QgSWRlbnRpZnkgaWYgdGhlIHNvdXJjZSBjb2RlIGlzIGFuIE9yZGluYXJ5Q29tcGlsYXRpb25Vbml0IG9yICBNb2R1bGFyQ29tcGlsYXRpb25Vbml0XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5leHRUb2tlblR5cGUgPSB0aGlzLkxBKDEpLnRva2VuVHlwZTtcbiAgICByZXR1cm4gKFxuICAgICAgdG9rZW5NYXRjaGVyKG5leHRUb2tlblR5cGUsIHQuT3BlbikgfHxcbiAgICAgIHRva2VuTWF0Y2hlcihuZXh0VG9rZW5UeXBlLCB0Lk1vZHVsZSlcbiAgICApO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVJ1bGVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/packages-and-modules.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/productions/types-values-and-variables.js":
/*!********************************************************************************!*\
  !*** ./node_modules/java-parser/src/productions/types-values-and-variables.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst { tokenMatcher } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\n\nfunction defineRules($, t) {\n  // ---------------------\n  // Productions from 4 (Types, Values, and Variables)\n  // ---------------------\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-PrimitiveType\n  $.RULE(\"primitiveType\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.OR([\n      { ALT: () => $.SUBRULE($.numericType) },\n      { ALT: () => $.CONSUME(t.Boolean) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-NumericType\n  $.RULE(\"numericType\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.integralType) },\n      { ALT: () => $.SUBRULE($.floatingPointType) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-IntegralType\n  $.RULE(\"integralType\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Byte) },\n      { ALT: () => $.CONSUME(t.Short) },\n      { ALT: () => $.CONSUME(t.Int) },\n      { ALT: () => $.CONSUME(t.Long) },\n      { ALT: () => $.CONSUME(t.Char) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-FloatingPointType\n  $.RULE(\"floatingPointType\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Float) },\n      { ALT: () => $.CONSUME(t.Double) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-ReferenceType\n  $.RULE(\"referenceType\", () => {\n    $.MANY(() => {\n      // Spec Deviation: by extracting the common \"annotation\" prefix\n      // we can avoid backtracking and thus improve performance.\n      // Note that the annotation prefix is still present inside\n      // \"primitiveType\" and \"classOrInterfaceType\"\n      $.SUBRULE($.annotation);\n    });\n    // Spec Deviation: The array type \"dims\" suffix was extracted to this rule\n    // to avoid backtracking for performance reasons.\n    $.OR({\n      DEF: [\n        {\n          ALT: () => {\n            $.SUBRULE($.primitiveType);\n            $.SUBRULE($.dims);\n          }\n        },\n        {\n          // Spec Deviation: \"typeVariable\" alternative is missing because\n          //                 it is included in \"classOrInterfaceType\"\n          ALT: () => {\n            $.SUBRULE($.classOrInterfaceType);\n            $.OPTION(() => {\n              $.SUBRULE2($.dims);\n            });\n          }\n        }\n      ],\n      IGNORE_AMBIGUITIES: true // annotation prefix was extracted to remove ambiguities\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-ClassOrInterfaceType\n  $.RULE(\"classOrInterfaceType\", () => {\n    // Spec Deviation: The spec says: \"classType | interfaceType\" but \"interfaceType\"\n    //                 is not mentioned in the parser because it is identical to \"classType\"\n    //                 The distinction is **semantic** not syntactic.\n    $.SUBRULE($.classType);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-ClassType\n  $.RULE(\"classType\", () => {\n    // Spec Deviation: Refactored left recursion and alternation to iterations\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.Identifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      // TODO: Semantic Check: This Identifier cannot be \"var\"\n      $.CONSUME2(t.Identifier);\n      $.OPTION2({\n        // To avoid confusion with \"TypeArgumentsOrDiamond\" rule\n        // as we use the \"classType\" rule in the \"identifyNewExpressionType\"\n        // optimized lookahead rule.\n        GATE: () => tokenMatcher($.LA(2).tokenType, t.Greater) === false,\n        DEF: () => {\n          $.SUBRULE2($.typeArguments);\n        }\n      });\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-InterfaceType\n  $.RULE(\"interfaceType\", () => {\n    $.SUBRULE($.classType);\n  });\n\n  $.RULE(\"typeVariable\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    // TODO: Semantic Check: This Identifier cannot be \"var\"\n    $.CONSUME(t.Identifier);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-Dims\n  $.RULE(\"dims\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.LSquare);\n    $.CONSUME(t.RSquare);\n    $.MANY2({\n      GATE: () => $.BACKTRACK_LOOKAHEAD($.isDims),\n      DEF: () => {\n        $.MANY3(() => {\n          $.SUBRULE2($.annotation);\n        });\n        $.CONSUME2(t.LSquare);\n        $.CONSUME2(t.RSquare);\n      }\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-TypeParameter\n  $.RULE(\"typeParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.typeParameterModifier);\n    });\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeBound);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-TypeParameterModifier\n  $.RULE(\"typeParameterModifier\", () => {\n    $.SUBRULE($.annotation);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-TypeBound\n  $.RULE(\"typeBound\", () => {\n    $.CONSUME(t.Extends);\n    // Spec Deviation: The alternative with \"TypeVariable\" is not specified\n    //      because it's syntax is included in \"classOrInterfaceType\"\n    $.SUBRULE($.classOrInterfaceType);\n    $.MANY2(() => {\n      $.SUBRULE($.additionalBound);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-AdditionalBound\n  $.RULE(\"additionalBound\", () => {\n    $.CONSUME(t.And);\n    $.SUBRULE($.interfaceType);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-TypeArguments\n  $.RULE(\"typeArguments\", () => {\n    $.CONSUME(t.Less);\n    $.SUBRULE($.typeArgumentList);\n    $.CONSUME(t.Greater);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-TypeArgumentList\n  $.RULE(\"typeArgumentList\", () => {\n    $.SUBRULE($.typeArgument);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.typeArgument);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-TypeArgument\n  $.RULE(\"typeArgument\", () => {\n    // TODO: performance: evaluate flipping the order of alternatives\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.referenceType),\n        ALT: () => $.SUBRULE($.referenceType)\n      },\n      { ALT: () => $.SUBRULE($.wildcard) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-Wildcard\n  $.RULE(\"wildcard\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.QuestionMark);\n    $.OPTION(() => {\n      $.SUBRULE($.wildcardBounds);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-WildcardBounds\n  $.RULE(\"wildcardBounds\", () => {\n    // TODO: consider in-lining suffix into the alternatives to match the spec more strongly\n    $.OR([\n      { ALT: () => $.CONSUME(t.Extends) },\n      { ALT: () => $.CONSUME(t.Super) }\n    ]);\n    $.SUBRULE($.referenceType);\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Byb2R1Y3Rpb25zL3R5cGVzLXZhbHVlcy1hbmQtdmFyaWFibGVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy9wcm9kdWN0aW9ucy90eXBlcy12YWx1ZXMtYW5kLXZhcmlhYmxlcy5qcz81MDdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IHRva2VuTWF0Y2hlciB9ID0gcmVxdWlyZShcImNoZXZyb3RhaW5cIik7XG5cbmZ1bmN0aW9uIGRlZmluZVJ1bGVzKCQsIHQpIHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFByb2R1Y3Rpb25zIGZyb20gwqc0IChUeXBlcywgVmFsdWVzLCBhbmQgVmFyaWFibGVzKVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1QcmltaXRpdmVUeXBlXG4gICQuUlVMRShcInByaW1pdGl2ZVR5cGVcIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgICB9KTtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5udW1lcmljVHlwZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Cb29sZWFuKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy00Lmh0bWwjamxzLU51bWVyaWNUeXBlXG4gICQuUlVMRShcIm51bWVyaWNUeXBlXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLlNVQlJVTEUoJC5pbnRlZ3JhbFR5cGUpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCQuZmxvYXRpbmdQb2ludFR5cGUpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTQuaHRtbCNqbHMtSW50ZWdyYWxUeXBlXG4gICQuUlVMRShcImludGVncmFsVHlwZVwiLCAoKSA9PiB7XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuQnl0ZSkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TaG9ydCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5JbnQpIH0sXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuTG9uZykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5DaGFyKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy00Lmh0bWwjamxzLUZsb2F0aW5nUG9pbnRUeXBlXG4gICQuUlVMRShcImZsb2F0aW5nUG9pbnRUeXBlXCIsICgpID0+IHtcbiAgICAkLk9SKFtcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5GbG9hdCkgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5Eb3VibGUpIH1cbiAgICBdKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTQuaHRtbCNqbHMtUmVmZXJlbmNlVHlwZVxuICAkLlJVTEUoXCJyZWZlcmVuY2VUeXBlXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgLy8gU3BlYyBEZXZpYXRpb246IGJ5IGV4dHJhY3RpbmcgdGhlIGNvbW1vbiBcImFubm90YXRpb25cIiBwcmVmaXhcbiAgICAgIC8vIHdlIGNhbiBhdm9pZCBiYWNrdHJhY2tpbmcgYW5kIHRodXMgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgYW5ub3RhdGlvbiBwcmVmaXggaXMgc3RpbGwgcHJlc2VudCBpbnNpZGVcbiAgICAgIC8vIFwicHJpbWl0aXZlVHlwZVwiIGFuZCBcImNsYXNzT3JJbnRlcmZhY2VUeXBlXCJcbiAgICAgICQuU1VCUlVMRSgkLmFubm90YXRpb24pO1xuICAgIH0pO1xuICAgIC8vIFNwZWMgRGV2aWF0aW9uOiBUaGUgYXJyYXkgdHlwZSBcImRpbXNcIiBzdWZmaXggd2FzIGV4dHJhY3RlZCB0byB0aGlzIHJ1bGVcbiAgICAvLyB0byBhdm9pZCBiYWNrdHJhY2tpbmcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgJC5PUih7XG4gICAgICBERUY6IFtcbiAgICAgICAge1xuICAgICAgICAgIEFMVDogKCkgPT4ge1xuICAgICAgICAgICAgJC5TVUJSVUxFKCQucHJpbWl0aXZlVHlwZSk7XG4gICAgICAgICAgICAkLlNVQlJVTEUoJC5kaW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTcGVjIERldmlhdGlvbjogXCJ0eXBlVmFyaWFibGVcIiBhbHRlcm5hdGl2ZSBpcyBtaXNzaW5nIGJlY2F1c2VcbiAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgaXQgaXMgaW5jbHVkZWQgaW4gXCJjbGFzc09ySW50ZXJmYWNlVHlwZVwiXG4gICAgICAgICAgQUxUOiAoKSA9PiB7XG4gICAgICAgICAgICAkLlNVQlJVTEUoJC5jbGFzc09ySW50ZXJmYWNlVHlwZSk7XG4gICAgICAgICAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAgICAgICAgICQuU1VCUlVMRTIoJC5kaW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIElHTk9SRV9BTUJJR1VJVElFUzogdHJ1ZSAvLyBhbm5vdGF0aW9uIHByZWZpeCB3YXMgZXh0cmFjdGVkIHRvIHJlbW92ZSBhbWJpZ3VpdGllc1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1DbGFzc09ySW50ZXJmYWNlVHlwZVxuICAkLlJVTEUoXCJjbGFzc09ySW50ZXJmYWNlVHlwZVwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IFRoZSBzcGVjIHNheXM6IFwiY2xhc3NUeXBlIHwgaW50ZXJmYWNlVHlwZVwiIGJ1dCBcImludGVyZmFjZVR5cGVcIlxuICAgIC8vICAgICAgICAgICAgICAgICBpcyBub3QgbWVudGlvbmVkIGluIHRoZSBwYXJzZXIgYmVjYXVzZSBpdCBpcyBpZGVudGljYWwgdG8gXCJjbGFzc1R5cGVcIlxuICAgIC8vICAgICAgICAgICAgICAgICBUaGUgZGlzdGluY3Rpb24gaXMgKipzZW1hbnRpYyoqIG5vdCBzeW50YWN0aWMuXG4gICAgJC5TVUJSVUxFKCQuY2xhc3NUeXBlKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTQuaHRtbCNqbHMtQ2xhc3NUeXBlXG4gICQuUlVMRShcImNsYXNzVHlwZVwiLCAoKSA9PiB7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IFJlZmFjdG9yZWQgbGVmdCByZWN1cnNpb24gYW5kIGFsdGVybmF0aW9uIHRvIGl0ZXJhdGlvbnNcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuSWRlbnRpZmllcik7XG4gICAgJC5PUFRJT04oKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQudHlwZUFyZ3VtZW50cyk7XG4gICAgfSk7XG4gICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUodC5Eb3QpO1xuICAgICAgJC5NQU5ZMygoKSA9PiB7XG4gICAgICAgICQuU1VCUlVMRTIoJC5hbm5vdGF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgLy8gVE9ETzogU2VtYW50aWMgQ2hlY2s6IFRoaXMgSWRlbnRpZmllciBjYW5ub3QgYmUgXCJ2YXJcIlxuICAgICAgJC5DT05TVU1FMih0LklkZW50aWZpZXIpO1xuICAgICAgJC5PUFRJT04yKHtcbiAgICAgICAgLy8gVG8gYXZvaWQgY29uZnVzaW9uIHdpdGggXCJUeXBlQXJndW1lbnRzT3JEaWFtb25kXCIgcnVsZVxuICAgICAgICAvLyBhcyB3ZSB1c2UgdGhlIFwiY2xhc3NUeXBlXCIgcnVsZSBpbiB0aGUgXCJpZGVudGlmeU5ld0V4cHJlc3Npb25UeXBlXCJcbiAgICAgICAgLy8gb3B0aW1pemVkIGxvb2thaGVhZCBydWxlLlxuICAgICAgICBHQVRFOiAoKSA9PiB0b2tlbk1hdGNoZXIoJC5MQSgyKS50b2tlblR5cGUsIHQuR3JlYXRlcikgPT09IGZhbHNlLFxuICAgICAgICBERUY6ICgpID0+IHtcbiAgICAgICAgICAkLlNVQlJVTEUyKCQudHlwZUFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1JbnRlcmZhY2VUeXBlXG4gICQuUlVMRShcImludGVyZmFjZVR5cGVcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLmNsYXNzVHlwZSk7XG4gIH0pO1xuXG4gICQuUlVMRShcInR5cGVWYXJpYWJsZVwiLCAoKSA9PiB7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuU1VCUlVMRSgkLmFubm90YXRpb24pO1xuICAgIH0pO1xuICAgIC8vIFRPRE86IFNlbWFudGljIENoZWNrOiBUaGlzIElkZW50aWZpZXIgY2Fubm90IGJlIFwidmFyXCJcbiAgICAkLkNPTlNVTUUodC5JZGVudGlmaWVyKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTQuaHRtbCNqbHMtRGltc1xuICAkLlJVTEUoXCJkaW1zXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuTFNxdWFyZSk7XG4gICAgJC5DT05TVU1FKHQuUlNxdWFyZSk7XG4gICAgJC5NQU5ZMih7XG4gICAgICBHQVRFOiAoKSA9PiAkLkJBQ0tUUkFDS19MT09LQUhFQUQoJC5pc0RpbXMpLFxuICAgICAgREVGOiAoKSA9PiB7XG4gICAgICAgICQuTUFOWTMoKCkgPT4ge1xuICAgICAgICAgICQuU1VCUlVMRTIoJC5hbm5vdGF0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgICQuQ09OU1VNRTIodC5MU3F1YXJlKTtcbiAgICAgICAgJC5DT05TVU1FMih0LlJTcXVhcmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1UeXBlUGFyYW1ldGVyXG4gICQuUlVMRShcInR5cGVQYXJhbWV0ZXJcIiwgKCkgPT4ge1xuICAgICQuTUFOWSgoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC50eXBlUGFyYW1ldGVyTW9kaWZpZXIpO1xuICAgIH0pO1xuICAgICQuU1VCUlVMRSgkLnR5cGVJZGVudGlmaWVyKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC50eXBlQm91bmQpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1UeXBlUGFyYW1ldGVyTW9kaWZpZXJcbiAgJC5SVUxFKFwidHlwZVBhcmFtZXRlck1vZGlmaWVyXCIsICgpID0+IHtcbiAgICAkLlNVQlJVTEUoJC5hbm5vdGF0aW9uKTtcbiAgfSk7XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTQuaHRtbCNqbHMtVHlwZUJvdW5kXG4gICQuUlVMRShcInR5cGVCb3VuZFwiLCAoKSA9PiB7XG4gICAgJC5DT05TVU1FKHQuRXh0ZW5kcyk7XG4gICAgLy8gU3BlYyBEZXZpYXRpb246IFRoZSBhbHRlcm5hdGl2ZSB3aXRoIFwiVHlwZVZhcmlhYmxlXCIgaXMgbm90IHNwZWNpZmllZFxuICAgIC8vICAgICAgYmVjYXVzZSBpdCdzIHN5bnRheCBpcyBpbmNsdWRlZCBpbiBcImNsYXNzT3JJbnRlcmZhY2VUeXBlXCJcbiAgICAkLlNVQlJVTEUoJC5jbGFzc09ySW50ZXJmYWNlVHlwZSk7XG4gICAgJC5NQU5ZMigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC5hZGRpdGlvbmFsQm91bmQpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1BZGRpdGlvbmFsQm91bmRcbiAgJC5SVUxFKFwiYWRkaXRpb25hbEJvdW5kXCIsICgpID0+IHtcbiAgICAkLkNPTlNVTUUodC5BbmQpO1xuICAgICQuU1VCUlVMRSgkLmludGVyZmFjZVR5cGUpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1UeXBlQXJndW1lbnRzXG4gICQuUlVMRShcInR5cGVBcmd1bWVudHNcIiwgKCkgPT4ge1xuICAgICQuQ09OU1VNRSh0Lkxlc3MpO1xuICAgICQuU1VCUlVMRSgkLnR5cGVBcmd1bWVudExpc3QpO1xuICAgICQuQ09OU1VNRSh0LkdyZWF0ZXIpO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1UeXBlQXJndW1lbnRMaXN0XG4gICQuUlVMRShcInR5cGVBcmd1bWVudExpc3RcIiwgKCkgPT4ge1xuICAgICQuU1VCUlVMRSgkLnR5cGVBcmd1bWVudCk7XG4gICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICQuQ09OU1VNRSh0LkNvbW1hKTtcbiAgICAgICQuU1VCUlVMRTIoJC50eXBlQXJndW1lbnQpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtNC5odG1sI2pscy1UeXBlQXJndW1lbnRcbiAgJC5SVUxFKFwidHlwZUFyZ3VtZW50XCIsICgpID0+IHtcbiAgICAvLyBUT0RPOiBwZXJmb3JtYW5jZTogZXZhbHVhdGUgZmxpcHBpbmcgdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlc1xuICAgICQuT1IoW1xuICAgICAge1xuICAgICAgICBHQVRFOiAkLkJBQ0tUUkFDSygkLnJlZmVyZW5jZVR5cGUpLFxuICAgICAgICBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLnJlZmVyZW5jZVR5cGUpXG4gICAgICB9LFxuICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLndpbGRjYXJkKSB9XG4gICAgXSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy00Lmh0bWwjamxzLVdpbGRjYXJkXG4gICQuUlVMRShcIndpbGRjYXJkXCIsICgpID0+IHtcbiAgICAkLk1BTlkoKCkgPT4ge1xuICAgICAgJC5TVUJSVUxFKCQuYW5ub3RhdGlvbik7XG4gICAgfSk7XG4gICAgJC5DT05TVU1FKHQuUXVlc3Rpb25NYXJrKTtcbiAgICAkLk9QVElPTigoKSA9PiB7XG4gICAgICAkLlNVQlJVTEUoJC53aWxkY2FyZEJvdW5kcyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy00Lmh0bWwjamxzLVdpbGRjYXJkQm91bmRzXG4gICQuUlVMRShcIndpbGRjYXJkQm91bmRzXCIsICgpID0+IHtcbiAgICAvLyBUT0RPOiBjb25zaWRlciBpbi1saW5pbmcgc3VmZml4IGludG8gdGhlIGFsdGVybmF0aXZlcyB0byBtYXRjaCB0aGUgc3BlYyBtb3JlIHN0cm9uZ2x5XG4gICAgJC5PUihbXG4gICAgICB7IEFMVDogKCkgPT4gJC5DT05TVU1FKHQuRXh0ZW5kcykgfSxcbiAgICAgIHsgQUxUOiAoKSA9PiAkLkNPTlNVTUUodC5TdXBlcikgfVxuICAgIF0pO1xuICAgICQuU1VCUlVMRSgkLnJlZmVyZW5jZVR5cGUpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmluZVJ1bGVzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/productions/types-values-and-variables.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/tokens.js":
/*!************************************************!*\
  !*** ./node_modules/java-parser/src/tokens.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst { createToken: createTokenOrg, Lexer } = __webpack_require__(/*! chevrotain */ \"./node_modules/chevrotain/lib_esm/src/api.js\");\nlet chars;\n// A little mini DSL for easier lexer definition.\nconst fragments = {};\ntry {\n  chars = __webpack_require__(/*! ./unicodesets */ \"./node_modules/java-parser/src/unicodesets.js\");\n} catch (e) {\n  throw Error(\n    \"unicodesets.js file could not be found. Did you try to run the command: yarn run build ?\"\n  );\n}\n\nfunction inlineFragments(def) {\n  let inlinedDef = def;\n  Object.keys(fragments).forEach(prevFragmentName => {\n    const prevFragmentDef = fragments[prevFragmentName];\n    const templateRegExp = new RegExp(`{{${prevFragmentName}}}`, \"g\");\n    inlinedDef = inlinedDef.replace(templateRegExp, prevFragmentDef);\n  });\n  return inlinedDef;\n}\n\nfunction FRAGMENT(name, def) {\n  fragments[name] = inlineFragments(def);\n}\n\nfunction MAKE_PATTERN(def, flags) {\n  const inlinedDef = inlineFragments(def);\n  return new RegExp(inlinedDef, flags);\n}\n\n// The order of fragments definitions is important\nFRAGMENT(\"Digits\", \"[0-9]([0-9_]*[0-9])?\");\nFRAGMENT(\"ExponentPart\", \"[eE][+-]?{{Digits}}\");\nFRAGMENT(\"HexDigit\", \"[0-9a-fA-F]\");\nFRAGMENT(\"HexDigits\", \"{{HexDigit}}(({{HexDigit}}|'_')*{{HexDigit}})?\");\nFRAGMENT(\"FloatTypeSuffix\", \"[fFdD]\");\nFRAGMENT(\"LineTerminator\", \"(\\\\x0A|(\\\\x0D(\\\\x0A)?))\");\nFRAGMENT(\"UnicodeMarker\", \"uu*\");\nFRAGMENT(\"UnicodeEscape\", \"\\\\\\\\{{UnicodeMarker}}{{HexDigit}}{4}\");\nFRAGMENT(\"RawInputCharacter\", \"\\\\\\\\{{UnicodeMarker}}[0-9a-fA-F]{4}\");\nFRAGMENT(\"UnicodeInputCharacter\", \"({{UnicodeEscape}}|{{RawInputCharacter}})\");\nFRAGMENT(\"OctalDigit\", \"[0-7]\");\nFRAGMENT(\"ZeroToThree\", \"[0-3]\");\nFRAGMENT(\n  \"OctalEscape\",\n  \"\\\\\\\\({{OctalDigit}}|{{ZeroToThree}}?{{OctalDigit}}{2})\"\n);\nFRAGMENT(\"EscapeSequence\", \"\\\\\\\\[btnfr\\\"'\\\\\\\\]|{{OctalEscape}}\");\n// Not using InputCharacter terminology there because CR and LF are already captured in EscapeSequence\nFRAGMENT(\n  \"StringCharacter\",\n  \"(?:(?:{{EscapeSequence}})|{{UnicodeInputCharacter}})\"\n);\n\nfunction matchJavaIdentifier(text, startOffset) {\n  let endOffset = startOffset;\n  let charCode = text.codePointAt(endOffset);\n\n  // We verifiy if the first character is from one of these categories\n  // Corresponds to the isJavaIdentifierStart function from Java\n  if (chars.firstIdentChar.has(charCode)) {\n    endOffset++;\n    // If we encounter a surrogate pair (something that is beyond 65535/FFFF)\n    // We skip another offset because a surrogate pair is of length 2.\n    if (charCode > 65535) {\n      endOffset++;\n    }\n    charCode = text.codePointAt(endOffset);\n  }\n\n  // We verify if the remaining characters is from one of these categories\n  // Corresponds to the isJavaIdentifierPart function from Java\n  while (chars.restIdentChar.has(charCode)) {\n    endOffset++;\n    // See above.\n    if (charCode > 65535) {\n      endOffset++;\n    }\n    charCode = text.codePointAt(endOffset);\n  }\n\n  // No match, must return null to conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    return null;\n  }\n  const matchedString = text.substring(startOffset, endOffset);\n  // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n  return [matchedString];\n}\n\nconst Identifier = createTokenOrg({\n  name: \"Identifier\",\n  pattern: { exec: matchJavaIdentifier },\n  line_breaks: false,\n  start_chars_hint: Array.from(chars.firstIdentChar, x =>\n    String.fromCharCode(x)\n  )\n});\n\nconst allTokens = [];\nconst tokenDictionary = {};\n\nfunction createToken(options) {\n  // TODO create a test to check all the tokenbs have a label defined\n  if (!options.label) {\n    // simple token (e.g operator)\n    if (typeof options.pattern === \"string\") {\n      options.label = `'${options.pattern}'`;\n    }\n    // Complex token (e.g literal)\n    else if (options.pattern instanceof RegExp) {\n      options.label = `'${options.name}'`;\n    }\n  }\n\n  const newTokenType = createTokenOrg(options);\n  allTokens.push(newTokenType);\n  tokenDictionary[options.name] = newTokenType;\n  return newTokenType;\n}\n\nfunction createKeywordLikeToken(options) {\n  // A keyword 'like' token uses the \"longer_alt\" config option\n  // to resolve ambiguities, see: http://sap.github.io/chevrotain/docs/features/token_alternative_matches.html\n  options.longer_alt = Identifier;\n  return createToken(options);\n}\n\n// Token Categories\n// Used a Token Category to mark all restricted keywords.\n// This could be used in syntax highlights implementation.\nconst RestrictedKeyword = createToken({\n  name: \"RestrictedKeyword\",\n  pattern: Lexer.NA\n});\n\n// Used a Token Category to mark all keywords.\n// This could be used in syntax highlights implementation.\nconst Keyword = createToken({\n  name: \"Keyword\",\n  pattern: Lexer.NA\n});\n\nconst AssignmentOperator = createToken({\n  name: \"AssignmentOperator\",\n  pattern: Lexer.NA\n});\n\nconst BinaryOperator = createToken({\n  name: \"BinaryOperator\",\n  pattern: Lexer.NA\n});\n\nconst UnaryPrefixOperator = createToken({\n  name: \"UnaryPrefixOperator\",\n  pattern: Lexer.NA\n});\nconst UnaryPrefixOperatorNotPlusMinus = createToken({\n  name: \"UnaryPrefixOperatorNotPlusMinus\",\n  pattern: Lexer.NA\n});\n\nconst UnarySuffixOperator = createToken({\n  name: \"UnarySuffixOperator\",\n  pattern: Lexer.NA\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.11\nconst Separators = createToken({\n  name: \"Separators\",\n  pattern: Lexer.NA\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.6\n// Note [\\\\x09\\\\x20\\\\x0C] is equivalent to [\\\\t\\\\x20\\\\f] and that \\\\x20 represents\n// space character\ncreateToken({\n  name: \"WhiteSpace\",\n  pattern: MAKE_PATTERN(\"[\\\\x09\\\\x20\\\\x0C]|{{LineTerminator}}\"),\n  group: Lexer.SKIPPED\n});\ncreateToken({\n  name: \"LineComment\",\n  pattern: /\\/\\/[^\\n\\r]*/,\n  group: \"comments\"\n});\ncreateToken({\n  name: \"TraditionalComment\",\n  pattern: /\\/\\*([^*]|\\*(?!\\/))*\\*\\//,\n  group: \"comments\"\n});\ncreateToken({ name: \"BinaryLiteral\", pattern: /0[bB][01]([01_]*[01])?[lL]?/ });\ncreateToken({\n  name: \"FloatLiteral\",\n  pattern: MAKE_PATTERN(\n    \"{{Digits}}\\\\.({{Digits}})?({{ExponentPart}})?({{FloatTypeSuffix}})?|\" +\n      \"\\\\.{{Digits}}({{ExponentPart}})?({{FloatTypeSuffix}})?|\" +\n      \"{{Digits}}{{ExponentPart}}({{FloatTypeSuffix}})?|\" +\n      \"{{Digits}}({{ExponentPart}})?{{FloatTypeSuffix}}\"\n  )\n});\ncreateToken({ name: \"OctalLiteral\", pattern: /0_*[0-7]([0-7_]*[0-7])?[lL]?/ });\ncreateToken({\n  name: \"HexFloatLiteral\",\n  pattern: MAKE_PATTERN(\n    \"0[xX]({{HexDigits}}\\\\.?|({{HexDigits}})?\\\\.{{HexDigits}})[pP][+-]?{{Digits}}[fFdD]?\"\n  )\n});\ncreateToken({\n  name: \"HexLiteral\",\n  pattern: /0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?[lL]?/\n});\ncreateToken({\n  name: \"DecimalLiteral\",\n  pattern: MAKE_PATTERN(\"(0|[1-9](_+{{Digits}}|({{Digits}})?))[lL]?\")\n});\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.4\ncreateToken({\n  name: \"CharLiteral\",\n  // Not using SingleCharacter Terminology because ' and \\ are captured in EscapeSequence\n  pattern: MAKE_PATTERN(\n    \"'(?:[^\\\\\\\\']|(?:(?:{{EscapeSequence}})|{{UnicodeInputCharacter}}))'\"\n  )\n});\ncreateToken({\n  name: \"StringLiteral\",\n  pattern: MAKE_PATTERN('\"(?:[^\\\\\\\\\"]|{{StringCharacter}})*\"')\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.9\n// TODO: how to handle the special rule (see spec above) for \"requires\" and \"transitive\"\nconst restrictedKeywords = [\n  \"open\",\n  \"module\",\n  \"requires\",\n  \"transitive\",\n  \"exports\",\n  \"opens\",\n  \"to\",\n  \"uses\",\n  \"provides\",\n  \"with\"\n];\n\n// By sorting the keywords in descending order we avoid ambiguities\n// of common prefixes.\nsortDescLength(restrictedKeywords).forEach(word => {\n  createKeywordLikeToken({\n    name: word[0].toUpperCase() + word.substr(1),\n    pattern: word,\n    // restricted keywords can also be used as an Identifiers according to the spec.\n    // TODO: inspect this causes no ambiguities\n    categories: [Identifier, RestrictedKeyword]\n  });\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.9\nconst keywords = [\n  \"abstract\",\n  \"continue\",\n  \"for\",\n  \"new\",\n  \"switch\",\n  \"assert\",\n  \"default\",\n  \"if\",\n  \"package\",\n  \"synchronized\",\n  \"boolean\",\n  \"do\",\n  \"goto\",\n  \"private\",\n  \"this\",\n  \"break\",\n  \"double\",\n  \"implements\",\n  \"protected\",\n  \"throw\",\n  \"byte\",\n  \"else\",\n  \"import\",\n  \"public\",\n  \"throws\",\n  \"case\",\n  \"enum\",\n  // \"instanceof\", // special handling for \"instanceof\" operator below\n  \"return\",\n  \"transient\",\n  \"catch\",\n  \"extends\",\n  \"int\",\n  \"short\",\n  \"try\",\n  \"char\",\n  \"final\",\n  \"interface\",\n  \"static\",\n  \"void\",\n  \"class\",\n  \"finally\",\n  \"long\",\n  \"strictfp\",\n  \"volatile\",\n  \"const\",\n  \"float\",\n  \"native\",\n  \"super\",\n  \"while\",\n  [\"_\", \"underscore\"]\n];\n\nsortDescLength(keywords).forEach(word => {\n  // For handling symbols keywords (underscore)\n  const isPair = Array.isArray(word);\n  const actualName = isPair ? word[1] : word;\n  const actualPattern = isPair ? word[0] : word;\n\n  const options = {\n    name: actualName[0].toUpperCase() + actualName.substr(1),\n    pattern: actualPattern,\n    categories: Keyword\n  };\n\n  if (isPair) {\n    options.label = `'${actualName}'`;\n  }\n  createKeywordLikeToken(options);\n});\n\ncreateKeywordLikeToken({\n  name: \"Instanceof\",\n  pattern: \"instanceof\",\n  categories: [Keyword, BinaryOperator]\n});\n\ncreateKeywordLikeToken({\n  name: \"Var\",\n  pattern: \"var\",\n  // https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-Keyword\n  // \"var is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({ name: \"True\", pattern: \"true\" });\ncreateKeywordLikeToken({ name: \"False\", pattern: \"false\" });\ncreateKeywordLikeToken({ name: \"Null\", pattern: \"null\" });\n\n// punctuation and symbols\ncreateToken({ name: \"At\", pattern: \"@\", categories: [Separators] });\ncreateToken({ name: \"Arrow\", pattern: \"->\" });\ncreateToken({ name: \"DotDotDot\", pattern: \"...\", categories: [Separators] });\ncreateToken({ name: \"Dot\", pattern: \".\", categories: [Separators] });\ncreateToken({ name: \"Comma\", pattern: \",\", categories: [Separators] });\ncreateToken({ name: \"Semicolon\", pattern: \";\", categories: [Separators] });\ncreateToken({ name: \"ColonColon\", pattern: \"::\", categories: [Separators] });\ncreateToken({ name: \"Colon\", pattern: \":\" });\ncreateToken({ name: \"QuestionMark\", pattern: \"?\" });\ncreateToken({ name: \"LBrace\", pattern: \"(\", categories: [Separators] });\ncreateToken({ name: \"RBrace\", pattern: \")\", categories: [Separators] });\ncreateToken({ name: \"LCurly\", pattern: \"{\", categories: [Separators] });\ncreateToken({ name: \"RCurly\", pattern: \"}\", categories: [Separators] });\ncreateToken({ name: \"LSquare\", pattern: \"[\", categories: [Separators] });\ncreateToken({ name: \"RSquare\", pattern: \"]\", categories: [Separators] });\n\n// prefix and suffix operators\n// must be defined before \"-\"\ncreateToken({\n  name: \"MinusMinus\",\n  pattern: \"--\",\n  categories: [\n    UnaryPrefixOperator,\n    UnarySuffixOperator,\n    UnaryPrefixOperatorNotPlusMinus\n  ]\n});\n// must be defined before \"+\"\ncreateToken({\n  name: \"PlusPlus\",\n  pattern: \"++\",\n  categories: [\n    UnaryPrefixOperator,\n    UnarySuffixOperator,\n    UnaryPrefixOperatorNotPlusMinus\n  ]\n});\ncreateToken({\n  name: \"Complement\",\n  pattern: \"~\",\n  categories: [UnaryPrefixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\n\ncreateToken({\n  name: \"LessEquals\",\n  pattern: \"<=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"LessLessEquals\",\n  pattern: \"<<=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Less\", pattern: \"<\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"GreaterEquals\",\n  pattern: \">=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"GreaterGreaterEquals\",\n  pattern: \">>=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"GreaterGreaterGreaterEquals\",\n  pattern: \">>>=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Greater\", pattern: \">\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"EqualsEquals\",\n  pattern: \"==\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"Equals\",\n  pattern: \"=\",\n  categories: [BinaryOperator, AssignmentOperator]\n});\ncreateToken({\n  name: \"MinusEquals\",\n  pattern: \"-=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Minus\",\n  pattern: \"-\",\n  categories: [BinaryOperator, UnaryPrefixOperator]\n});\ncreateToken({\n  name: \"PlusEquals\",\n  pattern: \"+=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Plus\",\n  pattern: \"+\",\n  categories: [BinaryOperator, UnaryPrefixOperator]\n});\ncreateToken({ name: \"AndAnd\", pattern: \"&&\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"AndEquals\",\n  pattern: \"&=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"And\", pattern: \"&\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"XorEquals\",\n  pattern: \"^=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Xor\", pattern: \"^\", categories: [BinaryOperator] });\ncreateToken({ name: \"NotEquals\", pattern: \"!=\", categories: [BinaryOperator] });\ncreateToken({ name: \"OrOr\", pattern: \"||\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"OrEquals\",\n  pattern: \"|=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Or\", pattern: \"|\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"MultiplyEquals\",\n  pattern: \"*=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Star\", pattern: \"*\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"DivideEquals\",\n  pattern: \"/=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Divide\", pattern: \"/\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"ModuloEquals\",\n  pattern: \"%=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Modulo\", pattern: \"%\", categories: [BinaryOperator] });\n\n// must be defined after \"!=\"\ncreateToken({\n  name: \"Not\",\n  pattern: \"!\",\n  categories: [UnaryPrefixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\n\n// Identifier must appear AFTER all the keywords to avoid ambiguities.\n// See: https://github.com/SAP/chevrotain/blob/master/examples/lexer/keywords_vs_identifiers/keywords_vs_identifiers.js\nallTokens.push(Identifier);\ntokenDictionary[\"Identifier\"] = Identifier;\n\nfunction sortDescLength(arr) {\n  // sort is not stable, but that will not affect the lexing results.\n  return arr.sort((a, b) => {\n    return b.length - a.length;\n  });\n}\nmodule.exports = {\n  allTokens,\n  tokens: tokenDictionary\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3Rva2Vucy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qYXZhLXBhcnNlci9zcmMvdG9rZW5zLmpzPzE3OGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IGNyZWF0ZVRva2VuOiBjcmVhdGVUb2tlbk9yZywgTGV4ZXIgfSA9IHJlcXVpcmUoXCJjaGV2cm90YWluXCIpO1xubGV0IGNoYXJzO1xuLy8gQSBsaXR0bGUgbWluaSBEU0wgZm9yIGVhc2llciBsZXhlciBkZWZpbml0aW9uLlxuY29uc3QgZnJhZ21lbnRzID0ge307XG50cnkge1xuICBjaGFycyA9IHJlcXVpcmUoXCIuL3VuaWNvZGVzZXRzXCIpO1xufSBjYXRjaCAoZSkge1xuICB0aHJvdyBFcnJvcihcbiAgICBcInVuaWNvZGVzZXRzLmpzIGZpbGUgY291bGQgbm90IGJlIGZvdW5kLiBEaWQgeW91IHRyeSB0byBydW4gdGhlIGNvbW1hbmQ6IHlhcm4gcnVuIGJ1aWxkID9cIlxuICApO1xufVxuXG5mdW5jdGlvbiBpbmxpbmVGcmFnbWVudHMoZGVmKSB7XG4gIGxldCBpbmxpbmVkRGVmID0gZGVmO1xuICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2gocHJldkZyYWdtZW50TmFtZSA9PiB7XG4gICAgY29uc3QgcHJldkZyYWdtZW50RGVmID0gZnJhZ21lbnRzW3ByZXZGcmFnbWVudE5hbWVdO1xuICAgIGNvbnN0IHRlbXBsYXRlUmVnRXhwID0gbmV3IFJlZ0V4cChge3ske3ByZXZGcmFnbWVudE5hbWV9fX1gLCBcImdcIik7XG4gICAgaW5saW5lZERlZiA9IGlubGluZWREZWYucmVwbGFjZSh0ZW1wbGF0ZVJlZ0V4cCwgcHJldkZyYWdtZW50RGVmKTtcbiAgfSk7XG4gIHJldHVybiBpbmxpbmVkRGVmO1xufVxuXG5mdW5jdGlvbiBGUkFHTUVOVChuYW1lLCBkZWYpIHtcbiAgZnJhZ21lbnRzW25hbWVdID0gaW5saW5lRnJhZ21lbnRzKGRlZik7XG59XG5cbmZ1bmN0aW9uIE1BS0VfUEFUVEVSTihkZWYsIGZsYWdzKSB7XG4gIGNvbnN0IGlubGluZWREZWYgPSBpbmxpbmVGcmFnbWVudHMoZGVmKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoaW5saW5lZERlZiwgZmxhZ3MpO1xufVxuXG4vLyBUaGUgb3JkZXIgb2YgZnJhZ21lbnRzIGRlZmluaXRpb25zIGlzIGltcG9ydGFudFxuRlJBR01FTlQoXCJEaWdpdHNcIiwgXCJbMC05XShbMC05X10qWzAtOV0pP1wiKTtcbkZSQUdNRU5UKFwiRXhwb25lbnRQYXJ0XCIsIFwiW2VFXVsrLV0/e3tEaWdpdHN9fVwiKTtcbkZSQUdNRU5UKFwiSGV4RGlnaXRcIiwgXCJbMC05YS1mQS1GXVwiKTtcbkZSQUdNRU5UKFwiSGV4RGlnaXRzXCIsIFwie3tIZXhEaWdpdH19KCh7e0hleERpZ2l0fX18J18nKSp7e0hleERpZ2l0fX0pP1wiKTtcbkZSQUdNRU5UKFwiRmxvYXRUeXBlU3VmZml4XCIsIFwiW2ZGZERdXCIpO1xuRlJBR01FTlQoXCJMaW5lVGVybWluYXRvclwiLCBcIihcXFxceDBBfChcXFxceDBEKFxcXFx4MEEpPykpXCIpO1xuRlJBR01FTlQoXCJVbmljb2RlTWFya2VyXCIsIFwidXUqXCIpO1xuRlJBR01FTlQoXCJVbmljb2RlRXNjYXBlXCIsIFwiXFxcXFxcXFx7e1VuaWNvZGVNYXJrZXJ9fXt7SGV4RGlnaXR9fXs0fVwiKTtcbkZSQUdNRU5UKFwiUmF3SW5wdXRDaGFyYWN0ZXJcIiwgXCJcXFxcXFxcXHt7VW5pY29kZU1hcmtlcn19WzAtOWEtZkEtRl17NH1cIik7XG5GUkFHTUVOVChcIlVuaWNvZGVJbnB1dENoYXJhY3RlclwiLCBcIih7e1VuaWNvZGVFc2NhcGV9fXx7e1Jhd0lucHV0Q2hhcmFjdGVyfX0pXCIpO1xuRlJBR01FTlQoXCJPY3RhbERpZ2l0XCIsIFwiWzAtN11cIik7XG5GUkFHTUVOVChcIlplcm9Ub1RocmVlXCIsIFwiWzAtM11cIik7XG5GUkFHTUVOVChcbiAgXCJPY3RhbEVzY2FwZVwiLFxuICBcIlxcXFxcXFxcKHt7T2N0YWxEaWdpdH19fHt7WmVyb1RvVGhyZWV9fT97e09jdGFsRGlnaXR9fXsyfSlcIlxuKTtcbkZSQUdNRU5UKFwiRXNjYXBlU2VxdWVuY2VcIiwgXCJcXFxcXFxcXFtidG5mclxcXCInXFxcXFxcXFxdfHt7T2N0YWxFc2NhcGV9fVwiKTtcbi8vIE5vdCB1c2luZyBJbnB1dENoYXJhY3RlciB0ZXJtaW5vbG9neSB0aGVyZSBiZWNhdXNlIENSIGFuZCBMRiBhcmUgYWxyZWFkeSBjYXB0dXJlZCBpbiBFc2NhcGVTZXF1ZW5jZVxuRlJBR01FTlQoXG4gIFwiU3RyaW5nQ2hhcmFjdGVyXCIsXG4gIFwiKD86KD86e3tFc2NhcGVTZXF1ZW5jZX19KXx7e1VuaWNvZGVJbnB1dENoYXJhY3Rlcn19KVwiXG4pO1xuXG5mdW5jdGlvbiBtYXRjaEphdmFJZGVudGlmaWVyKHRleHQsIHN0YXJ0T2Zmc2V0KSB7XG4gIGxldCBlbmRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgbGV0IGNoYXJDb2RlID0gdGV4dC5jb2RlUG9pbnRBdChlbmRPZmZzZXQpO1xuXG4gIC8vIFdlIHZlcmlmaXkgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBmcm9tIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzXG4gIC8vIENvcnJlc3BvbmRzIHRvIHRoZSBpc0phdmFJZGVudGlmaWVyU3RhcnQgZnVuY3Rpb24gZnJvbSBKYXZhXG4gIGlmIChjaGFycy5maXJzdElkZW50Q2hhci5oYXMoY2hhckNvZGUpKSB7XG4gICAgZW5kT2Zmc2V0Kys7XG4gICAgLy8gSWYgd2UgZW5jb3VudGVyIGEgc3Vycm9nYXRlIHBhaXIgKHNvbWV0aGluZyB0aGF0IGlzIGJleW9uZCA2NTUzNS9GRkZGKVxuICAgIC8vIFdlIHNraXAgYW5vdGhlciBvZmZzZXQgYmVjYXVzZSBhIHN1cnJvZ2F0ZSBwYWlyIGlzIG9mIGxlbmd0aCAyLlxuICAgIGlmIChjaGFyQ29kZSA+IDY1NTM1KSB7XG4gICAgICBlbmRPZmZzZXQrKztcbiAgICB9XG4gICAgY2hhckNvZGUgPSB0ZXh0LmNvZGVQb2ludEF0KGVuZE9mZnNldCk7XG4gIH1cblxuICAvLyBXZSB2ZXJpZnkgaWYgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGlzIGZyb20gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXNcbiAgLy8gQ29ycmVzcG9uZHMgdG8gdGhlIGlzSmF2YUlkZW50aWZpZXJQYXJ0IGZ1bmN0aW9uIGZyb20gSmF2YVxuICB3aGlsZSAoY2hhcnMucmVzdElkZW50Q2hhci5oYXMoY2hhckNvZGUpKSB7XG4gICAgZW5kT2Zmc2V0Kys7XG4gICAgLy8gU2VlIGFib3ZlLlxuICAgIGlmIChjaGFyQ29kZSA+IDY1NTM1KSB7XG4gICAgICBlbmRPZmZzZXQrKztcbiAgICB9XG4gICAgY2hhckNvZGUgPSB0ZXh0LmNvZGVQb2ludEF0KGVuZE9mZnNldCk7XG4gIH1cblxuICAvLyBObyBtYXRjaCwgbXVzdCByZXR1cm4gbnVsbCB0byBjb25mb3JtIHdpdGggdGhlIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyBzaWduYXR1cmVcbiAgaWYgKGVuZE9mZnNldCA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXRjaGVkU3RyaW5nID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gIC8vIGFjY29yZGluZyB0byB0aGUgUmVnRXhwLnByb3RvdHlwZS5leGVjIEFQSSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgbXVzdCBiZSB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmcuXG4gIHJldHVybiBbbWF0Y2hlZFN0cmluZ107XG59XG5cbmNvbnN0IElkZW50aWZpZXIgPSBjcmVhdGVUb2tlbk9yZyh7XG4gIG5hbWU6IFwiSWRlbnRpZmllclwiLFxuICBwYXR0ZXJuOiB7IGV4ZWM6IG1hdGNoSmF2YUlkZW50aWZpZXIgfSxcbiAgbGluZV9icmVha3M6IGZhbHNlLFxuICBzdGFydF9jaGFyc19oaW50OiBBcnJheS5mcm9tKGNoYXJzLmZpcnN0SWRlbnRDaGFyLCB4ID0+XG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZSh4KVxuICApXG59KTtcblxuY29uc3QgYWxsVG9rZW5zID0gW107XG5jb25zdCB0b2tlbkRpY3Rpb25hcnkgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlVG9rZW4ob3B0aW9ucykge1xuICAvLyBUT0RPIGNyZWF0ZSBhIHRlc3QgdG8gY2hlY2sgYWxsIHRoZSB0b2tlbmJzIGhhdmUgYSBsYWJlbCBkZWZpbmVkXG4gIGlmICghb3B0aW9ucy5sYWJlbCkge1xuICAgIC8vIHNpbXBsZSB0b2tlbiAoZS5nIG9wZXJhdG9yKVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcHRpb25zLmxhYmVsID0gYCcke29wdGlvbnMucGF0dGVybn0nYDtcbiAgICB9XG4gICAgLy8gQ29tcGxleCB0b2tlbiAoZS5nIGxpdGVyYWwpXG4gICAgZWxzZSBpZiAob3B0aW9ucy5wYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBvcHRpb25zLmxhYmVsID0gYCcke29wdGlvbnMubmFtZX0nYDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdUb2tlblR5cGUgPSBjcmVhdGVUb2tlbk9yZyhvcHRpb25zKTtcbiAgYWxsVG9rZW5zLnB1c2gobmV3VG9rZW5UeXBlKTtcbiAgdG9rZW5EaWN0aW9uYXJ5W29wdGlvbnMubmFtZV0gPSBuZXdUb2tlblR5cGU7XG4gIHJldHVybiBuZXdUb2tlblR5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRMaWtlVG9rZW4ob3B0aW9ucykge1xuICAvLyBBIGtleXdvcmQgJ2xpa2UnIHRva2VuIHVzZXMgdGhlIFwibG9uZ2VyX2FsdFwiIGNvbmZpZyBvcHRpb25cbiAgLy8gdG8gcmVzb2x2ZSBhbWJpZ3VpdGllcywgc2VlOiBodHRwOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZmVhdHVyZXMvdG9rZW5fYWx0ZXJuYXRpdmVfbWF0Y2hlcy5odG1sXG4gIG9wdGlvbnMubG9uZ2VyX2FsdCA9IElkZW50aWZpZXI7XG4gIHJldHVybiBjcmVhdGVUb2tlbihvcHRpb25zKTtcbn1cblxuLy8gVG9rZW4gQ2F0ZWdvcmllc1xuLy8gVXNlZCBhIFRva2VuIENhdGVnb3J5IHRvIG1hcmsgYWxsIHJlc3RyaWN0ZWQga2V5d29yZHMuXG4vLyBUaGlzIGNvdWxkIGJlIHVzZWQgaW4gc3ludGF4IGhpZ2hsaWdodHMgaW1wbGVtZW50YXRpb24uXG5jb25zdCBSZXN0cmljdGVkS2V5d29yZCA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJSZXN0cmljdGVkS2V5d29yZFwiLFxuICBwYXR0ZXJuOiBMZXhlci5OQVxufSk7XG5cbi8vIFVzZWQgYSBUb2tlbiBDYXRlZ29yeSB0byBtYXJrIGFsbCBrZXl3b3Jkcy5cbi8vIFRoaXMgY291bGQgYmUgdXNlZCBpbiBzeW50YXggaGlnaGxpZ2h0cyBpbXBsZW1lbnRhdGlvbi5cbmNvbnN0IEtleXdvcmQgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiS2V5d29yZFwiLFxuICBwYXR0ZXJuOiBMZXhlci5OQVxufSk7XG5cbmNvbnN0IEFzc2lnbm1lbnRPcGVyYXRvciA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJBc3NpZ25tZW50T3BlcmF0b3JcIixcbiAgcGF0dGVybjogTGV4ZXIuTkFcbn0pO1xuXG5jb25zdCBCaW5hcnlPcGVyYXRvciA9IGNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJCaW5hcnlPcGVyYXRvclwiLFxuICBwYXR0ZXJuOiBMZXhlci5OQVxufSk7XG5cbmNvbnN0IFVuYXJ5UHJlZml4T3BlcmF0b3IgPSBjcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiVW5hcnlQcmVmaXhPcGVyYXRvclwiLFxuICBwYXR0ZXJuOiBMZXhlci5OQVxufSk7XG5jb25zdCBVbmFyeVByZWZpeE9wZXJhdG9yTm90UGx1c01pbnVzID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlVuYXJ5UHJlZml4T3BlcmF0b3JOb3RQbHVzTWludXNcIixcbiAgcGF0dGVybjogTGV4ZXIuTkFcbn0pO1xuXG5jb25zdCBVbmFyeVN1ZmZpeE9wZXJhdG9yID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlVuYXJ5U3VmZml4T3BlcmF0b3JcIixcbiAgcGF0dGVybjogTGV4ZXIuTkFcbn0pO1xuXG4vLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMy5odG1sI2pscy0zLjExXG5jb25zdCBTZXBhcmF0b3JzID0gY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlNlcGFyYXRvcnNcIixcbiAgcGF0dGVybjogTGV4ZXIuTkFcbn0pO1xuXG4vLyBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2Uvc3BlY3MvamxzL3NlMTEvaHRtbC9qbHMtMy5odG1sI2pscy0zLjZcbi8vIE5vdGUgW1xcXFx4MDlcXFxceDIwXFxcXHgwQ10gaXMgZXF1aXZhbGVudCB0byBbXFxcXHRcXFxceDIwXFxcXGZdIGFuZCB0aGF0IFxcXFx4MjAgcmVwcmVzZW50c1xuLy8gc3BhY2UgY2hhcmFjdGVyXG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiV2hpdGVTcGFjZVwiLFxuICBwYXR0ZXJuOiBNQUtFX1BBVFRFUk4oXCJbXFxcXHgwOVxcXFx4MjBcXFxceDBDXXx7e0xpbmVUZXJtaW5hdG9yfX1cIiksXG4gIGdyb3VwOiBMZXhlci5TS0lQUEVEXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJMaW5lQ29tbWVudFwiLFxuICBwYXR0ZXJuOiAvXFwvXFwvW15cXG5cXHJdKi8sXG4gIGdyb3VwOiBcImNvbW1lbnRzXCJcbn0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlRyYWRpdGlvbmFsQ29tbWVudFwiLFxuICBwYXR0ZXJuOiAvXFwvXFwqKFteKl18XFwqKD8hXFwvKSkqXFwqXFwvLyxcbiAgZ3JvdXA6IFwiY29tbWVudHNcIlxufSk7XG5jcmVhdGVUb2tlbih7IG5hbWU6IFwiQmluYXJ5TGl0ZXJhbFwiLCBwYXR0ZXJuOiAvMFtiQl1bMDFdKFswMV9dKlswMV0pP1tsTF0/LyB9KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJGbG9hdExpdGVyYWxcIixcbiAgcGF0dGVybjogTUFLRV9QQVRURVJOKFxuICAgIFwie3tEaWdpdHN9fVxcXFwuKHt7RGlnaXRzfX0pPyh7e0V4cG9uZW50UGFydH19KT8oe3tGbG9hdFR5cGVTdWZmaXh9fSk/fFwiICtcbiAgICAgIFwiXFxcXC57e0RpZ2l0c319KHt7RXhwb25lbnRQYXJ0fX0pPyh7e0Zsb2F0VHlwZVN1ZmZpeH19KT98XCIgK1xuICAgICAgXCJ7e0RpZ2l0c319e3tFeHBvbmVudFBhcnR9fSh7e0Zsb2F0VHlwZVN1ZmZpeH19KT98XCIgK1xuICAgICAgXCJ7e0RpZ2l0c319KHt7RXhwb25lbnRQYXJ0fX0pP3t7RmxvYXRUeXBlU3VmZml4fX1cIlxuICApXG59KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJPY3RhbExpdGVyYWxcIiwgcGF0dGVybjogLzBfKlswLTddKFswLTdfXSpbMC03XSk/W2xMXT8vIH0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkhleEZsb2F0TGl0ZXJhbFwiLFxuICBwYXR0ZXJuOiBNQUtFX1BBVFRFUk4oXG4gICAgXCIwW3hYXSh7e0hleERpZ2l0c319XFxcXC4/fCh7e0hleERpZ2l0c319KT9cXFxcLnt7SGV4RGlnaXRzfX0pW3BQXVsrLV0/e3tEaWdpdHN9fVtmRmREXT9cIlxuICApXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJIZXhMaXRlcmFsXCIsXG4gIHBhdHRlcm46IC8wW3hYXVswLTlhLWZBLUZdKFswLTlhLWZBLUZfXSpbMC05YS1mQS1GXSk/W2xMXT8vXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJEZWNpbWFsTGl0ZXJhbFwiLFxuICBwYXR0ZXJuOiBNQUtFX1BBVFRFUk4oXCIoMHxbMS05XShfK3t7RGlnaXRzfX18KHt7RGlnaXRzfX0pPykpW2xMXT9cIilcbn0pO1xuLy8gaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTExL2h0bWwvamxzLTMuaHRtbCNqbHMtMy4xMC40XG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiQ2hhckxpdGVyYWxcIixcbiAgLy8gTm90IHVzaW5nIFNpbmdsZUNoYXJhY3RlciBUZXJtaW5vbG9neSBiZWNhdXNlICcgYW5kIFxcIGFyZSBjYXB0dXJlZCBpbiBFc2NhcGVTZXF1ZW5jZVxuICBwYXR0ZXJuOiBNQUtFX1BBVFRFUk4oXG4gICAgXCInKD86W15cXFxcXFxcXCddfCg/Oig/Ont7RXNjYXBlU2VxdWVuY2V9fSl8e3tVbmljb2RlSW5wdXRDaGFyYWN0ZXJ9fSkpJ1wiXG4gIClcbn0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlN0cmluZ0xpdGVyYWxcIixcbiAgcGF0dGVybjogTUFLRV9QQVRURVJOKCdcIig/OlteXFxcXFxcXFxcIl18e3tTdHJpbmdDaGFyYWN0ZXJ9fSkqXCInKVxufSk7XG5cbi8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0zLmh0bWwjamxzLTMuOVxuLy8gVE9ETzogaG93IHRvIGhhbmRsZSB0aGUgc3BlY2lhbCBydWxlIChzZWUgc3BlYyBhYm92ZSkgZm9yIFwicmVxdWlyZXNcIiBhbmQgXCJ0cmFuc2l0aXZlXCJcbmNvbnN0IHJlc3RyaWN0ZWRLZXl3b3JkcyA9IFtcbiAgXCJvcGVuXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwicmVxdWlyZXNcIixcbiAgXCJ0cmFuc2l0aXZlXCIsXG4gIFwiZXhwb3J0c1wiLFxuICBcIm9wZW5zXCIsXG4gIFwidG9cIixcbiAgXCJ1c2VzXCIsXG4gIFwicHJvdmlkZXNcIixcbiAgXCJ3aXRoXCJcbl07XG5cbi8vIEJ5IHNvcnRpbmcgdGhlIGtleXdvcmRzIGluIGRlc2NlbmRpbmcgb3JkZXIgd2UgYXZvaWQgYW1iaWd1aXRpZXNcbi8vIG9mIGNvbW1vbiBwcmVmaXhlcy5cbnNvcnREZXNjTGVuZ3RoKHJlc3RyaWN0ZWRLZXl3b3JkcykuZm9yRWFjaCh3b3JkID0+IHtcbiAgY3JlYXRlS2V5d29yZExpa2VUb2tlbih7XG4gICAgbmFtZTogd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHIoMSksXG4gICAgcGF0dGVybjogd29yZCxcbiAgICAvLyByZXN0cmljdGVkIGtleXdvcmRzIGNhbiBhbHNvIGJlIHVzZWQgYXMgYW4gSWRlbnRpZmllcnMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjLlxuICAgIC8vIFRPRE86IGluc3BlY3QgdGhpcyBjYXVzZXMgbm8gYW1iaWd1aXRpZXNcbiAgICBjYXRlZ29yaWVzOiBbSWRlbnRpZmllciwgUmVzdHJpY3RlZEtleXdvcmRdXG4gIH0pO1xufSk7XG5cbi8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0zLmh0bWwjamxzLTMuOVxuY29uc3Qga2V5d29yZHMgPSBbXG4gIFwiYWJzdHJhY3RcIixcbiAgXCJjb250aW51ZVwiLFxuICBcImZvclwiLFxuICBcIm5ld1wiLFxuICBcInN3aXRjaFwiLFxuICBcImFzc2VydFwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJpZlwiLFxuICBcInBhY2thZ2VcIixcbiAgXCJzeW5jaHJvbml6ZWRcIixcbiAgXCJib29sZWFuXCIsXG4gIFwiZG9cIixcbiAgXCJnb3RvXCIsXG4gIFwicHJpdmF0ZVwiLFxuICBcInRoaXNcIixcbiAgXCJicmVha1wiLFxuICBcImRvdWJsZVwiLFxuICBcImltcGxlbWVudHNcIixcbiAgXCJwcm90ZWN0ZWRcIixcbiAgXCJ0aHJvd1wiLFxuICBcImJ5dGVcIixcbiAgXCJlbHNlXCIsXG4gIFwiaW1wb3J0XCIsXG4gIFwicHVibGljXCIsXG4gIFwidGhyb3dzXCIsXG4gIFwiY2FzZVwiLFxuICBcImVudW1cIixcbiAgLy8gXCJpbnN0YW5jZW9mXCIsIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIFwiaW5zdGFuY2VvZlwiIG9wZXJhdG9yIGJlbG93XG4gIFwicmV0dXJuXCIsXG4gIFwidHJhbnNpZW50XCIsXG4gIFwiY2F0Y2hcIixcbiAgXCJleHRlbmRzXCIsXG4gIFwiaW50XCIsXG4gIFwic2hvcnRcIixcbiAgXCJ0cnlcIixcbiAgXCJjaGFyXCIsXG4gIFwiZmluYWxcIixcbiAgXCJpbnRlcmZhY2VcIixcbiAgXCJzdGF0aWNcIixcbiAgXCJ2b2lkXCIsXG4gIFwiY2xhc3NcIixcbiAgXCJmaW5hbGx5XCIsXG4gIFwibG9uZ1wiLFxuICBcInN0cmljdGZwXCIsXG4gIFwidm9sYXRpbGVcIixcbiAgXCJjb25zdFwiLFxuICBcImZsb2F0XCIsXG4gIFwibmF0aXZlXCIsXG4gIFwic3VwZXJcIixcbiAgXCJ3aGlsZVwiLFxuICBbXCJfXCIsIFwidW5kZXJzY29yZVwiXVxuXTtcblxuc29ydERlc2NMZW5ndGgoa2V5d29yZHMpLmZvckVhY2god29yZCA9PiB7XG4gIC8vIEZvciBoYW5kbGluZyBzeW1ib2xzIGtleXdvcmRzICh1bmRlcnNjb3JlKVxuICBjb25zdCBpc1BhaXIgPSBBcnJheS5pc0FycmF5KHdvcmQpO1xuICBjb25zdCBhY3R1YWxOYW1lID0gaXNQYWlyID8gd29yZFsxXSA6IHdvcmQ7XG4gIGNvbnN0IGFjdHVhbFBhdHRlcm4gPSBpc1BhaXIgPyB3b3JkWzBdIDogd29yZDtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIG5hbWU6IGFjdHVhbE5hbWVbMF0udG9VcHBlckNhc2UoKSArIGFjdHVhbE5hbWUuc3Vic3RyKDEpLFxuICAgIHBhdHRlcm46IGFjdHVhbFBhdHRlcm4sXG4gICAgY2F0ZWdvcmllczogS2V5d29yZFxuICB9O1xuXG4gIGlmIChpc1BhaXIpIHtcbiAgICBvcHRpb25zLmxhYmVsID0gYCcke2FjdHVhbE5hbWV9J2A7XG4gIH1cbiAgY3JlYXRlS2V5d29yZExpa2VUb2tlbihvcHRpb25zKTtcbn0pO1xuXG5jcmVhdGVLZXl3b3JkTGlrZVRva2VuKHtcbiAgbmFtZTogXCJJbnN0YW5jZW9mXCIsXG4gIHBhdHRlcm46IFwiaW5zdGFuY2VvZlwiLFxuICBjYXRlZ29yaWVzOiBbS2V5d29yZCwgQmluYXJ5T3BlcmF0b3JdXG59KTtcblxuY3JlYXRlS2V5d29yZExpa2VUb2tlbih7XG4gIG5hbWU6IFwiVmFyXCIsXG4gIHBhdHRlcm46IFwidmFyXCIsXG4gIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS9zcGVjcy9qbHMvc2UxMS9odG1sL2pscy0zLmh0bWwjamxzLUtleXdvcmRcbiAgLy8gXCJ2YXIgaXMgbm90IGEga2V5d29yZCwgYnV0IHJhdGhlciBhbiBpZGVudGlmaWVyIHdpdGggc3BlY2lhbCBtZWFuaW5nIGFzIHRoZSB0eXBlIG9mIGEgbG9jYWwgdmFyaWFibGUgZGVjbGFyYXRpb25cIlxuICBjYXRlZ29yaWVzOiBJZGVudGlmaWVyXG59KTtcbmNyZWF0ZUtleXdvcmRMaWtlVG9rZW4oeyBuYW1lOiBcIlRydWVcIiwgcGF0dGVybjogXCJ0cnVlXCIgfSk7XG5jcmVhdGVLZXl3b3JkTGlrZVRva2VuKHsgbmFtZTogXCJGYWxzZVwiLCBwYXR0ZXJuOiBcImZhbHNlXCIgfSk7XG5jcmVhdGVLZXl3b3JkTGlrZVRva2VuKHsgbmFtZTogXCJOdWxsXCIsIHBhdHRlcm46IFwibnVsbFwiIH0pO1xuXG4vLyBwdW5jdHVhdGlvbiBhbmQgc3ltYm9sc1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkF0XCIsIHBhdHRlcm46IFwiQFwiLCBjYXRlZ29yaWVzOiBbU2VwYXJhdG9yc10gfSk7XG5jcmVhdGVUb2tlbih7IG5hbWU6IFwiQXJyb3dcIiwgcGF0dGVybjogXCItPlwiIH0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkRvdERvdERvdFwiLCBwYXR0ZXJuOiBcIi4uLlwiLCBjYXRlZ29yaWVzOiBbU2VwYXJhdG9yc10gfSk7XG5jcmVhdGVUb2tlbih7IG5hbWU6IFwiRG90XCIsIHBhdHRlcm46IFwiLlwiLCBjYXRlZ29yaWVzOiBbU2VwYXJhdG9yc10gfSk7XG5jcmVhdGVUb2tlbih7IG5hbWU6IFwiQ29tbWFcIiwgcGF0dGVybjogXCIsXCIsIGNhdGVnb3JpZXM6IFtTZXBhcmF0b3JzXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJTZW1pY29sb25cIiwgcGF0dGVybjogXCI7XCIsIGNhdGVnb3JpZXM6IFtTZXBhcmF0b3JzXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJDb2xvbkNvbG9uXCIsIHBhdHRlcm46IFwiOjpcIiwgY2F0ZWdvcmllczogW1NlcGFyYXRvcnNdIH0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkNvbG9uXCIsIHBhdHRlcm46IFwiOlwiIH0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIlF1ZXN0aW9uTWFya1wiLCBwYXR0ZXJuOiBcIj9cIiB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJMQnJhY2VcIiwgcGF0dGVybjogXCIoXCIsIGNhdGVnb3JpZXM6IFtTZXBhcmF0b3JzXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJSQnJhY2VcIiwgcGF0dGVybjogXCIpXCIsIGNhdGVnb3JpZXM6IFtTZXBhcmF0b3JzXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJMQ3VybHlcIiwgcGF0dGVybjogXCJ7XCIsIGNhdGVnb3JpZXM6IFtTZXBhcmF0b3JzXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJSQ3VybHlcIiwgcGF0dGVybjogXCJ9XCIsIGNhdGVnb3JpZXM6IFtTZXBhcmF0b3JzXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJMU3F1YXJlXCIsIHBhdHRlcm46IFwiW1wiLCBjYXRlZ29yaWVzOiBbU2VwYXJhdG9yc10gfSk7XG5jcmVhdGVUb2tlbih7IG5hbWU6IFwiUlNxdWFyZVwiLCBwYXR0ZXJuOiBcIl1cIiwgY2F0ZWdvcmllczogW1NlcGFyYXRvcnNdIH0pO1xuXG4vLyBwcmVmaXggYW5kIHN1ZmZpeCBvcGVyYXRvcnNcbi8vIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgXCItXCJcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJNaW51c01pbnVzXCIsXG4gIHBhdHRlcm46IFwiLS1cIixcbiAgY2F0ZWdvcmllczogW1xuICAgIFVuYXJ5UHJlZml4T3BlcmF0b3IsXG4gICAgVW5hcnlTdWZmaXhPcGVyYXRvcixcbiAgICBVbmFyeVByZWZpeE9wZXJhdG9yTm90UGx1c01pbnVzXG4gIF1cbn0pO1xuLy8gbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBcIitcIlxuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIlBsdXNQbHVzXCIsXG4gIHBhdHRlcm46IFwiKytcIixcbiAgY2F0ZWdvcmllczogW1xuICAgIFVuYXJ5UHJlZml4T3BlcmF0b3IsXG4gICAgVW5hcnlTdWZmaXhPcGVyYXRvcixcbiAgICBVbmFyeVByZWZpeE9wZXJhdG9yTm90UGx1c01pbnVzXG4gIF1cbn0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkNvbXBsZW1lbnRcIixcbiAgcGF0dGVybjogXCJ+XCIsXG4gIGNhdGVnb3JpZXM6IFtVbmFyeVByZWZpeE9wZXJhdG9yLCBVbmFyeVByZWZpeE9wZXJhdG9yTm90UGx1c01pbnVzXVxufSk7XG5cbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJMZXNzRXF1YWxzXCIsXG4gIHBhdHRlcm46IFwiPD1cIixcbiAgY2F0ZWdvcmllczogW0JpbmFyeU9wZXJhdG9yXVxufSk7XG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiTGVzc0xlc3NFcXVhbHNcIixcbiAgcGF0dGVybjogXCI8PD1cIixcbiAgY2F0ZWdvcmllczogW0Fzc2lnbm1lbnRPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkxlc3NcIiwgcGF0dGVybjogXCI8XCIsIGNhdGVnb3JpZXM6IFtCaW5hcnlPcGVyYXRvcl0gfSk7XG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiR3JlYXRlckVxdWFsc1wiLFxuICBwYXR0ZXJuOiBcIj49XCIsXG4gIGNhdGVnb3JpZXM6IFtCaW5hcnlPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkdyZWF0ZXJHcmVhdGVyRXF1YWxzXCIsXG4gIHBhdHRlcm46IFwiPj49XCIsXG4gIGNhdGVnb3JpZXM6IFtBc3NpZ25tZW50T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJHcmVhdGVyR3JlYXRlckdyZWF0ZXJFcXVhbHNcIixcbiAgcGF0dGVybjogXCI+Pj49XCIsXG4gIGNhdGVnb3JpZXM6IFtBc3NpZ25tZW50T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJHcmVhdGVyXCIsIHBhdHRlcm46IFwiPlwiLCBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3JdIH0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkVxdWFsc0VxdWFsc1wiLFxuICBwYXR0ZXJuOiBcIj09XCIsXG4gIGNhdGVnb3JpZXM6IFtCaW5hcnlPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkVxdWFsc1wiLFxuICBwYXR0ZXJuOiBcIj1cIixcbiAgY2F0ZWdvcmllczogW0JpbmFyeU9wZXJhdG9yLCBBc3NpZ25tZW50T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJNaW51c0VxdWFsc1wiLFxuICBwYXR0ZXJuOiBcIi09XCIsXG4gIGNhdGVnb3JpZXM6IFtBc3NpZ25tZW50T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJNaW51c1wiLFxuICBwYXR0ZXJuOiBcIi1cIixcbiAgY2F0ZWdvcmllczogW0JpbmFyeU9wZXJhdG9yLCBVbmFyeVByZWZpeE9wZXJhdG9yXVxufSk7XG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiUGx1c0VxdWFsc1wiLFxuICBwYXR0ZXJuOiBcIis9XCIsXG4gIGNhdGVnb3JpZXM6IFtBc3NpZ25tZW50T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJQbHVzXCIsXG4gIHBhdHRlcm46IFwiK1wiLFxuICBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3IsIFVuYXJ5UHJlZml4T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJBbmRBbmRcIiwgcGF0dGVybjogXCImJlwiLCBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3JdIH0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIkFuZEVxdWFsc1wiLFxuICBwYXR0ZXJuOiBcIiY9XCIsXG4gIGNhdGVnb3JpZXM6IFtBc3NpZ25tZW50T3BlcmF0b3JdXG59KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJBbmRcIiwgcGF0dGVybjogXCImXCIsIGNhdGVnb3JpZXM6IFtCaW5hcnlPcGVyYXRvcl0gfSk7XG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiWG9yRXF1YWxzXCIsXG4gIHBhdHRlcm46IFwiXj1cIixcbiAgY2F0ZWdvcmllczogW0Fzc2lnbm1lbnRPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIlhvclwiLCBwYXR0ZXJuOiBcIl5cIiwgY2F0ZWdvcmllczogW0JpbmFyeU9wZXJhdG9yXSB9KTtcbmNyZWF0ZVRva2VuKHsgbmFtZTogXCJOb3RFcXVhbHNcIiwgcGF0dGVybjogXCIhPVwiLCBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3JdIH0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIk9yT3JcIiwgcGF0dGVybjogXCJ8fFwiLCBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3JdIH0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIk9yRXF1YWxzXCIsXG4gIHBhdHRlcm46IFwifD1cIixcbiAgY2F0ZWdvcmllczogW0Fzc2lnbm1lbnRPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIk9yXCIsIHBhdHRlcm46IFwifFwiLCBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3JdIH0pO1xuY3JlYXRlVG9rZW4oe1xuICBuYW1lOiBcIk11bHRpcGx5RXF1YWxzXCIsXG4gIHBhdHRlcm46IFwiKj1cIixcbiAgY2F0ZWdvcmllczogW0Fzc2lnbm1lbnRPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIlN0YXJcIiwgcGF0dGVybjogXCIqXCIsIGNhdGVnb3JpZXM6IFtCaW5hcnlPcGVyYXRvcl0gfSk7XG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiRGl2aWRlRXF1YWxzXCIsXG4gIHBhdHRlcm46IFwiLz1cIixcbiAgY2F0ZWdvcmllczogW0Fzc2lnbm1lbnRPcGVyYXRvcl1cbn0pO1xuY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkRpdmlkZVwiLCBwYXR0ZXJuOiBcIi9cIiwgY2F0ZWdvcmllczogW0JpbmFyeU9wZXJhdG9yXSB9KTtcbmNyZWF0ZVRva2VuKHtcbiAgbmFtZTogXCJNb2R1bG9FcXVhbHNcIixcbiAgcGF0dGVybjogXCIlPVwiLFxuICBjYXRlZ29yaWVzOiBbQXNzaWdubWVudE9wZXJhdG9yXVxufSk7XG5jcmVhdGVUb2tlbih7IG5hbWU6IFwiTW9kdWxvXCIsIHBhdHRlcm46IFwiJVwiLCBjYXRlZ29yaWVzOiBbQmluYXJ5T3BlcmF0b3JdIH0pO1xuXG4vLyBtdXN0IGJlIGRlZmluZWQgYWZ0ZXIgXCIhPVwiXG5jcmVhdGVUb2tlbih7XG4gIG5hbWU6IFwiTm90XCIsXG4gIHBhdHRlcm46IFwiIVwiLFxuICBjYXRlZ29yaWVzOiBbVW5hcnlQcmVmaXhPcGVyYXRvciwgVW5hcnlQcmVmaXhPcGVyYXRvck5vdFBsdXNNaW51c11cbn0pO1xuXG4vLyBJZGVudGlmaWVyIG11c3QgYXBwZWFyIEFGVEVSIGFsbCB0aGUga2V5d29yZHMgdG8gYXZvaWQgYW1iaWd1aXRpZXMuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9TQVAvY2hldnJvdGFpbi9ibG9iL21hc3Rlci9leGFtcGxlcy9sZXhlci9rZXl3b3Jkc192c19pZGVudGlmaWVycy9rZXl3b3Jkc192c19pZGVudGlmaWVycy5qc1xuYWxsVG9rZW5zLnB1c2goSWRlbnRpZmllcik7XG50b2tlbkRpY3Rpb25hcnlbXCJJZGVudGlmaWVyXCJdID0gSWRlbnRpZmllcjtcblxuZnVuY3Rpb24gc29ydERlc2NMZW5ndGgoYXJyKSB7XG4gIC8vIHNvcnQgaXMgbm90IHN0YWJsZSwgYnV0IHRoYXQgd2lsbCBub3QgYWZmZWN0IHRoZSBsZXhpbmcgcmVzdWx0cy5cbiAgcmV0dXJuIGFyci5zb3J0KChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFsbFRva2VucyxcbiAgdG9rZW5zOiB0b2tlbkRpY3Rpb25hcnlcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/tokens.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/unicodesets.js":
/*!*****************************************************!*\
  !*** ./node_modules/java-parser/src/unicodesets.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*File generated with ../scripts/unicode.js using ../resources/Unicode/UnicodeData.txt.\n * As Java Identifiers may contains unicodes letters, this file defines two sets of unicode\n * characters, firstIdentChar used to help to determine if a character can be the first letter\n * of a JavaIdentifier and the other one (restIdentChar) to determine if it can be part of a\n * JavaIdentifier other than the first character.\n * Java uses the same file UnicodeData.txt as the unicode.js script to define the unicodes.\n * For more:\n *   https://github.com/jhipster/prettier-java/issues/116\n *   https://github.com/jhipster/prettier-java/pull/155\n */\n\nconst addRanges = (set, rangesArr) => {\n  for (let i = 0; i < rangesArr.length; i++) {\n    const range = rangesArr[i];\n    const start = range[0];\n    const end = range[1];\n    for (let codePoint = start; codePoint <= end; codePoint++) {\n      set.add(codePoint);\n    }\n  }\n};\nconst fic = new Set([\n  181,\n  257,\n  259,\n  261,\n  263,\n  265,\n  267,\n  269,\n  271,\n  273,\n  275,\n  277,\n  279,\n  281,\n  283,\n  285,\n  287,\n  289,\n  291,\n  293,\n  295,\n  297,\n  299,\n  301,\n  303,\n  305,\n  307,\n  309,\n  314,\n  316,\n  318,\n  320,\n  322,\n  324,\n  326,\n  331,\n  333,\n  335,\n  337,\n  339,\n  341,\n  343,\n  345,\n  347,\n  349,\n  351,\n  353,\n  355,\n  357,\n  359,\n  361,\n  363,\n  365,\n  367,\n  369,\n  371,\n  373,\n  375,\n  378,\n  380,\n  387,\n  389,\n  392,\n  402,\n  405,\n  414,\n  417,\n  419,\n  421,\n  424,\n  429,\n  432,\n  436,\n  438,\n  454,\n  457,\n  460,\n  462,\n  464,\n  466,\n  468,\n  470,\n  472,\n  474,\n  479,\n  481,\n  483,\n  485,\n  487,\n  489,\n  491,\n  493,\n  499,\n  501,\n  505,\n  507,\n  509,\n  511,\n  513,\n  515,\n  517,\n  519,\n  521,\n  523,\n  525,\n  527,\n  529,\n  531,\n  533,\n  535,\n  537,\n  539,\n  541,\n  543,\n  545,\n  547,\n  549,\n  551,\n  553,\n  555,\n  557,\n  559,\n  561,\n  572,\n  578,\n  583,\n  585,\n  587,\n  589,\n  881,\n  883,\n  887,\n  912,\n  985,\n  987,\n  989,\n  991,\n  993,\n  995,\n  997,\n  999,\n  1001,\n  1003,\n  1005,\n  1013,\n  1016,\n  1121,\n  1123,\n  1125,\n  1127,\n  1129,\n  1131,\n  1133,\n  1135,\n  1137,\n  1139,\n  1141,\n  1143,\n  1145,\n  1147,\n  1149,\n  1151,\n  1153,\n  1163,\n  1165,\n  1167,\n  1169,\n  1171,\n  1173,\n  1175,\n  1177,\n  1179,\n  1181,\n  1183,\n  1185,\n  1187,\n  1189,\n  1191,\n  1193,\n  1195,\n  1197,\n  1199,\n  1201,\n  1203,\n  1205,\n  1207,\n  1209,\n  1211,\n  1213,\n  1215,\n  1218,\n  1220,\n  1222,\n  1224,\n  1226,\n  1228,\n  1233,\n  1235,\n  1237,\n  1239,\n  1241,\n  1243,\n  1245,\n  1247,\n  1249,\n  1251,\n  1253,\n  1255,\n  1257,\n  1259,\n  1261,\n  1263,\n  1265,\n  1267,\n  1269,\n  1271,\n  1273,\n  1275,\n  1277,\n  1279,\n  1281,\n  1283,\n  1285,\n  1287,\n  1289,\n  1291,\n  1293,\n  1295,\n  1297,\n  1299,\n  1301,\n  1303,\n  1305,\n  1307,\n  1309,\n  1311,\n  1313,\n  1315,\n  1317,\n  1319,\n  1321,\n  1323,\n  1325,\n  1327,\n  7681,\n  7683,\n  7685,\n  7687,\n  7689,\n  7691,\n  7693,\n  7695,\n  7697,\n  7699,\n  7701,\n  7703,\n  7705,\n  7707,\n  7709,\n  7711,\n  7713,\n  7715,\n  7717,\n  7719,\n  7721,\n  7723,\n  7725,\n  7727,\n  7729,\n  7731,\n  7733,\n  7735,\n  7737,\n  7739,\n  7741,\n  7743,\n  7745,\n  7747,\n  7749,\n  7751,\n  7753,\n  7755,\n  7757,\n  7759,\n  7761,\n  7763,\n  7765,\n  7767,\n  7769,\n  7771,\n  7773,\n  7775,\n  7777,\n  7779,\n  7781,\n  7783,\n  7785,\n  7787,\n  7789,\n  7791,\n  7793,\n  7795,\n  7797,\n  7799,\n  7801,\n  7803,\n  7805,\n  7807,\n  7809,\n  7811,\n  7813,\n  7815,\n  7817,\n  7819,\n  7821,\n  7823,\n  7825,\n  7827,\n  7839,\n  7841,\n  7843,\n  7845,\n  7847,\n  7849,\n  7851,\n  7853,\n  7855,\n  7857,\n  7859,\n  7861,\n  7863,\n  7865,\n  7867,\n  7869,\n  7871,\n  7873,\n  7875,\n  7877,\n  7879,\n  7881,\n  7883,\n  7885,\n  7887,\n  7889,\n  7891,\n  7893,\n  7895,\n  7897,\n  7899,\n  7901,\n  7903,\n  7905,\n  7907,\n  7909,\n  7911,\n  7913,\n  7915,\n  7917,\n  7919,\n  7921,\n  7923,\n  7925,\n  7927,\n  7929,\n  7931,\n  7933,\n  8126,\n  8458,\n  8467,\n  8495,\n  8500,\n  8505,\n  8526,\n  8580,\n  11361,\n  11368,\n  11370,\n  11372,\n  11377,\n  11393,\n  11395,\n  11397,\n  11399,\n  11401,\n  11403,\n  11405,\n  11407,\n  11409,\n  11411,\n  11413,\n  11415,\n  11417,\n  11419,\n  11421,\n  11423,\n  11425,\n  11427,\n  11429,\n  11431,\n  11433,\n  11435,\n  11437,\n  11439,\n  11441,\n  11443,\n  11445,\n  11447,\n  11449,\n  11451,\n  11453,\n  11455,\n  11457,\n  11459,\n  11461,\n  11463,\n  11465,\n  11467,\n  11469,\n  11471,\n  11473,\n  11475,\n  11477,\n  11479,\n  11481,\n  11483,\n  11485,\n  11487,\n  11489,\n  11500,\n  11502,\n  11507,\n  11559,\n  11565,\n  42561,\n  42563,\n  42565,\n  42567,\n  42569,\n  42571,\n  42573,\n  42575,\n  42577,\n  42579,\n  42581,\n  42583,\n  42585,\n  42587,\n  42589,\n  42591,\n  42593,\n  42595,\n  42597,\n  42599,\n  42601,\n  42603,\n  42605,\n  42625,\n  42627,\n  42629,\n  42631,\n  42633,\n  42635,\n  42637,\n  42639,\n  42641,\n  42643,\n  42645,\n  42647,\n  42649,\n  42651,\n  42787,\n  42789,\n  42791,\n  42793,\n  42795,\n  42797,\n  42803,\n  42805,\n  42807,\n  42809,\n  42811,\n  42813,\n  42815,\n  42817,\n  42819,\n  42821,\n  42823,\n  42825,\n  42827,\n  42829,\n  42831,\n  42833,\n  42835,\n  42837,\n  42839,\n  42841,\n  42843,\n  42845,\n  42847,\n  42849,\n  42851,\n  42853,\n  42855,\n  42857,\n  42859,\n  42861,\n  42863,\n  42874,\n  42876,\n  42879,\n  42881,\n  42883,\n  42885,\n  42887,\n  42892,\n  42894,\n  42897,\n  42903,\n  42905,\n  42907,\n  42909,\n  42911,\n  42913,\n  42915,\n  42917,\n  42919,\n  42921,\n  42927,\n  42933,\n  42935,\n  42937,\n  42939,\n  42941,\n  42943,\n  42947,\n  43002,\n  119995,\n  120779,\n  748,\n  750,\n  884,\n  890,\n  1369,\n  1600,\n  2042,\n  2074,\n  2084,\n  2088,\n  2417,\n  3654,\n  3782,\n  4348,\n  6103,\n  6211,\n  6823,\n  7544,\n  8305,\n  8319,\n  11631,\n  11823,\n  12293,\n  12347,\n  40981,\n  42508,\n  42623,\n  42864,\n  42888,\n  43471,\n  43494,\n  43632,\n  43741,\n  65392,\n  94179,\n  125259,\n  170,\n  186,\n  443,\n  660,\n  1749,\n  1791,\n  1808,\n  1969,\n  2365,\n  2384,\n  2482,\n  2493,\n  2510,\n  2556,\n  2654,\n  2749,\n  2768,\n  2809,\n  2877,\n  2929,\n  2947,\n  2972,\n  3024,\n  3133,\n  3200,\n  3261,\n  3294,\n  3389,\n  3406,\n  3517,\n  3716,\n  3749,\n  3773,\n  3840,\n  4159,\n  4193,\n  4238,\n  4696,\n  4800,\n  6108,\n  6314,\n  7418,\n  12294,\n  12348,\n  12447,\n  12543,\n  13312,\n  19968,\n  42606,\n  42895,\n  42999,\n  43259,\n  43642,\n  43697,\n  43712,\n  43714,\n  43762,\n  44032,\n  64285,\n  64318,\n  67592,\n  67644,\n  68096,\n  69415,\n  69956,\n  70006,\n  70106,\n  70108,\n  70280,\n  70461,\n  70480,\n  70751,\n  70855,\n  71236,\n  71352,\n  71935,\n  72161,\n  72163,\n  72192,\n  72250,\n  72272,\n  72349,\n  72768,\n  73030,\n  73112,\n  94032,\n  94208,\n  123214,\n  126500,\n  126503,\n  126521,\n  126523,\n  126530,\n  126535,\n  126537,\n  126539,\n  126548,\n  126551,\n  126553,\n  126555,\n  126557,\n  126559,\n  126564,\n  126590,\n  131072,\n  173824,\n  177984,\n  178208,\n  183984,\n  453,\n  456,\n  459,\n  498,\n  8124,\n  8140,\n  8188,\n  256,\n  258,\n  260,\n  262,\n  264,\n  266,\n  268,\n  270,\n  272,\n  274,\n  276,\n  278,\n  280,\n  282,\n  284,\n  286,\n  288,\n  290,\n  292,\n  294,\n  296,\n  298,\n  300,\n  302,\n  304,\n  306,\n  308,\n  310,\n  313,\n  315,\n  317,\n  319,\n  321,\n  323,\n  325,\n  327,\n  330,\n  332,\n  334,\n  336,\n  338,\n  340,\n  342,\n  344,\n  346,\n  348,\n  350,\n  352,\n  354,\n  356,\n  358,\n  360,\n  362,\n  364,\n  366,\n  368,\n  370,\n  372,\n  374,\n  379,\n  381,\n  388,\n  418,\n  420,\n  425,\n  428,\n  437,\n  444,\n  452,\n  455,\n  458,\n  461,\n  463,\n  465,\n  467,\n  469,\n  471,\n  473,\n  475,\n  478,\n  480,\n  482,\n  484,\n  486,\n  488,\n  490,\n  492,\n  494,\n  497,\n  500,\n  506,\n  508,\n  510,\n  512,\n  514,\n  516,\n  518,\n  520,\n  522,\n  524,\n  526,\n  528,\n  530,\n  532,\n  534,\n  536,\n  538,\n  540,\n  542,\n  544,\n  546,\n  548,\n  550,\n  552,\n  554,\n  556,\n  558,\n  560,\n  562,\n  577,\n  584,\n  586,\n  588,\n  590,\n  880,\n  882,\n  886,\n  895,\n  902,\n  908,\n  975,\n  984,\n  986,\n  988,\n  990,\n  992,\n  994,\n  996,\n  998,\n  1000,\n  1002,\n  1004,\n  1006,\n  1012,\n  1015,\n  1120,\n  1122,\n  1124,\n  1126,\n  1128,\n  1130,\n  1132,\n  1134,\n  1136,\n  1138,\n  1140,\n  1142,\n  1144,\n  1146,\n  1148,\n  1150,\n  1152,\n  1162,\n  1164,\n  1166,\n  1168,\n  1170,\n  1172,\n  1174,\n  1176,\n  1178,\n  1180,\n  1182,\n  1184,\n  1186,\n  1188,\n  1190,\n  1192,\n  1194,\n  1196,\n  1198,\n  1200,\n  1202,\n  1204,\n  1206,\n  1208,\n  1210,\n  1212,\n  1214,\n  1219,\n  1221,\n  1223,\n  1225,\n  1227,\n  1229,\n  1232,\n  1234,\n  1236,\n  1238,\n  1240,\n  1242,\n  1244,\n  1246,\n  1248,\n  1250,\n  1252,\n  1254,\n  1256,\n  1258,\n  1260,\n  1262,\n  1264,\n  1266,\n  1268,\n  1270,\n  1272,\n  1274,\n  1276,\n  1278,\n  1280,\n  1282,\n  1284,\n  1286,\n  1288,\n  1290,\n  1292,\n  1294,\n  1296,\n  1298,\n  1300,\n  1302,\n  1304,\n  1306,\n  1308,\n  1310,\n  1312,\n  1314,\n  1316,\n  1318,\n  1320,\n  1322,\n  1324,\n  1326,\n  4295,\n  4301,\n  7680,\n  7682,\n  7684,\n  7686,\n  7688,\n  7690,\n  7692,\n  7694,\n  7696,\n  7698,\n  7700,\n  7702,\n  7704,\n  7706,\n  7708,\n  7710,\n  7712,\n  7714,\n  7716,\n  7718,\n  7720,\n  7722,\n  7724,\n  7726,\n  7728,\n  7730,\n  7732,\n  7734,\n  7736,\n  7738,\n  7740,\n  7742,\n  7744,\n  7746,\n  7748,\n  7750,\n  7752,\n  7754,\n  7756,\n  7758,\n  7760,\n  7762,\n  7764,\n  7766,\n  7768,\n  7770,\n  7772,\n  7774,\n  7776,\n  7778,\n  7780,\n  7782,\n  7784,\n  7786,\n  7788,\n  7790,\n  7792,\n  7794,\n  7796,\n  7798,\n  7800,\n  7802,\n  7804,\n  7806,\n  7808,\n  7810,\n  7812,\n  7814,\n  7816,\n  7818,\n  7820,\n  7822,\n  7824,\n  7826,\n  7828,\n  7838,\n  7840,\n  7842,\n  7844,\n  7846,\n  7848,\n  7850,\n  7852,\n  7854,\n  7856,\n  7858,\n  7860,\n  7862,\n  7864,\n  7866,\n  7868,\n  7870,\n  7872,\n  7874,\n  7876,\n  7878,\n  7880,\n  7882,\n  7884,\n  7886,\n  7888,\n  7890,\n  7892,\n  7894,\n  7896,\n  7898,\n  7900,\n  7902,\n  7904,\n  7906,\n  7908,\n  7910,\n  7912,\n  7914,\n  7916,\n  7918,\n  7920,\n  7922,\n  7924,\n  7926,\n  7928,\n  7930,\n  7932,\n  7934,\n  8025,\n  8027,\n  8029,\n  8031,\n  8450,\n  8455,\n  8469,\n  8484,\n  8486,\n  8488,\n  8517,\n  8579,\n  11360,\n  11367,\n  11369,\n  11371,\n  11378,\n  11381,\n  11394,\n  11396,\n  11398,\n  11400,\n  11402,\n  11404,\n  11406,\n  11408,\n  11410,\n  11412,\n  11414,\n  11416,\n  11418,\n  11420,\n  11422,\n  11424,\n  11426,\n  11428,\n  11430,\n  11432,\n  11434,\n  11436,\n  11438,\n  11440,\n  11442,\n  11444,\n  11446,\n  11448,\n  11450,\n  11452,\n  11454,\n  11456,\n  11458,\n  11460,\n  11462,\n  11464,\n  11466,\n  11468,\n  11470,\n  11472,\n  11474,\n  11476,\n  11478,\n  11480,\n  11482,\n  11484,\n  11486,\n  11488,\n  11490,\n  11499,\n  11501,\n  11506,\n  42560,\n  42562,\n  42564,\n  42566,\n  42568,\n  42570,\n  42572,\n  42574,\n  42576,\n  42578,\n  42580,\n  42582,\n  42584,\n  42586,\n  42588,\n  42590,\n  42592,\n  42594,\n  42596,\n  42598,\n  42600,\n  42602,\n  42604,\n  42624,\n  42626,\n  42628,\n  42630,\n  42632,\n  42634,\n  42636,\n  42638,\n  42640,\n  42642,\n  42644,\n  42646,\n  42648,\n  42650,\n  42786,\n  42788,\n  42790,\n  42792,\n  42794,\n  42796,\n  42798,\n  42802,\n  42804,\n  42806,\n  42808,\n  42810,\n  42812,\n  42814,\n  42816,\n  42818,\n  42820,\n  42822,\n  42824,\n  42826,\n  42828,\n  42830,\n  42832,\n  42834,\n  42836,\n  42838,\n  42840,\n  42842,\n  42844,\n  42846,\n  42848,\n  42850,\n  42852,\n  42854,\n  42856,\n  42858,\n  42860,\n  42862,\n  42873,\n  42875,\n  42880,\n  42882,\n  42884,\n  42886,\n  42891,\n  42893,\n  42896,\n  42898,\n  42902,\n  42904,\n  42906,\n  42908,\n  42910,\n  42912,\n  42914,\n  42916,\n  42918,\n  42920,\n  42934,\n  42936,\n  42938,\n  42940,\n  42942,\n  42946,\n  119964,\n  119970,\n  120134,\n  120778,\n  12295,\n  66369,\n  66378,\n  36,\n  1423,\n  1547,\n  2555,\n  2801,\n  3065,\n  3647,\n  6107,\n  43064,\n  65020,\n  65129,\n  65284,\n  123647,\n  126128,\n  95,\n  8276,\n  65343\n]);\nconst fic_a = [\n  [97, 122],\n  [223, 246],\n  [248, 255],\n  [311, 312],\n  [328, 329],\n  [382, 384],\n  [396, 397],\n  [409, 411],\n  [426, 427],\n  [441, 442],\n  [445, 447],\n  [476, 477],\n  [495, 496],\n  [563, 569],\n  [575, 576],\n  [591, 659],\n  [661, 687],\n  [891, 893],\n  [940, 974],\n  [976, 977],\n  [981, 983],\n  [1007, 1011],\n  [1019, 1020],\n  [1072, 1119],\n  [1230, 1231],\n  [1376, 1416],\n  [4304, 4346],\n  [4349, 4351],\n  [5112, 5117],\n  [7296, 7304],\n  [7424, 7467],\n  [7531, 7543],\n  [7545, 7578],\n  [7829, 7837],\n  [7935, 7943],\n  [7952, 7957],\n  [7968, 7975],\n  [7984, 7991],\n  [8000, 8005],\n  [8016, 8023],\n  [8032, 8039],\n  [8048, 8061],\n  [8064, 8071],\n  [8080, 8087],\n  [8096, 8103],\n  [8112, 8116],\n  [8118, 8119],\n  [8130, 8132],\n  [8134, 8135],\n  [8144, 8147],\n  [8150, 8151],\n  [8160, 8167],\n  [8178, 8180],\n  [8182, 8183],\n  [8462, 8463],\n  [8508, 8509],\n  [8518, 8521],\n  [11312, 11358],\n  [11365, 11366],\n  [11379, 11380],\n  [11382, 11387],\n  [11491, 11492],\n  [11520, 11557],\n  [42799, 42801],\n  [42865, 42872],\n  [42899, 42901],\n  [43824, 43866],\n  [43872, 43879],\n  [43888, 43967],\n  [64256, 64262],\n  [64275, 64279],\n  [65345, 65370],\n  [66600, 66639],\n  [66776, 66811],\n  [68800, 68850],\n  [71872, 71903],\n  [93792, 93823],\n  [119834, 119859],\n  [119886, 119892],\n  [119894, 119911],\n  [119938, 119963],\n  [119990, 119993],\n  [119997, 120003],\n  [120005, 120015],\n  [120042, 120067],\n  [120094, 120119],\n  [120146, 120171],\n  [120198, 120223],\n  [120250, 120275],\n  [120302, 120327],\n  [120354, 120379],\n  [120406, 120431],\n  [120458, 120485],\n  [120514, 120538],\n  [120540, 120545],\n  [120572, 120596],\n  [120598, 120603],\n  [120630, 120654],\n  [120656, 120661],\n  [120688, 120712],\n  [120714, 120719],\n  [120746, 120770],\n  [120772, 120777],\n  [125218, 125251],\n  [688, 705],\n  [710, 721],\n  [736, 740],\n  [1765, 1766],\n  [2036, 2037],\n  [7288, 7293],\n  [7468, 7530],\n  [7579, 7615],\n  [8336, 8348],\n  [11388, 11389],\n  [12337, 12341],\n  [12445, 12446],\n  [12540, 12542],\n  [42232, 42237],\n  [42652, 42653],\n  [42775, 42783],\n  [43000, 43001],\n  [43763, 43764],\n  [43868, 43871],\n  [65438, 65439],\n  [92992, 92995],\n  [94099, 94111],\n  [94176, 94177],\n  [123191, 123197],\n  [13313, 19893],\n  [19969, 40943],\n  [44033, 55203],\n  [94209, 100343],\n  [131073, 173782],\n  [173825, 177972],\n  [177985, 178205],\n  [178209, 183969],\n  [183985, 191456],\n  [448, 451],\n  [1488, 1514],\n  [1519, 1522],\n  [1568, 1599],\n  [1601, 1610],\n  [1646, 1647],\n  [1649, 1747],\n  [1774, 1775],\n  [1786, 1788],\n  [1810, 1839],\n  [1869, 1957],\n  [1994, 2026],\n  [2048, 2069],\n  [2112, 2136],\n  [2144, 2154],\n  [2208, 2228],\n  [2230, 2237],\n  [2308, 2361],\n  [2392, 2401],\n  [2418, 2432],\n  [2437, 2444],\n  [2447, 2448],\n  [2451, 2472],\n  [2474, 2480],\n  [2486, 2489],\n  [2524, 2525],\n  [2527, 2529],\n  [2544, 2545],\n  [2565, 2570],\n  [2575, 2576],\n  [2579, 2600],\n  [2602, 2608],\n  [2610, 2611],\n  [2613, 2614],\n  [2616, 2617],\n  [2649, 2652],\n  [2674, 2676],\n  [2693, 2701],\n  [2703, 2705],\n  [2707, 2728],\n  [2730, 2736],\n  [2738, 2739],\n  [2741, 2745],\n  [2784, 2785],\n  [2821, 2828],\n  [2831, 2832],\n  [2835, 2856],\n  [2858, 2864],\n  [2866, 2867],\n  [2869, 2873],\n  [2908, 2909],\n  [2911, 2913],\n  [2949, 2954],\n  [2958, 2960],\n  [2962, 2965],\n  [2969, 2970],\n  [2974, 2975],\n  [2979, 2980],\n  [2984, 2986],\n  [2990, 3001],\n  [3077, 3084],\n  [3086, 3088],\n  [3090, 3112],\n  [3114, 3129],\n  [3160, 3162],\n  [3168, 3169],\n  [3205, 3212],\n  [3214, 3216],\n  [3218, 3240],\n  [3242, 3251],\n  [3253, 3257],\n  [3296, 3297],\n  [3313, 3314],\n  [3333, 3340],\n  [3342, 3344],\n  [3346, 3386],\n  [3412, 3414],\n  [3423, 3425],\n  [3450, 3455],\n  [3461, 3478],\n  [3482, 3505],\n  [3507, 3515],\n  [3520, 3526],\n  [3585, 3632],\n  [3634, 3635],\n  [3648, 3653],\n  [3713, 3714],\n  [3718, 3722],\n  [3724, 3747],\n  [3751, 3760],\n  [3762, 3763],\n  [3776, 3780],\n  [3804, 3807],\n  [3904, 3911],\n  [3913, 3948],\n  [3976, 3980],\n  [4096, 4138],\n  [4176, 4181],\n  [4186, 4189],\n  [4197, 4198],\n  [4206, 4208],\n  [4213, 4225],\n  [4352, 4680],\n  [4682, 4685],\n  [4688, 4694],\n  [4698, 4701],\n  [4704, 4744],\n  [4746, 4749],\n  [4752, 4784],\n  [4786, 4789],\n  [4792, 4798],\n  [4802, 4805],\n  [4808, 4822],\n  [4824, 4880],\n  [4882, 4885],\n  [4888, 4954],\n  [4992, 5007],\n  [5121, 5740],\n  [5743, 5759],\n  [5761, 5786],\n  [5792, 5866],\n  [5873, 5880],\n  [5888, 5900],\n  [5902, 5905],\n  [5920, 5937],\n  [5952, 5969],\n  [5984, 5996],\n  [5998, 6000],\n  [6016, 6067],\n  [6176, 6210],\n  [6212, 6264],\n  [6272, 6276],\n  [6279, 6312],\n  [6320, 6389],\n  [6400, 6430],\n  [6480, 6509],\n  [6512, 6516],\n  [6528, 6571],\n  [6576, 6601],\n  [6656, 6678],\n  [6688, 6740],\n  [6917, 6963],\n  [6981, 6987],\n  [7043, 7072],\n  [7086, 7087],\n  [7098, 7141],\n  [7168, 7203],\n  [7245, 7247],\n  [7258, 7287],\n  [7401, 7404],\n  [7406, 7411],\n  [7413, 7414],\n  [8501, 8504],\n  [11568, 11623],\n  [11648, 11670],\n  [11680, 11686],\n  [11688, 11694],\n  [11696, 11702],\n  [11704, 11710],\n  [11712, 11718],\n  [11720, 11726],\n  [11728, 11734],\n  [11736, 11742],\n  [12353, 12438],\n  [12449, 12538],\n  [12549, 12591],\n  [12593, 12686],\n  [12704, 12730],\n  [12784, 12799],\n  [40960, 40980],\n  [40982, 42124],\n  [42192, 42231],\n  [42240, 42507],\n  [42512, 42527],\n  [42538, 42539],\n  [42656, 42725],\n  [43003, 43009],\n  [43011, 43013],\n  [43015, 43018],\n  [43020, 43042],\n  [43072, 43123],\n  [43138, 43187],\n  [43250, 43255],\n  [43261, 43262],\n  [43274, 43301],\n  [43312, 43334],\n  [43360, 43388],\n  [43396, 43442],\n  [43488, 43492],\n  [43495, 43503],\n  [43514, 43518],\n  [43520, 43560],\n  [43584, 43586],\n  [43588, 43595],\n  [43616, 43631],\n  [43633, 43638],\n  [43646, 43695],\n  [43701, 43702],\n  [43705, 43709],\n  [43739, 43740],\n  [43744, 43754],\n  [43777, 43782],\n  [43785, 43790],\n  [43793, 43798],\n  [43808, 43814],\n  [43816, 43822],\n  [43968, 44002],\n  [55216, 55238],\n  [55243, 55291],\n  [63744, 64109],\n  [64112, 64217],\n  [64287, 64296],\n  [64298, 64310],\n  [64312, 64316],\n  [64320, 64321],\n  [64323, 64324],\n  [64326, 64433],\n  [64467, 64829],\n  [64848, 64911],\n  [64914, 64967],\n  [65008, 65019],\n  [65136, 65140],\n  [65142, 65276],\n  [65382, 65391],\n  [65393, 65437],\n  [65440, 65470],\n  [65474, 65479],\n  [65482, 65487],\n  [65490, 65495],\n  [65498, 65500],\n  [65536, 65547],\n  [65549, 65574],\n  [65576, 65594],\n  [65596, 65597],\n  [65599, 65613],\n  [65616, 65629],\n  [65664, 65786],\n  [66176, 66204],\n  [66208, 66256],\n  [66304, 66335],\n  [66349, 66368],\n  [66370, 66377],\n  [66384, 66421],\n  [66432, 66461],\n  [66464, 66499],\n  [66504, 66511],\n  [66640, 66717],\n  [66816, 66855],\n  [66864, 66915],\n  [67072, 67382],\n  [67392, 67413],\n  [67424, 67431],\n  [67584, 67589],\n  [67594, 67637],\n  [67639, 67640],\n  [67647, 67669],\n  [67680, 67702],\n  [67712, 67742],\n  [67808, 67826],\n  [67828, 67829],\n  [67840, 67861],\n  [67872, 67897],\n  [67968, 68023],\n  [68030, 68031],\n  [68112, 68115],\n  [68117, 68119],\n  [68121, 68149],\n  [68192, 68220],\n  [68224, 68252],\n  [68288, 68295],\n  [68297, 68324],\n  [68352, 68405],\n  [68416, 68437],\n  [68448, 68466],\n  [68480, 68497],\n  [68608, 68680],\n  [68864, 68899],\n  [69376, 69404],\n  [69424, 69445],\n  [69600, 69622],\n  [69635, 69687],\n  [69763, 69807],\n  [69840, 69864],\n  [69891, 69926],\n  [69968, 70002],\n  [70019, 70066],\n  [70081, 70084],\n  [70144, 70161],\n  [70163, 70187],\n  [70272, 70278],\n  [70282, 70285],\n  [70287, 70301],\n  [70303, 70312],\n  [70320, 70366],\n  [70405, 70412],\n  [70415, 70416],\n  [70419, 70440],\n  [70442, 70448],\n  [70450, 70451],\n  [70453, 70457],\n  [70493, 70497],\n  [70656, 70708],\n  [70727, 70730],\n  [70784, 70831],\n  [70852, 70853],\n  [71040, 71086],\n  [71128, 71131],\n  [71168, 71215],\n  [71296, 71338],\n  [71424, 71450],\n  [71680, 71723],\n  [72096, 72103],\n  [72106, 72144],\n  [72203, 72242],\n  [72284, 72329],\n  [72384, 72440],\n  [72704, 72712],\n  [72714, 72750],\n  [72818, 72847],\n  [72960, 72966],\n  [72968, 72969],\n  [72971, 73008],\n  [73056, 73061],\n  [73063, 73064],\n  [73066, 73097],\n  [73440, 73458],\n  [73728, 74649],\n  [74880, 75075],\n  [77824, 78894],\n  [82944, 83526],\n  [92160, 92728],\n  [92736, 92766],\n  [92880, 92909],\n  [92928, 92975],\n  [93027, 93047],\n  [93053, 93071],\n  [93952, 94026],\n  [100352, 101106],\n  [110592, 110878],\n  [110928, 110930],\n  [110948, 110951],\n  [110960, 111355],\n  [113664, 113770],\n  [113776, 113788],\n  [113792, 113800],\n  [113808, 113817],\n  [123136, 123180],\n  [123584, 123627],\n  [124928, 125124],\n  [126464, 126467],\n  [126469, 126495],\n  [126497, 126498],\n  [126505, 126514],\n  [126516, 126519],\n  [126541, 126543],\n  [126545, 126546],\n  [126561, 126562],\n  [126567, 126570],\n  [126572, 126578],\n  [126580, 126583],\n  [126585, 126588],\n  [126592, 126601],\n  [126603, 126619],\n  [126625, 126627],\n  [126629, 126633],\n  [126635, 126651],\n  [194560, 195101],\n  [8072, 8079],\n  [8088, 8095],\n  [8104, 8111],\n  [65, 90],\n  [192, 214],\n  [216, 222],\n  [376, 377],\n  [385, 386],\n  [390, 391],\n  [393, 395],\n  [398, 401],\n  [403, 404],\n  [406, 408],\n  [412, 413],\n  [415, 416],\n  [422, 423],\n  [430, 431],\n  [433, 435],\n  [439, 440],\n  [502, 504],\n  [570, 571],\n  [573, 574],\n  [579, 582],\n  [904, 906],\n  [910, 911],\n  [913, 929],\n  [931, 939],\n  [978, 980],\n  [1017, 1018],\n  [1021, 1071],\n  [1216, 1217],\n  [1329, 1366],\n  [4256, 4293],\n  [5024, 5109],\n  [7312, 7354],\n  [7357, 7359],\n  [7944, 7951],\n  [7960, 7965],\n  [7976, 7983],\n  [7992, 7999],\n  [8008, 8013],\n  [8040, 8047],\n  [8120, 8123],\n  [8136, 8139],\n  [8152, 8155],\n  [8168, 8172],\n  [8184, 8187],\n  [8459, 8461],\n  [8464, 8466],\n  [8473, 8477],\n  [8490, 8493],\n  [8496, 8499],\n  [8510, 8511],\n  [11264, 11310],\n  [11362, 11364],\n  [11373, 11376],\n  [11390, 11392],\n  [42877, 42878],\n  [42922, 42926],\n  [42928, 42932],\n  [42948, 42950],\n  [65313, 65338],\n  [66560, 66599],\n  [66736, 66771],\n  [68736, 68786],\n  [71840, 71871],\n  [93760, 93791],\n  [119808, 119833],\n  [119860, 119885],\n  [119912, 119937],\n  [119966, 119967],\n  [119973, 119974],\n  [119977, 119980],\n  [119982, 119989],\n  [120016, 120041],\n  [120068, 120069],\n  [120071, 120074],\n  [120077, 120084],\n  [120086, 120092],\n  [120120, 120121],\n  [120123, 120126],\n  [120128, 120132],\n  [120138, 120144],\n  [120172, 120197],\n  [120224, 120249],\n  [120276, 120301],\n  [120328, 120353],\n  [120380, 120405],\n  [120432, 120457],\n  [120488, 120512],\n  [120546, 120570],\n  [120604, 120628],\n  [120662, 120686],\n  [120720, 120744],\n  [125184, 125217],\n  [5870, 5872],\n  [8544, 8578],\n  [8581, 8584],\n  [12321, 12329],\n  [12344, 12346],\n  [42726, 42735],\n  [65856, 65908],\n  [66513, 66517],\n  [74752, 74862],\n  [162, 165],\n  [2046, 2047],\n  [2546, 2547],\n  [8352, 8383],\n  [65504, 65505],\n  [65509, 65510],\n  [73693, 73696],\n  [8255, 8256],\n  [65075, 65076],\n  [65101, 65103]\n];\naddRanges(fic, fic_a);\nconst ricd = new Set([\n  1471,\n  1479,\n  1648,\n  1809,\n  2045,\n  2362,\n  2364,\n  2381,\n  2433,\n  2492,\n  2509,\n  2558,\n  2620,\n  2641,\n  2677,\n  2748,\n  2765,\n  2817,\n  2876,\n  2879,\n  2893,\n  2902,\n  2946,\n  3008,\n  3021,\n  3072,\n  3076,\n  3201,\n  3260,\n  3263,\n  3270,\n  3405,\n  3530,\n  3542,\n  3633,\n  3761,\n  3893,\n  3895,\n  3897,\n  4038,\n  4226,\n  4237,\n  4253,\n  6086,\n  6109,\n  6313,\n  6450,\n  6683,\n  6742,\n  6752,\n  6754,\n  6783,\n  6964,\n  6972,\n  6978,\n  7142,\n  7149,\n  7405,\n  7412,\n  8417,\n  11647,\n  42607,\n  43010,\n  43014,\n  43019,\n  43263,\n  43443,\n  43493,\n  43587,\n  43596,\n  43644,\n  43696,\n  43713,\n  43766,\n  44005,\n  44008,\n  44013,\n  64286,\n  66045,\n  66272,\n  68159,\n  69633,\n  70003,\n  70196,\n  70206,\n  70367,\n  70464,\n  70726,\n  70750,\n  70842,\n  71229,\n  71339,\n  71341,\n  71351,\n  72160,\n  72263,\n  72767,\n  73018,\n  73031,\n  73109,\n  73111,\n  94031,\n  121461,\n  121476,\n  173,\n  1564,\n  1757,\n  1807,\n  2274,\n  6158,\n  65279,\n  69821,\n  69837,\n  917505\n]);\nconst ricd_a = [\n  [768, 879],\n  [1155, 1159],\n  [1425, 1469],\n  [1473, 1474],\n  [1476, 1477],\n  [1552, 1562],\n  [1611, 1631],\n  [1750, 1756],\n  [1759, 1764],\n  [1767, 1768],\n  [1770, 1773],\n  [1840, 1866],\n  [1958, 1968],\n  [2027, 2035],\n  [2070, 2073],\n  [2075, 2083],\n  [2085, 2087],\n  [2089, 2093],\n  [2137, 2139],\n  [2259, 2273],\n  [2275, 2306],\n  [2369, 2376],\n  [2385, 2391],\n  [2402, 2403],\n  [2497, 2500],\n  [2530, 2531],\n  [2561, 2562],\n  [2625, 2626],\n  [2631, 2632],\n  [2635, 2637],\n  [2672, 2673],\n  [2689, 2690],\n  [2753, 2757],\n  [2759, 2760],\n  [2786, 2787],\n  [2810, 2815],\n  [2881, 2884],\n  [2914, 2915],\n  [3134, 3136],\n  [3142, 3144],\n  [3146, 3149],\n  [3157, 3158],\n  [3170, 3171],\n  [3276, 3277],\n  [3298, 3299],\n  [3328, 3329],\n  [3387, 3388],\n  [3393, 3396],\n  [3426, 3427],\n  [3538, 3540],\n  [3636, 3642],\n  [3655, 3662],\n  [3764, 3772],\n  [3784, 3789],\n  [3864, 3865],\n  [3953, 3966],\n  [3968, 3972],\n  [3974, 3975],\n  [3981, 3991],\n  [3993, 4028],\n  [4141, 4144],\n  [4146, 4151],\n  [4153, 4154],\n  [4157, 4158],\n  [4184, 4185],\n  [4190, 4192],\n  [4209, 4212],\n  [4229, 4230],\n  [4957, 4959],\n  [5906, 5908],\n  [5938, 5940],\n  [5970, 5971],\n  [6002, 6003],\n  [6068, 6069],\n  [6071, 6077],\n  [6089, 6099],\n  [6155, 6157],\n  [6277, 6278],\n  [6432, 6434],\n  [6439, 6440],\n  [6457, 6459],\n  [6679, 6680],\n  [6744, 6750],\n  [6757, 6764],\n  [6771, 6780],\n  [6832, 6845],\n  [6912, 6915],\n  [6966, 6970],\n  [7019, 7027],\n  [7040, 7041],\n  [7074, 7077],\n  [7080, 7081],\n  [7083, 7085],\n  [7144, 7145],\n  [7151, 7153],\n  [7212, 7219],\n  [7222, 7223],\n  [7376, 7378],\n  [7380, 7392],\n  [7394, 7400],\n  [7416, 7417],\n  [7616, 7673],\n  [7675, 7679],\n  [8400, 8412],\n  [8421, 8432],\n  [11503, 11505],\n  [11744, 11775],\n  [12330, 12333],\n  [12441, 12442],\n  [42612, 42621],\n  [42654, 42655],\n  [42736, 42737],\n  [43045, 43046],\n  [43204, 43205],\n  [43232, 43249],\n  [43302, 43309],\n  [43335, 43345],\n  [43392, 43394],\n  [43446, 43449],\n  [43452, 43453],\n  [43561, 43566],\n  [43569, 43570],\n  [43573, 43574],\n  [43698, 43700],\n  [43703, 43704],\n  [43710, 43711],\n  [43756, 43757],\n  [65024, 65039],\n  [65056, 65071],\n  [66422, 66426],\n  [68097, 68099],\n  [68101, 68102],\n  [68108, 68111],\n  [68152, 68154],\n  [68325, 68326],\n  [68900, 68903],\n  [69446, 69456],\n  [69688, 69702],\n  [69759, 69761],\n  [69811, 69814],\n  [69817, 69818],\n  [69888, 69890],\n  [69927, 69931],\n  [69933, 69940],\n  [70016, 70017],\n  [70070, 70078],\n  [70089, 70092],\n  [70191, 70193],\n  [70198, 70199],\n  [70371, 70378],\n  [70400, 70401],\n  [70459, 70460],\n  [70502, 70508],\n  [70512, 70516],\n  [70712, 70719],\n  [70722, 70724],\n  [70835, 70840],\n  [70847, 70848],\n  [70850, 70851],\n  [71090, 71093],\n  [71100, 71101],\n  [71103, 71104],\n  [71132, 71133],\n  [71219, 71226],\n  [71231, 71232],\n  [71344, 71349],\n  [71453, 71455],\n  [71458, 71461],\n  [71463, 71467],\n  [71727, 71735],\n  [71737, 71738],\n  [72148, 72151],\n  [72154, 72155],\n  [72193, 72202],\n  [72243, 72248],\n  [72251, 72254],\n  [72273, 72278],\n  [72281, 72283],\n  [72330, 72342],\n  [72344, 72345],\n  [72752, 72758],\n  [72760, 72765],\n  [72850, 72871],\n  [72874, 72880],\n  [72882, 72883],\n  [72885, 72886],\n  [73009, 73014],\n  [73020, 73021],\n  [73023, 73029],\n  [73104, 73105],\n  [73459, 73460],\n  [92912, 92916],\n  [92976, 92982],\n  [94095, 94098],\n  [113821, 113822],\n  [119143, 119145],\n  [119163, 119170],\n  [119173, 119179],\n  [119210, 119213],\n  [119362, 119364],\n  [121344, 121398],\n  [121403, 121452],\n  [121499, 121503],\n  [121505, 121519],\n  [122880, 122886],\n  [122888, 122904],\n  [122907, 122913],\n  [122915, 122916],\n  [122918, 122922],\n  [123184, 123190],\n  [123628, 123631],\n  [125136, 125142],\n  [125252, 125258],\n  [917760, 917999],\n  [1536, 1541],\n  [8203, 8207],\n  [8234, 8238],\n  [8288, 8292],\n  [8294, 8303],\n  [65529, 65531],\n  [78896, 78904],\n  [113824, 113827],\n  [119155, 119162],\n  [917536, 917631]\n];\naddRanges(ricd, ricd_a);\nconst mac_a = [\n  [0, 8],\n  [14, 27],\n  [127, 159],\n  [768, 879],\n  [6832, 6911],\n  [7616, 7679],\n  [8400, 8447],\n  [65056, 65071],\n  [48, 57]\n];\naddRanges(ricd, mac_a);\nconst ric = new Set(\n  (function*() {\n    yield* fic;\n    yield* ricd;\n  })()\n);\nmodule.exports = {\n  firstIdentChar: fic,\n  restIdentChar: ric\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3VuaWNvZGVzZXRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy91bmljb2Rlc2V0cy5qcz81YmFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qRmlsZSBnZW5lcmF0ZWQgd2l0aCAuLi9zY3JpcHRzL3VuaWNvZGUuanMgdXNpbmcgLi4vcmVzb3VyY2VzL1VuaWNvZGUvVW5pY29kZURhdGEudHh0LlxuICogQXMgSmF2YSBJZGVudGlmaWVycyBtYXkgY29udGFpbnMgdW5pY29kZXMgbGV0dGVycywgdGhpcyBmaWxlIGRlZmluZXMgdHdvIHNldHMgb2YgdW5pY29kZVxuICogY2hhcmFjdGVycywgZmlyc3RJZGVudENoYXIgdXNlZCB0byBoZWxwIHRvIGRldGVybWluZSBpZiBhIGNoYXJhY3RlciBjYW4gYmUgdGhlIGZpcnN0IGxldHRlclxuICogb2YgYSBKYXZhSWRlbnRpZmllciBhbmQgdGhlIG90aGVyIG9uZSAocmVzdElkZW50Q2hhcikgdG8gZGV0ZXJtaW5lIGlmIGl0IGNhbiBiZSBwYXJ0IG9mIGFcbiAqIEphdmFJZGVudGlmaWVyIG90aGVyIHRoYW4gdGhlIGZpcnN0IGNoYXJhY3Rlci5cbiAqIEphdmEgdXNlcyB0aGUgc2FtZSBmaWxlIFVuaWNvZGVEYXRhLnR4dCBhcyB0aGUgdW5pY29kZS5qcyBzY3JpcHQgdG8gZGVmaW5lIHRoZSB1bmljb2Rlcy5cbiAqIEZvciBtb3JlOlxuICogICBodHRwczovL2dpdGh1Yi5jb20vamhpcHN0ZXIvcHJldHRpZXItamF2YS9pc3N1ZXMvMTE2XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9qaGlwc3Rlci9wcmV0dGllci1qYXZhL3B1bGwvMTU1XG4gKi9cblwidXNlIHN0cmljdFwiO1xuY29uc3QgYWRkUmFuZ2VzID0gKHNldCwgcmFuZ2VzQXJyKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmFuZ2UgPSByYW5nZXNBcnJbaV07XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZVswXTtcbiAgICBjb25zdCBlbmQgPSByYW5nZVsxXTtcbiAgICBmb3IgKGxldCBjb2RlUG9pbnQgPSBzdGFydDsgY29kZVBvaW50IDw9IGVuZDsgY29kZVBvaW50KyspIHtcbiAgICAgIHNldC5hZGQoY29kZVBvaW50KTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBmaWMgPSBuZXcgU2V0KFtcbiAgMTgxLFxuICAyNTcsXG4gIDI1OSxcbiAgMjYxLFxuICAyNjMsXG4gIDI2NSxcbiAgMjY3LFxuICAyNjksXG4gIDI3MSxcbiAgMjczLFxuICAyNzUsXG4gIDI3NyxcbiAgMjc5LFxuICAyODEsXG4gIDI4MyxcbiAgMjg1LFxuICAyODcsXG4gIDI4OSxcbiAgMjkxLFxuICAyOTMsXG4gIDI5NSxcbiAgMjk3LFxuICAyOTksXG4gIDMwMSxcbiAgMzAzLFxuICAzMDUsXG4gIDMwNyxcbiAgMzA5LFxuICAzMTQsXG4gIDMxNixcbiAgMzE4LFxuICAzMjAsXG4gIDMyMixcbiAgMzI0LFxuICAzMjYsXG4gIDMzMSxcbiAgMzMzLFxuICAzMzUsXG4gIDMzNyxcbiAgMzM5LFxuICAzNDEsXG4gIDM0MyxcbiAgMzQ1LFxuICAzNDcsXG4gIDM0OSxcbiAgMzUxLFxuICAzNTMsXG4gIDM1NSxcbiAgMzU3LFxuICAzNTksXG4gIDM2MSxcbiAgMzYzLFxuICAzNjUsXG4gIDM2NyxcbiAgMzY5LFxuICAzNzEsXG4gIDM3MyxcbiAgMzc1LFxuICAzNzgsXG4gIDM4MCxcbiAgMzg3LFxuICAzODksXG4gIDM5MixcbiAgNDAyLFxuICA0MDUsXG4gIDQxNCxcbiAgNDE3LFxuICA0MTksXG4gIDQyMSxcbiAgNDI0LFxuICA0MjksXG4gIDQzMixcbiAgNDM2LFxuICA0MzgsXG4gIDQ1NCxcbiAgNDU3LFxuICA0NjAsXG4gIDQ2MixcbiAgNDY0LFxuICA0NjYsXG4gIDQ2OCxcbiAgNDcwLFxuICA0NzIsXG4gIDQ3NCxcbiAgNDc5LFxuICA0ODEsXG4gIDQ4MyxcbiAgNDg1LFxuICA0ODcsXG4gIDQ4OSxcbiAgNDkxLFxuICA0OTMsXG4gIDQ5OSxcbiAgNTAxLFxuICA1MDUsXG4gIDUwNyxcbiAgNTA5LFxuICA1MTEsXG4gIDUxMyxcbiAgNTE1LFxuICA1MTcsXG4gIDUxOSxcbiAgNTIxLFxuICA1MjMsXG4gIDUyNSxcbiAgNTI3LFxuICA1MjksXG4gIDUzMSxcbiAgNTMzLFxuICA1MzUsXG4gIDUzNyxcbiAgNTM5LFxuICA1NDEsXG4gIDU0MyxcbiAgNTQ1LFxuICA1NDcsXG4gIDU0OSxcbiAgNTUxLFxuICA1NTMsXG4gIDU1NSxcbiAgNTU3LFxuICA1NTksXG4gIDU2MSxcbiAgNTcyLFxuICA1NzgsXG4gIDU4MyxcbiAgNTg1LFxuICA1ODcsXG4gIDU4OSxcbiAgODgxLFxuICA4ODMsXG4gIDg4NyxcbiAgOTEyLFxuICA5ODUsXG4gIDk4NyxcbiAgOTg5LFxuICA5OTEsXG4gIDk5MyxcbiAgOTk1LFxuICA5OTcsXG4gIDk5OSxcbiAgMTAwMSxcbiAgMTAwMyxcbiAgMTAwNSxcbiAgMTAxMyxcbiAgMTAxNixcbiAgMTEyMSxcbiAgMTEyMyxcbiAgMTEyNSxcbiAgMTEyNyxcbiAgMTEyOSxcbiAgMTEzMSxcbiAgMTEzMyxcbiAgMTEzNSxcbiAgMTEzNyxcbiAgMTEzOSxcbiAgMTE0MSxcbiAgMTE0MyxcbiAgMTE0NSxcbiAgMTE0NyxcbiAgMTE0OSxcbiAgMTE1MSxcbiAgMTE1MyxcbiAgMTE2MyxcbiAgMTE2NSxcbiAgMTE2NyxcbiAgMTE2OSxcbiAgMTE3MSxcbiAgMTE3MyxcbiAgMTE3NSxcbiAgMTE3NyxcbiAgMTE3OSxcbiAgMTE4MSxcbiAgMTE4MyxcbiAgMTE4NSxcbiAgMTE4NyxcbiAgMTE4OSxcbiAgMTE5MSxcbiAgMTE5MyxcbiAgMTE5NSxcbiAgMTE5NyxcbiAgMTE5OSxcbiAgMTIwMSxcbiAgMTIwMyxcbiAgMTIwNSxcbiAgMTIwNyxcbiAgMTIwOSxcbiAgMTIxMSxcbiAgMTIxMyxcbiAgMTIxNSxcbiAgMTIxOCxcbiAgMTIyMCxcbiAgMTIyMixcbiAgMTIyNCxcbiAgMTIyNixcbiAgMTIyOCxcbiAgMTIzMyxcbiAgMTIzNSxcbiAgMTIzNyxcbiAgMTIzOSxcbiAgMTI0MSxcbiAgMTI0MyxcbiAgMTI0NSxcbiAgMTI0NyxcbiAgMTI0OSxcbiAgMTI1MSxcbiAgMTI1MyxcbiAgMTI1NSxcbiAgMTI1NyxcbiAgMTI1OSxcbiAgMTI2MSxcbiAgMTI2MyxcbiAgMTI2NSxcbiAgMTI2NyxcbiAgMTI2OSxcbiAgMTI3MSxcbiAgMTI3MyxcbiAgMTI3NSxcbiAgMTI3NyxcbiAgMTI3OSxcbiAgMTI4MSxcbiAgMTI4MyxcbiAgMTI4NSxcbiAgMTI4NyxcbiAgMTI4OSxcbiAgMTI5MSxcbiAgMTI5MyxcbiAgMTI5NSxcbiAgMTI5NyxcbiAgMTI5OSxcbiAgMTMwMSxcbiAgMTMwMyxcbiAgMTMwNSxcbiAgMTMwNyxcbiAgMTMwOSxcbiAgMTMxMSxcbiAgMTMxMyxcbiAgMTMxNSxcbiAgMTMxNyxcbiAgMTMxOSxcbiAgMTMyMSxcbiAgMTMyMyxcbiAgMTMyNSxcbiAgMTMyNyxcbiAgNzY4MSxcbiAgNzY4MyxcbiAgNzY4NSxcbiAgNzY4NyxcbiAgNzY4OSxcbiAgNzY5MSxcbiAgNzY5MyxcbiAgNzY5NSxcbiAgNzY5NyxcbiAgNzY5OSxcbiAgNzcwMSxcbiAgNzcwMyxcbiAgNzcwNSxcbiAgNzcwNyxcbiAgNzcwOSxcbiAgNzcxMSxcbiAgNzcxMyxcbiAgNzcxNSxcbiAgNzcxNyxcbiAgNzcxOSxcbiAgNzcyMSxcbiAgNzcyMyxcbiAgNzcyNSxcbiAgNzcyNyxcbiAgNzcyOSxcbiAgNzczMSxcbiAgNzczMyxcbiAgNzczNSxcbiAgNzczNyxcbiAgNzczOSxcbiAgNzc0MSxcbiAgNzc0MyxcbiAgNzc0NSxcbiAgNzc0NyxcbiAgNzc0OSxcbiAgNzc1MSxcbiAgNzc1MyxcbiAgNzc1NSxcbiAgNzc1NyxcbiAgNzc1OSxcbiAgNzc2MSxcbiAgNzc2MyxcbiAgNzc2NSxcbiAgNzc2NyxcbiAgNzc2OSxcbiAgNzc3MSxcbiAgNzc3MyxcbiAgNzc3NSxcbiAgNzc3NyxcbiAgNzc3OSxcbiAgNzc4MSxcbiAgNzc4MyxcbiAgNzc4NSxcbiAgNzc4NyxcbiAgNzc4OSxcbiAgNzc5MSxcbiAgNzc5MyxcbiAgNzc5NSxcbiAgNzc5NyxcbiAgNzc5OSxcbiAgNzgwMSxcbiAgNzgwMyxcbiAgNzgwNSxcbiAgNzgwNyxcbiAgNzgwOSxcbiAgNzgxMSxcbiAgNzgxMyxcbiAgNzgxNSxcbiAgNzgxNyxcbiAgNzgxOSxcbiAgNzgyMSxcbiAgNzgyMyxcbiAgNzgyNSxcbiAgNzgyNyxcbiAgNzgzOSxcbiAgNzg0MSxcbiAgNzg0MyxcbiAgNzg0NSxcbiAgNzg0NyxcbiAgNzg0OSxcbiAgNzg1MSxcbiAgNzg1MyxcbiAgNzg1NSxcbiAgNzg1NyxcbiAgNzg1OSxcbiAgNzg2MSxcbiAgNzg2MyxcbiAgNzg2NSxcbiAgNzg2NyxcbiAgNzg2OSxcbiAgNzg3MSxcbiAgNzg3MyxcbiAgNzg3NSxcbiAgNzg3NyxcbiAgNzg3OSxcbiAgNzg4MSxcbiAgNzg4MyxcbiAgNzg4NSxcbiAgNzg4NyxcbiAgNzg4OSxcbiAgNzg5MSxcbiAgNzg5MyxcbiAgNzg5NSxcbiAgNzg5NyxcbiAgNzg5OSxcbiAgNzkwMSxcbiAgNzkwMyxcbiAgNzkwNSxcbiAgNzkwNyxcbiAgNzkwOSxcbiAgNzkxMSxcbiAgNzkxMyxcbiAgNzkxNSxcbiAgNzkxNyxcbiAgNzkxOSxcbiAgNzkyMSxcbiAgNzkyMyxcbiAgNzkyNSxcbiAgNzkyNyxcbiAgNzkyOSxcbiAgNzkzMSxcbiAgNzkzMyxcbiAgODEyNixcbiAgODQ1OCxcbiAgODQ2NyxcbiAgODQ5NSxcbiAgODUwMCxcbiAgODUwNSxcbiAgODUyNixcbiAgODU4MCxcbiAgMTEzNjEsXG4gIDExMzY4LFxuICAxMTM3MCxcbiAgMTEzNzIsXG4gIDExMzc3LFxuICAxMTM5MyxcbiAgMTEzOTUsXG4gIDExMzk3LFxuICAxMTM5OSxcbiAgMTE0MDEsXG4gIDExNDAzLFxuICAxMTQwNSxcbiAgMTE0MDcsXG4gIDExNDA5LFxuICAxMTQxMSxcbiAgMTE0MTMsXG4gIDExNDE1LFxuICAxMTQxNyxcbiAgMTE0MTksXG4gIDExNDIxLFxuICAxMTQyMyxcbiAgMTE0MjUsXG4gIDExNDI3LFxuICAxMTQyOSxcbiAgMTE0MzEsXG4gIDExNDMzLFxuICAxMTQzNSxcbiAgMTE0MzcsXG4gIDExNDM5LFxuICAxMTQ0MSxcbiAgMTE0NDMsXG4gIDExNDQ1LFxuICAxMTQ0NyxcbiAgMTE0NDksXG4gIDExNDUxLFxuICAxMTQ1MyxcbiAgMTE0NTUsXG4gIDExNDU3LFxuICAxMTQ1OSxcbiAgMTE0NjEsXG4gIDExNDYzLFxuICAxMTQ2NSxcbiAgMTE0NjcsXG4gIDExNDY5LFxuICAxMTQ3MSxcbiAgMTE0NzMsXG4gIDExNDc1LFxuICAxMTQ3NyxcbiAgMTE0NzksXG4gIDExNDgxLFxuICAxMTQ4MyxcbiAgMTE0ODUsXG4gIDExNDg3LFxuICAxMTQ4OSxcbiAgMTE1MDAsXG4gIDExNTAyLFxuICAxMTUwNyxcbiAgMTE1NTksXG4gIDExNTY1LFxuICA0MjU2MSxcbiAgNDI1NjMsXG4gIDQyNTY1LFxuICA0MjU2NyxcbiAgNDI1NjksXG4gIDQyNTcxLFxuICA0MjU3MyxcbiAgNDI1NzUsXG4gIDQyNTc3LFxuICA0MjU3OSxcbiAgNDI1ODEsXG4gIDQyNTgzLFxuICA0MjU4NSxcbiAgNDI1ODcsXG4gIDQyNTg5LFxuICA0MjU5MSxcbiAgNDI1OTMsXG4gIDQyNTk1LFxuICA0MjU5NyxcbiAgNDI1OTksXG4gIDQyNjAxLFxuICA0MjYwMyxcbiAgNDI2MDUsXG4gIDQyNjI1LFxuICA0MjYyNyxcbiAgNDI2MjksXG4gIDQyNjMxLFxuICA0MjYzMyxcbiAgNDI2MzUsXG4gIDQyNjM3LFxuICA0MjYzOSxcbiAgNDI2NDEsXG4gIDQyNjQzLFxuICA0MjY0NSxcbiAgNDI2NDcsXG4gIDQyNjQ5LFxuICA0MjY1MSxcbiAgNDI3ODcsXG4gIDQyNzg5LFxuICA0Mjc5MSxcbiAgNDI3OTMsXG4gIDQyNzk1LFxuICA0Mjc5NyxcbiAgNDI4MDMsXG4gIDQyODA1LFxuICA0MjgwNyxcbiAgNDI4MDksXG4gIDQyODExLFxuICA0MjgxMyxcbiAgNDI4MTUsXG4gIDQyODE3LFxuICA0MjgxOSxcbiAgNDI4MjEsXG4gIDQyODIzLFxuICA0MjgyNSxcbiAgNDI4MjcsXG4gIDQyODI5LFxuICA0MjgzMSxcbiAgNDI4MzMsXG4gIDQyODM1LFxuICA0MjgzNyxcbiAgNDI4MzksXG4gIDQyODQxLFxuICA0Mjg0MyxcbiAgNDI4NDUsXG4gIDQyODQ3LFxuICA0Mjg0OSxcbiAgNDI4NTEsXG4gIDQyODUzLFxuICA0Mjg1NSxcbiAgNDI4NTcsXG4gIDQyODU5LFxuICA0Mjg2MSxcbiAgNDI4NjMsXG4gIDQyODc0LFxuICA0Mjg3NixcbiAgNDI4NzksXG4gIDQyODgxLFxuICA0Mjg4MyxcbiAgNDI4ODUsXG4gIDQyODg3LFxuICA0Mjg5MixcbiAgNDI4OTQsXG4gIDQyODk3LFxuICA0MjkwMyxcbiAgNDI5MDUsXG4gIDQyOTA3LFxuICA0MjkwOSxcbiAgNDI5MTEsXG4gIDQyOTEzLFxuICA0MjkxNSxcbiAgNDI5MTcsXG4gIDQyOTE5LFxuICA0MjkyMSxcbiAgNDI5MjcsXG4gIDQyOTMzLFxuICA0MjkzNSxcbiAgNDI5MzcsXG4gIDQyOTM5LFxuICA0Mjk0MSxcbiAgNDI5NDMsXG4gIDQyOTQ3LFxuICA0MzAwMixcbiAgMTE5OTk1LFxuICAxMjA3NzksXG4gIDc0OCxcbiAgNzUwLFxuICA4ODQsXG4gIDg5MCxcbiAgMTM2OSxcbiAgMTYwMCxcbiAgMjA0MixcbiAgMjA3NCxcbiAgMjA4NCxcbiAgMjA4OCxcbiAgMjQxNyxcbiAgMzY1NCxcbiAgMzc4MixcbiAgNDM0OCxcbiAgNjEwMyxcbiAgNjIxMSxcbiAgNjgyMyxcbiAgNzU0NCxcbiAgODMwNSxcbiAgODMxOSxcbiAgMTE2MzEsXG4gIDExODIzLFxuICAxMjI5MyxcbiAgMTIzNDcsXG4gIDQwOTgxLFxuICA0MjUwOCxcbiAgNDI2MjMsXG4gIDQyODY0LFxuICA0Mjg4OCxcbiAgNDM0NzEsXG4gIDQzNDk0LFxuICA0MzYzMixcbiAgNDM3NDEsXG4gIDY1MzkyLFxuICA5NDE3OSxcbiAgMTI1MjU5LFxuICAxNzAsXG4gIDE4NixcbiAgNDQzLFxuICA2NjAsXG4gIDE3NDksXG4gIDE3OTEsXG4gIDE4MDgsXG4gIDE5NjksXG4gIDIzNjUsXG4gIDIzODQsXG4gIDI0ODIsXG4gIDI0OTMsXG4gIDI1MTAsXG4gIDI1NTYsXG4gIDI2NTQsXG4gIDI3NDksXG4gIDI3NjgsXG4gIDI4MDksXG4gIDI4NzcsXG4gIDI5MjksXG4gIDI5NDcsXG4gIDI5NzIsXG4gIDMwMjQsXG4gIDMxMzMsXG4gIDMyMDAsXG4gIDMyNjEsXG4gIDMyOTQsXG4gIDMzODksXG4gIDM0MDYsXG4gIDM1MTcsXG4gIDM3MTYsXG4gIDM3NDksXG4gIDM3NzMsXG4gIDM4NDAsXG4gIDQxNTksXG4gIDQxOTMsXG4gIDQyMzgsXG4gIDQ2OTYsXG4gIDQ4MDAsXG4gIDYxMDgsXG4gIDYzMTQsXG4gIDc0MTgsXG4gIDEyMjk0LFxuICAxMjM0OCxcbiAgMTI0NDcsXG4gIDEyNTQzLFxuICAxMzMxMixcbiAgMTk5NjgsXG4gIDQyNjA2LFxuICA0Mjg5NSxcbiAgNDI5OTksXG4gIDQzMjU5LFxuICA0MzY0MixcbiAgNDM2OTcsXG4gIDQzNzEyLFxuICA0MzcxNCxcbiAgNDM3NjIsXG4gIDQ0MDMyLFxuICA2NDI4NSxcbiAgNjQzMTgsXG4gIDY3NTkyLFxuICA2NzY0NCxcbiAgNjgwOTYsXG4gIDY5NDE1LFxuICA2OTk1NixcbiAgNzAwMDYsXG4gIDcwMTA2LFxuICA3MDEwOCxcbiAgNzAyODAsXG4gIDcwNDYxLFxuICA3MDQ4MCxcbiAgNzA3NTEsXG4gIDcwODU1LFxuICA3MTIzNixcbiAgNzEzNTIsXG4gIDcxOTM1LFxuICA3MjE2MSxcbiAgNzIxNjMsXG4gIDcyMTkyLFxuICA3MjI1MCxcbiAgNzIyNzIsXG4gIDcyMzQ5LFxuICA3Mjc2OCxcbiAgNzMwMzAsXG4gIDczMTEyLFxuICA5NDAzMixcbiAgOTQyMDgsXG4gIDEyMzIxNCxcbiAgMTI2NTAwLFxuICAxMjY1MDMsXG4gIDEyNjUyMSxcbiAgMTI2NTIzLFxuICAxMjY1MzAsXG4gIDEyNjUzNSxcbiAgMTI2NTM3LFxuICAxMjY1MzksXG4gIDEyNjU0OCxcbiAgMTI2NTUxLFxuICAxMjY1NTMsXG4gIDEyNjU1NSxcbiAgMTI2NTU3LFxuICAxMjY1NTksXG4gIDEyNjU2NCxcbiAgMTI2NTkwLFxuICAxMzEwNzIsXG4gIDE3MzgyNCxcbiAgMTc3OTg0LFxuICAxNzgyMDgsXG4gIDE4Mzk4NCxcbiAgNDUzLFxuICA0NTYsXG4gIDQ1OSxcbiAgNDk4LFxuICA4MTI0LFxuICA4MTQwLFxuICA4MTg4LFxuICAyNTYsXG4gIDI1OCxcbiAgMjYwLFxuICAyNjIsXG4gIDI2NCxcbiAgMjY2LFxuICAyNjgsXG4gIDI3MCxcbiAgMjcyLFxuICAyNzQsXG4gIDI3NixcbiAgMjc4LFxuICAyODAsXG4gIDI4MixcbiAgMjg0LFxuICAyODYsXG4gIDI4OCxcbiAgMjkwLFxuICAyOTIsXG4gIDI5NCxcbiAgMjk2LFxuICAyOTgsXG4gIDMwMCxcbiAgMzAyLFxuICAzMDQsXG4gIDMwNixcbiAgMzA4LFxuICAzMTAsXG4gIDMxMyxcbiAgMzE1LFxuICAzMTcsXG4gIDMxOSxcbiAgMzIxLFxuICAzMjMsXG4gIDMyNSxcbiAgMzI3LFxuICAzMzAsXG4gIDMzMixcbiAgMzM0LFxuICAzMzYsXG4gIDMzOCxcbiAgMzQwLFxuICAzNDIsXG4gIDM0NCxcbiAgMzQ2LFxuICAzNDgsXG4gIDM1MCxcbiAgMzUyLFxuICAzNTQsXG4gIDM1NixcbiAgMzU4LFxuICAzNjAsXG4gIDM2MixcbiAgMzY0LFxuICAzNjYsXG4gIDM2OCxcbiAgMzcwLFxuICAzNzIsXG4gIDM3NCxcbiAgMzc5LFxuICAzODEsXG4gIDM4OCxcbiAgNDE4LFxuICA0MjAsXG4gIDQyNSxcbiAgNDI4LFxuICA0MzcsXG4gIDQ0NCxcbiAgNDUyLFxuICA0NTUsXG4gIDQ1OCxcbiAgNDYxLFxuICA0NjMsXG4gIDQ2NSxcbiAgNDY3LFxuICA0NjksXG4gIDQ3MSxcbiAgNDczLFxuICA0NzUsXG4gIDQ3OCxcbiAgNDgwLFxuICA0ODIsXG4gIDQ4NCxcbiAgNDg2LFxuICA0ODgsXG4gIDQ5MCxcbiAgNDkyLFxuICA0OTQsXG4gIDQ5NyxcbiAgNTAwLFxuICA1MDYsXG4gIDUwOCxcbiAgNTEwLFxuICA1MTIsXG4gIDUxNCxcbiAgNTE2LFxuICA1MTgsXG4gIDUyMCxcbiAgNTIyLFxuICA1MjQsXG4gIDUyNixcbiAgNTI4LFxuICA1MzAsXG4gIDUzMixcbiAgNTM0LFxuICA1MzYsXG4gIDUzOCxcbiAgNTQwLFxuICA1NDIsXG4gIDU0NCxcbiAgNTQ2LFxuICA1NDgsXG4gIDU1MCxcbiAgNTUyLFxuICA1NTQsXG4gIDU1NixcbiAgNTU4LFxuICA1NjAsXG4gIDU2MixcbiAgNTc3LFxuICA1ODQsXG4gIDU4NixcbiAgNTg4LFxuICA1OTAsXG4gIDg4MCxcbiAgODgyLFxuICA4ODYsXG4gIDg5NSxcbiAgOTAyLFxuICA5MDgsXG4gIDk3NSxcbiAgOTg0LFxuICA5ODYsXG4gIDk4OCxcbiAgOTkwLFxuICA5OTIsXG4gIDk5NCxcbiAgOTk2LFxuICA5OTgsXG4gIDEwMDAsXG4gIDEwMDIsXG4gIDEwMDQsXG4gIDEwMDYsXG4gIDEwMTIsXG4gIDEwMTUsXG4gIDExMjAsXG4gIDExMjIsXG4gIDExMjQsXG4gIDExMjYsXG4gIDExMjgsXG4gIDExMzAsXG4gIDExMzIsXG4gIDExMzQsXG4gIDExMzYsXG4gIDExMzgsXG4gIDExNDAsXG4gIDExNDIsXG4gIDExNDQsXG4gIDExNDYsXG4gIDExNDgsXG4gIDExNTAsXG4gIDExNTIsXG4gIDExNjIsXG4gIDExNjQsXG4gIDExNjYsXG4gIDExNjgsXG4gIDExNzAsXG4gIDExNzIsXG4gIDExNzQsXG4gIDExNzYsXG4gIDExNzgsXG4gIDExODAsXG4gIDExODIsXG4gIDExODQsXG4gIDExODYsXG4gIDExODgsXG4gIDExOTAsXG4gIDExOTIsXG4gIDExOTQsXG4gIDExOTYsXG4gIDExOTgsXG4gIDEyMDAsXG4gIDEyMDIsXG4gIDEyMDQsXG4gIDEyMDYsXG4gIDEyMDgsXG4gIDEyMTAsXG4gIDEyMTIsXG4gIDEyMTQsXG4gIDEyMTksXG4gIDEyMjEsXG4gIDEyMjMsXG4gIDEyMjUsXG4gIDEyMjcsXG4gIDEyMjksXG4gIDEyMzIsXG4gIDEyMzQsXG4gIDEyMzYsXG4gIDEyMzgsXG4gIDEyNDAsXG4gIDEyNDIsXG4gIDEyNDQsXG4gIDEyNDYsXG4gIDEyNDgsXG4gIDEyNTAsXG4gIDEyNTIsXG4gIDEyNTQsXG4gIDEyNTYsXG4gIDEyNTgsXG4gIDEyNjAsXG4gIDEyNjIsXG4gIDEyNjQsXG4gIDEyNjYsXG4gIDEyNjgsXG4gIDEyNzAsXG4gIDEyNzIsXG4gIDEyNzQsXG4gIDEyNzYsXG4gIDEyNzgsXG4gIDEyODAsXG4gIDEyODIsXG4gIDEyODQsXG4gIDEyODYsXG4gIDEyODgsXG4gIDEyOTAsXG4gIDEyOTIsXG4gIDEyOTQsXG4gIDEyOTYsXG4gIDEyOTgsXG4gIDEzMDAsXG4gIDEzMDIsXG4gIDEzMDQsXG4gIDEzMDYsXG4gIDEzMDgsXG4gIDEzMTAsXG4gIDEzMTIsXG4gIDEzMTQsXG4gIDEzMTYsXG4gIDEzMTgsXG4gIDEzMjAsXG4gIDEzMjIsXG4gIDEzMjQsXG4gIDEzMjYsXG4gIDQyOTUsXG4gIDQzMDEsXG4gIDc2ODAsXG4gIDc2ODIsXG4gIDc2ODQsXG4gIDc2ODYsXG4gIDc2ODgsXG4gIDc2OTAsXG4gIDc2OTIsXG4gIDc2OTQsXG4gIDc2OTYsXG4gIDc2OTgsXG4gIDc3MDAsXG4gIDc3MDIsXG4gIDc3MDQsXG4gIDc3MDYsXG4gIDc3MDgsXG4gIDc3MTAsXG4gIDc3MTIsXG4gIDc3MTQsXG4gIDc3MTYsXG4gIDc3MTgsXG4gIDc3MjAsXG4gIDc3MjIsXG4gIDc3MjQsXG4gIDc3MjYsXG4gIDc3MjgsXG4gIDc3MzAsXG4gIDc3MzIsXG4gIDc3MzQsXG4gIDc3MzYsXG4gIDc3MzgsXG4gIDc3NDAsXG4gIDc3NDIsXG4gIDc3NDQsXG4gIDc3NDYsXG4gIDc3NDgsXG4gIDc3NTAsXG4gIDc3NTIsXG4gIDc3NTQsXG4gIDc3NTYsXG4gIDc3NTgsXG4gIDc3NjAsXG4gIDc3NjIsXG4gIDc3NjQsXG4gIDc3NjYsXG4gIDc3NjgsXG4gIDc3NzAsXG4gIDc3NzIsXG4gIDc3NzQsXG4gIDc3NzYsXG4gIDc3NzgsXG4gIDc3ODAsXG4gIDc3ODIsXG4gIDc3ODQsXG4gIDc3ODYsXG4gIDc3ODgsXG4gIDc3OTAsXG4gIDc3OTIsXG4gIDc3OTQsXG4gIDc3OTYsXG4gIDc3OTgsXG4gIDc4MDAsXG4gIDc4MDIsXG4gIDc4MDQsXG4gIDc4MDYsXG4gIDc4MDgsXG4gIDc4MTAsXG4gIDc4MTIsXG4gIDc4MTQsXG4gIDc4MTYsXG4gIDc4MTgsXG4gIDc4MjAsXG4gIDc4MjIsXG4gIDc4MjQsXG4gIDc4MjYsXG4gIDc4MjgsXG4gIDc4MzgsXG4gIDc4NDAsXG4gIDc4NDIsXG4gIDc4NDQsXG4gIDc4NDYsXG4gIDc4NDgsXG4gIDc4NTAsXG4gIDc4NTIsXG4gIDc4NTQsXG4gIDc4NTYsXG4gIDc4NTgsXG4gIDc4NjAsXG4gIDc4NjIsXG4gIDc4NjQsXG4gIDc4NjYsXG4gIDc4NjgsXG4gIDc4NzAsXG4gIDc4NzIsXG4gIDc4NzQsXG4gIDc4NzYsXG4gIDc4NzgsXG4gIDc4ODAsXG4gIDc4ODIsXG4gIDc4ODQsXG4gIDc4ODYsXG4gIDc4ODgsXG4gIDc4OTAsXG4gIDc4OTIsXG4gIDc4OTQsXG4gIDc4OTYsXG4gIDc4OTgsXG4gIDc5MDAsXG4gIDc5MDIsXG4gIDc5MDQsXG4gIDc5MDYsXG4gIDc5MDgsXG4gIDc5MTAsXG4gIDc5MTIsXG4gIDc5MTQsXG4gIDc5MTYsXG4gIDc5MTgsXG4gIDc5MjAsXG4gIDc5MjIsXG4gIDc5MjQsXG4gIDc5MjYsXG4gIDc5MjgsXG4gIDc5MzAsXG4gIDc5MzIsXG4gIDc5MzQsXG4gIDgwMjUsXG4gIDgwMjcsXG4gIDgwMjksXG4gIDgwMzEsXG4gIDg0NTAsXG4gIDg0NTUsXG4gIDg0NjksXG4gIDg0ODQsXG4gIDg0ODYsXG4gIDg0ODgsXG4gIDg1MTcsXG4gIDg1NzksXG4gIDExMzYwLFxuICAxMTM2NyxcbiAgMTEzNjksXG4gIDExMzcxLFxuICAxMTM3OCxcbiAgMTEzODEsXG4gIDExMzk0LFxuICAxMTM5NixcbiAgMTEzOTgsXG4gIDExNDAwLFxuICAxMTQwMixcbiAgMTE0MDQsXG4gIDExNDA2LFxuICAxMTQwOCxcbiAgMTE0MTAsXG4gIDExNDEyLFxuICAxMTQxNCxcbiAgMTE0MTYsXG4gIDExNDE4LFxuICAxMTQyMCxcbiAgMTE0MjIsXG4gIDExNDI0LFxuICAxMTQyNixcbiAgMTE0MjgsXG4gIDExNDMwLFxuICAxMTQzMixcbiAgMTE0MzQsXG4gIDExNDM2LFxuICAxMTQzOCxcbiAgMTE0NDAsXG4gIDExNDQyLFxuICAxMTQ0NCxcbiAgMTE0NDYsXG4gIDExNDQ4LFxuICAxMTQ1MCxcbiAgMTE0NTIsXG4gIDExNDU0LFxuICAxMTQ1NixcbiAgMTE0NTgsXG4gIDExNDYwLFxuICAxMTQ2MixcbiAgMTE0NjQsXG4gIDExNDY2LFxuICAxMTQ2OCxcbiAgMTE0NzAsXG4gIDExNDcyLFxuICAxMTQ3NCxcbiAgMTE0NzYsXG4gIDExNDc4LFxuICAxMTQ4MCxcbiAgMTE0ODIsXG4gIDExNDg0LFxuICAxMTQ4NixcbiAgMTE0ODgsXG4gIDExNDkwLFxuICAxMTQ5OSxcbiAgMTE1MDEsXG4gIDExNTA2LFxuICA0MjU2MCxcbiAgNDI1NjIsXG4gIDQyNTY0LFxuICA0MjU2NixcbiAgNDI1NjgsXG4gIDQyNTcwLFxuICA0MjU3MixcbiAgNDI1NzQsXG4gIDQyNTc2LFxuICA0MjU3OCxcbiAgNDI1ODAsXG4gIDQyNTgyLFxuICA0MjU4NCxcbiAgNDI1ODYsXG4gIDQyNTg4LFxuICA0MjU5MCxcbiAgNDI1OTIsXG4gIDQyNTk0LFxuICA0MjU5NixcbiAgNDI1OTgsXG4gIDQyNjAwLFxuICA0MjYwMixcbiAgNDI2MDQsXG4gIDQyNjI0LFxuICA0MjYyNixcbiAgNDI2MjgsXG4gIDQyNjMwLFxuICA0MjYzMixcbiAgNDI2MzQsXG4gIDQyNjM2LFxuICA0MjYzOCxcbiAgNDI2NDAsXG4gIDQyNjQyLFxuICA0MjY0NCxcbiAgNDI2NDYsXG4gIDQyNjQ4LFxuICA0MjY1MCxcbiAgNDI3ODYsXG4gIDQyNzg4LFxuICA0Mjc5MCxcbiAgNDI3OTIsXG4gIDQyNzk0LFxuICA0Mjc5NixcbiAgNDI3OTgsXG4gIDQyODAyLFxuICA0MjgwNCxcbiAgNDI4MDYsXG4gIDQyODA4LFxuICA0MjgxMCxcbiAgNDI4MTIsXG4gIDQyODE0LFxuICA0MjgxNixcbiAgNDI4MTgsXG4gIDQyODIwLFxuICA0MjgyMixcbiAgNDI4MjQsXG4gIDQyODI2LFxuICA0MjgyOCxcbiAgNDI4MzAsXG4gIDQyODMyLFxuICA0MjgzNCxcbiAgNDI4MzYsXG4gIDQyODM4LFxuICA0Mjg0MCxcbiAgNDI4NDIsXG4gIDQyODQ0LFxuICA0Mjg0NixcbiAgNDI4NDgsXG4gIDQyODUwLFxuICA0Mjg1MixcbiAgNDI4NTQsXG4gIDQyODU2LFxuICA0Mjg1OCxcbiAgNDI4NjAsXG4gIDQyODYyLFxuICA0Mjg3MyxcbiAgNDI4NzUsXG4gIDQyODgwLFxuICA0Mjg4MixcbiAgNDI4ODQsXG4gIDQyODg2LFxuICA0Mjg5MSxcbiAgNDI4OTMsXG4gIDQyODk2LFxuICA0Mjg5OCxcbiAgNDI5MDIsXG4gIDQyOTA0LFxuICA0MjkwNixcbiAgNDI5MDgsXG4gIDQyOTEwLFxuICA0MjkxMixcbiAgNDI5MTQsXG4gIDQyOTE2LFxuICA0MjkxOCxcbiAgNDI5MjAsXG4gIDQyOTM0LFxuICA0MjkzNixcbiAgNDI5MzgsXG4gIDQyOTQwLFxuICA0Mjk0MixcbiAgNDI5NDYsXG4gIDExOTk2NCxcbiAgMTE5OTcwLFxuICAxMjAxMzQsXG4gIDEyMDc3OCxcbiAgMTIyOTUsXG4gIDY2MzY5LFxuICA2NjM3OCxcbiAgMzYsXG4gIDE0MjMsXG4gIDE1NDcsXG4gIDI1NTUsXG4gIDI4MDEsXG4gIDMwNjUsXG4gIDM2NDcsXG4gIDYxMDcsXG4gIDQzMDY0LFxuICA2NTAyMCxcbiAgNjUxMjksXG4gIDY1Mjg0LFxuICAxMjM2NDcsXG4gIDEyNjEyOCxcbiAgOTUsXG4gIDgyNzYsXG4gIDY1MzQzXG5dKTtcbmNvbnN0IGZpY19hID0gW1xuICBbOTcsIDEyMl0sXG4gIFsyMjMsIDI0Nl0sXG4gIFsyNDgsIDI1NV0sXG4gIFszMTEsIDMxMl0sXG4gIFszMjgsIDMyOV0sXG4gIFszODIsIDM4NF0sXG4gIFszOTYsIDM5N10sXG4gIFs0MDksIDQxMV0sXG4gIFs0MjYsIDQyN10sXG4gIFs0NDEsIDQ0Ml0sXG4gIFs0NDUsIDQ0N10sXG4gIFs0NzYsIDQ3N10sXG4gIFs0OTUsIDQ5Nl0sXG4gIFs1NjMsIDU2OV0sXG4gIFs1NzUsIDU3Nl0sXG4gIFs1OTEsIDY1OV0sXG4gIFs2NjEsIDY4N10sXG4gIFs4OTEsIDg5M10sXG4gIFs5NDAsIDk3NF0sXG4gIFs5NzYsIDk3N10sXG4gIFs5ODEsIDk4M10sXG4gIFsxMDA3LCAxMDExXSxcbiAgWzEwMTksIDEwMjBdLFxuICBbMTA3MiwgMTExOV0sXG4gIFsxMjMwLCAxMjMxXSxcbiAgWzEzNzYsIDE0MTZdLFxuICBbNDMwNCwgNDM0Nl0sXG4gIFs0MzQ5LCA0MzUxXSxcbiAgWzUxMTIsIDUxMTddLFxuICBbNzI5NiwgNzMwNF0sXG4gIFs3NDI0LCA3NDY3XSxcbiAgWzc1MzEsIDc1NDNdLFxuICBbNzU0NSwgNzU3OF0sXG4gIFs3ODI5LCA3ODM3XSxcbiAgWzc5MzUsIDc5NDNdLFxuICBbNzk1MiwgNzk1N10sXG4gIFs3OTY4LCA3OTc1XSxcbiAgWzc5ODQsIDc5OTFdLFxuICBbODAwMCwgODAwNV0sXG4gIFs4MDE2LCA4MDIzXSxcbiAgWzgwMzIsIDgwMzldLFxuICBbODA0OCwgODA2MV0sXG4gIFs4MDY0LCA4MDcxXSxcbiAgWzgwODAsIDgwODddLFxuICBbODA5NiwgODEwM10sXG4gIFs4MTEyLCA4MTE2XSxcbiAgWzgxMTgsIDgxMTldLFxuICBbODEzMCwgODEzMl0sXG4gIFs4MTM0LCA4MTM1XSxcbiAgWzgxNDQsIDgxNDddLFxuICBbODE1MCwgODE1MV0sXG4gIFs4MTYwLCA4MTY3XSxcbiAgWzgxNzgsIDgxODBdLFxuICBbODE4MiwgODE4M10sXG4gIFs4NDYyLCA4NDYzXSxcbiAgWzg1MDgsIDg1MDldLFxuICBbODUxOCwgODUyMV0sXG4gIFsxMTMxMiwgMTEzNThdLFxuICBbMTEzNjUsIDExMzY2XSxcbiAgWzExMzc5LCAxMTM4MF0sXG4gIFsxMTM4MiwgMTEzODddLFxuICBbMTE0OTEsIDExNDkyXSxcbiAgWzExNTIwLCAxMTU1N10sXG4gIFs0Mjc5OSwgNDI4MDFdLFxuICBbNDI4NjUsIDQyODcyXSxcbiAgWzQyODk5LCA0MjkwMV0sXG4gIFs0MzgyNCwgNDM4NjZdLFxuICBbNDM4NzIsIDQzODc5XSxcbiAgWzQzODg4LCA0Mzk2N10sXG4gIFs2NDI1NiwgNjQyNjJdLFxuICBbNjQyNzUsIDY0Mjc5XSxcbiAgWzY1MzQ1LCA2NTM3MF0sXG4gIFs2NjYwMCwgNjY2MzldLFxuICBbNjY3NzYsIDY2ODExXSxcbiAgWzY4ODAwLCA2ODg1MF0sXG4gIFs3MTg3MiwgNzE5MDNdLFxuICBbOTM3OTIsIDkzODIzXSxcbiAgWzExOTgzNCwgMTE5ODU5XSxcbiAgWzExOTg4NiwgMTE5ODkyXSxcbiAgWzExOTg5NCwgMTE5OTExXSxcbiAgWzExOTkzOCwgMTE5OTYzXSxcbiAgWzExOTk5MCwgMTE5OTkzXSxcbiAgWzExOTk5NywgMTIwMDAzXSxcbiAgWzEyMDAwNSwgMTIwMDE1XSxcbiAgWzEyMDA0MiwgMTIwMDY3XSxcbiAgWzEyMDA5NCwgMTIwMTE5XSxcbiAgWzEyMDE0NiwgMTIwMTcxXSxcbiAgWzEyMDE5OCwgMTIwMjIzXSxcbiAgWzEyMDI1MCwgMTIwMjc1XSxcbiAgWzEyMDMwMiwgMTIwMzI3XSxcbiAgWzEyMDM1NCwgMTIwMzc5XSxcbiAgWzEyMDQwNiwgMTIwNDMxXSxcbiAgWzEyMDQ1OCwgMTIwNDg1XSxcbiAgWzEyMDUxNCwgMTIwNTM4XSxcbiAgWzEyMDU0MCwgMTIwNTQ1XSxcbiAgWzEyMDU3MiwgMTIwNTk2XSxcbiAgWzEyMDU5OCwgMTIwNjAzXSxcbiAgWzEyMDYzMCwgMTIwNjU0XSxcbiAgWzEyMDY1NiwgMTIwNjYxXSxcbiAgWzEyMDY4OCwgMTIwNzEyXSxcbiAgWzEyMDcxNCwgMTIwNzE5XSxcbiAgWzEyMDc0NiwgMTIwNzcwXSxcbiAgWzEyMDc3MiwgMTIwNzc3XSxcbiAgWzEyNTIxOCwgMTI1MjUxXSxcbiAgWzY4OCwgNzA1XSxcbiAgWzcxMCwgNzIxXSxcbiAgWzczNiwgNzQwXSxcbiAgWzE3NjUsIDE3NjZdLFxuICBbMjAzNiwgMjAzN10sXG4gIFs3Mjg4LCA3MjkzXSxcbiAgWzc0NjgsIDc1MzBdLFxuICBbNzU3OSwgNzYxNV0sXG4gIFs4MzM2LCA4MzQ4XSxcbiAgWzExMzg4LCAxMTM4OV0sXG4gIFsxMjMzNywgMTIzNDFdLFxuICBbMTI0NDUsIDEyNDQ2XSxcbiAgWzEyNTQwLCAxMjU0Ml0sXG4gIFs0MjIzMiwgNDIyMzddLFxuICBbNDI2NTIsIDQyNjUzXSxcbiAgWzQyNzc1LCA0Mjc4M10sXG4gIFs0MzAwMCwgNDMwMDFdLFxuICBbNDM3NjMsIDQzNzY0XSxcbiAgWzQzODY4LCA0Mzg3MV0sXG4gIFs2NTQzOCwgNjU0MzldLFxuICBbOTI5OTIsIDkyOTk1XSxcbiAgWzk0MDk5LCA5NDExMV0sXG4gIFs5NDE3NiwgOTQxNzddLFxuICBbMTIzMTkxLCAxMjMxOTddLFxuICBbMTMzMTMsIDE5ODkzXSxcbiAgWzE5OTY5LCA0MDk0M10sXG4gIFs0NDAzMywgNTUyMDNdLFxuICBbOTQyMDksIDEwMDM0M10sXG4gIFsxMzEwNzMsIDE3Mzc4Ml0sXG4gIFsxNzM4MjUsIDE3Nzk3Ml0sXG4gIFsxNzc5ODUsIDE3ODIwNV0sXG4gIFsxNzgyMDksIDE4Mzk2OV0sXG4gIFsxODM5ODUsIDE5MTQ1Nl0sXG4gIFs0NDgsIDQ1MV0sXG4gIFsxNDg4LCAxNTE0XSxcbiAgWzE1MTksIDE1MjJdLFxuICBbMTU2OCwgMTU5OV0sXG4gIFsxNjAxLCAxNjEwXSxcbiAgWzE2NDYsIDE2NDddLFxuICBbMTY0OSwgMTc0N10sXG4gIFsxNzc0LCAxNzc1XSxcbiAgWzE3ODYsIDE3ODhdLFxuICBbMTgxMCwgMTgzOV0sXG4gIFsxODY5LCAxOTU3XSxcbiAgWzE5OTQsIDIwMjZdLFxuICBbMjA0OCwgMjA2OV0sXG4gIFsyMTEyLCAyMTM2XSxcbiAgWzIxNDQsIDIxNTRdLFxuICBbMjIwOCwgMjIyOF0sXG4gIFsyMjMwLCAyMjM3XSxcbiAgWzIzMDgsIDIzNjFdLFxuICBbMjM5MiwgMjQwMV0sXG4gIFsyNDE4LCAyNDMyXSxcbiAgWzI0MzcsIDI0NDRdLFxuICBbMjQ0NywgMjQ0OF0sXG4gIFsyNDUxLCAyNDcyXSxcbiAgWzI0NzQsIDI0ODBdLFxuICBbMjQ4NiwgMjQ4OV0sXG4gIFsyNTI0LCAyNTI1XSxcbiAgWzI1MjcsIDI1MjldLFxuICBbMjU0NCwgMjU0NV0sXG4gIFsyNTY1LCAyNTcwXSxcbiAgWzI1NzUsIDI1NzZdLFxuICBbMjU3OSwgMjYwMF0sXG4gIFsyNjAyLCAyNjA4XSxcbiAgWzI2MTAsIDI2MTFdLFxuICBbMjYxMywgMjYxNF0sXG4gIFsyNjE2LCAyNjE3XSxcbiAgWzI2NDksIDI2NTJdLFxuICBbMjY3NCwgMjY3Nl0sXG4gIFsyNjkzLCAyNzAxXSxcbiAgWzI3MDMsIDI3MDVdLFxuICBbMjcwNywgMjcyOF0sXG4gIFsyNzMwLCAyNzM2XSxcbiAgWzI3MzgsIDI3MzldLFxuICBbMjc0MSwgMjc0NV0sXG4gIFsyNzg0LCAyNzg1XSxcbiAgWzI4MjEsIDI4MjhdLFxuICBbMjgzMSwgMjgzMl0sXG4gIFsyODM1LCAyODU2XSxcbiAgWzI4NTgsIDI4NjRdLFxuICBbMjg2NiwgMjg2N10sXG4gIFsyODY5LCAyODczXSxcbiAgWzI5MDgsIDI5MDldLFxuICBbMjkxMSwgMjkxM10sXG4gIFsyOTQ5LCAyOTU0XSxcbiAgWzI5NTgsIDI5NjBdLFxuICBbMjk2MiwgMjk2NV0sXG4gIFsyOTY5LCAyOTcwXSxcbiAgWzI5NzQsIDI5NzVdLFxuICBbMjk3OSwgMjk4MF0sXG4gIFsyOTg0LCAyOTg2XSxcbiAgWzI5OTAsIDMwMDFdLFxuICBbMzA3NywgMzA4NF0sXG4gIFszMDg2LCAzMDg4XSxcbiAgWzMwOTAsIDMxMTJdLFxuICBbMzExNCwgMzEyOV0sXG4gIFszMTYwLCAzMTYyXSxcbiAgWzMxNjgsIDMxNjldLFxuICBbMzIwNSwgMzIxMl0sXG4gIFszMjE0LCAzMjE2XSxcbiAgWzMyMTgsIDMyNDBdLFxuICBbMzI0MiwgMzI1MV0sXG4gIFszMjUzLCAzMjU3XSxcbiAgWzMyOTYsIDMyOTddLFxuICBbMzMxMywgMzMxNF0sXG4gIFszMzMzLCAzMzQwXSxcbiAgWzMzNDIsIDMzNDRdLFxuICBbMzM0NiwgMzM4Nl0sXG4gIFszNDEyLCAzNDE0XSxcbiAgWzM0MjMsIDM0MjVdLFxuICBbMzQ1MCwgMzQ1NV0sXG4gIFszNDYxLCAzNDc4XSxcbiAgWzM0ODIsIDM1MDVdLFxuICBbMzUwNywgMzUxNV0sXG4gIFszNTIwLCAzNTI2XSxcbiAgWzM1ODUsIDM2MzJdLFxuICBbMzYzNCwgMzYzNV0sXG4gIFszNjQ4LCAzNjUzXSxcbiAgWzM3MTMsIDM3MTRdLFxuICBbMzcxOCwgMzcyMl0sXG4gIFszNzI0LCAzNzQ3XSxcbiAgWzM3NTEsIDM3NjBdLFxuICBbMzc2MiwgMzc2M10sXG4gIFszNzc2LCAzNzgwXSxcbiAgWzM4MDQsIDM4MDddLFxuICBbMzkwNCwgMzkxMV0sXG4gIFszOTEzLCAzOTQ4XSxcbiAgWzM5NzYsIDM5ODBdLFxuICBbNDA5NiwgNDEzOF0sXG4gIFs0MTc2LCA0MTgxXSxcbiAgWzQxODYsIDQxODldLFxuICBbNDE5NywgNDE5OF0sXG4gIFs0MjA2LCA0MjA4XSxcbiAgWzQyMTMsIDQyMjVdLFxuICBbNDM1MiwgNDY4MF0sXG4gIFs0NjgyLCA0Njg1XSxcbiAgWzQ2ODgsIDQ2OTRdLFxuICBbNDY5OCwgNDcwMV0sXG4gIFs0NzA0LCA0NzQ0XSxcbiAgWzQ3NDYsIDQ3NDldLFxuICBbNDc1MiwgNDc4NF0sXG4gIFs0Nzg2LCA0Nzg5XSxcbiAgWzQ3OTIsIDQ3OThdLFxuICBbNDgwMiwgNDgwNV0sXG4gIFs0ODA4LCA0ODIyXSxcbiAgWzQ4MjQsIDQ4ODBdLFxuICBbNDg4MiwgNDg4NV0sXG4gIFs0ODg4LCA0OTU0XSxcbiAgWzQ5OTIsIDUwMDddLFxuICBbNTEyMSwgNTc0MF0sXG4gIFs1NzQzLCA1NzU5XSxcbiAgWzU3NjEsIDU3ODZdLFxuICBbNTc5MiwgNTg2Nl0sXG4gIFs1ODczLCA1ODgwXSxcbiAgWzU4ODgsIDU5MDBdLFxuICBbNTkwMiwgNTkwNV0sXG4gIFs1OTIwLCA1OTM3XSxcbiAgWzU5NTIsIDU5NjldLFxuICBbNTk4NCwgNTk5Nl0sXG4gIFs1OTk4LCA2MDAwXSxcbiAgWzYwMTYsIDYwNjddLFxuICBbNjE3NiwgNjIxMF0sXG4gIFs2MjEyLCA2MjY0XSxcbiAgWzYyNzIsIDYyNzZdLFxuICBbNjI3OSwgNjMxMl0sXG4gIFs2MzIwLCA2Mzg5XSxcbiAgWzY0MDAsIDY0MzBdLFxuICBbNjQ4MCwgNjUwOV0sXG4gIFs2NTEyLCA2NTE2XSxcbiAgWzY1MjgsIDY1NzFdLFxuICBbNjU3NiwgNjYwMV0sXG4gIFs2NjU2LCA2Njc4XSxcbiAgWzY2ODgsIDY3NDBdLFxuICBbNjkxNywgNjk2M10sXG4gIFs2OTgxLCA2OTg3XSxcbiAgWzcwNDMsIDcwNzJdLFxuICBbNzA4NiwgNzA4N10sXG4gIFs3MDk4LCA3MTQxXSxcbiAgWzcxNjgsIDcyMDNdLFxuICBbNzI0NSwgNzI0N10sXG4gIFs3MjU4LCA3Mjg3XSxcbiAgWzc0MDEsIDc0MDRdLFxuICBbNzQwNiwgNzQxMV0sXG4gIFs3NDEzLCA3NDE0XSxcbiAgWzg1MDEsIDg1MDRdLFxuICBbMTE1NjgsIDExNjIzXSxcbiAgWzExNjQ4LCAxMTY3MF0sXG4gIFsxMTY4MCwgMTE2ODZdLFxuICBbMTE2ODgsIDExNjk0XSxcbiAgWzExNjk2LCAxMTcwMl0sXG4gIFsxMTcwNCwgMTE3MTBdLFxuICBbMTE3MTIsIDExNzE4XSxcbiAgWzExNzIwLCAxMTcyNl0sXG4gIFsxMTcyOCwgMTE3MzRdLFxuICBbMTE3MzYsIDExNzQyXSxcbiAgWzEyMzUzLCAxMjQzOF0sXG4gIFsxMjQ0OSwgMTI1MzhdLFxuICBbMTI1NDksIDEyNTkxXSxcbiAgWzEyNTkzLCAxMjY4Nl0sXG4gIFsxMjcwNCwgMTI3MzBdLFxuICBbMTI3ODQsIDEyNzk5XSxcbiAgWzQwOTYwLCA0MDk4MF0sXG4gIFs0MDk4MiwgNDIxMjRdLFxuICBbNDIxOTIsIDQyMjMxXSxcbiAgWzQyMjQwLCA0MjUwN10sXG4gIFs0MjUxMiwgNDI1MjddLFxuICBbNDI1MzgsIDQyNTM5XSxcbiAgWzQyNjU2LCA0MjcyNV0sXG4gIFs0MzAwMywgNDMwMDldLFxuICBbNDMwMTEsIDQzMDEzXSxcbiAgWzQzMDE1LCA0MzAxOF0sXG4gIFs0MzAyMCwgNDMwNDJdLFxuICBbNDMwNzIsIDQzMTIzXSxcbiAgWzQzMTM4LCA0MzE4N10sXG4gIFs0MzI1MCwgNDMyNTVdLFxuICBbNDMyNjEsIDQzMjYyXSxcbiAgWzQzMjc0LCA0MzMwMV0sXG4gIFs0MzMxMiwgNDMzMzRdLFxuICBbNDMzNjAsIDQzMzg4XSxcbiAgWzQzMzk2LCA0MzQ0Ml0sXG4gIFs0MzQ4OCwgNDM0OTJdLFxuICBbNDM0OTUsIDQzNTAzXSxcbiAgWzQzNTE0LCA0MzUxOF0sXG4gIFs0MzUyMCwgNDM1NjBdLFxuICBbNDM1ODQsIDQzNTg2XSxcbiAgWzQzNTg4LCA0MzU5NV0sXG4gIFs0MzYxNiwgNDM2MzFdLFxuICBbNDM2MzMsIDQzNjM4XSxcbiAgWzQzNjQ2LCA0MzY5NV0sXG4gIFs0MzcwMSwgNDM3MDJdLFxuICBbNDM3MDUsIDQzNzA5XSxcbiAgWzQzNzM5LCA0Mzc0MF0sXG4gIFs0Mzc0NCwgNDM3NTRdLFxuICBbNDM3NzcsIDQzNzgyXSxcbiAgWzQzNzg1LCA0Mzc5MF0sXG4gIFs0Mzc5MywgNDM3OThdLFxuICBbNDM4MDgsIDQzODE0XSxcbiAgWzQzODE2LCA0MzgyMl0sXG4gIFs0Mzk2OCwgNDQwMDJdLFxuICBbNTUyMTYsIDU1MjM4XSxcbiAgWzU1MjQzLCA1NTI5MV0sXG4gIFs2Mzc0NCwgNjQxMDldLFxuICBbNjQxMTIsIDY0MjE3XSxcbiAgWzY0Mjg3LCA2NDI5Nl0sXG4gIFs2NDI5OCwgNjQzMTBdLFxuICBbNjQzMTIsIDY0MzE2XSxcbiAgWzY0MzIwLCA2NDMyMV0sXG4gIFs2NDMyMywgNjQzMjRdLFxuICBbNjQzMjYsIDY0NDMzXSxcbiAgWzY0NDY3LCA2NDgyOV0sXG4gIFs2NDg0OCwgNjQ5MTFdLFxuICBbNjQ5MTQsIDY0OTY3XSxcbiAgWzY1MDA4LCA2NTAxOV0sXG4gIFs2NTEzNiwgNjUxNDBdLFxuICBbNjUxNDIsIDY1Mjc2XSxcbiAgWzY1MzgyLCA2NTM5MV0sXG4gIFs2NTM5MywgNjU0MzddLFxuICBbNjU0NDAsIDY1NDcwXSxcbiAgWzY1NDc0LCA2NTQ3OV0sXG4gIFs2NTQ4MiwgNjU0ODddLFxuICBbNjU0OTAsIDY1NDk1XSxcbiAgWzY1NDk4LCA2NTUwMF0sXG4gIFs2NTUzNiwgNjU1NDddLFxuICBbNjU1NDksIDY1NTc0XSxcbiAgWzY1NTc2LCA2NTU5NF0sXG4gIFs2NTU5NiwgNjU1OTddLFxuICBbNjU1OTksIDY1NjEzXSxcbiAgWzY1NjE2LCA2NTYyOV0sXG4gIFs2NTY2NCwgNjU3ODZdLFxuICBbNjYxNzYsIDY2MjA0XSxcbiAgWzY2MjA4LCA2NjI1Nl0sXG4gIFs2NjMwNCwgNjYzMzVdLFxuICBbNjYzNDksIDY2MzY4XSxcbiAgWzY2MzcwLCA2NjM3N10sXG4gIFs2NjM4NCwgNjY0MjFdLFxuICBbNjY0MzIsIDY2NDYxXSxcbiAgWzY2NDY0LCA2NjQ5OV0sXG4gIFs2NjUwNCwgNjY1MTFdLFxuICBbNjY2NDAsIDY2NzE3XSxcbiAgWzY2ODE2LCA2Njg1NV0sXG4gIFs2Njg2NCwgNjY5MTVdLFxuICBbNjcwNzIsIDY3MzgyXSxcbiAgWzY3MzkyLCA2NzQxM10sXG4gIFs2NzQyNCwgNjc0MzFdLFxuICBbNjc1ODQsIDY3NTg5XSxcbiAgWzY3NTk0LCA2NzYzN10sXG4gIFs2NzYzOSwgNjc2NDBdLFxuICBbNjc2NDcsIDY3NjY5XSxcbiAgWzY3NjgwLCA2NzcwMl0sXG4gIFs2NzcxMiwgNjc3NDJdLFxuICBbNjc4MDgsIDY3ODI2XSxcbiAgWzY3ODI4LCA2NzgyOV0sXG4gIFs2Nzg0MCwgNjc4NjFdLFxuICBbNjc4NzIsIDY3ODk3XSxcbiAgWzY3OTY4LCA2ODAyM10sXG4gIFs2ODAzMCwgNjgwMzFdLFxuICBbNjgxMTIsIDY4MTE1XSxcbiAgWzY4MTE3LCA2ODExOV0sXG4gIFs2ODEyMSwgNjgxNDldLFxuICBbNjgxOTIsIDY4MjIwXSxcbiAgWzY4MjI0LCA2ODI1Ml0sXG4gIFs2ODI4OCwgNjgyOTVdLFxuICBbNjgyOTcsIDY4MzI0XSxcbiAgWzY4MzUyLCA2ODQwNV0sXG4gIFs2ODQxNiwgNjg0MzddLFxuICBbNjg0NDgsIDY4NDY2XSxcbiAgWzY4NDgwLCA2ODQ5N10sXG4gIFs2ODYwOCwgNjg2ODBdLFxuICBbNjg4NjQsIDY4ODk5XSxcbiAgWzY5Mzc2LCA2OTQwNF0sXG4gIFs2OTQyNCwgNjk0NDVdLFxuICBbNjk2MDAsIDY5NjIyXSxcbiAgWzY5NjM1LCA2OTY4N10sXG4gIFs2OTc2MywgNjk4MDddLFxuICBbNjk4NDAsIDY5ODY0XSxcbiAgWzY5ODkxLCA2OTkyNl0sXG4gIFs2OTk2OCwgNzAwMDJdLFxuICBbNzAwMTksIDcwMDY2XSxcbiAgWzcwMDgxLCA3MDA4NF0sXG4gIFs3MDE0NCwgNzAxNjFdLFxuICBbNzAxNjMsIDcwMTg3XSxcbiAgWzcwMjcyLCA3MDI3OF0sXG4gIFs3MDI4MiwgNzAyODVdLFxuICBbNzAyODcsIDcwMzAxXSxcbiAgWzcwMzAzLCA3MDMxMl0sXG4gIFs3MDMyMCwgNzAzNjZdLFxuICBbNzA0MDUsIDcwNDEyXSxcbiAgWzcwNDE1LCA3MDQxNl0sXG4gIFs3MDQxOSwgNzA0NDBdLFxuICBbNzA0NDIsIDcwNDQ4XSxcbiAgWzcwNDUwLCA3MDQ1MV0sXG4gIFs3MDQ1MywgNzA0NTddLFxuICBbNzA0OTMsIDcwNDk3XSxcbiAgWzcwNjU2LCA3MDcwOF0sXG4gIFs3MDcyNywgNzA3MzBdLFxuICBbNzA3ODQsIDcwODMxXSxcbiAgWzcwODUyLCA3MDg1M10sXG4gIFs3MTA0MCwgNzEwODZdLFxuICBbNzExMjgsIDcxMTMxXSxcbiAgWzcxMTY4LCA3MTIxNV0sXG4gIFs3MTI5NiwgNzEzMzhdLFxuICBbNzE0MjQsIDcxNDUwXSxcbiAgWzcxNjgwLCA3MTcyM10sXG4gIFs3MjA5NiwgNzIxMDNdLFxuICBbNzIxMDYsIDcyMTQ0XSxcbiAgWzcyMjAzLCA3MjI0Ml0sXG4gIFs3MjI4NCwgNzIzMjldLFxuICBbNzIzODQsIDcyNDQwXSxcbiAgWzcyNzA0LCA3MjcxMl0sXG4gIFs3MjcxNCwgNzI3NTBdLFxuICBbNzI4MTgsIDcyODQ3XSxcbiAgWzcyOTYwLCA3Mjk2Nl0sXG4gIFs3Mjk2OCwgNzI5NjldLFxuICBbNzI5NzEsIDczMDA4XSxcbiAgWzczMDU2LCA3MzA2MV0sXG4gIFs3MzA2MywgNzMwNjRdLFxuICBbNzMwNjYsIDczMDk3XSxcbiAgWzczNDQwLCA3MzQ1OF0sXG4gIFs3MzcyOCwgNzQ2NDldLFxuICBbNzQ4ODAsIDc1MDc1XSxcbiAgWzc3ODI0LCA3ODg5NF0sXG4gIFs4Mjk0NCwgODM1MjZdLFxuICBbOTIxNjAsIDkyNzI4XSxcbiAgWzkyNzM2LCA5Mjc2Nl0sXG4gIFs5Mjg4MCwgOTI5MDldLFxuICBbOTI5MjgsIDkyOTc1XSxcbiAgWzkzMDI3LCA5MzA0N10sXG4gIFs5MzA1MywgOTMwNzFdLFxuICBbOTM5NTIsIDk0MDI2XSxcbiAgWzEwMDM1MiwgMTAxMTA2XSxcbiAgWzExMDU5MiwgMTEwODc4XSxcbiAgWzExMDkyOCwgMTEwOTMwXSxcbiAgWzExMDk0OCwgMTEwOTUxXSxcbiAgWzExMDk2MCwgMTExMzU1XSxcbiAgWzExMzY2NCwgMTEzNzcwXSxcbiAgWzExMzc3NiwgMTEzNzg4XSxcbiAgWzExMzc5MiwgMTEzODAwXSxcbiAgWzExMzgwOCwgMTEzODE3XSxcbiAgWzEyMzEzNiwgMTIzMTgwXSxcbiAgWzEyMzU4NCwgMTIzNjI3XSxcbiAgWzEyNDkyOCwgMTI1MTI0XSxcbiAgWzEyNjQ2NCwgMTI2NDY3XSxcbiAgWzEyNjQ2OSwgMTI2NDk1XSxcbiAgWzEyNjQ5NywgMTI2NDk4XSxcbiAgWzEyNjUwNSwgMTI2NTE0XSxcbiAgWzEyNjUxNiwgMTI2NTE5XSxcbiAgWzEyNjU0MSwgMTI2NTQzXSxcbiAgWzEyNjU0NSwgMTI2NTQ2XSxcbiAgWzEyNjU2MSwgMTI2NTYyXSxcbiAgWzEyNjU2NywgMTI2NTcwXSxcbiAgWzEyNjU3MiwgMTI2NTc4XSxcbiAgWzEyNjU4MCwgMTI2NTgzXSxcbiAgWzEyNjU4NSwgMTI2NTg4XSxcbiAgWzEyNjU5MiwgMTI2NjAxXSxcbiAgWzEyNjYwMywgMTI2NjE5XSxcbiAgWzEyNjYyNSwgMTI2NjI3XSxcbiAgWzEyNjYyOSwgMTI2NjMzXSxcbiAgWzEyNjYzNSwgMTI2NjUxXSxcbiAgWzE5NDU2MCwgMTk1MTAxXSxcbiAgWzgwNzIsIDgwNzldLFxuICBbODA4OCwgODA5NV0sXG4gIFs4MTA0LCA4MTExXSxcbiAgWzY1LCA5MF0sXG4gIFsxOTIsIDIxNF0sXG4gIFsyMTYsIDIyMl0sXG4gIFszNzYsIDM3N10sXG4gIFszODUsIDM4Nl0sXG4gIFszOTAsIDM5MV0sXG4gIFszOTMsIDM5NV0sXG4gIFszOTgsIDQwMV0sXG4gIFs0MDMsIDQwNF0sXG4gIFs0MDYsIDQwOF0sXG4gIFs0MTIsIDQxM10sXG4gIFs0MTUsIDQxNl0sXG4gIFs0MjIsIDQyM10sXG4gIFs0MzAsIDQzMV0sXG4gIFs0MzMsIDQzNV0sXG4gIFs0MzksIDQ0MF0sXG4gIFs1MDIsIDUwNF0sXG4gIFs1NzAsIDU3MV0sXG4gIFs1NzMsIDU3NF0sXG4gIFs1NzksIDU4Ml0sXG4gIFs5MDQsIDkwNl0sXG4gIFs5MTAsIDkxMV0sXG4gIFs5MTMsIDkyOV0sXG4gIFs5MzEsIDkzOV0sXG4gIFs5NzgsIDk4MF0sXG4gIFsxMDE3LCAxMDE4XSxcbiAgWzEwMjEsIDEwNzFdLFxuICBbMTIxNiwgMTIxN10sXG4gIFsxMzI5LCAxMzY2XSxcbiAgWzQyNTYsIDQyOTNdLFxuICBbNTAyNCwgNTEwOV0sXG4gIFs3MzEyLCA3MzU0XSxcbiAgWzczNTcsIDczNTldLFxuICBbNzk0NCwgNzk1MV0sXG4gIFs3OTYwLCA3OTY1XSxcbiAgWzc5NzYsIDc5ODNdLFxuICBbNzk5MiwgNzk5OV0sXG4gIFs4MDA4LCA4MDEzXSxcbiAgWzgwNDAsIDgwNDddLFxuICBbODEyMCwgODEyM10sXG4gIFs4MTM2LCA4MTM5XSxcbiAgWzgxNTIsIDgxNTVdLFxuICBbODE2OCwgODE3Ml0sXG4gIFs4MTg0LCA4MTg3XSxcbiAgWzg0NTksIDg0NjFdLFxuICBbODQ2NCwgODQ2Nl0sXG4gIFs4NDczLCA4NDc3XSxcbiAgWzg0OTAsIDg0OTNdLFxuICBbODQ5NiwgODQ5OV0sXG4gIFs4NTEwLCA4NTExXSxcbiAgWzExMjY0LCAxMTMxMF0sXG4gIFsxMTM2MiwgMTEzNjRdLFxuICBbMTEzNzMsIDExMzc2XSxcbiAgWzExMzkwLCAxMTM5Ml0sXG4gIFs0Mjg3NywgNDI4NzhdLFxuICBbNDI5MjIsIDQyOTI2XSxcbiAgWzQyOTI4LCA0MjkzMl0sXG4gIFs0Mjk0OCwgNDI5NTBdLFxuICBbNjUzMTMsIDY1MzM4XSxcbiAgWzY2NTYwLCA2NjU5OV0sXG4gIFs2NjczNiwgNjY3NzFdLFxuICBbNjg3MzYsIDY4Nzg2XSxcbiAgWzcxODQwLCA3MTg3MV0sXG4gIFs5Mzc2MCwgOTM3OTFdLFxuICBbMTE5ODA4LCAxMTk4MzNdLFxuICBbMTE5ODYwLCAxMTk4ODVdLFxuICBbMTE5OTEyLCAxMTk5MzddLFxuICBbMTE5OTY2LCAxMTk5NjddLFxuICBbMTE5OTczLCAxMTk5NzRdLFxuICBbMTE5OTc3LCAxMTk5ODBdLFxuICBbMTE5OTgyLCAxMTk5ODldLFxuICBbMTIwMDE2LCAxMjAwNDFdLFxuICBbMTIwMDY4LCAxMjAwNjldLFxuICBbMTIwMDcxLCAxMjAwNzRdLFxuICBbMTIwMDc3LCAxMjAwODRdLFxuICBbMTIwMDg2LCAxMjAwOTJdLFxuICBbMTIwMTIwLCAxMjAxMjFdLFxuICBbMTIwMTIzLCAxMjAxMjZdLFxuICBbMTIwMTI4LCAxMjAxMzJdLFxuICBbMTIwMTM4LCAxMjAxNDRdLFxuICBbMTIwMTcyLCAxMjAxOTddLFxuICBbMTIwMjI0LCAxMjAyNDldLFxuICBbMTIwMjc2LCAxMjAzMDFdLFxuICBbMTIwMzI4LCAxMjAzNTNdLFxuICBbMTIwMzgwLCAxMjA0MDVdLFxuICBbMTIwNDMyLCAxMjA0NTddLFxuICBbMTIwNDg4LCAxMjA1MTJdLFxuICBbMTIwNTQ2LCAxMjA1NzBdLFxuICBbMTIwNjA0LCAxMjA2MjhdLFxuICBbMTIwNjYyLCAxMjA2ODZdLFxuICBbMTIwNzIwLCAxMjA3NDRdLFxuICBbMTI1MTg0LCAxMjUyMTddLFxuICBbNTg3MCwgNTg3Ml0sXG4gIFs4NTQ0LCA4NTc4XSxcbiAgWzg1ODEsIDg1ODRdLFxuICBbMTIzMjEsIDEyMzI5XSxcbiAgWzEyMzQ0LCAxMjM0Nl0sXG4gIFs0MjcyNiwgNDI3MzVdLFxuICBbNjU4NTYsIDY1OTA4XSxcbiAgWzY2NTEzLCA2NjUxN10sXG4gIFs3NDc1MiwgNzQ4NjJdLFxuICBbMTYyLCAxNjVdLFxuICBbMjA0NiwgMjA0N10sXG4gIFsyNTQ2LCAyNTQ3XSxcbiAgWzgzNTIsIDgzODNdLFxuICBbNjU1MDQsIDY1NTA1XSxcbiAgWzY1NTA5LCA2NTUxMF0sXG4gIFs3MzY5MywgNzM2OTZdLFxuICBbODI1NSwgODI1Nl0sXG4gIFs2NTA3NSwgNjUwNzZdLFxuICBbNjUxMDEsIDY1MTAzXVxuXTtcbmFkZFJhbmdlcyhmaWMsIGZpY19hKTtcbmNvbnN0IHJpY2QgPSBuZXcgU2V0KFtcbiAgMTQ3MSxcbiAgMTQ3OSxcbiAgMTY0OCxcbiAgMTgwOSxcbiAgMjA0NSxcbiAgMjM2MixcbiAgMjM2NCxcbiAgMjM4MSxcbiAgMjQzMyxcbiAgMjQ5MixcbiAgMjUwOSxcbiAgMjU1OCxcbiAgMjYyMCxcbiAgMjY0MSxcbiAgMjY3NyxcbiAgMjc0OCxcbiAgMjc2NSxcbiAgMjgxNyxcbiAgMjg3NixcbiAgMjg3OSxcbiAgMjg5MyxcbiAgMjkwMixcbiAgMjk0NixcbiAgMzAwOCxcbiAgMzAyMSxcbiAgMzA3MixcbiAgMzA3NixcbiAgMzIwMSxcbiAgMzI2MCxcbiAgMzI2MyxcbiAgMzI3MCxcbiAgMzQwNSxcbiAgMzUzMCxcbiAgMzU0MixcbiAgMzYzMyxcbiAgMzc2MSxcbiAgMzg5MyxcbiAgMzg5NSxcbiAgMzg5NyxcbiAgNDAzOCxcbiAgNDIyNixcbiAgNDIzNyxcbiAgNDI1MyxcbiAgNjA4NixcbiAgNjEwOSxcbiAgNjMxMyxcbiAgNjQ1MCxcbiAgNjY4MyxcbiAgNjc0MixcbiAgNjc1MixcbiAgNjc1NCxcbiAgNjc4MyxcbiAgNjk2NCxcbiAgNjk3MixcbiAgNjk3OCxcbiAgNzE0MixcbiAgNzE0OSxcbiAgNzQwNSxcbiAgNzQxMixcbiAgODQxNyxcbiAgMTE2NDcsXG4gIDQyNjA3LFxuICA0MzAxMCxcbiAgNDMwMTQsXG4gIDQzMDE5LFxuICA0MzI2MyxcbiAgNDM0NDMsXG4gIDQzNDkzLFxuICA0MzU4NyxcbiAgNDM1OTYsXG4gIDQzNjQ0LFxuICA0MzY5NixcbiAgNDM3MTMsXG4gIDQzNzY2LFxuICA0NDAwNSxcbiAgNDQwMDgsXG4gIDQ0MDEzLFxuICA2NDI4NixcbiAgNjYwNDUsXG4gIDY2MjcyLFxuICA2ODE1OSxcbiAgNjk2MzMsXG4gIDcwMDAzLFxuICA3MDE5NixcbiAgNzAyMDYsXG4gIDcwMzY3LFxuICA3MDQ2NCxcbiAgNzA3MjYsXG4gIDcwNzUwLFxuICA3MDg0MixcbiAgNzEyMjksXG4gIDcxMzM5LFxuICA3MTM0MSxcbiAgNzEzNTEsXG4gIDcyMTYwLFxuICA3MjI2MyxcbiAgNzI3NjcsXG4gIDczMDE4LFxuICA3MzAzMSxcbiAgNzMxMDksXG4gIDczMTExLFxuICA5NDAzMSxcbiAgMTIxNDYxLFxuICAxMjE0NzYsXG4gIDE3MyxcbiAgMTU2NCxcbiAgMTc1NyxcbiAgMTgwNyxcbiAgMjI3NCxcbiAgNjE1OCxcbiAgNjUyNzksXG4gIDY5ODIxLFxuICA2OTgzNyxcbiAgOTE3NTA1XG5dKTtcbmNvbnN0IHJpY2RfYSA9IFtcbiAgWzc2OCwgODc5XSxcbiAgWzExNTUsIDExNTldLFxuICBbMTQyNSwgMTQ2OV0sXG4gIFsxNDczLCAxNDc0XSxcbiAgWzE0NzYsIDE0NzddLFxuICBbMTU1MiwgMTU2Ml0sXG4gIFsxNjExLCAxNjMxXSxcbiAgWzE3NTAsIDE3NTZdLFxuICBbMTc1OSwgMTc2NF0sXG4gIFsxNzY3LCAxNzY4XSxcbiAgWzE3NzAsIDE3NzNdLFxuICBbMTg0MCwgMTg2Nl0sXG4gIFsxOTU4LCAxOTY4XSxcbiAgWzIwMjcsIDIwMzVdLFxuICBbMjA3MCwgMjA3M10sXG4gIFsyMDc1LCAyMDgzXSxcbiAgWzIwODUsIDIwODddLFxuICBbMjA4OSwgMjA5M10sXG4gIFsyMTM3LCAyMTM5XSxcbiAgWzIyNTksIDIyNzNdLFxuICBbMjI3NSwgMjMwNl0sXG4gIFsyMzY5LCAyMzc2XSxcbiAgWzIzODUsIDIzOTFdLFxuICBbMjQwMiwgMjQwM10sXG4gIFsyNDk3LCAyNTAwXSxcbiAgWzI1MzAsIDI1MzFdLFxuICBbMjU2MSwgMjU2Ml0sXG4gIFsyNjI1LCAyNjI2XSxcbiAgWzI2MzEsIDI2MzJdLFxuICBbMjYzNSwgMjYzN10sXG4gIFsyNjcyLCAyNjczXSxcbiAgWzI2ODksIDI2OTBdLFxuICBbMjc1MywgMjc1N10sXG4gIFsyNzU5LCAyNzYwXSxcbiAgWzI3ODYsIDI3ODddLFxuICBbMjgxMCwgMjgxNV0sXG4gIFsyODgxLCAyODg0XSxcbiAgWzI5MTQsIDI5MTVdLFxuICBbMzEzNCwgMzEzNl0sXG4gIFszMTQyLCAzMTQ0XSxcbiAgWzMxNDYsIDMxNDldLFxuICBbMzE1NywgMzE1OF0sXG4gIFszMTcwLCAzMTcxXSxcbiAgWzMyNzYsIDMyNzddLFxuICBbMzI5OCwgMzI5OV0sXG4gIFszMzI4LCAzMzI5XSxcbiAgWzMzODcsIDMzODhdLFxuICBbMzM5MywgMzM5Nl0sXG4gIFszNDI2LCAzNDI3XSxcbiAgWzM1MzgsIDM1NDBdLFxuICBbMzYzNiwgMzY0Ml0sXG4gIFszNjU1LCAzNjYyXSxcbiAgWzM3NjQsIDM3NzJdLFxuICBbMzc4NCwgMzc4OV0sXG4gIFszODY0LCAzODY1XSxcbiAgWzM5NTMsIDM5NjZdLFxuICBbMzk2OCwgMzk3Ml0sXG4gIFszOTc0LCAzOTc1XSxcbiAgWzM5ODEsIDM5OTFdLFxuICBbMzk5MywgNDAyOF0sXG4gIFs0MTQxLCA0MTQ0XSxcbiAgWzQxNDYsIDQxNTFdLFxuICBbNDE1MywgNDE1NF0sXG4gIFs0MTU3LCA0MTU4XSxcbiAgWzQxODQsIDQxODVdLFxuICBbNDE5MCwgNDE5Ml0sXG4gIFs0MjA5LCA0MjEyXSxcbiAgWzQyMjksIDQyMzBdLFxuICBbNDk1NywgNDk1OV0sXG4gIFs1OTA2LCA1OTA4XSxcbiAgWzU5MzgsIDU5NDBdLFxuICBbNTk3MCwgNTk3MV0sXG4gIFs2MDAyLCA2MDAzXSxcbiAgWzYwNjgsIDYwNjldLFxuICBbNjA3MSwgNjA3N10sXG4gIFs2MDg5LCA2MDk5XSxcbiAgWzYxNTUsIDYxNTddLFxuICBbNjI3NywgNjI3OF0sXG4gIFs2NDMyLCA2NDM0XSxcbiAgWzY0MzksIDY0NDBdLFxuICBbNjQ1NywgNjQ1OV0sXG4gIFs2Njc5LCA2NjgwXSxcbiAgWzY3NDQsIDY3NTBdLFxuICBbNjc1NywgNjc2NF0sXG4gIFs2NzcxLCA2NzgwXSxcbiAgWzY4MzIsIDY4NDVdLFxuICBbNjkxMiwgNjkxNV0sXG4gIFs2OTY2LCA2OTcwXSxcbiAgWzcwMTksIDcwMjddLFxuICBbNzA0MCwgNzA0MV0sXG4gIFs3MDc0LCA3MDc3XSxcbiAgWzcwODAsIDcwODFdLFxuICBbNzA4MywgNzA4NV0sXG4gIFs3MTQ0LCA3MTQ1XSxcbiAgWzcxNTEsIDcxNTNdLFxuICBbNzIxMiwgNzIxOV0sXG4gIFs3MjIyLCA3MjIzXSxcbiAgWzczNzYsIDczNzhdLFxuICBbNzM4MCwgNzM5Ml0sXG4gIFs3Mzk0LCA3NDAwXSxcbiAgWzc0MTYsIDc0MTddLFxuICBbNzYxNiwgNzY3M10sXG4gIFs3Njc1LCA3Njc5XSxcbiAgWzg0MDAsIDg0MTJdLFxuICBbODQyMSwgODQzMl0sXG4gIFsxMTUwMywgMTE1MDVdLFxuICBbMTE3NDQsIDExNzc1XSxcbiAgWzEyMzMwLCAxMjMzM10sXG4gIFsxMjQ0MSwgMTI0NDJdLFxuICBbNDI2MTIsIDQyNjIxXSxcbiAgWzQyNjU0LCA0MjY1NV0sXG4gIFs0MjczNiwgNDI3MzddLFxuICBbNDMwNDUsIDQzMDQ2XSxcbiAgWzQzMjA0LCA0MzIwNV0sXG4gIFs0MzIzMiwgNDMyNDldLFxuICBbNDMzMDIsIDQzMzA5XSxcbiAgWzQzMzM1LCA0MzM0NV0sXG4gIFs0MzM5MiwgNDMzOTRdLFxuICBbNDM0NDYsIDQzNDQ5XSxcbiAgWzQzNDUyLCA0MzQ1M10sXG4gIFs0MzU2MSwgNDM1NjZdLFxuICBbNDM1NjksIDQzNTcwXSxcbiAgWzQzNTczLCA0MzU3NF0sXG4gIFs0MzY5OCwgNDM3MDBdLFxuICBbNDM3MDMsIDQzNzA0XSxcbiAgWzQzNzEwLCA0MzcxMV0sXG4gIFs0Mzc1NiwgNDM3NTddLFxuICBbNjUwMjQsIDY1MDM5XSxcbiAgWzY1MDU2LCA2NTA3MV0sXG4gIFs2NjQyMiwgNjY0MjZdLFxuICBbNjgwOTcsIDY4MDk5XSxcbiAgWzY4MTAxLCA2ODEwMl0sXG4gIFs2ODEwOCwgNjgxMTFdLFxuICBbNjgxNTIsIDY4MTU0XSxcbiAgWzY4MzI1LCA2ODMyNl0sXG4gIFs2ODkwMCwgNjg5MDNdLFxuICBbNjk0NDYsIDY5NDU2XSxcbiAgWzY5Njg4LCA2OTcwMl0sXG4gIFs2OTc1OSwgNjk3NjFdLFxuICBbNjk4MTEsIDY5ODE0XSxcbiAgWzY5ODE3LCA2OTgxOF0sXG4gIFs2OTg4OCwgNjk4OTBdLFxuICBbNjk5MjcsIDY5OTMxXSxcbiAgWzY5OTMzLCA2OTk0MF0sXG4gIFs3MDAxNiwgNzAwMTddLFxuICBbNzAwNzAsIDcwMDc4XSxcbiAgWzcwMDg5LCA3MDA5Ml0sXG4gIFs3MDE5MSwgNzAxOTNdLFxuICBbNzAxOTgsIDcwMTk5XSxcbiAgWzcwMzcxLCA3MDM3OF0sXG4gIFs3MDQwMCwgNzA0MDFdLFxuICBbNzA0NTksIDcwNDYwXSxcbiAgWzcwNTAyLCA3MDUwOF0sXG4gIFs3MDUxMiwgNzA1MTZdLFxuICBbNzA3MTIsIDcwNzE5XSxcbiAgWzcwNzIyLCA3MDcyNF0sXG4gIFs3MDgzNSwgNzA4NDBdLFxuICBbNzA4NDcsIDcwODQ4XSxcbiAgWzcwODUwLCA3MDg1MV0sXG4gIFs3MTA5MCwgNzEwOTNdLFxuICBbNzExMDAsIDcxMTAxXSxcbiAgWzcxMTAzLCA3MTEwNF0sXG4gIFs3MTEzMiwgNzExMzNdLFxuICBbNzEyMTksIDcxMjI2XSxcbiAgWzcxMjMxLCA3MTIzMl0sXG4gIFs3MTM0NCwgNzEzNDldLFxuICBbNzE0NTMsIDcxNDU1XSxcbiAgWzcxNDU4LCA3MTQ2MV0sXG4gIFs3MTQ2MywgNzE0NjddLFxuICBbNzE3MjcsIDcxNzM1XSxcbiAgWzcxNzM3LCA3MTczOF0sXG4gIFs3MjE0OCwgNzIxNTFdLFxuICBbNzIxNTQsIDcyMTU1XSxcbiAgWzcyMTkzLCA3MjIwMl0sXG4gIFs3MjI0MywgNzIyNDhdLFxuICBbNzIyNTEsIDcyMjU0XSxcbiAgWzcyMjczLCA3MjI3OF0sXG4gIFs3MjI4MSwgNzIyODNdLFxuICBbNzIzMzAsIDcyMzQyXSxcbiAgWzcyMzQ0LCA3MjM0NV0sXG4gIFs3Mjc1MiwgNzI3NThdLFxuICBbNzI3NjAsIDcyNzY1XSxcbiAgWzcyODUwLCA3Mjg3MV0sXG4gIFs3Mjg3NCwgNzI4ODBdLFxuICBbNzI4ODIsIDcyODgzXSxcbiAgWzcyODg1LCA3Mjg4Nl0sXG4gIFs3MzAwOSwgNzMwMTRdLFxuICBbNzMwMjAsIDczMDIxXSxcbiAgWzczMDIzLCA3MzAyOV0sXG4gIFs3MzEwNCwgNzMxMDVdLFxuICBbNzM0NTksIDczNDYwXSxcbiAgWzkyOTEyLCA5MjkxNl0sXG4gIFs5Mjk3NiwgOTI5ODJdLFxuICBbOTQwOTUsIDk0MDk4XSxcbiAgWzExMzgyMSwgMTEzODIyXSxcbiAgWzExOTE0MywgMTE5MTQ1XSxcbiAgWzExOTE2MywgMTE5MTcwXSxcbiAgWzExOTE3MywgMTE5MTc5XSxcbiAgWzExOTIxMCwgMTE5MjEzXSxcbiAgWzExOTM2MiwgMTE5MzY0XSxcbiAgWzEyMTM0NCwgMTIxMzk4XSxcbiAgWzEyMTQwMywgMTIxNDUyXSxcbiAgWzEyMTQ5OSwgMTIxNTAzXSxcbiAgWzEyMTUwNSwgMTIxNTE5XSxcbiAgWzEyMjg4MCwgMTIyODg2XSxcbiAgWzEyMjg4OCwgMTIyOTA0XSxcbiAgWzEyMjkwNywgMTIyOTEzXSxcbiAgWzEyMjkxNSwgMTIyOTE2XSxcbiAgWzEyMjkxOCwgMTIyOTIyXSxcbiAgWzEyMzE4NCwgMTIzMTkwXSxcbiAgWzEyMzYyOCwgMTIzNjMxXSxcbiAgWzEyNTEzNiwgMTI1MTQyXSxcbiAgWzEyNTI1MiwgMTI1MjU4XSxcbiAgWzkxNzc2MCwgOTE3OTk5XSxcbiAgWzE1MzYsIDE1NDFdLFxuICBbODIwMywgODIwN10sXG4gIFs4MjM0LCA4MjM4XSxcbiAgWzgyODgsIDgyOTJdLFxuICBbODI5NCwgODMwM10sXG4gIFs2NTUyOSwgNjU1MzFdLFxuICBbNzg4OTYsIDc4OTA0XSxcbiAgWzExMzgyNCwgMTEzODI3XSxcbiAgWzExOTE1NSwgMTE5MTYyXSxcbiAgWzkxNzUzNiwgOTE3NjMxXVxuXTtcbmFkZFJhbmdlcyhyaWNkLCByaWNkX2EpO1xuY29uc3QgbWFjX2EgPSBbXG4gIFswLCA4XSxcbiAgWzE0LCAyN10sXG4gIFsxMjcsIDE1OV0sXG4gIFs3NjgsIDg3OV0sXG4gIFs2ODMyLCA2OTExXSxcbiAgWzc2MTYsIDc2NzldLFxuICBbODQwMCwgODQ0N10sXG4gIFs2NTA1NiwgNjUwNzFdLFxuICBbNDgsIDU3XVxuXTtcbmFkZFJhbmdlcyhyaWNkLCBtYWNfYSk7XG5jb25zdCByaWMgPSBuZXcgU2V0KFxuICAoZnVuY3Rpb24qKCkge1xuICAgIHlpZWxkKiBmaWM7XG4gICAgeWllbGQqIHJpY2Q7XG4gIH0pKClcbik7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlyc3RJZGVudENoYXI6IGZpYyxcbiAgcmVzdElkZW50Q2hhcjogcmljXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/unicodesets.js\n");

/***/ }),

/***/ "./node_modules/java-parser/src/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/java-parser/src/utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n/**\n * Should Parser / Lexer Validations be skipped?\n *\n * By default (productive mode) the validations would be skipped to reduce parser initialization time.\n * But during development flows (e.g testing/CI) they should be enabled to detect possible issues.\n *\n * @returns {boolean}\n */\nfunction getSkipValidations() {\n  return (\n    (process && // (not every runtime has a global `process` object\n      process.env &&\n      process.env[\"prettier-java-development-mode\"] === \"enabled\") === false\n  );\n}\n\nmodule.exports = {\n  getSkipValidations\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF2YS1wYXJzZXIvc3JjL3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2phdmEtcGFyc2VyL3NyYy91dGlscy5qcz8xNjAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFNob3VsZCBQYXJzZXIgLyBMZXhlciBWYWxpZGF0aW9ucyBiZSBza2lwcGVkP1xuICpcbiAqIEJ5IGRlZmF1bHQgKHByb2R1Y3RpdmUgbW9kZSkgdGhlIHZhbGlkYXRpb25zIHdvdWxkIGJlIHNraXBwZWQgdG8gcmVkdWNlIHBhcnNlciBpbml0aWFsaXphdGlvbiB0aW1lLlxuICogQnV0IGR1cmluZyBkZXZlbG9wbWVudCBmbG93cyAoZS5nIHRlc3RpbmcvQ0kpIHRoZXkgc2hvdWxkIGJlIGVuYWJsZWQgdG8gZGV0ZWN0IHBvc3NpYmxlIGlzc3Vlcy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZ2V0U2tpcFZhbGlkYXRpb25zKCkge1xuICByZXR1cm4gKFxuICAgIChwcm9jZXNzICYmIC8vIChub3QgZXZlcnkgcnVudGltZSBoYXMgYSBnbG9iYWwgYHByb2Nlc3NgIG9iamVjdFxuICAgICAgcHJvY2Vzcy5lbnYgJiZcbiAgICAgIHByb2Nlc3MuZW52W1wicHJldHRpZXItamF2YS1kZXZlbG9wbWVudC1tb2RlXCJdID09PSBcImVuYWJsZWRcIikgPT09IGZhbHNlXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRTa2lwVmFsaWRhdGlvbnNcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/java-parser/src/utils.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/regexp-to-ast/lib/regexp-to-ast.js":
/*!*********************************************************!*\
  !*** ./node_modules/regexp-to-ast/lib/regexp-to-ast.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {\n    // istanbul ignore next\n    if (true) {\n        // istanbul ignore next\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else {}\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return { type: \"Pattern\", flags: flags, value: value }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            switch (this.popChar()) {\n                case \"^\":\n                    return { type: \"StartAnchor\" }\n                case \"$\":\n                    return { type: \"EndAnchor\" }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return { type: \"WordBoundary\" }\n                        case \"B\":\n                            return { type: \"NonWordBoundary\" }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return { type: type, value: disjunction }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead  DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.4.0\"\n        }\n    }\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZXhwLXRvLWFzdC9saWIvcmVnZXhwLXRvLWFzdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWdleHAtdG8tYXN0L2xpYi9yZWdleHAtdG8tYXN0LmpzPzg5MGYiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHJvb3QucmVnZXhwVG9Bc3QgPSBmYWN0b3J5KClcbiAgICB9XG59KShcbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc2VsZlxuICAgICAgICA6IHRoaXMsXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHJlZmVyZW5jZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9oYWNrZXJub29uLmNvbS90aGUtbWFkbmVzcy1vZi1wYXJzaW5nLXJlYWwtd29ybGQtamF2YXNjcmlwdC1yZWdleHBzLWQ5ZWUzMzZkZjk4M1xuICAgICAgICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC9pbmRleC5odG1sI3Byb2QtUGF0dGVyblxuICAgICAgICBmdW5jdGlvbiBSZWdFeHBQYXJzZXIoKSB7fVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkeDogdGhpcy5pZHgsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJZHg6IHRoaXMuZ3JvdXBJZHhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaWR4ID0gbmV3U3RhdGUuaWR4XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gbmV3U3RhdGUuaW5wdXRcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJZHggPSBuZXdTdGF0ZS5ncm91cElkeFxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5wYXR0ZXJuID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pZHggPSAwXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXRcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJZHggPSAwXG5cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmRpc2p1bmN0aW9uKClcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpXG5cbiAgICAgICAgICAgIHZhciBmbGFncyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkZsYWdzXCIsXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVDYXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuaWNvZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0aWNreTogZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNSZWdFeHBGbGFnKCkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGbGFnKGZsYWdzLCBcImdsb2JhbFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwiaWdub3JlQ2FzZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwibXVsdGlMaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJ1bmljb2RlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJzdGlja3lcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pZHggIT09IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiUmVkdW5kYW50IGlucHV0OiBcIiArIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaWR4KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiUGF0dGVyblwiLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmRpc2p1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWx0cyA9IFtdXG4gICAgICAgICAgICBhbHRzLnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrQ2hhcigpID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ8XCIpXG4gICAgICAgICAgICAgICAgYWx0cy5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJEaXNqdW5jdGlvblwiLCB2YWx1ZTogYWx0cyB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmFsdGVybmF0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGVybXMgPSBbXVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc1Rlcm0oKSkge1xuICAgICAgICAgICAgICAgIHRlcm1zLnB1c2godGhpcy50ZXJtKCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQWx0ZXJuYXRpdmVcIiwgdmFsdWU6IHRlcm1zIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUudGVybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3NlcnRpb24oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VydGlvbigpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0b20oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5hc3NlcnRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIlN0YXJ0QW5jaG9yXCIgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiRW5kQW5jaG9yXCIgfVxuICAgICAgICAgICAgICAgIC8vICdcXGInIG9yICdcXEInXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIldvcmRCb3VuZGFyeVwiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJOb25Xb3JkQm91bmRhcnlcIiB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIEFzc2VydGlvbiBFc2NhcGVcIilcbiAgICAgICAgICAgICAgICAvLyAnKD89JyBvciAnKD8hJ1xuICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJMb29rYWhlYWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIk5lZ2F0aXZlTG9va2FoZWFkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEFTU0VSVF9FWElTVFModHlwZSlcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzanVuY3Rpb24gPSB0aGlzLmRpc2p1bmN0aW9uKClcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIHZhbHVlOiBkaXNqdW5jdGlvbiB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5xdWFudGlmaWVyID0gZnVuY3Rpb24oaXNCYWNrdHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogSW5maW5pdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogSW5maW5pdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0TGVhc3QgPSB0aGlzLmludGVnZXJJbmNsdWRpbmdaZXJvKClcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0OiBhdExlYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdE1vc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RpZ2l0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0ID0gdGhpcy5pbnRlZ2VySW5jbHVkaW5nWmVybygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogYXRNb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IGF0TGVhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIn1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93aW5nIGV4Y2VwdGlvbnMgZnJvbSBcIkFTU0VSVF9FWElTVFNcIiBkdXJpbmcgYmFja3RyYWNraW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlcyBzZXZlcmUgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2t0cmFja2luZyA9PT0gdHJ1ZSAmJiByYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhyYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhyb3dpbmcgZXhjZXB0aW9ucyBmcm9tIFwiQVNTRVJUX0VYSVNUU1wiIGR1cmluZyBiYWNrdHJhY2tpbmdcbiAgICAgICAgICAgIC8vIGNhdXNlcyBzZXZlcmUgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25zXG4gICAgICAgICAgICBpZiAoaXNCYWNrdHJhY2tpbmcgPT09IHRydWUgJiYgcmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhyYW5nZSlcblxuICAgICAgICAgICAgaWYgKHRoaXMucGVla0NoYXIoMCkgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIilcbiAgICAgICAgICAgICAgICByYW5nZS5ncmVlZHkgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5ncmVlZHkgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlLnR5cGUgPSBcIlF1YW50aWZpZXJcIlxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhdG9tXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmRvdEFsbCgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMuYXRvbUVzY2FwZSgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMuY2hhcmFjdGVyQ2xhc3MoKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmdyb3VwKClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0b20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpKSB7XG4gICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMucGF0dGVybkNoYXJhY3RlcigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFTU0VSVF9FWElTVFMoYXRvbSlcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNRdWFudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICBhdG9tLnF1YW50aWZpZXIgPSB0aGlzLnF1YW50aWZpZXIoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXRvbVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5kb3RBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIuXCIpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU2V0XCIsXG4gICAgICAgICAgICAgICAgY29tcGxlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogW2NjKFwiXFxuXCIpLCBjYyhcIlxcclwiKSwgY2MoXCJcXHUyMDI4XCIpLCBjYyhcIlxcdTIwMjlcIildXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmF0b21Fc2NhcGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJcXFxcXCIpXG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWxFc2NhcGVBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKClcbiAgICAgICAgICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmRlY2ltYWxFc2NhcGVBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBvc2l0aXZlSW50ZWdlcigpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiR3JvdXBCYWNrUmVmZXJlbmNlXCIsIHZhbHVlOiB2YWx1ZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNoYXJhY3RlckNsYXNzRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2V0XG4gICAgICAgICAgICB2YXIgY29tcGxlbWVudCA9IGZhbHNlXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gZGlnaXRzQ2hhckNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gZGlnaXRzQ2hhckNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gd2hpdGVzcGFjZUNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gd2hpdGVzcGFjZUNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0ID0gd29yZENoYXJDb2Rlc1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHdvcmRDaGFyQ29kZXNcbiAgICAgICAgICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhzZXQpXG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiU2V0XCIsIHZhbHVlOiBzZXQsIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jb250cm9sRXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVzY2FwZUNvZGVcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXGZcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHJcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHRcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHZcIilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFTU0VSVF9FWElTVFMoZXNjYXBlQ29kZSlcblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGVzY2FwZUNvZGUgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcImNcIilcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChsZXR0ZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxldHRlckNvZGUgPSBsZXR0ZXIudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gNjRcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBsZXR0ZXJDb2RlIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUubnVsQ2hhcmFjdGVyQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgJ1tsb29rYWhlYWQg4oiJIERlY2ltYWxEaWdpdF0nXG4gICAgICAgICAgICAvLyBUT0RPOiBmb3IgdGhlIGRlcHJlY2F0ZWQgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiMFwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGNjKFwiXFwwXCIpIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaGV4RXNjYXBlU2VxdWVuY2VBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwieFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIZXhEaWdpdHMoMilcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcInVcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGV4RGlnaXRzKDQpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlkZW50aXR5RXNjYXBlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IFwiU291cmNlQ2hhcmFjdGVyIGJ1dCBub3QgVW5pY29kZUlEQ29udGludWVcIlxuICAgICAgICAgICAgLy8gLy8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzMS8jU3BlY2lmaWNfQ2hhcmFjdGVyX0FkanVzdG1lbnRzXG4gICAgICAgICAgICB2YXIgZXNjYXBlZENoYXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGNjKGVzY2FwZWRDaGFyKSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRCRFwiKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhuZXh0Q2hhcikgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5jaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNldCA9IFtdXG4gICAgICAgICAgICB2YXIgY29tcGxlbWVudCA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiW1wiKVxuICAgICAgICAgICAgaWYgKHRoaXMucGVla0NoYXIoMCkgPT09IFwiXlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIl5cIilcbiAgICAgICAgICAgICAgICBjb21wbGVtZW50ID0gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0NsYXNzQXRvbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmNsYXNzQXRvbSgpXG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvbVNpbmdsZUNoYXIgPSBmcm9tLnR5cGUgPT09IFwiQ2hhcmFjdGVyXCJcbiAgICAgICAgICAgICAgICBpZiAoaXNGcm9tU2luZ2xlQ2hhciAmJiB0aGlzLmlzUmFuZ2VEYXNoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIi1cIilcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gdGhpcy5jbGFzc0F0b20oKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNUb1NpbmdsZUNoYXIgPSB0by50eXBlID09PSBcIkNoYXJhY3RlclwiXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYSByYW5nZSBjYW4gb25seSBiZSB1c2VkIHdoZW4gYm90aCBzaWRlcyBhcmUgc2luZ2xlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG9TaW5nbGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8udmFsdWUgPCBmcm9tLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaCh7IGZyb206IGZyb20udmFsdWUsIHRvOiB0by52YWx1ZSB9KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCBkYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUb1NldChmcm9tLnZhbHVlLCBzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChjYyhcIi1cIikpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUb1NldCh0by52YWx1ZSwgc2V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VG9TZXQoZnJvbS52YWx1ZSwgc2V0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIl1cIilcblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJTZXRcIiwgY29tcGxlbWVudDogY29tcGxlbWVudCwgdmFsdWU6IHNldCB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNsYXNzQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIilcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0VzY2FwZSgpXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NQYXR0ZXJuQ2hhcmFjdGVyQXRvbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNsYXNzRXNjYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIGEgYmFja3NwYWNlLlxuICAgICAgICAgICAgICAgIC8vIChOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCBcXGIgd29yZCBib3VuZGFyeSBvdXRzaWRlIGNoYXJhY3RlckNsYXNzKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJiXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhcIlxcdTAwMDhcIikgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDbGFzc0VzY2FwZSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sRXNjYXBlQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbExldHRlckVzY2FwZUF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bENoYXJhY3RlckF0b20oKVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhleEVzY2FwZVNlcXVlbmNlQXRvbSgpXG4gICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHlFc2NhcGVBdG9tKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJpbmcgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiKFwiKVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIjpcIilcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyaW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyb3VwSWR4KytcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGlzanVuY3Rpb24oKVxuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIilcIilcblxuICAgICAgICAgICAgdmFyIGdyb3VwQXN0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgICAgICAgICAgICBjYXB0dXJpbmc6IGNhcHR1cmluZyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhcHR1cmluZykge1xuICAgICAgICAgICAgICAgIGdyb3VwQXN0LmlkeCA9IHRoaXMuZ3JvdXBJZHhcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwQXN0XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBvc2l0aXZlSW50ZWdlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHRoaXMucG9wQ2hhcigpXG5cbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2FuJ3QgZXZlciBnZXQgaGVyZSBkdWUgdG8gcHJldmlvdXMgbG9va2FoZWFkIGNoZWNrc1xuICAgICAgICAgICAgLy8gc3RpbGwgaW1wbGVtZW50aW5nIHRoaXMgZXJyb3IgY2hlY2tpbmcgaW4gY2FzZSB0aGlzIGV2ZXIgY2hhbmdlcy5cbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGF0dGVybk5vWmVyby50ZXN0KG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChkZWNpbWFsUGF0dGVybi50ZXN0KHRoaXMucGVla0NoYXIoMCkpKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW1iZXIsIDEwKVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pbnRlZ2VySW5jbHVkaW5nWmVybyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhdHRlcm4udGVzdChudW1iZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGFuIGludGVnZXJcIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGRlY2ltYWxQYXR0ZXJuLnRlc3QodGhpcy5wZWVrQ2hhcigwKSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gdGhpcy5wb3BDaGFyKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHRoaXMucG9wQ2hhcigpXG4gICAgICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRCRFwiKVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhuZXh0Q2hhcikgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaXNSZWdFeHBGbGFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzUmFuZ2VEYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZWVrQ2hhcigpID09PSBcIi1cIiAmJiB0aGlzLmlzQ2xhc3NBdG9tKDEpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzRGlnaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGF0dGVybi50ZXN0KHRoaXMucGVla0NoYXIoMCkpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzQ2xhc3NBdG9tID0gZnVuY3Rpb24oaG93TXVjaCkge1xuICAgICAgICAgICAgaWYgKGhvd011Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvd011Y2ggPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcihob3dNdWNoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzVGVybSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBdG9tKCkgfHwgdGhpcy5pc0Fzc2VydGlvbigpXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmlzQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXR0ZXJuQ2hhcmFjdGVyKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoMCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IC8vIGF0b21Fc2NhcGVcbiAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOiAvLyBjaGFyYWN0ZXJDbGFzc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzQXRvbSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgaXNBc3NlcnRpb24gLSBkaXNhbWJpZ3VhdGVcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOiAvLyBncm91cFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc0Fzc2VydGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIC8vICdcXGInIG9yICdcXEInXG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICcoPz0nIG9yICcoPyEnXG4gICAgICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVla0NoYXIoMSkgPT09IFwiP1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5wZWVrQ2hhcigyKSA9PT0gXCI9XCIgfHwgdGhpcy5wZWVrQ2hhcigyKSA9PT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlZ0V4cFBhcnNlci5wcm90b3R5cGUuaXNRdWFudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gdGhpcy5zYXZlU3RhdGUoKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFudGlmaWVyKHRydWUpICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGUocHJldlN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgUmVnRXhwUGFyc2VyLnByb3RvdHlwZS5pc1BhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBhcnNlSGV4RGlnaXRzID0gZnVuY3Rpb24oaG93TWFueSkge1xuICAgICAgICAgICAgdmFyIGhleFN0cmluZyA9IFwiXCJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhleENoYXIgPSB0aGlzLnBvcENoYXIoKVxuICAgICAgICAgICAgICAgIGlmIChoZXhEaWdpdFBhdHRlcm4udGVzdChoZXhDaGFyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBIZXhEZWNpbWFsIGRpZ2l0c1wiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZXhTdHJpbmcgKz0gaGV4Q2hhclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoaGV4U3RyaW5nLCAxNilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjaGFyQ29kZSB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBlZWtDaGFyID0gZnVuY3Rpb24oaG93TXVjaCkge1xuICAgICAgICAgICAgaWYgKGhvd011Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvd011Y2ggPSAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFt0aGlzLmlkeCArIGhvd011Y2hdXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLnBvcENoYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHRoaXMucGVla0NoYXIoMClcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoKVxuICAgICAgICAgICAgcmV0dXJuIG5leHRDaGFyXG4gICAgICAgIH1cblxuICAgICAgICBSZWdFeHBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVDaGFyID0gZnVuY3Rpb24oY2hhcikge1xuICAgICAgICAgICAgaWYgKGNoYXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlucHV0W3RoaXMuaWR4XSAhPT0gY2hhcikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhciArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicgYnV0IGZvdW5kOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFt0aGlzLmlkeF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInIGF0IG9mZnNldDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pZHhcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlkeCA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWR4KytcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0cyBhbmQgdXRpbGl0aWVzXG4gICAgICAgIHZhciBoZXhEaWdpdFBhdHRlcm4gPSAvWzAtOWEtZkEtRl0vXG4gICAgICAgIHZhciBkZWNpbWFsUGF0dGVybiA9IC9bMC05XS9cbiAgICAgICAgdmFyIGRlY2ltYWxQYXR0ZXJuTm9aZXJvID0gL1sxLTldL1xuXG4gICAgICAgIGZ1bmN0aW9uIGNjKGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyLmNoYXJDb2RlQXQoMClcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluc2VydFRvU2V0KGl0ZW0sIHNldCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmZvckVhY2goZnVuY3Rpb24oc3ViSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChzdWJJdGVtKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldC5wdXNoKGl0ZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRGbGFnKGZsYWdPYmosIGZsYWdLZXkpIHtcbiAgICAgICAgICAgIGlmIChmbGFnT2JqW2ZsYWdLZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJkdXBsaWNhdGUgZmxhZyBcIiArIGZsYWdLZXlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxhZ09ialtmbGFnS2V5XSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEFTU0VSVF9FWElTVFMob2JqKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGZ1bmN0aW9uIEFTU0VSVF9ORVZFUl9SRUFDSF9IRVJFKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpXG4gICAgICAgIHZhciBkaWdpdHNDaGFyQ29kZXMgPSBbXVxuICAgICAgICBmb3IgKGkgPSBjYyhcIjBcIik7IGkgPD0gY2MoXCI5XCIpOyBpKyspIHtcbiAgICAgICAgICAgIGRpZ2l0c0NoYXJDb2Rlcy5wdXNoKGkpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29yZENoYXJDb2RlcyA9IFtjYyhcIl9cIildLmNvbmNhdChkaWdpdHNDaGFyQ29kZXMpXG4gICAgICAgIGZvciAoaSA9IGNjKFwiYVwiKTsgaSA8PSBjYyhcInpcIik7IGkrKykge1xuICAgICAgICAgICAgd29yZENoYXJDb2Rlcy5wdXNoKGkpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBjYyhcIkFcIik7IGkgPD0gY2MoXCJaXCIpOyBpKyspIHtcbiAgICAgICAgICAgIHdvcmRDaGFyQ29kZXMucHVzaChpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwI2NoYXJhY3Rlci1jbGFzc2VzXG4gICAgICAgIHZhciB3aGl0ZXNwYWNlQ29kZXMgPSBbXG4gICAgICAgICAgICBjYyhcIiBcIiksXG4gICAgICAgICAgICBjYyhcIlxcZlwiKSxcbiAgICAgICAgICAgIGNjKFwiXFxuXCIpLFxuICAgICAgICAgICAgY2MoXCJcXHJcIiksXG4gICAgICAgICAgICBjYyhcIlxcdFwiKSxcbiAgICAgICAgICAgIGNjKFwiXFx2XCIpLFxuICAgICAgICAgICAgY2MoXCJcXHRcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTAwYTBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTE2ODBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDFcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDJcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDNcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDRcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDVcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDdcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDhcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMDlcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMGFcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMjhcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMjlcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwMmZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTIwNWZcIiksXG4gICAgICAgICAgICBjYyhcIlxcdTMwMDBcIiksXG4gICAgICAgICAgICBjYyhcIlxcdWZlZmZcIilcbiAgICAgICAgXVxuXG4gICAgICAgIGZ1bmN0aW9uIEJhc2VSZWdFeHBWaXNpdG9yKCkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtrZXldXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24oc3ViQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KHN1YkNoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiRmxhZ3NcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEZsYWdzKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkRpc2p1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXREaXNqdW5jdGlvbihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBbHRlcm5hdGl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWx0ZXJuYXRpdmUobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiU3RhcnRBbmNob3JcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN0YXJ0QW5jaG9yKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkVuZEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RW5kQW5jaG9yKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0V29yZEJvdW5kYXJ5KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIk5vbldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0Tm9uV29yZEJvdW5kYXJ5KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIkxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TG9va2FoZWFkKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJDaGFyYWN0ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdENoYXJhY3Rlcihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFNldChub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0R3JvdXAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBCYWNrUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRHcm91cEJhY2tSZWZlcmVuY2Uobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUXVhbnRpZmllclwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UXVhbnRpZmllcihub2RlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSlcbiAgICAgICAgfVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBhdHRlcm4gPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZsYWdzID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIC8vIEFzc2VydGlvblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGFydEFuY2hvciA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRXb3JkQm91bmRhcnkgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vbldvcmRCb3VuZGFyeSA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TG9va2FoZWFkID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXROZWdhdGl2ZUxvb2thaGVhZCA9IGZ1bmN0aW9uKG5vZGUpIHt9XG5cbiAgICAgICAgLy8gYXRvbXNcbiAgICAgICAgQmFzZVJlZ0V4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRTZXQgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdEdyb3VwID0gZnVuY3Rpb24obm9kZSkge31cblxuICAgICAgICBCYXNlUmVnRXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRHcm91cEJhY2tSZWZlcmVuY2UgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1YW50aWZpZXIgPSBmdW5jdGlvbihub2RlKSB7fVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSZWdFeHBQYXJzZXI6IFJlZ0V4cFBhcnNlcixcbiAgICAgICAgICAgIEJhc2VSZWdFeHBWaXNpdG9yOiBCYXNlUmVnRXhwVmlzaXRvcixcbiAgICAgICAgICAgIFZFUlNJT046IFwiMC40LjBcIlxuICAgICAgICB9XG4gICAgfVxuKVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsYUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regexp-to-ast/lib/regexp-to-ast.js\n");

/***/ })

}]);