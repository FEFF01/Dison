(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[83],{

/***/ "./node_modules/meriyah/dist/meriyah.umd.js":
/*!**************************************************!*\
  !*** ./node_modules/meriyah/dist/meriyah.umd.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n  const errorMessages = {\r\n      [0]: 'Unexpected token',\r\n      [28]: \"Unexpected token: '%0'\",\r\n      [1]: 'Octal escape sequences are not allowed in strict mode',\r\n      [2]: 'Octal escape sequences are not allowed in template strings',\r\n      [3]: 'Unexpected token `#`',\r\n      [4]: 'Illegal Unicode escape sequence',\r\n      [5]: 'Invalid code point %0',\r\n      [6]: 'Invalid hexadecimal escape sequence',\r\n      [8]: 'Octal literals are not allowed in strict mode',\r\n      [7]: 'Decimal integer literals with a leading zero are forbidden in strict mode',\r\n      [9]: 'Expected number in radix %0',\r\n      [145]: 'Invalid left-hand side assignment to a destructible right-hand side',\r\n      [10]: 'Non-number found after exponent indicator',\r\n      [11]: 'Invalid BigIntLiteral',\r\n      [12]: 'No identifiers allowed directly after numeric literal',\r\n      [13]: 'Escapes \\\\8 or \\\\9 are not syntactically valid escapes',\r\n      [14]: 'Unterminated string literal',\r\n      [15]: 'Unterminated template literal',\r\n      [16]: 'Multiline comment was not closed properly',\r\n      [17]: 'The identifier contained dynamic unicode escape that was not closed',\r\n      [18]: \"Illegal character '%0'\",\r\n      [19]: 'Missing hexadecimal digits',\r\n      [20]: 'Invalid implicit octal',\r\n      [21]: 'Invalid line break in string literal',\r\n      [22]: 'Only unicode escapes are legal in identifier names',\r\n      [23]: \"Expected '%0'\",\r\n      [24]: 'Invalid left-hand side in assignment',\r\n      [25]: 'Invalid left-hand side in async arrow',\r\n      [26]: 'Calls to super must be in the \"constructor\" method of a class expression or class declaration that has a superclass',\r\n      [27]: 'Member access on super must be in a method',\r\n      [29]: 'Await expression not allowed in formal parameter',\r\n      [30]: 'Yield expression not allowed in formal parameter',\r\n      [92]: \"Unexpected token: 'escaped keyword'\",\r\n      [31]: 'Unary expressions as the left operand of an exponentation expression must be disambiguated with parentheses',\r\n      [119]: 'Async functions can only be declared at the top level or inside a block',\r\n      [32]: 'Unterminated regular expression',\r\n      [33]: 'Unexpected regular expression flag',\r\n      [34]: \"Duplicate regular expression flag '%0'\",\r\n      [35]: '%0 functions must have exactly %1 argument%2',\r\n      [36]: 'Setter function argument must not be a rest parameter',\r\n      [37]: '%0 declaration must have a name in this context',\r\n      [38]: 'Function name may not contain any reserved words or be eval or arguments in strict mode',\r\n      [39]: 'The rest operator is missing an argument',\r\n      [40]: 'A getter cannot be a generator',\r\n      [41]: 'A computed property name must be followed by a colon or paren',\r\n      [130]: 'Object literal keys that are strings or numbers must be a method or have a colon',\r\n      [43]: 'Found `* async x(){}` but this should be `async * x(){}`',\r\n      [42]: 'Getters and setters can not be generators',\r\n      [44]: \"'%0' can not be generator method\",\r\n      [45]: \"No line break is allowed after '=>'\",\r\n      [46]: 'The left-hand side of the arrow can only be destructed through assignment',\r\n      [47]: 'The binding declaration is not destructible',\r\n      [48]: 'Async arrow can not be followed by new expression',\r\n      [49]: \"Classes may not have a static property named 'prototype'\",\r\n      [50]: 'Class constructor may not be a %0',\r\n      [51]: 'Duplicate constructor method in class',\r\n      [52]: 'Invalid increment/decrement operand',\r\n      [53]: 'Invalid use of `new` keyword on an increment/decrement expression',\r\n      [54]: '`=>` is an invalid assignment target',\r\n      [55]: 'Rest element may not have a trailing comma',\r\n      [56]: 'Missing initializer in %0 declaration',\r\n      [57]: \"'for-%0' loop head declarations can not have an initializer\",\r\n      [58]: 'Invalid left-hand side in for-%0 loop: Must have a single binding',\r\n      [59]: 'Invalid shorthand property initializer',\r\n      [60]: 'Property name __proto__ appears more than once in object literal',\r\n      [61]: 'Let is disallowed as a lexically bound name',\r\n      [62]: \"Invalid use of '%0' inside new expression\",\r\n      [63]: \"Illegal 'use strict' directive in function with non-simple parameter list\",\r\n      [64]: 'Identifier \"let\" disallowed as left-hand side expression in strict mode',\r\n      [65]: 'Illegal continue statement',\r\n      [66]: 'Illegal break statement',\r\n      [67]: 'Cannot have `let[...]` as a var name in strict mode',\r\n      [68]: 'Invalid destructuring assignment target',\r\n      [69]: 'Rest parameter may not have a default initializer',\r\n      [70]: 'The rest argument must the be last parameter',\r\n      [71]: 'Invalid rest argument',\r\n      [73]: 'In strict mode code, functions can only be declared at top level or inside a block',\r\n      [74]: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement',\r\n      [75]: 'Without web compability enabled functions can not be declared at top level, inside a block, or as the body of an if statement',\r\n      [76]: \"Class declaration can't appear in single-statement context\",\r\n      [77]: 'Invalid left-hand side in for-%0',\r\n      [78]: 'Invalid assignment in for-%0',\r\n      [79]: 'for await (... of ...) is only valid in async functions and async generators',\r\n      [80]: 'The first token after the template expression should be a continuation of the template',\r\n      [82]: '`let` declaration not allowed here and `let` cannot be a regular var name in strict mode',\r\n      [81]: '`let \\n [` is a restricted production at the start of a statement',\r\n      [83]: 'Catch clause requires exactly one parameter, not more (and no trailing comma)',\r\n      [84]: 'Catch clause parameter does not support default values',\r\n      [85]: 'Missing catch or finally after try',\r\n      [86]: 'More than one default clause in switch statement',\r\n      [87]: 'Illegal newline after throw',\r\n      [88]: 'Strict mode code may not include a with statement',\r\n      [89]: 'Illegal return statement',\r\n      [90]: 'The left hand side of the for-header binding declaration is not destructible',\r\n      [91]: 'new.target only allowed within functions',\r\n      [92]: \"'Unexpected token: 'escaped keyword'\",\r\n      [93]: \"'#' not followed by identifier\",\r\n      [99]: 'Invalid keyword',\r\n      [98]: \"Can not use 'let' as a class name\",\r\n      [97]: \"'A lexical declaration can't define a 'let' binding\",\r\n      [96]: 'Can not use `let` as variable name in strict mode',\r\n      [94]: \"'%0' may not be used as an identifier in this context\",\r\n      [95]: 'Await is only valid in async functions',\r\n      [100]: 'The %0 keyword can only be used with the module goal',\r\n      [101]: 'Unicode codepoint must not be greater than 0x10FFFF',\r\n      [102]: '%0 source must be string',\r\n      [103]: 'Only a identifier can be used to indicate alias',\r\n      [104]: \"Only '*' or '{...}' can be imported after default\",\r\n      [105]: 'Trailing decorator may be followed by method',\r\n      [106]: \"Decorators can't be used with a constructor\",\r\n      [107]: \"'%0' may not be used as an identifier in this context\",\r\n      [108]: 'HTML comments are only allowed with web compability (Annex B)',\r\n      [109]: \"The identifier 'let' must not be in expression position in strict mode\",\r\n      [110]: 'Cannot assign to `eval` and `arguments` in strict mode',\r\n      [111]: \"The left-hand side of a for-of loop may not start with 'let'\",\r\n      [112]: 'Block body arrows can not be immediately invoked without a group',\r\n      [113]: 'Block body arrows can not be immediately accessed without a group',\r\n      [114]: 'Unexpected strict mode reserved word',\r\n      [115]: 'Unexpected eval or arguments in strict mode',\r\n      [116]: 'Decorators must not be followed by a semicolon',\r\n      [117]: 'Calling delete on expression not allowed in strict mode',\r\n      [118]: 'Pattern can not have a tail',\r\n      [120]: 'Can not have a `yield` expression on the left side of a ternary',\r\n      [121]: 'An arrow function can not have a postfix update operator',\r\n      [122]: 'Invalid object literal key character after generator star',\r\n      [123]: 'Private fields can not be deleted',\r\n      [125]: 'Classes may not have a field called constructor',\r\n      [124]: 'Classes may not have a private element named constructor',\r\n      [126]: 'A class field initializer may not contain arguments',\r\n      [127]: 'Generators can only be declared at the top level or inside a block',\r\n      [128]: 'Async methods are a restricted production and cannot have a newline following it',\r\n      [129]: 'Unexpected character after object literal property name',\r\n      [131]: 'Invalid key token',\r\n      [132]: \"Label '%0' has already been declared\",\r\n      [133]: 'continue statement must be nested within an iteration statement',\r\n      [134]: \"Undefined label '%0'\",\r\n      [135]: 'Trailing comma is disallowed inside import(...) arguments',\r\n      [136]: 'import() requires exactly one argument',\r\n      [137]: 'Cannot use new with import(...)',\r\n      [138]: '... is not allowed in import()',\r\n      [139]: \"Expected '=>'\",\r\n      [140]: \"Duplicate binding '%0'\",\r\n      [141]: \"Cannot export a duplicate name '%0'\",\r\n      [144]: 'Duplicate %0 for-binding',\r\n      [142]: \"Exported binding '%0' needs to refer to a top-level declared variable\",\r\n      [143]: 'Unexpected private field',\r\n      [147]: 'Numeric separators are not allowed at the end of numeric literals',\r\n      [146]: 'Only one underscore is allowed as numeric separator',\r\n      [148]: 'JSX value should be either an expression or a quoted JSX text',\r\n      [149]: 'Expected corresponding JSX closing tag for %0',\r\n      [150]: 'Adjacent JSX elements must be wrapped in an enclosing tag',\r\n      [151]: \"JSX attributes must only be assigned a non-empty 'expression'\",\r\n      [152]: \"'%0' has already been declared\",\r\n      [153]: \"'%0' shadowed a catch clause binding\",\r\n      [154]: 'Dot property must be an identifier',\r\n      [155]: 'Encountered invalid input after spread/rest argument',\r\n      [156]: 'Catch without try',\r\n      [157]: 'Finally without try',\r\n      [158]: 'Expected corresponding closing tag for JSX fragment',\r\n      [159]: 'Coalescing and logical operators used together in the same expression must be disambiguated with parentheses',\r\n      [160]: 'Invalid tagged template on optional chain',\r\n      [161]: 'Invalid optional chain from super property',\r\n      [162]: 'Invalid optional chain from new expression',\r\n      [163]: 'Cannot use \"import.meta\" outside a module'\r\n  };\r\n  class ParseError extends SyntaxError {\r\n      constructor(startindex, line, column, type, ...params) {\r\n          const message = '[' + line + ':' + column + ']: ' + errorMessages[type].replace(/%(\\d+)/g, (_, i) => params[i]);\r\n          super(`${message}`);\r\n          this.index = startindex;\r\n          this.line = line;\r\n          this.column = column;\r\n          this.description = message;\r\n          this.loc = {\r\n              line,\r\n              column\r\n          };\r\n      }\r\n  }\r\n  function report(parser, type, ...params) {\r\n      throw new ParseError(parser.index, parser.line, parser.column, type, ...params);\r\n  }\r\n  function reportScopeError(scope) {\r\n      throw new ParseError(scope.index, scope.line, scope.column, scope.type, scope.params);\r\n  }\r\n  function reportMessageAt(index, line, column, type, ...params) {\r\n      throw new ParseError(index, line, column, type, ...params);\r\n  }\r\n  function reportScannerError(index, line, column, type) {\r\n      throw new ParseError(index, line, column, type);\r\n  }\n\n  const unicodeLookup = ((compressed, lookup) => {\r\n      const result = new Uint32Array(104448);\r\n      let index = 0;\r\n      let subIndex = 0;\r\n      while (index < 3540) {\r\n          const inst = compressed[index++];\r\n          if (inst < 0) {\r\n              subIndex -= inst;\r\n          }\r\n          else {\r\n              let code = compressed[index++];\r\n              if (inst & 2)\r\n                  code = lookup[code];\r\n              if (inst & 1) {\r\n                  result.fill(code, subIndex, subIndex += compressed[index++]);\r\n              }\r\n              else {\r\n                  result[subIndex++] = code;\r\n              }\r\n          }\r\n      }\r\n      return result;\r\n  })([-1, 2, 24, 2, 25, 2, 5, -1, 0, 77595648, 3, 44, 2, 3, 0, 14, 2, 57, 2, 58, 3, 0, 3, 0, 3168796671, 0, 4294956992, 2, 1, 2, 0, 2, 59, 3, 0, 4, 0, 4294966523, 3, 0, 4, 2, 16, 2, 60, 2, 0, 0, 4294836735, 0, 3221225471, 0, 4294901942, 2, 61, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0, 2683305983, 0, 2684354047, 2, 17, 2, 0, 0, 4294961151, 3, 0, 2, 2, 19, 2, 0, 0, 608174079, 2, 0, 2, 131, 2, 6, 2, 56, -1, 2, 37, 0, 4294443263, 2, 1, 3, 0, 3, 0, 4294901711, 2, 39, 0, 4089839103, 0, 2961209759, 0, 1342439375, 0, 4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2, 2, 0, 80831, 0, 4261478351, 0, 4294549486, 2, 2, 0, 2967484831, 0, 196559, 0, 3594373100, 0, 3288319768, 0, 8469959, 2, 194, 2, 3, 0, 3825204735, 0, 123747807, 0, 65487, 0, 4294828015, 0, 4092591615, 0, 1080049119, 0, 458703, 2, 3, 2, 0, 0, 2163244511, 0, 4227923919, 0, 4236247022, 2, 66, 0, 4284449919, 0, 851904, 2, 4, 2, 11, 0, 67076095, -1, 2, 67, 0, 1073741743, 0, 4093591391, -1, 0, 50331649, 0, 3265266687, 2, 32, 0, 4294844415, 0, 4278190047, 2, 18, 2, 129, -1, 3, 0, 2, 2, 21, 2, 0, 2, 9, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 69, 2, 0, 2, 70, 2, 71, 2, 72, 2, 0, 2, 73, 2, 0, 2, 10, 0, 261632, 2, 23, 3, 0, 2, 2, 12, 2, 4, 3, 0, 18, 2, 74, 2, 5, 3, 0, 2, 2, 75, 0, 2088959, 2, 27, 2, 8, 0, 909311, 3, 0, 2, 0, 814743551, 2, 41, 0, 67057664, 3, 0, 2, 2, 40, 2, 0, 2, 28, 2, 0, 2, 29, 2, 7, 0, 268374015, 2, 26, 2, 49, 2, 0, 2, 76, 0, 134153215, -1, 2, 6, 2, 0, 2, 7, 0, 2684354559, 0, 67044351, 0, 3221160064, 0, 1, -1, 3, 0, 2, 2, 42, 0, 1046528, 3, 0, 3, 2, 8, 2, 0, 2, 51, 0, 4294960127, 2, 9, 2, 38, 2, 10, 0, 4294377472, 2, 11, 3, 0, 7, 0, 4227858431, 3, 0, 8, 2, 12, 2, 0, 2, 78, 2, 9, 2, 0, 2, 79, 2, 80, 2, 81, -1, 2, 124, 0, 1048577, 2, 82, 2, 13, -1, 2, 13, 0, 131042, 2, 83, 2, 84, 2, 85, 2, 0, 2, 33, -83, 2, 0, 2, 53, 2, 7, 3, 0, 4, 0, 1046559, 2, 0, 2, 14, 2, 0, 0, 2147516671, 2, 20, 3, 86, 2, 2, 0, -16, 2, 87, 0, 524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 2, 0, 2, 15, 2, 77, 2, 16, 3, 0, 2, 2, 47, 2, 0, -1, 2, 17, -16, 3, 0, 206, -2, 3, 0, 655, 2, 18, 3, 0, 36, 2, 68, -1, 2, 17, 2, 9, 3, 0, 8, 2, 89, 2, 121, 2, 0, 0, 3220242431, 3, 0, 3, 2, 19, 2, 90, 2, 91, 3, 0, 2, 2, 92, 2, 0, 2, 93, 2, 94, 2, 0, 0, 4351, 2, 0, 2, 8, 3, 0, 2, 0, 67043391, 0, 3909091327, 2, 0, 2, 22, 2, 8, 2, 18, 3, 0, 2, 0, 67076097, 2, 7, 2, 0, 2, 20, 0, 67059711, 0, 4236247039, 3, 0, 2, 0, 939524103, 0, 8191999, 2, 97, 2, 98, 2, 15, 2, 21, 3, 0, 3, 0, 67057663, 3, 0, 349, 2, 99, 2, 100, 2, 6, -264, 3, 0, 11, 2, 22, 3, 0, 2, 2, 31, -1, 0, 3774349439, 2, 101, 2, 102, 3, 0, 2, 2, 19, 2, 103, 3, 0, 10, 2, 9, 2, 17, 2, 0, 2, 45, 2, 0, 2, 30, 2, 104, 2, 23, 0, 1638399, 2, 172, 2, 105, 3, 0, 3, 2, 18, 2, 24, 2, 25, 2, 5, 2, 26, 2, 0, 2, 7, 2, 106, -1, 2, 107, 2, 108, 2, 109, -1, 3, 0, 3, 2, 11, -2, 2, 0, 2, 27, -3, 2, 150, -4, 2, 18, 2, 0, 2, 35, 0, 1, 2, 0, 2, 62, 2, 28, 2, 11, 2, 9, 2, 0, 2, 110, -1, 3, 0, 4, 2, 9, 2, 21, 2, 111, 2, 6, 2, 0, 2, 112, 2, 0, 2, 48, -4, 3, 0, 9, 2, 20, 2, 29, 2, 30, -4, 2, 113, 2, 114, 2, 29, 2, 20, 2, 7, -2, 2, 115, 2, 29, 2, 31, -2, 2, 0, 2, 116, -2, 0, 4277137519, 0, 2269118463, -1, 3, 18, 2, -1, 2, 32, 2, 36, 2, 0, 3, 29, 2, 2, 34, 2, 19, -3, 3, 0, 2, 2, 33, -1, 2, 0, 2, 34, 2, 0, 2, 34, 2, 0, 2, 46, -10, 2, 0, 0, 203775, -2, 2, 18, 2, 43, 2, 35, -2, 2, 17, 2, 117, 2, 20, 3, 0, 2, 2, 36, 0, 2147549120, 2, 0, 2, 11, 2, 17, 2, 135, 2, 0, 2, 37, 2, 52, 0, 5242879, 3, 0, 2, 0, 402644511, -1, 2, 120, 0, 1090519039, -2, 2, 122, 2, 38, 2, 0, 0, 67045375, 2, 39, 0, 4226678271, 0, 3766565279, 0, 2039759, -4, 3, 0, 2, 0, 3288270847, 0, 3, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0, 1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 40, 2, 41, -1, 2, 10, 2, 42, -6, 2, 0, 2, 11, -3, 3, 0, 2, 0, 2147484671, 2, 125, 0, 4190109695, 2, 50, -2, 2, 126, 0, 4244635647, 0, 27, 2, 0, 2, 7, 2, 43, 2, 0, 2, 63, -1, 2, 0, 2, 40, -8, 2, 54, 2, 44, 0, 67043329, 2, 127, 2, 45, 0, 8388351, -2, 2, 128, 0, 3028287487, 2, 46, 2, 130, 0, 33259519, 2, 41, -9, 2, 20, -5, 2, 64, -2, 3, 0, 28, 2, 31, -3, 3, 0, 3, 2, 47, 3, 0, 6, 2, 48, -85, 3, 0, 33, 2, 47, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 40, 2, 7, 2, 41, -2, 2, 17, 2, 49, 2, 0, 2, 20, 2, 50, 2, 132, 2, 23, -21, 3, 0, 2, -4, 3, 0, 2, 0, 4294936575, 2, 0, 0, 4294934783, -2, 0, 196635, 3, 0, 191, 2, 51, 3, 0, 38, 2, 29, -1, 2, 33, -279, 3, 0, 8, 2, 7, -1, 2, 133, 2, 52, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 134, 0, 1677656575, -166, 0, 4161266656, 0, 4071, 0, 15360, -4, 0, 28, -13, 3, 0, 2, 2, 37, 2, 0, 2, 136, 2, 137, 2, 55, 2, 0, 2, 138, 2, 139, 2, 140, 3, 0, 10, 2, 141, 2, 142, 2, 15, 3, 37, 2, 3, 53, 2, 3, 54, 2, 0, 4294954999, 2, 0, -16, 2, 0, 2, 88, 2, 0, 0, 2105343, 0, 4160749584, 0, 65534, -42, 0, 4194303871, 0, 2011, -6, 2, 0, 0, 1073684479, 0, 17407, -11, 2, 0, 2, 31, -40, 3, 0, 6, 0, 8323103, -1, 3, 0, 2, 2, 42, -37, 2, 55, 2, 144, 2, 145, 2, 146, 2, 147, 2, 148, -105, 2, 24, -32, 3, 0, 1334, 2, 9, -1, 3, 0, 129, 2, 27, 3, 0, 6, 2, 9, 3, 0, 180, 2, 149, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 9, -47, 3, 0, 154, 2, 56, -22381, 3, 0, 7, 2, 23, -6130, 3, 5, 2, -1, 0, 69207040, 3, 44, 2, 3, 0, 14, 2, 57, 2, 58, -3, 0, 3168731136, 0, 4294956864, 2, 1, 2, 0, 2, 59, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 16, 2, 60, 2, 0, 2, 33, -1, 2, 17, 2, 61, -1, 2, 0, 2, 56, 0, 4294885376, 3, 0, 2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2, 23, 2, 62, 3, 0, 2, 0, 131135, 2, 95, 0, 70256639, 0, 71303167, 0, 272, 2, 40, 2, 56, -1, 2, 37, 2, 30, -1, 2, 96, 2, 63, 0, 4278255616, 0, 4294836227, 0, 4294549473, 0, 600178175, 0, 2952806400, 0, 268632067, 0, 4294543328, 0, 57540095, 0, 1577058304, 0, 1835008, 0, 4294688736, 2, 65, 2, 64, 0, 33554435, 2, 123, 2, 65, 2, 151, 0, 131075, 0, 3594373096, 0, 67094296, 2, 64, -1, 0, 4294828000, 0, 603979263, 2, 160, 0, 3, 0, 4294828001, 0, 602930687, 2, 183, 0, 393219, 0, 4294828016, 0, 671088639, 0, 2154840064, 0, 4227858435, 0, 4236247008, 2, 66, 2, 36, -1, 2, 4, 0, 917503, 2, 36, -1, 2, 67, 0, 537788335, 0, 4026531935, -1, 0, 1, -1, 2, 32, 2, 68, 0, 7936, -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 69, 2, 0, 2, 70, 2, 71, 2, 72, 2, 0, 2, 73, 2, 0, 2, 11, -1, 2, 23, 3, 0, 2, 2, 12, 2, 4, 3, 0, 18, 2, 74, 2, 5, 3, 0, 2, 2, 75, 0, 253951, 3, 19, 2, 0, 122879, 2, 0, 2, 8, 0, 276824064, -2, 3, 0, 2, 2, 40, 2, 0, 0, 4294903295, 2, 0, 2, 29, 2, 7, -1, 2, 17, 2, 49, 2, 0, 2, 76, 2, 41, -1, 2, 20, 2, 0, 2, 27, -2, 0, 128, -2, 2, 77, 2, 8, 0, 4064, -1, 2, 119, 0, 4227907585, 2, 0, 2, 118, 2, 0, 2, 48, 2, 173, 2, 9, 2, 38, 2, 10, -1, 0, 74440192, 3, 0, 6, -2, 3, 0, 8, 2, 12, 2, 0, 2, 78, 2, 9, 2, 0, 2, 79, 2, 80, 2, 81, -3, 2, 82, 2, 13, -3, 2, 83, 2, 84, 2, 85, 2, 0, 2, 33, -83, 2, 0, 2, 53, 2, 7, 3, 0, 4, 0, 817183, 2, 0, 2, 14, 2, 0, 0, 33023, 2, 20, 3, 86, 2, -17, 2, 87, 0, 524157950, 2, 4, 2, 0, 2, 88, 2, 4, 2, 0, 2, 15, 2, 77, 2, 16, 3, 0, 2, 2, 47, 2, 0, -1, 2, 17, -16, 3, 0, 206, -2, 3, 0, 655, 2, 18, 3, 0, 36, 2, 68, -1, 2, 17, 2, 9, 3, 0, 8, 2, 89, 0, 3072, 2, 0, 0, 2147516415, 2, 9, 3, 0, 2, 2, 23, 2, 90, 2, 91, 3, 0, 2, 2, 92, 2, 0, 2, 93, 2, 94, 0, 4294965179, 0, 7, 2, 0, 2, 8, 2, 91, 2, 8, -1, 0, 1761345536, 2, 95, 0, 4294901823, 2, 36, 2, 18, 2, 96, 2, 34, 2, 166, 0, 2080440287, 2, 0, 2, 33, 2, 143, 0, 3296722943, 2, 0, 0, 1046675455, 0, 939524101, 0, 1837055, 2, 97, 2, 98, 2, 15, 2, 21, 3, 0, 3, 0, 7, 3, 0, 349, 2, 99, 2, 100, 2, 6, -264, 3, 0, 11, 2, 22, 3, 0, 2, 2, 31, -1, 0, 2700607615, 2, 101, 2, 102, 3, 0, 2, 2, 19, 2, 103, 3, 0, 10, 2, 9, 2, 17, 2, 0, 2, 45, 2, 0, 2, 30, 2, 104, -3, 2, 105, 3, 0, 3, 2, 18, -1, 3, 5, 2, 2, 26, 2, 0, 2, 7, 2, 106, -1, 2, 107, 2, 108, 2, 109, -1, 3, 0, 3, 2, 11, -2, 2, 0, 2, 27, -8, 2, 18, 2, 0, 2, 35, -1, 2, 0, 2, 62, 2, 28, 2, 29, 2, 9, 2, 0, 2, 110, -1, 3, 0, 4, 2, 9, 2, 17, 2, 111, 2, 6, 2, 0, 2, 112, 2, 0, 2, 48, -4, 3, 0, 9, 2, 20, 2, 29, 2, 30, -4, 2, 113, 2, 114, 2, 29, 2, 20, 2, 7, -2, 2, 115, 2, 29, 2, 31, -2, 2, 0, 2, 116, -2, 0, 4277075969, 2, 29, -1, 3, 18, 2, -1, 2, 32, 2, 117, 2, 0, 3, 29, 2, 2, 34, 2, 19, -3, 3, 0, 2, 2, 33, -1, 2, 0, 2, 34, 2, 0, 2, 34, 2, 0, 2, 48, -10, 2, 0, 0, 197631, -2, 2, 18, 2, 43, 2, 118, -2, 2, 17, 2, 117, 2, 20, 2, 119, 2, 51, -2, 2, 119, 2, 23, 2, 17, 2, 33, 2, 119, 2, 36, 0, 4294901904, 0, 4718591, 2, 119, 2, 34, 0, 335544350, -1, 2, 120, 2, 121, -2, 2, 122, 2, 38, 2, 7, -1, 2, 123, 2, 65, 0, 3758161920, 0, 3, -4, 2, 0, 2, 27, 0, 2147485568, 0, 3, 2, 0, 2, 23, 0, 176, -5, 2, 0, 2, 47, 2, 186, -1, 2, 0, 2, 23, 2, 197, -1, 2, 0, 0, 16779263, -2, 2, 11, -7, 2, 0, 2, 121, -3, 3, 0, 2, 2, 124, 2, 125, 0, 2147549183, 0, 2, -2, 2, 126, 2, 35, 0, 10, 0, 4294965249, 0, 67633151, 0, 4026597376, 2, 0, 0, 536871935, -1, 2, 0, 2, 40, -8, 2, 54, 2, 47, 0, 1, 2, 127, 2, 23, -3, 2, 128, 2, 35, 2, 129, 2, 130, 0, 16778239, -10, 2, 34, -5, 2, 64, -2, 3, 0, 28, 2, 31, -3, 3, 0, 3, 2, 47, 3, 0, 6, 2, 48, -85, 3, 0, 33, 2, 47, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 40, 2, 7, -3, 2, 17, 2, 131, 2, 0, 2, 23, 2, 48, 2, 132, 2, 23, -21, 3, 0, 2, -4, 3, 0, 2, 0, 67583, -1, 2, 103, -2, 0, 11, 3, 0, 191, 2, 51, 3, 0, 38, 2, 29, -1, 2, 33, -279, 3, 0, 8, 2, 7, -1, 2, 133, 2, 52, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 134, 2, 135, -187, 3, 0, 2, 2, 37, 2, 0, 2, 136, 2, 137, 2, 55, 2, 0, 2, 138, 2, 139, 2, 140, 3, 0, 10, 2, 141, 2, 142, 2, 15, 3, 37, 2, 3, 53, 2, 3, 54, 2, 2, 143, -73, 2, 0, 0, 1065361407, 0, 16384, -11, 2, 0, 2, 121, -40, 3, 0, 6, 2, 117, -1, 3, 0, 2, 0, 2063, -37, 2, 55, 2, 144, 2, 145, 2, 146, 2, 147, 2, 148, -138, 3, 0, 1334, 2, 9, -1, 3, 0, 129, 2, 27, 3, 0, 6, 2, 9, 3, 0, 180, 2, 149, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 9, -47, 3, 0, 154, 2, 56, -28517, 2, 0, 0, 1, -1, 2, 124, 2, 0, 0, 8193, -21, 2, 193, 0, 10255, 0, 4, -11, 2, 64, 2, 171, -1, 0, 71680, -1, 2, 161, 0, 4292900864, 0, 805306431, -5, 2, 150, -1, 2, 157, -1, 0, 6144, -2, 2, 127, -1, 2, 154, -1, 0, 2147532800, 2, 151, 2, 165, 2, 0, 2, 164, 0, 524032, 0, 4, -4, 2, 190, 0, 205128192, 0, 1333757536, 0, 2147483696, 0, 423953, 0, 747766272, 0, 2717763192, 0, 4286578751, 0, 278545, 2, 152, 0, 4294886464, 0, 33292336, 0, 417809, 2, 152, 0, 1327482464, 0, 4278190128, 0, 700594195, 0, 1006647527, 0, 4286497336, 0, 4160749631, 2, 153, 0, 469762560, 0, 4171219488, 0, 8323120, 2, 153, 0, 202375680, 0, 3214918176, 0, 4294508592, 2, 153, -1, 0, 983584, 0, 48, 0, 58720273, 0, 3489923072, 0, 10517376, 0, 4293066815, 0, 1, 0, 2013265920, 2, 177, 2, 0, 0, 2089, 0, 3221225552, 0, 201375904, 2, 0, -2, 0, 256, 0, 122880, 0, 16777216, 2, 150, 0, 4160757760, 2, 0, -6, 2, 167, -11, 0, 3263218176, -1, 0, 49664, 0, 2160197632, 0, 8388802, -1, 0, 12713984, -1, 2, 154, 2, 159, 2, 178, -2, 2, 162, -20, 0, 3758096385, -2, 2, 155, 0, 4292878336, 2, 90, 2, 169, 0, 4294057984, -2, 2, 163, 2, 156, 2, 175, -2, 2, 155, -1, 2, 182, -1, 2, 170, 2, 124, 0, 4026593280, 0, 14, 0, 4292919296, -1, 2, 158, 0, 939588608, -1, 0, 805306368, -1, 2, 124, 0, 1610612736, 2, 156, 2, 157, 2, 4, 2, 0, -2, 2, 158, 2, 159, -3, 0, 267386880, -1, 2, 160, 0, 7168, -1, 0, 65024, 2, 154, 2, 161, 2, 179, -7, 2, 168, -8, 2, 162, -1, 0, 1426112704, 2, 163, -1, 2, 164, 0, 271581216, 0, 2149777408, 2, 23, 2, 161, 2, 124, 0, 851967, 2, 180, -1, 2, 23, 2, 181, -4, 2, 158, -20, 2, 195, 2, 165, -56, 0, 3145728, 2, 185, -4, 2, 166, 2, 124, -4, 0, 32505856, -1, 2, 167, -1, 0, 2147385088, 2, 90, 1, 2155905152, 2, -3, 2, 103, 2, 0, 2, 168, -2, 2, 169, -6, 2, 170, 0, 4026597375, 0, 1, -1, 0, 1, -1, 2, 171, -3, 2, 117, 2, 64, -2, 2, 166, -2, 2, 176, 2, 124, -878, 2, 159, -36, 2, 172, -1, 2, 201, -10, 2, 188, -5, 2, 174, -6, 0, 4294965251, 2, 27, -1, 2, 173, -1, 2, 174, -2, 0, 4227874752, -3, 0, 2146435072, 2, 159, -2, 0, 1006649344, 2, 124, -1, 2, 90, 0, 201375744, -3, 0, 134217720, 2, 90, 0, 4286677377, 0, 32896, -1, 2, 158, -3, 2, 175, -349, 2, 176, 0, 1920, 2, 177, 3, 0, 264, -11, 2, 157, -2, 2, 178, 2, 0, 0, 520617856, 0, 2692743168, 0, 36, -3, 0, 524284, -11, 2, 23, -1, 2, 187, -1, 2, 184, 0, 3221291007, 2, 178, -1, 2, 202, 0, 2158720, -3, 2, 159, 0, 1, -4, 2, 124, 0, 3808625411, 0, 3489628288, 2, 200, 0, 1207959680, 0, 3221274624, 2, 0, -3, 2, 179, 0, 120, 0, 7340032, -2, 2, 180, 2, 4, 2, 23, 2, 163, 3, 0, 4, 2, 159, -1, 2, 181, 2, 177, -1, 0, 8176, 2, 182, 2, 179, 2, 183, -1, 0, 4290773232, 2, 0, -4, 2, 163, 2, 189, 0, 15728640, 2, 177, -1, 2, 161, -1, 0, 4294934512, 3, 0, 4, -9, 2, 90, 2, 170, 2, 184, 3, 0, 4, 0, 704, 0, 1849688064, 2, 185, -1, 2, 124, 0, 4294901887, 2, 0, 0, 130547712, 0, 1879048192, 2, 199, 3, 0, 2, -1, 2, 186, 2, 187, -1, 0, 17829776, 0, 2025848832, 0, 4261477888, -2, 2, 0, -1, 0, 4286580608, -1, 0, 29360128, 2, 192, 0, 16252928, 0, 3791388672, 2, 38, 3, 0, 2, -2, 2, 196, 2, 0, -1, 2, 103, -1, 0, 66584576, -1, 2, 191, 3, 0, 9, 2, 124, -1, 0, 4294755328, 3, 0, 2, -1, 2, 161, 2, 178, 3, 0, 2, 2, 23, 2, 188, 2, 90, -2, 0, 245760, 0, 2147418112, -1, 2, 150, 2, 203, 0, 4227923456, -1, 2, 164, 2, 161, 2, 90, -3, 0, 4292870145, 0, 262144, 2, 124, 3, 0, 2, 0, 1073758848, 2, 189, -1, 0, 4227921920, 2, 190, 0, 68289024, 0, 528402016, 0, 4292927536, 3, 0, 4, -2, 0, 268435456, 2, 91, -2, 2, 191, 3, 0, 5, -1, 2, 192, 2, 163, 2, 0, -2, 0, 4227923936, 2, 62, -1, 2, 155, 2, 95, 2, 0, 2, 154, 2, 158, 3, 0, 6, -1, 2, 177, 3, 0, 3, -2, 0, 2146959360, 0, 9440640, 0, 104857600, 0, 4227923840, 3, 0, 2, 0, 768, 2, 193, 2, 77, -2, 2, 161, -2, 2, 119, -1, 2, 155, 3, 0, 8, 0, 512, 0, 8388608, 2, 194, 2, 172, 2, 187, 0, 4286578944, 3, 0, 2, 0, 1152, 0, 1266679808, 2, 191, 0, 576, 0, 4261707776, 2, 95, 3, 0, 9, 2, 155, 3, 0, 5, 2, 16, -1, 0, 2147221504, -28, 2, 178, 3, 0, 3, -3, 0, 4292902912, -6, 2, 96, 3, 0, 85, -33, 0, 4294934528, 3, 0, 126, -18, 2, 195, 3, 0, 269, -17, 2, 155, 2, 124, 2, 198, 3, 0, 2, 2, 23, 0, 4290822144, -2, 0, 67174336, 0, 520093700, 2, 17, 3, 0, 21, -2, 2, 179, 3, 0, 3, -2, 0, 30720, -1, 0, 32512, 3, 0, 2, 0, 4294770656, -191, 2, 174, -38, 2, 170, 2, 0, 2, 196, 3, 0, 279, -8, 2, 124, 2, 0, 0, 4294508543, 0, 65295, -11, 2, 177, 3, 0, 72, -3, 0, 3758159872, 0, 201391616, 3, 0, 155, -7, 2, 170, -1, 0, 384, -1, 0, 133693440, -3, 2, 196, -2, 2, 26, 3, 0, 4, 2, 169, -2, 2, 90, 2, 155, 3, 0, 4, -2, 2, 164, -1, 2, 150, 0, 335552923, 2, 197, -1, 0, 538974272, 0, 2214592512, 0, 132000, -10, 0, 192, -8, 0, 12288, -21, 0, 134213632, 0, 4294901761, 3, 0, 42, 0, 100663424, 0, 4294965284, 3, 0, 6, -1, 0, 3221282816, 2, 198, 3, 0, 11, -1, 2, 199, 3, 0, 40, -6, 0, 4286578784, 2, 0, -2, 0, 1006694400, 3, 0, 24, 2, 35, -1, 2, 94, 3, 0, 2, 0, 1, 2, 163, 3, 0, 6, 2, 197, 0, 4110942569, 0, 1432950139, 0, 2701658217, 0, 4026532864, 0, 4026532881, 2, 0, 2, 45, 3, 0, 8, -1, 2, 158, -2, 2, 169, 0, 98304, 0, 65537, 2, 170, -5, 0, 4294950912, 2, 0, 2, 118, 0, 65528, 2, 177, 0, 4294770176, 2, 26, 3, 0, 4, -30, 2, 174, 0, 3758153728, -3, 2, 169, -2, 2, 155, 2, 188, 2, 158, -1, 2, 191, -1, 2, 161, 0, 4294754304, 3, 0, 2, -3, 0, 33554432, -2, 2, 200, -3, 2, 169, 0, 4175478784, 2, 201, 0, 4286643712, 0, 4286644216, 2, 0, -4, 2, 202, -1, 2, 165, 0, 4227923967, 3, 0, 32, -1334, 2, 163, 2, 0, -129, 2, 94, -6, 2, 163, -180, 2, 203, -233, 2, 4, 3, 0, 96, -16, 2, 163, 3, 0, 47, -154, 2, 165, 3, 0, 22381, -7, 2, 17, 3, 0, 6128], [4294967295, 4294967291, 4092460543, 4294828031, 4294967294, 134217726, 268435455, 2147483647, 1048575, 1073741823, 3892314111, 134217727, 1061158911, 536805376, 4294910143, 4160749567, 4294901759, 4294901760, 536870911, 262143, 8388607, 4294902783, 4294918143, 65535, 67043328, 2281701374, 4294967232, 2097151, 4294903807, 4194303, 255, 67108863, 4294967039, 511, 524287, 131071, 127, 4292870143, 4294902271, 4294549487, 33554431, 1023, 67047423, 4294901888, 4286578687, 4294770687, 67043583, 32767, 15, 2047999, 67043343, 16777215, 4294902000, 4294934527, 4294966783, 4294967279, 2047, 262083, 20511, 4290772991, 41943039, 493567, 4294959104, 603979775, 65536, 602799615, 805044223, 4294965206, 8191, 1031749119, 4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095, 4294905855, 4294967264, 2868854591, 1608515583, 265232348, 534519807, 2147614720, 1060109444, 4093640016, 17376, 2139062143, 224, 4169138175, 4294909951, 4286578688, 4294967292, 4294965759, 2044, 4292870144, 4294966272, 4294967280, 8289918, 4294934399, 4294901775, 4294965375, 1602223615, 4294967259, 4294443008, 268369920, 4292804608, 486341884, 4294963199, 3087007615, 1073692671, 4128527, 4279238655, 4294902015, 4294966591, 2445279231, 3670015, 3238002687, 31, 63, 4294967288, 4294705151, 4095, 3221208447, 4294549472, 2147483648, 4285526655, 4294966527, 4294705152, 4294966143, 64, 4294966719, 16383, 3774873592, 458752, 536807423, 67043839, 3758096383, 3959414372, 3755993023, 2080374783, 4294835295, 4294967103, 4160749565, 4087, 184024726, 2862017156, 1593309078, 268434431, 268434414, 4294901763, 536870912, 2952790016, 202506752, 139264, 402653184, 4261412864, 4227922944, 49152, 61440, 3758096384, 117440512, 65280, 3233808384, 3221225472, 2097152, 4294965248, 32768, 57152, 67108864, 4293918720, 4290772992, 25165824, 57344, 4227915776, 4278190080, 4227907584, 65520, 4026531840, 4227858432, 4160749568, 3758129152, 4294836224, 63488, 1073741824, 4294967040, 4194304, 251658240, 196608, 4294963200, 64512, 417808, 4227923712, 12582912, 50331648, 65472, 4294967168, 4294966784, 16, 4294917120, 2080374784, 4096, 65408, 524288, 65532]);\n\n  const TokenLookup = [\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      125,\r\n      133,\r\n      125,\r\n      125,\r\n      127,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      126,\r\n      125,\r\n      16842797,\r\n      134283267,\r\n      128,\r\n      208897,\r\n      8457012,\r\n      8455748,\r\n      134283267,\r\n      67174411,\r\n      16,\r\n      8457011,\r\n      25233967,\r\n      1073741842,\r\n      25233968,\r\n      67108877,\r\n      8457013,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      134283266,\r\n      21,\r\n      1074790417,\r\n      8456255,\r\n      1077936157,\r\n      8456256,\r\n      22,\r\n      130,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      208897,\r\n      69271571,\r\n      134,\r\n      20,\r\n      8455494,\r\n      208897,\r\n      129,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      4096,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      4096,\r\n      208897,\r\n      4096,\r\n      4096,\r\n      2162700,\r\n      8455237,\r\n      1074790415,\r\n      16842798,\r\n      126\r\n  ];\r\n  function nextToken(parser, context) {\r\n      parser.flags = (parser.flags | 1) ^ 1;\r\n      parser.startPos = parser.index;\r\n      parser.startColumn = parser.column;\r\n      parser.startLine = parser.line;\r\n      parser.token = scanSingleToken(parser, context, 0);\r\n      if (parser.onToken && parser.token !== 1048576)\r\n          parser.onToken(convertTokenType(parser.token), parser.tokenPos, parser.index);\r\n  }\r\n  function scanSingleToken(parser, context, state) {\r\n      const isStartOfLine = parser.index === 0;\r\n      const source = parser.source;\r\n      while (parser.index < parser.end) {\r\n          parser.tokenPos = parser.index;\r\n          parser.colPos = parser.column;\r\n          parser.linePos = parser.line;\r\n          let char = parser.currentChar;\r\n          if (char <= 0x7e) {\r\n              const token = TokenLookup[char];\r\n              switch (token) {\r\n                  case 67174411:\r\n                  case 16:\r\n                  case 2162700:\r\n                  case 1074790415:\r\n                  case 69271571:\r\n                  case 20:\r\n                  case 21:\r\n                  case 1074790417:\r\n                  case 1073741842:\r\n                  case 16842798:\r\n                  case 130:\r\n                  case 126:\r\n                      advanceChar(parser);\r\n                      return token;\r\n                  case 8456255:\r\n                      let ch = advanceChar(parser);\r\n                      if (parser.index < parser.end) {\r\n                          if (ch === 60) {\r\n                              if (parser.index < parser.end && advanceChar(parser) === 61) {\r\n                                  advanceChar(parser);\r\n                                  return 4194334;\r\n                              }\r\n                              return 8456513;\r\n                          }\r\n                          else if (ch === 61) {\r\n                              advanceChar(parser);\r\n                              return 8455997;\r\n                          }\r\n                          if (ch === 33) {\r\n                              const index = parser.index + 1;\r\n                              if (index + 1 < parser.end &&\r\n                                  source.charCodeAt(index) === 45 &&\r\n                                  source.charCodeAt(index + 1) == 45) {\r\n                                  parser.column += 3;\r\n                                  parser.currentChar = source.charCodeAt((parser.index += 3));\r\n                                  state = skipSingleHTMLComment(parser, source, state, context, 2);\r\n                                  continue;\r\n                              }\r\n                              return 8456255;\r\n                          }\r\n                          if (ch === 47) {\r\n                              if ((context & 16) < 1)\r\n                                  return 8456255;\r\n                              const index = parser.index + 1;\r\n                              if (index < parser.end) {\r\n                                  ch = source.charCodeAt(index);\r\n                                  if (ch === 42 || ch === 47)\r\n                                      break;\r\n                              }\r\n                              advanceChar(parser);\r\n                              return 25;\r\n                          }\r\n                      }\r\n                      return 8456255;\r\n                  case 1077936157: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 1077936157;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 61) {\r\n                          if (advanceChar(parser) === 61) {\r\n                              advanceChar(parser);\r\n                              return 8455993;\r\n                          }\r\n                          return 8455995;\r\n                      }\r\n                      if (ch === 62) {\r\n                          advanceChar(parser);\r\n                          return 10;\r\n                      }\r\n                      return 1077936157;\r\n                  }\r\n                  case 16842797:\r\n                      if (advanceChar(parser) !== 61) {\r\n                          return 16842797;\r\n                      }\r\n                      if (advanceChar(parser) !== 61) {\r\n                          return 8455996;\r\n                      }\r\n                      advanceChar(parser);\r\n                      return 8455994;\r\n                  case 8457012:\r\n                      if (advanceChar(parser) !== 61)\r\n                          return 8457012;\r\n                      advanceChar(parser);\r\n                      return 4194342;\r\n                  case 8457011: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8457011;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194340;\r\n                      }\r\n                      if (ch !== 42)\r\n                          return 8457011;\r\n                      if (advanceChar(parser) !== 61)\r\n                          return 8457270;\r\n                      advanceChar(parser);\r\n                      return 4194337;\r\n                  }\r\n                  case 8455494:\r\n                      if (advanceChar(parser) !== 61)\r\n                          return 8455494;\r\n                      advanceChar(parser);\r\n                      return 4194343;\r\n                  case 25233967: {\r\n                      advanceChar(parser);\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 43) {\r\n                          advanceChar(parser);\r\n                          return 33619995;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194338;\r\n                      }\r\n                      return 25233967;\r\n                  }\r\n                  case 25233968: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 25233968;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 45) {\r\n                          advanceChar(parser);\r\n                          if ((state & 1 || isStartOfLine) && parser.currentChar === 62) {\r\n                              if ((context & 256) === 0)\r\n                                  report(parser, 108);\r\n                              advanceChar(parser);\r\n                              state = skipSingleHTMLComment(parser, source, state, context, 3);\r\n                              continue;\r\n                          }\r\n                          return 33619996;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194339;\r\n                      }\r\n                      return 25233968;\r\n                  }\r\n                  case 8457013: {\r\n                      advanceChar(parser);\r\n                      if (parser.index < parser.end) {\r\n                          const ch = parser.currentChar;\r\n                          if (ch === 47) {\r\n                              advanceChar(parser);\r\n                              state = skipSingleLineComment(parser, source, state, 0);\r\n                              continue;\r\n                          }\r\n                          if (ch === 42) {\r\n                              advanceChar(parser);\r\n                              state = skipMultiLineComment(parser, source, state);\r\n                              continue;\r\n                          }\r\n                          if (context & 32768) {\r\n                              return scanRegularExpression(parser, context);\r\n                          }\r\n                          if (ch === 61) {\r\n                              advanceChar(parser);\r\n                              return 4259877;\r\n                          }\r\n                      }\r\n                      return 8457013;\r\n                  }\r\n                  case 8455237: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8455237;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 124) {\r\n                          advanceChar(parser);\r\n                          return 8979000;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194344;\r\n                      }\r\n                      return 8455237;\r\n                  }\r\n                  case 8456256: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8456256;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 8455998;\r\n                      }\r\n                      if (ch !== 62)\r\n                          return 8456256;\r\n                      advanceChar(parser);\r\n                      if (parser.index < parser.end) {\r\n                          const ch = parser.currentChar;\r\n                          if (ch === 62) {\r\n                              if (advanceChar(parser) === 61) {\r\n                                  advanceChar(parser);\r\n                                  return 4194336;\r\n                              }\r\n                              return 8456515;\r\n                          }\r\n                          if (ch === 61) {\r\n                              advanceChar(parser);\r\n                              return 4194335;\r\n                          }\r\n                      }\r\n                      return 8456514;\r\n                  }\r\n                  case 8455748: {\r\n                      advanceChar(parser);\r\n                      if (parser.index >= parser.end)\r\n                          return 8455748;\r\n                      const ch = parser.currentChar;\r\n                      if (ch === 38) {\r\n                          advanceChar(parser);\r\n                          return 8979255;\r\n                      }\r\n                      if (ch === 61) {\r\n                          advanceChar(parser);\r\n                          return 4194345;\r\n                      }\r\n                      return 8455748;\r\n                  }\r\n                  case 67108877:\r\n                      const next = advanceChar(parser);\r\n                      if (next >= 48 && next <= 57)\r\n                          return scanNumber(parser, context, 64 | 16);\r\n                      if (next === 46) {\r\n                          const index = parser.index + 1;\r\n                          if (index < parser.end && source.charCodeAt(index) === 46) {\r\n                              parser.column += 2;\r\n                              parser.currentChar = source.charCodeAt((parser.index += 2));\r\n                              return 14;\r\n                          }\r\n                      }\r\n                      return 67108877;\r\n                  case 22: {\r\n                      let ch = advanceChar(parser);\r\n                      if ((context & 1) < 1)\r\n                          return 22;\r\n                      if (ch === 63) {\r\n                          advanceChar(parser);\r\n                          return 276889979;\r\n                      }\r\n                      if (ch === 46) {\r\n                          const index = parser.index + 1;\r\n                          if (index < parser.end) {\r\n                              ch = source.charCodeAt(index);\r\n                              if (!(ch >= 48 && ch <= 57)) {\r\n                                  advanceChar(parser);\r\n                                  return 67108988;\r\n                              }\r\n                          }\r\n                      }\r\n                      return 22;\r\n                  }\r\n                  case 4096:\r\n                      return scanIdentifier(parser, context, 1);\r\n                  case 208897:\r\n                      return scanIdentifier(parser, context, 0);\r\n                  case 134283266:\r\n                      return scanNumber(parser, context, 16 | 128);\r\n                  case 134283267:\r\n                      return scanString(parser, context, char);\r\n                  case 129:\r\n                      return scanTemplate(parser, context);\r\n                  case 134:\r\n                      return scanUnicodeIdentifier(parser, context);\r\n                  case 128:\r\n                      return scanPrivateName(parser);\r\n                  case 125:\r\n                      advanceChar(parser);\r\n                      break;\r\n                  case 127:\r\n                      state |= 1 | 4;\r\n                      scanNewLine(parser);\r\n                      break;\r\n                  case 133:\r\n                      consumeLineFeed(parser, state);\r\n                      state = (state & ~4) | 1;\r\n                      break;\r\n              }\r\n          }\r\n          else {\r\n              if ((char ^ 8232) <= 1) {\r\n                  state = (state & ~4) | 1;\r\n                  scanNewLine(parser);\r\n                  continue;\r\n              }\r\n              if ((char & 0xfc00) === 0xd800 || ((unicodeLookup[(char >>> 5) + 34816] >>> char) & 31 & 1) !== 0) {\r\n                  if ((char & 0xfc00) === 0xdc00) {\r\n                      char = ((char & 0x3ff) << 10) | (char & 0x3ff) | 0x10000;\r\n                      if (((unicodeLookup[(char >>> 5) + 0] >>> char) & 31 & 1) === 0) {\r\n                          report(parser, 18, fromCodePoint(char));\r\n                      }\r\n                      parser.index++;\r\n                      parser.currentChar = char;\r\n                  }\r\n                  parser.column++;\r\n                  parser.tokenValue = '';\r\n                  return scanIdentifierSlowCase(parser, context, 0, 0);\r\n              }\r\n              if (isExoticECMAScriptWhitespace(char)) {\r\n                  advanceChar(parser);\r\n                  continue;\r\n              }\r\n              report(parser, 18, fromCodePoint(char));\r\n          }\r\n      }\r\n      return 1048576;\r\n  }\n\n  const CommentTypes = ['SingleLine', 'MultiLine', 'HTMLOpen', 'HTMLClose', 'HashbangComment'];\r\n  function skipHashBang(parser) {\r\n      const source = parser.source;\r\n      if (parser.currentChar === 35 && source.charCodeAt(parser.index + 1) === 33) {\r\n          skipSingleLineComment(parser, source, 0, 4);\r\n      }\r\n  }\r\n  function skipSingleHTMLComment(parser, source, state, context, type) {\r\n      if (context & 2048)\r\n          report(parser, 0);\r\n      return skipSingleLineComment(parser, source, state, type);\r\n  }\r\n  function skipSingleLineComment(parser, source, state, type) {\r\n      const { index } = parser;\r\n      while (parser.index < parser.end) {\r\n          if (CharTypes[parser.currentChar] & 8) {\r\n              const isCR = parser.currentChar === 13;\r\n              scanNewLine(parser);\r\n              if (isCR && parser.index < parser.end && parser.currentChar === 10)\r\n                  parser.currentChar = source.charCodeAt(++parser.index);\r\n              break;\r\n          }\r\n          else if ((parser.currentChar ^ 8232) <= 1) {\r\n              scanNewLine(parser);\r\n              break;\r\n          }\r\n          advanceChar(parser);\r\n      }\r\n      if (parser.onComment)\r\n          parser.onComment(CommentTypes[type & 0xff], source.slice(index, parser.index), index, parser.index);\r\n      return state | 1;\r\n  }\r\n  function skipMultiLineComment(parser, source, state) {\r\n      const { index } = parser;\r\n      while (parser.index < parser.end) {\r\n          if (parser.currentChar < 0x2b) {\r\n              let skippedOneAsterisk = false;\r\n              while (parser.currentChar === 42) {\r\n                  if (!skippedOneAsterisk) {\r\n                      state &= ~4;\r\n                      skippedOneAsterisk = true;\r\n                  }\r\n                  if (advanceChar(parser) === 47) {\r\n                      advanceChar(parser);\r\n                      if (parser.onComment)\r\n                          parser.onComment(CommentTypes[1 & 0xff], source.slice(index, parser.index - 2), index, parser.index);\r\n                      return state;\r\n                  }\r\n              }\r\n              if (skippedOneAsterisk) {\r\n                  continue;\r\n              }\r\n              if (CharTypes[parser.currentChar] & 8) {\r\n                  if (parser.currentChar === 13) {\r\n                      state |= 1 | 4;\r\n                      scanNewLine(parser);\r\n                  }\r\n                  else {\r\n                      consumeLineFeed(parser, state);\r\n                      state = (state & ~4) | 1;\r\n                  }\r\n              }\r\n              else {\r\n                  advanceChar(parser);\r\n              }\r\n          }\r\n          else if ((parser.currentChar ^ 8232) <= 1) {\r\n              state = (state & ~4) | 1;\r\n              scanNewLine(parser);\r\n          }\r\n          else {\r\n              state &= ~4;\r\n              advanceChar(parser);\r\n          }\r\n      }\r\n      report(parser, 16);\r\n  }\n\n  function advanceChar(parser) {\r\n      parser.column++;\r\n      return (parser.currentChar = parser.source.charCodeAt(++parser.index));\r\n  }\r\n  function consumeMultiUnitCodePoint(parser, hi) {\r\n      if ((hi & 0xfc00) !== 55296)\r\n          return 0;\r\n      const lo = parser.source.charCodeAt(parser.index + 1);\r\n      if ((lo & 0xfc00) !== 0xdc00)\r\n          return 0;\r\n      hi = parser.currentChar = 65536 + ((hi & 0x3ff) << 10) + (lo & 0x3ff);\r\n      if (((unicodeLookup[(hi >>> 5) + 0] >>> hi) & 31 & 1) === 0) {\r\n          report(parser, 18, fromCodePoint(hi));\r\n      }\r\n      parser.index++;\r\n      parser.column++;\r\n      return 1;\r\n  }\r\n  function consumeLineFeed(parser, state) {\r\n      parser.currentChar = parser.source.charCodeAt(++parser.index);\r\n      parser.flags |= 1;\r\n      if ((state & 4) === 0) {\r\n          parser.column = 0;\r\n          parser.line++;\r\n      }\r\n  }\r\n  function scanNewLine(parser) {\r\n      parser.flags |= 1;\r\n      parser.currentChar = parser.source.charCodeAt(++parser.index);\r\n      parser.column = 0;\r\n      parser.line++;\r\n  }\r\n  function isExoticECMAScriptWhitespace(ch) {\r\n      return (ch === 160 ||\r\n          ch === 65279 ||\r\n          ch === 133 ||\r\n          ch === 5760 ||\r\n          (ch >= 8192 && ch <= 8203) ||\r\n          ch === 8239 ||\r\n          ch === 8287 ||\r\n          ch === 12288 ||\r\n          ch === 8201 ||\r\n          ch === 65519);\r\n  }\r\n  function fromCodePoint(codePoint) {\r\n      return codePoint <= 65535\r\n          ? String.fromCharCode(codePoint)\r\n          : String.fromCharCode(codePoint >>> 10) + String.fromCharCode(codePoint & 0x3ff);\r\n  }\r\n  function toHex(code) {\r\n      return code < 65 ? code - 48 : (code - 65 + 10) & 0xf;\r\n  }\r\n  function convertTokenType(t) {\r\n      switch (t) {\r\n          case 134283266:\r\n              return 'NumericLiteral';\r\n          case 134283267:\r\n              return 'StringLiteral';\r\n          case 86021:\r\n          case 86022:\r\n              return 'BooleanLiteral';\r\n          case 86023:\r\n              return 'NullLiteral';\r\n          case 65540:\r\n              return 'RegularExpression';\r\n          case 67174408:\r\n          case 67174409:\r\n          case 129:\r\n              return 'TemplateLiteral';\r\n          default:\r\n              if ((t & 143360) === 143360)\r\n                  return 'Identifier';\r\n              if ((t & 4096) === 4096)\r\n                  return 'Keyword';\r\n              return 'Punctuator';\r\n      }\r\n  }\n\n  const CharTypes = [\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      8 | 1024,\r\n      0,\r\n      0,\r\n      8 | 2048,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      8192,\r\n      0,\r\n      1 | 2,\r\n      0,\r\n      0,\r\n      8192,\r\n      0,\r\n      0,\r\n      0,\r\n      256,\r\n      0,\r\n      256 | 32768,\r\n      0,\r\n      0,\r\n      2 | 16 | 128 | 32 | 64,\r\n      2 | 16 | 128 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 32 | 64,\r\n      2 | 16 | 512 | 64,\r\n      2 | 16 | 512 | 64,\r\n      0,\r\n      0,\r\n      16384,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2 | 64,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      1 | 2,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      1 | 2 | 4096,\r\n      0,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4 | 64,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      1 | 2 | 4,\r\n      16384,\r\n      0,\r\n      0,\r\n      0,\r\n      0\r\n  ];\r\n  const isIdStart = [\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0\r\n  ];\r\n  const isIdPart = [\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      1,\r\n      0,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      1,\r\n      0,\r\n      0,\r\n      0,\r\n      0,\r\n      0\r\n  ];\r\n  function isIdentifierStart(code) {\r\n      return code <= 0x7F\r\n          ? isIdStart[code]\r\n          : (unicodeLookup[(code >>> 5) + 34816] >>> code) & 31 & 1;\r\n  }\r\n  function isIdentifierPart(code) {\r\n      return code <= 0x7F\r\n          ? isIdPart[code]\r\n          : (unicodeLookup[(code >>> 5) + 0] >>> code) & 31 & 1 || (code === 8204 || code === 8205);\r\n  }\n\n  const KeywordDescTable = [\r\n      'end of source',\r\n      'identifier', 'number', 'string', 'regular expression',\r\n      'false', 'true', 'null',\r\n      'template continuation', 'template tail',\r\n      '=>', '(', '{', '.', '...', '}', ')', ';', ',', '[', ']', ':', '?', '\\'', '\"', '</', '/>',\r\n      '++', '--',\r\n      '=', '<<=', '>>=', '>>>=', '**=', '+=', '-=', '*=', '/=', '%=', '^=', '|=',\r\n      '&=',\r\n      'typeof', 'delete', 'void', '!', '~', '+', '-', 'in', 'instanceof', '*', '%', '/', '**', '&&',\r\n      '||', '===', '!==', '==', '!=', '<=', '>=', '<', '>', '<<', '>>', '>>>', '&', '|', '^',\r\n      'var', 'let', 'const',\r\n      'break', 'case', 'catch', 'class', 'continue', 'debugger', 'default', 'do', 'else', 'export',\r\n      'extends', 'finally', 'for', 'function', 'if', 'import', 'new', 'return', 'super', 'switch',\r\n      'this', 'throw', 'try', 'while', 'with',\r\n      'implements', 'interface', 'package', 'private', 'protected', 'public', 'static', 'yield',\r\n      'as', 'async', 'await', 'constructor', 'get', 'set', 'from', 'of',\r\n      'enum', 'eval', 'arguments', 'escaped keyword', 'escaped future reserved keyword', 'reserved if strict', '#',\r\n      'BigIntLiteral', '??', '?.', 'WhiteSpace', 'Illegal', 'LineTerminator', 'PrivateField',\r\n      'Template', '@', 'target', 'meta', 'LineFeed', 'Escaped', 'JSXText'\r\n  ];\r\n  const descKeywordTable = Object.create(null, {\r\n      this: { value: 86110 },\r\n      function: { value: 86103 },\r\n      if: { value: 20568 },\r\n      return: { value: 20571 },\r\n      var: { value: 86087 },\r\n      else: { value: 20562 },\r\n      for: { value: 20566 },\r\n      new: { value: 86106 },\r\n      in: { value: 8738865 },\r\n      typeof: { value: 16863274 },\r\n      while: { value: 20577 },\r\n      case: { value: 20555 },\r\n      break: { value: 20554 },\r\n      try: { value: 20576 },\r\n      catch: { value: 20556 },\r\n      delete: { value: 16863275 },\r\n      throw: { value: 86111 },\r\n      switch: { value: 86109 },\r\n      continue: { value: 20558 },\r\n      default: { value: 20560 },\r\n      instanceof: { value: 8476722 },\r\n      do: { value: 20561 },\r\n      void: { value: 16863276 },\r\n      finally: { value: 20565 },\r\n      async: { value: 143468 },\r\n      await: { value: 209005 },\r\n      class: { value: 86093 },\r\n      const: { value: 86089 },\r\n      constructor: { value: 12398 },\r\n      debugger: { value: 20559 },\r\n      export: { value: 20563 },\r\n      extends: { value: 20564 },\r\n      false: { value: 86021 },\r\n      from: { value: 12401 },\r\n      get: { value: 12399 },\r\n      implements: { value: 36963 },\r\n      import: { value: 86105 },\r\n      interface: { value: 36964 },\r\n      let: { value: 241736 },\r\n      null: { value: 86023 },\r\n      of: { value: 274546 },\r\n      package: { value: 36965 },\r\n      private: { value: 36966 },\r\n      protected: { value: 36967 },\r\n      public: { value: 36968 },\r\n      set: { value: 12400 },\r\n      static: { value: 36969 },\r\n      super: { value: 86108 },\r\n      true: { value: 86022 },\r\n      with: { value: 20578 },\r\n      yield: { value: 241770 },\r\n      enum: { value: 20595 },\r\n      eval: { value: 537079924 },\r\n      as: { value: 12395 },\r\n      arguments: { value: 537079925 },\r\n      target: { value: 143491 },\r\n      meta: { value: 143492 },\r\n  });\n\n  function scanIdentifier(parser, context, isValidAsKeyword) {\r\n      while (isIdPart[advanceChar(parser)]) { }\r\n      parser.tokenValue = parser.source.slice(parser.tokenPos, parser.index);\r\n      return parser.currentChar !== 92 && parser.currentChar < 0x7e\r\n          ? descKeywordTable[parser.tokenValue] || 208897\r\n          : scanIdentifierSlowCase(parser, context, 0, isValidAsKeyword);\r\n  }\r\n  function scanUnicodeIdentifier(parser, context) {\r\n      const cookedChar = scanIdentifierUnicodeEscape(parser);\r\n      if (!isIdentifierPart(cookedChar))\r\n          report(parser, 4);\r\n      parser.tokenValue = fromCodePoint(cookedChar);\r\n      return scanIdentifierSlowCase(parser, context, 1, CharTypes[cookedChar] & 4);\r\n  }\r\n  function scanIdentifierSlowCase(parser, context, hasEscape, isValidAsKeyword) {\r\n      let start = parser.index;\r\n      while (parser.index < parser.end) {\r\n          if (parser.currentChar === 92) {\r\n              parser.tokenValue += parser.source.slice(start, parser.index);\r\n              hasEscape = 1;\r\n              const code = scanIdentifierUnicodeEscape(parser);\r\n              if (!isIdentifierPart(code))\r\n                  report(parser, 4);\r\n              isValidAsKeyword = isValidAsKeyword && CharTypes[code] & 4;\r\n              parser.tokenValue += fromCodePoint(code);\r\n              start = parser.index;\r\n          }\r\n          else if (isIdentifierPart(parser.currentChar) || consumeMultiUnitCodePoint(parser, parser.currentChar)) {\r\n              advanceChar(parser);\r\n          }\r\n          else {\r\n              break;\r\n          }\r\n      }\r\n      if (parser.index <= parser.end) {\r\n          parser.tokenValue += parser.source.slice(start, parser.index);\r\n      }\r\n      const length = parser.tokenValue.length;\r\n      if (isValidAsKeyword && (length >= 2 && length <= 11)) {\r\n          const token = descKeywordTable[parser.tokenValue];\r\n          if (token === void 0)\r\n              return 208897;\r\n          if (!hasEscape)\r\n              return token;\r\n          if (context & 1024) {\r\n              return token === 209005 && (context & (2048 | 4194304)) === 0\r\n                  ? token\r\n                  : token === 36969\r\n                      ? 119\r\n                      : (token & 36864) === 36864\r\n                          ? 119\r\n                          : 118;\r\n          }\r\n          if (context & 1073741824 &&\r\n              (context & 8192) === 0 &&\r\n              (token & 20480) === 20480)\r\n              return token;\r\n          if (token === 241770) {\r\n              return context & 1073741824\r\n                  ? 143480\r\n                  : context & 2097152\r\n                      ? 118\r\n                      : token;\r\n          }\r\n          return token === 143468 && context & 1073741824\r\n              ? 143480\r\n              : (token & 36864) === 36864\r\n                  ? token\r\n                  : token === 209005 && (context & 4194304) === 0\r\n                      ? token\r\n                      : 118;\r\n      }\r\n      return 208897;\r\n  }\r\n  function scanPrivateName(parser) {\r\n      if (!isIdentifierStart(advanceChar(parser)))\r\n          report(parser, 93);\r\n      return 128;\r\n  }\r\n  function scanIdentifierUnicodeEscape(parser) {\r\n      if (parser.source.charCodeAt(parser.index + 1) !== 117) {\r\n          report(parser, 4);\r\n      }\r\n      parser.currentChar = parser.source.charCodeAt((parser.index += 2));\r\n      return scanUnicodeEscape(parser);\r\n  }\r\n  function scanUnicodeEscape(parser) {\r\n      let codePoint = 0;\r\n      const char = parser.currentChar;\r\n      if (char === 123) {\r\n          const begin = parser.index - 2;\r\n          while (CharTypes[advanceChar(parser)] & 64) {\r\n              codePoint = (codePoint << 4) | toHex(parser.currentChar);\r\n              if (codePoint > 1114111)\r\n                  reportScannerError(begin, parser.line, parser.index + 1, 101);\r\n          }\r\n          if (parser.currentChar !== 125) {\r\n              reportScannerError(begin, parser.line, parser.index - 1, 6);\r\n          }\r\n          advanceChar(parser);\r\n          return codePoint;\r\n      }\r\n      if ((CharTypes[char] & 64) === 0)\r\n          report(parser, 6);\r\n      const char2 = parser.source.charCodeAt(parser.index + 1);\r\n      if ((CharTypes[char2] & 64) === 0)\r\n          report(parser, 6);\r\n      const char3 = parser.source.charCodeAt(parser.index + 2);\r\n      if ((CharTypes[char3] & 64) === 0)\r\n          report(parser, 6);\r\n      const char4 = parser.source.charCodeAt(parser.index + 3);\r\n      if ((CharTypes[char4] & 64) === 0)\r\n          report(parser, 6);\r\n      codePoint = (toHex(char) << 12) | (toHex(char2) << 8) | (toHex(char3) << 4) | toHex(char4);\r\n      parser.currentChar = parser.source.charCodeAt((parser.index += 4));\r\n      return codePoint;\r\n  }\n\n  function scanString(parser, context, quote) {\r\n      const { index: start } = parser;\r\n      let ret = '';\r\n      let char = advanceChar(parser);\r\n      let marker = parser.index;\r\n      while ((CharTypes[char] & 8) === 0) {\r\n          if (char === quote) {\r\n              ret += parser.source.slice(marker, parser.index);\r\n              advanceChar(parser);\r\n              if (context & 512)\r\n                  parser.tokenRaw = parser.source.slice(start, parser.index);\r\n              parser.tokenValue = ret;\r\n              return 134283267;\r\n          }\r\n          if ((char & 8) === 8 && char === 92) {\r\n              ret += parser.source.slice(marker, parser.index);\r\n              char = advanceChar(parser);\r\n              if (char > 0x7e) {\r\n                  ret += fromCodePoint(char);\r\n              }\r\n              else {\r\n                  const code = parseEscape(parser, context, char);\r\n                  if (code >= 0)\r\n                      ret += fromCodePoint(code);\r\n                  else\r\n                      handleStringError(parser, code, 0);\r\n              }\r\n              marker = parser.index + 1;\r\n          }\r\n          if (parser.index >= parser.end)\r\n              report(parser, 14);\r\n          char = advanceChar(parser);\r\n      }\r\n      report(parser, 14);\r\n  }\r\n  function parseEscape(parser, context, first) {\r\n      switch (first) {\r\n          case 98:\r\n              return 8;\r\n          case 102:\r\n              return 12;\r\n          case 114:\r\n              return 13;\r\n          case 110:\r\n              return 10;\r\n          case 116:\r\n              return 9;\r\n          case 118:\r\n              return 11;\r\n          case 13: {\r\n              if (parser.index < parser.end) {\r\n                  if (parser.currentChar === 10) {\r\n                      parser.index = parser.index + 1;\r\n                      parser.currentChar = parser.source.charCodeAt(parser.index);\r\n                  }\r\n              }\r\n          }\r\n          case 10:\r\n          case 8232:\r\n          case 8233:\r\n              parser.column = -1;\r\n              parser.line++;\r\n              return -1;\r\n          case 48:\r\n          case 49:\r\n          case 50:\r\n          case 51: {\r\n              let code = first - 48;\r\n              let index = parser.index + 1;\r\n              let column = parser.column + 1;\r\n              if (index < parser.end) {\r\n                  const next = parser.source.charCodeAt(index);\r\n                  if ((CharTypes[next] & 32) === 0) {\r\n                      if ((code !== 0 || CharTypes[next] & 512) && context & 1024)\r\n                          return -2;\r\n                  }\r\n                  else if (context & 1024) {\r\n                      return -2;\r\n                  }\r\n                  else {\r\n                      parser.currentChar = next;\r\n                      code = (code << 3) | (next - 48);\r\n                      index++;\r\n                      column++;\r\n                      if (index < parser.end) {\r\n                          const next = parser.source.charCodeAt(index);\r\n                          if (CharTypes[next] & 32) {\r\n                              parser.currentChar = next;\r\n                              code = (code << 3) | (next - 48);\r\n                              index++;\r\n                              column++;\r\n                          }\r\n                      }\r\n                      parser.flags |= 64;\r\n                      parser.index = index - 1;\r\n                      parser.column = column - 1;\r\n                  }\r\n              }\r\n              return code;\r\n          }\r\n          case 52:\r\n          case 53:\r\n          case 54:\r\n          case 55: {\r\n              if (context & 1024)\r\n                  return -2;\r\n              let code = first - 48;\r\n              const index = parser.index + 1;\r\n              const column = parser.column + 1;\r\n              if (index < parser.end) {\r\n                  const next = parser.source.charCodeAt(index);\r\n                  if (CharTypes[next] & 32) {\r\n                      code = (code << 3) | (next - 48);\r\n                      parser.currentChar = next;\r\n                      parser.index = index;\r\n                      parser.column = column;\r\n                  }\r\n              }\r\n              parser.flags |= 64;\r\n              return code;\r\n          }\r\n          case 56:\r\n          case 57:\r\n              return -3;\r\n          case 120: {\r\n              const ch1 = advanceChar(parser);\r\n              if ((CharTypes[ch1] & 64) === 0)\r\n                  return -4;\r\n              const hi = toHex(ch1);\r\n              const ch2 = advanceChar(parser);\r\n              if ((CharTypes[ch2] & 64) === 0)\r\n                  return -4;\r\n              const lo = toHex(ch2);\r\n              return (hi << 4) | lo;\r\n          }\r\n          case 117: {\r\n              const ch = advanceChar(parser);\r\n              if (parser.currentChar === 123) {\r\n                  let code = 0;\r\n                  while ((CharTypes[advanceChar(parser)] & 64) !== 0) {\r\n                      code = (code << 4) | toHex(parser.currentChar);\r\n                      if (code > 1114111)\r\n                          return -5;\r\n                  }\r\n                  if (parser.currentChar < 1 || parser.currentChar !== 125) {\r\n                      return -4;\r\n                  }\r\n                  return code;\r\n              }\r\n              else {\r\n                  if ((CharTypes[ch] & 64) === 0)\r\n                      return -4;\r\n                  const ch2 = parser.source.charCodeAt(parser.index + 1);\r\n                  if ((CharTypes[ch2] & 64) === 0)\r\n                      return -4;\r\n                  const ch3 = parser.source.charCodeAt(parser.index + 2);\r\n                  if ((CharTypes[ch3] & 64) === 0)\r\n                      return -4;\r\n                  const ch4 = parser.source.charCodeAt(parser.index + 3);\r\n                  if ((CharTypes[ch4] & 64) === 0)\r\n                      return -4;\r\n                  parser.index += 3;\r\n                  parser.column += 3;\r\n                  parser.currentChar = parser.source.charCodeAt(parser.index);\r\n                  return (toHex(ch) << 12) | (toHex(ch2) << 8) | (toHex(ch3) << 4) | toHex(ch4);\r\n              }\r\n          }\r\n          default:\r\n              return first;\r\n      }\r\n  }\r\n  function handleStringError(state, code, isTemplate) {\r\n      switch (code) {\r\n          case -1:\r\n              return;\r\n          case -2:\r\n              report(state, isTemplate ? 2 : 1);\r\n          case -3:\r\n              report(state, 13);\r\n          case -4:\r\n              report(state, 6);\r\n          case -5:\r\n              report(state, 101);\r\n      }\r\n  }\n\n  function scanNumber(parser, context, kind) {\r\n      let char = parser.currentChar;\r\n      let value = 0;\r\n      let digit = 9;\r\n      let atStart = kind & 64 ? 0 : 1;\r\n      let digits = 0;\r\n      let allowSeparator = 0;\r\n      if (kind & 64) {\r\n          value = '.' + scanDecimalDigitsOrSeparator(parser, char);\r\n          char = parser.currentChar;\r\n          if (char === 110)\r\n              report(parser, 11);\r\n      }\r\n      else {\r\n          if (char === 48) {\r\n              char = advanceChar(parser);\r\n              if ((char | 32) === 120) {\r\n                  kind = 8 | 128;\r\n                  char = advanceChar(parser);\r\n                  while (CharTypes[char] & (64 | 4096)) {\r\n                      if (char === 95) {\r\n                          if (!allowSeparator)\r\n                              report(parser, 146);\r\n                          allowSeparator = 0;\r\n                          char = advanceChar(parser);\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 1;\r\n                      value = value * 0x10 + toHex(char);\r\n                      digits++;\r\n                      char = advanceChar(parser);\r\n                  }\r\n                  if (digits < 1 || !allowSeparator) {\r\n                      report(parser, digits < 1 ? 19 : 147);\r\n                  }\r\n              }\r\n              else if ((char | 32) === 111) {\r\n                  kind = 4 | 128;\r\n                  char = advanceChar(parser);\r\n                  while (CharTypes[char] & (32 | 4096)) {\r\n                      if (char === 95) {\r\n                          if (!allowSeparator) {\r\n                              report(parser, 146);\r\n                          }\r\n                          allowSeparator = 0;\r\n                          char = advanceChar(parser);\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 1;\r\n                      value = value * 8 + (char - 48);\r\n                      digits++;\r\n                      char = advanceChar(parser);\r\n                  }\r\n                  if (digits < 1 || !allowSeparator) {\r\n                      report(parser, digits < 1 ? 0 : 147);\r\n                  }\r\n              }\r\n              else if ((char | 32) === 98) {\r\n                  kind = 2 | 128;\r\n                  char = advanceChar(parser);\r\n                  while (CharTypes[char] & (128 | 4096)) {\r\n                      if (char === 95) {\r\n                          if (!allowSeparator) {\r\n                              report(parser, 146);\r\n                          }\r\n                          allowSeparator = 0;\r\n                          char = advanceChar(parser);\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 1;\r\n                      value = value * 2 + (char - 48);\r\n                      digits++;\r\n                      char = advanceChar(parser);\r\n                  }\r\n                  if (digits < 1 || !allowSeparator) {\r\n                      report(parser, digits < 1 ? 0 : 147);\r\n                  }\r\n              }\r\n              else if (CharTypes[char] & 32) {\r\n                  if (context & 1024)\r\n                      report(parser, 1);\r\n                  kind = 1;\r\n                  while (CharTypes[char] & 16) {\r\n                      if (CharTypes[char] & 512) {\r\n                          kind = 32;\r\n                          atStart = 0;\r\n                          break;\r\n                      }\r\n                      value = value * 8 + (char - 48);\r\n                      char = advanceChar(parser);\r\n                  }\r\n              }\r\n              else if (CharTypes[char] & 512) {\r\n                  if (context & 1024)\r\n                      report(parser, 1);\r\n                  parser.flags |= 64;\r\n                  kind = 32;\r\n              }\r\n              else if (char === 95) {\r\n                  report(parser, 0);\r\n              }\r\n          }\r\n          if (kind & 48) {\r\n              if (atStart) {\r\n                  while (digit >= 0 && CharTypes[char] & (16 | 4096)) {\r\n                      if (char === 95) {\r\n                          char = advanceChar(parser);\r\n                          if (char === 95 || kind & 32) {\r\n                              reportScannerError(parser.index, parser.line, parser.index + 1, 146);\r\n                          }\r\n                          allowSeparator = 1;\r\n                          continue;\r\n                      }\r\n                      allowSeparator = 0;\r\n                      value = 10 * value + (char - 48);\r\n                      char = advanceChar(parser);\r\n                      --digit;\r\n                  }\r\n                  if (allowSeparator) {\r\n                      reportScannerError(parser.index, parser.line, parser.index + 1, 147);\r\n                  }\r\n                  if (digit >= 0 && !isIdentifierStart(char) && char !== 46) {\r\n                      parser.tokenValue = value;\r\n                      if (context & 512)\r\n                          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n                      return 134283266;\r\n                  }\r\n              }\r\n              value += scanDecimalDigitsOrSeparator(parser, char);\r\n              char = parser.currentChar;\r\n              if (char === 46) {\r\n                  if (advanceChar(parser) === 95)\r\n                      report(parser, 0);\r\n                  kind = 64;\r\n                  value += '.' + scanDecimalDigitsOrSeparator(parser, parser.currentChar);\r\n                  char = parser.currentChar;\r\n              }\r\n          }\r\n      }\r\n      const end = parser.index;\r\n      let isBigInt = 0;\r\n      if (char === 110 && kind & 128) {\r\n          isBigInt = 1;\r\n          char = advanceChar(parser);\r\n      }\r\n      else {\r\n          if ((char | 32) === 101) {\r\n              char = advanceChar(parser);\r\n              if (CharTypes[char] & 256)\r\n                  char = advanceChar(parser);\r\n              const { index } = parser;\r\n              if ((CharTypes[char] & 16) < 1)\r\n                  report(parser, 10);\r\n              value += parser.source.substring(end, index) + scanDecimalDigitsOrSeparator(parser, char);\r\n              char = parser.currentChar;\r\n          }\r\n      }\r\n      if ((parser.index < parser.end && CharTypes[char] & 16) || isIdentifierStart(char)) {\r\n          report(parser, 12);\r\n      }\r\n      if (isBigInt) {\r\n          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n          parser.tokenValue = parseInt(value, 0xa);\r\n          return 122;\r\n      }\r\n      parser.tokenValue =\r\n          kind & (1 | 2 | 8 | 4)\r\n              ? value\r\n              : kind & 32\r\n                  ? parseFloat(parser.source.substring(parser.tokenPos, parser.index))\r\n                  : +value;\r\n      if (context & 512)\r\n          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n      return 134283266;\r\n  }\r\n  function scanDecimalDigitsOrSeparator(parser, char) {\r\n      let allowSeparator = 0;\r\n      let start = parser.index;\r\n      let ret = '';\r\n      while (CharTypes[char] & (16 | 4096)) {\r\n          if (char === 95) {\r\n              const { index } = parser;\r\n              char = advanceChar(parser);\r\n              if (char === 95) {\r\n                  reportScannerError(parser.index, parser.line, parser.index + 1, 146);\r\n              }\r\n              allowSeparator = 1;\r\n              ret += parser.source.substring(start, index);\r\n              start = parser.index;\r\n              continue;\r\n          }\r\n          allowSeparator = 0;\r\n          char = advanceChar(parser);\r\n      }\r\n      if (allowSeparator) {\r\n          reportScannerError(parser.index, parser.line, parser.index + 1, 147);\r\n      }\r\n      return ret + parser.source.substring(start, parser.index);\r\n  }\n\n  function scanTemplate(parser, context) {\r\n      const { index: start } = parser;\r\n      let token = 67174409;\r\n      let ret = '';\r\n      let char = advanceChar(parser);\r\n      while (char !== 96) {\r\n          if (char === 36 && parser.source.charCodeAt(parser.index + 1) === 123) {\r\n              advanceChar(parser);\r\n              token = 67174408;\r\n              break;\r\n          }\r\n          else if ((char & 8) === 8 && char === 92) {\r\n              char = advanceChar(parser);\r\n              if (char > 0x7e) {\r\n                  ret += fromCodePoint(char);\r\n              }\r\n              else {\r\n                  const code = parseEscape(parser, context | 1024, char);\r\n                  if (code >= 0) {\r\n                      ret += fromCodePoint(code);\r\n                  }\r\n                  else if (code !== -1 && context & 65536) {\r\n                      ret = undefined;\r\n                      char = scanBadTemplate(parser, char);\r\n                      if (char < 0)\r\n                          token = 67174408;\r\n                      break;\r\n                  }\r\n                  else {\r\n                      handleStringError(parser, code, 1);\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              if (parser.index < parser.end &&\r\n                  char === 13 &&\r\n                  parser.source.charCodeAt(parser.index) === 10) {\r\n                  ret += fromCodePoint(char);\r\n                  parser.currentChar = parser.source.charCodeAt(++parser.index);\r\n              }\r\n              if (((char & 83) < 3 && char === 10) || (char ^ 8232) <= 1) {\r\n                  parser.column = -1;\r\n                  parser.line++;\r\n              }\r\n              ret += fromCodePoint(char);\r\n          }\r\n          if (parser.index >= parser.end)\r\n              report(parser, 15);\r\n          char = advanceChar(parser);\r\n      }\r\n      advanceChar(parser);\r\n      parser.tokenValue = ret;\r\n      parser.tokenRaw = parser.source.slice(start + 1, parser.index - (token === 67174409 ? 1 : 2));\r\n      return token;\r\n  }\r\n  function scanBadTemplate(parser, ch) {\r\n      while (ch !== 96) {\r\n          switch (ch) {\r\n              case 36: {\r\n                  const index = parser.index + 1;\r\n                  if (index < parser.end && parser.source.charCodeAt(index) === 123) {\r\n                      parser.index = index;\r\n                      parser.column++;\r\n                      return -ch;\r\n                  }\r\n                  break;\r\n              }\r\n              case 10:\r\n              case 8232:\r\n              case 8233:\r\n                  parser.column = -1;\r\n                  parser.line++;\r\n          }\r\n          if (parser.index >= parser.end)\r\n              report(parser, 15);\r\n          ch = advanceChar(parser);\r\n      }\r\n      return ch;\r\n  }\r\n  function scanTemplateTail(parser, context) {\r\n      if (parser.index >= parser.end)\r\n          report(parser, 0);\r\n      parser.index--;\r\n      parser.column--;\r\n      return scanTemplate(parser, context);\r\n  }\n\n  function scanRegularExpression(parser, context) {\r\n      const bodyStart = parser.index;\r\n      let preparseState = 0;\r\n      loop: while (true) {\r\n          const ch = parser.currentChar;\r\n          advanceChar(parser);\r\n          if (preparseState & 1) {\r\n              preparseState &= ~1;\r\n          }\r\n          else {\r\n              switch (ch) {\r\n                  case 47:\r\n                      if (!preparseState)\r\n                          break loop;\r\n                      else\r\n                          break;\r\n                  case 92:\r\n                      preparseState |= 1;\r\n                      break;\r\n                  case 91:\r\n                      preparseState |= 2;\r\n                      break;\r\n                  case 93:\r\n                      preparseState &= 1;\r\n                      break;\r\n                  case 13:\r\n                  case 10:\r\n                  case 8232:\r\n                  case 8233:\r\n                      report(parser, 32);\r\n              }\r\n          }\r\n          if (parser.index >= parser.source.length) {\r\n              return report(parser, 32);\r\n          }\r\n      }\r\n      const bodyEnd = parser.index - 1;\r\n      let mask = 0;\r\n      let char = parser.currentChar;\r\n      const { index: flagStart } = parser;\r\n      while (isIdentifierPart(char)) {\r\n          switch (char) {\r\n              case 103:\r\n                  if (mask & 2)\r\n                      report(parser, 34, 'g');\r\n                  mask |= 2;\r\n                  break;\r\n              case 105:\r\n                  if (mask & 1)\r\n                      report(parser, 34, 'i');\r\n                  mask |= 1;\r\n                  break;\r\n              case 109:\r\n                  if (mask & 4)\r\n                      report(parser, 34, 'm');\r\n                  mask |= 4;\r\n                  break;\r\n              case 117:\r\n                  if (mask & 16)\r\n                      report(parser, 34, 'g');\r\n                  mask |= 16;\r\n                  break;\r\n              case 121:\r\n                  if (mask & 8)\r\n                      report(parser, 34, 'y');\r\n                  mask |= 8;\r\n                  break;\r\n              case 115:\r\n                  if (mask & 12)\r\n                      report(parser, 34, 's');\r\n                  mask |= 12;\r\n                  break;\r\n              default:\r\n                  report(parser, 33);\r\n          }\r\n          char = advanceChar(parser);\r\n      }\r\n      const flags = parser.source.slice(flagStart, parser.index);\r\n      const pattern = parser.source.slice(bodyStart, bodyEnd);\r\n      parser.tokenRegExp = { pattern, flags };\r\n      if (context & 512)\r\n          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);\r\n      parser.tokenValue = validate(parser, pattern, flags);\r\n      return 65540;\r\n  }\r\n  function validate(parser, pattern, flags) {\r\n      try {\r\n          return new RegExp(pattern, flags);\r\n      }\r\n      catch (e) {\r\n          report(parser, 32);\r\n      }\r\n  }\n\n  function scanJSXAttributeValue(parser, context) {\r\n      parser.startPos = parser.index;\r\n      parser.startColumn = parser.column;\r\n      parser.startLine = parser.line;\r\n      parser.token =\r\n          CharTypes[parser.currentChar] & 8192\r\n              ? scanJSXString(parser)\r\n              : scanSingleToken(parser, context, 0);\r\n      return parser.token;\r\n  }\r\n  function scanJSXString(parser) {\r\n      const quote = parser.currentChar;\r\n      let char = advanceChar(parser);\r\n      const start = parser.index;\r\n      while (char !== quote) {\r\n          if (parser.index >= parser.end)\r\n              report(parser, 14);\r\n          char = advanceChar(parser);\r\n      }\r\n      if (char !== quote)\r\n          report(parser, 14);\r\n      parser.tokenValue = parser.source.slice(start, parser.index);\r\n      advanceChar(parser);\r\n      return 134283267;\r\n  }\r\n  function scanJSXToken(parser) {\r\n      parser.startPos = parser.tokenPos = parser.index;\r\n      parser.startColumn = parser.colPos = parser.column;\r\n      parser.startLine = parser.linePos = parser.line;\r\n      if (parser.index >= parser.end)\r\n          return (parser.token = 1048576);\r\n      const token = TokenLookup[parser.source.charCodeAt(parser.index)];\r\n      switch (token) {\r\n          case 8456255: {\r\n              advanceChar(parser);\r\n              if (parser.currentChar === 47) {\r\n                  advanceChar(parser);\r\n                  parser.token = 25;\r\n              }\r\n              else {\r\n                  parser.token = 8456255;\r\n              }\r\n              break;\r\n          }\r\n          case 2162700: {\r\n              advanceChar(parser);\r\n              parser.token = 2162700;\r\n              break;\r\n          }\r\n          default:\r\n              while (parser.index < parser.end && (CharTypes[advanceChar(parser)] & 16384) === 0) { }\r\n              parser.tokenValue = parser.source.slice(parser.tokenPos, parser.index);\r\n              parser.token = 135;\r\n      }\r\n      return parser.token;\r\n  }\r\n  function scanJSXIdentifier(parser) {\r\n      if ((parser.token & 143360) === 143360) {\r\n          const { index } = parser;\r\n          let char = parser.currentChar;\r\n          while (CharTypes[char] & (32768 | 2)) {\r\n              char = advanceChar(parser);\r\n          }\r\n          parser.tokenValue += parser.source.slice(index, parser.index);\r\n      }\r\n      parser.token = 208897;\r\n      return parser.token;\r\n  }\n\n  function matchOrInsertSemicolon(parser, context, specDeviation) {\r\n      if ((parser.flags & 1) === 0 &&\r\n          (parser.token & 1048576) !== 1048576 &&\r\n          !specDeviation) {\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      consumeOpt(parser, context, 1074790417);\r\n  }\r\n  function isValidStrictMode(parser, index, tokenPos, tokenValue) {\r\n      if (index - tokenPos < 13 && tokenValue === 'use strict') {\r\n          if ((parser.token & 1048576) === 1048576 || parser.flags & 1) {\r\n              return 1;\r\n          }\r\n      }\r\n      return 0;\r\n  }\r\n  function optionalBit(parser, context, t) {\r\n      if (parser.token !== t)\r\n          return 0;\r\n      nextToken(parser, context);\r\n      return 1;\r\n  }\r\n  function consumeOpt(parser, context, t) {\r\n      if (parser.token !== t)\r\n          return false;\r\n      nextToken(parser, context);\r\n      return true;\r\n  }\r\n  function consume(parser, context, t) {\r\n      if (parser.token !== t)\r\n          report(parser, 23, KeywordDescTable[t & 255]);\r\n      nextToken(parser, context);\r\n  }\r\n  function reinterpretToPattern(state, node) {\r\n      switch (node.type) {\r\n          case 'ArrayExpression':\r\n              node.type = 'ArrayPattern';\r\n              const elements = node.elements;\r\n              for (let i = 0, n = elements.length; i < n; ++i) {\r\n                  const element = elements[i];\r\n                  if (element)\r\n                      reinterpretToPattern(state, element);\r\n              }\r\n              return;\r\n          case 'ObjectExpression':\r\n              node.type = 'ObjectPattern';\r\n              const properties = node.properties;\r\n              for (let i = 0, n = properties.length; i < n; ++i) {\r\n                  reinterpretToPattern(state, properties[i]);\r\n              }\r\n              return;\r\n          case 'AssignmentExpression':\r\n              node.type = 'AssignmentPattern';\r\n              if (node.operator !== '=')\r\n                  report(state, 68);\r\n              delete node.operator;\r\n              reinterpretToPattern(state, node.left);\r\n              return;\r\n          case 'Property':\r\n              reinterpretToPattern(state, node.value);\r\n              return;\r\n          case 'SpreadElement':\r\n              node.type = 'RestElement';\r\n              reinterpretToPattern(state, node.argument);\r\n      }\r\n  }\r\n  function validateBindingIdentifier(parser, context, kind, t, skipEvalArgCheck) {\r\n      if (context & 1024) {\r\n          if ((t & 36864) === 36864) {\r\n              report(parser, 114);\r\n          }\r\n          if (!skipEvalArgCheck && (t & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n      }\r\n      if ((t & 20480) === 20480) {\r\n          report(parser, 99);\r\n      }\r\n      if (kind & (8 | 16) && t === 241736) {\r\n          report(parser, 97);\r\n      }\r\n      if (context & (4194304 | 2048) && t === 209005) {\r\n          report(parser, 95);\r\n      }\r\n      if (context & (2097152 | 1024) && t === 241770) {\r\n          report(parser, 94, 'yield');\r\n      }\r\n  }\r\n  function validateFunctionName(parser, context, t) {\r\n      if (context & 1024) {\r\n          if ((t & 36864) === 36864) {\r\n              report(parser, 114);\r\n          }\r\n          if ((t & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          if (t === 119) {\r\n              report(parser, 92);\r\n          }\r\n          if (t === 118) {\r\n              report(parser, 92);\r\n          }\r\n      }\r\n      if ((t & 20480) === 20480) {\r\n          report(parser, 99);\r\n      }\r\n      if (context & (4194304 | 2048) && t === 209005) {\r\n          report(parser, 95);\r\n      }\r\n      if (context & (2097152 | 1024) && t === 241770) {\r\n          report(parser, 94, 'yield');\r\n      }\r\n  }\r\n  function isStrictReservedWord(parser, context, t) {\r\n      if (t === 209005) {\r\n          if (context & (4194304 | 2048))\r\n              report(parser, 95);\r\n          parser.destructible |= 128;\r\n      }\r\n      if (t === 241770 && context & 2097152)\r\n          report(parser, 94, 'yield');\r\n      return ((t & 20480) === 20480 ||\r\n          (t & 36864) === 36864 ||\r\n          t == 119);\r\n  }\r\n  function isPropertyWithPrivateFieldKey(expr) {\r\n      return !expr.property ? false : expr.property.type === 'PrivateName';\r\n  }\r\n  function isValidLabel(parser, labels, name, isIterationStatement) {\r\n      while (labels) {\r\n          if (labels['$' + name]) {\r\n              if (isIterationStatement)\r\n                  report(parser, 133);\r\n              return 1;\r\n          }\r\n          if (isIterationStatement && labels.loop)\r\n              isIterationStatement = 0;\r\n          labels = labels['$'];\r\n      }\r\n      return 0;\r\n  }\r\n  function validateAndDeclareLabel(parser, labels, name) {\r\n      let set = labels;\r\n      while (set) {\r\n          if (set['$' + name])\r\n              report(parser, 132, name);\r\n          set = set['$'];\r\n      }\r\n      labels['$' + name] = 1;\r\n  }\r\n  function finishNode(parser, context, start, line, column, node) {\r\n      if (context & 2) {\r\n          node.start = start;\r\n          node.end = parser.startPos;\r\n          node.range = [start, parser.startPos];\r\n      }\r\n      if (context & 4) {\r\n          node.loc = {\r\n              start: {\r\n                  line,\r\n                  column\r\n              },\r\n              end: {\r\n                  line: parser.startLine,\r\n                  column: parser.startColumn\r\n              }\r\n          };\r\n          if (parser.sourceFile) {\r\n              node.loc.source = parser.sourceFile;\r\n          }\r\n      }\r\n      return node;\r\n  }\r\n  function isEqualTagName(elementName) {\r\n      switch (elementName.type) {\r\n          case 'JSXIdentifier':\r\n              return elementName.name;\r\n          case 'JSXNamespacedName':\r\n              return elementName.namespace + ':' + elementName.name;\r\n          case 'JSXMemberExpression':\r\n              return isEqualTagName(elementName.object) + '.' + isEqualTagName(elementName.property);\r\n      }\r\n  }\r\n  function createArrowHeadParsingScope(parser, context, value) {\r\n      const scope = addChildScope(createScope(), 1024);\r\n      addBlockName(parser, context, scope, value, 1, 0);\r\n      return scope;\r\n  }\r\n  function recordScopeError(parser, type, ...params) {\r\n      const { index, line, column } = parser;\r\n      return {\r\n          type,\r\n          params,\r\n          index,\r\n          line,\r\n          column\r\n      };\r\n  }\r\n  function createScope() {\r\n      return {\r\n          parent: void 0,\r\n          type: 2\r\n      };\r\n  }\r\n  function addChildScope(parent, type) {\r\n      return {\r\n          parent,\r\n          type,\r\n          scopeError: void 0\r\n      };\r\n  }\r\n  function addVarOrBlock(parser, context, scope, name, kind, origin) {\r\n      if (kind & 4) {\r\n          addVarName(parser, context, scope, name, kind);\r\n      }\r\n      else {\r\n          addBlockName(parser, context, scope, name, kind, origin);\r\n      }\r\n      if (origin & 64) {\r\n          declareUnboundVariable(parser, name);\r\n      }\r\n  }\r\n  function addBlockName(parser, context, scope, name, kind, origin) {\r\n      const value = scope['#' + name];\r\n      if (value && (value & 2) === 0) {\r\n          if (kind & 1) {\r\n              scope.scopeError = recordScopeError(parser, 140, name);\r\n          }\r\n          else if (context & 256 &&\r\n              value & 64 &&\r\n              origin & 2) ;\r\n          else {\r\n              report(parser, 140, name);\r\n          }\r\n      }\r\n      if (scope.type & 128 &&\r\n          (scope.parent['#' + name] && (scope.parent['#' + name] & 2) === 0)) {\r\n          report(parser, 140, name);\r\n      }\r\n      if (scope.type & 1024 && value && (value & 2) === 0) {\r\n          if (kind & 1) {\r\n              scope.scopeError = recordScopeError(parser, 140, name);\r\n          }\r\n      }\r\n      if (scope.type & 64) {\r\n          if (scope.parent['#' + name] & 768)\r\n              report(parser, 153, name);\r\n      }\r\n      scope['#' + name] = kind;\r\n  }\r\n  function addVarName(parser, context, scope, name, kind) {\r\n      let currentScope = scope;\r\n      while (currentScope && (currentScope.type & 256) === 0) {\r\n          const value = currentScope['#' + name];\r\n          if (value & 248) {\r\n              if (context & 256 &&\r\n                  (context & 1024) === 0 &&\r\n                  ((kind & 128 && value & 68) ||\r\n                      (value & 128 && kind & 68))) ;\r\n              else {\r\n                  report(parser, 140, name);\r\n              }\r\n          }\r\n          if (currentScope === scope) {\r\n              if (value & 1 && kind & 1) {\r\n                  currentScope.scopeError = recordScopeError(parser, 140, name);\r\n              }\r\n          }\r\n          if (value & (512 | 256)) {\r\n              if ((value & 512) === 0 ||\r\n                  (context & 256) === 0 ||\r\n                  context & 1024) {\r\n                  report(parser, 140, name);\r\n              }\r\n          }\r\n          currentScope['#' + name] = kind;\r\n          currentScope = currentScope.parent;\r\n      }\r\n  }\r\n  function declareUnboundVariable(parser, name) {\r\n      if (parser.exportedNames !== void 0 && name !== '') {\r\n          if (parser.exportedNames['#' + name]) {\r\n              report(parser, 141, name);\r\n          }\r\n          parser.exportedNames['#' + name] = 1;\r\n      }\r\n  }\r\n  function addBindingToExports(parser, name) {\r\n      if (parser.exportedBindings !== void 0 && name !== '') {\r\n          parser.exportedBindings['#' + name] = 1;\r\n      }\r\n  }\r\n  function pushComment(context, array) {\r\n      return function (type, value, start, end) {\r\n          const comment = {\r\n              type,\r\n              value\r\n          };\r\n          if (context & 2) {\r\n              comment.start = start;\r\n              comment.end = end;\r\n              comment.range = [start, end];\r\n          }\r\n          array.push(comment);\r\n      };\r\n  }\r\n  function pushToken(context, array) {\r\n      return function (token, start, end) {\r\n          const tokens = {\r\n              token\r\n          };\r\n          if (context & 4) {\r\n              tokens.start = start;\r\n              tokens.end = end;\r\n          }\r\n          array.push(tokens);\r\n      };\r\n  }\r\n  function isValidIdentifier(context, t) {\r\n      if (context & (1024 | 2097152)) {\r\n          if (context & 2048 && t === 209005)\r\n              return false;\r\n          if (context & 2097152 && t === 241770)\r\n              return false;\r\n          return (t & 143360) === 143360 || (t & 12288) === 12288;\r\n      }\r\n      return ((t & 143360) === 143360 ||\r\n          (t & 12288) === 12288 ||\r\n          (t & 36864) === 36864);\r\n  }\r\n  function classifyIdentifier(parser, context, t, isArrow) {\r\n      if ((t & 537079808) === 537079808) {\r\n          if (context & 1024)\r\n              report(parser, 115);\r\n          if (isArrow)\r\n              parser.flags |= 512;\r\n      }\r\n      if (!isValidIdentifier(context, t))\r\n          report(parser, 0);\r\n  }\n\n  function create(source, sourceFile, onComment, onToken) {\r\n      return {\r\n          source,\r\n          flags: 0,\r\n          index: 0,\r\n          line: 1,\r\n          column: 0,\r\n          startPos: 0,\r\n          end: source.length,\r\n          tokenPos: 0,\r\n          startColumn: 0,\r\n          colPos: 0,\r\n          linePos: 0,\r\n          startLine: 1,\r\n          sourceFile,\r\n          tokenValue: '',\r\n          token: 1048576,\r\n          tokenRaw: '',\r\n          tokenRegExp: void 0,\r\n          currentChar: source.charCodeAt(0),\r\n          exportedNames: [],\r\n          exportedBindings: [],\r\n          assignable: 1,\r\n          destructible: 0,\r\n          onComment,\r\n          onToken\r\n      };\r\n  }\r\n  function parseSource(source, options, context) {\r\n      let sourceFile = '';\r\n      let onComment;\r\n      let onToken;\r\n      if (options != null) {\r\n          if (options.module)\r\n              context |= 2048 | 1024;\r\n          if (options.next)\r\n              context |= 1;\r\n          if (options.loc)\r\n              context |= 4;\r\n          if (options.ranges)\r\n              context |= 2;\r\n          if (options.uniqueKeyInPattern)\r\n              context |= -2147483648;\r\n          if (options.lexical)\r\n              context |= 64;\r\n          if (options.webcompat)\r\n              context |= 256;\r\n          if (options.directives)\r\n              context |= 8 | 512;\r\n          if (options.globalReturn)\r\n              context |= 32;\r\n          if (options.raw)\r\n              context |= 512;\r\n          if (options.preserveParens)\r\n              context |= 128;\r\n          if (options.impliedStrict)\r\n              context |= 1024;\r\n          if (options.jsx)\r\n              context |= 16;\r\n          if (options.identifierPattern)\r\n              context |= 268435456;\r\n          if (options.specDeviation)\r\n              context |= 536870912;\r\n          if (options.source)\r\n              sourceFile = options.source;\r\n          if (options.onComment != null) {\r\n              onComment = Array.isArray(options.onComment) ? pushComment(context, options.onComment) : options.onComment;\r\n          }\r\n          if (options.onToken != null) {\r\n              onToken = Array.isArray(options.onToken) ? pushToken(context, options.onToken) : options.onToken;\r\n          }\r\n      }\r\n      const parser = create(source, sourceFile, onComment, onToken);\r\n      if (context & 1)\r\n          skipHashBang(parser);\r\n      const scope = context & 64 ? createScope() : void 0;\r\n      let body = [];\r\n      let sourceType = 'script';\r\n      if (context & 2048) {\r\n          sourceType = 'module';\r\n          body = parseModuleItemList(parser, context | 8192, scope);\r\n          if (scope) {\r\n              for (const key in parser.exportedBindings) {\r\n                  if (key[0] === '#' && !scope[key])\r\n                      report(parser, 142, key.slice(1));\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          body = parseStatementList(parser, context | 8192, scope);\r\n      }\r\n      const node = {\r\n          type: 'Program',\r\n          sourceType,\r\n          body\r\n      };\r\n      if (context & 2) {\r\n          node.start = 0;\r\n          node.end = source.length;\r\n          node.range = [0, source.length];\r\n      }\r\n      if (context & 4) {\r\n          node.loc = {\r\n              start: { line: 1, column: 0 },\r\n              end: { line: parser.line, column: parser.column }\r\n          };\r\n          if (parser.sourceFile)\r\n              node.loc.source = sourceFile;\r\n      }\r\n      return node;\r\n  }\r\n  function parseStatementList(parser, context, scope) {\r\n      nextToken(parser, context | 32768 | 1073741824);\r\n      const statements = [];\r\n      while (parser.token === 134283267) {\r\n          const { index, tokenPos, tokenValue, linePos, colPos, token } = parser;\r\n          const expr = parseLiteral(parser, context);\r\n          if (isValidStrictMode(parser, index, tokenPos, tokenValue))\r\n              context |= 1024;\r\n          statements.push(parseDirective(parser, context, expr, token, tokenPos, linePos, colPos));\r\n      }\r\n      while (parser.token !== 1048576) {\r\n          statements.push(parseStatementListItem(parser, context, scope, 4, {}, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return statements;\r\n  }\r\n  function parseModuleItemList(parser, context, scope) {\r\n      nextToken(parser, context | 32768);\r\n      const statements = [];\r\n      if (context & 8) {\r\n          while (parser.token === 134283267) {\r\n              const { tokenPos, linePos, colPos, token } = parser;\r\n              statements.push(parseDirective(parser, context, parseLiteral(parser, context), token, tokenPos, linePos, colPos));\r\n          }\r\n      }\r\n      while (parser.token !== 1048576) {\r\n          statements.push(parseModuleItem(parser, context, scope, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return statements;\r\n  }\r\n  function parseModuleItem(parser, context, scope, start, line, column) {\r\n      switch (parser.token) {\r\n          case 20563:\r\n              return parseExportDeclaration(parser, context, scope, start, line, column);\r\n          case 86105:\r\n              return parseImportDeclaration(parser, context, scope, start, line, column);\r\n          case 130:\r\n              return parseDecorators(parser, context);\r\n          default:\r\n              return parseStatementListItem(parser, context, scope, 4, {}, start, line, column);\r\n      }\r\n  }\r\n  function parseStatementListItem(parser, context, scope, origin, labels, start, line, column) {\r\n      switch (parser.token) {\r\n          case 86103:\r\n              return parseFunctionDeclaration(parser, context, scope, origin, 1, 0, 0, start, line, column);\r\n          case 130:\r\n          case 86093:\r\n              return parseClassDeclaration(parser, context, scope, 0, start, line, column);\r\n          case 86089:\r\n              return parseLexicalDeclaration(parser, context, scope, 16, 0, start, line, column);\r\n          case 241736:\r\n              return parseLetIdentOrVarDeclarationStatement(parser, context, scope, origin, start, line, column);\r\n          case 20563:\r\n              report(parser, 100, 'export');\r\n          case 86105:\r\n              nextToken(parser, context);\r\n              switch (parser.token) {\r\n                  case 67174411:\r\n                      return parseImportCallDeclaration(parser, context, start, line, column);\r\n                  case 67108877:\r\n                      return parseImportMetaDeclaration(parser, context, start, line, column);\r\n                  default:\r\n                      report(parser, 100, 'import');\r\n              }\r\n          case 143468:\r\n              return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context, scope, origin, labels, 1, start, line, column);\r\n          default:\r\n              return parseStatement(parser, context, scope, origin, labels, 1, start, line, column);\r\n      }\r\n  }\r\n  function parseStatement(parser, context, scope, origin, labels, allowFuncDecl, start, line, column) {\r\n      switch (parser.token) {\r\n          case 86087:\r\n              return parseVariableStatement(parser, context, scope, 0, start, line, column);\r\n          case 20571:\r\n              return parseReturnStatement(parser, context, start, line, column);\r\n          case 20568:\r\n              return parseIfStatement(parser, context, scope, labels, start, line, column);\r\n          case 20566:\r\n              return parseForStatement(parser, context, scope, labels, start, line, column);\r\n          case 20561:\r\n              return parseDoWhileStatement(parser, context, scope, labels, start, line, column);\r\n          case 20577:\r\n              return parseWhileStatement(parser, context, scope, labels, start, line, column);\r\n          case 86109:\r\n              return parseSwitchStatement(parser, context, scope, labels, start, line, column);\r\n          case 1074790417:\r\n              return parseEmptyStatement(parser, context, start, line, column);\r\n          case 2162700:\r\n              return parseBlock(parser, context, scope ? addChildScope(scope, 2) : scope, labels, start, line, column);\r\n          case 86111:\r\n              return parseThrowStatement(parser, context, start, line, column);\r\n          case 20554:\r\n              return parseBreakStatement(parser, context, labels, start, line, column);\r\n          case 20558:\r\n              return parseContinueStatement(parser, context, labels, start, line, column);\r\n          case 20576:\r\n              return parseTryStatement(parser, context, scope, labels, start, line, column);\r\n          case 20578:\r\n              return parseWithStatement(parser, context, scope, labels, start, line, column);\r\n          case 20559:\r\n              return parseDebuggerStatement(parser, context, start, line, column);\r\n          case 143468:\r\n              return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context, scope, origin, labels, 0, start, line, column);\r\n          case 20556:\r\n              report(parser, 156);\r\n          case 20565:\r\n              report(parser, 157);\r\n          case 86103:\r\n              report(parser, context & 1024\r\n                  ? 73\r\n                  : (context & 256) < 1\r\n                      ? 75\r\n                      : 74);\r\n          case 86093:\r\n              report(parser, 76);\r\n          default:\r\n              return parseExpressionOrLabelledStatement(parser, context, scope, origin, labels, allowFuncDecl, start, line, column);\r\n      }\r\n  }\r\n  function parseExpressionOrLabelledStatement(parser, context, scope, origin, labels, allowFuncDecl, start, line, column) {\r\n      const { tokenValue, token } = parser;\r\n      let expr;\r\n      switch (token) {\r\n          case 241736:\r\n              expr = parseIdentifier(parser, context, 0);\r\n              if (context & 1024)\r\n                  report(parser, 82);\r\n              if (parser.token === 69271571)\r\n                  report(parser, 81);\r\n              break;\r\n          default:\r\n              expr = parsePrimaryExpression(parser, context, 2, 0, 1, 0, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      if (token & 143360 && parser.token === 21) {\r\n          return parseLabelledStatement(parser, context, scope, origin, labels, tokenValue, expr, token, allowFuncDecl, start, line, column);\r\n      }\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      if (parser.token === 1073741842) {\r\n          expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n      }\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseBlock(parser, context, scope, labels, start, line, column) {\r\n      const body = [];\r\n      consume(parser, context | 32768, 2162700);\r\n      while (parser.token !== 1074790415) {\r\n          body.push(parseStatementListItem(parser, context, scope, 2, { $: labels }, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      consume(parser, context | 32768, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'BlockStatement',\r\n          body\r\n      });\r\n  }\r\n  function parseReturnStatement(parser, context, start, line, column) {\r\n      if ((context & 32) < 1 && context & 8192)\r\n          report(parser, 89);\r\n      nextToken(parser, context | 32768);\r\n      const argument = parser.flags & 1 || parser.token & 1048576\r\n          ? null\r\n          : parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.line, parser.column);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ReturnStatement',\r\n          argument\r\n      });\r\n  }\r\n  function parseExpressionStatement(parser, context, expression, start, line, column) {\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ExpressionStatement',\r\n          expression\r\n      });\r\n  }\r\n  function parseLabelledStatement(parser, context, scope, origin, labels, value, expr, token, allowFuncDecl, start, line, column) {\r\n      validateBindingIdentifier(parser, context, 0, token, 1);\r\n      validateAndDeclareLabel(parser, labels, value);\r\n      nextToken(parser, context | 32768);\r\n      const body = allowFuncDecl &&\r\n          (context & 1024) < 1 &&\r\n          context & 256 &&\r\n          parser.token === 86103\r\n          ? parseFunctionDeclaration(parser, context, addChildScope(scope, 2), origin, 0, 0, 0, parser.tokenPos, parser.linePos, parser.colPos)\r\n          : parseStatement(parser, context, scope, origin, labels, allowFuncDecl, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'LabeledStatement',\r\n          label: expr,\r\n          body\r\n      });\r\n  }\r\n  function parseAsyncArrowOrAsyncFunctionDeclaration(parser, context, scope, origin, labels, allowFuncDecl, start, line, column) {\r\n      const { token, tokenValue } = parser;\r\n      let expr = parseIdentifier(parser, context, 0);\r\n      if (parser.token === 21) {\r\n          return parseLabelledStatement(parser, context, scope, origin, labels, tokenValue, expr, token, 1, start, line, column);\r\n      }\r\n      const asyncNewLine = parser.flags & 1;\r\n      if (!asyncNewLine) {\r\n          if (parser.token === 86103) {\r\n              if (!allowFuncDecl)\r\n                  report(parser, 119);\r\n              return parseFunctionDeclaration(parser, context, scope, origin, 1, 0, 1, start, line, column);\r\n          }\r\n          if ((parser.token & 143360) === 143360) {\r\n              expr = parseAsyncArrowAfterIdent(parser, context, 1, start, line, column);\r\n              if (parser.token === 1073741842)\r\n                  expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n              return parseExpressionStatement(parser, context, expr, start, line, column);\r\n          }\r\n      }\r\n      if (parser.token === 67174411) {\r\n          expr = parseAsyncArrowOrCallExpression(parser, context, expr, 1, 1, 0, asyncNewLine, start, line, column);\r\n      }\r\n      else {\r\n          if (parser.token === 10) {\r\n              classifyIdentifier(parser, context, token, 1);\r\n              expr = parseArrowFromIdentifier(parser, context, parser.tokenValue, expr, 0, 1, 0, start, line, column);\r\n          }\r\n          parser.assignable = 1;\r\n      }\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      if (parser.token === 1073741842)\r\n          expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n      expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      parser.assignable = 1;\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseDirective(parser, context, expression, token, start, line, column) {\r\n      const { tokenRaw } = parser;\r\n      if (token !== 1074790417) {\r\n          parser.assignable = 2;\r\n          expression = parseMemberOrUpdateExpression(parser, context, expression, 0, start, line, column);\r\n          if (parser.token !== 1074790417) {\r\n              expression = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expression);\r\n              if (parser.token === 1073741842) {\r\n                  expression = parseSequenceExpression(parser, context, 0, start, line, column, expression);\r\n              }\r\n          }\r\n          matchOrInsertSemicolon(parser, context | 32768);\r\n      }\r\n      return context & 8\r\n          ? finishNode(parser, context, start, line, column, {\r\n              type: 'ExpressionStatement',\r\n              expression,\r\n              directive: tokenRaw.slice(1, -1)\r\n          })\r\n          : finishNode(parser, context, start, line, column, {\r\n              type: 'ExpressionStatement',\r\n              expression\r\n          });\r\n  }\r\n  function parseEmptyStatement(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'EmptyStatement'\r\n      });\r\n  }\r\n  function parseThrowStatement(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      if (parser.flags & 1)\r\n          report(parser, 87);\r\n      const argument = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ThrowStatement',\r\n          argument\r\n      });\r\n  }\r\n  function parseIfStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context | 32768, 67174411);\r\n      parser.assignable = 1;\r\n      const test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.line, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const consequent = parseConsequentOrAlternative(parser, context, scope, labels, parser.tokenPos, parser.linePos, parser.colPos);\r\n      let alternate = null;\r\n      if (parser.token === 20562) {\r\n          nextToken(parser, context | 32768);\r\n          alternate = parseConsequentOrAlternative(parser, context, scope, labels, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'IfStatement',\r\n          test,\r\n          consequent,\r\n          alternate\r\n      });\r\n  }\r\n  function parseConsequentOrAlternative(parser, context, scope, labels, start, line, column) {\r\n      return context & 1024 ||\r\n          (context & 256) < 1 ||\r\n          parser.token !== 86103\r\n          ? parseStatement(parser, context, scope, 0, { $: labels }, 0, parser.tokenPos, parser.linePos, parser.colPos)\r\n          : parseFunctionDeclaration(parser, context, addChildScope(scope, 2), 0, 0, 0, 0, start, line, column);\r\n  }\r\n  function parseSwitchStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context | 32768, 67174411);\r\n      const discriminant = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 16);\r\n      consume(parser, context, 2162700);\r\n      const cases = [];\r\n      let seenDefault = 0;\r\n      if (scope)\r\n          scope = addChildScope(scope, 8);\r\n      while (parser.token !== 1074790415) {\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          let test = null;\r\n          const consequent = [];\r\n          if (consumeOpt(parser, context | 32768, 20555)) {\r\n              test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          }\r\n          else {\r\n              consume(parser, context | 32768, 20560);\r\n              if (seenDefault)\r\n                  report(parser, 86);\r\n              seenDefault = 1;\r\n          }\r\n          consume(parser, context | 32768, 21);\r\n          while (parser.token !== 20555 &&\r\n              parser.token !== 1074790415 &&\r\n              parser.token !== 20560) {\r\n              consequent.push(parseStatementListItem(parser, context | 4096, scope, 2, {\r\n                  $: labels\r\n              }, parser.tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          cases.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n              type: 'SwitchCase',\r\n              test,\r\n              consequent\r\n          }));\r\n      }\r\n      consume(parser, context | 32768, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'SwitchStatement',\r\n          discriminant,\r\n          cases\r\n      });\r\n  }\r\n  function parseWhileStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context | 32768, 67174411);\r\n      const test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const body = parseIterationStatementBody(parser, context, scope, labels);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'WhileStatement',\r\n          test,\r\n          body\r\n      });\r\n  }\r\n  function parseIterationStatementBody(parser, context, scope, labels) {\r\n      return parseStatement(parser, ((context | 134217728) ^ 134217728) | 131072, scope, 0, { loop: 1, $: labels }, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n  }\r\n  function parseContinueStatement(parser, context, labels, start, line, column) {\r\n      if ((context & 131072) < 1)\r\n          report(parser, 65);\r\n      nextToken(parser, context);\r\n      let label = null;\r\n      if ((parser.flags & 1) < 1 && parser.token & 143360) {\r\n          const { tokenValue } = parser;\r\n          label = parseIdentifier(parser, context | 32768, 0);\r\n          if (!isValidLabel(parser, labels, tokenValue, 1))\r\n              report(parser, 134, tokenValue);\r\n      }\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ContinueStatement',\r\n          label\r\n      });\r\n  }\r\n  function parseBreakStatement(parser, context, labels, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let label = null;\r\n      if ((parser.flags & 1) < 1 && parser.token & 143360) {\r\n          const { tokenValue } = parser;\r\n          label = parseIdentifier(parser, context | 32768, 0);\r\n          if (!isValidLabel(parser, labels, tokenValue, 0))\r\n              report(parser, 134, tokenValue);\r\n      }\r\n      else if ((context & (4096 | 131072)) < 1) {\r\n          report(parser, 66);\r\n      }\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'BreakStatement',\r\n          label\r\n      });\r\n  }\r\n  function parseWithStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      if (context & 1024)\r\n          report(parser, 88);\r\n      consume(parser, context | 32768, 67174411);\r\n      const object = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const body = parseStatement(parser, context, scope, 2, labels, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'WithStatement',\r\n          object,\r\n          body\r\n      });\r\n  }\r\n  function parseDebuggerStatement(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'DebuggerStatement'\r\n      });\r\n  }\r\n  function parseTryStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const firstScope = scope ? addChildScope(scope, 32) : void 0;\r\n      const block = parseBlock(parser, context, firstScope, { $: labels }, parser.tokenPos, parser.linePos, parser.colPos);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      const handler = consumeOpt(parser, context | 32768, 20556)\r\n          ? parseCatchBlock(parser, context, scope, labels, tokenPos, linePos, colPos)\r\n          : null;\r\n      let finalizer = null;\r\n      if (parser.token === 20565) {\r\n          nextToken(parser, context | 32768);\r\n          const finalizerScope = firstScope ? addChildScope(scope, 4) : void 0;\r\n          finalizer = parseBlock(parser, context, finalizerScope, { $: labels }, tokenPos, linePos, colPos);\r\n      }\r\n      if (!handler && !finalizer) {\r\n          report(parser, 85);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'TryStatement',\r\n          block,\r\n          handler,\r\n          finalizer\r\n      });\r\n  }\r\n  function parseCatchBlock(parser, context, scope, labels, start, line, column) {\r\n      let param = null;\r\n      let additionalScope = scope;\r\n      if (consumeOpt(parser, context, 67174411)) {\r\n          if (scope)\r\n              scope = addChildScope(scope, 4);\r\n          param = parseBindingPattern(parser, context, scope, (parser.token & 2097152) === 2097152\r\n              ? 256\r\n              : 512, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          if (parser.token === 1073741842) {\r\n              report(parser, 83);\r\n          }\r\n          else if (parser.token === 1077936157) {\r\n              report(parser, 84);\r\n          }\r\n          consume(parser, context | 32768, 16);\r\n          if (scope)\r\n              additionalScope = addChildScope(scope, 64);\r\n      }\r\n      const body = parseBlock(parser, context, additionalScope, { $: labels }, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'CatchClause',\r\n          param,\r\n          body\r\n      });\r\n  }\r\n  function parseDoWhileStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const body = parseIterationStatementBody(parser, context, scope, labels);\r\n      consume(parser, context, 20577);\r\n      consume(parser, context | 32768, 67174411);\r\n      const test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      matchOrInsertSemicolon(parser, context | 32768, context & 536870912);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'DoWhileStatement',\r\n          body,\r\n          test\r\n      });\r\n  }\r\n  function parseLetIdentOrVarDeclarationStatement(parser, context, scope, origin, start, line, column) {\r\n      const { token, tokenValue } = parser;\r\n      let expr = parseIdentifier(parser, context, 0);\r\n      if (parser.token & (143360 | 2097152)) {\r\n          const declarations = parseVariableDeclarationList(parser, context, scope, 8, 0);\r\n          matchOrInsertSemicolon(parser, context | 32768);\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'VariableDeclaration',\r\n              kind: 'let',\r\n              declarations\r\n          });\r\n      }\r\n      parser.assignable = 1;\r\n      if (context & 1024)\r\n          report(parser, 82);\r\n      if (parser.token === 21) {\r\n          return parseLabelledStatement(parser, context, scope, origin, {}, tokenValue, expr, token, 0, start, line, column);\r\n      }\r\n      if (parser.token === 10) {\r\n          let scope = void 0;\r\n          if (context & 64)\r\n              scope = createArrowHeadParsingScope(parser, context, tokenValue);\r\n          parser.flags = (parser.flags | 128) ^ 128;\r\n          expr = parseArrowFunctionExpression(parser, context, scope, [expr], 0, start, line, column);\r\n      }\r\n      else {\r\n          expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n          expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      }\r\n      if (parser.token === 1073741842) {\r\n          expr = parseSequenceExpression(parser, context, 0, start, line, column, expr);\r\n      }\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseLexicalDeclaration(parser, context, scope, kind, origin, start, line, column) {\r\n      nextToken(parser, context);\r\n      const declarations = parseVariableDeclarationList(parser, context, scope, kind, origin);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'VariableDeclaration',\r\n          kind: kind & 8 ? 'let' : 'const',\r\n          declarations\r\n      });\r\n  }\r\n  function parseVariableStatement(parser, context, scope, origin, start, line, column) {\r\n      nextToken(parser, context);\r\n      const declarations = parseVariableDeclarationList(parser, context, scope, 4, origin);\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'VariableDeclaration',\r\n          kind: 'var',\r\n          declarations\r\n      });\r\n  }\r\n  function parseVariableDeclarationList(parser, context, scope, kind, origin) {\r\n      let bindingCount = 1;\r\n      const list = [parseVariableDeclaration(parser, context, scope, kind, origin)];\r\n      while (consumeOpt(parser, context, 1073741842)) {\r\n          bindingCount++;\r\n          list.push(parseVariableDeclaration(parser, context, scope, kind, origin));\r\n      }\r\n      if (bindingCount > 1 && origin & 32 && parser.token & 262144) {\r\n          report(parser, 58, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      return list;\r\n  }\r\n  function parseVariableDeclaration(parser, context, scope, kind, origin) {\r\n      const { token, tokenPos, linePos, colPos } = parser;\r\n      let init = null;\r\n      const id = parseBindingPattern(parser, context, scope, kind, origin, tokenPos, linePos, colPos);\r\n      if (parser.token === 1077936157) {\r\n          nextToken(parser, context | 32768);\r\n          init = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          if (origin & 32 || (token & 2097152) < 1) {\r\n              if (parser.token === 274546 ||\r\n                  (parser.token === 8738865 &&\r\n                      (token & 2097152 ||\r\n                          (kind & 4) < 1 ||\r\n                          (context & 256) < 1 ||\r\n                          context & 1024))) {\r\n                  reportMessageAt(tokenPos, parser.line, parser.index - 3, 57, parser.token === 274546 ? 'of' : 'in');\r\n              }\r\n          }\r\n      }\r\n      else if ((kind & 16 || (token & 2097152) > 0) &&\r\n          (parser.token & 262144) !== 262144) {\r\n          report(parser, 56, kind & 16 ? 'const' : 'destructuring');\r\n      }\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'VariableDeclarator',\r\n          id,\r\n          init\r\n      });\r\n  }\r\n  function parseForStatement(parser, context, scope, labels, start, line, column) {\r\n      nextToken(parser, context);\r\n      const forAwait = (context & 4194304) > 0 && consumeOpt(parser, context, 209005);\r\n      consume(parser, context | 32768, 67174411);\r\n      if (scope)\r\n          scope = addChildScope(scope, 1);\r\n      let test = null;\r\n      let update = null;\r\n      let destructible = 0;\r\n      let init = null;\r\n      let isVarDecl = parser.token === 86087 || parser.token === 241736 || parser.token === 86089;\r\n      let right;\r\n      const { token, tokenPos, linePos, colPos } = parser;\r\n      if (isVarDecl) {\r\n          if (token === 241736) {\r\n              init = parseIdentifier(parser, context, 0);\r\n              if (parser.token & (143360 | 2097152)) {\r\n                  if (parser.token === 8738865) {\r\n                      if (context & 1024)\r\n                          report(parser, 64);\r\n                  }\r\n                  else {\r\n                      init = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                          type: 'VariableDeclaration',\r\n                          kind: 'let',\r\n                          declarations: parseVariableDeclarationList(parser, context | 134217728, scope, 8, 32)\r\n                      });\r\n                  }\r\n                  parser.assignable = 1;\r\n              }\r\n              else if (context & 1024) {\r\n                  report(parser, 64);\r\n              }\r\n              else {\r\n                  isVarDecl = false;\r\n                  parser.assignable = 1;\r\n                  init = parseMemberOrUpdateExpression(parser, context, init, 0, tokenPos, linePos, colPos);\r\n                  if (parser.token === 274546)\r\n                      report(parser, 111);\r\n              }\r\n          }\r\n          else {\r\n              nextToken(parser, context);\r\n              init = finishNode(parser, context, tokenPos, linePos, colPos, token === 86087\r\n                  ? {\r\n                      type: 'VariableDeclaration',\r\n                      kind: 'var',\r\n                      declarations: parseVariableDeclarationList(parser, context | 134217728, scope, 4, 32)\r\n                  }\r\n                  : {\r\n                      type: 'VariableDeclaration',\r\n                      kind: 'const',\r\n                      declarations: parseVariableDeclarationList(parser, context | 134217728, scope, 16, 32)\r\n                  });\r\n              parser.assignable = 1;\r\n          }\r\n      }\r\n      else if (token === 1074790417) {\r\n          if (forAwait)\r\n              report(parser, 79);\r\n      }\r\n      else if ((token & 2097152) === 2097152) {\r\n          init =\r\n              token === 2162700\r\n                  ? parseObjectLiteralOrPattern(parser, context, void 0, 1, 0, 0, 2, 32, tokenPos, linePos, colPos)\r\n                  : parseArrayExpressionOrPattern(parser, context, void 0, 1, 0, 0, 2, 32, tokenPos, linePos, colPos);\r\n          destructible = parser.destructible;\r\n          if (context & 256 && destructible & 64) {\r\n              report(parser, 60);\r\n          }\r\n          parser.assignable =\r\n              destructible & 16 ? 2 : 1;\r\n          init = parseMemberOrUpdateExpression(parser, context | 134217728, init, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      else {\r\n          init = parseLeftHandSideExpression(parser, context | 134217728, 1, 0, 1, tokenPos, linePos, colPos);\r\n      }\r\n      if ((parser.token & 262144) === 262144) {\r\n          if (parser.token === 274546) {\r\n              if (parser.assignable & 2)\r\n                  report(parser, 77, forAwait ? 'await' : 'of');\r\n              reinterpretToPattern(parser, init);\r\n              nextToken(parser, context | 32768);\r\n              right = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              consume(parser, context | 32768, 16);\r\n              const body = parseIterationStatementBody(parser, context, scope, labels);\r\n              return finishNode(parser, context, start, line, column, {\r\n                  type: 'ForOfStatement',\r\n                  left: init,\r\n                  right,\r\n                  body,\r\n                  await: forAwait\r\n              });\r\n          }\r\n          if (parser.assignable & 2)\r\n              report(parser, 77, 'in');\r\n          reinterpretToPattern(parser, init);\r\n          nextToken(parser, context | 32768);\r\n          if (forAwait)\r\n              report(parser, 79);\r\n          right = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          consume(parser, context | 32768, 16);\r\n          const body = parseIterationStatementBody(parser, context, scope, labels);\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'ForInStatement',\r\n              body,\r\n              left: init,\r\n              right\r\n          });\r\n      }\r\n      if (forAwait)\r\n          report(parser, 79);\r\n      if (!isVarDecl) {\r\n          if (destructible & 8 && parser.token !== 1077936157) {\r\n              report(parser, 77, 'loop');\r\n          }\r\n          init = parseAssignmentExpression(parser, context | 134217728, 0, 0, tokenPos, linePos, colPos, init);\r\n      }\r\n      if (parser.token === 1073741842)\r\n          init = parseSequenceExpression(parser, context, 0, parser.tokenPos, parser.linePos, parser.colPos, init);\r\n      consume(parser, context | 32768, 1074790417);\r\n      if (parser.token !== 1074790417)\r\n          test = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 1074790417);\r\n      if (parser.token !== 16)\r\n          update = parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 16);\r\n      const body = parseIterationStatementBody(parser, context, scope, labels);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ForStatement',\r\n          init,\r\n          test,\r\n          update,\r\n          body\r\n      });\r\n  }\r\n  function parseRestrictedIdentifier(parser, context, scope) {\r\n      if (!isValidIdentifier(context, parser.token))\r\n          report(parser, 114);\r\n      if ((parser.token & 537079808) === 537079808)\r\n          report(parser, 115);\r\n      if (scope)\r\n          addBlockName(parser, context, scope, parser.tokenValue, 8, 0);\r\n      return parseIdentifier(parser, context, 0);\r\n  }\r\n  function parseImportDeclaration(parser, context, scope, start, line, column) {\r\n      nextToken(parser, context);\r\n      let source = null;\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      let specifiers = [];\r\n      if (parser.token === 134283267) {\r\n          source = parseLiteral(parser, context);\r\n      }\r\n      else {\r\n          if (parser.token & 143360) {\r\n              const local = parseRestrictedIdentifier(parser, context, scope);\r\n              specifiers = [\r\n                  finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                      type: 'ImportDefaultSpecifier',\r\n                      local\r\n                  })\r\n              ];\r\n              if (consumeOpt(parser, context, 1073741842)) {\r\n                  switch (parser.token) {\r\n                      case 8457011:\r\n                          specifiers.push(parseImportNamespaceSpecifier(parser, context, scope));\r\n                          break;\r\n                      case 2162700:\r\n                          parseImportSpecifierOrNamedImports(parser, context, scope, specifiers);\r\n                          break;\r\n                      default:\r\n                          report(parser, 104);\r\n                  }\r\n              }\r\n          }\r\n          else {\r\n              switch (parser.token) {\r\n                  case 8457011:\r\n                      specifiers = [parseImportNamespaceSpecifier(parser, context, scope)];\r\n                      break;\r\n                  case 2162700:\r\n                      parseImportSpecifierOrNamedImports(parser, context, scope, specifiers);\r\n                      break;\r\n                  case 67174411:\r\n                      return parseImportCallDeclaration(parser, context, start, line, column);\r\n                  case 67108877:\r\n                      if (context & 1) {\r\n                          return parseImportMetaDeclaration(parser, context, start, line, column);\r\n                      }\r\n                  default:\r\n                      report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n              }\r\n          }\r\n          source = parseModuleSpecifier(parser, context);\r\n      }\r\n      matchOrInsertSemicolon(parser, context | 32768);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ImportDeclaration',\r\n          specifiers,\r\n          source\r\n      });\r\n  }\r\n  function parseImportNamespaceSpecifier(parser, context, scope) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      consume(parser, context, 12395);\r\n      if ((parser.token & 134217728) === 134217728) {\r\n          reportMessageAt(tokenPos, parser.line, parser.index, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'ImportNamespaceSpecifier',\r\n          local: parseRestrictedIdentifier(parser, context, scope)\r\n      });\r\n  }\r\n  function parseModuleSpecifier(parser, context) {\r\n      consumeOpt(parser, context, 12401);\r\n      if (parser.token !== 134283267)\r\n          report(parser, 102, 'Import');\r\n      return parseLiteral(parser, context);\r\n  }\r\n  function parseImportSpecifierOrNamedImports(parser, context, scope, specifiers) {\r\n      nextToken(parser, context);\r\n      while (parser.token & 143360) {\r\n          let { token, tokenValue, tokenPos, linePos, colPos } = parser;\r\n          const imported = parseIdentifier(parser, context, 0);\r\n          let local;\r\n          if (consumeOpt(parser, context, 12395)) {\r\n              if ((parser.token & 134217728) === 134217728 || parser.token === 1073741842) {\r\n                  report(parser, 103);\r\n              }\r\n              else {\r\n                  validateBindingIdentifier(parser, context, 16, parser.token, 0);\r\n              }\r\n              tokenValue = parser.tokenValue;\r\n              local = parseIdentifier(parser, context, 0);\r\n          }\r\n          else {\r\n              validateBindingIdentifier(parser, context, 16, token, 0);\r\n              local = imported;\r\n          }\r\n          if (scope)\r\n              addBlockName(parser, context, scope, tokenValue, 8, 0);\r\n          specifiers.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n              type: 'ImportSpecifier',\r\n              local,\r\n              imported\r\n          }));\r\n          if (parser.token !== 1074790415)\r\n              consume(parser, context, 1073741842);\r\n      }\r\n      consume(parser, context, 1074790415);\r\n      return specifiers;\r\n  }\r\n  function parseImportMetaDeclaration(parser, context, start, line, column) {\r\n      let expr = parseImportMetaExpression(parser, context, finishNode(parser, context, start, line, column, {\r\n          type: 'Identifier',\r\n          name: 'import'\r\n      }), start, line, column);\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      expr = parseAssignmentExpression(parser, context, 0, 0, start, line, column, expr);\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseImportCallDeclaration(parser, context, start, line, column) {\r\n      let expr = parseImportExpression(parser, context, 0, start, line, column);\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      return parseExpressionStatement(parser, context, expr, start, line, column);\r\n  }\r\n  function parseExportDeclaration(parser, context, scope, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let specifiers = [];\r\n      let declaration = null;\r\n      let source = null;\r\n      let key;\r\n      if (consumeOpt(parser, context | 32768, 20560)) {\r\n          switch (parser.token) {\r\n              case 86103: {\r\n                  declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 1, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  break;\r\n              }\r\n              case 130:\r\n              case 86093:\r\n                  declaration = parseClassDeclaration(parser, context, scope, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  break;\r\n              case 143468:\r\n                  const { tokenPos, linePos, colPos } = parser;\r\n                  declaration = parseIdentifier(parser, context, 0);\r\n                  const { flags } = parser;\r\n                  if ((flags & 1) < 1) {\r\n                      if (parser.token === 86103) {\r\n                          declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 1, 1, tokenPos, linePos, colPos);\r\n                      }\r\n                      else {\r\n                          if (parser.token === 67174411) {\r\n                              declaration = parseAsyncArrowOrCallExpression(parser, context, declaration, 1, 1, 0, flags, tokenPos, linePos, colPos);\r\n                              declaration = parseMemberOrUpdateExpression(parser, context, declaration, 0, tokenPos, linePos, colPos);\r\n                              declaration = parseAssignmentExpression(parser, context, 0, 0, tokenPos, linePos, colPos, declaration);\r\n                          }\r\n                          else if (parser.token & 143360) {\r\n                              if (scope)\r\n                                  scope = createArrowHeadParsingScope(parser, context, parser.tokenValue);\r\n                              declaration = parseIdentifier(parser, context, 0);\r\n                              declaration = parseArrowFunctionExpression(parser, context, scope, [declaration], 1, tokenPos, linePos, colPos);\r\n                          }\r\n                      }\r\n                  }\r\n                  break;\r\n              default:\r\n                  declaration = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  matchOrInsertSemicolon(parser, context | 32768);\r\n          }\r\n          if (scope)\r\n              declareUnboundVariable(parser, 'default');\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'ExportDefaultDeclaration',\r\n              declaration\r\n          });\r\n      }\r\n      switch (parser.token) {\r\n          case 8457011: {\r\n              nextToken(parser, context);\r\n              const isNamedDeclaration = consumeOpt(parser, context, 12395);\r\n              if (isNamedDeclaration) {\r\n                  if (scope)\r\n                      declareUnboundVariable(parser, parser.tokenValue);\r\n                  specifiers = [\r\n                      finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                          type: 'ExportNamespaceSpecifier',\r\n                          specifier: parseIdentifier(parser, context, 0)\r\n                      })\r\n                  ];\r\n              }\r\n              consume(parser, context, 12401);\r\n              if (parser.token !== 134283267)\r\n                  report(parser, 102, 'Export');\r\n              source = parseLiteral(parser, context);\r\n              matchOrInsertSemicolon(parser, context | 32768);\r\n              return isNamedDeclaration\r\n                  ? finishNode(parser, context, start, line, column, {\r\n                      type: 'ExportNamedDeclaration',\r\n                      source,\r\n                      specifiers\r\n                  })\r\n                  : finishNode(parser, context, start, line, column, {\r\n                      type: 'ExportAllDeclaration',\r\n                      source\r\n                  });\r\n          }\r\n          case 2162700: {\r\n              nextToken(parser, context);\r\n              const tmpExportedNames = [];\r\n              const tmpExportedBindings = [];\r\n              while (parser.token & 143360) {\r\n                  const { tokenPos, tokenValue, linePos, colPos } = parser;\r\n                  const local = parseIdentifier(parser, context, 0);\r\n                  let exported;\r\n                  if (parser.token === 12395) {\r\n                      nextToken(parser, context);\r\n                      if ((parser.token & 134217728) === 134217728) {\r\n                          report(parser, 103);\r\n                      }\r\n                      if (scope) {\r\n                          tmpExportedNames.push(parser.tokenValue);\r\n                          tmpExportedBindings.push(tokenValue);\r\n                      }\r\n                      exported = parseIdentifier(parser, context, 0);\r\n                  }\r\n                  else {\r\n                      if (scope) {\r\n                          tmpExportedNames.push(parser.tokenValue);\r\n                          tmpExportedBindings.push(parser.tokenValue);\r\n                      }\r\n                      exported = local;\r\n                  }\r\n                  specifiers.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                      type: 'ExportSpecifier',\r\n                      local,\r\n                      exported\r\n                  }));\r\n                  if (parser.token !== 1074790415)\r\n                      consume(parser, context, 1073741842);\r\n              }\r\n              consume(parser, context, 1074790415);\r\n              if (consumeOpt(parser, context, 12401)) {\r\n                  if (parser.token !== 134283267)\r\n                      report(parser, 102, 'Export');\r\n                  source = parseLiteral(parser, context);\r\n              }\r\n              else if (scope) {\r\n                  let i = 0;\r\n                  let iMax = tmpExportedNames.length;\r\n                  for (; i < iMax; i++) {\r\n                      declareUnboundVariable(parser, tmpExportedNames[i]);\r\n                  }\r\n                  i = 0;\r\n                  iMax = tmpExportedBindings.length;\r\n                  for (; i < iMax; i++) {\r\n                      addBindingToExports(parser, tmpExportedBindings[i]);\r\n                  }\r\n              }\r\n              matchOrInsertSemicolon(parser, context | 32768);\r\n              break;\r\n          }\r\n          case 86093:\r\n              declaration = parseClassDeclaration(parser, context, scope, 2, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 86103:\r\n              declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 2, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 241736:\r\n              declaration = parseLexicalDeclaration(parser, context, scope, 8, 64, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 86089:\r\n              declaration = parseLexicalDeclaration(parser, context, scope, 16, 64, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 86087:\r\n              declaration = parseVariableStatement(parser, context, scope, 64, parser.tokenPos, parser.linePos, parser.colPos);\r\n              break;\r\n          case 143468:\r\n              const { tokenPos, linePos, colPos } = parser;\r\n              nextToken(parser, context);\r\n              if ((parser.flags & 1) < 1 && parser.token === 86103) {\r\n                  declaration = parseFunctionDeclaration(parser, context, scope, 4, 1, 2, 1, tokenPos, linePos, colPos);\r\n                  if (scope) {\r\n                      key = declaration.id ? declaration.id.name : '';\r\n                      declareUnboundVariable(parser, key);\r\n                  }\r\n                  break;\r\n              }\r\n          default:\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ExportNamedDeclaration',\r\n          declaration,\r\n          specifiers,\r\n          source\r\n      });\r\n  }\r\n  function parseExpression(parser, context, canAssign, isPattern, inGroup, start, line, column) {\r\n      let expr = parsePrimaryExpression(parser, context, 2, 0, canAssign, isPattern, inGroup, 1, start, line, column);\r\n      expr = parseMemberOrUpdateExpression(parser, context, expr, inGroup, start, line, column);\r\n      return parseAssignmentExpression(parser, context, inGroup, 0, start, line, column, expr);\r\n  }\r\n  function parseSequenceExpression(parser, context, inGroup, start, line, column, expr) {\r\n      const expressions = [expr];\r\n      while (consumeOpt(parser, context | 32768, 1073741842)) {\r\n          expressions.push(parseExpression(parser, context, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'SequenceExpression',\r\n          expressions\r\n      });\r\n  }\r\n  function parseExpressions(parser, context, inGroup, canAssign, start, line, column) {\r\n      const expr = parseExpression(parser, context, canAssign, 0, inGroup, start, line, column);\r\n      return parser.token === 1073741842\r\n          ? parseSequenceExpression(parser, context, inGroup, start, line, column, expr)\r\n          : expr;\r\n  }\r\n  function parseAssignmentExpression(parser, context, inGroup, isPattern, start, line, column, left) {\r\n      const { token } = parser;\r\n      if ((token & 4194304) === 4194304) {\r\n          if (parser.assignable & 2)\r\n              report(parser, 24);\r\n          if ((!isPattern && token === 1077936157 && left.type === 'ArrayExpression') ||\r\n              left.type === 'ObjectExpression') {\r\n              reinterpretToPattern(parser, left);\r\n          }\r\n          nextToken(parser, context | 32768);\r\n          const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n          parser.assignable = 2;\r\n          return finishNode(parser, context, start, line, column, isPattern\r\n              ? {\r\n                  type: 'AssignmentPattern',\r\n                  left,\r\n                  right\r\n              }\r\n              : {\r\n                  type: 'AssignmentExpression',\r\n                  left,\r\n                  operator: KeywordDescTable[token & 255],\r\n                  right\r\n              });\r\n      }\r\n      if ((token & 8454144) === 8454144) {\r\n          left = parseBinaryExpression(parser, context, inGroup, start, line, column, 4, token, left);\r\n      }\r\n      if (consumeOpt(parser, context | 32768, 22)) {\r\n          left = parseConditionalExpression(parser, context, left, start, line, column);\r\n      }\r\n      return left;\r\n  }\r\n  function parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, start, line, column, left) {\r\n      const { token } = parser;\r\n      nextToken(parser, context | 32768);\r\n      const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      left = finishNode(parser, context, start, line, column, isPattern\r\n          ? {\r\n              type: 'AssignmentPattern',\r\n              left,\r\n              right\r\n          }\r\n          : {\r\n              type: 'AssignmentExpression',\r\n              left,\r\n              operator: KeywordDescTable[token & 255],\r\n              right\r\n          });\r\n      parser.assignable = 2;\r\n      return left;\r\n  }\r\n  function parseConditionalExpression(parser, context, test, start, line, column) {\r\n      const consequent = parseExpression(parser, (context | 134217728) ^ 134217728, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context | 32768, 21);\r\n      parser.assignable = 1;\r\n      const alternate = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ConditionalExpression',\r\n          test,\r\n          consequent,\r\n          alternate\r\n      });\r\n  }\r\n  function parseBinaryExpression(parser, context, inGroup, start, line, column, minPrec, operator, left) {\r\n      const bit = -((context & 134217728) > 0) & 8738865;\r\n      let t;\r\n      let prec;\r\n      parser.assignable = 2;\r\n      while (parser.token & 8454144) {\r\n          t = parser.token;\r\n          prec = t & 3840;\r\n          if ((t & 524288 && operator & 268435456) || (operator & 524288 && t & 268435456)) {\r\n              report(parser, 159);\r\n          }\r\n          if (prec + ((t === 8457270) << 8) - ((bit === t) << 12) <= minPrec)\r\n              break;\r\n          nextToken(parser, context | 32768);\r\n          left = finishNode(parser, context, start, line, column, {\r\n              type: t & 524288 ? 'LogicalExpression' : t & 268435456 ? 'CoalesceExpression' : 'BinaryExpression',\r\n              left,\r\n              right: parseBinaryExpression(parser, context, inGroup, parser.tokenPos, parser.linePos, parser.colPos, prec, t, parseLeftHandSideExpression(parser, context, 0, inGroup, 1, parser.tokenPos, parser.linePos, parser.colPos)),\r\n              operator: KeywordDescTable[t & 255]\r\n          });\r\n      }\r\n      if (parser.token === 1077936157)\r\n          report(parser, 24);\r\n      return left;\r\n  }\r\n  function parseUnaryExpression(parser, context, isLHS, start, line, column, inGroup) {\r\n      if (!isLHS)\r\n          report(parser, 0);\r\n      const unaryOperator = parser.token;\r\n      nextToken(parser, context | 32768);\r\n      const arg = parseLeftHandSideExpression(parser, context, 0, inGroup, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      if (parser.token === 8457270)\r\n          report(parser, 31);\r\n      if (context & 1024 && unaryOperator === 16863275) {\r\n          if (arg.type === 'Identifier') {\r\n              report(parser, 117);\r\n          }\r\n          else if (isPropertyWithPrivateFieldKey(arg)) {\r\n              report(parser, 123);\r\n          }\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'UnaryExpression',\r\n          operator: KeywordDescTable[unaryOperator & 255],\r\n          argument: arg,\r\n          prefix: true\r\n      });\r\n  }\r\n  function parseAsyncExpression(parser, context, inGroup, isLHS, canAssign, isPattern, inNew, start, line, column) {\r\n      const { token } = parser;\r\n      const expr = parseIdentifier(parser, context, isPattern);\r\n      const { flags } = parser;\r\n      if ((flags & 1) < 1) {\r\n          if (parser.token === 86103) {\r\n              return parseFunctionExpression(parser, context, 1, inGroup, start, line, column);\r\n          }\r\n          if ((parser.token & 143360) === 143360) {\r\n              if (!isLHS)\r\n                  report(parser, 0);\r\n              return parseAsyncArrowAfterIdent(parser, context, canAssign, start, line, column);\r\n          }\r\n      }\r\n      if (!inNew && parser.token === 67174411) {\r\n          return parseAsyncArrowOrCallExpression(parser, context, expr, canAssign, 1, 0, flags, start, line, column);\r\n      }\r\n      if (parser.token === 10) {\r\n          classifyIdentifier(parser, context, token, 1);\r\n          if (inNew)\r\n              report(parser, 48);\r\n          return parseArrowFromIdentifier(parser, context, parser.tokenValue, expr, inNew, canAssign, 0, start, line, column);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseYieldExpression(parser, context, inGroup, canAssign, start, line, column) {\r\n      if (inGroup)\r\n          parser.destructible |= 256;\r\n      if (context & 2097152) {\r\n          nextToken(parser, context | 32768);\r\n          if (context & 8388608)\r\n              report(parser, 30);\r\n          if (!canAssign)\r\n              report(parser, 24);\r\n          if (parser.token === 22)\r\n              report(parser, 120);\r\n          let argument = null;\r\n          let delegate = false;\r\n          if ((parser.flags & 1) < 1) {\r\n              delegate = consumeOpt(parser, context | 32768, 8457011);\r\n              if (parser.token & 65536 || delegate) {\r\n                  argument = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              }\r\n          }\r\n          parser.assignable = 2;\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'YieldExpression',\r\n              argument,\r\n              delegate\r\n          });\r\n      }\r\n      if (context & 1024)\r\n          report(parser, 94, 'yield');\r\n      return parseIdentifierOrArrow(parser, context, start, line, column);\r\n  }\r\n  function parseAwaitExpression(parser, context, inNew, inGroup, start, line, column) {\r\n      if (inGroup)\r\n          parser.destructible |= 128;\r\n      if (context & 4194304) {\r\n          if (inNew)\r\n              report(parser, 0);\r\n          if (context & 8388608) {\r\n              reportMessageAt(parser.index, parser.line, parser.index, 29);\r\n          }\r\n          nextToken(parser, context | 32768);\r\n          const argument = parseLeftHandSideExpression(parser, context, 0, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          parser.assignable = 2;\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'AwaitExpression',\r\n              argument\r\n          });\r\n      }\r\n      if (context & 2048)\r\n          report(parser, 107, 'Await');\r\n      return parseIdentifierOrArrow(parser, context, start, line, column);\r\n  }\r\n  function parseFunctionBody(parser, context, scope, origin, firstRestricted, scopeError) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      consume(parser, context | 32768, 2162700);\r\n      const body = [];\r\n      const prevContext = context;\r\n      if (parser.token !== 1074790415) {\r\n          while (parser.token === 134283267) {\r\n              const { index, tokenPos, tokenValue, token } = parser;\r\n              const expr = parseLiteral(parser, context);\r\n              if (isValidStrictMode(parser, index, tokenPos, tokenValue)) {\r\n                  context |= 1024;\r\n                  if (parser.flags & 128) {\r\n                      reportMessageAt(parser.index, parser.line, parser.tokenPos, 63);\r\n                  }\r\n                  if (parser.flags & 64) {\r\n                      reportMessageAt(parser.index, parser.line, parser.tokenPos, 8);\r\n                  }\r\n              }\r\n              body.push(parseDirective(parser, context, expr, token, tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          if (context & 1024) {\r\n              if (firstRestricted) {\r\n                  if ((firstRestricted & 537079808) === 537079808) {\r\n                      report(parser, 115);\r\n                  }\r\n                  if ((firstRestricted & 36864) === 36864) {\r\n                      report(parser, 38);\r\n                  }\r\n              }\r\n              if (parser.flags & 512)\r\n                  report(parser, 115);\r\n              if (parser.flags & 256)\r\n                  report(parser, 114);\r\n          }\r\n          if (context & 64 &&\r\n              scope &&\r\n              scopeError !== void 0 &&\r\n              (prevContext & 1024) < 1 &&\r\n              (context & 8192) < 1) {\r\n              reportScopeError(scopeError);\r\n          }\r\n      }\r\n      parser.flags =\r\n          (parser.flags | 512 | 256 | 64) ^\r\n              (512 | 256 | 64);\r\n      parser.destructible = (parser.destructible | 256) ^ 256;\r\n      while (parser.token !== 1074790415) {\r\n          body.push(parseStatementListItem(parser, context, scope, 4, {}, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      consume(parser, origin & (16 | 8) ? context | 32768 : context, 1074790415);\r\n      parser.flags &= ~(128 | 64);\r\n      if (parser.token === 1077936157)\r\n          report(parser, 24);\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'BlockStatement',\r\n          body\r\n      });\r\n  }\r\n  function parseSuperExpression(parser, context, start, line, column) {\r\n      nextToken(parser, context);\r\n      switch (parser.token) {\r\n          case 67108988:\r\n              report(parser, 161);\r\n          case 67174411: {\r\n              if ((context & 524288) < 1)\r\n                  report(parser, 26);\r\n              if (context & 16384)\r\n                  report(parser, 143);\r\n              parser.assignable = 2;\r\n              break;\r\n          }\r\n          case 69271571:\r\n          case 67108877: {\r\n              if ((context & 262144) < 1)\r\n                  report(parser, 27);\r\n              if (context & 16384)\r\n                  report(parser, 143);\r\n              parser.assignable = 1;\r\n              break;\r\n          }\r\n          default:\r\n              report(parser, 28, 'super');\r\n      }\r\n      return finishNode(parser, context, start, line, column, { type: 'Super' });\r\n  }\r\n  function parseLeftHandSideExpression(parser, context, canAssign, inGroup, isLHS, start, line, column) {\r\n      const expression = parsePrimaryExpression(parser, context, 2, 0, canAssign, 0, inGroup, isLHS, start, line, column);\r\n      return parseMemberOrUpdateExpression(parser, context, expression, inGroup, start, line, column);\r\n  }\r\n  function parseUpdateExpression(parser, context, expr, start, line, column) {\r\n      if (parser.assignable & 2)\r\n          report(parser, 52);\r\n      const { token } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'UpdateExpression',\r\n          argument: expr,\r\n          operator: KeywordDescTable[token & 255],\r\n          prefix: false\r\n      });\r\n  }\r\n  function parseMemberOrUpdateExpression(parser, context, expr, inGroup, start, line, column) {\r\n      if ((parser.token & 33619968) === 33619968 && (parser.flags & 1) < 1) {\r\n          return parseUpdateExpression(parser, context, expr, start, line, column);\r\n      }\r\n      if ((parser.token & 67108864) === 67108864) {\r\n          context = (context | 134217728 | 8192) ^ (134217728 | 8192);\r\n          switch (parser.token) {\r\n              case 67108877: {\r\n                  nextToken(parser, context | 1073741824);\r\n                  parser.assignable = 1;\r\n                  const property = parsePropertyOrPrivatePropertyName(parser, context);\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'MemberExpression',\r\n                      object: expr,\r\n                      computed: false,\r\n                      property\r\n                  });\r\n                  break;\r\n              }\r\n              case 69271571: {\r\n                  nextToken(parser, context | 32768);\r\n                  const { tokenPos, linePos, colPos } = parser;\r\n                  const property = parseExpressions(parser, context, inGroup, 1, tokenPos, linePos, colPos);\r\n                  consume(parser, context, 20);\r\n                  parser.assignable = 1;\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'MemberExpression',\r\n                      object: expr,\r\n                      computed: true,\r\n                      property\r\n                  });\r\n                  break;\r\n              }\r\n              case 67174411: {\r\n                  if ((parser.flags & 1024) === 1024) {\r\n                      parser.flags = (parser.flags | 1024) ^ 1024;\r\n                      return expr;\r\n                  }\r\n                  const args = parseArguments(parser, context, inGroup);\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'CallExpression',\r\n                      callee: expr,\r\n                      arguments: args\r\n                  });\r\n                  break;\r\n              }\r\n              case 67108988: {\r\n                  nextToken(parser, context);\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, start, line, column, {\r\n                      type: 'OptionalExpression',\r\n                      object: expr,\r\n                      chain: parseOptionalChain(parser, context, start, line, column)\r\n                  });\r\n                  break;\r\n              }\r\n              default:\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                      type: 'TaggedTemplateExpression',\r\n                      tag: expr,\r\n                      quasi: parser.token === 67174408\r\n                          ? parseTemplate(parser, context | 65536, start, line, column)\r\n                          : parseTemplateLiteral(parser, context, start, line, column)\r\n                  });\r\n          }\r\n          return parseMemberOrUpdateExpression(parser, context, expr, 0, start, line, column);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseOptionalChain(parser, context, start, line, column) {\r\n      let base = null;\r\n      if (parser.token === 69271571) {\r\n          nextToken(parser, context | 32768);\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          const property = parseExpressions(parser, context, 0, 1, tokenPos, linePos, colPos);\r\n          consume(parser, context, 20);\r\n          parser.assignable = 2;\r\n          base = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n              type: 'OptionalChain',\r\n              base: null,\r\n              computed: true,\r\n              property\r\n          });\r\n      }\r\n      else if (parser.token === 67174411) {\r\n          const args = parseArguments(parser, context, 0);\r\n          parser.assignable = 2;\r\n          base = finishNode(parser, context, start, line, column, {\r\n              type: 'OptionalChain',\r\n              base: null,\r\n              arguments: args\r\n          });\r\n      }\r\n      else {\r\n          if ((parser.token & (143360 | 4096)) < 1)\r\n              report(parser, 154);\r\n          const property = parseIdentifier(parser, context, 0);\r\n          parser.assignable = 2;\r\n          base = finishNode(parser, context, start, line, column, {\r\n              type: 'OptionalChain',\r\n              base: null,\r\n              computed: false,\r\n              property\r\n          });\r\n      }\r\n      while ((parser.token & 67108864) === 67108864) {\r\n          if (parser.token === 67108877) {\r\n              nextToken(parser, context);\r\n              parser.assignable = 1;\r\n              if ((parser.token & (143360 | 4096)) < 1)\r\n                  report(parser, 154);\r\n              const property = parseIdentifier(parser, context, 0);\r\n              base = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'OptionalChain',\r\n                  base,\r\n                  computed: false,\r\n                  property\r\n              });\r\n          }\r\n          else if (parser.token === 69271571) {\r\n              nextToken(parser, context | 32768);\r\n              const { tokenPos, linePos, colPos } = parser;\r\n              const property = parseExpressions(parser, context, 0, 1, tokenPos, linePos, colPos);\r\n              consume(parser, context, 20);\r\n              parser.assignable = 2;\r\n              base = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'OptionalChain',\r\n                  base,\r\n                  computed: true,\r\n                  property\r\n              });\r\n          }\r\n          else if (parser.token === 67174411) {\r\n              const args = parseArguments(parser, context, 0);\r\n              parser.assignable = 2;\r\n              base = finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'OptionalChain',\r\n                  base,\r\n                  arguments: args\r\n              });\r\n          }\r\n          else if (parser.token === 67174408 || parser.token === 67174409) {\r\n              report(parser, 160);\r\n          }\r\n          else {\r\n              break;\r\n          }\r\n      }\r\n      return base;\r\n  }\r\n  function parsePropertyOrPrivatePropertyName(parser, context) {\r\n      if ((parser.token & (143360 | 4096)) < 1 && parser.token !== 128) {\r\n          report(parser, 154);\r\n      }\r\n      return context & 1 && parser.token === 128\r\n          ? parsePrivateName(parser, context, parser.tokenPos, parser.linePos, parser.colPos)\r\n          : parseIdentifier(parser, context, 0);\r\n  }\r\n  function parseUpdateExpressionPrefixed(parser, context, inNew, isLHS, start, line, column) {\r\n      if (inNew)\r\n          report(parser, 53);\r\n      if (!isLHS)\r\n          report(parser, 0);\r\n      const { token } = parser;\r\n      nextToken(parser, context | 32768);\r\n      const arg = parseLeftHandSideExpression(parser, context, 0, 0, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n      if (parser.assignable & 2) {\r\n          report(parser, 52);\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'UpdateExpression',\r\n          argument: arg,\r\n          operator: KeywordDescTable[token & 255],\r\n          prefix: true\r\n      });\r\n  }\r\n  function parsePrimaryExpression(parser, context, kind, inNew, canAssign, isPattern, inGroup, isLHS, start, line, column) {\r\n      if ((parser.token & 143360) === 143360) {\r\n          switch (parser.token) {\r\n              case 209005:\r\n                  return parseAwaitExpression(parser, context, inNew, inGroup, start, line, column);\r\n              case 241770:\r\n                  return parseYieldExpression(parser, context, inGroup, canAssign, start, line, column);\r\n              case 143468:\r\n                  return parseAsyncExpression(parser, context, inGroup, isLHS, canAssign, isPattern, inNew, start, line, column);\r\n          }\r\n          const { token, tokenValue } = parser;\r\n          const expr = parseIdentifier(parser, context | 65536, isPattern);\r\n          if (parser.token === 10) {\r\n              if (!isLHS)\r\n                  report(parser, 0);\r\n              classifyIdentifier(parser, context, token, 1);\r\n              return parseArrowFromIdentifier(parser, context, tokenValue, expr, inNew, canAssign, 0, start, line, column);\r\n          }\r\n          if (context & 16384 && token === 537079925)\r\n              report(parser, 126);\r\n          if (token === 241736) {\r\n              if (context & 1024)\r\n                  report(parser, 109);\r\n              if (kind & (8 | 16))\r\n                  report(parser, 97);\r\n          }\r\n          parser.assignable =\r\n              context & 1024 && (token & 537079808) === 537079808\r\n                  ? 2\r\n                  : 1;\r\n          return expr;\r\n      }\r\n      if ((parser.token & 134217728) === 134217728) {\r\n          return parseLiteral(parser, context);\r\n      }\r\n      switch (parser.token) {\r\n          case 33619995:\r\n          case 33619996:\r\n              return parseUpdateExpressionPrefixed(parser, context, inNew, isLHS, start, line, column);\r\n          case 16863275:\r\n          case 16842797:\r\n          case 16842798:\r\n          case 25233967:\r\n          case 25233968:\r\n          case 16863274:\r\n          case 16863276:\r\n              return parseUnaryExpression(parser, context, isLHS, start, line, column, inGroup);\r\n          case 86103:\r\n              return parseFunctionExpression(parser, context, 0, inGroup, start, line, column);\r\n          case 2162700:\r\n              return parseObjectLiteral(parser, context, canAssign ? 0 : 1, inGroup, start, line, column);\r\n          case 69271571:\r\n              return parseArrayLiteral(parser, context, canAssign ? 0 : 1, inGroup, start, line, column);\r\n          case 67174411:\r\n              return parseParenthesizedExpression(parser, context, canAssign, 1, 0, start, line, column);\r\n          case 86021:\r\n          case 86022:\r\n          case 86023:\r\n              return parseNullOrTrueOrFalseLiteral(parser, context, start, line, column);\r\n          case 86110:\r\n              return parseThisExpression(parser, context);\r\n          case 65540:\r\n              return parseRegExpLiteral(parser, context, start, line, column);\r\n          case 130:\r\n          case 86093:\r\n              return parseClassExpression(parser, context, inGroup, start, line, column);\r\n          case 86108:\r\n              return parseSuperExpression(parser, context, start, line, column);\r\n          case 67174409:\r\n              return parseTemplateLiteral(parser, context, start, line, column);\r\n          case 67174408:\r\n              return parseTemplate(parser, context, start, line, column);\r\n          case 86106:\r\n              return parseNewExpression(parser, context, inGroup, start, line, column);\r\n          case 122:\r\n              return parseBigIntLiteral(parser, context, start, line, column);\r\n          case 128:\r\n              return parsePrivateName(parser, context, start, line, column);\r\n          case 86105:\r\n              return parseImportCallOrMetaExpression(parser, context, inNew, inGroup, start, line, column);\r\n          case 8456255:\r\n              if (context & 16)\r\n                  return parseJSXRootElementOrFragment(parser, context, 1, start, line, column);\r\n          default:\r\n              if (isValidIdentifier(context, parser.token))\r\n                  return parseIdentifierOrArrow(parser, context, start, line, column);\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n  }\r\n  function parseImportCallOrMetaExpression(parser, context, inNew, inGroup, start, line, column) {\r\n      let expr = parseIdentifier(parser, context, 0);\r\n      if (context & 1 && parser.token === 67108877) {\r\n          return parseImportMetaExpression(parser, context, expr, start, line, column);\r\n      }\r\n      if (inNew)\r\n          report(parser, 137);\r\n      expr = parseImportExpression(parser, context, inGroup, start, line, column);\r\n      parser.assignable = 2;\r\n      return parseMemberOrUpdateExpression(parser, context, expr, inGroup, start, line, column);\r\n  }\r\n  function parseImportMetaExpression(parser, context, meta, start, line, column) {\r\n      if ((context & 2048) === 0)\r\n          report(parser, 163);\r\n      nextToken(parser, context);\r\n      if (parser.token !== 143492 && parser.tokenValue !== 'meta')\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'MetaProperty',\r\n          meta,\r\n          property: parseIdentifier(parser, context, 0)\r\n      });\r\n  }\r\n  function parseImportExpression(parser, context, inGroup, start, line, column) {\r\n      consume(parser, context | 32768, 67174411);\r\n      if (parser.token === 14)\r\n          report(parser, 138);\r\n      const source = parseExpression(parser, context, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 16);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ImportExpression',\r\n          source\r\n      });\r\n  }\r\n  function parseBigIntLiteral(parser, context, start, line, column) {\r\n      const { tokenRaw, tokenValue } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, context & 512\r\n          ? {\r\n              type: 'BigIntLiteral',\r\n              value: tokenValue,\r\n              bigint: tokenRaw,\r\n              raw: tokenRaw\r\n          }\r\n          : {\r\n              type: 'BigIntLiteral',\r\n              value: tokenValue,\r\n              bigint: tokenRaw\r\n          });\r\n  }\r\n  function parseTemplateLiteral(parser, context, start, line, column) {\r\n      parser.assignable = 2;\r\n      consume(parser, context, 67174409);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'TemplateLiteral',\r\n          expressions: [],\r\n          quasis: [parseTemplateElement(parser, context, true)]\r\n      });\r\n  }\r\n  function parseTemplate(parser, context, start, line, column) {\r\n      context = (context | 134217728) ^ 134217728;\r\n      const quasis = [parseTemplateElement(parser, context, false)];\r\n      consume(parser, context | 32768, 67174408);\r\n      const expressions = [parseExpressions(parser, context, 0, 1, parser.tokenPos, parser.linePos, parser.colPos)];\r\n      if (parser.token !== 1074790415)\r\n          report(parser, 80);\r\n      while ((parser.token = scanTemplateTail(parser, context)) !== 67174409) {\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          quasis.push(parseTemplateElement(parser, context, false));\r\n          consume(parser, context | 32768, 67174408);\r\n          expressions.push(parseExpressions(parser, context, 0, 1, tokenPos, linePos, colPos));\r\n          if (parser.token !== 1074790415)\r\n              report(parser, 80);\r\n      }\r\n      quasis.push(parseTemplateElement(parser, context, true));\r\n      consume(parser, context, 67174409);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'TemplateLiteral',\r\n          expressions,\r\n          quasis\r\n      });\r\n  }\r\n  function parseTemplateElement(parser, context, tail) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'TemplateElement',\r\n          value: {\r\n              cooked: parser.tokenValue,\r\n              raw: parser.tokenRaw\r\n          },\r\n          tail\r\n      });\r\n  }\r\n  function parseSpreadElement(parser, context, start, line, column) {\r\n      context = (context | 134217728) ^ 134217728;\r\n      consume(parser, context | 32768, 14);\r\n      const argument = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      parser.assignable = 1;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'SpreadElement',\r\n          argument\r\n      });\r\n  }\r\n  function parseArguments(parser, context, inGroup) {\r\n      nextToken(parser, context | 32768);\r\n      const args = [];\r\n      if (parser.token === 16) {\r\n          nextToken(parser, context);\r\n          return args;\r\n      }\r\n      while (parser.token !== 16) {\r\n          if (parser.token === 14) {\r\n              args.push(parseSpreadElement(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          else {\r\n              args.push(parseExpression(parser, context, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos));\r\n          }\r\n          if (parser.token !== 1073741842)\r\n              break;\r\n          nextToken(parser, context | 32768);\r\n          if (parser.token === 16)\r\n              break;\r\n      }\r\n      consume(parser, context, 16);\r\n      return args;\r\n  }\r\n  function parseIdentifier(parser, context, isPattern) {\r\n      const { tokenValue, tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, context & 268435456\r\n          ? {\r\n              type: 'Identifier',\r\n              name: tokenValue,\r\n              pattern: isPattern === 1\r\n          }\r\n          : {\r\n              type: 'Identifier',\r\n              name: tokenValue\r\n          });\r\n  }\r\n  function parseLiteral(parser, context) {\r\n      const { tokenValue, tokenRaw, tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, context & 512\r\n          ? {\r\n              type: 'Literal',\r\n              value: tokenValue,\r\n              raw: tokenRaw\r\n          }\r\n          : {\r\n              type: 'Literal',\r\n              value: tokenValue\r\n          });\r\n  }\r\n  function parseNullOrTrueOrFalseLiteral(parser, context, start, line, column) {\r\n      const raw = KeywordDescTable[parser.token & 255];\r\n      const value = parser.token === 86023 ? null : raw === 'true';\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, context & 512\r\n          ? {\r\n              type: 'Literal',\r\n              value,\r\n              raw\r\n          }\r\n          : {\r\n              type: 'Literal',\r\n              value\r\n          });\r\n  }\r\n  function parseThisExpression(parser, context) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'ThisExpression'\r\n      });\r\n  }\r\n  function parseFunctionDeclaration(parser, context, scope, origin, allowGen, flags, isAsync, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const isGenerator = allowGen ? optionalBit(parser, context, 8457011) : 0;\r\n      let id = null;\r\n      let firstRestricted;\r\n      let functionScope = scope ? createScope() : void 0;\r\n      if (parser.token === 67174411) {\r\n          if ((flags & 1) < 1)\r\n              report(parser, 37, 'Function');\r\n      }\r\n      else {\r\n          const kind = origin & 4 && ((context & 8192) < 1 || (context & 2048) < 1)\r\n              ? 4\r\n              : 64;\r\n          validateFunctionName(parser, context | ((context & 3072) << 11), parser.token);\r\n          if (scope) {\r\n              if (kind & 4) {\r\n                  addVarName(parser, context, scope, parser.tokenValue, kind);\r\n              }\r\n              else {\r\n                  addBlockName(parser, context, scope, parser.tokenValue, kind, origin);\r\n              }\r\n              functionScope = addChildScope(functionScope, 256);\r\n              if (flags) {\r\n                  if (flags & 2) {\r\n                      declareUnboundVariable(parser, parser.tokenValue);\r\n                  }\r\n              }\r\n          }\r\n          firstRestricted = parser.token;\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      context =\r\n          ((context | 32243712) ^ 32243712) |\r\n              67108864 |\r\n              ((isAsync * 2 + isGenerator) << 21) |\r\n              (isGenerator ? 0 : 1073741824);\r\n      if (scope)\r\n          functionScope = addChildScope(functionScope, 512);\r\n      const params = parseFormalParametersOrFormalList(parser, context | 8388608, functionScope, 0, 1);\r\n      const body = parseFunctionBody(parser, (context | 8192 | 4096 | 131072) ^\r\n          (8192 | 4096 | 131072), scope ? addChildScope(functionScope, 128) : functionScope, 8, firstRestricted, scope ? functionScope.scopeError : void 0);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FunctionDeclaration',\r\n          id,\r\n          params,\r\n          body,\r\n          async: isAsync === 1,\r\n          generator: isGenerator === 1\r\n      });\r\n  }\r\n  function parseFunctionExpression(parser, context, isAsync, inGroup, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const isGenerator = optionalBit(parser, context, 8457011);\r\n      const generatorAndAsyncFlags = (isAsync * 2 + isGenerator) << 21;\r\n      let id = null;\r\n      let firstRestricted;\r\n      let scope = context & 64 ? createScope() : void 0;\r\n      if ((parser.token & (143360 | 4096 | 36864)) > 0) {\r\n          validateFunctionName(parser, ((context | 0x1ec0000) ^ 0x1ec0000) | generatorAndAsyncFlags, parser.token);\r\n          if (scope)\r\n              scope = addChildScope(scope, 256);\r\n          firstRestricted = parser.token;\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      context =\r\n          ((context | 32243712) ^ 32243712) |\r\n              67108864 |\r\n              generatorAndAsyncFlags |\r\n              (isGenerator ? 0 : 1073741824);\r\n      if (scope)\r\n          scope = addChildScope(scope, 512);\r\n      const params = parseFormalParametersOrFormalList(parser, context | 8388608, scope, inGroup, 1);\r\n      const body = parseFunctionBody(parser, context & ~(0x8001000 | 8192 | 4096 | 131072 | 16384), scope ? addChildScope(scope, 128) : scope, 0, firstRestricted, void 0);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FunctionExpression',\r\n          id,\r\n          params,\r\n          body,\r\n          async: isAsync === 1,\r\n          generator: isGenerator === 1\r\n      });\r\n  }\r\n  function parseArrayLiteral(parser, context, skipInitializer, inGroup, start, line, column) {\r\n      const expr = parseArrayExpressionOrPattern(parser, context, void 0, skipInitializer, inGroup, 0, 2, 0, start, line, column);\r\n      if (context & 256 && parser.destructible & 64) {\r\n          report(parser, 60);\r\n      }\r\n      if (parser.destructible & 8) {\r\n          report(parser, 59);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseArrayExpressionOrPattern(parser, context, scope, skipInitializer, inGroup, isPattern, kind, origin, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const elements = [];\r\n      let destructible = 0;\r\n      context = (context | 134217728) ^ 134217728;\r\n      while (parser.token !== 20) {\r\n          if (consumeOpt(parser, context | 32768, 1073741842)) {\r\n              elements.push(null);\r\n          }\r\n          else {\r\n              let left;\r\n              const { token, tokenPos, linePos, colPos, tokenValue } = parser;\r\n              if (token & 143360) {\r\n                  left = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token === 1077936157) {\r\n                      if (parser.assignable & 2)\r\n                          report(parser, 24);\r\n                      nextToken(parser, context | 32768);\r\n                      if (scope)\r\n                          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                      const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                      left = finishNode(parser, context, tokenPos, linePos, colPos, isPattern\r\n                          ? {\r\n                              type: 'AssignmentPattern',\r\n                              left,\r\n                              right\r\n                          }\r\n                          : {\r\n                              type: 'AssignmentExpression',\r\n                              operator: '=',\r\n                              left,\r\n                              right\r\n                          });\r\n                      destructible |=\r\n                          parser.destructible & 256\r\n                              ? 256\r\n                              : 0 | (parser.destructible & 128)\r\n                                  ? 128\r\n                                  : 0;\r\n                  }\r\n                  else if (parser.token === 1073741842 || parser.token === 20) {\r\n                      if (parser.assignable & 2) {\r\n                          destructible |= 16;\r\n                      }\r\n                      else if (scope) {\r\n                          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                      }\r\n                      destructible |=\r\n                          parser.destructible & 256\r\n                              ? 256\r\n                              : 0 | (parser.destructible & 128)\r\n                                  ? 128\r\n                                  : 0;\r\n                  }\r\n                  else {\r\n                      destructible |=\r\n                          kind & 1\r\n                              ? 32\r\n                              : (kind & 2) < 1\r\n                                  ? 16\r\n                                  : 0;\r\n                      left = parseMemberOrUpdateExpression(parser, context, left, inGroup, tokenPos, linePos, colPos);\r\n                      if (parser.token !== 1073741842 && parser.token !== 20) {\r\n                          if (parser.token !== 1077936157)\r\n                              destructible |= 16;\r\n                          left = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, left);\r\n                      }\r\n                      else if (parser.token !== 1077936157) {\r\n                          destructible |=\r\n                              parser.assignable & 2\r\n                                  ? 16\r\n                                  : 32;\r\n                      }\r\n                  }\r\n              }\r\n              else if (token & 2097152) {\r\n                  left =\r\n                      parser.token === 2162700\r\n                          ? parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                          : parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                  destructible |= parser.destructible;\r\n                  parser.assignable =\r\n                      parser.destructible & 16\r\n                          ? 2\r\n                          : 1;\r\n                  if (parser.token === 1073741842 || parser.token === 20) {\r\n                      if (parser.assignable & 2) {\r\n                          destructible |= 16;\r\n                      }\r\n                  }\r\n                  else if (parser.destructible & 8) {\r\n                      report(parser, 68);\r\n                  }\r\n                  else {\r\n                      left = parseMemberOrUpdateExpression(parser, context, left, inGroup, tokenPos, linePos, colPos);\r\n                      destructible = parser.assignable & 2 ? 16 : 0;\r\n                      if (parser.token !== 1073741842 && parser.token !== 20) {\r\n                          left = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, left);\r\n                      }\r\n                      else if (parser.token !== 1077936157) {\r\n                          destructible |=\r\n                              parser.assignable & 2\r\n                                  ? 16\r\n                                  : 32;\r\n                      }\r\n                  }\r\n              }\r\n              else if (token === 14) {\r\n                  left = parseSpreadOrRestElement(parser, context, scope, 20, kind, origin, 0, inGroup, isPattern, tokenPos, linePos, colPos);\r\n                  destructible |= parser.destructible;\r\n                  if (parser.token !== 1073741842 && parser.token !== 20)\r\n                      report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n              }\r\n              else {\r\n                  left = parseLeftHandSideExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token !== 1073741842 && parser.token !== 20) {\r\n                      left = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, left);\r\n                      if ((kind & (2 | 1)) < 1 && token === 67174411)\r\n                          destructible |= 16;\r\n                  }\r\n                  else if (parser.assignable & 2) {\r\n                      destructible |= 16;\r\n                  }\r\n                  else if (token === 67174411) {\r\n                      destructible |=\r\n                          parser.assignable & 1 && kind & (2 | 1)\r\n                              ? 32\r\n                              : 16;\r\n                  }\r\n              }\r\n              elements.push(left);\r\n              if (consumeOpt(parser, context | 32768, 1073741842)) {\r\n                  if (parser.token === 20)\r\n                      break;\r\n              }\r\n              else\r\n                  break;\r\n          }\r\n      }\r\n      consume(parser, context, 20);\r\n      const node = finishNode(parser, context, start, line, column, {\r\n          type: isPattern ? 'ArrayPattern' : 'ArrayExpression',\r\n          elements\r\n      });\r\n      if (!skipInitializer && parser.token & 4194304) {\r\n          return parseArrayOrObjectAssignmentPattern(parser, context, destructible, inGroup, isPattern, start, line, column, node);\r\n      }\r\n      parser.destructible = destructible;\r\n      return node;\r\n  }\r\n  function parseArrayOrObjectAssignmentPattern(parser, context, destructible, inGroup, isPattern, start, line, column, node) {\r\n      if (parser.token !== 1077936157)\r\n          report(parser, 24);\r\n      nextToken(parser, context | 32768);\r\n      if (destructible & 16)\r\n          report(parser, 24);\r\n      if (!isPattern)\r\n          reinterpretToPattern(parser, node);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      const right = parseExpression(parser, context, 1, 1, inGroup, tokenPos, linePos, colPos);\r\n      parser.destructible =\r\n          ((destructible | 64 | 8) ^\r\n              (8 | 64)) |\r\n              (parser.destructible & 128 ? 128 : 0) |\r\n              (parser.destructible & 256 ? 256 : 0);\r\n      return finishNode(parser, context, start, line, column, isPattern\r\n          ? {\r\n              type: 'AssignmentPattern',\r\n              left: node,\r\n              right\r\n          }\r\n          : {\r\n              type: 'AssignmentExpression',\r\n              left: node,\r\n              operator: '=',\r\n              right\r\n          });\r\n  }\r\n  function parseSpreadOrRestElement(parser, context, scope, closingToken, kind, origin, isAsync, inGroup, isPattern, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let argument = null;\r\n      let destructible = 0;\r\n      let { token, tokenValue, tokenPos, linePos, colPos } = parser;\r\n      if (token & (4096 | 143360)) {\r\n          parser.assignable = 1;\r\n          argument = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n          token = parser.token;\r\n          argument = parseMemberOrUpdateExpression(parser, context, argument, inGroup, tokenPos, linePos, colPos);\r\n          if (parser.token !== 1073741842 && parser.token !== closingToken) {\r\n              if (parser.assignable & 2 && parser.token === 1077936157)\r\n                  report(parser, 68);\r\n              destructible |= 16;\r\n              argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n          }\r\n          if (parser.assignable & 2) {\r\n              destructible |= 16;\r\n          }\r\n          else if (token === closingToken || token === 1073741842) {\r\n              if (scope)\r\n                  addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n          }\r\n          else {\r\n              destructible |= 32;\r\n          }\r\n          destructible |= parser.destructible & 128 ? 128 : 0;\r\n      }\r\n      else if (token === closingToken) {\r\n          report(parser, 39);\r\n      }\r\n      else if (token & 2097152) {\r\n          argument =\r\n              parser.token === 2162700\r\n                  ? parseObjectLiteralOrPattern(parser, context, scope, 1, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                  : parseArrayExpressionOrPattern(parser, context, scope, 1, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n          token = parser.token;\r\n          if (token !== 1077936157 && token !== closingToken && token !== 1073741842) {\r\n              if (parser.destructible & 8)\r\n                  report(parser, 68);\r\n              argument = parseMemberOrUpdateExpression(parser, context, argument, inGroup, tokenPos, linePos, colPos);\r\n              destructible |= parser.assignable & 2 ? 16 : 0;\r\n              if ((parser.token & 4194304) === 4194304) {\r\n                  if (parser.token !== 1077936157)\r\n                      destructible |= 16;\r\n                  argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n              }\r\n              else {\r\n                  if ((parser.token & 8454144) === 8454144) {\r\n                      argument = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, argument);\r\n                  }\r\n                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                      argument = parseConditionalExpression(parser, context, argument, tokenPos, linePos, colPos);\r\n                  }\r\n                  destructible |=\r\n                      parser.assignable & 2\r\n                          ? 16\r\n                          : 32;\r\n              }\r\n          }\r\n          else {\r\n              destructible |=\r\n                  closingToken === 1074790415 && token !== 1077936157\r\n                      ? 16\r\n                      : parser.destructible;\r\n          }\r\n      }\r\n      else {\r\n          destructible |= 32;\r\n          argument = parseLeftHandSideExpression(parser, context, 1, inGroup, 1, parser.tokenPos, parser.linePos, parser.colPos);\r\n          const { token, tokenPos, linePos, colPos } = parser;\r\n          if (token === 1077936157 && token !== closingToken && token !== 1073741842) {\r\n              if (parser.assignable & 2)\r\n                  report(parser, 24);\r\n              argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n              destructible |= 16;\r\n          }\r\n          else {\r\n              if (token === 1073741842) {\r\n                  destructible |= 16;\r\n              }\r\n              else if (token !== closingToken) {\r\n                  argument = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, argument);\r\n              }\r\n              destructible |=\r\n                  parser.assignable & 1 ? 32 : 16;\r\n          }\r\n          parser.destructible = destructible;\r\n          if (parser.token !== closingToken && parser.token !== 1073741842)\r\n              report(parser, 155);\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: isPattern ? 'RestElement' : 'SpreadElement',\r\n              argument: argument\r\n          });\r\n      }\r\n      if (parser.token !== closingToken) {\r\n          if (kind & 1)\r\n              destructible |= isAsync ? 16 : 32;\r\n          if (consumeOpt(parser, context | 32768, 1077936157)) {\r\n              if (destructible & 16)\r\n                  report(parser, 24);\r\n              reinterpretToPattern(parser, argument);\r\n              const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n              argument = finishNode(parser, context, tokenPos, linePos, colPos, isPattern\r\n                  ? {\r\n                      type: 'AssignmentPattern',\r\n                      left: argument,\r\n                      right\r\n                  }\r\n                  : {\r\n                      type: 'AssignmentExpression',\r\n                      left: argument,\r\n                      operator: '=',\r\n                      right\r\n                  });\r\n              destructible = 16;\r\n          }\r\n          else {\r\n              destructible |= 16;\r\n          }\r\n      }\r\n      parser.destructible = destructible;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: isPattern ? 'RestElement' : 'SpreadElement',\r\n          argument: argument\r\n      });\r\n  }\r\n  function parseMethodDefinition(parser, context, kind, inGroup, start, line, column) {\r\n      const modifierFlags = (kind & 64) < 1 ? 31981568 : 14680064;\r\n      context =\r\n          ((context | modifierFlags) ^ modifierFlags) |\r\n              ((kind & 88) << 18) |\r\n              100925440;\r\n      let scope = context & 64 ? addChildScope(createScope(), 512) : void 0;\r\n      const params = parseMethodFormals(parser, context | 8388608, scope, kind, 1, inGroup);\r\n      if (scope)\r\n          scope = addChildScope(scope, 128);\r\n      const body = parseFunctionBody(parser, context & ~(0x8001000 | 8192), scope, 0, void 0, void 0);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FunctionExpression',\r\n          params,\r\n          body,\r\n          async: (kind & 16) > 0,\r\n          generator: (kind & 8) > 0,\r\n          id: null\r\n      });\r\n  }\r\n  function parseObjectLiteral(parser, context, skipInitializer, inGroup, start, line, column) {\r\n      const expr = parseObjectLiteralOrPattern(parser, context, void 0, skipInitializer, inGroup, 0, 2, 0, start, line, column);\r\n      if (context & 256 && parser.destructible & 64) {\r\n          report(parser, 60);\r\n      }\r\n      if (parser.destructible & 8) {\r\n          report(parser, 59);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseObjectLiteralOrPattern(parser, context, scope, skipInitializer, inGroup, isPattern, kind, origin, start, line, column) {\r\n      nextToken(parser, context);\r\n      const properties = [];\r\n      let destructible = 0;\r\n      let prototypeCount = 0;\r\n      context = (context | 134217728) ^ 134217728;\r\n      while (parser.token !== 1074790415) {\r\n          const { token, tokenValue, linePos, colPos, tokenPos } = parser;\r\n          if (token === 14) {\r\n              properties.push(parseSpreadOrRestElement(parser, context, scope, 1074790415, kind, origin, 0, inGroup, isPattern, tokenPos, linePos, colPos));\r\n          }\r\n          else {\r\n              let state = 0;\r\n              let key = null;\r\n              let value;\r\n              const t = parser.token;\r\n              if (parser.token & (143360 | 4096) || parser.token === 118) {\r\n                  key = parseIdentifier(parser, context, 0);\r\n                  if (parser.token === 1073741842 || parser.token === 1074790415 || parser.token === 1077936157) {\r\n                      state |= 4;\r\n                      if (context & 1024 && (token & 537079808) === 537079808) {\r\n                          destructible |= 16;\r\n                      }\r\n                      else {\r\n                          validateBindingIdentifier(parser, context, kind, token, 0);\r\n                      }\r\n                      if (scope)\r\n                          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                      if (consumeOpt(parser, context | 32768, 1077936157)) {\r\n                          destructible |= 8;\r\n                          const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                          destructible |=\r\n                              parser.destructible & 256\r\n                                  ? 256\r\n                                  : 0 | (parser.destructible & 128)\r\n                                      ? 128\r\n                                      : 0;\r\n                          value = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                              type: 'AssignmentPattern',\r\n                              left: context & -2147483648 ? Object.assign({}, key) : key,\r\n                              right\r\n                          });\r\n                      }\r\n                      else {\r\n                          destructible |=\r\n                              (token === 209005 ? 128 : 0) |\r\n                                  (token === 118 ? 16 : 0);\r\n                          value = context & -2147483648 ? Object.assign({}, key) : key;\r\n                      }\r\n                  }\r\n                  else if (consumeOpt(parser, context | 32768, 21)) {\r\n                      const { tokenPos, linePos, colPos } = parser;\r\n                      if (tokenValue === '__proto__')\r\n                          prototypeCount++;\r\n                      if (parser.token & 143360) {\r\n                          const tokenAfterColon = parser.token;\r\n                          const valueAfterColon = parser.tokenValue;\r\n                          destructible |= t === 118 ? 16 : 0;\r\n                          value = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                          const { token } = parser;\r\n                          value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (token === 1077936157 || token === 1074790415 || token === 1073741842) {\r\n                                  destructible |= parser.destructible & 128 ? 128 : 0;\r\n                                  if (parser.assignable & 2) {\r\n                                      destructible |= 16;\r\n                                  }\r\n                                  else if (scope && (tokenAfterColon & 143360) === 143360) {\r\n                                      addVarOrBlock(parser, context, scope, valueAfterColon, kind, origin);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  destructible |=\r\n                                      parser.assignable & 1\r\n                                          ? 32\r\n                                          : 16;\r\n                              }\r\n                          }\r\n                          else if ((parser.token & 4194304) === 4194304) {\r\n                              if (parser.assignable & 2) {\r\n                                  destructible |= 16;\r\n                              }\r\n                              else if (token !== 1077936157) {\r\n                                  destructible |= 32;\r\n                              }\r\n                              else if (scope) {\r\n                                  addVarOrBlock(parser, context, scope, valueAfterColon, kind, origin);\r\n                              }\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                          else {\r\n                              destructible |= 16;\r\n                              if ((parser.token & 8454144) === 8454144) {\r\n                                  value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                              }\r\n                              if (consumeOpt(parser, context | 32768, 22)) {\r\n                                  value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                              }\r\n                          }\r\n                      }\r\n                      else if ((parser.token & 2097152) === 2097152) {\r\n                          value =\r\n                              parser.token === 69271571\r\n                                  ? parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                                  : parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                          destructible = parser.destructible;\r\n                          parser.assignable =\r\n                              destructible & 16 ? 2 : 1;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else if (parser.destructible & 8) {\r\n                              report(parser, 68);\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 2 ? 16 : 0;\r\n                              if ((parser.token & 4194304) === 4194304) {\r\n                                  value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                              else {\r\n                                  if ((parser.token & 8454144) === 8454144) {\r\n                                      value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                                  }\r\n                                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                                      value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                                  }\r\n                                  destructible |=\r\n                                      parser.assignable & 2\r\n                                          ? 16\r\n                                          : 32;\r\n                              }\r\n                          }\r\n                      }\r\n                      else {\r\n                          value = parseLeftHandSideExpression(parser, context, 1, inGroup, 1, tokenPos, linePos, colPos);\r\n                          destructible |=\r\n                              parser.assignable & 1\r\n                                  ? 32\r\n                                  : 16;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, tokenPos, colPos);\r\n                              destructible = parser.assignable & 2 ? 16 : 0;\r\n                              if (parser.token !== 1073741842 && token !== 1074790415) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, tokenPos, colPos, value);\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (parser.token === 69271571) {\r\n                      destructible |= 16;\r\n                      if (token === 143468)\r\n                          state |= 16;\r\n                      state |=\r\n                          (token === 12399\r\n                              ? 256\r\n                              : token === 12400\r\n                                  ? 512\r\n                                  : 1) | 2;\r\n                      key = parseComputedPropertyName(parser, context, inGroup);\r\n                      destructible |= parser.assignable;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if (parser.token & (143360 | 4096)) {\r\n                      destructible |= 16;\r\n                      if (token === 118)\r\n                          report(parser, 92);\r\n                      if (token === 143468) {\r\n                          if (parser.flags & 1)\r\n                              report(parser, 128);\r\n                          state |= 16;\r\n                      }\r\n                      key = parseIdentifier(parser, context, 0);\r\n                      state |=\r\n                          token === 12399\r\n                              ? 256\r\n                              : token === 12400\r\n                                  ? 512\r\n                                  : 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if (parser.token === 67174411) {\r\n                      destructible |= 16;\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if (parser.token === 8457011) {\r\n                      destructible |= 16;\r\n                      if (token === 12399 || token === 12400) {\r\n                          report(parser, 40);\r\n                      }\r\n                      else if (token === 143480) {\r\n                          report(parser, 92);\r\n                      }\r\n                      nextToken(parser, context);\r\n                      state |=\r\n                          8 | 1 | (token === 143468 ? 16 : 0);\r\n                      if (parser.token & 143360) {\r\n                          key = parseIdentifier(parser, context, 0);\r\n                      }\r\n                      else if ((parser.token & 134217728) === 134217728) {\r\n                          key = parseLiteral(parser, context);\r\n                      }\r\n                      else if (parser.token === 69271571) {\r\n                          state |= 2;\r\n                          key = parseComputedPropertyName(parser, context, inGroup);\r\n                          destructible |= parser.assignable;\r\n                      }\r\n                      else {\r\n                          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n                      }\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else if ((parser.token & 134217728) === 134217728) {\r\n                      if (token === 143468)\r\n                          state |= 16;\r\n                      state |=\r\n                          token === 12399\r\n                              ? 256\r\n                              : token === 12400\r\n                                  ? 512\r\n                                  : 1;\r\n                      destructible |= 16;\r\n                      key = parseLiteral(parser, context);\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else {\r\n                      report(parser, 129);\r\n                  }\r\n              }\r\n              else if ((parser.token & 134217728) === 134217728) {\r\n                  key = parseLiteral(parser, context);\r\n                  if (parser.token === 21) {\r\n                      consume(parser, context | 32768, 21);\r\n                      const { tokenPos, linePos, colPos } = parser;\r\n                      if (tokenValue === '__proto__')\r\n                          prototypeCount++;\r\n                      if (parser.token & 143360) {\r\n                          value = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                          const { token, tokenValue: valueAfterColon } = parser;\r\n                          value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (token === 1077936157 || token === 1074790415 || token === 1073741842) {\r\n                                  if (parser.assignable & 2) {\r\n                                      destructible |= 16;\r\n                                  }\r\n                                  else if (scope) {\r\n                                      addVarOrBlock(parser, context, scope, valueAfterColon, kind, origin);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  destructible |=\r\n                                      parser.assignable & 1\r\n                                          ? 32\r\n                                          : 16;\r\n                              }\r\n                          }\r\n                          else if (parser.token === 1077936157) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                          else {\r\n                              destructible |= 16;\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                      }\r\n                      else if ((parser.token & 2097152) === 2097152) {\r\n                          value =\r\n                              parser.token === 69271571\r\n                                  ? parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                                  : parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                          destructible = parser.destructible;\r\n                          parser.assignable =\r\n                              destructible & 16 ? 2 : 1;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2) {\r\n                                  destructible |= 16;\r\n                              }\r\n                          }\r\n                          else if ((parser.destructible & 8) !== 8) {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 2 ? 16 : 0;\r\n                              if ((parser.token & 4194304) === 4194304) {\r\n                                  value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                              else {\r\n                                  if ((parser.token & 8454144) === 8454144) {\r\n                                      value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                                  }\r\n                                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                                      value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                                  }\r\n                                  destructible |=\r\n                                      parser.assignable & 2\r\n                                          ? 16\r\n                                          : 32;\r\n                              }\r\n                          }\r\n                      }\r\n                      else {\r\n                          value = parseLeftHandSideExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n                          destructible |=\r\n                              parser.assignable & 1\r\n                                  ? 32\r\n                                  : 16;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2) {\r\n                                  destructible |= 16;\r\n                              }\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 1 ? 0 : 16;\r\n                              if (parser.token !== 1073741842 && parser.token !== 1074790415) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (parser.token === 67174411) {\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                      destructible = parser.assignable | 16;\r\n                  }\r\n                  else {\r\n                      report(parser, 130);\r\n                  }\r\n              }\r\n              else if (parser.token === 69271571) {\r\n                  key = parseComputedPropertyName(parser, context, inGroup);\r\n                  destructible |= parser.destructible & 256 ? 256 : 0;\r\n                  state |= 2;\r\n                  if (parser.token === 21) {\r\n                      nextToken(parser, context | 32768);\r\n                      const { tokenPos, linePos, colPos, tokenValue, token: tokenAfterColon } = parser;\r\n                      if (parser.token & 143360) {\r\n                          value = parsePrimaryExpression(parser, context, kind, 0, 1, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n                          const { token } = parser;\r\n                          value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                          if ((parser.token & 4194304) === 4194304) {\r\n                              destructible |=\r\n                                  parser.assignable & 2\r\n                                      ? 16\r\n                                      : token === 1077936157\r\n                                          ? 0\r\n                                          : 32;\r\n                              value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                          else if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (token === 1077936157 || token === 1074790415 || token === 1073741842) {\r\n                                  if (parser.assignable & 2) {\r\n                                      destructible |= 16;\r\n                                  }\r\n                                  else if (scope && (tokenAfterColon & 143360) === 143360) {\r\n                                      addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n                                  }\r\n                              }\r\n                              else {\r\n                                  destructible |=\r\n                                      parser.assignable & 1\r\n                                          ? 32\r\n                                          : 16;\r\n                              }\r\n                          }\r\n                          else {\r\n                              destructible |= 16;\r\n                              value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                          }\r\n                      }\r\n                      else if ((parser.token & 2097152) === 2097152) {\r\n                          value =\r\n                              parser.token === 69271571\r\n                                  ? parseArrayExpressionOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos)\r\n                                  : parseObjectLiteralOrPattern(parser, context, scope, 0, inGroup, isPattern, kind, origin, tokenPos, linePos, colPos);\r\n                          destructible = parser.destructible;\r\n                          parser.assignable =\r\n                              destructible & 16 ? 2 : 1;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else if (destructible & 8) {\r\n                              report(parser, 59);\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible =\r\n                                  parser.assignable & 2 ? destructible | 16 : 0;\r\n                              if ((parser.token & 4194304) === 4194304) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpressionOrPattern(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                              else {\r\n                                  if ((parser.token & 8454144) === 8454144) {\r\n                                      value = parseBinaryExpression(parser, context, 1, tokenPos, linePos, colPos, 4, token, value);\r\n                                  }\r\n                                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                                      value = parseConditionalExpression(parser, context, value, tokenPos, linePos, colPos);\r\n                                  }\r\n                                  destructible |=\r\n                                      parser.assignable & 2\r\n                                          ? 16\r\n                                          : 32;\r\n                              }\r\n                          }\r\n                      }\r\n                      else {\r\n                          value = parseLeftHandSideExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n                          destructible |=\r\n                              parser.assignable & 1\r\n                                  ? 32\r\n                                  : 16;\r\n                          if (parser.token === 1073741842 || parser.token === 1074790415) {\r\n                              if (parser.assignable & 2)\r\n                                  destructible |= 16;\r\n                          }\r\n                          else {\r\n                              value = parseMemberOrUpdateExpression(parser, context, value, inGroup, tokenPos, linePos, colPos);\r\n                              destructible = parser.assignable & 1 ? 0 : 16;\r\n                              if (parser.token !== 1073741842 && parser.token !== 1074790415) {\r\n                                  if (parser.token !== 1077936157)\r\n                                      destructible |= 16;\r\n                                  value = parseAssignmentExpression(parser, context, inGroup, isPattern, tokenPos, linePos, colPos, value);\r\n                              }\r\n                          }\r\n                      }\r\n                  }\r\n                  else if (parser.token === 67174411) {\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, linePos, colPos);\r\n                      destructible = 16;\r\n                  }\r\n                  else {\r\n                      report(parser, 41);\r\n                  }\r\n              }\r\n              else if (token === 8457011) {\r\n                  consume(parser, context | 32768, 8457011);\r\n                  state |= 8;\r\n                  if (parser.token & 143360) {\r\n                      const { token, line, index } = parser;\r\n                      key = parseIdentifier(parser, context, 0);\r\n                      state |= 1;\r\n                      if (parser.token === 67174411) {\r\n                          destructible |= 16;\r\n                          value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                      }\r\n                      else {\r\n                          reportMessageAt(index, line, index, token === 143468\r\n                              ? 43\r\n                              : token === 12399 || parser.token === 12400\r\n                                  ? 42\r\n                                  : 44, KeywordDescTable[token & 255]);\r\n                      }\r\n                  }\r\n                  else if ((parser.token & 134217728) === 134217728) {\r\n                      destructible |= 16;\r\n                      key = parseLiteral(parser, context);\r\n                      state |= 1;\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, tokenPos, linePos, colPos);\r\n                  }\r\n                  else if (parser.token === 69271571) {\r\n                      destructible |= 16;\r\n                      state |= 2 | 1;\r\n                      key = parseComputedPropertyName(parser, context, inGroup);\r\n                      value = parseMethodDefinition(parser, context, state, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n                  }\r\n                  else {\r\n                      report(parser, 122);\r\n                  }\r\n              }\r\n              else {\r\n                  report(parser, 28, KeywordDescTable[token & 255]);\r\n              }\r\n              destructible |= parser.destructible & 128 ? 128 : 0;\r\n              parser.destructible = destructible;\r\n              properties.push(finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                  type: 'Property',\r\n                  key: key,\r\n                  value,\r\n                  kind: !(state & 768) ? 'init' : state & 512 ? 'set' : 'get',\r\n                  computed: (state & 2) > 0,\r\n                  method: (state & 1) > 0,\r\n                  shorthand: (state & 4) > 0\r\n              }));\r\n          }\r\n          destructible |= parser.destructible;\r\n          if (parser.token !== 1073741842)\r\n              break;\r\n          nextToken(parser, context);\r\n      }\r\n      consume(parser, context, 1074790415);\r\n      if (prototypeCount > 1)\r\n          destructible |= 64;\r\n      const node = finishNode(parser, context, start, line, column, {\r\n          type: isPattern ? 'ObjectPattern' : 'ObjectExpression',\r\n          properties\r\n      });\r\n      if (!skipInitializer && parser.token & 4194304) {\r\n          return parseArrayOrObjectAssignmentPattern(parser, context, destructible, inGroup, isPattern, start, line, column, node);\r\n      }\r\n      parser.destructible = destructible;\r\n      return node;\r\n  }\r\n  function parseMethodFormals(parser, context, scope, kind, type, inGroup) {\r\n      consume(parser, context, 67174411);\r\n      const params = [];\r\n      parser.flags = (parser.flags | 128) ^ 128;\r\n      if (parser.token === 16) {\r\n          if (kind & 512) {\r\n              report(parser, 35, 'Setter', 'one', '');\r\n          }\r\n          nextToken(parser, context);\r\n          return params;\r\n      }\r\n      if (kind & 256) {\r\n          report(parser, 35, 'Getter', 'no', 's');\r\n      }\r\n      if (kind & 512 && parser.token === 14) {\r\n          report(parser, 36);\r\n      }\r\n      context = (context | 134217728) ^ 134217728;\r\n      let setterArgs = 0;\r\n      let isSimpleParameterList = 0;\r\n      while (parser.token !== 1073741842) {\r\n          let left = null;\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          if (parser.token & 143360) {\r\n              if ((context & 1024) < 1) {\r\n                  if ((parser.token & 36864) === 36864) {\r\n                      parser.flags |= 256;\r\n                  }\r\n                  if ((parser.token & 537079808) === 537079808) {\r\n                      parser.flags |= 512;\r\n                  }\r\n              }\r\n              left = parseAndClassifyIdentifier(parser, context, scope, kind | 1, 0, tokenPos, linePos, colPos);\r\n          }\r\n          else {\r\n              if (parser.token === 2162700) {\r\n                  left = parseObjectLiteralOrPattern(parser, context, scope, 1, inGroup, 1, type, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 69271571) {\r\n                  left = parseArrayExpressionOrPattern(parser, context, scope, 1, inGroup, 1, type, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 14) {\r\n                  left = parseSpreadOrRestElement(parser, context, scope, 16, type, 0, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n              }\r\n              isSimpleParameterList = 1;\r\n              if (parser.destructible & (32 | 16))\r\n                  report(parser, 47);\r\n          }\r\n          if (parser.token === 1077936157) {\r\n              nextToken(parser, context | 32768);\r\n              isSimpleParameterList = 1;\r\n              const right = parseExpression(parser, context, 1, 1, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n              left = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                  type: 'AssignmentPattern',\r\n                  left: left,\r\n                  right\r\n              });\r\n          }\r\n          setterArgs++;\r\n          params.push(left);\r\n          if (!consumeOpt(parser, context, 1073741842))\r\n              break;\r\n          if (parser.token === 16) {\r\n              break;\r\n          }\r\n      }\r\n      if (kind & 512 && setterArgs !== 1) {\r\n          report(parser, 35, 'Setter', 'one', '');\r\n      }\r\n      if (scope && scope.scopeError !== void 0)\r\n          reportScopeError(scope.scopeError);\r\n      if (isSimpleParameterList)\r\n          parser.flags |= 128;\r\n      consume(parser, context, 16);\r\n      return params;\r\n  }\r\n  function parseComputedPropertyName(parser, context, inGroup) {\r\n      nextToken(parser, context | 32768);\r\n      const key = parseExpression(parser, (context | 134217728) ^ 134217728, 1, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 20);\r\n      return key;\r\n  }\r\n  function parseParenthesizedExpression(parser, context, canAssign, kind, origin, start, line, column) {\r\n      parser.flags = (parser.flags | 128) ^ 128;\r\n      nextToken(parser, context | 32768 | 1073741824);\r\n      const scope = context & 64 ? addChildScope(createScope(), 1024) : void 0;\r\n      context = (context | 134217728 | 8192) ^ (8192 | 134217728);\r\n      if (consumeOpt(parser, context, 16)) {\r\n          return parseParenthesizedArrow(parser, context, scope, [], canAssign, 0, start, line, column);\r\n      }\r\n      let destructible = 0;\r\n      parser.destructible &= ~(256 | 128);\r\n      let expr;\r\n      let expressions = [];\r\n      let isSequence = 0;\r\n      let isSimpleParameterList = 0;\r\n      const { tokenPos: iStart, linePos: lStart, colPos: cStart } = parser;\r\n      parser.assignable = 1;\r\n      while (parser.token !== 16) {\r\n          const { token, tokenPos, linePos, colPos } = parser;\r\n          if (token & (143360 | 4096)) {\r\n              if (scope)\r\n                  addBlockName(parser, context, scope, parser.tokenValue, 1, 0);\r\n              expr = parsePrimaryExpression(parser, context, kind, 0, 1, 0, 1, 1, tokenPos, linePos, colPos);\r\n              if (parser.token === 16 || parser.token === 1073741842) {\r\n                  if (parser.assignable & 2) {\r\n                      destructible |= 16;\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else if ((token & 537079808) === 537079808 ||\r\n                      (token & 36864) === 36864) {\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n              }\r\n              else {\r\n                  if (parser.token === 1077936157) {\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else {\r\n                      destructible |= 16;\r\n                  }\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                      expr = parseAssignmentExpression(parser, context, 1, 0, tokenPos, linePos, colPos, expr);\r\n                  }\r\n              }\r\n          }\r\n          else if ((token & 2097152) === 2097152) {\r\n              expr =\r\n                  token === 2162700\r\n                      ? parseObjectLiteralOrPattern(parser, context | 1073741824, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos)\r\n                      : parseArrayExpressionOrPattern(parser, context | 1073741824, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos);\r\n              destructible |= parser.destructible;\r\n              isSimpleParameterList = 1;\r\n              parser.assignable = 2;\r\n              if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                  if (destructible & 8)\r\n                      report(parser, 118);\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 0, tokenPos, linePos, colPos);\r\n                  destructible |= 16;\r\n                  if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                      expr = parseAssignmentExpression(parser, context, 0, 0, tokenPos, linePos, colPos, expr);\r\n                  }\r\n              }\r\n          }\r\n          else if (token === 14) {\r\n              expr = parseSpreadOrRestElement(parser, context, scope, 16, kind, origin, 0, 1, 0, tokenPos, linePos, colPos);\r\n              if (parser.destructible & 16)\r\n                  report(parser, 71);\r\n              isSimpleParameterList = 1;\r\n              if (isSequence && (parser.token === 16 || parser.token === 1073741842)) {\r\n                  expressions.push(expr);\r\n              }\r\n              destructible |= 8;\r\n              break;\r\n          }\r\n          else {\r\n              destructible |= 16;\r\n              expr = parseExpression(parser, context, 1, 0, 1, tokenPos, linePos, colPos);\r\n              if (isSequence && (parser.token === 16 || parser.token === 1073741842)) {\r\n                  expressions.push(expr);\r\n              }\r\n              if (parser.token === 1073741842) {\r\n                  if (!isSequence) {\r\n                      isSequence = 1;\r\n                      expressions = [expr];\r\n                  }\r\n              }\r\n              if (isSequence) {\r\n                  while (consumeOpt(parser, context | 32768, 1073741842)) {\r\n                      expressions.push(parseExpression(parser, context, 1, 0, 1, parser.tokenPos, parser.linePos, parser.colPos));\r\n                  }\r\n                  parser.assignable = 2;\r\n                  expr = finishNode(parser, context, iStart, lStart, cStart, {\r\n                      type: 'SequenceExpression',\r\n                      expressions\r\n                  });\r\n              }\r\n              consume(parser, context, 16);\r\n              parser.destructible = destructible;\r\n              return expr;\r\n          }\r\n          if (isSequence && (parser.token === 16 || parser.token === 1073741842)) {\r\n              expressions.push(expr);\r\n          }\r\n          if (!consumeOpt(parser, context | 32768, 1073741842))\r\n              break;\r\n          if (!isSequence) {\r\n              isSequence = 1;\r\n              expressions = [expr];\r\n          }\r\n          if (parser.token === 16) {\r\n              destructible |= 8;\r\n              break;\r\n          }\r\n      }\r\n      if (isSequence) {\r\n          parser.assignable = 2;\r\n          expr = finishNode(parser, context, iStart, lStart, cStart, {\r\n              type: 'SequenceExpression',\r\n              expressions\r\n          });\r\n      }\r\n      consume(parser, context, 16);\r\n      if (destructible & 16 && destructible & 8)\r\n          report(parser, 145);\r\n      destructible |=\r\n          parser.destructible & 256\r\n              ? 256\r\n              : 0 | (parser.destructible & 128)\r\n                  ? 128\r\n                  : 0;\r\n      if (parser.token === 10) {\r\n          if (destructible & (32 | 16))\r\n              report(parser, 46);\r\n          if (context & (4194304 | 2048) && destructible & 128)\r\n              report(parser, 29);\r\n          if (context & (1024 | 2097152) && destructible & 256) {\r\n              report(parser, 30);\r\n          }\r\n          if (isSimpleParameterList)\r\n              parser.flags |= 128;\r\n          return parseParenthesizedArrow(parser, context, scope, isSequence ? expressions : [expr], canAssign, 0, start, line, column);\r\n      }\r\n      else if (destructible & 8) {\r\n          report(parser, 139);\r\n      }\r\n      parser.destructible = ((parser.destructible | 256) ^ 256) | destructible;\r\n      return context & 128\r\n          ? finishNode(parser, context, iStart, lStart, cStart, {\r\n              type: 'ParenthesizedExpression',\r\n              expression: expr\r\n          })\r\n          : expr;\r\n  }\r\n  function parseIdentifierOrArrow(parser, context, start, line, column) {\r\n      const { tokenValue } = parser;\r\n      const expr = parseIdentifier(parser, context, 0);\r\n      parser.assignable = 1;\r\n      if (parser.token === 10) {\r\n          let scope = void 0;\r\n          if (context & 64)\r\n              scope = createArrowHeadParsingScope(parser, context, tokenValue);\r\n          parser.flags = (parser.flags | 128) ^ 128;\r\n          return parseArrowFunctionExpression(parser, context, scope, [expr], 0, start, line, column);\r\n      }\r\n      return expr;\r\n  }\r\n  function parseArrowFromIdentifier(parser, context, value, expr, inNew, canAssign, isAsync, start, line, column) {\r\n      if (!canAssign)\r\n          report(parser, 54);\r\n      if (inNew)\r\n          report(parser, 48);\r\n      parser.flags &= ~128;\r\n      const scope = context & 64 ? createArrowHeadParsingScope(parser, context, value) : void 0;\r\n      return parseArrowFunctionExpression(parser, context, scope, [expr], isAsync, start, line, column);\r\n  }\r\n  function parseParenthesizedArrow(parser, context, scope, params, canAssign, isAsync, start, line, column) {\r\n      if (!canAssign)\r\n          report(parser, 54);\r\n      for (let i = 0; i < params.length; ++i)\r\n          reinterpretToPattern(parser, params[i]);\r\n      return parseArrowFunctionExpression(parser, context, scope, params, isAsync, start, line, column);\r\n  }\r\n  function parseArrowFunctionExpression(parser, context, scope, params, isAsync, start, line, column) {\r\n      if (parser.flags & 1)\r\n          report(parser, 45);\r\n      consume(parser, context | 32768, 10);\r\n      context = ((context | 15728640) ^ 15728640) | (isAsync << 22);\r\n      const expression = parser.token !== 2162700;\r\n      let body;\r\n      if (scope && scope.scopeError !== void 0) {\r\n          reportScopeError(scope.scopeError);\r\n      }\r\n      if (expression) {\r\n          body = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      }\r\n      else {\r\n          if (scope)\r\n              scope = addChildScope(scope, 128);\r\n          body = parseFunctionBody(parser, (context | 134221824 | 8192 | 16384) ^\r\n              (134221824 | 8192 | 16384), scope, 16, void 0, void 0);\r\n          switch (parser.token) {\r\n              case 69271571:\r\n                  if ((parser.flags & 1) < 1) {\r\n                      report(parser, 112);\r\n                  }\r\n                  break;\r\n              case 67108877:\r\n              case 67174409:\r\n              case 22:\r\n                  report(parser, 113);\r\n              case 67174411:\r\n                  if ((parser.flags & 1) < 1) {\r\n                      report(parser, 112);\r\n                  }\r\n                  parser.flags |= 1024;\r\n                  break;\r\n          }\r\n          if ((parser.token & 8454144) === 8454144 && (parser.flags & 1) < 1)\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n          if ((parser.token & 33619968) === 33619968)\r\n              report(parser, 121);\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'ArrowFunctionExpression',\r\n          params,\r\n          body,\r\n          async: isAsync === 1,\r\n          expression\r\n      });\r\n  }\r\n  function parseFormalParametersOrFormalList(parser, context, scope, inGroup, kind) {\r\n      consume(parser, context, 67174411);\r\n      parser.flags = (parser.flags | 128) ^ 128;\r\n      const params = [];\r\n      if (consumeOpt(parser, context, 16))\r\n          return params;\r\n      context = (context | 134217728) ^ 134217728;\r\n      let isSimpleParameterList = 0;\r\n      while (parser.token !== 1073741842) {\r\n          let left;\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          if (parser.token & 143360) {\r\n              if ((context & 1024) < 1) {\r\n                  if ((parser.token & 36864) === 36864) {\r\n                      parser.flags |= 256;\r\n                  }\r\n                  if ((parser.token & 537079808) === 537079808) {\r\n                      parser.flags |= 512;\r\n                  }\r\n              }\r\n              left = parseAndClassifyIdentifier(parser, context, scope, kind | 1, 0, tokenPos, linePos, colPos);\r\n          }\r\n          else {\r\n              if (parser.token === 2162700) {\r\n                  left = parseObjectLiteralOrPattern(parser, context, scope, 1, inGroup, 1, kind, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 69271571) {\r\n                  left = parseArrayExpressionOrPattern(parser, context, scope, 1, inGroup, 1, kind, 0, tokenPos, linePos, colPos);\r\n              }\r\n              else if (parser.token === 14) {\r\n                  left = parseSpreadOrRestElement(parser, context, scope, 16, kind, 0, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n              }\r\n              else {\r\n                  report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n              }\r\n              isSimpleParameterList = 1;\r\n              if (parser.destructible & (32 | 16)) {\r\n                  report(parser, 47);\r\n              }\r\n          }\r\n          if (parser.token === 1077936157) {\r\n              nextToken(parser, context | 32768);\r\n              isSimpleParameterList = 1;\r\n              const right = parseExpression(parser, context, 1, 1, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n              left = finishNode(parser, context, tokenPos, linePos, colPos, {\r\n                  type: 'AssignmentPattern',\r\n                  left,\r\n                  right\r\n              });\r\n          }\r\n          params.push(left);\r\n          if (!consumeOpt(parser, context, 1073741842))\r\n              break;\r\n          if (parser.token === 16) {\r\n              break;\r\n          }\r\n      }\r\n      if (isSimpleParameterList)\r\n          parser.flags |= 128;\r\n      if (scope && (isSimpleParameterList || context & 1024) && scope.scopeError !== void 0) {\r\n          reportScopeError(scope.scopeError);\r\n      }\r\n      consume(parser, context, 16);\r\n      return params;\r\n  }\r\n  function parseMembeExpressionNoCall(parser, context, expr, inGroup, start, line, column) {\r\n      const { token } = parser;\r\n      if (token & 67108864) {\r\n          if (token === 67108877) {\r\n              nextToken(parser, context | 1073741824);\r\n              parser.assignable = 1;\r\n              const property = parsePropertyOrPrivatePropertyName(parser, context);\r\n              return parseMembeExpressionNoCall(parser, context, finishNode(parser, context, start, line, column, {\r\n                  type: 'MemberExpression',\r\n                  object: expr,\r\n                  computed: false,\r\n                  property\r\n              }), 0, start, line, column);\r\n          }\r\n          else if (token === 69271571) {\r\n              nextToken(parser, context | 32768);\r\n              const { tokenPos, linePos, colPos } = parser;\r\n              const property = parseExpressions(parser, context, inGroup, 1, tokenPos, linePos, colPos);\r\n              consume(parser, context, 20);\r\n              parser.assignable = 1;\r\n              return parseMembeExpressionNoCall(parser, context, finishNode(parser, context, start, line, column, {\r\n                  type: 'MemberExpression',\r\n                  object: expr,\r\n                  computed: true,\r\n                  property\r\n              }), 0, start, line, column);\r\n          }\r\n          else if (token === 67174408 || token === 67174409) {\r\n              parser.assignable = 2;\r\n              return parseMembeExpressionNoCall(parser, context, finishNode(parser, context, parser.tokenPos, parser.linePos, parser.colPos, {\r\n                  type: 'TaggedTemplateExpression',\r\n                  tag: expr,\r\n                  quasi: parser.token === 67174408\r\n                      ? parseTemplate(parser, context | 65536, start, line, column)\r\n                      : parseTemplateLiteral(parser, context, start, line, column)\r\n              }), 0, start, line, column);\r\n          }\r\n      }\r\n      return expr;\r\n  }\r\n  function parseNewExpression(parser, context, inGroup, start, line, column) {\r\n      const id = parseIdentifier(parser, context | 32768, 0);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      if (consumeOpt(parser, context, 67108877)) {\r\n          if (context & 67108864 && parser.token === 143491) {\r\n              parser.assignable = 2;\r\n              return parseMetaProperty(parser, context, id, start, line, column);\r\n          }\r\n          report(parser, 91);\r\n      }\r\n      parser.assignable = 2;\r\n      if ((parser.token & 16842752) === 16842752) {\r\n          report(parser, 62, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      const expr = parsePrimaryExpression(parser, context, 2, 1, 0, 0, inGroup, 1, tokenPos, linePos, colPos);\r\n      context = (context | 134217728) ^ 134217728;\r\n      if (parser.token === 67108988)\r\n          report(parser, 162);\r\n      const callee = parseMembeExpressionNoCall(parser, context, expr, inGroup, tokenPos, linePos, colPos);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'NewExpression',\r\n          callee,\r\n          arguments: parser.token === 67174411 ? parseArguments(parser, context, inGroup) : []\r\n      });\r\n  }\r\n  function parseMetaProperty(parser, context, meta, start, line, column) {\r\n      const property = parseIdentifier(parser, context, 0);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'MetaProperty',\r\n          meta,\r\n          property\r\n      });\r\n  }\r\n  function parseAsyncArrowAfterIdent(parser, context, canAssign, start, line, column) {\r\n      if (parser.token === 209005)\r\n          report(parser, 29);\r\n      if (context & (1024 | 2097152) && parser.token === 241770) {\r\n          report(parser, 30);\r\n      }\r\n      if ((parser.token & 537079808) === 537079808) {\r\n          parser.flags |= 512;\r\n      }\r\n      return parseArrowFromIdentifier(parser, context, parser.tokenValue, parseIdentifier(parser, context, 0), 0, canAssign, 1, start, line, column);\r\n  }\r\n  function parseAsyncArrowOrCallExpression(parser, context, callee, canAssign, kind, origin, flags, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      const scope = context & 64 ? addChildScope(createScope(), 1024) : void 0;\r\n      context = (context | 134217728) ^ 134217728;\r\n      if (consumeOpt(parser, context, 16)) {\r\n          if (parser.token === 10) {\r\n              if (flags & 1)\r\n                  report(parser, 45);\r\n              return parseParenthesizedArrow(parser, context, scope, [], canAssign, 1, start, line, column);\r\n          }\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'CallExpression',\r\n              callee,\r\n              arguments: []\r\n          });\r\n      }\r\n      let destructible = 0;\r\n      let expr = null;\r\n      let isSimpleParameterList = 0;\r\n      parser.destructible =\r\n          (parser.destructible | 256 | 128) ^\r\n              (256 | 128);\r\n      const params = [];\r\n      while (parser.token !== 16) {\r\n          const { token, tokenPos, linePos, colPos } = parser;\r\n          if (token & (143360 | 4096)) {\r\n              if (scope)\r\n                  addBlockName(parser, context, scope, parser.tokenValue, kind, 0);\r\n              expr = parsePrimaryExpression(parser, context, kind, 0, 1, 0, 1, 1, tokenPos, linePos, colPos);\r\n              if (parser.token === 16 || parser.token === 1073741842) {\r\n                  if (parser.assignable & 2) {\r\n                      destructible |= 16;\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else if ((token & 537079808) === 537079808) {\r\n                      parser.flags |= 512;\r\n                  }\r\n                  else if ((token & 36864) === 36864) {\r\n                      parser.flags |= 256;\r\n                  }\r\n              }\r\n              else {\r\n                  if (parser.token === 1077936157) {\r\n                      isSimpleParameterList = 1;\r\n                  }\r\n                  else {\r\n                      destructible |= 16;\r\n                  }\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 1, tokenPos, linePos, colPos);\r\n                  if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                      expr = parseAssignmentExpression(parser, context, 1, 0, tokenPos, linePos, colPos, expr);\r\n                  }\r\n              }\r\n          }\r\n          else if (token & 2097152) {\r\n              expr =\r\n                  token === 2162700\r\n                      ? parseObjectLiteralOrPattern(parser, context, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos)\r\n                      : parseArrayExpressionOrPattern(parser, context, scope, 0, 1, 0, kind, origin, tokenPos, linePos, colPos);\r\n              destructible |= parser.destructible;\r\n              isSimpleParameterList = 1;\r\n              if (parser.token !== 16 && parser.token !== 1073741842) {\r\n                  if (destructible & 8)\r\n                      report(parser, 118);\r\n                  expr = parseMemberOrUpdateExpression(parser, context, expr, 0, tokenPos, linePos, colPos);\r\n                  destructible |= 16;\r\n                  if ((parser.token & 8454144) === 8454144) {\r\n                      expr = parseBinaryExpression(parser, context, 1, start, line, column, 4, token, expr);\r\n                  }\r\n                  if (consumeOpt(parser, context | 32768, 22)) {\r\n                      expr = parseConditionalExpression(parser, context, expr, start, line, column);\r\n                  }\r\n              }\r\n          }\r\n          else if (token === 14) {\r\n              expr = parseSpreadOrRestElement(parser, context, scope, 16, kind, origin, 1, 1, 0, tokenPos, linePos, colPos);\r\n              destructible |= (parser.token === 16 ? 0 : 16) | parser.destructible;\r\n              isSimpleParameterList = 1;\r\n          }\r\n          else {\r\n              expr = parseExpression(parser, context, 1, 0, 0, tokenPos, linePos, colPos);\r\n              destructible = parser.assignable;\r\n              params.push(expr);\r\n              while (consumeOpt(parser, context | 32768, 1073741842)) {\r\n                  params.push(parseExpression(parser, context, 1, 0, 0, tokenPos, linePos, colPos));\r\n              }\r\n              destructible |= parser.assignable;\r\n              consume(parser, context, 16);\r\n              parser.destructible = destructible | 16;\r\n              parser.assignable = 2;\r\n              return finishNode(parser, context, start, line, column, {\r\n                  type: 'CallExpression',\r\n                  callee,\r\n                  arguments: params\r\n              });\r\n          }\r\n          params.push(expr);\r\n          if (!consumeOpt(parser, context | 32768, 1073741842))\r\n              break;\r\n      }\r\n      consume(parser, context, 16);\r\n      destructible |=\r\n          parser.destructible & 256\r\n              ? 256\r\n              : 0 | (parser.destructible & 128)\r\n                  ? 128\r\n                  : 0;\r\n      if (parser.token === 10) {\r\n          if (destructible & (32 | 16))\r\n              report(parser, 25);\r\n          if (parser.flags & 1 || flags & 1)\r\n              report(parser, 45);\r\n          if (destructible & 128)\r\n              report(parser, 29);\r\n          if (context & (1024 | 2097152) && destructible & 256)\r\n              report(parser, 30);\r\n          if (isSimpleParameterList)\r\n              parser.flags |= 128;\r\n          return parseParenthesizedArrow(parser, context, scope, params, canAssign, 1, start, line, column);\r\n      }\r\n      else if (destructible & 8) {\r\n          report(parser, 59);\r\n      }\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'CallExpression',\r\n          callee,\r\n          arguments: params\r\n      });\r\n  }\r\n  function parseRegExpLiteral(parser, context, start, line, column) {\r\n      const { tokenRaw, tokenRegExp, tokenValue } = parser;\r\n      nextToken(parser, context);\r\n      parser.assignable = 2;\r\n      return context & 512\r\n          ? finishNode(parser, context, start, line, column, {\r\n              type: 'Literal',\r\n              value: tokenValue,\r\n              regex: tokenRegExp,\r\n              raw: tokenRaw\r\n          })\r\n          : finishNode(parser, context, start, line, column, {\r\n              type: 'Literal',\r\n              value: tokenValue,\r\n              regex: tokenRegExp\r\n          });\r\n  }\r\n  function parseClassDeclaration(parser, context, scope, flags, start, line, column) {\r\n      context = (context | 16777216 | 1024) ^ 16777216;\r\n      const decorators = context & 1 ? parseDecorators(parser, context) : [];\r\n      nextToken(parser, context);\r\n      let id = null;\r\n      let superClass = null;\r\n      const { tokenValue } = parser;\r\n      if (((parser.token & 4351) ^ 84) >\r\n          4096) {\r\n          if (isStrictReservedWord(parser, context, parser.token)) {\r\n              report(parser, 114);\r\n          }\r\n          if ((parser.token & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          if (scope) {\r\n              addBlockName(parser, context, scope, tokenValue, 32, 0);\r\n              if (flags) {\r\n                  if (flags & 2) {\r\n                      declareUnboundVariable(parser, tokenValue);\r\n                  }\r\n              }\r\n          }\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      else {\r\n          if ((flags & 1) < 1)\r\n              report(parser, 37, 'Class');\r\n      }\r\n      let inheritedContext = context;\r\n      if (consumeOpt(parser, context | 32768, 20564)) {\r\n          superClass = parseLeftHandSideExpression(parser, context, 0, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          inheritedContext |= 524288;\r\n      }\r\n      else {\r\n          inheritedContext = (inheritedContext | 524288) ^ 524288;\r\n      }\r\n      const body = parseClassBody(parser, inheritedContext, context, scope, 2, 8, 0);\r\n      return finishNode(parser, context, start, line, column, context & 1\r\n          ? {\r\n              type: 'ClassDeclaration',\r\n              id,\r\n              superClass,\r\n              decorators,\r\n              body\r\n          }\r\n          : {\r\n              type: 'ClassDeclaration',\r\n              id,\r\n              superClass,\r\n              body\r\n          });\r\n  }\r\n  function parseClassExpression(parser, context, inGroup, start, line, column) {\r\n      let id = null;\r\n      let superClass = null;\r\n      context = (context | 1024 | 16777216) ^ 16777216;\r\n      const decorators = context & 1 ? parseDecorators(parser, context) : [];\r\n      nextToken(parser, context);\r\n      if (((parser.token & 0x10ff) ^ 0x54) > 0x1000) {\r\n          if (isStrictReservedWord(parser, context, parser.token))\r\n              report(parser, 114);\r\n          if ((parser.token & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          id = parseIdentifier(parser, context, 0);\r\n      }\r\n      let inheritedContext = context;\r\n      if (consumeOpt(parser, context | 32768, 20564)) {\r\n          superClass = parseLeftHandSideExpression(parser, context, 0, inGroup, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n          inheritedContext |= 524288;\r\n      }\r\n      else {\r\n          inheritedContext = (inheritedContext | 524288) ^ 524288;\r\n      }\r\n      const body = parseClassBody(parser, inheritedContext, context, void 0, 2, 0, inGroup);\r\n      parser.assignable = 2;\r\n      return finishNode(parser, context, start, line, column, context & 1\r\n          ? {\r\n              type: 'ClassExpression',\r\n              id,\r\n              superClass,\r\n              decorators,\r\n              body\r\n          }\r\n          : {\r\n              type: 'ClassExpression',\r\n              id,\r\n              superClass,\r\n              body\r\n          });\r\n  }\r\n  function parseDecorators(parser, context) {\r\n      const list = [];\r\n      while (parser.token === 130) {\r\n          list.push(parseDecoratorList(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return list;\r\n  }\r\n  function parseDecoratorList(parser, context, start, line, column) {\r\n      nextToken(parser, context | 32768);\r\n      let expression = parsePrimaryExpression(parser, context, 2, 0, 1, 0, 0, 1, start, line, column);\r\n      expression = parseMemberOrUpdateExpression(parser, context, expression, 0, start, line, column);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'Decorator',\r\n          expression\r\n      });\r\n  }\r\n  function parseClassBody(parser, context, inheritedContext, scope, kind, origin, inGroup) {\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      consume(parser, context | 32768, 2162700);\r\n      context = (context | 134217728) ^ 134217728;\r\n      parser.flags = (parser.flags | 32) ^ 32;\r\n      const body = [];\r\n      let decorators = [];\r\n      while (parser.token !== 1074790415) {\r\n          let length = 0;\r\n          decorators = parseDecorators(parser, context);\r\n          length = decorators.length;\r\n          if (length > 0 && parser.tokenValue === 'constructor') {\r\n              report(parser, 106);\r\n          }\r\n          if (parser.token === 1074790415)\r\n              report(parser, 105);\r\n          if (consumeOpt(parser, context, 1074790417)) {\r\n              if (length > 0)\r\n                  report(parser, 116);\r\n              continue;\r\n          }\r\n          body.push(parseClassElementList(parser, context, scope, inheritedContext, kind, decorators, 0, inGroup, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      consume(parser, origin & 8 ? context | 32768 : context, 1074790415);\r\n      return finishNode(parser, context, tokenPos, linePos, colPos, {\r\n          type: 'ClassBody',\r\n          body\r\n      });\r\n  }\r\n  function parseClassElementList(parser, context, scope, inheritedContext, type, decorators, isStatic, inGroup, start, line, column) {\r\n      let kind = isStatic ? 32 : 0;\r\n      let key = null;\r\n      const { token, tokenPos, linePos, colPos } = parser;\r\n      if (token & (143360 | 36864)) {\r\n          key = parseIdentifier(parser, context, 0);\r\n          switch (token) {\r\n              case 36969:\r\n                  if (!isStatic && parser.token !== 67174411) {\r\n                      return parseClassElementList(parser, context, scope, inheritedContext, type, decorators, 1, inGroup, start, line, column);\r\n                  }\r\n                  break;\r\n              case 143468:\r\n                  if (parser.token !== 67174411 && (parser.flags & 1) < 1) {\r\n                      if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n                          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n                      }\r\n                      kind |= 16 | (optionalBit(parser, context, 8457011) ? 8 : 0);\r\n                  }\r\n                  break;\r\n              case 12399:\r\n                  if (parser.token !== 67174411) {\r\n                      if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n                          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n                      }\r\n                      kind |= 256;\r\n                  }\r\n                  break;\r\n              case 12400:\r\n                  if (parser.token !== 67174411) {\r\n                      if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n                          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n                      }\r\n                      kind |= 512;\r\n                  }\r\n                  break;\r\n          }\r\n      }\r\n      else if (token === 69271571) {\r\n          kind = 2;\r\n          key = parseComputedPropertyName(parser, inheritedContext, inGroup);\r\n      }\r\n      else if ((token & 134217728) === 134217728) {\r\n          key = parseLiteral(parser, context);\r\n      }\r\n      else if (token === 8457011) {\r\n          kind |= 8;\r\n          nextToken(parser, context);\r\n      }\r\n      else if (context & 1 && parser.token === 128) {\r\n          kind |= 4096;\r\n          key = parsePrivateName(parser, context, tokenPos, linePos, colPos);\r\n          context = context | 16384;\r\n      }\r\n      else if (context & 1 && (parser.token & 1073741824) === 1073741824) {\r\n          kind |= 128;\r\n          context = context | 16384;\r\n      }\r\n      else if (token === 119) {\r\n          key = parseIdentifier(parser, context, 0);\r\n          if (parser.token !== 67174411)\r\n              report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      else {\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      }\r\n      if (kind & (8 | 16 | 768)) {\r\n          if (parser.token & 143360) {\r\n              key = parseIdentifier(parser, context, 0);\r\n          }\r\n          else if ((parser.token & 134217728) === 134217728) {\r\n              key = parseLiteral(parser, context);\r\n          }\r\n          else if (parser.token === 69271571) {\r\n              kind |= 2;\r\n              key = parseComputedPropertyName(parser, context, 0);\r\n          }\r\n          else if (parser.token === 119) {\r\n              key = parseIdentifier(parser, context, 0);\r\n          }\r\n          else if (context & 1 && parser.token === 128) {\r\n              kind |= 4096;\r\n              key = parsePrivateName(parser, context, tokenPos, linePos, colPos);\r\n          }\r\n          else\r\n              report(parser, 131);\r\n      }\r\n      if ((kind & 2) < 1) {\r\n          if (parser.tokenValue === 'constructor') {\r\n              if ((parser.token & 1073741824) === 1073741824) {\r\n                  report(parser, 125);\r\n              }\r\n              else if ((kind & 32) < 1 && parser.token === 67174411) {\r\n                  if (kind & (768 | 16 | 128 | 8)) {\r\n                      report(parser, 50, 'accessor');\r\n                  }\r\n                  else if ((context & 524288) < 1) {\r\n                      if (parser.flags & 32)\r\n                          report(parser, 51);\r\n                      else\r\n                          parser.flags |= 32;\r\n                  }\r\n              }\r\n              kind |= 64;\r\n          }\r\n          else if ((kind & 4096) < 1 &&\r\n              kind & (32 | 768 | 8 | 16) &&\r\n              parser.tokenValue === 'prototype') {\r\n              report(parser, 49);\r\n          }\r\n      }\r\n      if (context & 1 && parser.token !== 67174411) {\r\n          return parseFieldDefinition(parser, context, key, kind, decorators, tokenPos, linePos, colPos);\r\n      }\r\n      const value = parseMethodDefinition(parser, context, kind, inGroup, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, context & 1\r\n          ? {\r\n              type: 'MethodDefinition',\r\n              kind: (kind & 32) < 1 && kind & 64\r\n                  ? 'constructor'\r\n                  : kind & 256\r\n                      ? 'get'\r\n                      : kind & 512\r\n                          ? 'set'\r\n                          : 'method',\r\n              static: (kind & 32) > 0,\r\n              computed: (kind & 2) > 0,\r\n              key,\r\n              decorators,\r\n              value\r\n          }\r\n          : {\r\n              type: 'MethodDefinition',\r\n              kind: (kind & 32) < 1 && kind & 64\r\n                  ? 'constructor'\r\n                  : kind & 256\r\n                      ? 'get'\r\n                      : kind & 512\r\n                          ? 'set'\r\n                          : 'method',\r\n              static: (kind & 32) > 0,\r\n              computed: (kind & 2) > 0,\r\n              key,\r\n              value\r\n          });\r\n  }\r\n  function parsePrivateName(parser, context, start, line, column) {\r\n      nextToken(parser, context);\r\n      const { tokenValue } = parser;\r\n      if (tokenValue === 'constructor')\r\n          report(parser, 124);\r\n      nextToken(parser, context);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'PrivateName',\r\n          name: tokenValue\r\n      });\r\n  }\r\n  function parseFieldDefinition(parser, context, key, state, decorators, start, line, column) {\r\n      let value = null;\r\n      if (state & 8)\r\n          report(parser, 0);\r\n      if (parser.token === 1077936157) {\r\n          nextToken(parser, context | 32768);\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          if (parser.token === 537079925)\r\n              report(parser, 115);\r\n          value = parsePrimaryExpression(parser, context | 16384, 2, 0, 1, 0, 0, 1, tokenPos, linePos, colPos);\r\n          if ((parser.token & 1073741824) !== 1073741824) {\r\n              value = parseMemberOrUpdateExpression(parser, context | 16384, value, 0, tokenPos, linePos, colPos);\r\n              value = parseAssignmentExpression(parser, context | 16384, 0, 0, tokenPos, linePos, colPos, value);\r\n              if (parser.token === 1073741842) {\r\n                  value = parseSequenceExpression(parser, context, 0, start, line, column, value);\r\n              }\r\n          }\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'FieldDefinition',\r\n          key,\r\n          value,\r\n          static: (state & 32) > 0,\r\n          computed: (state & 2) > 0,\r\n          decorators\r\n      });\r\n  }\r\n  function parseBindingPattern(parser, context, scope, type, origin, start, line, column) {\r\n      if (parser.token & 143360)\r\n          return parseAndClassifyIdentifier(parser, context, scope, type, origin, start, line, column);\r\n      if ((parser.token & 2097152) !== 2097152)\r\n          report(parser, 28, KeywordDescTable[parser.token & 255]);\r\n      const left = parser.token === 69271571\r\n          ? parseArrayExpressionOrPattern(parser, context, scope, 1, 0, 1, type, origin, start, line, column)\r\n          : parseObjectLiteralOrPattern(parser, context, scope, 1, 0, 1, type, origin, start, line, column);\r\n      if (parser.destructible & 16)\r\n          report(parser, 47);\r\n      if (parser.destructible & 32)\r\n          report(parser, 47);\r\n      return left;\r\n  }\r\n  function parseAndClassifyIdentifier(parser, context, scope, kind, origin, start, line, column) {\r\n      const { tokenValue, token } = parser;\r\n      if (context & 1024) {\r\n          if ((token & 537079808) === 537079808) {\r\n              report(parser, 115);\r\n          }\r\n          else if ((token & 36864) === 36864) {\r\n              report(parser, 114);\r\n          }\r\n      }\r\n      if ((token & 20480) === 20480) {\r\n          report(parser, 99);\r\n      }\r\n      if (context & (2048 | 2097152) && token === 241770) {\r\n          report(parser, 30);\r\n      }\r\n      if (token === 241736) {\r\n          if (kind & (8 | 16))\r\n              report(parser, 97);\r\n      }\r\n      if (context & (4194304 | 2048) && token === 209005) {\r\n          report(parser, 95);\r\n      }\r\n      nextToken(parser, context);\r\n      if (scope)\r\n          addVarOrBlock(parser, context, scope, tokenValue, kind, origin);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'Identifier',\r\n          name: tokenValue\r\n      });\r\n  }\r\n  function parseJSXRootElementOrFragment(parser, context, inJSXChild, start, line, column) {\r\n      nextToken(parser, context);\r\n      if (parser.token === 8456256) {\r\n          return finishNode(parser, context, start, line, column, {\r\n              type: 'JSXFragment',\r\n              openingFragment: parseOpeningFragment(parser, context, start, line, column),\r\n              children: parseJSXChildren(parser, context),\r\n              closingFragment: parseJSXClosingFragment(parser, context, inJSXChild, parser.tokenPos, parser.linePos, parser.colPos)\r\n          });\r\n      }\r\n      let closingElement = null;\r\n      let children = [];\r\n      const openingElement = parseJSXOpeningFragmentOrSelfCloseElement(parser, context, inJSXChild, start, line, column);\r\n      if (!openingElement.selfClosing) {\r\n          children = parseJSXChildren(parser, context);\r\n          closingElement = parseJSXClosingElement(parser, context, inJSXChild, parser.tokenPos, parser.linePos, parser.colPos);\r\n          const close = isEqualTagName(closingElement.name);\r\n          if (isEqualTagName(openingElement.name) !== close)\r\n              report(parser, 149, close);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXElement',\r\n          children,\r\n          openingElement,\r\n          closingElement\r\n      });\r\n  }\r\n  function parseOpeningFragment(parser, context, start, line, column) {\r\n      scanJSXToken(parser);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXOpeningFragment'\r\n      });\r\n  }\r\n  function parseJSXClosingElement(parser, context, inJSXChild, start, line, column) {\r\n      consume(parser, context, 25);\r\n      const name = parseJSXElementName(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      if (inJSXChild) {\r\n          consume(parser, context, 8456256);\r\n      }\r\n      else {\r\n          parser.token = scanJSXToken(parser);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXClosingElement',\r\n          name\r\n      });\r\n  }\r\n  function parseJSXClosingFragment(parser, context, inJSXChild, start, line, column) {\r\n      consume(parser, context, 25);\r\n      if (inJSXChild) {\r\n          consume(parser, context, 8456256);\r\n      }\r\n      else {\r\n          consume(parser, context, 8456256);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXClosingFragment'\r\n      });\r\n  }\r\n  function parseJSXChildren(parser, context) {\r\n      const children = [];\r\n      while (parser.token !== 25) {\r\n          parser.index = parser.tokenPos = parser.startPos;\r\n          parser.column = parser.colPos = parser.startColumn;\r\n          parser.line = parser.linePos = parser.startLine;\r\n          scanJSXToken(parser);\r\n          children.push(parseJSXChild(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return children;\r\n  }\r\n  function parseJSXChild(parser, context, start, line, column) {\r\n      if (parser.token === 135)\r\n          return parseJSXText(parser, context, start, line, column);\r\n      if (parser.token === 2162700)\r\n          return parseJSXExpressionContainer(parser, context, 0, 0, start, line, column);\r\n      if (parser.token === 8456255)\r\n          return parseJSXRootElementOrFragment(parser, context, 0, start, line, column);\r\n      report(parser, 0);\r\n  }\r\n  function parseJSXText(parser, context, start, line, column) {\r\n      scanJSXToken(parser);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXText',\r\n          value: parser.tokenValue\r\n      });\r\n  }\r\n  function parseJSXOpeningFragmentOrSelfCloseElement(parser, context, inJSXChild, start, line, column) {\r\n      if ((parser.token & 143360) !== 143360 && (parser.token & 4096) !== 4096)\r\n          report(parser, 0);\r\n      const tagName = parseJSXElementName(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      const attributes = parseJSXAttributes(parser, context);\r\n      const selfClosing = parser.token === 8457013;\r\n      if (parser.token === 8456256) {\r\n          scanJSXToken(parser);\r\n      }\r\n      else {\r\n          consume(parser, context, 8457013);\r\n          if (inJSXChild) {\r\n              consume(parser, context, 8456256);\r\n          }\r\n          else {\r\n              scanJSXToken(parser);\r\n          }\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXOpeningElement',\r\n          name: tagName,\r\n          attributes,\r\n          selfClosing\r\n      });\r\n  }\r\n  function parseJSXElementName(parser, context, start, line, column) {\r\n      scanJSXIdentifier(parser);\r\n      let key = parseJSXIdentifier(parser, context, start, line, column);\r\n      if (parser.token === 21)\r\n          return parseJSXNamespacedName(parser, context, key, start, line, column);\r\n      while (consumeOpt(parser, context, 67108877)) {\r\n          scanJSXIdentifier(parser);\r\n          key = parseJSXMemberExpression(parser, context, key, start, line, column);\r\n      }\r\n      return key;\r\n  }\r\n  function parseJSXMemberExpression(parser, context, object, start, line, column) {\r\n      const property = parseJSXIdentifier(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXMemberExpression',\r\n          object,\r\n          property\r\n      });\r\n  }\r\n  function parseJSXAttributes(parser, context) {\r\n      const attributes = [];\r\n      while (parser.token !== 8457013 && parser.token !== 8456256) {\r\n          attributes.push(parseJsxAttribute(parser, context, parser.tokenPos, parser.linePos, parser.colPos));\r\n      }\r\n      return attributes;\r\n  }\r\n  function parseJSXSpreadAttribute(parser, context, start, line, column) {\r\n      nextToken(parser, context);\r\n      consume(parser, context, 14);\r\n      const expression = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXSpreadAttribute',\r\n          argument: expression\r\n      });\r\n  }\r\n  function parseJsxAttribute(parser, context, start, line, column) {\r\n      if (parser.token === 2162700)\r\n          return parseJSXSpreadAttribute(parser, context, start, line, column);\r\n      scanJSXIdentifier(parser);\r\n      let value = null;\r\n      let name = parseJSXIdentifier(parser, context, start, line, column);\r\n      if (parser.token === 21) {\r\n          name = parseJSXNamespacedName(parser, context, name, start, line, column);\r\n      }\r\n      if (parser.token === 1077936157) {\r\n          const token = scanJSXAttributeValue(parser, context);\r\n          const { tokenPos, linePos, colPos } = parser;\r\n          switch (token) {\r\n              case 134283267:\r\n                  value = parseLiteral(parser, context);\r\n                  break;\r\n              case 8456255:\r\n                  value = parseJSXRootElementOrFragment(parser, context, 1, tokenPos, linePos, colPos);\r\n                  break;\r\n              case 2162700:\r\n                  value = parseJSXExpressionContainer(parser, context, 1, 1, tokenPos, linePos, colPos);\r\n                  break;\r\n              default:\r\n                  report(parser, 148);\r\n          }\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXAttribute',\r\n          value,\r\n          name\r\n      });\r\n  }\r\n  function parseJSXNamespacedName(parser, context, namespace, start, line, column) {\r\n      consume(parser, context, 21);\r\n      const name = parseJSXIdentifier(parser, context, parser.tokenPos, parser.linePos, parser.colPos);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXNamespacedName',\r\n          namespace,\r\n          name\r\n      });\r\n  }\r\n  function parseJSXExpressionContainer(parser, context, inJSXChild, isAttr, start, line, column) {\r\n      nextToken(parser, context);\r\n      const { tokenPos, linePos, colPos } = parser;\r\n      if (parser.token === 14)\r\n          return parseJSXSpreadChild(parser, context, tokenPos, linePos, colPos);\r\n      let expression = null;\r\n      if (parser.token === 1074790415) {\r\n          if (isAttr)\r\n              report(parser, 151);\r\n          expression = parseJSXEmptyExpression(parser, context, tokenPos, linePos, colPos);\r\n      }\r\n      else {\r\n          expression = parseExpression(parser, context, 1, 0, 0, tokenPos, linePos, colPos);\r\n      }\r\n      if (inJSXChild) {\r\n          consume(parser, context, 1074790415);\r\n      }\r\n      else {\r\n          scanJSXToken(parser);\r\n      }\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXExpressionContainer',\r\n          expression\r\n      });\r\n  }\r\n  function parseJSXSpreadChild(parser, context, start, line, column) {\r\n      consume(parser, context, 14);\r\n      const expression = parseExpression(parser, context, 1, 0, 0, parser.tokenPos, parser.linePos, parser.colPos);\r\n      consume(parser, context, 1074790415);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXSpreadChild',\r\n          expression\r\n      });\r\n  }\r\n  function parseJSXEmptyExpression(parser, context, start, line, column) {\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXEmptyExpression'\r\n      });\r\n  }\r\n  function parseJSXIdentifier(parser, context, start, line, column) {\r\n      const { tokenValue } = parser;\r\n      nextToken(parser, context);\r\n      return finishNode(parser, context, start, line, column, {\r\n          type: 'JSXIdentifier',\r\n          name: tokenValue\r\n      });\r\n  }\n\n\n\n  var estree = /*#__PURE__*/Object.freeze({\n    __proto__: null\n  });\n\n  function parseScript(source, options) {\r\n      return parseSource(source, options, 0);\r\n  }\r\n  function parseModule(source, options) {\r\n      return parseSource(source, options, 1024 | 2048);\r\n  }\r\n  function parse(source, options) {\r\n      return parseSource(source, options, 0);\r\n  }\r\n  const version = '1.9.15';\n\n  exports.ESTree = estree;\n  exports.parse = parse;\n  exports.parseModule = parseModule;\n  exports.parseScript = parseScript;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVyaXlhaC9kaXN0L21lcml5YWgudW1kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lcml5YWgvZGlzdC9tZXJpeWFoLnVtZC5qcz8yNWM5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5tZXJpeWFoID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBlcnJvck1lc3NhZ2VzID0ge1xyXG4gICAgICBbMF06ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuICAgICAgWzI4XTogXCJVbmV4cGVjdGVkIHRva2VuOiAnJTAnXCIsXHJcbiAgICAgIFsxXTogJ09jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuICAgICAgWzJdOiAnT2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5ncycsXHJcbiAgICAgIFszXTogJ1VuZXhwZWN0ZWQgdG9rZW4gYCNgJyxcclxuICAgICAgWzRdOiAnSWxsZWdhbCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZScsXHJcbiAgICAgIFs1XTogJ0ludmFsaWQgY29kZSBwb2ludCAlMCcsXHJcbiAgICAgIFs2XTogJ0ludmFsaWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlJyxcclxuICAgICAgWzhdOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuICAgICAgWzddOiAnRGVjaW1hbCBpbnRlZ2VyIGxpdGVyYWxzIHdpdGggYSBsZWFkaW5nIHplcm8gYXJlIGZvcmJpZGRlbiBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICAgIFs5XTogJ0V4cGVjdGVkIG51bWJlciBpbiByYWRpeCAlMCcsXHJcbiAgICAgIFsxNDVdOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBhc3NpZ25tZW50IHRvIGEgZGVzdHJ1Y3RpYmxlIHJpZ2h0LWhhbmQgc2lkZScsXHJcbiAgICAgIFsxMF06ICdOb24tbnVtYmVyIGZvdW5kIGFmdGVyIGV4cG9uZW50IGluZGljYXRvcicsXHJcbiAgICAgIFsxMV06ICdJbnZhbGlkIEJpZ0ludExpdGVyYWwnLFxyXG4gICAgICBbMTJdOiAnTm8gaWRlbnRpZmllcnMgYWxsb3dlZCBkaXJlY3RseSBhZnRlciBudW1lcmljIGxpdGVyYWwnLFxyXG4gICAgICBbMTNdOiAnRXNjYXBlcyBcXFxcOCBvciBcXFxcOSBhcmUgbm90IHN5bnRhY3RpY2FsbHkgdmFsaWQgZXNjYXBlcycsXHJcbiAgICAgIFsxNF06ICdVbnRlcm1pbmF0ZWQgc3RyaW5nIGxpdGVyYWwnLFxyXG4gICAgICBbMTVdOiAnVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWwnLFxyXG4gICAgICBbMTZdOiAnTXVsdGlsaW5lIGNvbW1lbnQgd2FzIG5vdCBjbG9zZWQgcHJvcGVybHknLFxyXG4gICAgICBbMTddOiAnVGhlIGlkZW50aWZpZXIgY29udGFpbmVkIGR5bmFtaWMgdW5pY29kZSBlc2NhcGUgdGhhdCB3YXMgbm90IGNsb3NlZCcsXHJcbiAgICAgIFsxOF06IFwiSWxsZWdhbCBjaGFyYWN0ZXIgJyUwJ1wiLFxyXG4gICAgICBbMTldOiAnTWlzc2luZyBoZXhhZGVjaW1hbCBkaWdpdHMnLFxyXG4gICAgICBbMjBdOiAnSW52YWxpZCBpbXBsaWNpdCBvY3RhbCcsXHJcbiAgICAgIFsyMV06ICdJbnZhbGlkIGxpbmUgYnJlYWsgaW4gc3RyaW5nIGxpdGVyYWwnLFxyXG4gICAgICBbMjJdOiAnT25seSB1bmljb2RlIGVzY2FwZXMgYXJlIGxlZ2FsIGluIGlkZW50aWZpZXIgbmFtZXMnLFxyXG4gICAgICBbMjNdOiBcIkV4cGVjdGVkICclMCdcIixcclxuICAgICAgWzI0XTogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXHJcbiAgICAgIFsyNV06ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzeW5jIGFycm93JyxcclxuICAgICAgWzI2XTogJ0NhbGxzIHRvIHN1cGVyIG11c3QgYmUgaW4gdGhlIFwiY29uc3RydWN0b3JcIiBtZXRob2Qgb2YgYSBjbGFzcyBleHByZXNzaW9uIG9yIGNsYXNzIGRlY2xhcmF0aW9uIHRoYXQgaGFzIGEgc3VwZXJjbGFzcycsXHJcbiAgICAgIFsyN106ICdNZW1iZXIgYWNjZXNzIG9uIHN1cGVyIG11c3QgYmUgaW4gYSBtZXRob2QnLFxyXG4gICAgICBbMjldOiAnQXdhaXQgZXhwcmVzc2lvbiBub3QgYWxsb3dlZCBpbiBmb3JtYWwgcGFyYW1ldGVyJyxcclxuICAgICAgWzMwXTogJ1lpZWxkIGV4cHJlc3Npb24gbm90IGFsbG93ZWQgaW4gZm9ybWFsIHBhcmFtZXRlcicsXHJcbiAgICAgIFs5Ml06IFwiVW5leHBlY3RlZCB0b2tlbjogJ2VzY2FwZWQga2V5d29yZCdcIixcclxuICAgICAgWzMxXTogJ1VuYXJ5IGV4cHJlc3Npb25zIGFzIHRoZSBsZWZ0IG9wZXJhbmQgb2YgYW4gZXhwb25lbnRhdGlvbiBleHByZXNzaW9uIG11c3QgYmUgZGlzYW1iaWd1YXRlZCB3aXRoIHBhcmVudGhlc2VzJyxcclxuICAgICAgWzExOV06ICdBc3luYyBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jaycsXHJcbiAgICAgIFszMl06ICdVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uJyxcclxuICAgICAgWzMzXTogJ1VuZXhwZWN0ZWQgcmVndWxhciBleHByZXNzaW9uIGZsYWcnLFxyXG4gICAgICBbMzRdOiBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZyAnJTAnXCIsXHJcbiAgICAgIFszNV06ICclMCBmdW5jdGlvbnMgbXVzdCBoYXZlIGV4YWN0bHkgJTEgYXJndW1lbnQlMicsXHJcbiAgICAgIFszNl06ICdTZXR0ZXIgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlcicsXHJcbiAgICAgIFszN106ICclMCBkZWNsYXJhdGlvbiBtdXN0IGhhdmUgYSBuYW1lIGluIHRoaXMgY29udGV4dCcsXHJcbiAgICAgIFszOF06ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgY29udGFpbiBhbnkgcmVzZXJ2ZWQgd29yZHMgb3IgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgICBbMzldOiAnVGhlIHJlc3Qgb3BlcmF0b3IgaXMgbWlzc2luZyBhbiBhcmd1bWVudCcsXHJcbiAgICAgIFs0MF06ICdBIGdldHRlciBjYW5ub3QgYmUgYSBnZW5lcmF0b3InLFxyXG4gICAgICBbNDFdOiAnQSBjb21wdXRlZCBwcm9wZXJ0eSBuYW1lIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBjb2xvbiBvciBwYXJlbicsXHJcbiAgICAgIFsxMzBdOiAnT2JqZWN0IGxpdGVyYWwga2V5cyB0aGF0IGFyZSBzdHJpbmdzIG9yIG51bWJlcnMgbXVzdCBiZSBhIG1ldGhvZCBvciBoYXZlIGEgY29sb24nLFxyXG4gICAgICBbNDNdOiAnRm91bmQgYCogYXN5bmMgeCgpe31gIGJ1dCB0aGlzIHNob3VsZCBiZSBgYXN5bmMgKiB4KCl7fWAnLFxyXG4gICAgICBbNDJdOiAnR2V0dGVycyBhbmQgc2V0dGVycyBjYW4gbm90IGJlIGdlbmVyYXRvcnMnLFxyXG4gICAgICBbNDRdOiBcIiclMCcgY2FuIG5vdCBiZSBnZW5lcmF0b3IgbWV0aG9kXCIsXHJcbiAgICAgIFs0NV06IFwiTm8gbGluZSBicmVhayBpcyBhbGxvd2VkIGFmdGVyICc9PidcIixcclxuICAgICAgWzQ2XTogJ1RoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgYXJyb3cgY2FuIG9ubHkgYmUgZGVzdHJ1Y3RlZCB0aHJvdWdoIGFzc2lnbm1lbnQnLFxyXG4gICAgICBbNDddOiAnVGhlIGJpbmRpbmcgZGVjbGFyYXRpb24gaXMgbm90IGRlc3RydWN0aWJsZScsXHJcbiAgICAgIFs0OF06ICdBc3luYyBhcnJvdyBjYW4gbm90IGJlIGZvbGxvd2VkIGJ5IG5ldyBleHByZXNzaW9uJyxcclxuICAgICAgWzQ5XTogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCAncHJvdG90eXBlJ1wiLFxyXG4gICAgICBbNTBdOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhICUwJyxcclxuICAgICAgWzUxXTogJ0R1cGxpY2F0ZSBjb25zdHJ1Y3RvciBtZXRob2QgaW4gY2xhc3MnLFxyXG4gICAgICBbNTJdOiAnSW52YWxpZCBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhbmQnLFxyXG4gICAgICBbNTNdOiAnSW52YWxpZCB1c2Ugb2YgYG5ld2Aga2V5d29yZCBvbiBhbiBpbmNyZW1lbnQvZGVjcmVtZW50IGV4cHJlc3Npb24nLFxyXG4gICAgICBbNTRdOiAnYD0+YCBpcyBhbiBpbnZhbGlkIGFzc2lnbm1lbnQgdGFyZ2V0JyxcclxuICAgICAgWzU1XTogJ1Jlc3QgZWxlbWVudCBtYXkgbm90IGhhdmUgYSB0cmFpbGluZyBjb21tYScsXHJcbiAgICAgIFs1Nl06ICdNaXNzaW5nIGluaXRpYWxpemVyIGluICUwIGRlY2xhcmF0aW9uJyxcclxuICAgICAgWzU3XTogXCInZm9yLSUwJyBsb29wIGhlYWQgZGVjbGFyYXRpb25zIGNhbiBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiLFxyXG4gICAgICBbNThdOiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItJTAgbG9vcDogTXVzdCBoYXZlIGEgc2luZ2xlIGJpbmRpbmcnLFxyXG4gICAgICBbNTldOiAnSW52YWxpZCBzaG9ydGhhbmQgcHJvcGVydHkgaW5pdGlhbGl6ZXInLFxyXG4gICAgICBbNjBdOiAnUHJvcGVydHkgbmFtZSBfX3Byb3RvX18gYXBwZWFycyBtb3JlIHRoYW4gb25jZSBpbiBvYmplY3QgbGl0ZXJhbCcsXHJcbiAgICAgIFs2MV06ICdMZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lJyxcclxuICAgICAgWzYyXTogXCJJbnZhbGlkIHVzZSBvZiAnJTAnIGluc2lkZSBuZXcgZXhwcmVzc2lvblwiLFxyXG4gICAgICBbNjNdOiBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIixcclxuICAgICAgWzY0XTogJ0lkZW50aWZpZXIgXCJsZXRcIiBkaXNhbGxvd2VkIGFzIGxlZnQtaGFuZCBzaWRlIGV4cHJlc3Npb24gaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgICBbNjVdOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxyXG4gICAgICBbNjZdOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxyXG4gICAgICBbNjddOiAnQ2Fubm90IGhhdmUgYGxldFsuLi5dYCBhcyBhIHZhciBuYW1lIGluIHN0cmljdCBtb2RlJyxcclxuICAgICAgWzY4XTogJ0ludmFsaWQgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IHRhcmdldCcsXHJcbiAgICAgIFs2OV06ICdSZXN0IHBhcmFtZXRlciBtYXkgbm90IGhhdmUgYSBkZWZhdWx0IGluaXRpYWxpemVyJyxcclxuICAgICAgWzcwXTogJ1RoZSByZXN0IGFyZ3VtZW50IG11c3QgdGhlIGJlIGxhc3QgcGFyYW1ldGVyJyxcclxuICAgICAgWzcxXTogJ0ludmFsaWQgcmVzdCBhcmd1bWVudCcsXHJcbiAgICAgIFs3M106ICdJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrJyxcclxuICAgICAgWzc0XTogJ0luIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50JyxcclxuICAgICAgWzc1XTogJ1dpdGhvdXQgd2ViIGNvbXBhYmlsaXR5IGVuYWJsZWQgZnVuY3Rpb25zIGNhbiBub3QgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50JyxcclxuICAgICAgWzc2XTogXCJDbGFzcyBkZWNsYXJhdGlvbiBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0XCIsXHJcbiAgICAgIFs3N106ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci0lMCcsXHJcbiAgICAgIFs3OF06ICdJbnZhbGlkIGFzc2lnbm1lbnQgaW4gZm9yLSUwJyxcclxuICAgICAgWzc5XTogJ2ZvciBhd2FpdCAoLi4uIG9mIC4uLikgaXMgb25seSB2YWxpZCBpbiBhc3luYyBmdW5jdGlvbnMgYW5kIGFzeW5jIGdlbmVyYXRvcnMnLFxyXG4gICAgICBbODBdOiAnVGhlIGZpcnN0IHRva2VuIGFmdGVyIHRoZSB0ZW1wbGF0ZSBleHByZXNzaW9uIHNob3VsZCBiZSBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgdGVtcGxhdGUnLFxyXG4gICAgICBbODJdOiAnYGxldGAgZGVjbGFyYXRpb24gbm90IGFsbG93ZWQgaGVyZSBhbmQgYGxldGAgY2Fubm90IGJlIGEgcmVndWxhciB2YXIgbmFtZSBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICAgIFs4MV06ICdgbGV0IFxcbiBbYCBpcyBhIHJlc3RyaWN0ZWQgcHJvZHVjdGlvbiBhdCB0aGUgc3RhcnQgb2YgYSBzdGF0ZW1lbnQnLFxyXG4gICAgICBbODNdOiAnQ2F0Y2ggY2xhdXNlIHJlcXVpcmVzIGV4YWN0bHkgb25lIHBhcmFtZXRlciwgbm90IG1vcmUgKGFuZCBubyB0cmFpbGluZyBjb21tYSknLFxyXG4gICAgICBbODRdOiAnQ2F0Y2ggY2xhdXNlIHBhcmFtZXRlciBkb2VzIG5vdCBzdXBwb3J0IGRlZmF1bHQgdmFsdWVzJyxcclxuICAgICAgWzg1XTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxyXG4gICAgICBbODZdOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcclxuICAgICAgWzg3XTogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXHJcbiAgICAgIFs4OF06ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcclxuICAgICAgWzg5XTogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXHJcbiAgICAgIFs5MF06ICdUaGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGZvci1oZWFkZXIgYmluZGluZyBkZWNsYXJhdGlvbiBpcyBub3QgZGVzdHJ1Y3RpYmxlJyxcclxuICAgICAgWzkxXTogJ25ldy50YXJnZXQgb25seSBhbGxvd2VkIHdpdGhpbiBmdW5jdGlvbnMnLFxyXG4gICAgICBbOTJdOiBcIidVbmV4cGVjdGVkIHRva2VuOiAnZXNjYXBlZCBrZXl3b3JkJ1wiLFxyXG4gICAgICBbOTNdOiBcIicjJyBub3QgZm9sbG93ZWQgYnkgaWRlbnRpZmllclwiLFxyXG4gICAgICBbOTldOiAnSW52YWxpZCBrZXl3b3JkJyxcclxuICAgICAgWzk4XTogXCJDYW4gbm90IHVzZSAnbGV0JyBhcyBhIGNsYXNzIG5hbWVcIixcclxuICAgICAgWzk3XTogXCInQSBsZXhpY2FsIGRlY2xhcmF0aW9uIGNhbid0IGRlZmluZSBhICdsZXQnIGJpbmRpbmdcIixcclxuICAgICAgWzk2XTogJ0NhbiBub3QgdXNlIGBsZXRgIGFzIHZhcmlhYmxlIG5hbWUgaW4gc3RyaWN0IG1vZGUnLFxyXG4gICAgICBbOTRdOiBcIiclMCcgbWF5IG5vdCBiZSB1c2VkIGFzIGFuIGlkZW50aWZpZXIgaW4gdGhpcyBjb250ZXh0XCIsXHJcbiAgICAgIFs5NV06ICdBd2FpdCBpcyBvbmx5IHZhbGlkIGluIGFzeW5jIGZ1bmN0aW9ucycsXHJcbiAgICAgIFsxMDBdOiAnVGhlICUwIGtleXdvcmQgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHRoZSBtb2R1bGUgZ29hbCcsXHJcbiAgICAgIFsxMDFdOiAnVW5pY29kZSBjb2RlcG9pbnQgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDB4MTBGRkZGJyxcclxuICAgICAgWzEwMl06ICclMCBzb3VyY2UgbXVzdCBiZSBzdHJpbmcnLFxyXG4gICAgICBbMTAzXTogJ09ubHkgYSBpZGVudGlmaWVyIGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIGFsaWFzJyxcclxuICAgICAgWzEwNF06IFwiT25seSAnKicgb3IgJ3suLi59JyBjYW4gYmUgaW1wb3J0ZWQgYWZ0ZXIgZGVmYXVsdFwiLFxyXG4gICAgICBbMTA1XTogJ1RyYWlsaW5nIGRlY29yYXRvciBtYXkgYmUgZm9sbG93ZWQgYnkgbWV0aG9kJyxcclxuICAgICAgWzEwNl06IFwiRGVjb3JhdG9ycyBjYW4ndCBiZSB1c2VkIHdpdGggYSBjb25zdHJ1Y3RvclwiLFxyXG4gICAgICBbMTA3XTogXCInJTAnIG1heSBub3QgYmUgdXNlZCBhcyBhbiBpZGVudGlmaWVyIGluIHRoaXMgY29udGV4dFwiLFxyXG4gICAgICBbMTA4XTogJ0hUTUwgY29tbWVudHMgYXJlIG9ubHkgYWxsb3dlZCB3aXRoIHdlYiBjb21wYWJpbGl0eSAoQW5uZXggQiknLFxyXG4gICAgICBbMTA5XTogXCJUaGUgaWRlbnRpZmllciAnbGV0JyBtdXN0IG5vdCBiZSBpbiBleHByZXNzaW9uIHBvc2l0aW9uIGluIHN0cmljdCBtb2RlXCIsXHJcbiAgICAgIFsxMTBdOiAnQ2Fubm90IGFzc2lnbiB0byBgZXZhbGAgYW5kIGBhcmd1bWVudHNgIGluIHN0cmljdCBtb2RlJyxcclxuICAgICAgWzExMV06IFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnXCIsXHJcbiAgICAgIFsxMTJdOiAnQmxvY2sgYm9keSBhcnJvd3MgY2FuIG5vdCBiZSBpbW1lZGlhdGVseSBpbnZva2VkIHdpdGhvdXQgYSBncm91cCcsXHJcbiAgICAgIFsxMTNdOiAnQmxvY2sgYm9keSBhcnJvd3MgY2FuIG5vdCBiZSBpbW1lZGlhdGVseSBhY2Nlc3NlZCB3aXRob3V0IGEgZ3JvdXAnLFxyXG4gICAgICBbMTE0XTogJ1VuZXhwZWN0ZWQgc3RyaWN0IG1vZGUgcmVzZXJ2ZWQgd29yZCcsXHJcbiAgICAgIFsxMTVdOiAnVW5leHBlY3RlZCBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICAgIFsxMTZdOiAnRGVjb3JhdG9ycyBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBhIHNlbWljb2xvbicsXHJcbiAgICAgIFsxMTddOiAnQ2FsbGluZyBkZWxldGUgb24gZXhwcmVzc2lvbiBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcbiAgICAgIFsxMThdOiAnUGF0dGVybiBjYW4gbm90IGhhdmUgYSB0YWlsJyxcclxuICAgICAgWzEyMF06ICdDYW4gbm90IGhhdmUgYSBgeWllbGRgIGV4cHJlc3Npb24gb24gdGhlIGxlZnQgc2lkZSBvZiBhIHRlcm5hcnknLFxyXG4gICAgICBbMTIxXTogJ0FuIGFycm93IGZ1bmN0aW9uIGNhbiBub3QgaGF2ZSBhIHBvc3RmaXggdXBkYXRlIG9wZXJhdG9yJyxcclxuICAgICAgWzEyMl06ICdJbnZhbGlkIG9iamVjdCBsaXRlcmFsIGtleSBjaGFyYWN0ZXIgYWZ0ZXIgZ2VuZXJhdG9yIHN0YXInLFxyXG4gICAgICBbMTIzXTogJ1ByaXZhdGUgZmllbGRzIGNhbiBub3QgYmUgZGVsZXRlZCcsXHJcbiAgICAgIFsxMjVdOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBmaWVsZCBjYWxsZWQgY29uc3RydWN0b3InLFxyXG4gICAgICBbMTI0XTogJ0NsYXNzZXMgbWF5IG5vdCBoYXZlIGEgcHJpdmF0ZSBlbGVtZW50IG5hbWVkIGNvbnN0cnVjdG9yJyxcclxuICAgICAgWzEyNl06ICdBIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyIG1heSBub3QgY29udGFpbiBhcmd1bWVudHMnLFxyXG4gICAgICBbMTI3XTogJ0dlbmVyYXRvcnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jaycsXHJcbiAgICAgIFsxMjhdOiAnQXN5bmMgbWV0aG9kcyBhcmUgYSByZXN0cmljdGVkIHByb2R1Y3Rpb24gYW5kIGNhbm5vdCBoYXZlIGEgbmV3bGluZSBmb2xsb3dpbmcgaXQnLFxyXG4gICAgICBbMTI5XTogJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIGFmdGVyIG9iamVjdCBsaXRlcmFsIHByb3BlcnR5IG5hbWUnLFxyXG4gICAgICBbMTMxXTogJ0ludmFsaWQga2V5IHRva2VuJyxcclxuICAgICAgWzEzMl06IFwiTGFiZWwgJyUwJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIsXHJcbiAgICAgIFsxMzNdOiAnY29udGludWUgc3RhdGVtZW50IG11c3QgYmUgbmVzdGVkIHdpdGhpbiBhbiBpdGVyYXRpb24gc3RhdGVtZW50JyxcclxuICAgICAgWzEzNF06IFwiVW5kZWZpbmVkIGxhYmVsICclMCdcIixcclxuICAgICAgWzEzNV06ICdUcmFpbGluZyBjb21tYSBpcyBkaXNhbGxvd2VkIGluc2lkZSBpbXBvcnQoLi4uKSBhcmd1bWVudHMnLFxyXG4gICAgICBbMTM2XTogJ2ltcG9ydCgpIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50JyxcclxuICAgICAgWzEzN106ICdDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCguLi4pJyxcclxuICAgICAgWzEzOF06ICcuLi4gaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KCknLFxyXG4gICAgICBbMTM5XTogXCJFeHBlY3RlZCAnPT4nXCIsXHJcbiAgICAgIFsxNDBdOiBcIkR1cGxpY2F0ZSBiaW5kaW5nICclMCdcIixcclxuICAgICAgWzE0MV06IFwiQ2Fubm90IGV4cG9ydCBhIGR1cGxpY2F0ZSBuYW1lICclMCdcIixcclxuICAgICAgWzE0NF06ICdEdXBsaWNhdGUgJTAgZm9yLWJpbmRpbmcnLFxyXG4gICAgICBbMTQyXTogXCJFeHBvcnRlZCBiaW5kaW5nICclMCcgbmVlZHMgdG8gcmVmZXIgdG8gYSB0b3AtbGV2ZWwgZGVjbGFyZWQgdmFyaWFibGVcIixcclxuICAgICAgWzE0M106ICdVbmV4cGVjdGVkIHByaXZhdGUgZmllbGQnLFxyXG4gICAgICBbMTQ3XTogJ051bWVyaWMgc2VwYXJhdG9ycyBhcmUgbm90IGFsbG93ZWQgYXQgdGhlIGVuZCBvZiBudW1lcmljIGxpdGVyYWxzJyxcclxuICAgICAgWzE0Nl06ICdPbmx5IG9uZSB1bmRlcnNjb3JlIGlzIGFsbG93ZWQgYXMgbnVtZXJpYyBzZXBhcmF0b3InLFxyXG4gICAgICBbMTQ4XTogJ0pTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHQnLFxyXG4gICAgICBbMTQ5XTogJ0V4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciAlMCcsXHJcbiAgICAgIFsxNTBdOiAnQWRqYWNlbnQgSlNYIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnJyxcclxuICAgICAgWzE1MV06IFwiSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5ICdleHByZXNzaW9uJ1wiLFxyXG4gICAgICBbMTUyXTogXCInJTAnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIixcclxuICAgICAgWzE1M106IFwiJyUwJyBzaGFkb3dlZCBhIGNhdGNoIGNsYXVzZSBiaW5kaW5nXCIsXHJcbiAgICAgIFsxNTRdOiAnRG90IHByb3BlcnR5IG11c3QgYmUgYW4gaWRlbnRpZmllcicsXHJcbiAgICAgIFsxNTVdOiAnRW5jb3VudGVyZWQgaW52YWxpZCBpbnB1dCBhZnRlciBzcHJlYWQvcmVzdCBhcmd1bWVudCcsXHJcbiAgICAgIFsxNTZdOiAnQ2F0Y2ggd2l0aG91dCB0cnknLFxyXG4gICAgICBbMTU3XTogJ0ZpbmFsbHkgd2l0aG91dCB0cnknLFxyXG4gICAgICBbMTU4XTogJ0V4cGVjdGVkIGNvcnJlc3BvbmRpbmcgY2xvc2luZyB0YWcgZm9yIEpTWCBmcmFnbWVudCcsXHJcbiAgICAgIFsxNTldOiAnQ29hbGVzY2luZyBhbmQgbG9naWNhbCBvcGVyYXRvcnMgdXNlZCB0b2dldGhlciBpbiB0aGUgc2FtZSBleHByZXNzaW9uIG11c3QgYmUgZGlzYW1iaWd1YXRlZCB3aXRoIHBhcmVudGhlc2VzJyxcclxuICAgICAgWzE2MF06ICdJbnZhbGlkIHRhZ2dlZCB0ZW1wbGF0ZSBvbiBvcHRpb25hbCBjaGFpbicsXHJcbiAgICAgIFsxNjFdOiAnSW52YWxpZCBvcHRpb25hbCBjaGFpbiBmcm9tIHN1cGVyIHByb3BlcnR5JyxcclxuICAgICAgWzE2Ml06ICdJbnZhbGlkIG9wdGlvbmFsIGNoYWluIGZyb20gbmV3IGV4cHJlc3Npb24nLFxyXG4gICAgICBbMTYzXTogJ0Nhbm5vdCB1c2UgXCJpbXBvcnQubWV0YVwiIG91dHNpZGUgYSBtb2R1bGUnXHJcbiAgfTtcclxuICBjbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgU3ludGF4RXJyb3Ige1xyXG4gICAgICBjb25zdHJ1Y3RvcihzdGFydGluZGV4LCBsaW5lLCBjb2x1bW4sIHR5cGUsIC4uLnBhcmFtcykge1xyXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdbJyArIGxpbmUgKyAnOicgKyBjb2x1bW4gKyAnXTogJyArIGVycm9yTWVzc2FnZXNbdHlwZV0ucmVwbGFjZSgvJShcXGQrKS9nLCAoXywgaSkgPT4gcGFyYW1zW2ldKTtcclxuICAgICAgICAgIHN1cGVyKGAke21lc3NhZ2V9YCk7XHJcbiAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnRpbmRleDtcclxuICAgICAgICAgIHRoaXMubGluZSA9IGxpbmU7XHJcbiAgICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcclxuICAgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBtZXNzYWdlO1xyXG4gICAgICAgICAgdGhpcy5sb2MgPSB7XHJcbiAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICBjb2x1bW5cclxuICAgICAgICAgIH07XHJcbiAgICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwb3J0KHBhcnNlciwgdHlwZSwgLi4ucGFyYW1zKSB7XHJcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKHBhcnNlci5pbmRleCwgcGFyc2VyLmxpbmUsIHBhcnNlci5jb2x1bW4sIHR5cGUsIC4uLnBhcmFtcyk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlcG9ydFNjb3BlRXJyb3Ioc2NvcGUpIHtcclxuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3Ioc2NvcGUuaW5kZXgsIHNjb3BlLmxpbmUsIHNjb3BlLmNvbHVtbiwgc2NvcGUudHlwZSwgc2NvcGUucGFyYW1zKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwb3J0TWVzc2FnZUF0KGluZGV4LCBsaW5lLCBjb2x1bW4sIHR5cGUsIC4uLnBhcmFtcykge1xyXG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCB0eXBlLCAuLi5wYXJhbXMpO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZXBvcnRTY2FubmVyRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgdHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCB0eXBlKTtcclxuICB9XG5cbiAgY29uc3QgdW5pY29kZUxvb2t1cCA9ICgoY29tcHJlc3NlZCwgbG9va3VwKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheSgxMDQ0NDgpO1xyXG4gICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICBsZXQgc3ViSW5kZXggPSAwO1xyXG4gICAgICB3aGlsZSAoaW5kZXggPCAzNTQwKSB7XHJcbiAgICAgICAgICBjb25zdCBpbnN0ID0gY29tcHJlc3NlZFtpbmRleCsrXTtcclxuICAgICAgICAgIGlmIChpbnN0IDwgMCkge1xyXG4gICAgICAgICAgICAgIHN1YkluZGV4IC09IGluc3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvbXByZXNzZWRbaW5kZXgrK107XHJcbiAgICAgICAgICAgICAgaWYgKGluc3QgJiAyKVxyXG4gICAgICAgICAgICAgICAgICBjb2RlID0gbG9va3VwW2NvZGVdO1xyXG4gICAgICAgICAgICAgIGlmIChpbnN0ICYgMSkge1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHQuZmlsbChjb2RlLCBzdWJJbmRleCwgc3ViSW5kZXggKz0gY29tcHJlc3NlZFtpbmRleCsrXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHRbc3ViSW5kZXgrK10gPSBjb2RlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0pKFstMSwgMiwgMjQsIDIsIDI1LCAyLCA1LCAtMSwgMCwgNzc1OTU2NDgsIDMsIDQ0LCAyLCAzLCAwLCAxNCwgMiwgNTcsIDIsIDU4LCAzLCAwLCAzLCAwLCAzMTY4Nzk2NjcxLCAwLCA0Mjk0OTU2OTkyLCAyLCAxLCAyLCAwLCAyLCA1OSwgMywgMCwgNCwgMCwgNDI5NDk2NjUyMywgMywgMCwgNCwgMiwgMTYsIDIsIDYwLCAyLCAwLCAwLCA0Mjk0ODM2NzM1LCAwLCAzMjIxMjI1NDcxLCAwLCA0Mjk0OTAxOTQyLCAyLCA2MSwgMCwgMTM0MTUyMTkyLCAzLCAwLCAyLCAwLCA0Mjk0OTUxOTM1LCAzLCAwLCAyLCAwLCAyNjgzMzA1OTgzLCAwLCAyNjg0MzU0MDQ3LCAyLCAxNywgMiwgMCwgMCwgNDI5NDk2MTE1MSwgMywgMCwgMiwgMiwgMTksIDIsIDAsIDAsIDYwODE3NDA3OSwgMiwgMCwgMiwgMTMxLCAyLCA2LCAyLCA1NiwgLTEsIDIsIDM3LCAwLCA0Mjk0NDQzMjYzLCAyLCAxLCAzLCAwLCAzLCAwLCA0Mjk0OTAxNzExLCAyLCAzOSwgMCwgNDA4OTgzOTEwMywgMCwgMjk2MTIwOTc1OSwgMCwgMTM0MjQzOTM3NSwgMCwgNDI5NDU0MzM0MiwgMCwgMzU0NzIwMTAyMywgMCwgMTU3NzIwNDEwMywgMCwgNDE5NDI0MCwgMCwgNDI5NDY4ODc1MCwgMiwgMiwgMCwgODA4MzEsIDAsIDQyNjE0NzgzNTEsIDAsIDQyOTQ1NDk0ODYsIDIsIDIsIDAsIDI5Njc0ODQ4MzEsIDAsIDE5NjU1OSwgMCwgMzU5NDM3MzEwMCwgMCwgMzI4ODMxOTc2OCwgMCwgODQ2OTk1OSwgMiwgMTk0LCAyLCAzLCAwLCAzODI1MjA0NzM1LCAwLCAxMjM3NDc4MDcsIDAsIDY1NDg3LCAwLCA0Mjk0ODI4MDE1LCAwLCA0MDkyNTkxNjE1LCAwLCAxMDgwMDQ5MTE5LCAwLCA0NTg3MDMsIDIsIDMsIDIsIDAsIDAsIDIxNjMyNDQ1MTEsIDAsIDQyMjc5MjM5MTksIDAsIDQyMzYyNDcwMjIsIDIsIDY2LCAwLCA0Mjg0NDQ5OTE5LCAwLCA4NTE5MDQsIDIsIDQsIDIsIDExLCAwLCA2NzA3NjA5NSwgLTEsIDIsIDY3LCAwLCAxMDczNzQxNzQzLCAwLCA0MDkzNTkxMzkxLCAtMSwgMCwgNTAzMzE2NDksIDAsIDMyNjUyNjY2ODcsIDIsIDMyLCAwLCA0Mjk0ODQ0NDE1LCAwLCA0Mjc4MTkwMDQ3LCAyLCAxOCwgMiwgMTI5LCAtMSwgMywgMCwgMiwgMiwgMjEsIDIsIDAsIDIsIDksIDIsIDAsIDIsIDE0LCAyLCAxNSwgMywgMCwgMTAsIDIsIDY5LCAyLCAwLCAyLCA3MCwgMiwgNzEsIDIsIDcyLCAyLCAwLCAyLCA3MywgMiwgMCwgMiwgMTAsIDAsIDI2MTYzMiwgMiwgMjMsIDMsIDAsIDIsIDIsIDEyLCAyLCA0LCAzLCAwLCAxOCwgMiwgNzQsIDIsIDUsIDMsIDAsIDIsIDIsIDc1LCAwLCAyMDg4OTU5LCAyLCAyNywgMiwgOCwgMCwgOTA5MzExLCAzLCAwLCAyLCAwLCA4MTQ3NDM1NTEsIDIsIDQxLCAwLCA2NzA1NzY2NCwgMywgMCwgMiwgMiwgNDAsIDIsIDAsIDIsIDI4LCAyLCAwLCAyLCAyOSwgMiwgNywgMCwgMjY4Mzc0MDE1LCAyLCAyNiwgMiwgNDksIDIsIDAsIDIsIDc2LCAwLCAxMzQxNTMyMTUsIC0xLCAyLCA2LCAyLCAwLCAyLCA3LCAwLCAyNjg0MzU0NTU5LCAwLCA2NzA0NDM1MSwgMCwgMzIyMTE2MDA2NCwgMCwgMSwgLTEsIDMsIDAsIDIsIDIsIDQyLCAwLCAxMDQ2NTI4LCAzLCAwLCAzLCAyLCA4LCAyLCAwLCAyLCA1MSwgMCwgNDI5NDk2MDEyNywgMiwgOSwgMiwgMzgsIDIsIDEwLCAwLCA0Mjk0Mzc3NDcyLCAyLCAxMSwgMywgMCwgNywgMCwgNDIyNzg1ODQzMSwgMywgMCwgOCwgMiwgMTIsIDIsIDAsIDIsIDc4LCAyLCA5LCAyLCAwLCAyLCA3OSwgMiwgODAsIDIsIDgxLCAtMSwgMiwgMTI0LCAwLCAxMDQ4NTc3LCAyLCA4MiwgMiwgMTMsIC0xLCAyLCAxMywgMCwgMTMxMDQyLCAyLCA4MywgMiwgODQsIDIsIDg1LCAyLCAwLCAyLCAzMywgLTgzLCAyLCAwLCAyLCA1MywgMiwgNywgMywgMCwgNCwgMCwgMTA0NjU1OSwgMiwgMCwgMiwgMTQsIDIsIDAsIDAsIDIxNDc1MTY2NzEsIDIsIDIwLCAzLCA4NiwgMiwgMiwgMCwgLTE2LCAyLCA4NywgMCwgNTI0MjIyNDYyLCAyLCA0LCAyLCAwLCAwLCA0MjY5ODAxNDcxLCAyLCA0LCAyLCAwLCAyLCAxNSwgMiwgNzcsIDIsIDE2LCAzLCAwLCAyLCAyLCA0NywgMiwgMCwgLTEsIDIsIDE3LCAtMTYsIDMsIDAsIDIwNiwgLTIsIDMsIDAsIDY1NSwgMiwgMTgsIDMsIDAsIDM2LCAyLCA2OCwgLTEsIDIsIDE3LCAyLCA5LCAzLCAwLCA4LCAyLCA4OSwgMiwgMTIxLCAyLCAwLCAwLCAzMjIwMjQyNDMxLCAzLCAwLCAzLCAyLCAxOSwgMiwgOTAsIDIsIDkxLCAzLCAwLCAyLCAyLCA5MiwgMiwgMCwgMiwgOTMsIDIsIDk0LCAyLCAwLCAwLCA0MzUxLCAyLCAwLCAyLCA4LCAzLCAwLCAyLCAwLCA2NzA0MzM5MSwgMCwgMzkwOTA5MTMyNywgMiwgMCwgMiwgMjIsIDIsIDgsIDIsIDE4LCAzLCAwLCAyLCAwLCA2NzA3NjA5NywgMiwgNywgMiwgMCwgMiwgMjAsIDAsIDY3MDU5NzExLCAwLCA0MjM2MjQ3MDM5LCAzLCAwLCAyLCAwLCA5Mzk1MjQxMDMsIDAsIDgxOTE5OTksIDIsIDk3LCAyLCA5OCwgMiwgMTUsIDIsIDIxLCAzLCAwLCAzLCAwLCA2NzA1NzY2MywgMywgMCwgMzQ5LCAyLCA5OSwgMiwgMTAwLCAyLCA2LCAtMjY0LCAzLCAwLCAxMSwgMiwgMjIsIDMsIDAsIDIsIDIsIDMxLCAtMSwgMCwgMzc3NDM0OTQzOSwgMiwgMTAxLCAyLCAxMDIsIDMsIDAsIDIsIDIsIDE5LCAyLCAxMDMsIDMsIDAsIDEwLCAyLCA5LCAyLCAxNywgMiwgMCwgMiwgNDUsIDIsIDAsIDIsIDMwLCAyLCAxMDQsIDIsIDIzLCAwLCAxNjM4Mzk5LCAyLCAxNzIsIDIsIDEwNSwgMywgMCwgMywgMiwgMTgsIDIsIDI0LCAyLCAyNSwgMiwgNSwgMiwgMjYsIDIsIDAsIDIsIDcsIDIsIDEwNiwgLTEsIDIsIDEwNywgMiwgMTA4LCAyLCAxMDksIC0xLCAzLCAwLCAzLCAyLCAxMSwgLTIsIDIsIDAsIDIsIDI3LCAtMywgMiwgMTUwLCAtNCwgMiwgMTgsIDIsIDAsIDIsIDM1LCAwLCAxLCAyLCAwLCAyLCA2MiwgMiwgMjgsIDIsIDExLCAyLCA5LCAyLCAwLCAyLCAxMTAsIC0xLCAzLCAwLCA0LCAyLCA5LCAyLCAyMSwgMiwgMTExLCAyLCA2LCAyLCAwLCAyLCAxMTIsIDIsIDAsIDIsIDQ4LCAtNCwgMywgMCwgOSwgMiwgMjAsIDIsIDI5LCAyLCAzMCwgLTQsIDIsIDExMywgMiwgMTE0LCAyLCAyOSwgMiwgMjAsIDIsIDcsIC0yLCAyLCAxMTUsIDIsIDI5LCAyLCAzMSwgLTIsIDIsIDAsIDIsIDExNiwgLTIsIDAsIDQyNzcxMzc1MTksIDAsIDIyNjkxMTg0NjMsIC0xLCAzLCAxOCwgMiwgLTEsIDIsIDMyLCAyLCAzNiwgMiwgMCwgMywgMjksIDIsIDIsIDM0LCAyLCAxOSwgLTMsIDMsIDAsIDIsIDIsIDMzLCAtMSwgMiwgMCwgMiwgMzQsIDIsIDAsIDIsIDM0LCAyLCAwLCAyLCA0NiwgLTEwLCAyLCAwLCAwLCAyMDM3NzUsIC0yLCAyLCAxOCwgMiwgNDMsIDIsIDM1LCAtMiwgMiwgMTcsIDIsIDExNywgMiwgMjAsIDMsIDAsIDIsIDIsIDM2LCAwLCAyMTQ3NTQ5MTIwLCAyLCAwLCAyLCAxMSwgMiwgMTcsIDIsIDEzNSwgMiwgMCwgMiwgMzcsIDIsIDUyLCAwLCA1MjQyODc5LCAzLCAwLCAyLCAwLCA0MDI2NDQ1MTEsIC0xLCAyLCAxMjAsIDAsIDEwOTA1MTkwMzksIC0yLCAyLCAxMjIsIDIsIDM4LCAyLCAwLCAwLCA2NzA0NTM3NSwgMiwgMzksIDAsIDQyMjY2NzgyNzEsIDAsIDM3NjY1NjUyNzksIDAsIDIwMzk3NTksIC00LCAzLCAwLCAyLCAwLCAzMjg4MjcwODQ3LCAwLCAzLCAzLCAwLCAyLCAwLCA2NzA0MzUxOSwgLTUsIDIsIDAsIDAsIDQyODIzODQzODMsIDAsIDEwNTY5NjQ2MDksIC0xLCAzLCAwLCAyLCAwLCA2NzA0MzM0NSwgLTEsIDIsIDAsIDIsIDQwLCAyLCA0MSwgLTEsIDIsIDEwLCAyLCA0MiwgLTYsIDIsIDAsIDIsIDExLCAtMywgMywgMCwgMiwgMCwgMjE0NzQ4NDY3MSwgMiwgMTI1LCAwLCA0MTkwMTA5Njk1LCAyLCA1MCwgLTIsIDIsIDEyNiwgMCwgNDI0NDYzNTY0NywgMCwgMjcsIDIsIDAsIDIsIDcsIDIsIDQzLCAyLCAwLCAyLCA2MywgLTEsIDIsIDAsIDIsIDQwLCAtOCwgMiwgNTQsIDIsIDQ0LCAwLCA2NzA0MzMyOSwgMiwgMTI3LCAyLCA0NSwgMCwgODM4ODM1MSwgLTIsIDIsIDEyOCwgMCwgMzAyODI4NzQ4NywgMiwgNDYsIDIsIDEzMCwgMCwgMzMyNTk1MTksIDIsIDQxLCAtOSwgMiwgMjAsIC01LCAyLCA2NCwgLTIsIDMsIDAsIDI4LCAyLCAzMSwgLTMsIDMsIDAsIDMsIDIsIDQ3LCAzLCAwLCA2LCAyLCA0OCwgLTg1LCAzLCAwLCAzMywgMiwgNDcsIC0xMjYsIDMsIDAsIDE4LCAyLCAzNiwgLTI2OSwgMywgMCwgMTcsIDIsIDQwLCAyLCA3LCAyLCA0MSwgLTIsIDIsIDE3LCAyLCA0OSwgMiwgMCwgMiwgMjAsIDIsIDUwLCAyLCAxMzIsIDIsIDIzLCAtMjEsIDMsIDAsIDIsIC00LCAzLCAwLCAyLCAwLCA0Mjk0OTM2NTc1LCAyLCAwLCAwLCA0Mjk0OTM0NzgzLCAtMiwgMCwgMTk2NjM1LCAzLCAwLCAxOTEsIDIsIDUxLCAzLCAwLCAzOCwgMiwgMjksIC0xLCAyLCAzMywgLTI3OSwgMywgMCwgOCwgMiwgNywgLTEsIDIsIDEzMywgMiwgNTIsIDMsIDAsIDExLCAyLCA2LCAtNzIsIDMsIDAsIDMsIDIsIDEzNCwgMCwgMTY3NzY1NjU3NSwgLTE2NiwgMCwgNDE2MTI2NjY1NiwgMCwgNDA3MSwgMCwgMTUzNjAsIC00LCAwLCAyOCwgLTEzLCAzLCAwLCAyLCAyLCAzNywgMiwgMCwgMiwgMTM2LCAyLCAxMzcsIDIsIDU1LCAyLCAwLCAyLCAxMzgsIDIsIDEzOSwgMiwgMTQwLCAzLCAwLCAxMCwgMiwgMTQxLCAyLCAxNDIsIDIsIDE1LCAzLCAzNywgMiwgMywgNTMsIDIsIDMsIDU0LCAyLCAwLCA0Mjk0OTU0OTk5LCAyLCAwLCAtMTYsIDIsIDAsIDIsIDg4LCAyLCAwLCAwLCAyMTA1MzQzLCAwLCA0MTYwNzQ5NTg0LCAwLCA2NTUzNCwgLTQyLCAwLCA0MTk0MzAzODcxLCAwLCAyMDExLCAtNiwgMiwgMCwgMCwgMTA3MzY4NDQ3OSwgMCwgMTc0MDcsIC0xMSwgMiwgMCwgMiwgMzEsIC00MCwgMywgMCwgNiwgMCwgODMyMzEwMywgLTEsIDMsIDAsIDIsIDIsIDQyLCAtMzcsIDIsIDU1LCAyLCAxNDQsIDIsIDE0NSwgMiwgMTQ2LCAyLCAxNDcsIDIsIDE0OCwgLTEwNSwgMiwgMjQsIC0zMiwgMywgMCwgMTMzNCwgMiwgOSwgLTEsIDMsIDAsIDEyOSwgMiwgMjcsIDMsIDAsIDYsIDIsIDksIDMsIDAsIDE4MCwgMiwgMTQ5LCAzLCAwLCAyMzMsIDAsIDEsIC05NiwgMywgMCwgMTYsIDIsIDksIC00NywgMywgMCwgMTU0LCAyLCA1NiwgLTIyMzgxLCAzLCAwLCA3LCAyLCAyMywgLTYxMzAsIDMsIDUsIDIsIC0xLCAwLCA2OTIwNzA0MCwgMywgNDQsIDIsIDMsIDAsIDE0LCAyLCA1NywgMiwgNTgsIC0zLCAwLCAzMTY4NzMxMTM2LCAwLCA0Mjk0OTU2ODY0LCAyLCAxLCAyLCAwLCAyLCA1OSwgMywgMCwgNCwgMCwgNDI5NDk2NjI3NSwgMywgMCwgNCwgMiwgMTYsIDIsIDYwLCAyLCAwLCAyLCAzMywgLTEsIDIsIDE3LCAyLCA2MSwgLTEsIDIsIDAsIDIsIDU2LCAwLCA0Mjk0ODg1Mzc2LCAzLCAwLCAyLCAwLCAzMTQ1NzI3LCAwLCAyNjE3Mjk0OTQ0LCAwLCA0Mjk0NzcwNjg4LCAyLCAyMywgMiwgNjIsIDMsIDAsIDIsIDAsIDEzMTEzNSwgMiwgOTUsIDAsIDcwMjU2NjM5LCAwLCA3MTMwMzE2NywgMCwgMjcyLCAyLCA0MCwgMiwgNTYsIC0xLCAyLCAzNywgMiwgMzAsIC0xLCAyLCA5NiwgMiwgNjMsIDAsIDQyNzgyNTU2MTYsIDAsIDQyOTQ4MzYyMjcsIDAsIDQyOTQ1NDk0NzMsIDAsIDYwMDE3ODE3NSwgMCwgMjk1MjgwNjQwMCwgMCwgMjY4NjMyMDY3LCAwLCA0Mjk0NTQzMzI4LCAwLCA1NzU0MDA5NSwgMCwgMTU3NzA1ODMwNCwgMCwgMTgzNTAwOCwgMCwgNDI5NDY4ODczNiwgMiwgNjUsIDIsIDY0LCAwLCAzMzU1NDQzNSwgMiwgMTIzLCAyLCA2NSwgMiwgMTUxLCAwLCAxMzEwNzUsIDAsIDM1OTQzNzMwOTYsIDAsIDY3MDk0Mjk2LCAyLCA2NCwgLTEsIDAsIDQyOTQ4MjgwMDAsIDAsIDYwMzk3OTI2MywgMiwgMTYwLCAwLCAzLCAwLCA0Mjk0ODI4MDAxLCAwLCA2MDI5MzA2ODcsIDIsIDE4MywgMCwgMzkzMjE5LCAwLCA0Mjk0ODI4MDE2LCAwLCA2NzEwODg2MzksIDAsIDIxNTQ4NDAwNjQsIDAsIDQyMjc4NTg0MzUsIDAsIDQyMzYyNDcwMDgsIDIsIDY2LCAyLCAzNiwgLTEsIDIsIDQsIDAsIDkxNzUwMywgMiwgMzYsIC0xLCAyLCA2NywgMCwgNTM3Nzg4MzM1LCAwLCA0MDI2NTMxOTM1LCAtMSwgMCwgMSwgLTEsIDIsIDMyLCAyLCA2OCwgMCwgNzkzNiwgLTMsIDIsIDAsIDAsIDIxNDc0ODU2OTUsIDAsIDEwMTA3NjE3MjgsIDAsIDQyOTI5ODQ5MzAsIDAsIDE2Mzg3LCAyLCAwLCAyLCAxNCwgMiwgMTUsIDMsIDAsIDEwLCAyLCA2OSwgMiwgMCwgMiwgNzAsIDIsIDcxLCAyLCA3MiwgMiwgMCwgMiwgNzMsIDIsIDAsIDIsIDExLCAtMSwgMiwgMjMsIDMsIDAsIDIsIDIsIDEyLCAyLCA0LCAzLCAwLCAxOCwgMiwgNzQsIDIsIDUsIDMsIDAsIDIsIDIsIDc1LCAwLCAyNTM5NTEsIDMsIDE5LCAyLCAwLCAxMjI4NzksIDIsIDAsIDIsIDgsIDAsIDI3NjgyNDA2NCwgLTIsIDMsIDAsIDIsIDIsIDQwLCAyLCAwLCAwLCA0Mjk0OTAzMjk1LCAyLCAwLCAyLCAyOSwgMiwgNywgLTEsIDIsIDE3LCAyLCA0OSwgMiwgMCwgMiwgNzYsIDIsIDQxLCAtMSwgMiwgMjAsIDIsIDAsIDIsIDI3LCAtMiwgMCwgMTI4LCAtMiwgMiwgNzcsIDIsIDgsIDAsIDQwNjQsIC0xLCAyLCAxMTksIDAsIDQyMjc5MDc1ODUsIDIsIDAsIDIsIDExOCwgMiwgMCwgMiwgNDgsIDIsIDE3MywgMiwgOSwgMiwgMzgsIDIsIDEwLCAtMSwgMCwgNzQ0NDAxOTIsIDMsIDAsIDYsIC0yLCAzLCAwLCA4LCAyLCAxMiwgMiwgMCwgMiwgNzgsIDIsIDksIDIsIDAsIDIsIDc5LCAyLCA4MCwgMiwgODEsIC0zLCAyLCA4MiwgMiwgMTMsIC0zLCAyLCA4MywgMiwgODQsIDIsIDg1LCAyLCAwLCAyLCAzMywgLTgzLCAyLCAwLCAyLCA1MywgMiwgNywgMywgMCwgNCwgMCwgODE3MTgzLCAyLCAwLCAyLCAxNCwgMiwgMCwgMCwgMzMwMjMsIDIsIDIwLCAzLCA4NiwgMiwgLTE3LCAyLCA4NywgMCwgNTI0MTU3OTUwLCAyLCA0LCAyLCAwLCAyLCA4OCwgMiwgNCwgMiwgMCwgMiwgMTUsIDIsIDc3LCAyLCAxNiwgMywgMCwgMiwgMiwgNDcsIDIsIDAsIC0xLCAyLCAxNywgLTE2LCAzLCAwLCAyMDYsIC0yLCAzLCAwLCA2NTUsIDIsIDE4LCAzLCAwLCAzNiwgMiwgNjgsIC0xLCAyLCAxNywgMiwgOSwgMywgMCwgOCwgMiwgODksIDAsIDMwNzIsIDIsIDAsIDAsIDIxNDc1MTY0MTUsIDIsIDksIDMsIDAsIDIsIDIsIDIzLCAyLCA5MCwgMiwgOTEsIDMsIDAsIDIsIDIsIDkyLCAyLCAwLCAyLCA5MywgMiwgOTQsIDAsIDQyOTQ5NjUxNzksIDAsIDcsIDIsIDAsIDIsIDgsIDIsIDkxLCAyLCA4LCAtMSwgMCwgMTc2MTM0NTUzNiwgMiwgOTUsIDAsIDQyOTQ5MDE4MjMsIDIsIDM2LCAyLCAxOCwgMiwgOTYsIDIsIDM0LCAyLCAxNjYsIDAsIDIwODA0NDAyODcsIDIsIDAsIDIsIDMzLCAyLCAxNDMsIDAsIDMyOTY3MjI5NDMsIDIsIDAsIDAsIDEwNDY2NzU0NTUsIDAsIDkzOTUyNDEwMSwgMCwgMTgzNzA1NSwgMiwgOTcsIDIsIDk4LCAyLCAxNSwgMiwgMjEsIDMsIDAsIDMsIDAsIDcsIDMsIDAsIDM0OSwgMiwgOTksIDIsIDEwMCwgMiwgNiwgLTI2NCwgMywgMCwgMTEsIDIsIDIyLCAzLCAwLCAyLCAyLCAzMSwgLTEsIDAsIDI3MDA2MDc2MTUsIDIsIDEwMSwgMiwgMTAyLCAzLCAwLCAyLCAyLCAxOSwgMiwgMTAzLCAzLCAwLCAxMCwgMiwgOSwgMiwgMTcsIDIsIDAsIDIsIDQ1LCAyLCAwLCAyLCAzMCwgMiwgMTA0LCAtMywgMiwgMTA1LCAzLCAwLCAzLCAyLCAxOCwgLTEsIDMsIDUsIDIsIDIsIDI2LCAyLCAwLCAyLCA3LCAyLCAxMDYsIC0xLCAyLCAxMDcsIDIsIDEwOCwgMiwgMTA5LCAtMSwgMywgMCwgMywgMiwgMTEsIC0yLCAyLCAwLCAyLCAyNywgLTgsIDIsIDE4LCAyLCAwLCAyLCAzNSwgLTEsIDIsIDAsIDIsIDYyLCAyLCAyOCwgMiwgMjksIDIsIDksIDIsIDAsIDIsIDExMCwgLTEsIDMsIDAsIDQsIDIsIDksIDIsIDE3LCAyLCAxMTEsIDIsIDYsIDIsIDAsIDIsIDExMiwgMiwgMCwgMiwgNDgsIC00LCAzLCAwLCA5LCAyLCAyMCwgMiwgMjksIDIsIDMwLCAtNCwgMiwgMTEzLCAyLCAxMTQsIDIsIDI5LCAyLCAyMCwgMiwgNywgLTIsIDIsIDExNSwgMiwgMjksIDIsIDMxLCAtMiwgMiwgMCwgMiwgMTE2LCAtMiwgMCwgNDI3NzA3NTk2OSwgMiwgMjksIC0xLCAzLCAxOCwgMiwgLTEsIDIsIDMyLCAyLCAxMTcsIDIsIDAsIDMsIDI5LCAyLCAyLCAzNCwgMiwgMTksIC0zLCAzLCAwLCAyLCAyLCAzMywgLTEsIDIsIDAsIDIsIDM0LCAyLCAwLCAyLCAzNCwgMiwgMCwgMiwgNDgsIC0xMCwgMiwgMCwgMCwgMTk3NjMxLCAtMiwgMiwgMTgsIDIsIDQzLCAyLCAxMTgsIC0yLCAyLCAxNywgMiwgMTE3LCAyLCAyMCwgMiwgMTE5LCAyLCA1MSwgLTIsIDIsIDExOSwgMiwgMjMsIDIsIDE3LCAyLCAzMywgMiwgMTE5LCAyLCAzNiwgMCwgNDI5NDkwMTkwNCwgMCwgNDcxODU5MSwgMiwgMTE5LCAyLCAzNCwgMCwgMzM1NTQ0MzUwLCAtMSwgMiwgMTIwLCAyLCAxMjEsIC0yLCAyLCAxMjIsIDIsIDM4LCAyLCA3LCAtMSwgMiwgMTIzLCAyLCA2NSwgMCwgMzc1ODE2MTkyMCwgMCwgMywgLTQsIDIsIDAsIDIsIDI3LCAwLCAyMTQ3NDg1NTY4LCAwLCAzLCAyLCAwLCAyLCAyMywgMCwgMTc2LCAtNSwgMiwgMCwgMiwgNDcsIDIsIDE4NiwgLTEsIDIsIDAsIDIsIDIzLCAyLCAxOTcsIC0xLCAyLCAwLCAwLCAxNjc3OTI2MywgLTIsIDIsIDExLCAtNywgMiwgMCwgMiwgMTIxLCAtMywgMywgMCwgMiwgMiwgMTI0LCAyLCAxMjUsIDAsIDIxNDc1NDkxODMsIDAsIDIsIC0yLCAyLCAxMjYsIDIsIDM1LCAwLCAxMCwgMCwgNDI5NDk2NTI0OSwgMCwgNjc2MzMxNTEsIDAsIDQwMjY1OTczNzYsIDIsIDAsIDAsIDUzNjg3MTkzNSwgLTEsIDIsIDAsIDIsIDQwLCAtOCwgMiwgNTQsIDIsIDQ3LCAwLCAxLCAyLCAxMjcsIDIsIDIzLCAtMywgMiwgMTI4LCAyLCAzNSwgMiwgMTI5LCAyLCAxMzAsIDAsIDE2Nzc4MjM5LCAtMTAsIDIsIDM0LCAtNSwgMiwgNjQsIC0yLCAzLCAwLCAyOCwgMiwgMzEsIC0zLCAzLCAwLCAzLCAyLCA0NywgMywgMCwgNiwgMiwgNDgsIC04NSwgMywgMCwgMzMsIDIsIDQ3LCAtMTI2LCAzLCAwLCAxOCwgMiwgMzYsIC0yNjksIDMsIDAsIDE3LCAyLCA0MCwgMiwgNywgLTMsIDIsIDE3LCAyLCAxMzEsIDIsIDAsIDIsIDIzLCAyLCA0OCwgMiwgMTMyLCAyLCAyMywgLTIxLCAzLCAwLCAyLCAtNCwgMywgMCwgMiwgMCwgNjc1ODMsIC0xLCAyLCAxMDMsIC0yLCAwLCAxMSwgMywgMCwgMTkxLCAyLCA1MSwgMywgMCwgMzgsIDIsIDI5LCAtMSwgMiwgMzMsIC0yNzksIDMsIDAsIDgsIDIsIDcsIC0xLCAyLCAxMzMsIDIsIDUyLCAzLCAwLCAxMSwgMiwgNiwgLTcyLCAzLCAwLCAzLCAyLCAxMzQsIDIsIDEzNSwgLTE4NywgMywgMCwgMiwgMiwgMzcsIDIsIDAsIDIsIDEzNiwgMiwgMTM3LCAyLCA1NSwgMiwgMCwgMiwgMTM4LCAyLCAxMzksIDIsIDE0MCwgMywgMCwgMTAsIDIsIDE0MSwgMiwgMTQyLCAyLCAxNSwgMywgMzcsIDIsIDMsIDUzLCAyLCAzLCA1NCwgMiwgMiwgMTQzLCAtNzMsIDIsIDAsIDAsIDEwNjUzNjE0MDcsIDAsIDE2Mzg0LCAtMTEsIDIsIDAsIDIsIDEyMSwgLTQwLCAzLCAwLCA2LCAyLCAxMTcsIC0xLCAzLCAwLCAyLCAwLCAyMDYzLCAtMzcsIDIsIDU1LCAyLCAxNDQsIDIsIDE0NSwgMiwgMTQ2LCAyLCAxNDcsIDIsIDE0OCwgLTEzOCwgMywgMCwgMTMzNCwgMiwgOSwgLTEsIDMsIDAsIDEyOSwgMiwgMjcsIDMsIDAsIDYsIDIsIDksIDMsIDAsIDE4MCwgMiwgMTQ5LCAzLCAwLCAyMzMsIDAsIDEsIC05NiwgMywgMCwgMTYsIDIsIDksIC00NywgMywgMCwgMTU0LCAyLCA1NiwgLTI4NTE3LCAyLCAwLCAwLCAxLCAtMSwgMiwgMTI0LCAyLCAwLCAwLCA4MTkzLCAtMjEsIDIsIDE5MywgMCwgMTAyNTUsIDAsIDQsIC0xMSwgMiwgNjQsIDIsIDE3MSwgLTEsIDAsIDcxNjgwLCAtMSwgMiwgMTYxLCAwLCA0MjkyOTAwODY0LCAwLCA4MDUzMDY0MzEsIC01LCAyLCAxNTAsIC0xLCAyLCAxNTcsIC0xLCAwLCA2MTQ0LCAtMiwgMiwgMTI3LCAtMSwgMiwgMTU0LCAtMSwgMCwgMjE0NzUzMjgwMCwgMiwgMTUxLCAyLCAxNjUsIDIsIDAsIDIsIDE2NCwgMCwgNTI0MDMyLCAwLCA0LCAtNCwgMiwgMTkwLCAwLCAyMDUxMjgxOTIsIDAsIDEzMzM3NTc1MzYsIDAsIDIxNDc0ODM2OTYsIDAsIDQyMzk1MywgMCwgNzQ3NzY2MjcyLCAwLCAyNzE3NzYzMTkyLCAwLCA0Mjg2NTc4NzUxLCAwLCAyNzg1NDUsIDIsIDE1MiwgMCwgNDI5NDg4NjQ2NCwgMCwgMzMyOTIzMzYsIDAsIDQxNzgwOSwgMiwgMTUyLCAwLCAxMzI3NDgyNDY0LCAwLCA0Mjc4MTkwMTI4LCAwLCA3MDA1OTQxOTUsIDAsIDEwMDY2NDc1MjcsIDAsIDQyODY0OTczMzYsIDAsIDQxNjA3NDk2MzEsIDIsIDE1MywgMCwgNDY5NzYyNTYwLCAwLCA0MTcxMjE5NDg4LCAwLCA4MzIzMTIwLCAyLCAxNTMsIDAsIDIwMjM3NTY4MCwgMCwgMzIxNDkxODE3NiwgMCwgNDI5NDUwODU5MiwgMiwgMTUzLCAtMSwgMCwgOTgzNTg0LCAwLCA0OCwgMCwgNTg3MjAyNzMsIDAsIDM0ODk5MjMwNzIsIDAsIDEwNTE3Mzc2LCAwLCA0MjkzMDY2ODE1LCAwLCAxLCAwLCAyMDEzMjY1OTIwLCAyLCAxNzcsIDIsIDAsIDAsIDIwODksIDAsIDMyMjEyMjU1NTIsIDAsIDIwMTM3NTkwNCwgMiwgMCwgLTIsIDAsIDI1NiwgMCwgMTIyODgwLCAwLCAxNjc3NzIxNiwgMiwgMTUwLCAwLCA0MTYwNzU3NzYwLCAyLCAwLCAtNiwgMiwgMTY3LCAtMTEsIDAsIDMyNjMyMTgxNzYsIC0xLCAwLCA0OTY2NCwgMCwgMjE2MDE5NzYzMiwgMCwgODM4ODgwMiwgLTEsIDAsIDEyNzEzOTg0LCAtMSwgMiwgMTU0LCAyLCAxNTksIDIsIDE3OCwgLTIsIDIsIDE2MiwgLTIwLCAwLCAzNzU4MDk2Mzg1LCAtMiwgMiwgMTU1LCAwLCA0MjkyODc4MzM2LCAyLCA5MCwgMiwgMTY5LCAwLCA0Mjk0MDU3OTg0LCAtMiwgMiwgMTYzLCAyLCAxNTYsIDIsIDE3NSwgLTIsIDIsIDE1NSwgLTEsIDIsIDE4MiwgLTEsIDIsIDE3MCwgMiwgMTI0LCAwLCA0MDI2NTkzMjgwLCAwLCAxNCwgMCwgNDI5MjkxOTI5NiwgLTEsIDIsIDE1OCwgMCwgOTM5NTg4NjA4LCAtMSwgMCwgODA1MzA2MzY4LCAtMSwgMiwgMTI0LCAwLCAxNjEwNjEyNzM2LCAyLCAxNTYsIDIsIDE1NywgMiwgNCwgMiwgMCwgLTIsIDIsIDE1OCwgMiwgMTU5LCAtMywgMCwgMjY3Mzg2ODgwLCAtMSwgMiwgMTYwLCAwLCA3MTY4LCAtMSwgMCwgNjUwMjQsIDIsIDE1NCwgMiwgMTYxLCAyLCAxNzksIC03LCAyLCAxNjgsIC04LCAyLCAxNjIsIC0xLCAwLCAxNDI2MTEyNzA0LCAyLCAxNjMsIC0xLCAyLCAxNjQsIDAsIDI3MTU4MTIxNiwgMCwgMjE0OTc3NzQwOCwgMiwgMjMsIDIsIDE2MSwgMiwgMTI0LCAwLCA4NTE5NjcsIDIsIDE4MCwgLTEsIDIsIDIzLCAyLCAxODEsIC00LCAyLCAxNTgsIC0yMCwgMiwgMTk1LCAyLCAxNjUsIC01NiwgMCwgMzE0NTcyOCwgMiwgMTg1LCAtNCwgMiwgMTY2LCAyLCAxMjQsIC00LCAwLCAzMjUwNTg1NiwgLTEsIDIsIDE2NywgLTEsIDAsIDIxNDczODUwODgsIDIsIDkwLCAxLCAyMTU1OTA1MTUyLCAyLCAtMywgMiwgMTAzLCAyLCAwLCAyLCAxNjgsIC0yLCAyLCAxNjksIC02LCAyLCAxNzAsIDAsIDQwMjY1OTczNzUsIDAsIDEsIC0xLCAwLCAxLCAtMSwgMiwgMTcxLCAtMywgMiwgMTE3LCAyLCA2NCwgLTIsIDIsIDE2NiwgLTIsIDIsIDE3NiwgMiwgMTI0LCAtODc4LCAyLCAxNTksIC0zNiwgMiwgMTcyLCAtMSwgMiwgMjAxLCAtMTAsIDIsIDE4OCwgLTUsIDIsIDE3NCwgLTYsIDAsIDQyOTQ5NjUyNTEsIDIsIDI3LCAtMSwgMiwgMTczLCAtMSwgMiwgMTc0LCAtMiwgMCwgNDIyNzg3NDc1MiwgLTMsIDAsIDIxNDY0MzUwNzIsIDIsIDE1OSwgLTIsIDAsIDEwMDY2NDkzNDQsIDIsIDEyNCwgLTEsIDIsIDkwLCAwLCAyMDEzNzU3NDQsIC0zLCAwLCAxMzQyMTc3MjAsIDIsIDkwLCAwLCA0Mjg2Njc3Mzc3LCAwLCAzMjg5NiwgLTEsIDIsIDE1OCwgLTMsIDIsIDE3NSwgLTM0OSwgMiwgMTc2LCAwLCAxOTIwLCAyLCAxNzcsIDMsIDAsIDI2NCwgLTExLCAyLCAxNTcsIC0yLCAyLCAxNzgsIDIsIDAsIDAsIDUyMDYxNzg1NiwgMCwgMjY5Mjc0MzE2OCwgMCwgMzYsIC0zLCAwLCA1MjQyODQsIC0xMSwgMiwgMjMsIC0xLCAyLCAxODcsIC0xLCAyLCAxODQsIDAsIDMyMjEyOTEwMDcsIDIsIDE3OCwgLTEsIDIsIDIwMiwgMCwgMjE1ODcyMCwgLTMsIDIsIDE1OSwgMCwgMSwgLTQsIDIsIDEyNCwgMCwgMzgwODYyNTQxMSwgMCwgMzQ4OTYyODI4OCwgMiwgMjAwLCAwLCAxMjA3OTU5NjgwLCAwLCAzMjIxMjc0NjI0LCAyLCAwLCAtMywgMiwgMTc5LCAwLCAxMjAsIDAsIDczNDAwMzIsIC0yLCAyLCAxODAsIDIsIDQsIDIsIDIzLCAyLCAxNjMsIDMsIDAsIDQsIDIsIDE1OSwgLTEsIDIsIDE4MSwgMiwgMTc3LCAtMSwgMCwgODE3NiwgMiwgMTgyLCAyLCAxNzksIDIsIDE4MywgLTEsIDAsIDQyOTA3NzMyMzIsIDIsIDAsIC00LCAyLCAxNjMsIDIsIDE4OSwgMCwgMTU3Mjg2NDAsIDIsIDE3NywgLTEsIDIsIDE2MSwgLTEsIDAsIDQyOTQ5MzQ1MTIsIDMsIDAsIDQsIC05LCAyLCA5MCwgMiwgMTcwLCAyLCAxODQsIDMsIDAsIDQsIDAsIDcwNCwgMCwgMTg0OTY4ODA2NCwgMiwgMTg1LCAtMSwgMiwgMTI0LCAwLCA0Mjk0OTAxODg3LCAyLCAwLCAwLCAxMzA1NDc3MTIsIDAsIDE4NzkwNDgxOTIsIDIsIDE5OSwgMywgMCwgMiwgLTEsIDIsIDE4NiwgMiwgMTg3LCAtMSwgMCwgMTc4Mjk3NzYsIDAsIDIwMjU4NDg4MzIsIDAsIDQyNjE0Nzc4ODgsIC0yLCAyLCAwLCAtMSwgMCwgNDI4NjU4MDYwOCwgLTEsIDAsIDI5MzYwMTI4LCAyLCAxOTIsIDAsIDE2MjUyOTI4LCAwLCAzNzkxMzg4NjcyLCAyLCAzOCwgMywgMCwgMiwgLTIsIDIsIDE5NiwgMiwgMCwgLTEsIDIsIDEwMywgLTEsIDAsIDY2NTg0NTc2LCAtMSwgMiwgMTkxLCAzLCAwLCA5LCAyLCAxMjQsIC0xLCAwLCA0Mjk0NzU1MzI4LCAzLCAwLCAyLCAtMSwgMiwgMTYxLCAyLCAxNzgsIDMsIDAsIDIsIDIsIDIzLCAyLCAxODgsIDIsIDkwLCAtMiwgMCwgMjQ1NzYwLCAwLCAyMTQ3NDE4MTEyLCAtMSwgMiwgMTUwLCAyLCAyMDMsIDAsIDQyMjc5MjM0NTYsIC0xLCAyLCAxNjQsIDIsIDE2MSwgMiwgOTAsIC0zLCAwLCA0MjkyODcwMTQ1LCAwLCAyNjIxNDQsIDIsIDEyNCwgMywgMCwgMiwgMCwgMTA3Mzc1ODg0OCwgMiwgMTg5LCAtMSwgMCwgNDIyNzkyMTkyMCwgMiwgMTkwLCAwLCA2ODI4OTAyNCwgMCwgNTI4NDAyMDE2LCAwLCA0MjkyOTI3NTM2LCAzLCAwLCA0LCAtMiwgMCwgMjY4NDM1NDU2LCAyLCA5MSwgLTIsIDIsIDE5MSwgMywgMCwgNSwgLTEsIDIsIDE5MiwgMiwgMTYzLCAyLCAwLCAtMiwgMCwgNDIyNzkyMzkzNiwgMiwgNjIsIC0xLCAyLCAxNTUsIDIsIDk1LCAyLCAwLCAyLCAxNTQsIDIsIDE1OCwgMywgMCwgNiwgLTEsIDIsIDE3NywgMywgMCwgMywgLTIsIDAsIDIxNDY5NTkzNjAsIDAsIDk0NDA2NDAsIDAsIDEwNDg1NzYwMCwgMCwgNDIyNzkyMzg0MCwgMywgMCwgMiwgMCwgNzY4LCAyLCAxOTMsIDIsIDc3LCAtMiwgMiwgMTYxLCAtMiwgMiwgMTE5LCAtMSwgMiwgMTU1LCAzLCAwLCA4LCAwLCA1MTIsIDAsIDgzODg2MDgsIDIsIDE5NCwgMiwgMTcyLCAyLCAxODcsIDAsIDQyODY1Nzg5NDQsIDMsIDAsIDIsIDAsIDExNTIsIDAsIDEyNjY2Nzk4MDgsIDIsIDE5MSwgMCwgNTc2LCAwLCA0MjYxNzA3Nzc2LCAyLCA5NSwgMywgMCwgOSwgMiwgMTU1LCAzLCAwLCA1LCAyLCAxNiwgLTEsIDAsIDIxNDcyMjE1MDQsIC0yOCwgMiwgMTc4LCAzLCAwLCAzLCAtMywgMCwgNDI5MjkwMjkxMiwgLTYsIDIsIDk2LCAzLCAwLCA4NSwgLTMzLCAwLCA0Mjk0OTM0NTI4LCAzLCAwLCAxMjYsIC0xOCwgMiwgMTk1LCAzLCAwLCAyNjksIC0xNywgMiwgMTU1LCAyLCAxMjQsIDIsIDE5OCwgMywgMCwgMiwgMiwgMjMsIDAsIDQyOTA4MjIxNDQsIC0yLCAwLCA2NzE3NDMzNiwgMCwgNTIwMDkzNzAwLCAyLCAxNywgMywgMCwgMjEsIC0yLCAyLCAxNzksIDMsIDAsIDMsIC0yLCAwLCAzMDcyMCwgLTEsIDAsIDMyNTEyLCAzLCAwLCAyLCAwLCA0Mjk0NzcwNjU2LCAtMTkxLCAyLCAxNzQsIC0zOCwgMiwgMTcwLCAyLCAwLCAyLCAxOTYsIDMsIDAsIDI3OSwgLTgsIDIsIDEyNCwgMiwgMCwgMCwgNDI5NDUwODU0MywgMCwgNjUyOTUsIC0xMSwgMiwgMTc3LCAzLCAwLCA3MiwgLTMsIDAsIDM3NTgxNTk4NzIsIDAsIDIwMTM5MTYxNiwgMywgMCwgMTU1LCAtNywgMiwgMTcwLCAtMSwgMCwgMzg0LCAtMSwgMCwgMTMzNjkzNDQwLCAtMywgMiwgMTk2LCAtMiwgMiwgMjYsIDMsIDAsIDQsIDIsIDE2OSwgLTIsIDIsIDkwLCAyLCAxNTUsIDMsIDAsIDQsIC0yLCAyLCAxNjQsIC0xLCAyLCAxNTAsIDAsIDMzNTU1MjkyMywgMiwgMTk3LCAtMSwgMCwgNTM4OTc0MjcyLCAwLCAyMjE0NTkyNTEyLCAwLCAxMzIwMDAsIC0xMCwgMCwgMTkyLCAtOCwgMCwgMTIyODgsIC0yMSwgMCwgMTM0MjEzNjMyLCAwLCA0Mjk0OTAxNzYxLCAzLCAwLCA0MiwgMCwgMTAwNjYzNDI0LCAwLCA0Mjk0OTY1Mjg0LCAzLCAwLCA2LCAtMSwgMCwgMzIyMTI4MjgxNiwgMiwgMTk4LCAzLCAwLCAxMSwgLTEsIDIsIDE5OSwgMywgMCwgNDAsIC02LCAwLCA0Mjg2NTc4Nzg0LCAyLCAwLCAtMiwgMCwgMTAwNjY5NDQwMCwgMywgMCwgMjQsIDIsIDM1LCAtMSwgMiwgOTQsIDMsIDAsIDIsIDAsIDEsIDIsIDE2MywgMywgMCwgNiwgMiwgMTk3LCAwLCA0MTEwOTQyNTY5LCAwLCAxNDMyOTUwMTM5LCAwLCAyNzAxNjU4MjE3LCAwLCA0MDI2NTMyODY0LCAwLCA0MDI2NTMyODgxLCAyLCAwLCAyLCA0NSwgMywgMCwgOCwgLTEsIDIsIDE1OCwgLTIsIDIsIDE2OSwgMCwgOTgzMDQsIDAsIDY1NTM3LCAyLCAxNzAsIC01LCAwLCA0Mjk0OTUwOTEyLCAyLCAwLCAyLCAxMTgsIDAsIDY1NTI4LCAyLCAxNzcsIDAsIDQyOTQ3NzAxNzYsIDIsIDI2LCAzLCAwLCA0LCAtMzAsIDIsIDE3NCwgMCwgMzc1ODE1MzcyOCwgLTMsIDIsIDE2OSwgLTIsIDIsIDE1NSwgMiwgMTg4LCAyLCAxNTgsIC0xLCAyLCAxOTEsIC0xLCAyLCAxNjEsIDAsIDQyOTQ3NTQzMDQsIDMsIDAsIDIsIC0zLCAwLCAzMzU1NDQzMiwgLTIsIDIsIDIwMCwgLTMsIDIsIDE2OSwgMCwgNDE3NTQ3ODc4NCwgMiwgMjAxLCAwLCA0Mjg2NjQzNzEyLCAwLCA0Mjg2NjQ0MjE2LCAyLCAwLCAtNCwgMiwgMjAyLCAtMSwgMiwgMTY1LCAwLCA0MjI3OTIzOTY3LCAzLCAwLCAzMiwgLTEzMzQsIDIsIDE2MywgMiwgMCwgLTEyOSwgMiwgOTQsIC02LCAyLCAxNjMsIC0xODAsIDIsIDIwMywgLTIzMywgMiwgNCwgMywgMCwgOTYsIC0xNiwgMiwgMTYzLCAzLCAwLCA0NywgLTE1NCwgMiwgMTY1LCAzLCAwLCAyMjM4MSwgLTcsIDIsIDE3LCAzLCAwLCA2MTI4XSwgWzQyOTQ5NjcyOTUsIDQyOTQ5NjcyOTEsIDQwOTI0NjA1NDMsIDQyOTQ4MjgwMzEsIDQyOTQ5NjcyOTQsIDEzNDIxNzcyNiwgMjY4NDM1NDU1LCAyMTQ3NDgzNjQ3LCAxMDQ4NTc1LCAxMDczNzQxODIzLCAzODkyMzE0MTExLCAxMzQyMTc3MjcsIDEwNjExNTg5MTEsIDUzNjgwNTM3NiwgNDI5NDkxMDE0MywgNDE2MDc0OTU2NywgNDI5NDkwMTc1OSwgNDI5NDkwMTc2MCwgNTM2ODcwOTExLCAyNjIxNDMsIDgzODg2MDcsIDQyOTQ5MDI3ODMsIDQyOTQ5MTgxNDMsIDY1NTM1LCA2NzA0MzMyOCwgMjI4MTcwMTM3NCwgNDI5NDk2NzIzMiwgMjA5NzE1MSwgNDI5NDkwMzgwNywgNDE5NDMwMywgMjU1LCA2NzEwODg2MywgNDI5NDk2NzAzOSwgNTExLCA1MjQyODcsIDEzMTA3MSwgMTI3LCA0MjkyODcwMTQzLCA0Mjk0OTAyMjcxLCA0Mjk0NTQ5NDg3LCAzMzU1NDQzMSwgMTAyMywgNjcwNDc0MjMsIDQyOTQ5MDE4ODgsIDQyODY1Nzg2ODcsIDQyOTQ3NzA2ODcsIDY3MDQzNTgzLCAzMjc2NywgMTUsIDIwNDc5OTksIDY3MDQzMzQzLCAxNjc3NzIxNSwgNDI5NDkwMjAwMCwgNDI5NDkzNDUyNywgNDI5NDk2Njc4MywgNDI5NDk2NzI3OSwgMjA0NywgMjYyMDgzLCAyMDUxMSwgNDI5MDc3Mjk5MSwgNDE5NDMwMzksIDQ5MzU2NywgNDI5NDk1OTEwNCwgNjAzOTc5Nzc1LCA2NTUzNiwgNjAyNzk5NjE1LCA4MDUwNDQyMjMsIDQyOTQ5NjUyMDYsIDgxOTEsIDEwMzE3NDkxMTksIDQyOTQ5MTc2MzEsIDIxMzQ3Njk2NjMsIDQyODY1Nzg0OTMsIDQyODIyNTMzMTEsIDQyOTQ5NDI3MTksIDMzNTQwMDk1LCA0Mjk0OTA1ODU1LCA0Mjk0OTY3MjY0LCAyODY4ODU0NTkxLCAxNjA4NTE1NTgzLCAyNjUyMzIzNDgsIDUzNDUxOTgwNywgMjE0NzYxNDcyMCwgMTA2MDEwOTQ0NCwgNDA5MzY0MDAxNiwgMTczNzYsIDIxMzkwNjIxNDMsIDIyNCwgNDE2OTEzODE3NSwgNDI5NDkwOTk1MSwgNDI4NjU3ODY4OCwgNDI5NDk2NzI5MiwgNDI5NDk2NTc1OSwgMjA0NCwgNDI5Mjg3MDE0NCwgNDI5NDk2NjI3MiwgNDI5NDk2NzI4MCwgODI4OTkxOCwgNDI5NDkzNDM5OSwgNDI5NDkwMTc3NSwgNDI5NDk2NTM3NSwgMTYwMjIyMzYxNSwgNDI5NDk2NzI1OSwgNDI5NDQ0MzAwOCwgMjY4MzY5OTIwLCA0MjkyODA0NjA4LCA0ODYzNDE4ODQsIDQyOTQ5NjMxOTksIDMwODcwMDc2MTUsIDEwNzM2OTI2NzEsIDQxMjg1MjcsIDQyNzkyMzg2NTUsIDQyOTQ5MDIwMTUsIDQyOTQ5NjY1OTEsIDI0NDUyNzkyMzEsIDM2NzAwMTUsIDMyMzgwMDI2ODcsIDMxLCA2MywgNDI5NDk2NzI4OCwgNDI5NDcwNTE1MSwgNDA5NSwgMzIyMTIwODQ0NywgNDI5NDU0OTQ3MiwgMjE0NzQ4MzY0OCwgNDI4NTUyNjY1NSwgNDI5NDk2NjUyNywgNDI5NDcwNTE1MiwgNDI5NDk2NjE0MywgNjQsIDQyOTQ5NjY3MTksIDE2MzgzLCAzNzc0ODczNTkyLCA0NTg3NTIsIDUzNjgwNzQyMywgNjcwNDM4MzksIDM3NTgwOTYzODMsIDM5NTk0MTQzNzIsIDM3NTU5OTMwMjMsIDIwODAzNzQ3ODMsIDQyOTQ4MzUyOTUsIDQyOTQ5NjcxMDMsIDQxNjA3NDk1NjUsIDQwODcsIDE4NDAyNDcyNiwgMjg2MjAxNzE1NiwgMTU5MzMwOTA3OCwgMjY4NDM0NDMxLCAyNjg0MzQ0MTQsIDQyOTQ5MDE3NjMsIDUzNjg3MDkxMiwgMjk1Mjc5MDAxNiwgMjAyNTA2NzUyLCAxMzkyNjQsIDQwMjY1MzE4NCwgNDI2MTQxMjg2NCwgNDIyNzkyMjk0NCwgNDkxNTIsIDYxNDQwLCAzNzU4MDk2Mzg0LCAxMTc0NDA1MTIsIDY1MjgwLCAzMjMzODA4Mzg0LCAzMjIxMjI1NDcyLCAyMDk3MTUyLCA0Mjk0OTY1MjQ4LCAzMjc2OCwgNTcxNTIsIDY3MTA4ODY0LCA0MjkzOTE4NzIwLCA0MjkwNzcyOTkyLCAyNTE2NTgyNCwgNTczNDQsIDQyMjc5MTU3NzYsIDQyNzgxOTAwODAsIDQyMjc5MDc1ODQsIDY1NTIwLCA0MDI2NTMxODQwLCA0MjI3ODU4NDMyLCA0MTYwNzQ5NTY4LCAzNzU4MTI5MTUyLCA0Mjk0ODM2MjI0LCA2MzQ4OCwgMTA3Mzc0MTgyNCwgNDI5NDk2NzA0MCwgNDE5NDMwNCwgMjUxNjU4MjQwLCAxOTY2MDgsIDQyOTQ5NjMyMDAsIDY0NTEyLCA0MTc4MDgsIDQyMjc5MjM3MTIsIDEyNTgyOTEyLCA1MDMzMTY0OCwgNjU0NzIsIDQyOTQ5NjcxNjgsIDQyOTQ5NjY3ODQsIDE2LCA0Mjk0OTE3MTIwLCAyMDgwMzc0Nzg0LCA0MDk2LCA2NTQwOCwgNTI0Mjg4LCA2NTUzMl0pO1xuXG4gIGNvbnN0IFRva2VuTG9va3VwID0gW1xyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjUsXHJcbiAgICAgIDEzMyxcclxuICAgICAgMTI1LFxyXG4gICAgICAxMjUsXHJcbiAgICAgIDEyNyxcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI2LFxyXG4gICAgICAxMjYsXHJcbiAgICAgIDEyNixcclxuICAgICAgMTI1LFxyXG4gICAgICAxNjg0Mjc5NyxcclxuICAgICAgMTM0MjgzMjY3LFxyXG4gICAgICAxMjgsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgODQ1NzAxMixcclxuICAgICAgODQ1NTc0OCxcclxuICAgICAgMTM0MjgzMjY3LFxyXG4gICAgICA2NzE3NDQxMSxcclxuICAgICAgMTYsXHJcbiAgICAgIDg0NTcwMTEsXHJcbiAgICAgIDI1MjMzOTY3LFxyXG4gICAgICAxMDczNzQxODQyLFxyXG4gICAgICAyNTIzMzk2OCxcclxuICAgICAgNjcxMDg4NzcsXHJcbiAgICAgIDg0NTcwMTMsXHJcbiAgICAgIDEzNDI4MzI2NixcclxuICAgICAgMTM0MjgzMjY2LFxyXG4gICAgICAxMzQyODMyNjYsXHJcbiAgICAgIDEzNDI4MzI2NixcclxuICAgICAgMTM0MjgzMjY2LFxyXG4gICAgICAxMzQyODMyNjYsXHJcbiAgICAgIDEzNDI4MzI2NixcclxuICAgICAgMTM0MjgzMjY2LFxyXG4gICAgICAxMzQyODMyNjYsXHJcbiAgICAgIDEzNDI4MzI2NixcclxuICAgICAgMjEsXHJcbiAgICAgIDEwNzQ3OTA0MTcsXHJcbiAgICAgIDg0NTYyNTUsXHJcbiAgICAgIDEwNzc5MzYxNTcsXHJcbiAgICAgIDg0NTYyNTYsXHJcbiAgICAgIDIyLFxyXG4gICAgICAxMzAsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICA2OTI3MTU3MSxcclxuICAgICAgMTM0LFxyXG4gICAgICAyMCxcclxuICAgICAgODQ1NTQ5NCxcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAxMjksXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgNDA5NixcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgNDA5NixcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICA0MDk2LFxyXG4gICAgICAyMDg4OTcsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDQwOTYsXHJcbiAgICAgIDIwODg5NyxcclxuICAgICAgNDA5NixcclxuICAgICAgNDA5NixcclxuICAgICAgMjA4ODk3LFxyXG4gICAgICA0MDk2LFxyXG4gICAgICA0MDk2LFxyXG4gICAgICAyMTYyNzAwLFxyXG4gICAgICA4NDU1MjM3LFxyXG4gICAgICAxMDc0NzkwNDE1LFxyXG4gICAgICAxNjg0Mjc5OCxcclxuICAgICAgMTI2XHJcbiAgXTtcclxuICBmdW5jdGlvbiBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KSB7XHJcbiAgICAgIHBhcnNlci5mbGFncyA9IChwYXJzZXIuZmxhZ3MgfCAxKSBeIDE7XHJcbiAgICAgIHBhcnNlci5zdGFydFBvcyA9IHBhcnNlci5pbmRleDtcclxuICAgICAgcGFyc2VyLnN0YXJ0Q29sdW1uID0gcGFyc2VyLmNvbHVtbjtcclxuICAgICAgcGFyc2VyLnN0YXJ0TGluZSA9IHBhcnNlci5saW5lO1xyXG4gICAgICBwYXJzZXIudG9rZW4gPSBzY2FuU2luZ2xlVG9rZW4ocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgaWYgKHBhcnNlci5vblRva2VuICYmIHBhcnNlci50b2tlbiAhPT0gMTA0ODU3NilcclxuICAgICAgICAgIHBhcnNlci5vblRva2VuKGNvbnZlcnRUb2tlblR5cGUocGFyc2VyLnRva2VuKSwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIuaW5kZXgpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuU2luZ2xlVG9rZW4ocGFyc2VyLCBjb250ZXh0LCBzdGF0ZSkge1xyXG4gICAgICBjb25zdCBpc1N0YXJ0T2ZMaW5lID0gcGFyc2VyLmluZGV4ID09PSAwO1xyXG4gICAgICBjb25zdCBzb3VyY2UgPSBwYXJzZXIuc291cmNlO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLmluZGV4IDwgcGFyc2VyLmVuZCkge1xyXG4gICAgICAgICAgcGFyc2VyLnRva2VuUG9zID0gcGFyc2VyLmluZGV4O1xyXG4gICAgICAgICAgcGFyc2VyLmNvbFBvcyA9IHBhcnNlci5jb2x1bW47XHJcbiAgICAgICAgICBwYXJzZXIubGluZVBvcyA9IHBhcnNlci5saW5lO1xyXG4gICAgICAgICAgbGV0IGNoYXIgPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICBpZiAoY2hhciA8PSAweDdlKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBUb2tlbkxvb2t1cFtjaGFyXTtcclxuICAgICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNjcxNzQ0MTE6XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjE2MjcwMDpcclxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDc0NzkwNDE1OlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDY5MjcxNTcxOlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDIxOlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwNzQ3OTA0MTc6XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA3Mzc0MTg0MjpcclxuICAgICAgICAgICAgICAgICAgY2FzZSAxNjg0Mjc5ODpcclxuICAgICAgICAgICAgICAgICAgY2FzZSAxMzA6XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTI2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgY2FzZSA4NDU2MjU1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGNoID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPCBwYXJzZXIuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmluZGV4IDwgcGFyc2VyLmVuZCAmJiBhZHZhbmNlQ2hhcihwYXJzZXIpID09PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0MTk0MzM0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU2NTEzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gNjEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTU5OTc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMzMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZXIuaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgcGFyc2VyLmVuZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSA0NSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PSA0NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiArPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gc291cmNlLmNoYXJDb2RlQXQoKHBhcnNlci5pbmRleCArPSAzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHNraXBTaW5nbGVIVE1MQ29tbWVudChwYXJzZXIsIHNvdXJjZSwgc3RhdGUsIGNvbnRleHQsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTYyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZXh0ICYgMTYpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU2MjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlci5pbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHBhcnNlci5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0MiB8fCBjaCA9PT0gNDcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU2MjU1O1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwNzc5MzYxNTc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmluZGV4ID49IHBhcnNlci5lbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwNzc5MzYxNTc7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHBhcnNlci5jdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNjEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWR2YW5jZUNoYXIocGFyc2VyKSA9PT0gNjEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTU5OTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU1OTk1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2Mikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwNzc5MzYxNTc7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgY2FzZSAxNjg0Mjc5NzpcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZHZhbmNlQ2hhcihwYXJzZXIpICE9PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNjg0Mjc5NztcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZHZhbmNlQ2hhcihwYXJzZXIpICE9PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU1OTk2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU1OTk0O1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDg0NTcwMTI6XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYWR2YW5jZUNoYXIocGFyc2VyKSAhPT0gNjEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTcwMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQxOTQzNDI7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgODQ1NzAxMToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPj0gcGFyc2VyLmVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gODQ1NzAxMTtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gcGFyc2VyLmN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQxOTQzNDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT09IDQyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU3MDExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFkdmFuY2VDaGFyKHBhcnNlcikgIT09IDYxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU3MjcwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA0MTk0MzM3O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgODQ1NTQ5NDpcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZHZhbmNlQ2hhcihwYXJzZXIpICE9PSA2MSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gODQ1NTQ5NDtcclxuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDE5NDM0MztcclxuICAgICAgICAgICAgICAgICAgY2FzZSAyNTIzMzk2Nzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gcGFyc2VyLmN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0Mykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDMzNjE5OTk1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQxOTQzMzg7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjUyMzM5Njc7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgY2FzZSAyNTIzMzk2ODoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPj0gcGFyc2VyLmVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjUyMzM5Njg7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHBhcnNlci5jdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc3RhdGUgJiAxIHx8IGlzU3RhcnRPZkxpbmUpICYmIHBhcnNlci5jdXJyZW50Q2hhciA9PT0gNjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZXh0ICYgMjU2KSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEwOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc2tpcFNpbmdsZUhUTUxDb21tZW50KHBhcnNlciwgc291cmNlLCBzdGF0ZSwgY29udGV4dCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzM2MTk5OTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDYxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDE5NDMzOTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyNTIzMzk2ODtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDg0NTcwMTM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmluZGV4IDwgcGFyc2VyLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gcGFyc2VyLmN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBza2lwU2luZ2xlTGluZUNvbW1lbnQocGFyc2VyLCBzb3VyY2UsIHN0YXRlLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBza2lwTXVsdGlMaW5lQ29tbWVudChwYXJzZXIsIHNvdXJjZSwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiAzMjc2OCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblJlZ3VsYXJFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNjEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQyNTk4Nzc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTcwMTM7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgY2FzZSA4NDU1MjM3OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5pbmRleCA+PSBwYXJzZXIuZW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU1MjM3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2ggPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEyNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg5NzkwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDYxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDE5NDM0NDtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU1MjM3O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgODQ1NjI1Njoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPj0gcGFyc2VyLmVuZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gODQ1NjI1NjtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gcGFyc2VyLmN1cnJlbnRDaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTU5OTg7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT09IDYyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDU2MjU2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPCBwYXJzZXIuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2ggPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2Mikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWR2YW5jZUNoYXIocGFyc2VyKSA9PT0gNjEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDE5NDMzNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gODQ1NjUxNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDE5NDMzNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gODQ1NjUxNDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDg0NTU3NDg6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmluZGV4ID49IHBhcnNlci5lbmQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0NTU3NDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHBhcnNlci5jdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMzgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA4OTc5MjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQxOTQzNDU7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gODQ1NTc0ODtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDY3MTA4ODc3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuTnVtYmVyKHBhcnNlciwgY29udGV4dCwgNjQgfCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gNDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlci5pbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcGFyc2VyLmVuZCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDQ2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gc291cmNlLmNoYXJDb2RlQXQoKHBhcnNlci5pbmRleCArPSAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNjcxMDg4Nzc7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIGxldCBjaCA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbnRleHQgJiAxKSA8IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA2Mykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI3Njg4OTk3OTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlci5pbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcGFyc2VyLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2ggPj0gNDggJiYgY2ggPD0gNTcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDY3MTA4OTg4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIyO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDA5NjpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDEpO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDIwODg5NzpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzNDI4MzI2NjpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuTnVtYmVyKHBhcnNlciwgY29udGV4dCwgMTYgfCAxMjgpO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzNDI4MzI2NzpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nKHBhcnNlciwgY29udGV4dCwgY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTI5OlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZShwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzNDpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuVW5pY29kZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgY2FzZSAxMjg6XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblByaXZhdGVOYW1lKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTI1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEyNzpcclxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDEgfCA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgc2Nhbk5ld0xpbmUocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzMzpcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVMaW5lRmVlZChwYXJzZXIsIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gKHN0YXRlICYgfjQpIHwgMTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmICgoY2hhciBeIDgyMzIpIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgc3RhdGUgPSAoc3RhdGUgJiB+NCkgfCAxO1xyXG4gICAgICAgICAgICAgICAgICBzY2FuTmV3TGluZShwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKChjaGFyICYgMHhmYzAwKSA9PT0gMHhkODAwIHx8ICgodW5pY29kZUxvb2t1cFsoY2hhciA+Pj4gNSkgKyAzNDgxNl0gPj4+IGNoYXIpICYgMzEgJiAxKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKGNoYXIgJiAweGZjMDApID09PSAweGRjMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNoYXIgPSAoKGNoYXIgJiAweDNmZikgPDwgMTApIHwgKGNoYXIgJiAweDNmZikgfCAweDEwMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCgodW5pY29kZUxvb2t1cFsoY2hhciA+Pj4gNSkgKyAwXSA+Pj4gY2hhcikgJiAzMSAmIDEpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTgsIGZyb21Db2RlUG9pbnQoY2hhcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY3VycmVudENoYXIgPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rKztcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLnRva2VuVmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyU2xvd0Nhc2UocGFyc2VyLCBjb250ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGlzRXhvdGljRUNNQVNjcmlwdFdoaXRlc3BhY2UoY2hhcikpIHtcclxuICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE4LCBmcm9tQ29kZVBvaW50KGNoYXIpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gMTA0ODU3NjtcclxuICB9XG5cbiAgY29uc3QgQ29tbWVudFR5cGVzID0gWydTaW5nbGVMaW5lJywgJ011bHRpTGluZScsICdIVE1MT3BlbicsICdIVE1MQ2xvc2UnLCAnSGFzaGJhbmdDb21tZW50J107XHJcbiAgZnVuY3Rpb24gc2tpcEhhc2hCYW5nKHBhcnNlcikge1xyXG4gICAgICBjb25zdCBzb3VyY2UgPSBwYXJzZXIuc291cmNlO1xyXG4gICAgICBpZiAocGFyc2VyLmN1cnJlbnRDaGFyID09PSAzNSAmJiBzb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXggKyAxKSA9PT0gMzMpIHtcclxuICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudChwYXJzZXIsIHNvdXJjZSwgMCwgNCk7XHJcbiAgICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gc2tpcFNpbmdsZUhUTUxDb21tZW50KHBhcnNlciwgc291cmNlLCBzdGF0ZSwgY29udGV4dCwgdHlwZSkge1xyXG4gICAgICBpZiAoY29udGV4dCAmIDIwNDgpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAwKTtcclxuICAgICAgcmV0dXJuIHNraXBTaW5nbGVMaW5lQ29tbWVudChwYXJzZXIsIHNvdXJjZSwgc3RhdGUsIHR5cGUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBza2lwU2luZ2xlTGluZUNvbW1lbnQocGFyc2VyLCBzb3VyY2UsIHN0YXRlLCB0eXBlKSB7XHJcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IHBhcnNlcjtcclxuICAgICAgd2hpbGUgKHBhcnNlci5pbmRleCA8IHBhcnNlci5lbmQpIHtcclxuICAgICAgICAgIGlmIChDaGFyVHlwZXNbcGFyc2VyLmN1cnJlbnRDaGFyXSAmIDgpIHtcclxuICAgICAgICAgICAgICBjb25zdCBpc0NSID0gcGFyc2VyLmN1cnJlbnRDaGFyID09PSAxMztcclxuICAgICAgICAgICAgICBzY2FuTmV3TGluZShwYXJzZXIpO1xyXG4gICAgICAgICAgICAgIGlmIChpc0NSICYmIHBhcnNlci5pbmRleCA8IHBhcnNlci5lbmQgJiYgcGFyc2VyLmN1cnJlbnRDaGFyID09PSAxMClcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gc291cmNlLmNoYXJDb2RlQXQoKytwYXJzZXIuaW5kZXgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci5jdXJyZW50Q2hhciBeIDgyMzIpIDw9IDEpIHtcclxuICAgICAgICAgICAgICBzY2FuTmV3TGluZShwYXJzZXIpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyc2VyLm9uQ29tbWVudClcclxuICAgICAgICAgIHBhcnNlci5vbkNvbW1lbnQoQ29tbWVudFR5cGVzW3R5cGUgJiAweGZmXSwgc291cmNlLnNsaWNlKGluZGV4LCBwYXJzZXIuaW5kZXgpLCBpbmRleCwgcGFyc2VyLmluZGV4KTtcclxuICAgICAgcmV0dXJuIHN0YXRlIHwgMTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2tpcE11bHRpTGluZUNvbW1lbnQocGFyc2VyLCBzb3VyY2UsIHN0YXRlKSB7XHJcbiAgICAgIGNvbnN0IHsgaW5kZXggfSA9IHBhcnNlcjtcclxuICAgICAgd2hpbGUgKHBhcnNlci5pbmRleCA8IHBhcnNlci5lbmQpIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIuY3VycmVudENoYXIgPCAweDJiKSB7XHJcbiAgICAgICAgICAgICAgbGV0IHNraXBwZWRPbmVBc3RlcmlzayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIHdoaWxlIChwYXJzZXIuY3VycmVudENoYXIgPT09IDQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghc2tpcHBlZE9uZUFzdGVyaXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSAmPSB+NDtcclxuICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRPbmVBc3RlcmlzayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKGFkdmFuY2VDaGFyKHBhcnNlcikgPT09IDQ3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5vbkNvbW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLm9uQ29tbWVudChDb21tZW50VHlwZXNbMSAmIDB4ZmZdLCBzb3VyY2Uuc2xpY2UoaW5kZXgsIHBhcnNlci5pbmRleCAtIDIpLCBpbmRleCwgcGFyc2VyLmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoc2tpcHBlZE9uZUFzdGVyaXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoQ2hhclR5cGVzW3BhcnNlci5jdXJyZW50Q2hhcl0gJiA4KSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY3VycmVudENoYXIgPT09IDEzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB8PSAxIHwgNDtcclxuICAgICAgICAgICAgICAgICAgICAgIHNjYW5OZXdMaW5lKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdW1lTGluZUZlZWQocGFyc2VyLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IChzdGF0ZSAmIH40KSB8IDE7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci5jdXJyZW50Q2hhciBeIDgyMzIpIDw9IDEpIHtcclxuICAgICAgICAgICAgICBzdGF0ZSA9IChzdGF0ZSAmIH40KSB8IDE7XHJcbiAgICAgICAgICAgICAgc2Nhbk5ld0xpbmUocGFyc2VyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN0YXRlICY9IH40O1xyXG4gICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmVwb3J0KHBhcnNlciwgMTYpO1xyXG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlQ2hhcihwYXJzZXIpIHtcclxuICAgICAgcGFyc2VyLmNvbHVtbisrO1xyXG4gICAgICByZXR1cm4gKHBhcnNlci5jdXJyZW50Q2hhciA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdCgrK3BhcnNlci5pbmRleCkpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb25zdW1lTXVsdGlVbml0Q29kZVBvaW50KHBhcnNlciwgaGkpIHtcclxuICAgICAgaWYgKChoaSAmIDB4ZmMwMCkgIT09IDU1Mjk2KVxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIGNvbnN0IGxvID0gcGFyc2VyLnNvdXJjZS5jaGFyQ29kZUF0KHBhcnNlci5pbmRleCArIDEpO1xyXG4gICAgICBpZiAoKGxvICYgMHhmYzAwKSAhPT0gMHhkYzAwKVxyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIGhpID0gcGFyc2VyLmN1cnJlbnRDaGFyID0gNjU1MzYgKyAoKGhpICYgMHgzZmYpIDw8IDEwKSArIChsbyAmIDB4M2ZmKTtcclxuICAgICAgaWYgKCgodW5pY29kZUxvb2t1cFsoaGkgPj4+IDUpICsgMF0gPj4+IGhpKSAmIDMxICYgMSkgPT09IDApIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE4LCBmcm9tQ29kZVBvaW50KGhpKSk7XHJcbiAgICAgIH1cclxuICAgICAgcGFyc2VyLmluZGV4Kys7XHJcbiAgICAgIHBhcnNlci5jb2x1bW4rKztcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNvbnN1bWVMaW5lRmVlZChwYXJzZXIsIHN0YXRlKSB7XHJcbiAgICAgIHBhcnNlci5jdXJyZW50Q2hhciA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdCgrK3BhcnNlci5pbmRleCk7XHJcbiAgICAgIHBhcnNlci5mbGFncyB8PSAxO1xyXG4gICAgICBpZiAoKHN0YXRlICYgNCkgPT09IDApIHtcclxuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwO1xyXG4gICAgICAgICAgcGFyc2VyLmxpbmUrKztcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuTmV3TGluZShwYXJzZXIpIHtcclxuICAgICAgcGFyc2VyLmZsYWdzIHw9IDE7XHJcbiAgICAgIHBhcnNlci5jdXJyZW50Q2hhciA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdCgrK3BhcnNlci5pbmRleCk7XHJcbiAgICAgIHBhcnNlci5jb2x1bW4gPSAwO1xyXG4gICAgICBwYXJzZXIubGluZSsrO1xyXG4gIH1cclxuICBmdW5jdGlvbiBpc0V4b3RpY0VDTUFTY3JpcHRXaGl0ZXNwYWNlKGNoKSB7XHJcbiAgICAgIHJldHVybiAoY2ggPT09IDE2MCB8fFxyXG4gICAgICAgICAgY2ggPT09IDY1Mjc5IHx8XHJcbiAgICAgICAgICBjaCA9PT0gMTMzIHx8XHJcbiAgICAgICAgICBjaCA9PT0gNTc2MCB8fFxyXG4gICAgICAgICAgKGNoID49IDgxOTIgJiYgY2ggPD0gODIwMykgfHxcclxuICAgICAgICAgIGNoID09PSA4MjM5IHx8XHJcbiAgICAgICAgICBjaCA9PT0gODI4NyB8fFxyXG4gICAgICAgICAgY2ggPT09IDEyMjg4IHx8XHJcbiAgICAgICAgICBjaCA9PT0gODIwMSB8fFxyXG4gICAgICAgICAgY2ggPT09IDY1NTE5KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpIHtcclxuICAgICAgcmV0dXJuIGNvZGVQb2ludCA8PSA2NTUzNVxyXG4gICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludClcclxuICAgICAgICAgIDogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQgPj4+IDEwKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50ICYgMHgzZmYpO1xyXG4gIH1cclxuICBmdW5jdGlvbiB0b0hleChjb2RlKSB7XHJcbiAgICAgIHJldHVybiBjb2RlIDwgNjUgPyBjb2RlIC0gNDggOiAoY29kZSAtIDY1ICsgMTApICYgMHhmO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjb252ZXJ0VG9rZW5UeXBlKHQpIHtcclxuICAgICAgc3dpdGNoICh0KSB7XHJcbiAgICAgICAgICBjYXNlIDEzNDI4MzI2NjpcclxuICAgICAgICAgICAgICByZXR1cm4gJ051bWVyaWNMaXRlcmFsJztcclxuICAgICAgICAgIGNhc2UgMTM0MjgzMjY3OlxyXG4gICAgICAgICAgICAgIHJldHVybiAnU3RyaW5nTGl0ZXJhbCc7XHJcbiAgICAgICAgICBjYXNlIDg2MDIxOlxyXG4gICAgICAgICAgY2FzZSA4NjAyMjpcclxuICAgICAgICAgICAgICByZXR1cm4gJ0Jvb2xlYW5MaXRlcmFsJztcclxuICAgICAgICAgIGNhc2UgODYwMjM6XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdOdWxsTGl0ZXJhbCc7XHJcbiAgICAgICAgICBjYXNlIDY1NTQwOlxyXG4gICAgICAgICAgICAgIHJldHVybiAnUmVndWxhckV4cHJlc3Npb24nO1xyXG4gICAgICAgICAgY2FzZSA2NzE3NDQwODpcclxuICAgICAgICAgIGNhc2UgNjcxNzQ0MDk6XHJcbiAgICAgICAgICBjYXNlIDEyOTpcclxuICAgICAgICAgICAgICByZXR1cm4gJ1RlbXBsYXRlTGl0ZXJhbCc7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGlmICgodCAmIDE0MzM2MCkgPT09IDE0MzM2MClcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdJZGVudGlmaWVyJztcclxuICAgICAgICAgICAgICBpZiAoKHQgJiA0MDk2KSA9PT0gNDA5NilcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuICdLZXl3b3JkJztcclxuICAgICAgICAgICAgICByZXR1cm4gJ1B1bmN0dWF0b3InO1xyXG4gICAgICB9XHJcbiAgfVxuXG4gIGNvbnN0IENoYXJUeXBlcyA9IFtcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgOCB8IDEwMjQsXHJcbiAgICAgIDAsXHJcbiAgICAgIDAsXHJcbiAgICAgIDggfCAyMDQ4LFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICA4MTkyLFxyXG4gICAgICAwLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgODE5MixcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMjU2LFxyXG4gICAgICAwLFxyXG4gICAgICAyNTYgfCAzMjc2OCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMiB8IDE2IHwgMTI4IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMTI4IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgMzIgfCA2NCxcclxuICAgICAgMiB8IDE2IHwgNTEyIHwgNjQsXHJcbiAgICAgIDIgfCAxNiB8IDUxMiB8IDY0LFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxNjM4NCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSB8IDIgfCA2NCxcclxuICAgICAgMSB8IDIgfCA2NCxcclxuICAgICAgMSB8IDIgfCA2NCxcclxuICAgICAgMSB8IDIgfCA2NCxcclxuICAgICAgMSB8IDIgfCA2NCxcclxuICAgICAgMSB8IDIgfCA2NCxcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAxIHwgMixcclxuICAgICAgMSB8IDIsXHJcbiAgICAgIDEgfCAyLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxIHwgMiB8IDQwOTYsXHJcbiAgICAgIDAsXHJcbiAgICAgIDEgfCAyIHwgNCB8IDY0LFxyXG4gICAgICAxIHwgMiB8IDQgfCA2NCxcclxuICAgICAgMSB8IDIgfCA0IHwgNjQsXHJcbiAgICAgIDEgfCAyIHwgNCB8IDY0LFxyXG4gICAgICAxIHwgMiB8IDQgfCA2NCxcclxuICAgICAgMSB8IDIgfCA0IHwgNjQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxIHwgMiB8IDQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxIHwgMiB8IDQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxIHwgMiB8IDQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxIHwgMiB8IDQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxIHwgMiB8IDQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxIHwgMiB8IDQsXHJcbiAgICAgIDEgfCAyIHwgNCxcclxuICAgICAgMSB8IDIgfCA0LFxyXG4gICAgICAxNjM4NCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMFxyXG4gIF07XHJcbiAgY29uc3QgaXNJZFN0YXJ0ID0gW1xyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAxLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwLFxyXG4gICAgICAwXHJcbiAgXTtcclxuICBjb25zdCBpc0lkUGFydCA9IFtcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMSxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMCxcclxuICAgICAgMFxyXG4gIF07XHJcbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xyXG4gICAgICByZXR1cm4gY29kZSA8PSAweDdGXHJcbiAgICAgICAgICA/IGlzSWRTdGFydFtjb2RlXVxyXG4gICAgICAgICAgOiAodW5pY29kZUxvb2t1cFsoY29kZSA+Pj4gNSkgKyAzNDgxNl0gPj4+IGNvZGUpICYgMzEgJiAxO1xyXG4gIH1cclxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcclxuICAgICAgcmV0dXJuIGNvZGUgPD0gMHg3RlxyXG4gICAgICAgICAgPyBpc0lkUGFydFtjb2RlXVxyXG4gICAgICAgICAgOiAodW5pY29kZUxvb2t1cFsoY29kZSA+Pj4gNSkgKyAwXSA+Pj4gY29kZSkgJiAzMSAmIDEgfHwgKGNvZGUgPT09IDgyMDQgfHwgY29kZSA9PT0gODIwNSk7XHJcbiAgfVxuXG4gIGNvbnN0IEtleXdvcmREZXNjVGFibGUgPSBbXHJcbiAgICAgICdlbmQgb2Ygc291cmNlJyxcclxuICAgICAgJ2lkZW50aWZpZXInLCAnbnVtYmVyJywgJ3N0cmluZycsICdyZWd1bGFyIGV4cHJlc3Npb24nLFxyXG4gICAgICAnZmFsc2UnLCAndHJ1ZScsICdudWxsJyxcclxuICAgICAgJ3RlbXBsYXRlIGNvbnRpbnVhdGlvbicsICd0ZW1wbGF0ZSB0YWlsJyxcclxuICAgICAgJz0+JywgJygnLCAneycsICcuJywgJy4uLicsICd9JywgJyknLCAnOycsICcsJywgJ1snLCAnXScsICc6JywgJz8nLCAnXFwnJywgJ1wiJywgJzwvJywgJy8+JyxcclxuICAgICAgJysrJywgJy0tJyxcclxuICAgICAgJz0nLCAnPDw9JywgJz4+PScsICc+Pj49JywgJyoqPScsICcrPScsICctPScsICcqPScsICcvPScsICclPScsICdePScsICd8PScsXHJcbiAgICAgICcmPScsXHJcbiAgICAgICd0eXBlb2YnLCAnZGVsZXRlJywgJ3ZvaWQnLCAnIScsICd+JywgJysnLCAnLScsICdpbicsICdpbnN0YW5jZW9mJywgJyonLCAnJScsICcvJywgJyoqJywgJyYmJyxcclxuICAgICAgJ3x8JywgJz09PScsICchPT0nLCAnPT0nLCAnIT0nLCAnPD0nLCAnPj0nLCAnPCcsICc+JywgJzw8JywgJz4+JywgJz4+PicsICcmJywgJ3wnLCAnXicsXHJcbiAgICAgICd2YXInLCAnbGV0JywgJ2NvbnN0JyxcclxuICAgICAgJ2JyZWFrJywgJ2Nhc2UnLCAnY2F0Y2gnLCAnY2xhc3MnLCAnY29udGludWUnLCAnZGVidWdnZXInLCAnZGVmYXVsdCcsICdkbycsICdlbHNlJywgJ2V4cG9ydCcsXHJcbiAgICAgICdleHRlbmRzJywgJ2ZpbmFsbHknLCAnZm9yJywgJ2Z1bmN0aW9uJywgJ2lmJywgJ2ltcG9ydCcsICduZXcnLCAncmV0dXJuJywgJ3N1cGVyJywgJ3N3aXRjaCcsXHJcbiAgICAgICd0aGlzJywgJ3Rocm93JywgJ3RyeScsICd3aGlsZScsICd3aXRoJyxcclxuICAgICAgJ2ltcGxlbWVudHMnLCAnaW50ZXJmYWNlJywgJ3BhY2thZ2UnLCAncHJpdmF0ZScsICdwcm90ZWN0ZWQnLCAncHVibGljJywgJ3N0YXRpYycsICd5aWVsZCcsXHJcbiAgICAgICdhcycsICdhc3luYycsICdhd2FpdCcsICdjb25zdHJ1Y3RvcicsICdnZXQnLCAnc2V0JywgJ2Zyb20nLCAnb2YnLFxyXG4gICAgICAnZW51bScsICdldmFsJywgJ2FyZ3VtZW50cycsICdlc2NhcGVkIGtleXdvcmQnLCAnZXNjYXBlZCBmdXR1cmUgcmVzZXJ2ZWQga2V5d29yZCcsICdyZXNlcnZlZCBpZiBzdHJpY3QnLCAnIycsXHJcbiAgICAgICdCaWdJbnRMaXRlcmFsJywgJz8/JywgJz8uJywgJ1doaXRlU3BhY2UnLCAnSWxsZWdhbCcsICdMaW5lVGVybWluYXRvcicsICdQcml2YXRlRmllbGQnLFxyXG4gICAgICAnVGVtcGxhdGUnLCAnQCcsICd0YXJnZXQnLCAnbWV0YScsICdMaW5lRmVlZCcsICdFc2NhcGVkJywgJ0pTWFRleHQnXHJcbiAgXTtcclxuICBjb25zdCBkZXNjS2V5d29yZFRhYmxlID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIHRoaXM6IHsgdmFsdWU6IDg2MTEwIH0sXHJcbiAgICAgIGZ1bmN0aW9uOiB7IHZhbHVlOiA4NjEwMyB9LFxyXG4gICAgICBpZjogeyB2YWx1ZTogMjA1NjggfSxcclxuICAgICAgcmV0dXJuOiB7IHZhbHVlOiAyMDU3MSB9LFxyXG4gICAgICB2YXI6IHsgdmFsdWU6IDg2MDg3IH0sXHJcbiAgICAgIGVsc2U6IHsgdmFsdWU6IDIwNTYyIH0sXHJcbiAgICAgIGZvcjogeyB2YWx1ZTogMjA1NjYgfSxcclxuICAgICAgbmV3OiB7IHZhbHVlOiA4NjEwNiB9LFxyXG4gICAgICBpbjogeyB2YWx1ZTogODczODg2NSB9LFxyXG4gICAgICB0eXBlb2Y6IHsgdmFsdWU6IDE2ODYzMjc0IH0sXHJcbiAgICAgIHdoaWxlOiB7IHZhbHVlOiAyMDU3NyB9LFxyXG4gICAgICBjYXNlOiB7IHZhbHVlOiAyMDU1NSB9LFxyXG4gICAgICBicmVhazogeyB2YWx1ZTogMjA1NTQgfSxcclxuICAgICAgdHJ5OiB7IHZhbHVlOiAyMDU3NiB9LFxyXG4gICAgICBjYXRjaDogeyB2YWx1ZTogMjA1NTYgfSxcclxuICAgICAgZGVsZXRlOiB7IHZhbHVlOiAxNjg2MzI3NSB9LFxyXG4gICAgICB0aHJvdzogeyB2YWx1ZTogODYxMTEgfSxcclxuICAgICAgc3dpdGNoOiB7IHZhbHVlOiA4NjEwOSB9LFxyXG4gICAgICBjb250aW51ZTogeyB2YWx1ZTogMjA1NTggfSxcclxuICAgICAgZGVmYXVsdDogeyB2YWx1ZTogMjA1NjAgfSxcclxuICAgICAgaW5zdGFuY2VvZjogeyB2YWx1ZTogODQ3NjcyMiB9LFxyXG4gICAgICBkbzogeyB2YWx1ZTogMjA1NjEgfSxcclxuICAgICAgdm9pZDogeyB2YWx1ZTogMTY4NjMyNzYgfSxcclxuICAgICAgZmluYWxseTogeyB2YWx1ZTogMjA1NjUgfSxcclxuICAgICAgYXN5bmM6IHsgdmFsdWU6IDE0MzQ2OCB9LFxyXG4gICAgICBhd2FpdDogeyB2YWx1ZTogMjA5MDA1IH0sXHJcbiAgICAgIGNsYXNzOiB7IHZhbHVlOiA4NjA5MyB9LFxyXG4gICAgICBjb25zdDogeyB2YWx1ZTogODYwODkgfSxcclxuICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IDEyMzk4IH0sXHJcbiAgICAgIGRlYnVnZ2VyOiB7IHZhbHVlOiAyMDU1OSB9LFxyXG4gICAgICBleHBvcnQ6IHsgdmFsdWU6IDIwNTYzIH0sXHJcbiAgICAgIGV4dGVuZHM6IHsgdmFsdWU6IDIwNTY0IH0sXHJcbiAgICAgIGZhbHNlOiB7IHZhbHVlOiA4NjAyMSB9LFxyXG4gICAgICBmcm9tOiB7IHZhbHVlOiAxMjQwMSB9LFxyXG4gICAgICBnZXQ6IHsgdmFsdWU6IDEyMzk5IH0sXHJcbiAgICAgIGltcGxlbWVudHM6IHsgdmFsdWU6IDM2OTYzIH0sXHJcbiAgICAgIGltcG9ydDogeyB2YWx1ZTogODYxMDUgfSxcclxuICAgICAgaW50ZXJmYWNlOiB7IHZhbHVlOiAzNjk2NCB9LFxyXG4gICAgICBsZXQ6IHsgdmFsdWU6IDI0MTczNiB9LFxyXG4gICAgICBudWxsOiB7IHZhbHVlOiA4NjAyMyB9LFxyXG4gICAgICBvZjogeyB2YWx1ZTogMjc0NTQ2IH0sXHJcbiAgICAgIHBhY2thZ2U6IHsgdmFsdWU6IDM2OTY1IH0sXHJcbiAgICAgIHByaXZhdGU6IHsgdmFsdWU6IDM2OTY2IH0sXHJcbiAgICAgIHByb3RlY3RlZDogeyB2YWx1ZTogMzY5NjcgfSxcclxuICAgICAgcHVibGljOiB7IHZhbHVlOiAzNjk2OCB9LFxyXG4gICAgICBzZXQ6IHsgdmFsdWU6IDEyNDAwIH0sXHJcbiAgICAgIHN0YXRpYzogeyB2YWx1ZTogMzY5NjkgfSxcclxuICAgICAgc3VwZXI6IHsgdmFsdWU6IDg2MTA4IH0sXHJcbiAgICAgIHRydWU6IHsgdmFsdWU6IDg2MDIyIH0sXHJcbiAgICAgIHdpdGg6IHsgdmFsdWU6IDIwNTc4IH0sXHJcbiAgICAgIHlpZWxkOiB7IHZhbHVlOiAyNDE3NzAgfSxcclxuICAgICAgZW51bTogeyB2YWx1ZTogMjA1OTUgfSxcclxuICAgICAgZXZhbDogeyB2YWx1ZTogNTM3MDc5OTI0IH0sXHJcbiAgICAgIGFzOiB7IHZhbHVlOiAxMjM5NSB9LFxyXG4gICAgICBhcmd1bWVudHM6IHsgdmFsdWU6IDUzNzA3OTkyNSB9LFxyXG4gICAgICB0YXJnZXQ6IHsgdmFsdWU6IDE0MzQ5MSB9LFxyXG4gICAgICBtZXRhOiB7IHZhbHVlOiAxNDM0OTIgfSxcclxuICB9KTtcblxuICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIGlzVmFsaWRBc0tleXdvcmQpIHtcclxuICAgICAgd2hpbGUgKGlzSWRQYXJ0W2FkdmFuY2VDaGFyKHBhcnNlcildKSB7IH1cclxuICAgICAgcGFyc2VyLnRva2VuVmFsdWUgPSBwYXJzZXIuc291cmNlLnNsaWNlKHBhcnNlci50b2tlblBvcywgcGFyc2VyLmluZGV4KTtcclxuICAgICAgcmV0dXJuIHBhcnNlci5jdXJyZW50Q2hhciAhPT0gOTIgJiYgcGFyc2VyLmN1cnJlbnRDaGFyIDwgMHg3ZVxyXG4gICAgICAgICAgPyBkZXNjS2V5d29yZFRhYmxlW3BhcnNlci50b2tlblZhbHVlXSB8fCAyMDg4OTdcclxuICAgICAgICAgIDogc2NhbklkZW50aWZpZXJTbG93Q2FzZShwYXJzZXIsIGNvbnRleHQsIDAsIGlzVmFsaWRBc0tleXdvcmQpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuVW5pY29kZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0KSB7XHJcbiAgICAgIGNvbnN0IGNvb2tlZENoYXIgPSBzY2FuSWRlbnRpZmllclVuaWNvZGVFc2NhcGUocGFyc2VyKTtcclxuICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNvb2tlZENoYXIpKVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNCk7XHJcbiAgICAgIHBhcnNlci50b2tlblZhbHVlID0gZnJvbUNvZGVQb2ludChjb29rZWRDaGFyKTtcclxuICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyU2xvd0Nhc2UocGFyc2VyLCBjb250ZXh0LCAxLCBDaGFyVHlwZXNbY29va2VkQ2hhcl0gJiA0KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXJTbG93Q2FzZShwYXJzZXIsIGNvbnRleHQsIGhhc0VzY2FwZSwgaXNWYWxpZEFzS2V5d29yZCkge1xyXG4gICAgICBsZXQgc3RhcnQgPSBwYXJzZXIuaW5kZXg7XHJcbiAgICAgIHdoaWxlIChwYXJzZXIuaW5kZXggPCBwYXJzZXIuZW5kKSB7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLmN1cnJlbnRDaGFyID09PSA5Mikge1xyXG4gICAgICAgICAgICAgIHBhcnNlci50b2tlblZhbHVlICs9IHBhcnNlci5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHBhcnNlci5pbmRleCk7XHJcbiAgICAgICAgICAgICAgaGFzRXNjYXBlID0gMTtcclxuICAgICAgICAgICAgICBjb25zdCBjb2RlID0gc2NhbklkZW50aWZpZXJVbmljb2RlRXNjYXBlKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNvZGUpKVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0KTtcclxuICAgICAgICAgICAgICBpc1ZhbGlkQXNLZXl3b3JkID0gaXNWYWxpZEFzS2V5d29yZCAmJiBDaGFyVHlwZXNbY29kZV0gJiA0O1xyXG4gICAgICAgICAgICAgIHBhcnNlci50b2tlblZhbHVlICs9IGZyb21Db2RlUG9pbnQoY29kZSk7XHJcbiAgICAgICAgICAgICAgc3RhcnQgPSBwYXJzZXIuaW5kZXg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChpc0lkZW50aWZpZXJQYXJ0KHBhcnNlci5jdXJyZW50Q2hhcikgfHwgY29uc3VtZU11bHRpVW5pdENvZGVQb2ludChwYXJzZXIsIHBhcnNlci5jdXJyZW50Q2hhcikpIHtcclxuICAgICAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcnNlci5pbmRleCA8PSBwYXJzZXIuZW5kKSB7XHJcbiAgICAgICAgICBwYXJzZXIudG9rZW5WYWx1ZSArPSBwYXJzZXIuc291cmNlLnNsaWNlKHN0YXJ0LCBwYXJzZXIuaW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlci50b2tlblZhbHVlLmxlbmd0aDtcclxuICAgICAgaWYgKGlzVmFsaWRBc0tleXdvcmQgJiYgKGxlbmd0aCA+PSAyICYmIGxlbmd0aCA8PSAxMSkpIHtcclxuICAgICAgICAgIGNvbnN0IHRva2VuID0gZGVzY0tleXdvcmRUYWJsZVtwYXJzZXIudG9rZW5WYWx1ZV07XHJcbiAgICAgICAgICBpZiAodG9rZW4gPT09IHZvaWQgMClcclxuICAgICAgICAgICAgICByZXR1cm4gMjA4ODk3O1xyXG4gICAgICAgICAgaWYgKCFoYXNFc2NhcGUpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSAyMDkwMDUgJiYgKGNvbnRleHQgJiAoMjA0OCB8IDQxOTQzMDQpKSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICA/IHRva2VuXHJcbiAgICAgICAgICAgICAgICAgIDogdG9rZW4gPT09IDM2OTY5XHJcbiAgICAgICAgICAgICAgICAgICAgICA/IDExOVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiAodG9rZW4gJiAzNjg2NCkgPT09IDM2ODY0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAxMTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IDExODtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgMTA3Mzc0MTgyNCAmJlxyXG4gICAgICAgICAgICAgIChjb250ZXh0ICYgODE5MikgPT09IDAgJiZcclxuICAgICAgICAgICAgICAodG9rZW4gJiAyMDQ4MCkgPT09IDIwNDgwKVxyXG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgIGlmICh0b2tlbiA9PT0gMjQxNzcwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgJiAxMDczNzQxODI0XHJcbiAgICAgICAgICAgICAgICAgID8gMTQzNDgwXHJcbiAgICAgICAgICAgICAgICAgIDogY29udGV4dCAmIDIwOTcxNTJcclxuICAgICAgICAgICAgICAgICAgICAgID8gMTE4XHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHRva2VuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRva2VuID09PSAxNDM0NjggJiYgY29udGV4dCAmIDEwNzM3NDE4MjRcclxuICAgICAgICAgICAgICA/IDE0MzQ4MFxyXG4gICAgICAgICAgICAgIDogKHRva2VuICYgMzY4NjQpID09PSAzNjg2NFxyXG4gICAgICAgICAgICAgICAgICA/IHRva2VuXHJcbiAgICAgICAgICAgICAgICAgIDogdG9rZW4gPT09IDIwOTAwNSAmJiAoY29udGV4dCAmIDQxOTQzMDQpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICA/IHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IDExODtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gMjA4ODk3O1xyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuUHJpdmF0ZU5hbWUocGFyc2VyKSB7XHJcbiAgICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoYWR2YW5jZUNoYXIocGFyc2VyKSkpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA5Myk7XHJcbiAgICAgIHJldHVybiAxMjg7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyVW5pY29kZUVzY2FwZShwYXJzZXIpIHtcclxuICAgICAgaWYgKHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXggKyAxKSAhPT0gMTE3KSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA0KTtcclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIuY3VycmVudENoYXIgPSBwYXJzZXIuc291cmNlLmNoYXJDb2RlQXQoKHBhcnNlci5pbmRleCArPSAyKSk7XHJcbiAgICAgIHJldHVybiBzY2FuVW5pY29kZUVzY2FwZShwYXJzZXIpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuVW5pY29kZUVzY2FwZShwYXJzZXIpIHtcclxuICAgICAgbGV0IGNvZGVQb2ludCA9IDA7XHJcbiAgICAgIGNvbnN0IGNoYXIgPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgIGlmIChjaGFyID09PSAxMjMpIHtcclxuICAgICAgICAgIGNvbnN0IGJlZ2luID0gcGFyc2VyLmluZGV4IC0gMjtcclxuICAgICAgICAgIHdoaWxlIChDaGFyVHlwZXNbYWR2YW5jZUNoYXIocGFyc2VyKV0gJiA2NCkge1xyXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IChjb2RlUG9pbnQgPDwgNCkgfCB0b0hleChwYXJzZXIuY3VycmVudENoYXIpO1xyXG4gICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAxMTE0MTExKVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnRTY2FubmVyRXJyb3IoYmVnaW4sIHBhcnNlci5saW5lLCBwYXJzZXIuaW5kZXggKyAxLCAxMDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcnNlci5jdXJyZW50Q2hhciAhPT0gMTI1KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0U2Nhbm5lckVycm9yKGJlZ2luLCBwYXJzZXIubGluZSwgcGFyc2VyLmluZGV4IC0gMSwgNik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKENoYXJUeXBlc1tjaGFyXSAmIDY0KSA9PT0gMClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDYpO1xyXG4gICAgICBjb25zdCBjaGFyMiA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXggKyAxKTtcclxuICAgICAgaWYgKChDaGFyVHlwZXNbY2hhcjJdICYgNjQpID09PSAwKVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNik7XHJcbiAgICAgIGNvbnN0IGNoYXIzID0gcGFyc2VyLnNvdXJjZS5jaGFyQ29kZUF0KHBhcnNlci5pbmRleCArIDIpO1xyXG4gICAgICBpZiAoKENoYXJUeXBlc1tjaGFyM10gJiA2NCkgPT09IDApXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA2KTtcclxuICAgICAgY29uc3QgY2hhcjQgPSBwYXJzZXIuc291cmNlLmNoYXJDb2RlQXQocGFyc2VyLmluZGV4ICsgMyk7XHJcbiAgICAgIGlmICgoQ2hhclR5cGVzW2NoYXI0XSAmIDY0KSA9PT0gMClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDYpO1xyXG4gICAgICBjb2RlUG9pbnQgPSAodG9IZXgoY2hhcikgPDwgMTIpIHwgKHRvSGV4KGNoYXIyKSA8PCA4KSB8ICh0b0hleChjaGFyMykgPDwgNCkgfCB0b0hleChjaGFyNCk7XHJcbiAgICAgIHBhcnNlci5jdXJyZW50Q2hhciA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdCgocGFyc2VyLmluZGV4ICs9IDQpKTtcclxuICAgICAgcmV0dXJuIGNvZGVQb2ludDtcclxuICB9XG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZyhwYXJzZXIsIGNvbnRleHQsIHF1b3RlKSB7XHJcbiAgICAgIGNvbnN0IHsgaW5kZXg6IHN0YXJ0IH0gPSBwYXJzZXI7XHJcbiAgICAgIGxldCByZXQgPSAnJztcclxuICAgICAgbGV0IGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICBsZXQgbWFya2VyID0gcGFyc2VyLmluZGV4O1xyXG4gICAgICB3aGlsZSAoKENoYXJUeXBlc1tjaGFyXSAmIDgpID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAoY2hhciA9PT0gcXVvdGUpIHtcclxuICAgICAgICAgICAgICByZXQgKz0gcGFyc2VyLnNvdXJjZS5zbGljZShtYXJrZXIsIHBhcnNlci5pbmRleCk7XHJcbiAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDUxMilcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLnRva2VuUmF3ID0gcGFyc2VyLnNvdXJjZS5zbGljZShzdGFydCwgcGFyc2VyLmluZGV4KTtcclxuICAgICAgICAgICAgICBwYXJzZXIudG9rZW5WYWx1ZSA9IHJldDtcclxuICAgICAgICAgICAgICByZXR1cm4gMTM0MjgzMjY3O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKChjaGFyICYgOCkgPT09IDggJiYgY2hhciA9PT0gOTIpIHtcclxuICAgICAgICAgICAgICByZXQgKz0gcGFyc2VyLnNvdXJjZS5zbGljZShtYXJrZXIsIHBhcnNlci5pbmRleCk7XHJcbiAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKGNoYXIgPiAweDdlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldCArPSBmcm9tQ29kZVBvaW50KGNoYXIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhcnNlRXNjYXBlKHBhcnNlciwgY29udGV4dCwgY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChjb2RlID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gZnJvbUNvZGVQb2ludChjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3RyaW5nRXJyb3IocGFyc2VyLCBjb2RlLCAwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbWFya2VyID0gcGFyc2VyLmluZGV4ICsgMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPj0gcGFyc2VyLmVuZClcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNCk7XHJcbiAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgfVxyXG4gICAgICByZXBvcnQocGFyc2VyLCAxNCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlRXNjYXBlKHBhcnNlciwgY29udGV4dCwgZmlyc3QpIHtcclxuICAgICAgc3dpdGNoIChmaXJzdCkge1xyXG4gICAgICAgICAgY2FzZSA5ODpcclxuICAgICAgICAgICAgICByZXR1cm4gODtcclxuICAgICAgICAgIGNhc2UgMTAyOlxyXG4gICAgICAgICAgICAgIHJldHVybiAxMjtcclxuICAgICAgICAgIGNhc2UgMTE0OlxyXG4gICAgICAgICAgICAgIHJldHVybiAxMztcclxuICAgICAgICAgIGNhc2UgMTEwOlxyXG4gICAgICAgICAgICAgIHJldHVybiAxMDtcclxuICAgICAgICAgIGNhc2UgMTE2OlxyXG4gICAgICAgICAgICAgIHJldHVybiA5O1xyXG4gICAgICAgICAgY2FzZSAxMTg6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIDExO1xyXG4gICAgICAgICAgY2FzZSAxMzoge1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPCBwYXJzZXIuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY3VycmVudENoYXIgPT09IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuaW5kZXggPSBwYXJzZXIuaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gcGFyc2VyLnNvdXJjZS5jaGFyQ29kZUF0KHBhcnNlci5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgY2FzZSA4MjMyOlxyXG4gICAgICAgICAgY2FzZSA4MjMzOlxyXG4gICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAtMTtcclxuICAgICAgICAgICAgICBwYXJzZXIubGluZSsrO1xyXG4gICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgIGNhc2UgNDg6XHJcbiAgICAgICAgICBjYXNlIDQ5OlxyXG4gICAgICAgICAgY2FzZSA1MDpcclxuICAgICAgICAgIGNhc2UgNTE6IHtcclxuICAgICAgICAgICAgICBsZXQgY29kZSA9IGZpcnN0IC0gNDg7XHJcbiAgICAgICAgICAgICAgbGV0IGluZGV4ID0gcGFyc2VyLmluZGV4ICsgMTtcclxuICAgICAgICAgICAgICBsZXQgY29sdW1uID0gcGFyc2VyLmNvbHVtbiArIDE7XHJcbiAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcGFyc2VyLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFyc2VyLnNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKChDaGFyVHlwZXNbbmV4dF0gJiAzMikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29kZSAhPT0gMCB8fCBDaGFyVHlwZXNbbmV4dF0gJiA1MTIpICYmIGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0ICYgMTAyNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0yO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoY29kZSA8PCAzKSB8IChuZXh0IC0gNDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcGFyc2VyLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDaGFyVHlwZXNbbmV4dF0gJiAzMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY3VycmVudENoYXIgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gKGNvZGUgPDwgMykgfCAobmV4dCAtIDQ4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmZsYWdzIHw9IDY0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmluZGV4ID0gaW5kZXggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IGNvbHVtbiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIDUyOlxyXG4gICAgICAgICAgY2FzZSA1MzpcclxuICAgICAgICAgIGNhc2UgNTQ6XHJcbiAgICAgICAgICBjYXNlIDU1OiB7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTI7XHJcbiAgICAgICAgICAgICAgbGV0IGNvZGUgPSBmaXJzdCAtIDQ4O1xyXG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VyLmluZGV4ICsgMTtcclxuICAgICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXJzZXIuY29sdW1uICsgMTtcclxuICAgICAgICAgICAgICBpZiAoaW5kZXggPCBwYXJzZXIuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoQ2hhclR5cGVzW25leHRdICYgMzIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoY29kZSA8PCAzKSB8IChuZXh0IC0gNDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IGNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gNjQ7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIDU2OlxyXG4gICAgICAgICAgY2FzZSA1NzpcclxuICAgICAgICAgICAgICByZXR1cm4gLTM7XHJcbiAgICAgICAgICBjYXNlIDEyMDoge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNoMSA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKChDaGFyVHlwZXNbY2gxXSAmIDY0KSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIC00O1xyXG4gICAgICAgICAgICAgIGNvbnN0IGhpID0gdG9IZXgoY2gxKTtcclxuICAgICAgICAgICAgICBjb25zdCBjaDIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgIGlmICgoQ2hhclR5cGVzW2NoMl0gJiA2NCkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtNDtcclxuICAgICAgICAgICAgICBjb25zdCBsbyA9IHRvSGV4KGNoMik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIChoaSA8PCA0KSB8IGxvO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSAxMTc6IHtcclxuICAgICAgICAgICAgICBjb25zdCBjaCA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5jdXJyZW50Q2hhciA9PT0gMTIzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gMDtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKChDaGFyVHlwZXNbYWR2YW5jZUNoYXIocGFyc2VyKV0gJiA2NCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAoY29kZSA8PCA0KSB8IHRvSGV4KHBhcnNlci5jdXJyZW50Q2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+IDExMTQxMTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC01O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY3VycmVudENoYXIgPCAxIHx8IHBhcnNlci5jdXJyZW50Q2hhciAhPT0gMTI1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTQ7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKENoYXJUeXBlc1tjaF0gJiA2NCkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTQ7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNoMiA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKChDaGFyVHlwZXNbY2gyXSAmIDY0KSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtNDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2gzID0gcGFyc2VyLnNvdXJjZS5jaGFyQ29kZUF0KHBhcnNlci5pbmRleCArIDIpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKENoYXJUeXBlc1tjaDNdICYgNjQpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC00O1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjaDQgPSBwYXJzZXIuc291cmNlLmNoYXJDb2RlQXQocGFyc2VyLmluZGV4ICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICgoQ2hhclR5cGVzW2NoNF0gJiA2NCkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTQ7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5pbmRleCArPSAzO1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uICs9IDM7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jdXJyZW50Q2hhciA9IHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHRvSGV4KGNoKSA8PCAxMikgfCAodG9IZXgoY2gyKSA8PCA4KSB8ICh0b0hleChjaDMpIDw8IDQpIHwgdG9IZXgoY2g0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBoYW5kbGVTdHJpbmdFcnJvcihzdGF0ZSwgY29kZSwgaXNUZW1wbGF0ZSkge1xyXG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgY2FzZSAtMjpcclxuICAgICAgICAgICAgICByZXBvcnQoc3RhdGUsIGlzVGVtcGxhdGUgPyAyIDogMSk7XHJcbiAgICAgICAgICBjYXNlIC0zOlxyXG4gICAgICAgICAgICAgIHJlcG9ydChzdGF0ZSwgMTMpO1xyXG4gICAgICAgICAgY2FzZSAtNDpcclxuICAgICAgICAgICAgICByZXBvcnQoc3RhdGUsIDYpO1xyXG4gICAgICAgICAgY2FzZSAtNTpcclxuICAgICAgICAgICAgICByZXBvcnQoc3RhdGUsIDEwMSk7XHJcbiAgICAgIH1cclxuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk51bWJlcihwYXJzZXIsIGNvbnRleHQsIGtpbmQpIHtcclxuICAgICAgbGV0IGNoYXIgPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgIGxldCB2YWx1ZSA9IDA7XHJcbiAgICAgIGxldCBkaWdpdCA9IDk7XHJcbiAgICAgIGxldCBhdFN0YXJ0ID0ga2luZCAmIDY0ID8gMCA6IDE7XHJcbiAgICAgIGxldCBkaWdpdHMgPSAwO1xyXG4gICAgICBsZXQgYWxsb3dTZXBhcmF0b3IgPSAwO1xyXG4gICAgICBpZiAoa2luZCAmIDY0KSB7XHJcbiAgICAgICAgICB2YWx1ZSA9ICcuJyArIHNjYW5EZWNpbWFsRGlnaXRzT3JTZXBhcmF0b3IocGFyc2VyLCBjaGFyKTtcclxuICAgICAgICAgIGNoYXIgPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICBpZiAoY2hhciA9PT0gMTEwKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmIChjaGFyID09PSA0OCkge1xyXG4gICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgIGlmICgoY2hhciB8IDMyKSA9PT0gMTIwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGtpbmQgPSA4IHwgMTI4O1xyXG4gICAgICAgICAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKENoYXJUeXBlc1tjaGFyXSAmICg2NCB8IDQwOTYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gOTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93U2VwYXJhdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U2VwYXJhdG9yID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGFsbG93U2VwYXJhdG9yID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAweDEwICsgdG9IZXgoY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkaWdpdHMrKztcclxuICAgICAgICAgICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHMgPCAxIHx8ICFhbGxvd1NlcGFyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgZGlnaXRzIDwgMSA/IDE5IDogMTQ3KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmICgoY2hhciB8IDMyKSA9PT0gMTExKSB7XHJcbiAgICAgICAgICAgICAgICAgIGtpbmQgPSA0IHwgMTI4O1xyXG4gICAgICAgICAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgd2hpbGUgKENoYXJUeXBlc1tjaGFyXSAmICgzMiB8IDQwOTYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gOTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE0Nik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93U2VwYXJhdG9yID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGFsbG93U2VwYXJhdG9yID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiA4ICsgKGNoYXIgLSA0OCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkaWdpdHMrKztcclxuICAgICAgICAgICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHMgPCAxIHx8ICFhbGxvd1NlcGFyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgZGlnaXRzIDwgMSA/IDAgOiAxNDcpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKChjaGFyIHwgMzIpID09PSA5OCkge1xyXG4gICAgICAgICAgICAgICAgICBraW5kID0gMiB8IDEyODtcclxuICAgICAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChDaGFyVHlwZXNbY2hhcl0gJiAoMTI4IHwgNDA5NikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSA5NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTQ2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTZXBhcmF0b3IgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgYWxsb3dTZXBhcmF0b3IgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDIgKyAoY2hhciAtIDQ4KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKGRpZ2l0cyA8IDEgfHwgIWFsbG93U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCBkaWdpdHMgPCAxID8gMCA6IDE0Nyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAoQ2hhclR5cGVzW2NoYXJdICYgMzIpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMSk7XHJcbiAgICAgICAgICAgICAgICAgIGtpbmQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoQ2hhclR5cGVzW2NoYXJdICYgMTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChDaGFyVHlwZXNbY2hhcl0gJiA1MTIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kID0gMzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXRTdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogOCArIChjaGFyIC0gNDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAoQ2hhclR5cGVzW2NoYXJdICYgNTEyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYgMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEpO1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gNjQ7XHJcbiAgICAgICAgICAgICAgICAgIGtpbmQgPSAzMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gOTUpIHtcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGtpbmQgJiA0OCkge1xyXG4gICAgICAgICAgICAgIGlmIChhdFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdCA+PSAwICYmIENoYXJUeXBlc1tjaGFyXSAmICgxNiB8IDQwOTYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gOTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gOTUgfHwga2luZCAmIDMyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydFNjYW5uZXJFcnJvcihwYXJzZXIuaW5kZXgsIHBhcnNlci5saW5lLCBwYXJzZXIuaW5kZXggKyAxLCAxNDYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1NlcGFyYXRvciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBhbGxvd1NlcGFyYXRvciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDEwICogdmFsdWUgKyAoY2hhciAtIDQ4KTtcclxuICAgICAgICAgICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgLS1kaWdpdDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoYWxsb3dTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydFNjYW5uZXJFcnJvcihwYXJzZXIuaW5kZXgsIHBhcnNlci5saW5lLCBwYXJzZXIuaW5kZXggKyAxLCAxNDcpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChkaWdpdCA+PSAwICYmICFpc0lkZW50aWZpZXJTdGFydChjaGFyKSAmJiBjaGFyICE9PSA0Nikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnRva2VuVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYgNTEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50b2tlblJhdyA9IHBhcnNlci5zb3VyY2Uuc2xpY2UocGFyc2VyLnRva2VuUG9zLCBwYXJzZXIuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEzNDI4MzI2NjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB2YWx1ZSArPSBzY2FuRGVjaW1hbERpZ2l0c09yU2VwYXJhdG9yKHBhcnNlciwgY2hhcik7XHJcbiAgICAgICAgICAgICAgY2hhciA9IHBhcnNlci5jdXJyZW50Q2hhcjtcclxuICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gNDYpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGFkdmFuY2VDaGFyKHBhcnNlcikgPT09IDk1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMCk7XHJcbiAgICAgICAgICAgICAgICAgIGtpbmQgPSA2NDtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gJy4nICsgc2NhbkRlY2ltYWxEaWdpdHNPclNlcGFyYXRvcihwYXJzZXIsIHBhcnNlci5jdXJyZW50Q2hhcik7XHJcbiAgICAgICAgICAgICAgICAgIGNoYXIgPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVuZCA9IHBhcnNlci5pbmRleDtcclxuICAgICAgbGV0IGlzQmlnSW50ID0gMDtcclxuICAgICAgaWYgKGNoYXIgPT09IDExMCAmJiBraW5kICYgMTI4KSB7XHJcbiAgICAgICAgICBpc0JpZ0ludCA9IDE7XHJcbiAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICgoY2hhciB8IDMyKSA9PT0gMTAxKSB7XHJcbiAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKENoYXJUeXBlc1tjaGFyXSAmIDI1NilcclxuICAgICAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgIGlmICgoQ2hhclR5cGVzW2NoYXJdICYgMTYpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTApO1xyXG4gICAgICAgICAgICAgIHZhbHVlICs9IHBhcnNlci5zb3VyY2Uuc3Vic3RyaW5nKGVuZCwgaW5kZXgpICsgc2NhbkRlY2ltYWxEaWdpdHNPclNlcGFyYXRvcihwYXJzZXIsIGNoYXIpO1xyXG4gICAgICAgICAgICAgIGNoYXIgPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChwYXJzZXIuaW5kZXggPCBwYXJzZXIuZW5kICYmIENoYXJUeXBlc1tjaGFyXSAmIDE2KSB8fCBpc0lkZW50aWZpZXJTdGFydChjaGFyKSkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0JpZ0ludCkge1xyXG4gICAgICAgICAgcGFyc2VyLnRva2VuUmF3ID0gcGFyc2VyLnNvdXJjZS5zbGljZShwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5pbmRleCk7XHJcbiAgICAgICAgICBwYXJzZXIudG9rZW5WYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAweGEpO1xyXG4gICAgICAgICAgcmV0dXJuIDEyMjtcclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIudG9rZW5WYWx1ZSA9XHJcbiAgICAgICAgICBraW5kICYgKDEgfCAyIHwgOCB8IDQpXHJcbiAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgIDoga2luZCAmIDMyXHJcbiAgICAgICAgICAgICAgICAgID8gcGFyc2VGbG9hdChwYXJzZXIuc291cmNlLnN1YnN0cmluZyhwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5pbmRleCkpXHJcbiAgICAgICAgICAgICAgICAgIDogK3ZhbHVlO1xyXG4gICAgICBpZiAoY29udGV4dCAmIDUxMilcclxuICAgICAgICAgIHBhcnNlci50b2tlblJhdyA9IHBhcnNlci5zb3VyY2Uuc2xpY2UocGFyc2VyLnRva2VuUG9zLCBwYXJzZXIuaW5kZXgpO1xyXG4gICAgICByZXR1cm4gMTM0MjgzMjY2O1xyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuRGVjaW1hbERpZ2l0c09yU2VwYXJhdG9yKHBhcnNlciwgY2hhcikge1xyXG4gICAgICBsZXQgYWxsb3dTZXBhcmF0b3IgPSAwO1xyXG4gICAgICBsZXQgc3RhcnQgPSBwYXJzZXIuaW5kZXg7XHJcbiAgICAgIGxldCByZXQgPSAnJztcclxuICAgICAgd2hpbGUgKENoYXJUeXBlc1tjaGFyXSAmICgxNiB8IDQwOTYpKSB7XHJcbiAgICAgICAgICBpZiAoY2hhciA9PT0gOTUpIHtcclxuICAgICAgICAgICAgICBjb25zdCB7IGluZGV4IH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IDk1KSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydFNjYW5uZXJFcnJvcihwYXJzZXIuaW5kZXgsIHBhcnNlci5saW5lLCBwYXJzZXIuaW5kZXggKyAxLCAxNDYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhbGxvd1NlcGFyYXRvciA9IDE7XHJcbiAgICAgICAgICAgICAgcmV0ICs9IHBhcnNlci5zb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgc3RhcnQgPSBwYXJzZXIuaW5kZXg7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhbGxvd1NlcGFyYXRvciA9IDA7XHJcbiAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYWxsb3dTZXBhcmF0b3IpIHtcclxuICAgICAgICAgIHJlcG9ydFNjYW5uZXJFcnJvcihwYXJzZXIuaW5kZXgsIHBhcnNlci5saW5lLCBwYXJzZXIuaW5kZXggKyAxLCAxNDcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXQgKyBwYXJzZXIuc291cmNlLnN1YnN0cmluZyhzdGFydCwgcGFyc2VyLmluZGV4KTtcclxuICB9XG5cbiAgZnVuY3Rpb24gc2NhblRlbXBsYXRlKHBhcnNlciwgY29udGV4dCkge1xyXG4gICAgICBjb25zdCB7IGluZGV4OiBzdGFydCB9ID0gcGFyc2VyO1xyXG4gICAgICBsZXQgdG9rZW4gPSA2NzE3NDQwOTtcclxuICAgICAgbGV0IHJldCA9ICcnO1xyXG4gICAgICBsZXQgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgIHdoaWxlIChjaGFyICE9PSA5Nikge1xyXG4gICAgICAgICAgaWYgKGNoYXIgPT09IDM2ICYmIHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXggKyAxKSA9PT0gMTIzKSB7XHJcbiAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICB0b2tlbiA9IDY3MTc0NDA4O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoKGNoYXIgJiA4KSA9PT0gOCAmJiBjaGFyID09PSA5Mikge1xyXG4gICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgICAgIGlmIChjaGFyID4gMHg3ZSkge1xyXG4gICAgICAgICAgICAgICAgICByZXQgKz0gZnJvbUNvZGVQb2ludChjaGFyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUVzY2FwZShwYXJzZXIsIGNvbnRleHQgfCAxMDI0LCBjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGZyb21Db2RlUG9pbnQoY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSAhPT0gLTEgJiYgY29udGV4dCAmIDY1NTM2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyID0gc2NhbkJhZFRlbXBsYXRlKHBhcnNlciwgY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSA2NzE3NDQwODtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3RyaW5nRXJyb3IocGFyc2VyLCBjb2RlLCAxKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPCBwYXJzZXIuZW5kICYmXHJcbiAgICAgICAgICAgICAgICAgIGNoYXIgPT09IDEzICYmXHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChwYXJzZXIuaW5kZXgpID09PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgICByZXQgKz0gZnJvbUNvZGVQb2ludChjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmN1cnJlbnRDaGFyID0gcGFyc2VyLnNvdXJjZS5jaGFyQ29kZUF0KCsrcGFyc2VyLmluZGV4KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKCgoY2hhciAmIDgzKSA8IDMgJiYgY2hhciA9PT0gMTApIHx8IChjaGFyIF4gODIzMikgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lKys7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldCArPSBmcm9tQ29kZVBvaW50KGNoYXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcnNlci5pbmRleCA+PSBwYXJzZXIuZW5kKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE1KTtcclxuICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgIHBhcnNlci50b2tlblZhbHVlID0gcmV0O1xyXG4gICAgICBwYXJzZXIudG9rZW5SYXcgPSBwYXJzZXIuc291cmNlLnNsaWNlKHN0YXJ0ICsgMSwgcGFyc2VyLmluZGV4IC0gKHRva2VuID09PSA2NzE3NDQwOSA/IDEgOiAyKSk7XHJcbiAgICAgIHJldHVybiB0b2tlbjtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2NhbkJhZFRlbXBsYXRlKHBhcnNlciwgY2gpIHtcclxuICAgICAgd2hpbGUgKGNoICE9PSA5Nikge1xyXG4gICAgICAgICAgc3dpdGNoIChjaCkge1xyXG4gICAgICAgICAgICAgIGNhc2UgMzY6IHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZXIuaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBwYXJzZXIuZW5kICYmIHBhcnNlci5zb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDEyMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWNoO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgIGNhc2UgODIzMjpcclxuICAgICAgICAgICAgICBjYXNlIDgyMzM6XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPj0gcGFyc2VyLmVuZClcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNSk7XHJcbiAgICAgICAgICBjaCA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNoO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzY2FuVGVtcGxhdGVUYWlsKHBhcnNlciwgY29udGV4dCkge1xyXG4gICAgICBpZiAocGFyc2VyLmluZGV4ID49IHBhcnNlci5lbmQpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAwKTtcclxuICAgICAgcGFyc2VyLmluZGV4LS07XHJcbiAgICAgIHBhcnNlci5jb2x1bW4tLTtcclxuICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZShwYXJzZXIsIGNvbnRleHQpO1xyXG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVndWxhckV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0KSB7XHJcbiAgICAgIGNvbnN0IGJvZHlTdGFydCA9IHBhcnNlci5pbmRleDtcclxuICAgICAgbGV0IHByZXBhcnNlU3RhdGUgPSAwO1xyXG4gICAgICBsb29wOiB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgY29uc3QgY2ggPSBwYXJzZXIuY3VycmVudENoYXI7XHJcbiAgICAgICAgICBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgaWYgKHByZXBhcnNlU3RhdGUgJiAxKSB7XHJcbiAgICAgICAgICAgICAgcHJlcGFyc2VTdGF0ZSAmPSB+MTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuICAgICAgICAgICAgICAgICAgY2FzZSA0NzpcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJlcGFyc2VTdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDkyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcHJlcGFyc2VTdGF0ZSB8PSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgOTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJzZVN0YXRlIHw9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgY2FzZSA5MzpcclxuICAgICAgICAgICAgICAgICAgICAgIHByZXBhcnNlU3RhdGUgJj0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDgyMzI6XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgODIzMzpcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDMyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGFyc2VyLmluZGV4ID49IHBhcnNlci5zb3VyY2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcG9ydChwYXJzZXIsIDMyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCBib2R5RW5kID0gcGFyc2VyLmluZGV4IC0gMTtcclxuICAgICAgbGV0IG1hc2sgPSAwO1xyXG4gICAgICBsZXQgY2hhciA9IHBhcnNlci5jdXJyZW50Q2hhcjtcclxuICAgICAgY29uc3QgeyBpbmRleDogZmxhZ1N0YXJ0IH0gPSBwYXJzZXI7XHJcbiAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KGNoYXIpKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcclxuICAgICAgICAgICAgICBjYXNlIDEwMzpcclxuICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgJiAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzQsICdnJyk7XHJcbiAgICAgICAgICAgICAgICAgIG1hc2sgfD0gMjtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAxMDU6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrICYgMSlcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDM0LCAnaScpO1xyXG4gICAgICAgICAgICAgICAgICBtYXNrIHw9IDE7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgMTA5OlxyXG4gICAgICAgICAgICAgICAgICBpZiAobWFzayAmIDQpXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAzNCwgJ20nKTtcclxuICAgICAgICAgICAgICAgICAgbWFzayB8PSA0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIDExNzpcclxuICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgJiAxNilcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDM0LCAnZycpO1xyXG4gICAgICAgICAgICAgICAgICBtYXNrIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIDEyMTpcclxuICAgICAgICAgICAgICAgICAgaWYgKG1hc2sgJiA4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzQsICd5Jyk7XHJcbiAgICAgICAgICAgICAgICAgIG1hc2sgfD0gODtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAxMTU6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrICYgMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAzNCwgJ3MnKTtcclxuICAgICAgICAgICAgICAgICAgbWFzayB8PSAxMjtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZmxhZ3MgPSBwYXJzZXIuc291cmNlLnNsaWNlKGZsYWdTdGFydCwgcGFyc2VyLmluZGV4KTtcclxuICAgICAgY29uc3QgcGF0dGVybiA9IHBhcnNlci5zb3VyY2Uuc2xpY2UoYm9keVN0YXJ0LCBib2R5RW5kKTtcclxuICAgICAgcGFyc2VyLnRva2VuUmVnRXhwID0geyBwYXR0ZXJuLCBmbGFncyB9O1xyXG4gICAgICBpZiAoY29udGV4dCAmIDUxMilcclxuICAgICAgICAgIHBhcnNlci50b2tlblJhdyA9IHBhcnNlci5zb3VyY2Uuc2xpY2UocGFyc2VyLnRva2VuUG9zLCBwYXJzZXIuaW5kZXgpO1xyXG4gICAgICBwYXJzZXIudG9rZW5WYWx1ZSA9IHZhbGlkYXRlKHBhcnNlciwgcGF0dGVybiwgZmxhZ3MpO1xyXG4gICAgICByZXR1cm4gNjU1NDA7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHBhcnNlciwgcGF0dGVybiwgZmxhZ3MpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzIpO1xyXG4gICAgICB9XHJcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5KU1hBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIGNvbnRleHQpIHtcclxuICAgICAgcGFyc2VyLnN0YXJ0UG9zID0gcGFyc2VyLmluZGV4O1xyXG4gICAgICBwYXJzZXIuc3RhcnRDb2x1bW4gPSBwYXJzZXIuY29sdW1uO1xyXG4gICAgICBwYXJzZXIuc3RhcnRMaW5lID0gcGFyc2VyLmxpbmU7XHJcbiAgICAgIHBhcnNlci50b2tlbiA9XHJcbiAgICAgICAgICBDaGFyVHlwZXNbcGFyc2VyLmN1cnJlbnRDaGFyXSAmIDgxOTJcclxuICAgICAgICAgICAgICA/IHNjYW5KU1hTdHJpbmcocGFyc2VyKVxyXG4gICAgICAgICAgICAgIDogc2NhblNpbmdsZVRva2VuKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgIHJldHVybiBwYXJzZXIudG9rZW47XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNjYW5KU1hTdHJpbmcocGFyc2VyKSB7XHJcbiAgICAgIGNvbnN0IHF1b3RlID0gcGFyc2VyLmN1cnJlbnRDaGFyO1xyXG4gICAgICBsZXQgY2hhciA9IGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcGFyc2VyLmluZGV4O1xyXG4gICAgICB3aGlsZSAoY2hhciAhPT0gcXVvdGUpIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIuaW5kZXggPj0gcGFyc2VyLmVuZClcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNCk7XHJcbiAgICAgICAgICBjaGFyID0gYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhciAhPT0gcXVvdGUpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNCk7XHJcbiAgICAgIHBhcnNlci50b2tlblZhbHVlID0gcGFyc2VyLnNvdXJjZS5zbGljZShzdGFydCwgcGFyc2VyLmluZGV4KTtcclxuICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgcmV0dXJuIDEzNDI4MzI2NztcclxuICB9XHJcbiAgZnVuY3Rpb24gc2NhbkpTWFRva2VuKHBhcnNlcikge1xyXG4gICAgICBwYXJzZXIuc3RhcnRQb3MgPSBwYXJzZXIudG9rZW5Qb3MgPSBwYXJzZXIuaW5kZXg7XHJcbiAgICAgIHBhcnNlci5zdGFydENvbHVtbiA9IHBhcnNlci5jb2xQb3MgPSBwYXJzZXIuY29sdW1uO1xyXG4gICAgICBwYXJzZXIuc3RhcnRMaW5lID0gcGFyc2VyLmxpbmVQb3MgPSBwYXJzZXIubGluZTtcclxuICAgICAgaWYgKHBhcnNlci5pbmRleCA+PSBwYXJzZXIuZW5kKVxyXG4gICAgICAgICAgcmV0dXJuIChwYXJzZXIudG9rZW4gPSAxMDQ4NTc2KTtcclxuICAgICAgY29uc3QgdG9rZW4gPSBUb2tlbkxvb2t1cFtwYXJzZXIuc291cmNlLmNoYXJDb2RlQXQocGFyc2VyLmluZGV4KV07XHJcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgIGNhc2UgODQ1NjI1NToge1xyXG4gICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5jdXJyZW50Q2hhciA9PT0gNDcpIHtcclxuICAgICAgICAgICAgICAgICAgYWR2YW5jZUNoYXIocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLnRva2VuID0gMjU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIudG9rZW4gPSA4NDU2MjU1O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgMjE2MjcwMDoge1xyXG4gICAgICAgICAgICAgIGFkdmFuY2VDaGFyKHBhcnNlcik7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLnRva2VuID0gMjE2MjcwMDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcnNlci5pbmRleCA8IHBhcnNlci5lbmQgJiYgKENoYXJUeXBlc1thZHZhbmNlQ2hhcihwYXJzZXIpXSAmIDE2Mzg0KSA9PT0gMCkgeyB9XHJcbiAgICAgICAgICAgICAgcGFyc2VyLnRva2VuVmFsdWUgPSBwYXJzZXIuc291cmNlLnNsaWNlKHBhcnNlci50b2tlblBvcywgcGFyc2VyLmluZGV4KTtcclxuICAgICAgICAgICAgICBwYXJzZXIudG9rZW4gPSAxMzU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcnNlci50b2tlbjtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2NhbkpTWElkZW50aWZpZXIocGFyc2VyKSB7XHJcbiAgICAgIGlmICgocGFyc2VyLnRva2VuICYgMTQzMzYwKSA9PT0gMTQzMzYwKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGluZGV4IH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICBsZXQgY2hhciA9IHBhcnNlci5jdXJyZW50Q2hhcjtcclxuICAgICAgICAgIHdoaWxlIChDaGFyVHlwZXNbY2hhcl0gJiAoMzI3NjggfCAyKSkge1xyXG4gICAgICAgICAgICAgIGNoYXIgPSBhZHZhbmNlQ2hhcihwYXJzZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGFyc2VyLnRva2VuVmFsdWUgKz0gcGFyc2VyLnNvdXJjZS5zbGljZShpbmRleCwgcGFyc2VyLmluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIudG9rZW4gPSAyMDg4OTc7XHJcbiAgICAgIHJldHVybiBwYXJzZXIudG9rZW47XHJcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0LCBzcGVjRGV2aWF0aW9uKSB7XHJcbiAgICAgIGlmICgocGFyc2VyLmZsYWdzICYgMSkgPT09IDAgJiZcclxuICAgICAgICAgIChwYXJzZXIudG9rZW4gJiAxMDQ4NTc2KSAhPT0gMTA0ODU3NiAmJlxyXG4gICAgICAgICAgIXNwZWNEZXZpYXRpb24pIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCAxMDc0NzkwNDE3KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gaXNWYWxpZFN0cmljdE1vZGUocGFyc2VyLCBpbmRleCwgdG9rZW5Qb3MsIHRva2VuVmFsdWUpIHtcclxuICAgICAgaWYgKGluZGV4IC0gdG9rZW5Qb3MgPCAxMyAmJiB0b2tlblZhbHVlID09PSAndXNlIHN0cmljdCcpIHtcclxuICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgMTA0ODU3NikgPT09IDEwNDg1NzYgfHwgcGFyc2VyLmZsYWdzICYgMSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBmdW5jdGlvbiBvcHRpb25hbEJpdChwYXJzZXIsIGNvbnRleHQsIHQpIHtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gdClcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCB0KSB7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IHQpXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIHQpIHtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gdClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDIzLCBLZXl3b3JkRGVzY1RhYmxlW3QgJiAyNTVdKTtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHN0YXRlLCBub2RlKSB7XHJcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxyXG4gICAgICAgICAgICAgIG5vZGUudHlwZSA9ICdBcnJheVBhdHRlcm4nO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gbm9kZS5lbGVtZW50cztcclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVpbnRlcnByZXRUb1BhdHRlcm4oc3RhdGUsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICBjYXNlICdPYmplY3RFeHByZXNzaW9uJzpcclxuICAgICAgICAgICAgICBub2RlLnR5cGUgPSAnT2JqZWN0UGF0dGVybic7XHJcbiAgICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHN0YXRlLCBwcm9wZXJ0aWVzW2ldKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxyXG4gICAgICAgICAgICAgIG5vZGUudHlwZSA9ICdBc3NpZ25tZW50UGF0dGVybic7XHJcbiAgICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09ICc9JylcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHN0YXRlLCA2OCk7XHJcbiAgICAgICAgICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XHJcbiAgICAgICAgICAgICAgcmVpbnRlcnByZXRUb1BhdHRlcm4oc3RhdGUsIG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgY2FzZSAnUHJvcGVydHknOlxyXG4gICAgICAgICAgICAgIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHN0YXRlLCBub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICBjYXNlICdTcHJlYWRFbGVtZW50JzpcclxuICAgICAgICAgICAgICBub2RlLnR5cGUgPSAnUmVzdEVsZW1lbnQnO1xyXG4gICAgICAgICAgICAgIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHN0YXRlLCBub2RlLmFyZ3VtZW50KTtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB2YWxpZGF0ZUJpbmRpbmdJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwga2luZCwgdCwgc2tpcEV2YWxBcmdDaGVjaykge1xyXG4gICAgICBpZiAoY29udGV4dCAmIDEwMjQpIHtcclxuICAgICAgICAgIGlmICgodCAmIDM2ODY0KSA9PT0gMzY4NjQpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFza2lwRXZhbEFyZ0NoZWNrICYmICh0ICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoKHQgJiAyMDQ4MCkgPT09IDIwNDgwKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA5OSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGtpbmQgJiAoOCB8IDE2KSAmJiB0ID09PSAyNDE3MzYpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDk3KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29udGV4dCAmICg0MTk0MzA0IHwgMjA0OCkgJiYgdCA9PT0gMjA5MDA1KSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA5NSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAoMjA5NzE1MiB8IDEwMjQpICYmIHQgPT09IDI0MTc3MCkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTQsICd5aWVsZCcpO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25OYW1lKHBhcnNlciwgY29udGV4dCwgdCkge1xyXG4gICAgICBpZiAoY29udGV4dCAmIDEwMjQpIHtcclxuICAgICAgICAgIGlmICgodCAmIDM2ODY0KSA9PT0gMzY4NjQpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCh0ICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0ID09PSAxMTkpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA5Mik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodCA9PT0gMTE4KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICgodCAmIDIwNDgwKSA9PT0gMjA0ODApIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDk5KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29udGV4dCAmICg0MTk0MzA0IHwgMjA0OCkgJiYgdCA9PT0gMjA5MDA1KSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA5NSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAoMjA5NzE1MiB8IDEwMjQpICYmIHQgPT09IDI0MTc3MCkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTQsICd5aWVsZCcpO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHBhcnNlciwgY29udGV4dCwgdCkge1xyXG4gICAgICBpZiAodCA9PT0gMjA5MDA1KSB7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmICg0MTk0MzA0IHwgMjA0OCkpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTUpO1xyXG4gICAgICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSB8PSAxMjg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHQgPT09IDI0MTc3MCAmJiBjb250ZXh0ICYgMjA5NzE1MilcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDk0LCAneWllbGQnKTtcclxuICAgICAgcmV0dXJuICgodCAmIDIwNDgwKSA9PT0gMjA0ODAgfHxcclxuICAgICAgICAgICh0ICYgMzY4NjQpID09PSAzNjg2NCB8fFxyXG4gICAgICAgICAgdCA9PSAxMTkpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBpc1Byb3BlcnR5V2l0aFByaXZhdGVGaWVsZEtleShleHByKSB7XHJcbiAgICAgIHJldHVybiAhZXhwci5wcm9wZXJ0eSA/IGZhbHNlIDogZXhwci5wcm9wZXJ0eS50eXBlID09PSAnUHJpdmF0ZU5hbWUnO1xyXG4gIH1cclxuICBmdW5jdGlvbiBpc1ZhbGlkTGFiZWwocGFyc2VyLCBsYWJlbHMsIG5hbWUsIGlzSXRlcmF0aW9uU3RhdGVtZW50KSB7XHJcbiAgICAgIHdoaWxlIChsYWJlbHMpIHtcclxuICAgICAgICAgIGlmIChsYWJlbHNbJyQnICsgbmFtZV0pIHtcclxuICAgICAgICAgICAgICBpZiAoaXNJdGVyYXRpb25TdGF0ZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEzMyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXNJdGVyYXRpb25TdGF0ZW1lbnQgJiYgbGFiZWxzLmxvb3ApXHJcbiAgICAgICAgICAgICAgaXNJdGVyYXRpb25TdGF0ZW1lbnQgPSAwO1xyXG4gICAgICAgICAgbGFiZWxzID0gbGFiZWxzWyckJ107XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQW5kRGVjbGFyZUxhYmVsKHBhcnNlciwgbGFiZWxzLCBuYW1lKSB7XHJcbiAgICAgIGxldCBzZXQgPSBsYWJlbHM7XHJcbiAgICAgIHdoaWxlIChzZXQpIHtcclxuICAgICAgICAgIGlmIChzZXRbJyQnICsgbmFtZV0pXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTMyLCBuYW1lKTtcclxuICAgICAgICAgIHNldCA9IHNldFsnJCddO1xyXG4gICAgICB9XHJcbiAgICAgIGxhYmVsc1snJCcgKyBuYW1lXSA9IDE7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCBub2RlKSB7XHJcbiAgICAgIGlmIChjb250ZXh0ICYgMikge1xyXG4gICAgICAgICAgbm9kZS5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgbm9kZS5lbmQgPSBwYXJzZXIuc3RhcnRQb3M7XHJcbiAgICAgICAgICBub2RlLnJhbmdlID0gW3N0YXJ0LCBwYXJzZXIuc3RhcnRQb3NdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb250ZXh0ICYgNCkge1xyXG4gICAgICAgICAgbm9kZS5sb2MgPSB7XHJcbiAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgICAgICAgY29sdW1uXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBlbmQ6IHtcclxuICAgICAgICAgICAgICAgICAgbGluZTogcGFyc2VyLnN0YXJ0TGluZSxcclxuICAgICAgICAgICAgICAgICAgY29sdW1uOiBwYXJzZXIuc3RhcnRDb2x1bW5cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKHBhcnNlci5zb3VyY2VGaWxlKSB7XHJcbiAgICAgICAgICAgICAgbm9kZS5sb2Muc291cmNlID0gcGFyc2VyLnNvdXJjZUZpbGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzRXF1YWxUYWdOYW1lKGVsZW1lbnROYW1lKSB7XHJcbiAgICAgIHN3aXRjaCAoZWxlbWVudE5hbWUudHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAnSlNYSWRlbnRpZmllcic6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lLm5hbWU7XHJcbiAgICAgICAgICBjYXNlICdKU1hOYW1lc3BhY2VkTmFtZSc6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lLm5hbWVzcGFjZSArICc6JyArIGVsZW1lbnROYW1lLm5hbWU7XHJcbiAgICAgICAgICBjYXNlICdKU1hNZW1iZXJFeHByZXNzaW9uJzpcclxuICAgICAgICAgICAgICByZXR1cm4gaXNFcXVhbFRhZ05hbWUoZWxlbWVudE5hbWUub2JqZWN0KSArICcuJyArIGlzRXF1YWxUYWdOYW1lKGVsZW1lbnROYW1lLnByb3BlcnR5KTtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVBcnJvd0hlYWRQYXJzaW5nU2NvcGUocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSkge1xyXG4gICAgICBjb25zdCBzY29wZSA9IGFkZENoaWxkU2NvcGUoY3JlYXRlU2NvcGUoKSwgMTAyNCk7XHJcbiAgICAgIGFkZEJsb2NrTmFtZShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB2YWx1ZSwgMSwgMCk7XHJcbiAgICAgIHJldHVybiBzY29wZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVjb3JkU2NvcGVFcnJvcihwYXJzZXIsIHR5cGUsIC4uLnBhcmFtcykge1xyXG4gICAgICBjb25zdCB7IGluZGV4LCBsaW5lLCBjb2x1bW4gfSA9IHBhcnNlcjtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICBjb2x1bW5cclxuICAgICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlU2NvcGUoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwYXJlbnQ6IHZvaWQgMCxcclxuICAgICAgICAgIHR5cGU6IDJcclxuICAgICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkQ2hpbGRTY29wZShwYXJlbnQsIHR5cGUpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHBhcmVudCxcclxuICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICBzY29wZUVycm9yOiB2b2lkIDBcclxuICAgICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkVmFyT3JCbG9jayhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBuYW1lLCBraW5kLCBvcmlnaW4pIHtcclxuICAgICAgaWYgKGtpbmQgJiA0KSB7XHJcbiAgICAgICAgICBhZGRWYXJOYW1lKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG5hbWUsIGtpbmQpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYWRkQmxvY2tOYW1lKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG5hbWUsIGtpbmQsIG9yaWdpbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9yaWdpbiAmIDY0KSB7XHJcbiAgICAgICAgICBkZWNsYXJlVW5ib3VuZFZhcmlhYmxlKHBhcnNlciwgbmFtZSk7XHJcbiAgICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkQmxvY2tOYW1lKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG5hbWUsIGtpbmQsIG9yaWdpbikge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHNjb3BlWycjJyArIG5hbWVdO1xyXG4gICAgICBpZiAodmFsdWUgJiYgKHZhbHVlICYgMikgPT09IDApIHtcclxuICAgICAgICAgIGlmIChraW5kICYgMSkge1xyXG4gICAgICAgICAgICAgIHNjb3BlLnNjb3BlRXJyb3IgPSByZWNvcmRTY29wZUVycm9yKHBhcnNlciwgMTQwLCBuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQgJiAyNTYgJiZcclxuICAgICAgICAgICAgICB2YWx1ZSAmIDY0ICYmXHJcbiAgICAgICAgICAgICAgb3JpZ2luICYgMikgO1xyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTQwLCBuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoc2NvcGUudHlwZSAmIDEyOCAmJlxyXG4gICAgICAgICAgKHNjb3BlLnBhcmVudFsnIycgKyBuYW1lXSAmJiAoc2NvcGUucGFyZW50WycjJyArIG5hbWVdICYgMikgPT09IDApKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDAsIG5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzY29wZS50eXBlICYgMTAyNCAmJiB2YWx1ZSAmJiAodmFsdWUgJiAyKSA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKGtpbmQgJiAxKSB7XHJcbiAgICAgICAgICAgICAgc2NvcGUuc2NvcGVFcnJvciA9IHJlY29yZFNjb3BlRXJyb3IocGFyc2VyLCAxNDAsIG5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzY29wZS50eXBlICYgNjQpIHtcclxuICAgICAgICAgIGlmIChzY29wZS5wYXJlbnRbJyMnICsgbmFtZV0gJiA3NjgpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTUzLCBuYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBzY29wZVsnIycgKyBuYW1lXSA9IGtpbmQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGFkZFZhck5hbWUocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbmFtZSwga2luZCkge1xyXG4gICAgICBsZXQgY3VycmVudFNjb3BlID0gc2NvcGU7XHJcbiAgICAgIHdoaWxlIChjdXJyZW50U2NvcGUgJiYgKGN1cnJlbnRTY29wZS50eXBlICYgMjU2KSA9PT0gMCkge1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50U2NvcGVbJyMnICsgbmFtZV07XHJcbiAgICAgICAgICBpZiAodmFsdWUgJiAyNDgpIHtcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDI1NiAmJlxyXG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmIDEwMjQpID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICgoa2luZCAmIDEyOCAmJiB2YWx1ZSAmIDY4KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgKHZhbHVlICYgMTI4ICYmIGtpbmQgJiA2OCkpKSA7XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE0MCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSA9PT0gc2NvcGUpIHtcclxuICAgICAgICAgICAgICBpZiAodmFsdWUgJiAxICYmIGtpbmQgJiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS5zY29wZUVycm9yID0gcmVjb3JkU2NvcGVFcnJvcihwYXJzZXIsIDE0MCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHZhbHVlICYgKDUxMiB8IDI1NikpIHtcclxuICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgNTEyKSA9PT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmIDI1NikgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICAgY29udGV4dCAmIDEwMjQpIHtcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTQwLCBuYW1lKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJyZW50U2NvcGVbJyMnICsgbmFtZV0gPSBraW5kO1xyXG4gICAgICAgICAgY3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlLnBhcmVudDtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBkZWNsYXJlVW5ib3VuZFZhcmlhYmxlKHBhcnNlciwgbmFtZSkge1xyXG4gICAgICBpZiAocGFyc2VyLmV4cG9ydGVkTmFtZXMgIT09IHZvaWQgMCAmJiBuYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgaWYgKHBhcnNlci5leHBvcnRlZE5hbWVzWycjJyArIG5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTQxLCBuYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcnNlci5leHBvcnRlZE5hbWVzWycjJyArIG5hbWVdID0gMTtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBhZGRCaW5kaW5nVG9FeHBvcnRzKHBhcnNlciwgbmFtZSkge1xyXG4gICAgICBpZiAocGFyc2VyLmV4cG9ydGVkQmluZGluZ3MgIT09IHZvaWQgMCAmJiBuYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgcGFyc2VyLmV4cG9ydGVkQmluZGluZ3NbJyMnICsgbmFtZV0gPSAxO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHB1c2hDb21tZW50KGNvbnRleHQsIGFycmF5KSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB7XHJcbiAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgMikge1xyXG4gICAgICAgICAgICAgIGNvbW1lbnQuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgICBjb21tZW50LmVuZCA9IGVuZDtcclxuICAgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYXJyYXkucHVzaChjb21tZW50KTtcclxuICAgICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcHVzaFRva2VuKGNvbnRleHQsIGFycmF5KSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4sIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgIGNvbnN0IHRva2VucyA9IHtcclxuICAgICAgICAgICAgICB0b2tlblxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgNCkge1xyXG4gICAgICAgICAgICAgIHRva2Vucy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgIHRva2Vucy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhcnJheS5wdXNoKHRva2Vucyk7XHJcbiAgICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKGNvbnRleHQsIHQpIHtcclxuICAgICAgaWYgKGNvbnRleHQgJiAoMTAyNCB8IDIwOTcxNTIpKSB7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDIwNDggJiYgdCA9PT0gMjA5MDA1KVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgMjA5NzE1MiAmJiB0ID09PSAyNDE3NzApXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuICh0ICYgMTQzMzYwKSA9PT0gMTQzMzYwIHx8ICh0ICYgMTIyODgpID09PSAxMjI4ODtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gKCh0ICYgMTQzMzYwKSA9PT0gMTQzMzYwIHx8XHJcbiAgICAgICAgICAodCAmIDEyMjg4KSA9PT0gMTIyODggfHxcclxuICAgICAgICAgICh0ICYgMzY4NjQpID09PSAzNjg2NCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNsYXNzaWZ5SWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHQsIGlzQXJyb3cpIHtcclxuICAgICAgaWYgKCh0ICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDEwMjQpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgICAgIGlmIChpc0Fycm93KVxyXG4gICAgICAgICAgICAgIHBhcnNlci5mbGFncyB8PSA1MTI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc1ZhbGlkSWRlbnRpZmllcihjb250ZXh0LCB0KSlcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDApO1xyXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGUoc291cmNlLCBzb3VyY2VGaWxlLCBvbkNvbW1lbnQsIG9uVG9rZW4pIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgIGZsYWdzOiAwLFxyXG4gICAgICAgICAgaW5kZXg6IDAsXHJcbiAgICAgICAgICBsaW5lOiAxLFxyXG4gICAgICAgICAgY29sdW1uOiAwLFxyXG4gICAgICAgICAgc3RhcnRQb3M6IDAsXHJcbiAgICAgICAgICBlbmQ6IHNvdXJjZS5sZW5ndGgsXHJcbiAgICAgICAgICB0b2tlblBvczogMCxcclxuICAgICAgICAgIHN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgY29sUG9zOiAwLFxyXG4gICAgICAgICAgbGluZVBvczogMCxcclxuICAgICAgICAgIHN0YXJ0TGluZTogMSxcclxuICAgICAgICAgIHNvdXJjZUZpbGUsXHJcbiAgICAgICAgICB0b2tlblZhbHVlOiAnJyxcclxuICAgICAgICAgIHRva2VuOiAxMDQ4NTc2LFxyXG4gICAgICAgICAgdG9rZW5SYXc6ICcnLFxyXG4gICAgICAgICAgdG9rZW5SZWdFeHA6IHZvaWQgMCxcclxuICAgICAgICAgIGN1cnJlbnRDaGFyOiBzb3VyY2UuY2hhckNvZGVBdCgwKSxcclxuICAgICAgICAgIGV4cG9ydGVkTmFtZXM6IFtdLFxyXG4gICAgICAgICAgZXhwb3J0ZWRCaW5kaW5nczogW10sXHJcbiAgICAgICAgICBhc3NpZ25hYmxlOiAxLFxyXG4gICAgICAgICAgZGVzdHJ1Y3RpYmxlOiAwLFxyXG4gICAgICAgICAgb25Db21tZW50LFxyXG4gICAgICAgICAgb25Ub2tlblxyXG4gICAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZShzb3VyY2UsIG9wdGlvbnMsIGNvbnRleHQpIHtcclxuICAgICAgbGV0IHNvdXJjZUZpbGUgPSAnJztcclxuICAgICAgbGV0IG9uQ29tbWVudDtcclxuICAgICAgbGV0IG9uVG9rZW47XHJcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcclxuICAgICAgICAgIGlmIChvcHRpb25zLm1vZHVsZSlcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDIwNDggfCAxMDI0O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMubmV4dClcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDE7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5sb2MpXHJcbiAgICAgICAgICAgICAgY29udGV4dCB8PSA0O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxyXG4gICAgICAgICAgICAgIGNvbnRleHQgfD0gMjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleUluUGF0dGVybilcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IC0yMTQ3NDgzNjQ4O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMubGV4aWNhbClcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDY0O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMud2ViY29tcGF0KVxyXG4gICAgICAgICAgICAgIGNvbnRleHQgfD0gMjU2O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcylcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDggfCA1MTI7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5nbG9iYWxSZXR1cm4pXHJcbiAgICAgICAgICAgICAgY29udGV4dCB8PSAzMjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLnJhdylcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDUxMjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLnByZXNlcnZlUGFyZW5zKVxyXG4gICAgICAgICAgICAgIGNvbnRleHQgfD0gMTI4O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW1wbGllZFN0cmljdClcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDEwMjQ7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5qc3gpXHJcbiAgICAgICAgICAgICAgY29udGV4dCB8PSAxNjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLmlkZW50aWZpZXJQYXR0ZXJuKVxyXG4gICAgICAgICAgICAgIGNvbnRleHQgfD0gMjY4NDM1NDU2O1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3BlY0RldmlhdGlvbilcclxuICAgICAgICAgICAgICBjb250ZXh0IHw9IDUzNjg3MDkxMjtcclxuICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZSlcclxuICAgICAgICAgICAgICBzb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2U7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5vbkNvbW1lbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIG9uQ29tbWVudCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpID8gcHVzaENvbW1lbnQoY29udGV4dCwgb3B0aW9ucy5vbkNvbW1lbnQpIDogb3B0aW9ucy5vbkNvbW1lbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5vblRva2VuICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICBvblRva2VuID0gQXJyYXkuaXNBcnJheShvcHRpb25zLm9uVG9rZW4pID8gcHVzaFRva2VuKGNvbnRleHQsIG9wdGlvbnMub25Ub2tlbikgOiBvcHRpb25zLm9uVG9rZW47XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcGFyc2VyID0gY3JlYXRlKHNvdXJjZSwgc291cmNlRmlsZSwgb25Db21tZW50LCBvblRva2VuKTtcclxuICAgICAgaWYgKGNvbnRleHQgJiAxKVxyXG4gICAgICAgICAgc2tpcEhhc2hCYW5nKHBhcnNlcik7XHJcbiAgICAgIGNvbnN0IHNjb3BlID0gY29udGV4dCAmIDY0ID8gY3JlYXRlU2NvcGUoKSA6IHZvaWQgMDtcclxuICAgICAgbGV0IGJvZHkgPSBbXTtcclxuICAgICAgbGV0IHNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuICAgICAgaWYgKGNvbnRleHQgJiAyMDQ4KSB7XHJcbiAgICAgICAgICBzb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcbiAgICAgICAgICBib2R5ID0gcGFyc2VNb2R1bGVJdGVtTGlzdChwYXJzZXIsIGNvbnRleHQgfCA4MTkyLCBzY29wZSk7XHJcbiAgICAgICAgICBpZiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZXIuZXhwb3J0ZWRCaW5kaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoa2V5WzBdID09PSAnIycgJiYgIXNjb3BlW2tleV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDIsIGtleS5zbGljZSgxKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50TGlzdChwYXJzZXIsIGNvbnRleHQgfCA4MTkyLCBzY29wZSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgbm9kZSA9IHtcclxuICAgICAgICAgIHR5cGU6ICdQcm9ncmFtJyxcclxuICAgICAgICAgIHNvdXJjZVR5cGUsXHJcbiAgICAgICAgICBib2R5XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjb250ZXh0ICYgMikge1xyXG4gICAgICAgICAgbm9kZS5zdGFydCA9IDA7XHJcbiAgICAgICAgICBub2RlLmVuZCA9IHNvdXJjZS5sZW5ndGg7XHJcbiAgICAgICAgICBub2RlLnJhbmdlID0gWzAsIHNvdXJjZS5sZW5ndGhdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb250ZXh0ICYgNCkge1xyXG4gICAgICAgICAgbm9kZS5sb2MgPSB7XHJcbiAgICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAwIH0sXHJcbiAgICAgICAgICAgICAgZW5kOiB7IGxpbmU6IHBhcnNlci5saW5lLCBjb2x1bW46IHBhcnNlci5jb2x1bW4gfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChwYXJzZXIuc291cmNlRmlsZSlcclxuICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSBzb3VyY2VGaWxlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3QocGFyc2VyLCBjb250ZXh0LCBzY29wZSkge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjggfCAxMDczNzQxODI0KTtcclxuICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLnRva2VuID09PSAxMzQyODMyNjcpIHtcclxuICAgICAgICAgIGNvbnN0IHsgaW5kZXgsIHRva2VuUG9zLCB0b2tlblZhbHVlLCBsaW5lUG9zLCBjb2xQb3MsIHRva2VuIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICBjb25zdCBleHByID0gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICBpZiAoaXNWYWxpZFN0cmljdE1vZGUocGFyc2VyLCBpbmRleCwgdG9rZW5Qb3MsIHRva2VuVmFsdWUpKVxyXG4gICAgICAgICAgICAgIGNvbnRleHQgfD0gMTAyNDtcclxuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChwYXJzZURpcmVjdGl2ZShwYXJzZXIsIGNvbnRleHQsIGV4cHIsIHRva2VuLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKSk7XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiAhPT0gMTA0ODU3Nikge1xyXG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgNCwge30sIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3RhdGVtZW50cztcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VNb2R1bGVJdGVtTGlzdChwYXJzZXIsIGNvbnRleHQsIHNjb3BlKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcclxuICAgICAgaWYgKGNvbnRleHQgJiA4KSB7XHJcbiAgICAgICAgICB3aGlsZSAocGFyc2VyLnRva2VuID09PSAxMzQyODMyNjcpIHtcclxuICAgICAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHRva2VuIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlRGlyZWN0aXZlKHBhcnNlciwgY29udGV4dCwgcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCksIHRva2VuLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiAhPT0gMTA0ODU3Nikge1xyXG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlTW9kdWxlSXRlbShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTW9kdWxlSXRlbShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIHN3aXRjaCAocGFyc2VyLnRva2VuKSB7XHJcbiAgICAgICAgICBjYXNlIDIwNTYzOlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSA4NjEwNTpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnREZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMTMwOlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZURlY29yYXRvcnMocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgNCwge30sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgc3dpdGNoIChwYXJzZXIudG9rZW4pIHtcclxuICAgICAgICAgIGNhc2UgODYxMDM6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBvcmlnaW4sIDEsIDAsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSAxMzA6XHJcbiAgICAgICAgICBjYXNlIDg2MDkzOlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUNsYXNzRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDg2MDg5OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAxNiwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDI0MTczNjpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VMZXRJZGVudE9yVmFyRGVjbGFyYXRpb25TdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMjA1NjM6XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTAwLCAnZXhwb3J0Jyk7XHJcbiAgICAgICAgICBjYXNlIDg2MTA1OlxyXG4gICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNjcxNzQ0MTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnRDYWxsRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgY2FzZSA2NzEwODg3NzpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUltcG9ydE1ldGFEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTAwLCAnaW1wb3J0Jyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSAxNDM0Njg6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXN5bmNBcnJvd09yQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG9yaWdpbiwgbGFiZWxzLCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG9yaWdpbiwgbGFiZWxzLCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBvcmlnaW4sIGxhYmVscywgYWxsb3dGdW5jRGVjbCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBzd2l0Y2ggKHBhcnNlci50b2tlbikge1xyXG4gICAgICAgICAgY2FzZSA4NjA4NzpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VWYXJpYWJsZVN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMjA1NzE6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmV0dXJuU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDIwNTY4OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUlmU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGxhYmVscywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDIwNTY2OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvclN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSAyMDU2MTpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEb1doaWxlU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGxhYmVscywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDIwNTc3OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVdoaWxlU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGxhYmVscywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDg2MTA5OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVN3aXRjaFN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSAxMDc0NzkwNDE3OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUVtcHR5U3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDIxNjI3MDA6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmxvY2socGFyc2VyLCBjb250ZXh0LCBzY29wZSA/IGFkZENoaWxkU2NvcGUoc2NvcGUsIDIpIDogc2NvcGUsIGxhYmVscywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDg2MTExOlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVRocm93U3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDIwNTU0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMjA1NTg6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29udGludWVTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSAyMDU3NjpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcnlTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMjA1Nzg6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSAyMDU1OTpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSAxNDM0Njg6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXN5bmNBcnJvd09yQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG9yaWdpbiwgbGFiZWxzLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMjA1NTY6XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTU2KTtcclxuICAgICAgICAgIGNhc2UgMjA1NjU6XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTU3KTtcclxuICAgICAgICAgIGNhc2UgODYxMDM6XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgY29udGV4dCAmIDEwMjRcclxuICAgICAgICAgICAgICAgICAgPyA3M1xyXG4gICAgICAgICAgICAgICAgICA6IChjb250ZXh0ICYgMjU2KSA8IDFcclxuICAgICAgICAgICAgICAgICAgICAgID8gNzVcclxuICAgICAgICAgICAgICAgICAgICAgIDogNzQpO1xyXG4gICAgICAgICAgY2FzZSA4NjA5MzpcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA3Nik7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25PckxhYmVsbGVkU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG9yaWdpbiwgbGFiZWxzLCBhbGxvd0Z1bmNEZWNsLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25PckxhYmVsbGVkU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG9yaWdpbiwgbGFiZWxzLCBhbGxvd0Z1bmNEZWNsLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSwgdG9rZW4gfSA9IHBhcnNlcjtcclxuICAgICAgbGV0IGV4cHI7XHJcbiAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgIGNhc2UgMjQxNzM2OlxyXG4gICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDgyKTtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSA2OTI3MTU3MSlcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgODEpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDIsIDAsIDEsIDAsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0b2tlbiAmIDE0MzM2MCAmJiBwYXJzZXIudG9rZW4gPT09IDIxKSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VMYWJlbGxlZFN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBvcmlnaW4sIGxhYmVscywgdG9rZW5WYWx1ZSwgZXhwciwgdG9rZW4sIGFsbG93RnVuY0RlY2wsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGV4cHIgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGV4cHIsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGV4cHIpO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICBleHByID0gcGFyc2VTZXF1ZW5jZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAwLCBzdGFydCwgbGluZSwgY29sdW1uLCBleHByKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgZXhwciwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQmxvY2socGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBbXTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjE2MjcwMCk7XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gIT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgIGJvZHkucHVzaChwYXJzZVN0YXRlbWVudExpc3RJdGVtKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDIsIHsgJDogbGFiZWxzIH0sIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxMDc0NzkwNDE1KTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnQmxvY2tTdGF0ZW1lbnQnLFxyXG4gICAgICAgICAgYm9keVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmICgoY29udGV4dCAmIDMyKSA8IDEgJiYgY29udGV4dCAmIDgxOTIpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA4OSk7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIGNvbnN0IGFyZ3VtZW50ID0gcGFyc2VyLmZsYWdzICYgMSB8fCBwYXJzZXIudG9rZW4gJiAxMDQ4NTc2XHJcbiAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgIDogcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmUsIHBhcnNlci5jb2x1bW4pO1xyXG4gICAgICBtYXRjaE9ySW5zZXJ0U2VtaWNvbG9uKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnUmV0dXJuU3RhdGVtZW50JyxcclxuICAgICAgICAgIGFyZ3VtZW50XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBleHByZXNzaW9uLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcclxuICAgICAgICAgIGV4cHJlc3Npb25cclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBsYWJlbHMsIHZhbHVlLCBleHByLCB0b2tlbiwgYWxsb3dGdW5jRGVjbCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICB2YWxpZGF0ZUJpbmRpbmdJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCwgdG9rZW4sIDEpO1xyXG4gICAgICB2YWxpZGF0ZUFuZERlY2xhcmVMYWJlbChwYXJzZXIsIGxhYmVscywgdmFsdWUpO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCBib2R5ID0gYWxsb3dGdW5jRGVjbCAmJlxyXG4gICAgICAgICAgKGNvbnRleHQgJiAxMDI0KSA8IDEgJiZcclxuICAgICAgICAgIGNvbnRleHQgJiAyNTYgJiZcclxuICAgICAgICAgIHBhcnNlci50b2tlbiA9PT0gODYxMDNcclxuICAgICAgICAgID8gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgYWRkQ2hpbGRTY29wZShzY29wZSwgMiksIG9yaWdpbiwgMCwgMCwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcylcclxuICAgICAgICAgIDogcGFyc2VTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBsYWJlbHMsIGFsbG93RnVuY0RlY2wsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdMYWJlbGVkU3RhdGVtZW50JyxcclxuICAgICAgICAgIGxhYmVsOiBleHByLFxyXG4gICAgICAgICAgYm9keVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VBc3luY0Fycm93T3JBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBsYWJlbHMsIGFsbG93RnVuY0RlY2wsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5WYWx1ZSB9ID0gcGFyc2VyO1xyXG4gICAgICBsZXQgZXhwciA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAyMSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBsYWJlbHMsIHRva2VuVmFsdWUsIGV4cHIsIHRva2VuLCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBhc3luY05ld0xpbmUgPSBwYXJzZXIuZmxhZ3MgJiAxO1xyXG4gICAgICBpZiAoIWFzeW5jTmV3TGluZSkge1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gODYxMDMpIHtcclxuICAgICAgICAgICAgICBpZiAoIWFsbG93RnVuY0RlY2wpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExOSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBvcmlnaW4sIDEsIDAsIDEsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAxNDMzNjApID09PSAxNDMzNjApIHtcclxuICAgICAgICAgICAgICBleHByID0gcGFyc2VBc3luY0Fycm93QWZ0ZXJJZGVudChwYXJzZXIsIGNvbnRleHQsIDEsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIpXHJcbiAgICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVNlcXVlbmNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGV4cHIpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBleHByLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSA2NzE3NDQxMSkge1xyXG4gICAgICAgICAgZXhwciA9IHBhcnNlQXN5bmNBcnJvd09yQ2FsbEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByLCAxLCAxLCAwLCBhc3luY05ld0xpbmUsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTApIHtcclxuICAgICAgICAgICAgICBjbGFzc2lmeUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCB0b2tlbiwgMSk7XHJcbiAgICAgICAgICAgICAgZXhwciA9IHBhcnNlQXJyb3dGcm9tSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblZhbHVlLCBleHByLCAwLCAxLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMTtcclxuICAgICAgfVxyXG4gICAgICBleHByID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MilcclxuICAgICAgICAgIGV4cHIgPSBwYXJzZVNlcXVlbmNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGV4cHIpO1xyXG4gICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGV4cHIpO1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBleHByLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUocGFyc2VyLCBjb250ZXh0LCBleHByZXNzaW9uLCB0b2tlbiwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdCB7IHRva2VuUmF3IH0gPSBwYXJzZXI7XHJcbiAgICAgIGlmICh0b2tlbiAhPT0gMTA3NDc5MDQxNykge1xyXG4gICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwcmVzc2lvbiwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE3KSB7XHJcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAwLCAwLCBzdGFydCwgbGluZSwgY29sdW1uLCBleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZVNlcXVlbmNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb250ZXh0ICYgOFxyXG4gICAgICAgICAgPyBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcclxuICAgICAgICAgICAgICBleHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgIGRpcmVjdGl2ZTogdG9rZW5SYXcuc2xpY2UoMSwgLTEpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgOiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcclxuICAgICAgICAgICAgICBleHByZXNzaW9uXHJcbiAgICAgICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VFbXB0eVN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnRW1wdHlTdGF0ZW1lbnQnXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVRocm93U3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBpZiAocGFyc2VyLmZsYWdzICYgMSlcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDg3KTtcclxuICAgICAgY29uc3QgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb25zKHBhcnNlciwgY29udGV4dCwgMCwgMSwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdUaHJvd1N0YXRlbWVudCcsXHJcbiAgICAgICAgICBhcmd1bWVudFxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDY3MTc0NDExKTtcclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAxO1xyXG4gICAgICBjb25zdCB0ZXN0ID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmUsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxNik7XHJcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBwYXJzZUNvbnNlcXVlbnRPckFsdGVybmF0aXZlKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGxhYmVscywgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgIGxldCBhbHRlcm5hdGUgPSBudWxsO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAyMDU2Mikge1xyXG4gICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlQ29uc2VxdWVudE9yQWx0ZXJuYXRpdmUocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdJZlN0YXRlbWVudCcsXHJcbiAgICAgICAgICB0ZXN0LFxyXG4gICAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICAgIGFsdGVybmF0ZVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VDb25zZXF1ZW50T3JBbHRlcm5hdGl2ZShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgcmV0dXJuIGNvbnRleHQgJiAxMDI0IHx8XHJcbiAgICAgICAgICAoY29udGV4dCAmIDI1NikgPCAxIHx8XHJcbiAgICAgICAgICBwYXJzZXIudG9rZW4gIT09IDg2MTAzXHJcbiAgICAgICAgICA/IHBhcnNlU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDAsIHsgJDogbGFiZWxzIH0sIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpXHJcbiAgICAgICAgICA6IHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIGFkZENoaWxkU2NvcGUoc2NvcGUsIDIpLCAwLCAwLCAwLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCA2NzE3NDQxMSk7XHJcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IHBhcnNlRXhwcmVzc2lvbnMocGFyc2VyLCBjb250ZXh0LCAwLCAxLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDE2KTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDIxNjI3MDApO1xyXG4gICAgICBjb25zdCBjYXNlcyA9IFtdO1xyXG4gICAgICBsZXQgc2VlbkRlZmF1bHQgPSAwO1xyXG4gICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAgICBzY29wZSA9IGFkZENoaWxkU2NvcGUoc2NvcGUsIDgpO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE1KSB7XHJcbiAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgIGxldCB0ZXN0ID0gbnVsbDtcclxuICAgICAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBbXTtcclxuICAgICAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMDU1NSkpIHtcclxuICAgICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjA1NjApO1xyXG4gICAgICAgICAgICAgIGlmIChzZWVuRGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgODYpO1xyXG4gICAgICAgICAgICAgIHNlZW5EZWZhdWx0ID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDIxKTtcclxuICAgICAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gIT09IDIwNTU1ICYmXHJcbiAgICAgICAgICAgICAgcGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE1ICYmXHJcbiAgICAgICAgICAgICAgcGFyc2VyLnRva2VuICE9PSAyMDU2MCkge1xyXG4gICAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaChwYXJzZVN0YXRlbWVudExpc3RJdGVtKHBhcnNlciwgY29udGV4dCB8IDQwOTYsIHNjb3BlLCAyLCB7XHJcbiAgICAgICAgICAgICAgICAgICQ6IGxhYmVsc1xyXG4gICAgICAgICAgICAgIH0sIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2VzLnB1c2goZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgICAgICB0eXBlOiAnU3dpdGNoQ2FzZScsXHJcbiAgICAgICAgICAgICAgdGVzdCxcclxuICAgICAgICAgICAgICBjb25zZXF1ZW50XHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTA3NDc5MDQxNSk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ1N3aXRjaFN0YXRlbWVudCcsXHJcbiAgICAgICAgICBkaXNjcmltaW5hbnQsXHJcbiAgICAgICAgICBjYXNlc1xyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDY3MTc0NDExKTtcclxuICAgICAgY29uc3QgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbnMocGFyc2VyLCBjb250ZXh0LCAwLCAxLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTYpO1xyXG4gICAgICBjb25zdCBib2R5ID0gcGFyc2VJdGVyYXRpb25TdGF0ZW1lbnRCb2R5KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGxhYmVscyk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ1doaWxlU3RhdGVtZW50JyxcclxuICAgICAgICAgIHRlc3QsXHJcbiAgICAgICAgICBib2R5XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUl0ZXJhdGlvblN0YXRlbWVudEJvZHkocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzKSB7XHJcbiAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudChwYXJzZXIsICgoY29udGV4dCB8IDEzNDIxNzcyOCkgXiAxMzQyMTc3MjgpIHwgMTMxMDcyLCBzY29wZSwgMCwgeyBsb29wOiAxLCAkOiBsYWJlbHMgfSwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQ29udGludWVTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgaWYgKChjb250ZXh0ICYgMTMxMDcyKSA8IDEpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA2NSk7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBsZXQgbGFiZWwgPSBudWxsO1xyXG4gICAgICBpZiAoKHBhcnNlci5mbGFncyAmIDEpIDwgMSAmJiBwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgbGFiZWwgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDApO1xyXG4gICAgICAgICAgaWYgKCFpc1ZhbGlkTGFiZWwocGFyc2VyLCBsYWJlbHMsIHRva2VuVmFsdWUsIDEpKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEzNCwgdG9rZW5WYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0NvbnRpbnVlU3RhdGVtZW50JyxcclxuICAgICAgICAgIGxhYmVsXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUJyZWFrU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIGxldCBsYWJlbCA9IG51bGw7XHJcbiAgICAgIGlmICgocGFyc2VyLmZsYWdzICYgMSkgPCAxICYmIHBhcnNlci50b2tlbiAmIDE0MzM2MCkge1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlblZhbHVlIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICBsYWJlbCA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMCk7XHJcbiAgICAgICAgICBpZiAoIWlzVmFsaWRMYWJlbChwYXJzZXIsIGxhYmVscywgdG9rZW5WYWx1ZSwgMCkpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTM0LCB0b2tlblZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICgoY29udGV4dCAmICg0MDk2IHwgMTMxMDcyKSkgPCAxKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA2Nik7XHJcbiAgICAgIH1cclxuICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0JyZWFrU3RhdGVtZW50JyxcclxuICAgICAgICAgIGxhYmVsXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBpZiAoY29udGV4dCAmIDEwMjQpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA4OCk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDY3MTc0NDExKTtcclxuICAgICAgY29uc3Qgb2JqZWN0ID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxNik7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBwYXJzZVN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAyLCBsYWJlbHMsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdXaXRoU3RhdGVtZW50JyxcclxuICAgICAgICAgIG9iamVjdCxcclxuICAgICAgICAgIGJvZHlcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdEZWJ1Z2dlclN0YXRlbWVudCdcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGxhYmVscywgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCBmaXJzdFNjb3BlID0gc2NvcGUgPyBhZGRDaGlsZFNjb3BlKHNjb3BlLCAzMikgOiB2b2lkIDA7XHJcbiAgICAgIGNvbnN0IGJsb2NrID0gcGFyc2VCbG9jayhwYXJzZXIsIGNvbnRleHQsIGZpcnN0U2NvcGUsIHsgJDogbGFiZWxzIH0sIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgY29uc3QgaGFuZGxlciA9IGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDIwNTU2KVxyXG4gICAgICAgICAgPyBwYXJzZUNhdGNoQmxvY2socGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKVxyXG4gICAgICAgICAgOiBudWxsO1xyXG4gICAgICBsZXQgZmluYWxpemVyID0gbnVsbDtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMjA1NjUpIHtcclxuICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICBjb25zdCBmaW5hbGl6ZXJTY29wZSA9IGZpcnN0U2NvcGUgPyBhZGRDaGlsZFNjb3BlKHNjb3BlLCA0KSA6IHZvaWQgMDtcclxuICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2socGFyc2VyLCBjb250ZXh0LCBmaW5hbGl6ZXJTY29wZSwgeyAkOiBsYWJlbHMgfSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFoYW5kbGVyICYmICFmaW5hbGl6ZXIpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDg1KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdUcnlTdGF0ZW1lbnQnLFxyXG4gICAgICAgICAgYmxvY2ssXHJcbiAgICAgICAgICBoYW5kbGVyLFxyXG4gICAgICAgICAgZmluYWxpemVyXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUNhdGNoQmxvY2socGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGxldCBwYXJhbSA9IG51bGw7XHJcbiAgICAgIGxldCBhZGRpdGlvbmFsU2NvcGUgPSBzY29wZTtcclxuICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCA2NzE3NDQxMSkpIHtcclxuICAgICAgICAgIGlmIChzY29wZSlcclxuICAgICAgICAgICAgICBzY29wZSA9IGFkZENoaWxkU2NvcGUoc2NvcGUsIDQpO1xyXG4gICAgICAgICAgcGFyYW0gPSBwYXJzZUJpbmRpbmdQYXR0ZXJuKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIChwYXJzZXIudG9rZW4gJiAyMDk3MTUyKSA9PT0gMjA5NzE1MlxyXG4gICAgICAgICAgICAgID8gMjU2XHJcbiAgICAgICAgICAgICAgOiA1MTIsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0Mikge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDgzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3NzkzNjE1Nykge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDg0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDE2KTtcclxuICAgICAgICAgIGlmIChzY29wZSlcclxuICAgICAgICAgICAgICBhZGRpdGlvbmFsU2NvcGUgPSBhZGRDaGlsZFNjb3BlKHNjb3BlLCA2NCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYm9keSA9IHBhcnNlQmxvY2socGFyc2VyLCBjb250ZXh0LCBhZGRpdGlvbmFsU2NvcGUsIHsgJDogbGFiZWxzIH0sIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdDYXRjaENsYXVzZScsXHJcbiAgICAgICAgICBwYXJhbSxcclxuICAgICAgICAgIGJvZHlcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZVN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgY29uc3QgYm9keSA9IHBhcnNlSXRlcmF0aW9uU3RhdGVtZW50Qm9keShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMjA1NzcpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCA2NzE3NDQxMSk7XHJcbiAgICAgIGNvbnN0IHRlc3QgPSBwYXJzZUV4cHJlc3Npb25zKHBhcnNlciwgY29udGV4dCwgMCwgMSwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDE2KTtcclxuICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgY29udGV4dCAmIDUzNjg3MDkxMik7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxyXG4gICAgICAgICAgYm9keSxcclxuICAgICAgICAgIHRlc3RcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTGV0SWRlbnRPclZhckRlY2xhcmF0aW9uU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIG9yaWdpbiwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdCB7IHRva2VuLCB0b2tlblZhbHVlIH0gPSBwYXJzZXI7XHJcbiAgICAgIGxldCBleHByID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAoMTQzMzYwIHwgMjA5NzE1MikpIHtcclxuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgOCwgMCk7XHJcbiAgICAgICAgICBtYXRjaE9ySW5zZXJ0U2VtaWNvbG9uKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuICAgICAgICAgICAgICBraW5kOiAnbGV0JyxcclxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbnNcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMTtcclxuICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgODIpO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAyMSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCB7fSwgdG9rZW5WYWx1ZSwgZXhwciwgdG9rZW4sIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwKSB7XHJcbiAgICAgICAgICBsZXQgc2NvcGUgPSB2b2lkIDA7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDY0KVxyXG4gICAgICAgICAgICAgIHNjb3BlID0gY3JlYXRlQXJyb3dIZWFkUGFyc2luZ1Njb3BlKHBhcnNlciwgY29udGV4dCwgdG9rZW5WYWx1ZSk7XHJcbiAgICAgICAgICBwYXJzZXIuZmxhZ3MgPSAocGFyc2VyLmZsYWdzIHwgMTI4KSBeIDEyODtcclxuICAgICAgICAgIGV4cHIgPSBwYXJzZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIFtleHByXSwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBleHByID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgZXhwcik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0Mikge1xyXG4gICAgICAgICAgZXhwciA9IHBhcnNlU2VxdWVuY2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgZXhwcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIGV4cHIsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBraW5kLCBvcmlnaW4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCwgb3JpZ2luKTtcclxuICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxyXG4gICAgICAgICAga2luZDoga2luZCAmIDggPyAnbGV0JyA6ICdjb25zdCcsXHJcbiAgICAgICAgICBkZWNsYXJhdGlvbnNcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDQsIG9yaWdpbik7XHJcbiAgICAgIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuICAgICAgICAgIGtpbmQ6ICd2YXInLFxyXG4gICAgICAgICAgZGVjbGFyYXRpb25zXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGtpbmQsIG9yaWdpbikge1xyXG4gICAgICBsZXQgYmluZGluZ0NvdW50ID0gMTtcclxuICAgICAgY29uc3QgbGlzdCA9IFtwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCwgb3JpZ2luKV07XHJcbiAgICAgIHdoaWxlIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCwgMTA3Mzc0MTg0MikpIHtcclxuICAgICAgICAgIGJpbmRpbmdDb3VudCsrO1xyXG4gICAgICAgICAgbGlzdC5wdXNoKHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBraW5kLCBvcmlnaW4pKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmluZGluZ0NvdW50ID4gMSAmJiBvcmlnaW4gJiAzMiAmJiBwYXJzZXIudG9rZW4gJiAyNjIxNDQpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDU4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaXN0O1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCwgb3JpZ2luKSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgbGV0IGluaXQgPSBudWxsO1xyXG4gICAgICBjb25zdCBpZCA9IHBhcnNlQmluZGluZ1BhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCwgb3JpZ2luLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3NzkzNjE1Nykge1xyXG4gICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgIGluaXQgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgIGlmIChvcmlnaW4gJiAzMiB8fCAodG9rZW4gJiAyMDk3MTUyKSA8IDEpIHtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAyNzQ1NDYgfHxcclxuICAgICAgICAgICAgICAgICAgKHBhcnNlci50b2tlbiA9PT0gODczODg2NSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgKHRva2VuICYgMjA5NzE1MiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChraW5kICYgNCkgPCAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiAyNTYpIDwgMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgJiAxMDI0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0TWVzc2FnZUF0KHRva2VuUG9zLCBwYXJzZXIubGluZSwgcGFyc2VyLmluZGV4IC0gMywgNTcsIHBhcnNlci50b2tlbiA9PT0gMjc0NTQ2ID8gJ29mJyA6ICdpbicpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICgoa2luZCAmIDE2IHx8ICh0b2tlbiAmIDIwOTcxNTIpID4gMCkgJiZcclxuICAgICAgICAgIChwYXJzZXIudG9rZW4gJiAyNjIxNDQpICE9PSAyNjIxNDQpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDU2LCBraW5kICYgMTYgPyAnY29uc3QnIDogJ2Rlc3RydWN0dXJpbmcnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxyXG4gICAgICAgICAgaWQsXHJcbiAgICAgICAgICBpbml0XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN0IGZvckF3YWl0ID0gKGNvbnRleHQgJiA0MTk0MzA0KSA+IDAgJiYgY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQsIDIwOTAwNSk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDY3MTc0NDExKTtcclxuICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgc2NvcGUgPSBhZGRDaGlsZFNjb3BlKHNjb3BlLCAxKTtcclxuICAgICAgbGV0IHRlc3QgPSBudWxsO1xyXG4gICAgICBsZXQgdXBkYXRlID0gbnVsbDtcclxuICAgICAgbGV0IGRlc3RydWN0aWJsZSA9IDA7XHJcbiAgICAgIGxldCBpbml0ID0gbnVsbDtcclxuICAgICAgbGV0IGlzVmFyRGVjbCA9IHBhcnNlci50b2tlbiA9PT0gODYwODcgfHwgcGFyc2VyLnRva2VuID09PSAyNDE3MzYgfHwgcGFyc2VyLnRva2VuID09PSA4NjA4OTtcclxuICAgICAgbGV0IHJpZ2h0O1xyXG4gICAgICBjb25zdCB7IHRva2VuLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgIGlmIChpc1ZhckRlY2wpIHtcclxuICAgICAgICAgIGlmICh0b2tlbiA9PT0gMjQxNzM2KSB7XHJcbiAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAoMTQzMzYwIHwgMjA5NzE1MikpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gODczODg2NSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDY0KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnbGV0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QocGFyc2VyLCBjb250ZXh0IHwgMTM0MjE3NzI4LCBzY29wZSwgOCwgMzIpXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQgJiAxMDI0KSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDY0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGlzVmFyRGVjbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIGluaXQgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluaXQsIDAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAyNzQ1NDYpXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTEpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgIGluaXQgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgdG9rZW4gPT09IDg2MDg3XHJcbiAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAga2luZDogJ3ZhcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QocGFyc2VyLCBjb250ZXh0IHwgMTM0MjE3NzI4LCBzY29wZSwgNCwgMzIpXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnY29uc3QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHBhcnNlciwgY29udGV4dCB8IDEzNDIxNzcyOCwgc2NvcGUsIDE2LCAzMilcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRva2VuID09PSAxMDc0NzkwNDE3KSB7XHJcbiAgICAgICAgICBpZiAoZm9yQXdhaXQpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgNzkpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCh0b2tlbiAmIDIwOTcxNTIpID09PSAyMDk3MTUyKSB7XHJcbiAgICAgICAgICBpbml0ID1cclxuICAgICAgICAgICAgICB0b2tlbiA9PT0gMjE2MjcwMFxyXG4gICAgICAgICAgICAgICAgICA/IHBhcnNlT2JqZWN0TGl0ZXJhbE9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHZvaWQgMCwgMSwgMCwgMCwgMiwgMzIsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpXHJcbiAgICAgICAgICAgICAgICAgIDogcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCB2b2lkIDAsIDEsIDAsIDAsIDIsIDMyLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgIGRlc3RydWN0aWJsZSA9IHBhcnNlci5kZXN0cnVjdGlibGU7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDI1NiAmJiBkZXN0cnVjdGlibGUgJiA2NCkge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDYwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID1cclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgJiAxNiA/IDIgOiAxO1xyXG4gICAgICAgICAgaW5pdCA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCB8IDEzNDIxNzcyOCwgaW5pdCwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpbml0ID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCB8IDEzNDIxNzcyOCwgMSwgMCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAyNjIxNDQpID09PSAyNjIxNDQpIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDI3NDU0Nikge1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDc3LCBmb3JBd2FpdCA/ICdhd2FpdCcgOiAnb2YnKTtcclxuICAgICAgICAgICAgICByZWludGVycHJldFRvUGF0dGVybihwYXJzZXIsIGluaXQpO1xyXG4gICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxNik7XHJcbiAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHBhcnNlSXRlcmF0aW9uU3RhdGVtZW50Qm9keShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnRm9yT2ZTdGF0ZW1lbnQnLFxyXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBpbml0LFxyXG4gICAgICAgICAgICAgICAgICByaWdodCxcclxuICAgICAgICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgICAgICAgYXdhaXQ6IGZvckF3YWl0XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDc3LCAnaW4nKTtcclxuICAgICAgICAgIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHBhcnNlciwgaW5pdCk7XHJcbiAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgaWYgKGZvckF3YWl0KVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDc5KTtcclxuICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTYpO1xyXG4gICAgICAgICAgY29uc3QgYm9keSA9IHBhcnNlSXRlcmF0aW9uU3RhdGVtZW50Qm9keShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBsYWJlbHMpO1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0ZvckluU3RhdGVtZW50JyxcclxuICAgICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICAgIGxlZnQ6IGluaXQsXHJcbiAgICAgICAgICAgICAgcmlnaHRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChmb3JBd2FpdClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDc5KTtcclxuICAgICAgaWYgKCFpc1ZhckRlY2wpIHtcclxuICAgICAgICAgIGlmIChkZXN0cnVjdGlibGUgJiA4ICYmIHBhcnNlci50b2tlbiAhPT0gMTA3NzkzNjE1Nykge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDc3LCAnbG9vcCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaW5pdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0IHwgMTM0MjE3NzI4LCAwLCAwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCBpbml0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyKVxyXG4gICAgICAgICAgaW5pdCA9IHBhcnNlU2VxdWVuY2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcywgaW5pdCk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDEwNzQ3OTA0MTcpO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE3KVxyXG4gICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbnMocGFyc2VyLCBjb250ZXh0LCAwLCAxLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTA3NDc5MDQxNyk7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDE2KVxyXG4gICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxNik7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBwYXJzZUl0ZXJhdGlvblN0YXRlbWVudEJvZHkocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgbGFiZWxzKTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnRm9yU3RhdGVtZW50JyxcclxuICAgICAgICAgIGluaXQsXHJcbiAgICAgICAgICB0ZXN0LFxyXG4gICAgICAgICAgdXBkYXRlLFxyXG4gICAgICAgICAgYm9keVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHNjb3BlKSB7XHJcbiAgICAgIGlmICghaXNWYWxpZElkZW50aWZpZXIoY29udGV4dCwgcGFyc2VyLnRva2VuKSlcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExNCk7XHJcbiAgICAgIGlmICgocGFyc2VyLnRva2VuICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgYWRkQmxvY2tOYW1lKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHBhcnNlci50b2tlblZhbHVlLCA4LCAwKTtcclxuICAgICAgcmV0dXJuIHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGxldCBzb3VyY2UgPSBudWxsO1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgbGV0IHNwZWNpZmllcnMgPSBbXTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTM0MjgzMjY3KSB7XHJcbiAgICAgICAgICBzb3VyY2UgPSBwYXJzZUxpdGVyYWwocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgICAgICBjb25zdCBsb2NhbCA9IHBhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzY29wZSk7XHJcbiAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IFtcclxuICAgICAgICAgICAgICAgICAgZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsXHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQsIDEwNzM3NDE4NDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg0NTcwMTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKHBhcnNlciwgY29udGV4dCwgc2NvcGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE2MjcwMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUltcG9ydFNwZWNpZmllck9yTmFtZWRJbXBvcnRzKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHNwZWNpZmllcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJzZXIudG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgY2FzZSA4NDU3MDExOlxyXG4gICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IFtwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihwYXJzZXIsIGNvbnRleHQsIHNjb3BlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgY2FzZSAyMTYyNzAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbXBvcnRTcGVjaWZpZXJPck5hbWVkSW1wb3J0cyhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBzcGVjaWZpZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICBjYXNlIDY3MTc0NDExOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW1wb3J0Q2FsbERlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgNjcxMDg4Nzc6XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnRNZXRhRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNvdXJjZSA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0ltcG9ydERlY2xhcmF0aW9uJyxcclxuICAgICAgICAgIHNwZWNpZmllcnMsXHJcbiAgICAgICAgICBzb3VyY2VcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKHBhcnNlciwgY29udGV4dCwgc2NvcGUpIHtcclxuICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTIzOTUpO1xyXG4gICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDEzNDIxNzcyOCkgPT09IDEzNDIxNzcyOCkge1xyXG4gICAgICAgICAgcmVwb3J0TWVzc2FnZUF0KHRva2VuUG9zLCBwYXJzZXIubGluZSwgcGFyc2VyLmluZGV4LCAyOCwgS2V5d29yZERlc2NUYWJsZVtwYXJzZXIudG9rZW4gJiAyNTVdKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgIHR5cGU6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxyXG4gICAgICAgICAgbG9jYWw6IHBhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzY29wZSlcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTW9kdWxlU3BlY2lmaWVyKHBhcnNlciwgY29udGV4dCkge1xyXG4gICAgICBjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCwgMTI0MDEpO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMzQyODMyNjcpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDIsICdJbXBvcnQnKTtcclxuICAgICAgcmV0dXJuIHBhcnNlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUltcG9ydFNwZWNpZmllck9yTmFtZWRJbXBvcnRzKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHNwZWNpZmllcnMpIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgIGxldCB7IHRva2VuLCB0b2tlblZhbHVlLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICBjb25zdCBpbXBvcnRlZCA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgbGV0IGxvY2FsO1xyXG4gICAgICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCAxMjM5NSkpIHtcclxuICAgICAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDEzNDIxNzcyOCkgPT09IDEzNDIxNzcyOCB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTAzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQmluZGluZ0lkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAxNiwgcGFyc2VyLnRva2VuLCAwKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdG9rZW5WYWx1ZSA9IHBhcnNlci50b2tlblZhbHVlO1xyXG4gICAgICAgICAgICAgIGxvY2FsID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICB2YWxpZGF0ZUJpbmRpbmdJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMTYsIHRva2VuLCAwKTtcclxuICAgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgICAgIGFkZEJsb2NrTmFtZShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCA4LCAwKTtcclxuICAgICAgICAgIHNwZWNpZmllcnMucHVzaChmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdJbXBvcnRTcGVjaWZpZXInLFxyXG4gICAgICAgICAgICAgIGxvY2FsLFxyXG4gICAgICAgICAgICAgIGltcG9ydGVkXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE1KVxyXG4gICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAxMDczNzQxODQyKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTA3NDc5MDQxNSk7XHJcbiAgICAgIHJldHVybiBzcGVjaWZpZXJzO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUltcG9ydE1ldGFEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbGV0IGV4cHIgPSBwYXJzZUltcG9ydE1ldGFFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcclxuICAgICAgICAgIG5hbWU6ICdpbXBvcnQnXHJcbiAgICAgIH0pLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgZXhwciA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBleHByLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJbXBvcnRDYWxsRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGxldCBleHByID0gcGFyc2VJbXBvcnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIGV4cHIgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGV4cHIsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHBhcnNlciwgY29udGV4dCwgZXhwciwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBsZXQgc3BlY2lmaWVycyA9IFtdO1xyXG4gICAgICBsZXQgZGVjbGFyYXRpb24gPSBudWxsO1xyXG4gICAgICBsZXQgc291cmNlID0gbnVsbDtcclxuICAgICAgbGV0IGtleTtcclxuICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDIwNTYwKSkge1xyXG4gICAgICAgICAgc3dpdGNoIChwYXJzZXIudG9rZW4pIHtcclxuICAgICAgICAgICAgICBjYXNlIDg2MTAzOiB7XHJcbiAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDQsIDEsIDEsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2FzZSAxMzA6XHJcbiAgICAgICAgICAgICAgY2FzZSA4NjA5MzpcclxuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUNsYXNzRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMSwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgMTQzNDY4OlxyXG4gICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeyBmbGFncyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSA4NjEwMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDQsIDEsIDEsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUFzeW5jQXJyb3dPckNhbGxFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZGVjbGFyYXRpb24sIDEsIDEsIDAsIGZsYWdzLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGRlY2xhcmF0aW9uLCAwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgZGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBjcmVhdGVBcnJvd0hlYWRQYXJzaW5nU2NvcGUocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBbZGVjbGFyYXRpb25dLCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAgICAgICAgZGVjbGFyZVVuYm91bmRWYXJpYWJsZShwYXJzZXIsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICB0eXBlOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcclxuICAgICAgICAgICAgICBkZWNsYXJhdGlvblxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChwYXJzZXIudG9rZW4pIHtcclxuICAgICAgICAgIGNhc2UgODQ1NzAxMToge1xyXG4gICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGlzTmFtZWREZWNsYXJhdGlvbiA9IGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCAxMjM5NSk7XHJcbiAgICAgICAgICAgICAgaWYgKGlzTmFtZWREZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlVW5ib3VuZFZhcmlhYmxlKHBhcnNlciwgcGFyc2VyLnRva2VuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXI6IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTI0MDEpO1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEzNDI4MzI2NylcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTAyLCAnRXhwb3J0Jyk7XHJcbiAgICAgICAgICAgICAgc291cmNlID0gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgbWF0Y2hPckluc2VydFNlbWljb2xvbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGlzTmFtZWREZWNsYXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICA/IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzXHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIDogZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIDIxNjI3MDA6IHtcclxuICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICBjb25zdCB0bXBFeHBvcnRlZE5hbWVzID0gW107XHJcbiAgICAgICAgICAgICAgY29uc3QgdG1wRXhwb3J0ZWRCaW5kaW5ncyA9IFtdO1xyXG4gICAgICAgICAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlblBvcywgdG9rZW5WYWx1ZSwgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBleHBvcnRlZDtcclxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTIzOTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAxMzQyMTc3MjgpID09PSAxMzQyMTc3MjgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wRXhwb3J0ZWROYW1lcy5wdXNoKHBhcnNlci50b2tlblZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBFeHBvcnRlZEJpbmRpbmdzLnB1c2godG9rZW5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZCA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wRXhwb3J0ZWROYW1lcy5wdXNoKHBhcnNlci50b2tlblZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBFeHBvcnRlZEJpbmRpbmdzLnB1c2gocGFyc2VyLnRva2VuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWQgPSBsb2NhbDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFeHBvcnRTcGVjaWZpZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFxyXG4gICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzQ3OTA0MTUpXHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTA3Mzc0MTg0Mik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAxMDc0NzkwNDE1KTtcclxuICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQsIDEyNDAxKSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMzQyODMyNjcpXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDIsICdFeHBvcnQnKTtcclxuICAgICAgICAgICAgICAgICAgc291cmNlID0gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgbGV0IGlNYXggPSB0bXBFeHBvcnRlZE5hbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpTWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmVVbmJvdW5kVmFyaWFibGUocGFyc2VyLCB0bXBFeHBvcnRlZE5hbWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgaU1heCA9IHRtcEV4cG9ydGVkQmluZGluZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGlNYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYWRkQmluZGluZ1RvRXhwb3J0cyhwYXJzZXIsIHRtcEV4cG9ydGVkQmluZGluZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIG1hdGNoT3JJbnNlcnRTZW1pY29sb24ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSA4NjA5MzpcclxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAyLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgODYxMDM6XHJcbiAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgNCwgMSwgMiwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDI0MTczNjpcclxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDgsIDY0LCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgODYwODk6XHJcbiAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUxleGljYWxEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAxNiwgNjQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSA4NjA4NzpcclxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgNjQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAxNDM0Njg6XHJcbiAgICAgICAgICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgaWYgKChwYXJzZXIuZmxhZ3MgJiAxKSA8IDEgJiYgcGFyc2VyLnRva2VuID09PSA4NjEwMykge1xyXG4gICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCA0LCAxLCAyLCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBkZWNsYXJhdGlvbi5pZCA/IGRlY2xhcmF0aW9uLmlkLm5hbWUgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmVVbmJvdW5kVmFyaWFibGUocGFyc2VyLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjgsIEtleXdvcmREZXNjVGFibGVbcGFyc2VyLnRva2VuICYgMjU1XSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXHJcbiAgICAgICAgICBkZWNsYXJhdGlvbixcclxuICAgICAgICAgIHNwZWNpZmllcnMsXHJcbiAgICAgICAgICBzb3VyY2VcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGNhbkFzc2lnbiwgaXNQYXR0ZXJuLCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGxldCBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDIsIDAsIGNhbkFzc2lnbiwgaXNQYXR0ZXJuLCBpbkdyb3VwLCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgZXhwciA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIHJldHVybiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgZXhwcik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlU2VxdWVuY2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgZXhwcikge1xyXG4gICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtleHByXTtcclxuICAgICAgd2hpbGUgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDEwNzM3NDE4NDIpKSB7XHJcbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDAsIGluR3JvdXAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgZXhwcmVzc2lvbnNcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbnMocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBjYW5Bc3NpZ24sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGNhbkFzc2lnbiwgMCwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIHJldHVybiBwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDJcclxuICAgICAgICAgID8gcGFyc2VTZXF1ZW5jZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uLCBleHByKVxyXG4gICAgICAgICAgOiBleHByO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBzdGFydCwgbGluZSwgY29sdW1uLCBsZWZ0KSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW4gfSA9IHBhcnNlcjtcclxuICAgICAgaWYgKCh0b2tlbiAmIDQxOTQzMDQpID09PSA0MTk0MzA0KSB7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI0KTtcclxuICAgICAgICAgIGlmICgoIWlzUGF0dGVybiAmJiB0b2tlbiA9PT0gMTA3NzkzNjE1NyAmJiBsZWZ0LnR5cGUgPT09ICdBcnJheUV4cHJlc3Npb24nKSB8fFxyXG4gICAgICAgICAgICAgIGxlZnQudHlwZSA9PT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XHJcbiAgICAgICAgICAgICAgcmVpbnRlcnByZXRUb1BhdHRlcm4ocGFyc2VyLCBsZWZ0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICBjb25zdCByaWdodCA9IHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDEsIGluR3JvdXAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCBpc1BhdHRlcm5cclxuICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuICAgICAgICAgICAgICAgICAgbGVmdCxcclxuICAgICAgICAgICAgICAgICAgcmlnaHRcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBLZXl3b3JkRGVzY1RhYmxlW3Rva2VuICYgMjU1XSxcclxuICAgICAgICAgICAgICAgICAgcmlnaHRcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKHRva2VuICYgODQ1NDE0NCkgPT09IDg0NTQxNDQpIHtcclxuICAgICAgICAgIGxlZnQgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uLCA0LCB0b2tlbiwgbGVmdCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDIyKSkge1xyXG4gICAgICAgICAgbGVmdCA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgbGVmdCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGxlZnQpIHtcclxuICAgICAgY29uc3QgeyB0b2tlbiB9ID0gcGFyc2VyO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCByaWdodCA9IHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDEsIGluR3JvdXAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBsZWZ0ID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGlzUGF0dGVyblxyXG4gICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuICAgICAgICAgICAgICBsZWZ0LFxyXG4gICAgICAgICAgICAgIHJpZ2h0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IEtleXdvcmREZXNjVGFibGVbdG9rZW4gJiAyNTVdLFxyXG4gICAgICAgICAgICAgIHJpZ2h0XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICByZXR1cm4gbGVmdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCB0ZXN0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCAoY29udGV4dCB8IDEzNDIxNzcyOCkgXiAxMzQyMTc3MjgsIDEsIDAsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMSk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMTtcclxuICAgICAgY29uc3QgYWx0ZXJuYXRlID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcclxuICAgICAgICAgIHRlc3QsXHJcbiAgICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgICAgYWx0ZXJuYXRlXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uLCBtaW5QcmVjLCBvcGVyYXRvciwgbGVmdCkge1xyXG4gICAgICBjb25zdCBiaXQgPSAtKChjb250ZXh0ICYgMTM0MjE3NzI4KSA+IDApICYgODczODg2NTtcclxuICAgICAgbGV0IHQ7XHJcbiAgICAgIGxldCBwcmVjO1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gJiA4NDU0MTQ0KSB7XHJcbiAgICAgICAgICB0ID0gcGFyc2VyLnRva2VuO1xyXG4gICAgICAgICAgcHJlYyA9IHQgJiAzODQwO1xyXG4gICAgICAgICAgaWYgKCh0ICYgNTI0Mjg4ICYmIG9wZXJhdG9yICYgMjY4NDM1NDU2KSB8fCAob3BlcmF0b3IgJiA1MjQyODggJiYgdCAmIDI2ODQzNTQ1NikpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNTkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHByZWMgKyAoKHQgPT09IDg0NTcyNzApIDw8IDgpIC0gKChiaXQgPT09IHQpIDw8IDEyKSA8PSBtaW5QcmVjKVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgIGxlZnQgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgIHR5cGU6IHQgJiA1MjQyODggPyAnTG9naWNhbEV4cHJlc3Npb24nIDogdCAmIDI2ODQzNTQ1NiA/ICdDb2FsZXNjZUV4cHJlc3Npb24nIDogJ0JpbmFyeUV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQmluYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MsIHByZWMsIHQsIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIGluR3JvdXAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKSxcclxuICAgICAgICAgICAgICBvcGVyYXRvcjogS2V5d29yZERlc2NUYWJsZVt0ICYgMjU1XVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3NzkzNjE1NylcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI0KTtcclxuICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaXNMSFMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIGluR3JvdXApIHtcclxuICAgICAgaWYgKCFpc0xIUylcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDApO1xyXG4gICAgICBjb25zdCB1bmFyeU9wZXJhdG9yID0gcGFyc2VyLnRva2VuO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCBhcmcgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAwLCBpbkdyb3VwLCAxLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gODQ1NzI3MClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDMxKTtcclxuICAgICAgaWYgKGNvbnRleHQgJiAxMDI0ICYmIHVuYXJ5T3BlcmF0b3IgPT09IDE2ODYzMjc1KSB7XHJcbiAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExNyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChpc1Byb3BlcnR5V2l0aFByaXZhdGVGaWVsZEtleShhcmcpKSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTIzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ1VuYXJ5RXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBvcGVyYXRvcjogS2V5d29yZERlc2NUYWJsZVt1bmFyeU9wZXJhdG9yICYgMjU1XSxcclxuICAgICAgICAgIGFyZ3VtZW50OiBhcmcsXHJcbiAgICAgICAgICBwcmVmaXg6IHRydWVcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQXN5bmNFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgaXNMSFMsIGNhbkFzc2lnbiwgaXNQYXR0ZXJuLCBpbk5ldywgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdCB7IHRva2VuIH0gPSBwYXJzZXI7XHJcbiAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBpc1BhdHRlcm4pO1xyXG4gICAgICBjb25zdCB7IGZsYWdzIH0gPSBwYXJzZXI7XHJcbiAgICAgIGlmICgoZmxhZ3MgJiAxKSA8IDEpIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDg2MTAzKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDE0MzM2MCkgPT09IDE0MzM2MCkge1xyXG4gICAgICAgICAgICAgIGlmICghaXNMSFMpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDApO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUFzeW5jQXJyb3dBZnRlcklkZW50KHBhcnNlciwgY29udGV4dCwgY2FuQXNzaWduLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWluTmV3ICYmIHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgIHJldHVybiBwYXJzZUFzeW5jQXJyb3dPckNhbGxFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgY2FuQXNzaWduLCAxLCAwLCBmbGFncywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTApIHtcclxuICAgICAgICAgIGNsYXNzaWZ5SWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHRva2VuLCAxKTtcclxuICAgICAgICAgIGlmIChpbk5ldylcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0OCk7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0Zyb21JZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgcGFyc2VyLnRva2VuVmFsdWUsIGV4cHIsIGluTmV3LCBjYW5Bc3NpZ24sIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBleHByO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVlpZWxkRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIGNhbkFzc2lnbiwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBpZiAoaW5Hcm91cClcclxuICAgICAgICAgIHBhcnNlci5kZXN0cnVjdGlibGUgfD0gMjU2O1xyXG4gICAgICBpZiAoY29udGV4dCAmIDIwOTcxNTIpIHtcclxuICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDgzODg2MDgpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzApO1xyXG4gICAgICAgICAgaWYgKCFjYW5Bc3NpZ24pXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjQpO1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMjIpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTIwKTtcclxuICAgICAgICAgIGxldCBhcmd1bWVudCA9IG51bGw7XHJcbiAgICAgICAgICBsZXQgZGVsZWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgIGlmICgocGFyc2VyLmZsYWdzICYgMSkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgZGVsZWdhdGUgPSBjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCA4NDU3MDExKTtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICYgNjU1MzYgfHwgZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICB0eXBlOiAnWWllbGRFeHByZXNzaW9uJyxcclxuICAgICAgICAgICAgICBhcmd1bWVudCxcclxuICAgICAgICAgICAgICBkZWxlZ2F0ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTQsICd5aWVsZCcpO1xyXG4gICAgICByZXR1cm4gcGFyc2VJZGVudGlmaWVyT3JBcnJvdyhwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUF3YWl0RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluTmV3LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmIChpbkdyb3VwKVxyXG4gICAgICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSB8PSAxMjg7XHJcbiAgICAgIGlmIChjb250ZXh0ICYgNDE5NDMwNCkge1xyXG4gICAgICAgICAgaWYgKGluTmV3KVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDApO1xyXG4gICAgICAgICAgaWYgKGNvbnRleHQgJiA4Mzg4NjA4KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0TWVzc2FnZUF0KHBhcnNlci5pbmRleCwgcGFyc2VyLmxpbmUsIHBhcnNlci5pbmRleCwgMjkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgMCwgMSwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICB0eXBlOiAnQXdhaXRFeHByZXNzaW9uJyxcclxuICAgICAgICAgICAgICBhcmd1bWVudFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAyMDQ4KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTA3LCAnQXdhaXQnKTtcclxuICAgICAgcmV0dXJuIHBhcnNlSWRlbnRpZmllck9yQXJyb3cocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkJvZHkocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBmaXJzdFJlc3RyaWN0ZWQsIHNjb3BlRXJyb3IpIHtcclxuICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDIxNjI3MDApO1xyXG4gICAgICBjb25zdCBib2R5ID0gW107XHJcbiAgICAgIGNvbnN0IHByZXZDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiA9PT0gMTM0MjgzMjY3KSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgeyBpbmRleCwgdG9rZW5Qb3MsIHRva2VuVmFsdWUsIHRva2VuIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgY29uc3QgZXhwciA9IHBhcnNlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgIGlmIChpc1ZhbGlkU3RyaWN0TW9kZShwYXJzZXIsIGluZGV4LCB0b2tlblBvcywgdG9rZW5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgY29udGV4dCB8PSAxMDI0O1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmZsYWdzICYgMTI4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnRNZXNzYWdlQXQocGFyc2VyLmluZGV4LCBwYXJzZXIubGluZSwgcGFyc2VyLnRva2VuUG9zLCA2Myk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5mbGFncyAmIDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnRNZXNzYWdlQXQocGFyc2VyLmluZGV4LCBwYXJzZXIubGluZSwgcGFyc2VyLnRva2VuUG9zLCA4KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBib2R5LnB1c2gocGFyc2VEaXJlY3RpdmUocGFyc2VyLCBjb250ZXh0LCBleHByLCB0b2tlbiwgdG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDEwMjQpIHtcclxuICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICgoZmlyc3RSZXN0cmljdGVkICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTUpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmICgoZmlyc3RSZXN0cmljdGVkICYgMzY4NjQpID09PSAzNjg2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzgpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuZmxhZ3MgJiA1MTIpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExNSk7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5mbGFncyAmIDI1NilcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgNjQgJiZcclxuICAgICAgICAgICAgICBzY29wZSAmJlxyXG4gICAgICAgICAgICAgIHNjb3BlRXJyb3IgIT09IHZvaWQgMCAmJlxyXG4gICAgICAgICAgICAgIChwcmV2Q29udGV4dCAmIDEwMjQpIDwgMSAmJlxyXG4gICAgICAgICAgICAgIChjb250ZXh0ICYgODE5MikgPCAxKSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0U2NvcGVFcnJvcihzY29wZUVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIuZmxhZ3MgPVxyXG4gICAgICAgICAgKHBhcnNlci5mbGFncyB8IDUxMiB8IDI1NiB8IDY0KSBeXHJcbiAgICAgICAgICAgICAgKDUxMiB8IDI1NiB8IDY0KTtcclxuICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSA9IChwYXJzZXIuZGVzdHJ1Y3RpYmxlIHwgMjU2KSBeIDI1NjtcclxuICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiAhPT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgYm9keS5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgNCwge30sIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdW1lKHBhcnNlciwgb3JpZ2luICYgKDE2IHwgOCkgPyBjb250ZXh0IHwgMzI3NjggOiBjb250ZXh0LCAxMDc0NzkwNDE1KTtcclxuICAgICAgcGFyc2VyLmZsYWdzICY9IH4oMTI4IHwgNjQpO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjQpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgIHR5cGU6ICdCbG9ja1N0YXRlbWVudCcsXHJcbiAgICAgICAgICBib2R5XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVN1cGVyRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHN3aXRjaCAocGFyc2VyLnRva2VuKSB7XHJcbiAgICAgICAgICBjYXNlIDY3MTA4OTg4OlxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE2MSk7XHJcbiAgICAgICAgICBjYXNlIDY3MTc0NDExOiB7XHJcbiAgICAgICAgICAgICAgaWYgKChjb250ZXh0ICYgNTI0Mjg4KSA8IDEpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI2KTtcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDE2Mzg0KVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDMpO1xyXG4gICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgNjkyNzE1NzE6XHJcbiAgICAgICAgICBjYXNlIDY3MTA4ODc3OiB7XHJcbiAgICAgICAgICAgICAgaWYgKChjb250ZXh0ICYgMjYyMTQ0KSA8IDEpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI3KTtcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDE2Mzg0KVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDMpO1xyXG4gICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjgsICdzdXBlcicpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgeyB0eXBlOiAnU3VwZXInIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBjYW5Bc3NpZ24sIGluR3JvdXAsIGlzTEhTLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMiwgMCwgY2FuQXNzaWduLCAwLCBpbkdyb3VwLCBpc0xIUywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIHJldHVybiBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGV4cHJlc3Npb24sIGluR3JvdXAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA1Mik7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW4gfSA9IHBhcnNlcjtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnVXBkYXRlRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBhcmd1bWVudDogZXhwcixcclxuICAgICAgICAgIG9wZXJhdG9yOiBLZXl3b3JkRGVzY1RhYmxlW3Rva2VuICYgMjU1XSxcclxuICAgICAgICAgIHByZWZpeDogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDMzNjE5OTY4KSA9PT0gMzM2MTk5NjggJiYgKHBhcnNlci5mbGFncyAmIDEpIDwgMSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGV4cHIsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgocGFyc2VyLnRva2VuICYgNjcxMDg4NjQpID09PSA2NzEwODg2NCkge1xyXG4gICAgICAgICAgY29udGV4dCA9IChjb250ZXh0IHwgMTM0MjE3NzI4IHwgODE5MikgXiAoMTM0MjE3NzI4IHwgODE5Mik7XHJcbiAgICAgICAgICBzd2l0Y2ggKHBhcnNlci50b2tlbikge1xyXG4gICAgICAgICAgICAgIGNhc2UgNjcxMDg4Nzc6IHtcclxuICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDEwNzM3NDE4MjQpO1xyXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcGFyc2VQcm9wZXJ0eU9yUHJpdmF0ZVByb3BlcnR5TmFtZShwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICBleHByID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2FzZSA2OTI3MTU3MToge1xyXG4gICAgICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwYXJzZUV4cHJlc3Npb25zKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAyMCk7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMTtcclxuICAgICAgICAgICAgICAgICAgZXhwciA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGV4cHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2FzZSA2NzE3NDQxMToge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlci5mbGFncyAmIDEwMjQpID09PSAxMDI0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgPSAocGFyc2VyLmZsYWdzIHwgMTAyNCkgXiAxMDI0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJndW1lbnRzKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgICAgICAgICAgICAgZXhwciA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBleHByLFxyXG4gICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY2FzZSA2NzEwODk4ODoge1xyXG4gICAgICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICBleHByID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPcHRpb25hbEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxyXG4gICAgICAgICAgICAgICAgICAgICAgY2hhaW46IHBhcnNlT3B0aW9uYWxDaGFpbihwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICBleHByID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdGFnOiBleHByLFxyXG4gICAgICAgICAgICAgICAgICAgICAgcXVhc2k6IHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MDhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlVGVtcGxhdGUocGFyc2VyLCBjb250ZXh0IHwgNjU1MzYsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJzZVRlbXBsYXRlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlT3B0aW9uYWxDaGFpbihwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbGV0IGJhc2UgPSBudWxsO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSA2OTI3MTU3MSkge1xyXG4gICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgIGNvbnN0IHsgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwYXJzZUV4cHJlc3Npb25zKHBhcnNlciwgY29udGV4dCwgMCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMjApO1xyXG4gICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgYmFzZSA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ09wdGlvbmFsQ2hhaW4nLFxyXG4gICAgICAgICAgICAgIGJhc2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgcHJvcGVydHlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyhwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgYmFzZSA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ09wdGlvbmFsQ2hhaW4nLFxyXG4gICAgICAgICAgICAgIGJhc2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgKDE0MzM2MCB8IDQwOTYpKSA8IDEpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTU0KTtcclxuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgICAgICBiYXNlID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICB0eXBlOiAnT3B0aW9uYWxDaGFpbicsXHJcbiAgICAgICAgICAgICAgYmFzZTogbnVsbCxcclxuICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgcHJvcGVydHlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlICgocGFyc2VyLnRva2VuICYgNjcxMDg4NjQpID09PSA2NzEwODg2NCkge1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gNjcxMDg4NzcpIHtcclxuICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAoMTQzMzYwIHwgNDA5NikpIDwgMSlcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTU0KTtcclxuICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcywge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnT3B0aW9uYWxDaGFpbicsXHJcbiAgICAgICAgICAgICAgICAgIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgcHJvcGVydHlcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzEpIHtcclxuICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAyMCk7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcywge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnT3B0aW9uYWxDaGFpbicsXHJcbiAgICAgICAgICAgICAgICAgIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSA2NzE3NDQxMSkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyhwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgICAgICAgICBiYXNlID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MsIHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ09wdGlvbmFsQ2hhaW4nLFxyXG4gICAgICAgICAgICAgICAgICBiYXNlLFxyXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MDggfHwgcGFyc2VyLnRva2VuID09PSA2NzE3NDQwOSkge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE2MCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYmFzZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU9yUHJpdmF0ZVByb3BlcnR5TmFtZShwYXJzZXIsIGNvbnRleHQpIHtcclxuICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAoMTQzMzYwIHwgNDA5NikpIDwgMSAmJiBwYXJzZXIudG9rZW4gIT09IDEyOCkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTU0KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29udGV4dCAmIDEgJiYgcGFyc2VyLnRva2VuID09PSAxMjhcclxuICAgICAgICAgID8gcGFyc2VQcml2YXRlTmFtZShwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpXHJcbiAgICAgICAgICA6IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVVwZGF0ZUV4cHJlc3Npb25QcmVmaXhlZChwYXJzZXIsIGNvbnRleHQsIGluTmV3LCBpc0xIUywgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBpZiAoaW5OZXcpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA1Myk7XHJcbiAgICAgIGlmICghaXNMSFMpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAwKTtcclxuICAgICAgY29uc3QgeyB0b2tlbiB9ID0gcGFyc2VyO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCBhcmcgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAwLCAwLCAxLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMikge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNTIpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnVXBkYXRlRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBhcmd1bWVudDogYXJnLFxyXG4gICAgICAgICAgb3BlcmF0b3I6IEtleXdvcmREZXNjVGFibGVbdG9rZW4gJiAyNTVdLFxyXG4gICAgICAgICAgcHJlZml4OiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwga2luZCwgaW5OZXcsIGNhbkFzc2lnbiwgaXNQYXR0ZXJuLCBpbkdyb3VwLCBpc0xIUywgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDE0MzM2MCkgPT09IDE0MzM2MCkge1xyXG4gICAgICAgICAgc3dpdGNoIChwYXJzZXIudG9rZW4pIHtcclxuICAgICAgICAgICAgICBjYXNlIDIwOTAwNTpcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXdhaXRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5OZXcsIGluR3JvdXAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICAgIGNhc2UgMjQxNzcwOlxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VZaWVsZEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBjYW5Bc3NpZ24sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgICAgIGNhc2UgMTQzNDY4OlxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBc3luY0V4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc0xIUywgY2FuQXNzaWduLCBpc1BhdHRlcm4sIGluTmV3LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHsgdG9rZW4sIHRva2VuVmFsdWUgfSA9IHBhcnNlcjtcclxuICAgICAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0IHwgNjU1MzYsIGlzUGF0dGVybik7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMCkge1xyXG4gICAgICAgICAgICAgIGlmICghaXNMSFMpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDApO1xyXG4gICAgICAgICAgICAgIGNsYXNzaWZ5SWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHRva2VuLCAxKTtcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0Zyb21JZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgdG9rZW5WYWx1ZSwgZXhwciwgaW5OZXcsIGNhbkFzc2lnbiwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmIDE2Mzg0ICYmIHRva2VuID09PSA1MzcwNzk5MjUpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTI2KTtcclxuICAgICAgICAgIGlmICh0b2tlbiA9PT0gMjQxNzM2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDkpO1xyXG4gICAgICAgICAgICAgIGlmIChraW5kICYgKDggfCAxNikpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDk3KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlID1cclxuICAgICAgICAgICAgICBjb250ZXh0ICYgMTAyNCAmJiAodG9rZW4gJiA1MzcwNzk4MDgpID09PSA1MzcwNzk4MDhcclxuICAgICAgICAgICAgICAgICAgPyAyXHJcbiAgICAgICAgICAgICAgICAgIDogMTtcclxuICAgICAgICAgIHJldHVybiBleHByO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgocGFyc2VyLnRva2VuICYgMTM0MjE3NzI4KSA9PT0gMTM0MjE3NzI4KSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChwYXJzZXIudG9rZW4pIHtcclxuICAgICAgICAgIGNhc2UgMzM2MTk5OTU6XHJcbiAgICAgICAgICBjYXNlIDMzNjE5OTk2OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVVwZGF0ZUV4cHJlc3Npb25QcmVmaXhlZChwYXJzZXIsIGNvbnRleHQsIGluTmV3LCBpc0xIUywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDE2ODYzMjc1OlxyXG4gICAgICAgICAgY2FzZSAxNjg0Mjc5NzpcclxuICAgICAgICAgIGNhc2UgMTY4NDI3OTg6XHJcbiAgICAgICAgICBjYXNlIDI1MjMzOTY3OlxyXG4gICAgICAgICAgY2FzZSAyNTIzMzk2ODpcclxuICAgICAgICAgIGNhc2UgMTY4NjMyNzQ6XHJcbiAgICAgICAgICBjYXNlIDE2ODYzMjc2OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVVuYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGlzTEhTLCBzdGFydCwgbGluZSwgY29sdW1uLCBpbkdyb3VwKTtcclxuICAgICAgICAgIGNhc2UgODYxMDM6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMCwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDIxNjI3MDA6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0TGl0ZXJhbChwYXJzZXIsIGNvbnRleHQsIGNhbkFzc2lnbiA/IDAgOiAxLCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgNjkyNzE1NzE6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgY2FuQXNzaWduID8gMCA6IDEsIGluR3JvdXAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSA2NzE3NDQxMTpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGNhbkFzc2lnbiwgMSwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDg2MDIxOlxyXG4gICAgICAgICAgY2FzZSA4NjAyMjpcclxuICAgICAgICAgIGNhc2UgODYwMjM6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVsbE9yVHJ1ZU9yRmFsc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDg2MTEwOlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVRoaXNFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICBjYXNlIDY1NTQwOlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVJlZ0V4cExpdGVyYWwocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgMTMwOlxyXG4gICAgICAgICAgY2FzZSA4NjA5MzpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0V4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgODYxMDg6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3VwZXJFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDY3MTc0NDA5OlxyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVRlbXBsYXRlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSA2NzE3NDQwODpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUZW1wbGF0ZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSA4NjEwNjpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VOZXdFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDEyMjpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VCaWdJbnRMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICBjYXNlIDEyODpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VQcml2YXRlTmFtZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgY2FzZSA4NjEwNTpcclxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnRDYWxsT3JNZXRhRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluTmV3LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGNhc2UgODQ1NjI1NTpcclxuICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDE2KVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VKU1hSb290RWxlbWVudE9yRnJhZ21lbnQocGFyc2VyLCBjb250ZXh0LCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWRJZGVudGlmaWVyKGNvbnRleHQsIHBhcnNlci50b2tlbikpXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlkZW50aWZpZXJPckFycm93KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjgsIEtleXdvcmREZXNjVGFibGVbcGFyc2VyLnRva2VuICYgMjU1XSk7XHJcbiAgICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJbXBvcnRDYWxsT3JNZXRhRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluTmV3LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGxldCBleHByID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgIGlmIChjb250ZXh0ICYgMSAmJiBwYXJzZXIudG9rZW4gPT09IDY3MTA4ODc3KSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VJbXBvcnRNZXRhRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGV4cHIsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbk5ldylcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEzNyk7XHJcbiAgICAgIGV4cHIgPSBwYXJzZUltcG9ydEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICByZXR1cm4gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByLCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJbXBvcnRNZXRhRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIG1ldGEsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgaWYgKChjb250ZXh0ICYgMjA0OCkgPT09IDApXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNjMpO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTQzNDkyICYmIHBhcnNlci50b2tlblZhbHVlICE9PSAnbWV0YScpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAyOCwgS2V5d29yZERlc2NUYWJsZVtwYXJzZXIudG9rZW4gJiAyNTVdKTtcclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdNZXRhUHJvcGVydHknLFxyXG4gICAgICAgICAgbWV0YSxcclxuICAgICAgICAgIHByb3BlcnR5OiBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJbXBvcnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCA2NzE3NDQxMSk7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDE0KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTM4KTtcclxuICAgICAgY29uc3Qgc291cmNlID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAxNik7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0ltcG9ydEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgc291cmNlXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUJpZ0ludExpdGVyYWwocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5SYXcsIHRva2VuVmFsdWUgfSA9IHBhcnNlcjtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCBjb250ZXh0ICYgNTEyXHJcbiAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnQmlnSW50TGl0ZXJhbCcsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHRva2VuVmFsdWUsXHJcbiAgICAgICAgICAgICAgYmlnaW50OiB0b2tlblJhdyxcclxuICAgICAgICAgICAgICByYXc6IHRva2VuUmF3XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnQmlnSW50TGl0ZXJhbCcsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHRva2VuVmFsdWUsXHJcbiAgICAgICAgICAgICAgYmlnaW50OiB0b2tlblJhd1xyXG4gICAgICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCA2NzE3NDQwOSk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ1RlbXBsYXRlTGl0ZXJhbCcsXHJcbiAgICAgICAgICBleHByZXNzaW9uczogW10sXHJcbiAgICAgICAgICBxdWFzaXM6IFtwYXJzZVRlbXBsYXRlRWxlbWVudChwYXJzZXIsIGNvbnRleHQsIHRydWUpXVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29udGV4dCA9IChjb250ZXh0IHwgMTM0MjE3NzI4KSBeIDEzNDIxNzcyODtcclxuICAgICAgY29uc3QgcXVhc2lzID0gW3BhcnNlVGVtcGxhdGVFbGVtZW50KHBhcnNlciwgY29udGV4dCwgZmFsc2UpXTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgNjcxNzQ0MDgpO1xyXG4gICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtwYXJzZUV4cHJlc3Npb25zKHBhcnNlciwgY29udGV4dCwgMCwgMSwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyldO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE1KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgODApO1xyXG4gICAgICB3aGlsZSAoKHBhcnNlci50b2tlbiA9IHNjYW5UZW1wbGF0ZVRhaWwocGFyc2VyLCBjb250ZXh0KSkgIT09IDY3MTc0NDA5KSB7XHJcbiAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgIHF1YXNpcy5wdXNoKHBhcnNlVGVtcGxhdGVFbGVtZW50KHBhcnNlciwgY29udGV4dCwgZmFsc2UpKTtcclxuICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDY3MTc0NDA4KTtcclxuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIDAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpKTtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzQ3OTA0MTUpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgODApO1xyXG4gICAgICB9XHJcbiAgICAgIHF1YXNpcy5wdXNoKHBhcnNlVGVtcGxhdGVFbGVtZW50KHBhcnNlciwgY29udGV4dCwgdHJ1ZSkpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgNjcxNzQ0MDkpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdUZW1wbGF0ZUxpdGVyYWwnLFxyXG4gICAgICAgICAgZXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICBxdWFzaXNcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVFbGVtZW50KHBhcnNlciwgY29udGV4dCwgdGFpbCkge1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB7XHJcbiAgICAgICAgICB0eXBlOiAnVGVtcGxhdGVFbGVtZW50JyxcclxuICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgY29va2VkOiBwYXJzZXIudG9rZW5WYWx1ZSxcclxuICAgICAgICAgICAgICByYXc6IHBhcnNlci50b2tlblJhd1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRhaWxcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlU3ByZWFkRWxlbWVudChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29udGV4dCA9IChjb250ZXh0IHwgMTM0MjE3NzI4KSBeIDEzNDIxNzcyODtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTQpO1xyXG4gICAgICBjb25zdCBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDAsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ1NwcmVhZEVsZW1lbnQnLFxyXG4gICAgICAgICAgYXJndW1lbnRcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCkge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCBhcmdzID0gW107XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDE2KSB7XHJcbiAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgIHJldHVybiBhcmdzO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gIT09IDE2KSB7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxNCkge1xyXG4gICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZVNwcmVhZEVsZW1lbnQocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcykpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTA3Mzc0MTg0MilcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxNilcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTYpO1xyXG4gICAgICByZXR1cm4gYXJncztcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgaXNQYXR0ZXJuKSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCBjb250ZXh0ICYgMjY4NDM1NDU2XHJcbiAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXHJcbiAgICAgICAgICAgICAgbmFtZTogdG9rZW5WYWx1ZSxcclxuICAgICAgICAgICAgICBwYXR0ZXJuOiBpc1BhdHRlcm4gPT09IDFcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcclxuICAgICAgICAgICAgICBuYW1lOiB0b2tlblZhbHVlXHJcbiAgICAgICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCkge1xyXG4gICAgICBjb25zdCB7IHRva2VuVmFsdWUsIHRva2VuUmF3LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgY29udGV4dCAmIDUxMlxyXG4gICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0b2tlblZhbHVlLFxyXG4gICAgICAgICAgICAgIHJhdzogdG9rZW5SYXdcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogdG9rZW5WYWx1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTnVsbE9yVHJ1ZU9yRmFsc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdCByYXcgPSBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV07XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VyLnRva2VuID09PSA4NjAyMyA/IG51bGwgOiByYXcgPT09ICd0cnVlJztcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCBjb250ZXh0ICYgNTEyXHJcbiAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXHJcbiAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgcmF3XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXHJcbiAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVRoaXNFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCkge1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB7XHJcbiAgICAgICAgICB0eXBlOiAnVGhpc0V4cHJlc3Npb24nXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgb3JpZ2luLCBhbGxvd0dlbiwgZmxhZ3MsIGlzQXN5bmMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgY29uc3QgaXNHZW5lcmF0b3IgPSBhbGxvd0dlbiA/IG9wdGlvbmFsQml0KHBhcnNlciwgY29udGV4dCwgODQ1NzAxMSkgOiAwO1xyXG4gICAgICBsZXQgaWQgPSBudWxsO1xyXG4gICAgICBsZXQgZmlyc3RSZXN0cmljdGVkO1xyXG4gICAgICBsZXQgZnVuY3Rpb25TY29wZSA9IHNjb3BlID8gY3JlYXRlU2NvcGUoKSA6IHZvaWQgMDtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSA8IDEpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzcsICdGdW5jdGlvbicpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgY29uc3Qga2luZCA9IG9yaWdpbiAmIDQgJiYgKChjb250ZXh0ICYgODE5MikgPCAxIHx8IChjb250ZXh0ICYgMjA0OCkgPCAxKVxyXG4gICAgICAgICAgICAgID8gNFxyXG4gICAgICAgICAgICAgIDogNjQ7XHJcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uTmFtZShwYXJzZXIsIGNvbnRleHQgfCAoKGNvbnRleHQgJiAzMDcyKSA8PCAxMSksIHBhcnNlci50b2tlbik7XHJcbiAgICAgICAgICBpZiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgICBpZiAoa2luZCAmIDQpIHtcclxuICAgICAgICAgICAgICAgICAgYWRkVmFyTmFtZShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBwYXJzZXIudG9rZW5WYWx1ZSwga2luZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBhZGRCbG9ja05hbWUocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgcGFyc2VyLnRva2VuVmFsdWUsIGtpbmQsIG9yaWdpbik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uU2NvcGUgPSBhZGRDaGlsZFNjb3BlKGZ1bmN0aW9uU2NvcGUsIDI1Nik7XHJcbiAgICAgICAgICAgICAgaWYgKGZsYWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmVVbmJvdW5kVmFyaWFibGUocGFyc2VyLCBwYXJzZXIudG9rZW5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBwYXJzZXIudG9rZW47XHJcbiAgICAgICAgICBpZCA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRleHQgPVxyXG4gICAgICAgICAgKChjb250ZXh0IHwgMzIyNDM3MTIpIF4gMzIyNDM3MTIpIHxcclxuICAgICAgICAgICAgICA2NzEwODg2NCB8XHJcbiAgICAgICAgICAgICAgKChpc0FzeW5jICogMiArIGlzR2VuZXJhdG9yKSA8PCAyMSkgfFxyXG4gICAgICAgICAgICAgIChpc0dlbmVyYXRvciA/IDAgOiAxMDczNzQxODI0KTtcclxuICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgZnVuY3Rpb25TY29wZSA9IGFkZENoaWxkU2NvcGUoZnVuY3Rpb25TY29wZSwgNTEyKTtcclxuICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VGb3JtYWxQYXJhbWV0ZXJzT3JGb3JtYWxMaXN0KHBhcnNlciwgY29udGV4dCB8IDgzODg2MDgsIGZ1bmN0aW9uU2NvcGUsIDAsIDEpO1xyXG4gICAgICBjb25zdCBib2R5ID0gcGFyc2VGdW5jdGlvbkJvZHkocGFyc2VyLCAoY29udGV4dCB8IDgxOTIgfCA0MDk2IHwgMTMxMDcyKSBeXHJcbiAgICAgICAgICAoODE5MiB8IDQwOTYgfCAxMzEwNzIpLCBzY29wZSA/IGFkZENoaWxkU2NvcGUoZnVuY3Rpb25TY29wZSwgMTI4KSA6IGZ1bmN0aW9uU2NvcGUsIDgsIGZpcnN0UmVzdHJpY3RlZCwgc2NvcGUgPyBmdW5jdGlvblNjb3BlLnNjb3BlRXJyb3IgOiB2b2lkIDApO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcclxuICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgYm9keSxcclxuICAgICAgICAgIGFzeW5jOiBpc0FzeW5jID09PSAxLFxyXG4gICAgICAgICAgZ2VuZXJhdG9yOiBpc0dlbmVyYXRvciA9PT0gMVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpc0FzeW5jLCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIGNvbnN0IGlzR2VuZXJhdG9yID0gb3B0aW9uYWxCaXQocGFyc2VyLCBjb250ZXh0LCA4NDU3MDExKTtcclxuICAgICAgY29uc3QgZ2VuZXJhdG9yQW5kQXN5bmNGbGFncyA9IChpc0FzeW5jICogMiArIGlzR2VuZXJhdG9yKSA8PCAyMTtcclxuICAgICAgbGV0IGlkID0gbnVsbDtcclxuICAgICAgbGV0IGZpcnN0UmVzdHJpY3RlZDtcclxuICAgICAgbGV0IHNjb3BlID0gY29udGV4dCAmIDY0ID8gY3JlYXRlU2NvcGUoKSA6IHZvaWQgMDtcclxuICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAoMTQzMzYwIHwgNDA5NiB8IDM2ODY0KSkgPiAwKSB7XHJcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uTmFtZShwYXJzZXIsICgoY29udGV4dCB8IDB4MWVjMDAwMCkgXiAweDFlYzAwMDApIHwgZ2VuZXJhdG9yQW5kQXN5bmNGbGFncywgcGFyc2VyLnRva2VuKTtcclxuICAgICAgICAgIGlmIChzY29wZSlcclxuICAgICAgICAgICAgICBzY29wZSA9IGFkZENoaWxkU2NvcGUoc2NvcGUsIDI1Nik7XHJcbiAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBwYXJzZXIudG9rZW47XHJcbiAgICAgICAgICBpZCA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRleHQgPVxyXG4gICAgICAgICAgKChjb250ZXh0IHwgMzIyNDM3MTIpIF4gMzIyNDM3MTIpIHxcclxuICAgICAgICAgICAgICA2NzEwODg2NCB8XHJcbiAgICAgICAgICAgICAgZ2VuZXJhdG9yQW5kQXN5bmNGbGFncyB8XHJcbiAgICAgICAgICAgICAgKGlzR2VuZXJhdG9yID8gMCA6IDEwNzM3NDE4MjQpO1xyXG4gICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAgICBzY29wZSA9IGFkZENoaWxkU2NvcGUoc2NvcGUsIDUxMik7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlRm9ybWFsUGFyYW1ldGVyc09yRm9ybWFsTGlzdChwYXJzZXIsIGNvbnRleHQgfCA4Mzg4NjA4LCBzY29wZSwgaW5Hcm91cCwgMSk7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBwYXJzZUZ1bmN0aW9uQm9keShwYXJzZXIsIGNvbnRleHQgJiB+KDB4ODAwMTAwMCB8IDgxOTIgfCA0MDk2IHwgMTMxMDcyIHwgMTYzODQpLCBzY29wZSA/IGFkZENoaWxkU2NvcGUoc2NvcGUsIDEyOCkgOiBzY29wZSwgMCwgZmlyc3RSZXN0cmljdGVkLCB2b2lkIDApO1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICBhc3luYzogaXNBc3luYyA9PT0gMSxcclxuICAgICAgICAgIGdlbmVyYXRvcjogaXNHZW5lcmF0b3IgPT09IDFcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXlMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc2tpcEluaXRpYWxpemVyLCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZUFycmF5RXhwcmVzc2lvbk9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHZvaWQgMCwgc2tpcEluaXRpYWxpemVyLCBpbkdyb3VwLCAwLCAyLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKGNvbnRleHQgJiAyNTYgJiYgcGFyc2VyLmRlc3RydWN0aWJsZSAmIDY0KSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA2MCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcnNlci5kZXN0cnVjdGlibGUgJiA4KSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA1OSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXlFeHByZXNzaW9uT3JQYXR0ZXJuKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHNraXBJbml0aWFsaXplciwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcclxuICAgICAgbGV0IGRlc3RydWN0aWJsZSA9IDA7XHJcbiAgICAgIGNvbnRleHQgPSAoY29udGV4dCB8IDEzNDIxNzcyOCkgXiAxMzQyMTc3Mjg7XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gIT09IDIwKSB7XHJcbiAgICAgICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTA3Mzc0MTg0MikpIHtcclxuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgbGV0IGxlZnQ7XHJcbiAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgdG9rZW5WYWx1ZSB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgIGlmICh0b2tlbiAmIDE0MzM2MCkge1xyXG4gICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGtpbmQsIDAsIDEsIDAsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI0KTtcclxuICAgICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFyT3JCbG9jayhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCBraW5kLCBvcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAxLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgaXNQYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50UGF0dGVybicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSAmIDI1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDI1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDAgfCAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDEyOClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMTI4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyIHx8IHBhcnNlci50b2tlbiA9PT0gMjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY29wZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZhck9yQmxvY2socGFyc2VyLCBjb250ZXh0LCBzY29wZSwgdG9rZW5WYWx1ZSwga2luZCwgb3JpZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5kZXN0cnVjdGlibGUgJiAyNTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyNTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwIHwgKHBhcnNlci5kZXN0cnVjdGlibGUgJiAxMjgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDEyOFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2luZCAmIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAzMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChraW5kICYgMikgPCAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBsZWZ0LCBpbkdyb3VwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIgJiYgcGFyc2VyLnRva2VuICE9PSAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzc5MzYxNTcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIGlzUGF0dGVybiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgbGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzc5MzYxNTcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgJiAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDMyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICYgMjA5NzE1Mikge1xyXG4gICAgICAgICAgICAgICAgICBsZWZ0ID1cclxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50b2tlbiA9PT0gMjE2MjcwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VPYmplY3RMaXRlcmFsT3JQYXR0ZXJuKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDAsIGluR3JvdXAsIGlzUGF0dGVybiwga2luZCwgb3JpZ2luLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gcGFyc2VyLmRlc3RydWN0aWJsZTtcclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSAmIDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyIHx8IHBhcnNlci50b2tlbiA9PT0gMjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDY4KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGxlZnQsIGluR3JvdXAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmFzc2lnbmFibGUgJiAyID8gMTYgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTA3Mzc0MTg0MiAmJiBwYXJzZXIudG9rZW4gIT09IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIGxlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAxNlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAzMjtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gMTQpIHtcclxuICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlU3ByZWFkT3JSZXN0RWxlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAyMCwga2luZCwgb3JpZ2luLCAwLCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gcGFyc2VyLmRlc3RydWN0aWJsZTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTA3Mzc0MTg0MiAmJiBwYXJzZXIudG9rZW4gIT09IDIwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjgsIEtleXdvcmREZXNjVGFibGVbcGFyc2VyLnRva2VuICYgMjU1XSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIgJiYgcGFyc2VyLnRva2VuICE9PSAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIGxlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKChraW5kICYgKDIgfCAxKSkgPCAxICYmIHRva2VuID09PSA2NzE3NDQxMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IDY3MTc0NDExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSAmIDEgJiYga2luZCAmICgyIHwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAzMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDE2O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobGVmdCk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDEwNzM3NDE4NDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDIwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDIwKTtcclxuICAgICAgY29uc3Qgbm9kZSA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiBpc1BhdHRlcm4gPyAnQXJyYXlQYXR0ZXJuJyA6ICdBcnJheUV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgZWxlbWVudHNcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghc2tpcEluaXRpYWxpemVyICYmIHBhcnNlci50b2tlbiAmIDQxOTQzMDQpIHtcclxuICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5T3JPYmplY3RBc3NpZ25tZW50UGF0dGVybihwYXJzZXIsIGNvbnRleHQsIGRlc3RydWN0aWJsZSwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBzdGFydCwgbGluZSwgY29sdW1uLCBub2RlKTtcclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlID0gZGVzdHJ1Y3RpYmxlO1xyXG4gICAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VBcnJheU9yT2JqZWN0QXNzaWdubWVudFBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBkZXN0cnVjdGlibGUsIGluR3JvdXAsIGlzUGF0dGVybiwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgbm9kZSkge1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc3OTM2MTU3KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjQpO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBpZiAoZGVzdHJ1Y3RpYmxlICYgMTYpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAyNCk7XHJcbiAgICAgIGlmICghaXNQYXR0ZXJuKVxyXG4gICAgICAgICAgcmVpbnRlcnByZXRUb1BhdHRlcm4ocGFyc2VyLCBub2RlKTtcclxuICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMSwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIHBhcnNlci5kZXN0cnVjdGlibGUgPVxyXG4gICAgICAgICAgKChkZXN0cnVjdGlibGUgfCA2NCB8IDgpIF5cclxuICAgICAgICAgICAgICAoOCB8IDY0KSkgfFxyXG4gICAgICAgICAgICAgIChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgMTI4ID8gMTI4IDogMCkgfFxyXG4gICAgICAgICAgICAgIChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgMjU2ID8gMjU2IDogMCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgaXNQYXR0ZXJuXHJcbiAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnQXNzaWdubWVudFBhdHRlcm4nLFxyXG4gICAgICAgICAgICAgIGxlZnQ6IG5vZGUsXHJcbiAgICAgICAgICAgICAgcmlnaHRcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgbGVmdDogbm9kZSxcclxuICAgICAgICAgICAgICBvcGVyYXRvcjogJz0nLFxyXG4gICAgICAgICAgICAgIHJpZ2h0XHJcbiAgICAgICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VTcHJlYWRPclJlc3RFbGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIGNsb3NpbmdUb2tlbiwga2luZCwgb3JpZ2luLCBpc0FzeW5jLCBpbkdyb3VwLCBpc1BhdHRlcm4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgbGV0IGFyZ3VtZW50ID0gbnVsbDtcclxuICAgICAgbGV0IGRlc3RydWN0aWJsZSA9IDA7XHJcbiAgICAgIGxldCB7IHRva2VuLCB0b2tlblZhbHVlLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgIGlmICh0b2tlbiAmICg0MDk2IHwgMTQzMzYwKSkge1xyXG4gICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAxO1xyXG4gICAgICAgICAgYXJndW1lbnQgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwga2luZCwgMCwgMSwgMCwgaW5Hcm91cCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICB0b2tlbiA9IHBhcnNlci50b2tlbjtcclxuICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBhcmd1bWVudCwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDczNzQxODQyICYmIHBhcnNlci50b2tlbiAhPT0gY2xvc2luZ1Rva2VuKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMiAmJiBwYXJzZXIudG9rZW4gPT09IDEwNzc5MzYxNTcpXHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDY4KTtcclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCBhcmd1bWVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKSB7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IGNsb3NpbmdUb2tlbiB8fCB0b2tlbiA9PT0gMTA3Mzc0MTg0Mikge1xyXG4gICAgICAgICAgICAgIGlmIChzY29wZSlcclxuICAgICAgICAgICAgICAgICAgYWRkVmFyT3JCbG9jayhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCBraW5kLCBvcmlnaW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDMyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlci5kZXN0cnVjdGlibGUgJiAxMjggPyAxMjggOiAwO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRva2VuID09PSBjbG9zaW5nVG9rZW4pIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDM5KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0b2tlbiAmIDIwOTcxNTIpIHtcclxuICAgICAgICAgIGFyZ3VtZW50ID1cclxuICAgICAgICAgICAgICBwYXJzZXIudG9rZW4gPT09IDIxNjI3MDBcclxuICAgICAgICAgICAgICAgICAgPyBwYXJzZU9iamVjdExpdGVyYWxPclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMSwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpXHJcbiAgICAgICAgICAgICAgICAgIDogcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMSwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgdG9rZW4gPSBwYXJzZXIudG9rZW47XHJcbiAgICAgICAgICBpZiAodG9rZW4gIT09IDEwNzc5MzYxNTcgJiYgdG9rZW4gIT09IGNsb3NpbmdUb2tlbiAmJiB0b2tlbiAhPT0gMTA3Mzc0MTg0Mikge1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgOClcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgNjgpO1xyXG4gICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBhcmd1bWVudCwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlci5hc3NpZ25hYmxlICYgMiA/IDE2IDogMDtcclxuICAgICAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDQxOTQzMDQpID09PSA0MTk0MzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzc5MzYxNTcpXHJcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIGlzUGF0dGVybiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA4NDU0MTQ0KSA9PT0gODQ1NDE0NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCA0LCB0b2tlbiwgYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBhcmd1bWVudCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSAmIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAzMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD1cclxuICAgICAgICAgICAgICAgICAgY2xvc2luZ1Rva2VuID09PSAxMDc0NzkwNDE1ICYmIHRva2VuICE9PSAxMDc3OTM2MTU3XHJcbiAgICAgICAgICAgICAgICAgICAgICA/IDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlci5kZXN0cnVjdGlibGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMzI7XHJcbiAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIGluR3JvdXAsIDEsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgaWYgKHRva2VuID09PSAxMDc3OTM2MTU3ICYmIHRva2VuICE9PSBjbG9zaW5nVG9rZW4gJiYgdG9rZW4gIT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAyNCk7XHJcbiAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCBhcmd1bWVudCk7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gIT09IGNsb3NpbmdUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMSA/IDMyIDogMTY7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlID0gZGVzdHJ1Y3RpYmxlO1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gY2xvc2luZ1Rva2VuICYmIHBhcnNlci50b2tlbiAhPT0gMTA3Mzc0MTg0MilcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNTUpO1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogaXNQYXR0ZXJuID8gJ1Jlc3RFbGVtZW50JyA6ICdTcHJlYWRFbGVtZW50JyxcclxuICAgICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IGNsb3NpbmdUb2tlbikge1xyXG4gICAgICAgICAgaWYgKGtpbmQgJiAxKVxyXG4gICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSBpc0FzeW5jID8gMTYgOiAzMjtcclxuICAgICAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxMDc3OTM2MTU3KSkge1xyXG4gICAgICAgICAgICAgIGlmIChkZXN0cnVjdGlibGUgJiAxNilcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMjQpO1xyXG4gICAgICAgICAgICAgIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHBhcnNlciwgYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMSwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgYXJndW1lbnQgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgaXNQYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFyZ3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBhcmd1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPScsXHJcbiAgICAgICAgICAgICAgICAgICAgICByaWdodFxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgPSAxNjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlID0gZGVzdHJ1Y3RpYmxlO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6IGlzUGF0dGVybiA/ICdSZXN0RWxlbWVudCcgOiAnU3ByZWFkRWxlbWVudCcsXHJcbiAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTWV0aG9kRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIGtpbmQsIGluR3JvdXAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgbW9kaWZpZXJGbGFncyA9IChraW5kICYgNjQpIDwgMSA/IDMxOTgxNTY4IDogMTQ2ODAwNjQ7XHJcbiAgICAgIGNvbnRleHQgPVxyXG4gICAgICAgICAgKChjb250ZXh0IHwgbW9kaWZpZXJGbGFncykgXiBtb2RpZmllckZsYWdzKSB8XHJcbiAgICAgICAgICAgICAgKChraW5kICYgODgpIDw8IDE4KSB8XHJcbiAgICAgICAgICAgICAgMTAwOTI1NDQwO1xyXG4gICAgICBsZXQgc2NvcGUgPSBjb250ZXh0ICYgNjQgPyBhZGRDaGlsZFNjb3BlKGNyZWF0ZVNjb3BlKCksIDUxMikgOiB2b2lkIDA7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcnNlTWV0aG9kRm9ybWFscyhwYXJzZXIsIGNvbnRleHQgfCA4Mzg4NjA4LCBzY29wZSwga2luZCwgMSwgaW5Hcm91cCk7XHJcbiAgICAgIGlmIChzY29wZSlcclxuICAgICAgICAgIHNjb3BlID0gYWRkQ2hpbGRTY29wZShzY29wZSwgMTI4KTtcclxuICAgICAgY29uc3QgYm9keSA9IHBhcnNlRnVuY3Rpb25Cb2R5KHBhcnNlciwgY29udGV4dCAmIH4oMHg4MDAxMDAwIHwgODE5MiksIHNjb3BlLCAwLCB2b2lkIDAsIHZvaWQgMCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgYXN5bmM6IChraW5kICYgMTYpID4gMCxcclxuICAgICAgICAgIGdlbmVyYXRvcjogKGtpbmQgJiA4KSA+IDAsXHJcbiAgICAgICAgICBpZDogbnVsbFxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc2tpcEluaXRpYWxpemVyLCBpbkdyb3VwLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZU9iamVjdExpdGVyYWxPclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCB2b2lkIDAsIHNraXBJbml0aWFsaXplciwgaW5Hcm91cCwgMCwgMiwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIGlmIChjb250ZXh0ICYgMjU2ICYmIHBhcnNlci5kZXN0cnVjdGlibGUgJiA2NCkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNjApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgOCkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNTkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBleHByO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZU9iamVjdExpdGVyYWxPclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgc2tpcEluaXRpYWxpemVyLCBpbkdyb3VwLCBpc1BhdHRlcm4sIGtpbmQsIG9yaWdpbiwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xyXG4gICAgICBsZXQgZGVzdHJ1Y3RpYmxlID0gMDtcclxuICAgICAgbGV0IHByb3RvdHlwZUNvdW50ID0gMDtcclxuICAgICAgY29udGV4dCA9IChjb250ZXh0IHwgMTM0MjE3NzI4KSBeIDEzNDIxNzcyODtcclxuICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiAhPT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5WYWx1ZSwgbGluZVBvcywgY29sUG9zLCB0b2tlblBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgaWYgKHRva2VuID09PSAxNCkge1xyXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwYXJzZVNwcmVhZE9yUmVzdEVsZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMTA3NDc5MDQxNSwga2luZCwgb3JpZ2luLCAwLCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGxldCBzdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgbGV0IGtleSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgbGV0IHZhbHVlO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHQgPSBwYXJzZXIudG9rZW47XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAmICgxNDMzNjAgfCA0MDk2KSB8fCBwYXJzZXIudG9rZW4gPT09IDExOCkge1xyXG4gICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUgfHwgcGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB8PSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiAxMDI0ICYmICh0b2tlbiAmIDUzNzA3OTgwOCkgPT09IDUzNzA3OTgwOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQmluZGluZ0lkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBraW5kLCB0b2tlbiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFyT3JCbG9jayhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCBraW5kLCBvcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDEwNzc5MzYxNTcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAxLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSAmIDI1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyNTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMCB8IChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgMTI4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMTI4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY29udGV4dCAmIC0yMTQ3NDgzNjQ4ID8gT2JqZWN0LmFzc2lnbih7fSwga2V5KSA6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4gPT09IDIwOTAwNSA/IDEyOCA6IDApIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbiA9PT0gMTE4ID8gMTYgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQgJiAtMjE0NzQ4MzY0OCA/IE9iamVjdC5hc3NpZ24oe30sIGtleSkgOiBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblZhbHVlID09PSAnX19wcm90b19fJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAmIDE0MzM2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuQWZ0ZXJDb2xvbiA9IHBhcnNlci50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUFmdGVyQ29sb24gPSBwYXJzZXIudG9rZW5WYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gdCA9PT0gMTE4ID8gMTYgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGtpbmQsIDAsIDEsIDAsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW4gfSA9IHBhcnNlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgdmFsdWUsIGluR3JvdXAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIgfHwgcGFyc2VyLnRva2VuID09PSAxMDc0NzkwNDE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gMTA3NzkzNjE1NyB8fCB0b2tlbiA9PT0gMTA3NDc5MDQxNSB8fCB0b2tlbiA9PT0gMTA3Mzc0MTg0Mikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlci5kZXN0cnVjdGlibGUgJiAxMjggPyAxMjggOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjb3BlICYmICh0b2tlbkFmdGVyQ29sb24gJiAxNDMzNjApID09PSAxNDMzNjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWYXJPckJsb2NrKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHZhbHVlQWZ0ZXJDb2xvbiwga2luZCwgb3JpZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDMyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci50b2tlbiAmIDQxOTQzMDQpID09PSA0MTk0MzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiAhPT0gMTA3NzkzNjE1Nykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDMyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWYXJPckJsb2NrKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHZhbHVlQWZ0ZXJDb2xvbiwga2luZCwgb3JpZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA4NDU0MTQ0KSA9PT0gODQ1NDE0NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCA0LCB0b2tlbiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocGFyc2VyLnRva2VuICYgMjA5NzE1MikgPT09IDIwOTcxNTIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlT2JqZWN0TGl0ZXJhbE9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAwLCBpbkdyb3VwLCBpc1BhdHRlcm4sIGtpbmQsIG9yaWdpbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmRlc3RydWN0aWJsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSAmIDE2ID8gMiA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgNjgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHZhbHVlLCBpbkdyb3VwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmFzc2lnbmFibGUgJiAyID8gMTYgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDQxOTQzMDQpID09PSA0MTk0MzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgODQ1NDE0NCkgPT09IDg0NTQxNDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIDQsIHRva2VuLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHZhbHVlLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSAmIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSwgaW5Hcm91cCwgdG9rZW5Qb3MsIHRva2VuUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgPSBwYXJzZXIuYXNzaWduYWJsZSAmIDIgPyAxNiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIgJiYgdG9rZW4gIT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzc5MzYxNTcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCB0b2tlblBvcywgdG9rZW5Qb3MsIGNvbFBvcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gMTQzNDY4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUgfD1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4gPT09IDEyMzk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMjU2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdG9rZW4gPT09IDEyNDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDUxMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxKSB8IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZUNvbXB1dGVkUHJvcGVydHlOYW1lKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gcGFyc2VyLmFzc2lnbmFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWV0aG9kRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIHN0YXRlLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIudG9rZW4gJiAoMTQzMzYwIHwgNDA5NikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gMTE4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDkyKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gMTQzNDY4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5mbGFncyAmIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEyOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPT09IDEyMzk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMjU2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdG9rZW4gPT09IDEyNDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDUxMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1ldGhvZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGF0ZSwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSA2NzE3NDQxMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUgfD0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VNZXRob2REZWZpbml0aW9uKHBhcnNlciwgY29udGV4dCwgc3RhdGUsIGluR3JvdXAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gODQ1NzAxMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAxMjM5OSB8fCB0b2tlbiA9PT0gMTI0MDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gMTQzNDgwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDggfCAxIHwgKHRva2VuID09PSAxNDM0NjggPyAxNiA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAmIDE0MzM2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci50b2tlbiAmIDEzNDIxNzcyOCkgPT09IDEzNDIxNzcyOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSA2OTI3MTU3MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gcGFyc2VDb21wdXRlZFByb3BlcnR5TmFtZShwYXJzZXIsIGNvbnRleHQsIGluR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSBwYXJzZXIuYXNzaWduYWJsZTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1ldGhvZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGF0ZSwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci50b2tlbiAmIDEzNDIxNzcyOCkgPT09IDEzNDIxNzcyOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAxNDM0NjgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID09PSAxMjM5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDI1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRva2VuID09PSAxMjQwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyA1MTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1ldGhvZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGF0ZSwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMjkpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKChwYXJzZXIudG9rZW4gJiAxMzQyMTc3MjgpID09PSAxMzQyMTc3MjgpIHtcclxuICAgICAgICAgICAgICAgICAga2V5ID0gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDIxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblZhbHVlID09PSAnX19wcm90b19fJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAmIDE0MzM2MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGtpbmQsIDAsIDEsIDAsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW4sIHRva2VuVmFsdWU6IHZhbHVlQWZ0ZXJDb2xvbiB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSAxMDc3OTM2MTU3IHx8IHRva2VuID09PSAxMDc0NzkwNDE1IHx8IHRva2VuID09PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWYXJPckJsb2NrKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHZhbHVlQWZ0ZXJDb2xvbiwga2luZCwgb3JpZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDMyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIGlzUGF0dGVybiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocGFyc2VyLnRva2VuICYgMjA5NzE1MikgPT09IDIwOTcxNTIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlT2JqZWN0TGl0ZXJhbE9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAwLCBpbkdyb3VwLCBpc1BhdHRlcm4sIGtpbmQsIG9yaWdpbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmRlc3RydWN0aWJsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSAmIDE2ID8gMiA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgOCkgIT09IDgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHZhbHVlLCBpbkdyb3VwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmFzc2lnbmFibGUgJiAyID8gMTYgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDQxOTQzMDQpID09PSA0MTk0MzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgODQ1NDE0NCkgPT09IDg0NTQxNDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIDQsIHRva2VuLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHZhbHVlLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDE2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSAmIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgdmFsdWUsIGluR3JvdXAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgPSBwYXJzZXIuYXNzaWduYWJsZSAmIDEgPyAwIDogMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIgJiYgcGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc3OTM2MTU3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIGlzUGF0dGVybiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWV0aG9kRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIHN0YXRlLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSA9IHBhcnNlci5hc3NpZ25hYmxlIHwgMTY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMzApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzEpIHtcclxuICAgICAgICAgICAgICAgICAga2V5ID0gcGFyc2VDb21wdXRlZFByb3BlcnR5TmFtZShwYXJzZXIsIGNvbnRleHQsIGluR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gcGFyc2VyLmRlc3RydWN0aWJsZSAmIDI1NiA/IDI1NiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDI7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDIxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB0b2tlblZhbHVlLCB0b2tlbjogdG9rZW5BZnRlckNvbG9uIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICYgMTQzMzYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwga2luZCwgMCwgMSwgMCwgaW5Hcm91cCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbiB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA0MTk0MzA0KSA9PT0gNDE5NDMwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRva2VuID09PSAxMDc3OTM2MTU3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDMyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyIHx8IHBhcnNlci50b2tlbiA9PT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IDEwNzc5MzYxNTcgfHwgdG9rZW4gPT09IDEwNzQ3OTA0MTUgfHwgdG9rZW4gPT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY29wZSAmJiAodG9rZW5BZnRlckNvbG9uICYgMTQzMzYwKSA9PT0gMTQzMzYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFyT3JCbG9jayhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCBraW5kLCBvcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgJiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocGFyc2VyLnRva2VuICYgMjA5NzE1MikgPT09IDIwOTcxNTIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMCwgaW5Hcm91cCwgaXNQYXR0ZXJuLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlT2JqZWN0TGl0ZXJhbE9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAwLCBpbkdyb3VwLCBpc1BhdHRlcm4sIGtpbmQsIG9yaWdpbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmRlc3RydWN0aWJsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSAmIDE2ID8gMiA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzQ3OTA0MTUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5hc3NpZ25hYmxlICYgMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVzdHJ1Y3RpYmxlICYgOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA1OSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgdmFsdWUsIGluR3JvdXAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgJiAyID8gZGVzdHJ1Y3RpYmxlIHwgMTYgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDQxOTQzMDQpID09PSA0MTk0MzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDc3OTM2MTU3KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbk9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIGlzUGF0dGVybiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA4NDU0MTQ0KSA9PT0gODQ1NDE0NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VCaW5hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgNCwgdG9rZW4sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgdmFsdWUsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgJiAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAzMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5hc3NpZ25hYmxlICYgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAzMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyIHx8IHBhcnNlci50b2tlbiA9PT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLmFzc2lnbmFibGUgJiAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHZhbHVlLCBpbkdyb3VwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gcGFyc2VyLmFzc2lnbmFibGUgJiAxID8gMCA6IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxMDczNzQxODQyICYmIHBhcnNlci50b2tlbiAhPT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTA3NzkzNjE1NylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBpbkdyb3VwLCBpc1BhdHRlcm4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIudG9rZW4gPT09IDY3MTc0NDExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB8PSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1ldGhvZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGF0ZSwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlID0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0MSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IDg0NTcwMTEpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgODQ1NzAxMSk7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDg7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW4sIGxpbmUsIGluZGV4IH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlIHw9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSA2NzE3NDQxMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWV0aG9kRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIHN0YXRlLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydE1lc3NhZ2VBdChpbmRleCwgbGluZSwgaW5kZXgsIHRva2VuID09PSAxNDM0NjhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyA0M1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRva2VuID09PSAxMjM5OSB8fCBwYXJzZXIudG9rZW4gPT09IDEyNDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDQyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDQ0LCBLZXl3b3JkRGVzY1RhYmxlW3Rva2VuICYgMjU1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHBhcnNlci50b2tlbiAmIDEzNDIxNzcyOCkgPT09IDEzNDIxNzcyOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAga2V5ID0gcGFyc2VMaXRlcmFsKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSB8PSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1ldGhvZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBzdGF0ZSwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSA2OTI3MTU3MSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUgfD0gMiB8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZUNvbXB1dGVkUHJvcGVydHlOYW1lKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTWV0aG9kRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIHN0YXRlLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEyMik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3Rva2VuICYgMjU1XSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSBwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgMTI4ID8gMTI4IDogMDtcclxuICAgICAgICAgICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlID0gZGVzdHJ1Y3RpYmxlO1xyXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnUHJvcGVydHknLFxyXG4gICAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgIGtpbmQ6ICEoc3RhdGUgJiA3NjgpID8gJ2luaXQnIDogc3RhdGUgJiA1MTIgPyAnc2V0JyA6ICdnZXQnLFxyXG4gICAgICAgICAgICAgICAgICBjb21wdXRlZDogKHN0YXRlICYgMikgPiAwLFxyXG4gICAgICAgICAgICAgICAgICBtZXRob2Q6IChzdGF0ZSAmIDEpID4gMCxcclxuICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kOiAoc3RhdGUgJiA0KSA+IDBcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gcGFyc2VyLmRlc3RydWN0aWJsZTtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIpXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTA3NDc5MDQxNSk7XHJcbiAgICAgIGlmIChwcm90b3R5cGVDb3VudCA+IDEpXHJcbiAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gNjQ7XHJcbiAgICAgIGNvbnN0IG5vZGUgPSBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogaXNQYXR0ZXJuID8gJ09iamVjdFBhdHRlcm4nIDogJ09iamVjdEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgcHJvcGVydGllc1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFza2lwSW5pdGlhbGl6ZXIgJiYgcGFyc2VyLnRva2VuICYgNDE5NDMwNCkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlPck9iamVjdEFzc2lnbm1lbnRQYXR0ZXJuKHBhcnNlciwgY29udGV4dCwgZGVzdHJ1Y3RpYmxlLCBpbkdyb3VwLCBpc1BhdHRlcm4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIG5vZGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcnNlci5kZXN0cnVjdGlibGUgPSBkZXN0cnVjdGlibGU7XHJcbiAgICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZU1ldGhvZEZvcm1hbHMocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCwgdHlwZSwgaW5Hcm91cCkge1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgNjcxNzQ0MTEpO1xyXG4gICAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgICAgcGFyc2VyLmZsYWdzID0gKHBhcnNlci5mbGFncyB8IDEyOCkgXiAxMjg7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDE2KSB7XHJcbiAgICAgICAgICBpZiAoa2luZCAmIDUxMikge1xyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDM1LCAnU2V0dGVyJywgJ29uZScsICcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgICAgfVxyXG4gICAgICBpZiAoa2luZCAmIDI1Nikge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMzUsICdHZXR0ZXInLCAnbm8nLCAncycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChraW5kICYgNTEyICYmIHBhcnNlci50b2tlbiA9PT0gMTQpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDM2KTtcclxuICAgICAgfVxyXG4gICAgICBjb250ZXh0ID0gKGNvbnRleHQgfCAxMzQyMTc3MjgpIF4gMTM0MjE3NzI4O1xyXG4gICAgICBsZXQgc2V0dGVyQXJncyA9IDA7XHJcbiAgICAgIGxldCBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAwO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLnRva2VuICE9PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICBsZXQgbGVmdCA9IG51bGw7XHJcbiAgICAgICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgICAgICBpZiAoKGNvbnRleHQgJiAxMDI0KSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAzNjg2NCkgPT09IDM2ODY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gMjU2O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gNTEyO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxlZnQgPSBwYXJzZUFuZENsYXNzaWZ5SWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBraW5kIHwgMSwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAyMTYyNzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxlZnQgPSBwYXJzZU9iamVjdExpdGVyYWxPclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMSwgaW5Hcm91cCwgMSwgdHlwZSwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzEpIHtcclxuICAgICAgICAgICAgICAgICAgbGVmdCA9IHBhcnNlQXJyYXlFeHByZXNzaW9uT3JQYXR0ZXJuKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDEsIGluR3JvdXAsIDEsIHR5cGUsIDAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIudG9rZW4gPT09IDE0KSB7XHJcbiAgICAgICAgICAgICAgICAgIGxlZnQgPSBwYXJzZVNwcmVhZE9yUmVzdEVsZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMTYsIHR5cGUsIDAsIDAsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAxO1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgKDMyIHwgMTYpKVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0Nyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgICAgICBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAxO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMSwgMCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgbGVmdCA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50UGF0dGVybicsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgICAgICAgICAgIHJpZ2h0XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZXR0ZXJBcmdzKys7XHJcbiAgICAgICAgICBwYXJhbXMucHVzaChsZWZ0KTtcclxuICAgICAgICAgIGlmICghY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQsIDEwNzM3NDE4NDIpKVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTYpIHtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoa2luZCAmIDUxMiAmJiBzZXR0ZXJBcmdzICE9PSAxKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAzNSwgJ1NldHRlcicsICdvbmUnLCAnJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNjb3BlICYmIHNjb3BlLnNjb3BlRXJyb3IgIT09IHZvaWQgMClcclxuICAgICAgICAgIHJlcG9ydFNjb3BlRXJyb3Ioc2NvcGUuc2NvcGVFcnJvcik7XHJcbiAgICAgIGlmIChpc1NpbXBsZVBhcmFtZXRlckxpc3QpXHJcbiAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gMTI4O1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTYpO1xyXG4gICAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkUHJvcGVydHlOYW1lKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCkge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICBjb25zdCBrZXkgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCAoY29udGV4dCB8IDEzNDIxNzcyOCkgXiAxMzQyMTc3MjgsIDEsIDAsIGluR3JvdXAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMjApO1xyXG4gICAgICByZXR1cm4ga2V5O1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgY2FuQXNzaWduLCBraW5kLCBvcmlnaW4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgcGFyc2VyLmZsYWdzID0gKHBhcnNlci5mbGFncyB8IDEyOCkgXiAxMjg7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCB8IDEwNzM3NDE4MjQpO1xyXG4gICAgICBjb25zdCBzY29wZSA9IGNvbnRleHQgJiA2NCA/IGFkZENoaWxkU2NvcGUoY3JlYXRlU2NvcGUoKSwgMTAyNCkgOiB2b2lkIDA7XHJcbiAgICAgIGNvbnRleHQgPSAoY29udGV4dCB8IDEzNDIxNzcyOCB8IDgxOTIpIF4gKDgxOTIgfCAxMzQyMTc3MjgpO1xyXG4gICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQsIDE2KSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyZW50aGVzaXplZEFycm93KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIFtdLCBjYW5Bc3NpZ24sIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkZXN0cnVjdGlibGUgPSAwO1xyXG4gICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlICY9IH4oMjU2IHwgMTI4KTtcclxuICAgICAgbGV0IGV4cHI7XHJcbiAgICAgIGxldCBleHByZXNzaW9ucyA9IFtdO1xyXG4gICAgICBsZXQgaXNTZXF1ZW5jZSA9IDA7XHJcbiAgICAgIGxldCBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAwO1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zOiBpU3RhcnQsIGxpbmVQb3M6IGxTdGFydCwgY29sUG9zOiBjU3RhcnQgfSA9IHBhcnNlcjtcclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAxO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLnRva2VuICE9PSAxNikge1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgaWYgKHRva2VuICYgKDE0MzM2MCB8IDQwOTYpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgICAgICAgICBhZGRCbG9ja05hbWUocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgcGFyc2VyLnRva2VuVmFsdWUsIDEsIDApO1xyXG4gICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwga2luZCwgMCwgMSwgMCwgMSwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTYgfHwgcGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlzU2ltcGxlUGFyYW1ldGVyTGlzdCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHRva2VuICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAodG9rZW4gJiAzNjg2NCkgPT09IDM2ODY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAxO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAxO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGV4cHIsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSAxNiAmJiBwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgZXhwcik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmICgodG9rZW4gJiAyMDk3MTUyKSA9PT0gMjA5NzE1Mikge1xyXG4gICAgICAgICAgICAgIGV4cHIgPVxyXG4gICAgICAgICAgICAgICAgICB0b2tlbiA9PT0gMjE2MjcwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZU9iamVjdExpdGVyYWxPclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0IHwgMTA3Mzc0MTgyNCwgc2NvcGUsIDAsIDEsIDAsIGtpbmQsIG9yaWdpbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcylcclxuICAgICAgICAgICAgICAgICAgICAgIDogcGFyc2VBcnJheUV4cHJlc3Npb25PclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0IHwgMTA3Mzc0MTgyNCwgc2NvcGUsIDAsIDEsIDAsIGtpbmQsIG9yaWdpbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IHBhcnNlci5kZXN0cnVjdGlibGU7XHJcbiAgICAgICAgICAgICAgaXNTaW1wbGVQYXJhbWV0ZXJMaXN0ID0gMTtcclxuICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTYgJiYgcGFyc2VyLnRva2VuICE9PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChkZXN0cnVjdGlibGUgJiA4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE4KTtcclxuICAgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTYgJiYgcGFyc2VyLnRva2VuICE9PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIDAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MsIGV4cHIpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IDE0KSB7XHJcbiAgICAgICAgICAgICAgZXhwciA9IHBhcnNlU3ByZWFkT3JSZXN0RWxlbWVudChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAxNiwga2luZCwgb3JpZ2luLCAwLCAxLCAwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDE2KVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA3MSk7XHJcbiAgICAgICAgICAgICAgaXNTaW1wbGVQYXJhbWV0ZXJMaXN0ID0gMTtcclxuICAgICAgICAgICAgICBpZiAoaXNTZXF1ZW5jZSAmJiAocGFyc2VyLnRva2VuID09PSAxNiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSA4O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IDE2O1xyXG4gICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICBpZiAoaXNTZXF1ZW5jZSAmJiAocGFyc2VyLnRva2VuID09PSAxNiB8fCBwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFpc1NlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpc1NlcXVlbmNlID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW2V4cHJdO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChpc1NlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxMDczNzQxODQyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAxLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICBleHByID0gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIGlTdGFydCwgbFN0YXJ0LCBjU3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAxNik7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSA9IGRlc3RydWN0aWJsZTtcclxuICAgICAgICAgICAgICByZXR1cm4gZXhwcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpc1NlcXVlbmNlICYmIChwYXJzZXIudG9rZW4gPT09IDE2IHx8IHBhcnNlci50b2tlbiA9PT0gMTA3Mzc0MTg0MikpIHtcclxuICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAxMDczNzQxODQyKSlcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGlmICghaXNTZXF1ZW5jZSkge1xyXG4gICAgICAgICAgICAgIGlzU2VxdWVuY2UgPSAxO1xyXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW2V4cHJdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTYpIHtcclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gODtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNTZXF1ZW5jZSkge1xyXG4gICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgZXhwciA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBpU3RhcnQsIGxTdGFydCwgY1N0YXJ0LCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbnNcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAxNik7XHJcbiAgICAgIGlmIChkZXN0cnVjdGlibGUgJiAxNiAmJiBkZXN0cnVjdGlibGUgJiA4KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTQ1KTtcclxuICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgMjU2XHJcbiAgICAgICAgICAgICAgPyAyNTZcclxuICAgICAgICAgICAgICA6IDAgfCAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDEyOClcclxuICAgICAgICAgICAgICAgICAgPyAxMjhcclxuICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMCkge1xyXG4gICAgICAgICAgaWYgKGRlc3RydWN0aWJsZSAmICgzMiB8IDE2KSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0Nik7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmICg0MTk0MzA0IHwgMjA0OCkgJiYgZGVzdHJ1Y3RpYmxlICYgMTI4KVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI5KTtcclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgKDEwMjQgfCAyMDk3MTUyKSAmJiBkZXN0cnVjdGlibGUgJiAyNTYpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAzMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXNTaW1wbGVQYXJhbWV0ZXJMaXN0KVxyXG4gICAgICAgICAgICAgIHBhcnNlci5mbGFncyB8PSAxMjg7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJlbnRoZXNpemVkQXJyb3cocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgaXNTZXF1ZW5jZSA/IGV4cHJlc3Npb25zIDogW2V4cHJdLCBjYW5Bc3NpZ24sIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGRlc3RydWN0aWJsZSAmIDgpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEzOSk7XHJcbiAgICAgIH1cclxuICAgICAgcGFyc2VyLmRlc3RydWN0aWJsZSA9ICgocGFyc2VyLmRlc3RydWN0aWJsZSB8IDI1NikgXiAyNTYpIHwgZGVzdHJ1Y3RpYmxlO1xyXG4gICAgICByZXR1cm4gY29udGV4dCAmIDEyOFxyXG4gICAgICAgICAgPyBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgaVN0YXJ0LCBsU3RhcnQsIGNTdGFydCwge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdQYXJlbnRoZXNpemVkRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwclxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIDogZXhwcjtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VJZGVudGlmaWVyT3JBcnJvdyhwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgeyB0b2tlblZhbHVlIH0gPSBwYXJzZXI7XHJcbiAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAxO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMCkge1xyXG4gICAgICAgICAgbGV0IHNjb3BlID0gdm9pZCAwO1xyXG4gICAgICAgICAgaWYgKGNvbnRleHQgJiA2NClcclxuICAgICAgICAgICAgICBzY29wZSA9IGNyZWF0ZUFycm93SGVhZFBhcnNpbmdTY29wZShwYXJzZXIsIGNvbnRleHQsIHRva2VuVmFsdWUpO1xyXG4gICAgICAgICAgcGFyc2VyLmZsYWdzID0gKHBhcnNlci5mbGFncyB8IDEyOCkgXiAxMjg7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBbZXhwcl0sIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBleHByO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUFycm93RnJvbUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSwgZXhwciwgaW5OZXcsIGNhbkFzc2lnbiwgaXNBc3luYywgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBpZiAoIWNhbkFzc2lnbilcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDU0KTtcclxuICAgICAgaWYgKGluTmV3KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNDgpO1xyXG4gICAgICBwYXJzZXIuZmxhZ3MgJj0gfjEyODtcclxuICAgICAgY29uc3Qgc2NvcGUgPSBjb250ZXh0ICYgNjQgPyBjcmVhdGVBcnJvd0hlYWRQYXJzaW5nU2NvcGUocGFyc2VyLCBjb250ZXh0LCB2YWx1ZSkgOiB2b2lkIDA7XHJcbiAgICAgIHJldHVybiBwYXJzZUFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIFtleHByXSwgaXNBc3luYywgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlUGFyZW50aGVzaXplZEFycm93KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIHBhcmFtcywgY2FuQXNzaWduLCBpc0FzeW5jLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmICghY2FuQXNzaWduKVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNTQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgIHJlaW50ZXJwcmV0VG9QYXR0ZXJuKHBhcnNlciwgcGFyYW1zW2ldKTtcclxuICAgICAgcmV0dXJuIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgcGFyYW1zLCBpc0FzeW5jLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBwYXJhbXMsIGlzQXN5bmMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgaWYgKHBhcnNlci5mbGFncyAmIDEpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA0NSk7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDEwKTtcclxuICAgICAgY29udGV4dCA9ICgoY29udGV4dCB8IDE1NzI4NjQwKSBeIDE1NzI4NjQwKSB8IChpc0FzeW5jIDw8IDIyKTtcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlci50b2tlbiAhPT0gMjE2MjcwMDtcclxuICAgICAgbGV0IGJvZHk7XHJcbiAgICAgIGlmIChzY29wZSAmJiBzY29wZS5zY29wZUVycm9yICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgIHJlcG9ydFNjb3BlRXJyb3Ioc2NvcGUuc2NvcGVFcnJvcik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcclxuICAgICAgICAgIGJvZHkgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmIChzY29wZSlcclxuICAgICAgICAgICAgICBzY29wZSA9IGFkZENoaWxkU2NvcGUoc2NvcGUsIDEyOCk7XHJcbiAgICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvbkJvZHkocGFyc2VyLCAoY29udGV4dCB8IDEzNDIyMTgyNCB8IDgxOTIgfCAxNjM4NCkgXlxyXG4gICAgICAgICAgICAgICgxMzQyMjE4MjQgfCA4MTkyIHwgMTYzODQpLCBzY29wZSwgMTYsIHZvaWQgMCwgdm9pZCAwKTtcclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnRva2VuKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSA2OTI3MTU3MTpcclxuICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIuZmxhZ3MgJiAxKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExMik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSA2NzEwODg3NzpcclxuICAgICAgICAgICAgICBjYXNlIDY3MTc0NDA5OlxyXG4gICAgICAgICAgICAgIGNhc2UgMjI6XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExMyk7XHJcbiAgICAgICAgICAgICAgY2FzZSA2NzE3NDQxMTpcclxuICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIuZmxhZ3MgJiAxKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDExMik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgcGFyc2VyLmZsYWdzIHw9IDEwMjQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA4NDU0MTQ0KSA9PT0gODQ1NDE0NCAmJiAocGFyc2VyLmZsYWdzICYgMSkgPCAxKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAzMzYxOTk2OCkgPT09IDMzNjE5OTY4KVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEyMSk7XHJcbiAgICAgIH1cclxuICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgYXN5bmM6IGlzQXN5bmMgPT09IDEsXHJcbiAgICAgICAgICBleHByZXNzaW9uXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUZvcm1hbFBhcmFtZXRlcnNPckZvcm1hbExpc3QocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgaW5Hcm91cCwga2luZCkge1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgNjcxNzQ0MTEpO1xyXG4gICAgICBwYXJzZXIuZmxhZ3MgPSAocGFyc2VyLmZsYWdzIHwgMTI4KSBeIDEyODtcclxuICAgICAgY29uc3QgcGFyYW1zID0gW107XHJcbiAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCwgMTYpKVxyXG4gICAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgICAgY29udGV4dCA9IChjb250ZXh0IHwgMTM0MjE3NzI4KSBeIDEzNDIxNzcyODtcclxuICAgICAgbGV0IGlzU2ltcGxlUGFyYW1ldGVyTGlzdCA9IDA7XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gIT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgIGxldCBsZWZ0O1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICYgMTQzMzYwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKChjb250ZXh0ICYgMTAyNCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgMzY4NjQpID09PSAzNjg2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmZsYWdzIHw9IDI1NjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDUzNzA3OTgwOCkgPT09IDUzNzA3OTgwOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmZsYWdzIHw9IDUxMjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VBbmRDbGFzc2lmeUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCB8IDEsIDAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMjE2MjcwMCkge1xyXG4gICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VPYmplY3RMaXRlcmFsT3JQYXR0ZXJuKHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDEsIGluR3JvdXAsIDEsIGtpbmQsIDAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZXIudG9rZW4gPT09IDY5MjcxNTcxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxlZnQgPSBwYXJzZUFycmF5RXhwcmVzc2lvbk9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAxLCBpbkdyb3VwLCAxLCBraW5kLCAwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSAxNCkge1xyXG4gICAgICAgICAgICAgICAgICBsZWZ0ID0gcGFyc2VTcHJlYWRPclJlc3RFbGVtZW50KHBhcnNlciwgY29udGV4dCwgc2NvcGUsIDE2LCBraW5kLCAwLCAwLCBpbkdyb3VwLCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAxO1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgKDMyIHwgMTYpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDQ3KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCB8IDMyNzY4KTtcclxuICAgICAgICAgICAgICBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAxO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMSwgaW5Hcm91cCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgbGVmdCA9IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50UGF0dGVybicsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgICAgICAgIHJpZ2h0XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXJhbXMucHVzaChsZWZ0KTtcclxuICAgICAgICAgIGlmICghY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQsIDEwNzM3NDE4NDIpKVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTYpIHtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNTaW1wbGVQYXJhbWV0ZXJMaXN0KVxyXG4gICAgICAgICAgcGFyc2VyLmZsYWdzIHw9IDEyODtcclxuICAgICAgaWYgKHNjb3BlICYmIChpc1NpbXBsZVBhcmFtZXRlckxpc3QgfHwgY29udGV4dCAmIDEwMjQpICYmIHNjb3BlLnNjb3BlRXJyb3IgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgcmVwb3J0U2NvcGVFcnJvcihzY29wZS5zY29wZUVycm9yKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTYpO1xyXG4gICAgICByZXR1cm4gcGFyYW1zO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZU1lbWJlRXhwcmVzc2lvbk5vQ2FsbChwYXJzZXIsIGNvbnRleHQsIGV4cHIsIGluR3JvdXAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgeyB0b2tlbiB9ID0gcGFyc2VyO1xyXG4gICAgICBpZiAodG9rZW4gJiA2NzEwODg2NCkge1xyXG4gICAgICAgICAgaWYgKHRva2VuID09PSA2NzEwODg3Nykge1xyXG4gICAgICAgICAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAxMDczNzQxODI0KTtcclxuICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDE7XHJcbiAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwYXJzZVByb3BlcnR5T3JQcml2YXRlUHJvcGVydHlOYW1lKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTWVtYmVFeHByZXNzaW9uTm9DYWxsKHBhcnNlciwgY29udGV4dCwgZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICBvYmplY3Q6IGV4cHIsXHJcbiAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgcHJvcGVydHlcclxuICAgICAgICAgICAgICB9KSwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gNjkyNzE1NzEpIHtcclxuICAgICAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcGFyc2VFeHByZXNzaW9ucyhwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAyMCk7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAxO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZU1lbWJlRXhwcmVzc2lvbk5vQ2FsbChwYXJzZXIsIGNvbnRleHQsIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcclxuICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxyXG4gICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgcHJvcGVydHlcclxuICAgICAgICAgICAgICB9KSwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gNjcxNzQ0MDggfHwgdG9rZW4gPT09IDY3MTc0NDA5KSB7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZU1lbWJlRXhwcmVzc2lvbk5vQ2FsbChwYXJzZXIsIGNvbnRleHQsIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zLCB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICB0YWc6IGV4cHIsXHJcbiAgICAgICAgICAgICAgICAgIHF1YXNpOiBwYXJzZXIudG9rZW4gPT09IDY3MTc0NDA4XHJcbiAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlVGVtcGxhdGUocGFyc2VyLCBjb250ZXh0IHwgNjU1MzYsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHBhcnNlVGVtcGxhdGVMaXRlcmFsKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbilcclxuICAgICAgICAgICAgICB9KSwgMCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGluR3JvdXAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgaWQgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgsIDApO1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCA2NzEwODg3NykpIHtcclxuICAgICAgICAgIGlmIChjb250ZXh0ICYgNjcxMDg4NjQgJiYgcGFyc2VyLnRva2VuID09PSAxNDM0OTEpIHtcclxuICAgICAgICAgICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlTWV0YVByb3BlcnR5KHBhcnNlciwgY29udGV4dCwgaWQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgOTEpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAxNjg0Mjc1MikgPT09IDE2ODQyNzUyKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA2MiwgS2V5d29yZERlc2NUYWJsZVtwYXJzZXIudG9rZW4gJiAyNTVdKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDIsIDEsIDAsIDAsIGluR3JvdXAsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICBjb250ZXh0ID0gKGNvbnRleHQgfCAxMzQyMTc3MjgpIF4gMTM0MjE3NzI4O1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSA2NzEwODk4OClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDE2Mik7XHJcbiAgICAgIGNvbnN0IGNhbGxlZSA9IHBhcnNlTWVtYmVFeHByZXNzaW9uTm9DYWxsKHBhcnNlciwgY29udGV4dCwgZXhwciwgaW5Hcm91cCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnTmV3RXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBjYWxsZWUsXHJcbiAgICAgICAgICBhcmd1bWVudHM6IHBhcnNlci50b2tlbiA9PT0gNjcxNzQ0MTEgPyBwYXJzZUFyZ3VtZW50cyhwYXJzZXIsIGNvbnRleHQsIGluR3JvdXApIDogW11cclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlTWV0YVByb3BlcnR5KHBhcnNlciwgY29udGV4dCwgbWV0YSwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHBhcnNlSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdNZXRhUHJvcGVydHknLFxyXG4gICAgICAgICAgbWV0YSxcclxuICAgICAgICAgIHByb3BlcnR5XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUFzeW5jQXJyb3dBZnRlcklkZW50KHBhcnNlciwgY29udGV4dCwgY2FuQXNzaWduLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDIwOTAwNSlcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI5KTtcclxuICAgICAgaWYgKGNvbnRleHQgJiAoMTAyNCB8IDIwOTcxNTIpICYmIHBhcnNlci50b2tlbiA9PT0gMjQxNzcwKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAzMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA1MzcwNzk4MDgpID09PSA1MzcwNzk4MDgpIHtcclxuICAgICAgICAgIHBhcnNlci5mbGFncyB8PSA1MTI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcnNlQXJyb3dGcm9tSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblZhbHVlLCBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKSwgMCwgY2FuQXNzaWduLCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VBc3luY0Fycm93T3JDYWxsRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIGNhbGxlZSwgY2FuQXNzaWduLCBraW5kLCBvcmlnaW4sIGZsYWdzLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIGNvbnN0IHNjb3BlID0gY29udGV4dCAmIDY0ID8gYWRkQ2hpbGRTY29wZShjcmVhdGVTY29wZSgpLCAxMDI0KSA6IHZvaWQgMDtcclxuICAgICAgY29udGV4dCA9IChjb250ZXh0IHwgMTM0MjE3NzI4KSBeIDEzNDIxNzcyODtcclxuICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCAxNikpIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGZsYWdzICYgMSlcclxuICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgNDUpO1xyXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVBhcmVudGhlc2l6ZWRBcnJvdyhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBbXSwgY2FuQXNzaWduLCAxLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdDYWxsRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICAgICAgY2FsbGVlLFxyXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogW11cclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkZXN0cnVjdGlibGUgPSAwO1xyXG4gICAgICBsZXQgZXhwciA9IG51bGw7XHJcbiAgICAgIGxldCBpc1NpbXBsZVBhcmFtZXRlckxpc3QgPSAwO1xyXG4gICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlID1cclxuICAgICAgICAgIChwYXJzZXIuZGVzdHJ1Y3RpYmxlIHwgMjU2IHwgMTI4KSBeXHJcbiAgICAgICAgICAgICAgKDI1NiB8IDEyOCk7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLnRva2VuICE9PSAxNikge1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgaWYgKHRva2VuICYgKDE0MzM2MCB8IDQwOTYpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgICAgICAgICBhZGRCbG9ja05hbWUocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgcGFyc2VyLnRva2VuVmFsdWUsIGtpbmQsIDApO1xyXG4gICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwga2luZCwgMCwgMSwgMCwgMSwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTYgfHwgcGFyc2VyLnRva2VuID09PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuYXNzaWduYWJsZSAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgIGlzU2ltcGxlUGFyYW1ldGVyTGlzdCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHRva2VuICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gNTEyO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0b2tlbiAmIDM2ODY0KSA9PT0gMzY4NjQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5mbGFncyB8PSAyNTY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwNzc5MzYxNTcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlzU2ltcGxlUGFyYW1ldGVyTGlzdCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gMTY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDE2ICYmIHBhcnNlci50b2tlbiAhPT0gMTA3Mzc0MTg0Mikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCBleHByKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHRva2VuICYgMjA5NzE1Mikge1xyXG4gICAgICAgICAgICAgIGV4cHIgPVxyXG4gICAgICAgICAgICAgICAgICB0b2tlbiA9PT0gMjE2MjcwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZU9iamVjdExpdGVyYWxPclBhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMCwgMSwgMCwga2luZCwgb3JpZ2luLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBwYXJzZUFycmF5RXhwcmVzc2lvbk9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAwLCAxLCAwLCBraW5kLCBvcmlnaW4sIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSBwYXJzZXIuZGVzdHJ1Y3RpYmxlO1xyXG4gICAgICAgICAgICAgIGlzU2ltcGxlUGFyYW1ldGVyTGlzdCA9IDE7XHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci50b2tlbiAhPT0gMTYgJiYgcGFyc2VyLnRva2VuICE9PSAxMDczNzQxODQyKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChkZXN0cnVjdGlibGUgJiA4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE4KTtcclxuICAgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlTWVtYmVyT3JVcGRhdGVFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgZXhwciwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgIGRlc3RydWN0aWJsZSB8PSAxNjtcclxuICAgICAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA4NDU0MTQ0KSA9PT0gODQ1NDE0NCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIDQsIHRva2VuLCBleHByKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09PSAxNCkge1xyXG4gICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVNwcmVhZE9yUmVzdEVsZW1lbnQocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgMTYsIGtpbmQsIG9yaWdpbiwgMSwgMSwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICAgICAgZGVzdHJ1Y3RpYmxlIHw9IChwYXJzZXIudG9rZW4gPT09IDE2ID8gMCA6IDE2KSB8IHBhcnNlci5kZXN0cnVjdGlibGU7XHJcbiAgICAgICAgICAgICAgaXNTaW1wbGVQYXJhbWV0ZXJMaXN0ID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAxLCAwLCAwLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgPSBwYXJzZXIuYXNzaWduYWJsZTtcclxuICAgICAgICAgICAgICBwYXJhbXMucHVzaChleHByKTtcclxuICAgICAgICAgICAgICB3aGlsZSAoY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTA3Mzc0MTg0MikpIHtcclxuICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcykpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkZXN0cnVjdGlibGUgfD0gcGFyc2VyLmFzc2lnbmFibGU7XHJcbiAgICAgICAgICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDE2KTtcclxuICAgICAgICAgICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlID0gZGVzdHJ1Y3RpYmxlIHwgMTY7XHJcbiAgICAgICAgICAgICAgcGFyc2VyLmFzc2lnbmFibGUgPSAyO1xyXG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgICAgICBjYWxsZWUsXHJcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogcGFyYW1zXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXJhbXMucHVzaChleHByKTtcclxuICAgICAgICAgIGlmICghY29uc3VtZU9wdChwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMTA3Mzc0MTg0MikpXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDE2KTtcclxuICAgICAgZGVzdHJ1Y3RpYmxlIHw9XHJcbiAgICAgICAgICBwYXJzZXIuZGVzdHJ1Y3RpYmxlICYgMjU2XHJcbiAgICAgICAgICAgICAgPyAyNTZcclxuICAgICAgICAgICAgICA6IDAgfCAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDEyOClcclxuICAgICAgICAgICAgICAgICAgPyAxMjhcclxuICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMCkge1xyXG4gICAgICAgICAgaWYgKGRlc3RydWN0aWJsZSAmICgzMiB8IDE2KSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAyNSk7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLmZsYWdzICYgMSB8fCBmbGFncyAmIDEpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgNDUpO1xyXG4gICAgICAgICAgaWYgKGRlc3RydWN0aWJsZSAmIDEyOClcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAyOSk7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCAmICgxMDI0IHwgMjA5NzE1MikgJiYgZGVzdHJ1Y3RpYmxlICYgMjU2KVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDMwKTtcclxuICAgICAgICAgIGlmIChpc1NpbXBsZVBhcmFtZXRlckxpc3QpXHJcbiAgICAgICAgICAgICAgcGFyc2VyLmZsYWdzIHw9IDEyODtcclxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmVudGhlc2l6ZWRBcnJvdyhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBwYXJhbXMsIGNhbkFzc2lnbiwgMSwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoZGVzdHJ1Y3RpYmxlICYgOCkge1xyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNTkpO1xyXG4gICAgICB9XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nLFxyXG4gICAgICAgICAgY2FsbGVlLFxyXG4gICAgICAgICAgYXJndW1lbnRzOiBwYXJhbXNcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlUmVnRXhwTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgeyB0b2tlblJhdywgdG9rZW5SZWdFeHAsIHRva2VuVmFsdWUgfSA9IHBhcnNlcjtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIHBhcnNlci5hc3NpZ25hYmxlID0gMjtcclxuICAgICAgcmV0dXJuIGNvbnRleHQgJiA1MTJcclxuICAgICAgICAgID8gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgICAgICB0eXBlOiAnTGl0ZXJhbCcsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHRva2VuVmFsdWUsXHJcbiAgICAgICAgICAgICAgcmVnZXg6IHRva2VuUmVnRXhwLFxyXG4gICAgICAgICAgICAgIHJhdzogdG9rZW5SYXdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICA6IGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0b2tlblZhbHVlLFxyXG4gICAgICAgICAgICAgIHJlZ2V4OiB0b2tlblJlZ0V4cFxyXG4gICAgICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBmbGFncywgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb250ZXh0ID0gKGNvbnRleHQgfCAxNjc3NzIxNiB8IDEwMjQpIF4gMTY3NzcyMTY7XHJcbiAgICAgIGNvbnN0IGRlY29yYXRvcnMgPSBjb250ZXh0ICYgMSA/IHBhcnNlRGVjb3JhdG9ycyhwYXJzZXIsIGNvbnRleHQpIDogW107XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBsZXQgaWQgPSBudWxsO1xyXG4gICAgICBsZXQgc3VwZXJDbGFzcyA9IG51bGw7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSB9ID0gcGFyc2VyO1xyXG4gICAgICBpZiAoKChwYXJzZXIudG9rZW4gJiA0MzUxKSBeIDg0KSA+XHJcbiAgICAgICAgICA0MDk2KSB7XHJcbiAgICAgICAgICBpZiAoaXNTdHJpY3RSZXNlcnZlZFdvcmQocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgocGFyc2VyLnRva2VuICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzY29wZSkge1xyXG4gICAgICAgICAgICAgIGFkZEJsb2NrTmFtZShwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCAzMiwgMCk7XHJcbiAgICAgICAgICAgICAgaWYgKGZsYWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmVVbmJvdW5kVmFyaWFibGUocGFyc2VyLCB0b2tlblZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlkID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPCAxKVxyXG4gICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDM3LCAnQ2xhc3MnKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgaW5oZXJpdGVkQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMDU2NCkpIHtcclxuICAgICAgICAgIHN1cGVyQ2xhc3MgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAwLCAwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgIGluaGVyaXRlZENvbnRleHQgfD0gNTI0Mjg4O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaW5oZXJpdGVkQ29udGV4dCA9IChpbmhlcml0ZWRDb250ZXh0IHwgNTI0Mjg4KSBeIDUyNDI4ODtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBib2R5ID0gcGFyc2VDbGFzc0JvZHkocGFyc2VyLCBpbmhlcml0ZWRDb250ZXh0LCBjb250ZXh0LCBzY29wZSwgMiwgOCwgMCk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgY29udGV4dCAmIDFcclxuICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdDbGFzc0RlY2xhcmF0aW9uJyxcclxuICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICBzdXBlckNsYXNzLFxyXG4gICAgICAgICAgICAgIGRlY29yYXRvcnMsXHJcbiAgICAgICAgICAgICAgYm9keVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0NsYXNzRGVjbGFyYXRpb24nLFxyXG4gICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MsXHJcbiAgICAgICAgICAgICAgYm9keVxyXG4gICAgICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQ2xhc3NFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBsZXQgaWQgPSBudWxsO1xyXG4gICAgICBsZXQgc3VwZXJDbGFzcyA9IG51bGw7XHJcbiAgICAgIGNvbnRleHQgPSAoY29udGV4dCB8IDEwMjQgfCAxNjc3NzIxNikgXiAxNjc3NzIxNjtcclxuICAgICAgY29uc3QgZGVjb3JhdG9ycyA9IGNvbnRleHQgJiAxID8gcGFyc2VEZWNvcmF0b3JzKHBhcnNlciwgY29udGV4dCkgOiBbXTtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGlmICgoKHBhcnNlci50b2tlbiAmIDB4MTBmZikgXiAweDU0KSA+IDB4MTAwMCkge1xyXG4gICAgICAgICAgaWYgKGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHBhcnNlciwgY29udGV4dCwgcGFyc2VyLnRva2VuKSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTQpO1xyXG4gICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiA1MzcwNzk4MDgpID09PSA1MzcwNzk4MDgpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWQgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgaW5oZXJpdGVkQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgIGlmIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCB8IDMyNzY4LCAyMDU2NCkpIHtcclxuICAgICAgICAgIHN1cGVyQ2xhc3MgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCAwLCBpbkdyb3VwLCAwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgICAgIGluaGVyaXRlZENvbnRleHQgfD0gNTI0Mjg4O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaW5oZXJpdGVkQ29udGV4dCA9IChpbmhlcml0ZWRDb250ZXh0IHwgNTI0Mjg4KSBeIDUyNDI4ODtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBib2R5ID0gcGFyc2VDbGFzc0JvZHkocGFyc2VyLCBpbmhlcml0ZWRDb250ZXh0LCBjb250ZXh0LCB2b2lkIDAsIDIsIDAsIGluR3JvdXApO1xyXG4gICAgICBwYXJzZXIuYXNzaWduYWJsZSA9IDI7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwgY29udGV4dCAmIDFcclxuICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdDbGFzc0V4cHJlc3Npb24nLFxyXG4gICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgIHN1cGVyQ2xhc3MsXHJcbiAgICAgICAgICAgICAgZGVjb3JhdG9ycyxcclxuICAgICAgICAgICAgICBib2R5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnQ2xhc3NFeHByZXNzaW9uJyxcclxuICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICBzdXBlckNsYXNzLFxyXG4gICAgICAgICAgICAgIGJvZHlcclxuICAgICAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZURlY29yYXRvcnMocGFyc2VyLCBjb250ZXh0KSB7XHJcbiAgICAgIGNvbnN0IGxpc3QgPSBbXTtcclxuICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiA9PT0gMTMwKSB7XHJcbiAgICAgICAgICBsaXN0LnB1c2gocGFyc2VEZWNvcmF0b3JMaXN0KHBhcnNlciwgY29udGV4dCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaXN0O1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZURlY29yYXRvckxpc3QocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCk7XHJcbiAgICAgIGxldCBleHByZXNzaW9uID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDIsIDAsIDEsIDAsIDAsIDEsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICBleHByZXNzaW9uID0gcGFyc2VNZW1iZXJPclVwZGF0ZUV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBleHByZXNzaW9uLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnRGVjb3JhdG9yJyxcclxuICAgICAgICAgIGV4cHJlc3Npb25cclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQ2xhc3NCb2R5KHBhcnNlciwgY29udGV4dCwgaW5oZXJpdGVkQ29udGV4dCwgc2NvcGUsIGtpbmQsIG9yaWdpbiwgaW5Hcm91cCkge1xyXG4gICAgICBjb25zdCB7IHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MgfSA9IHBhcnNlcjtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQgfCAzMjc2OCwgMjE2MjcwMCk7XHJcbiAgICAgIGNvbnRleHQgPSAoY29udGV4dCB8IDEzNDIxNzcyOCkgXiAxMzQyMTc3Mjg7XHJcbiAgICAgIHBhcnNlci5mbGFncyA9IChwYXJzZXIuZmxhZ3MgfCAzMikgXiAzMjtcclxuICAgICAgY29uc3QgYm9keSA9IFtdO1xyXG4gICAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xyXG4gICAgICB3aGlsZSAocGFyc2VyLnRva2VuICE9PSAxMDc0NzkwNDE1KSB7XHJcbiAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcclxuICAgICAgICAgIGRlY29yYXRvcnMgPSBwYXJzZURlY29yYXRvcnMocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgIGxlbmd0aCA9IGRlY29yYXRvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGxlbmd0aCA+IDAgJiYgcGFyc2VyLnRva2VuVmFsdWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3NDc5MDQxNSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMDUpO1xyXG4gICAgICAgICAgaWYgKGNvbnN1bWVPcHQocGFyc2VyLCBjb250ZXh0LCAxMDc0NzkwNDE3KSkge1xyXG4gICAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTYpO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYm9keS5wdXNoKHBhcnNlQ2xhc3NFbGVtZW50TGlzdChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBpbmhlcml0ZWRDb250ZXh0LCBraW5kLCBkZWNvcmF0b3JzLCAwLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3VtZShwYXJzZXIsIG9yaWdpbiAmIDggPyBjb250ZXh0IHwgMzI3NjggOiBjb250ZXh0LCAxMDc0NzkwNDE1KTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zLCB7XHJcbiAgICAgICAgICB0eXBlOiAnQ2xhc3NCb2R5JyxcclxuICAgICAgICAgIGJvZHlcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQ2xhc3NFbGVtZW50TGlzdChwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCBpbmhlcml0ZWRDb250ZXh0LCB0eXBlLCBkZWNvcmF0b3JzLCBpc1N0YXRpYywgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBsZXQga2luZCA9IGlzU3RhdGljID8gMzIgOiAwO1xyXG4gICAgICBsZXQga2V5ID0gbnVsbDtcclxuICAgICAgY29uc3QgeyB0b2tlbiwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICBpZiAodG9rZW4gJiAoMTQzMzYwIHwgMzY4NjQpKSB7XHJcbiAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgICBjYXNlIDM2OTY5OlxyXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljICYmIHBhcnNlci50b2tlbiAhPT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNsYXNzRWxlbWVudExpc3QocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgaW5oZXJpdGVkQ29udGV4dCwgdHlwZSwgZGVjb3JhdG9ycywgMSwgaW5Hcm91cCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAxNDM0Njg6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDY3MTc0NDExICYmIChwYXJzZXIuZmxhZ3MgJiAxKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYgMSAmJiAocGFyc2VyLnRva2VuICYgMTA3Mzc0MTgyNCkgPT09IDEwNzM3NDE4MjQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGaWVsZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBrZXksIGtpbmQsIGRlY29yYXRvcnMsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAga2luZCB8PSAxNiB8IChvcHRpb25hbEJpdChwYXJzZXIsIGNvbnRleHQsIDg0NTcwMTEpID8gOCA6IDApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgMTIzOTk6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDY3MTc0NDExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDEgJiYgKHBhcnNlci50b2tlbiAmIDEwNzM3NDE4MjQpID09PSAxMDczNzQxODI0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmllbGREZWZpbml0aW9uKHBhcnNlciwgY29udGV4dCwga2V5LCBraW5kLCBkZWNvcmF0b3JzLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGtpbmQgfD0gMjU2O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgMTI0MDA6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gIT09IDY3MTc0NDExKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmIDEgJiYgKHBhcnNlci50b2tlbiAmIDEwNzM3NDE4MjQpID09PSAxMDczNzQxODI0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmllbGREZWZpbml0aW9uKHBhcnNlciwgY29udGV4dCwga2V5LCBraW5kLCBkZWNvcmF0b3JzLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGtpbmQgfD0gNTEyO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRva2VuID09PSA2OTI3MTU3MSkge1xyXG4gICAgICAgICAga2luZCA9IDI7XHJcbiAgICAgICAgICBrZXkgPSBwYXJzZUNvbXB1dGVkUHJvcGVydHlOYW1lKHBhcnNlciwgaW5oZXJpdGVkQ29udGV4dCwgaW5Hcm91cCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoKHRva2VuICYgMTM0MjE3NzI4KSA9PT0gMTM0MjE3NzI4KSB7XHJcbiAgICAgICAgICBrZXkgPSBwYXJzZUxpdGVyYWwocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0b2tlbiA9PT0gODQ1NzAxMSkge1xyXG4gICAgICAgICAga2luZCB8PSA4O1xyXG4gICAgICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoY29udGV4dCAmIDEgJiYgcGFyc2VyLnRva2VuID09PSAxMjgpIHtcclxuICAgICAgICAgIGtpbmQgfD0gNDA5NjtcclxuICAgICAgICAgIGtleSA9IHBhcnNlUHJpdmF0ZU5hbWUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHwgMTYzODQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoY29udGV4dCAmIDEgJiYgKHBhcnNlci50b2tlbiAmIDEwNzM3NDE4MjQpID09PSAxMDczNzQxODI0KSB7XHJcbiAgICAgICAgICBraW5kIHw9IDEyODtcclxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHwgMTYzODQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAodG9rZW4gPT09IDExOSkge1xyXG4gICAgICAgICAga2V5ID0gcGFyc2VJZGVudGlmaWVyKHBhcnNlciwgY29udGV4dCwgMCk7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuICE9PSA2NzE3NDQxMSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAyOCwgS2V5d29yZERlc2NUYWJsZVtwYXJzZXIudG9rZW4gJiAyNTVdKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChraW5kICYgKDggfCAxNiB8IDc2OCkpIHtcclxuICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAxNDMzNjApIHtcclxuICAgICAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKChwYXJzZXIudG9rZW4gJiAxMzQyMTc3MjgpID09PSAxMzQyMTc3MjgpIHtcclxuICAgICAgICAgICAgICBrZXkgPSBwYXJzZUxpdGVyYWwocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKHBhcnNlci50b2tlbiA9PT0gNjkyNzE1NzEpIHtcclxuICAgICAgICAgICAgICBraW5kIHw9IDI7XHJcbiAgICAgICAgICAgICAga2V5ID0gcGFyc2VDb21wdXRlZFByb3BlcnR5TmFtZShwYXJzZXIsIGNvbnRleHQsIDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAocGFyc2VyLnRva2VuID09PSAxMTkpIHtcclxuICAgICAgICAgICAgICBrZXkgPSBwYXJzZUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGNvbnRleHQgJiAxICYmIHBhcnNlci50b2tlbiA9PT0gMTI4KSB7XHJcbiAgICAgICAgICAgICAga2luZCB8PSA0MDk2O1xyXG4gICAgICAgICAgICAgIGtleSA9IHBhcnNlUHJpdmF0ZU5hbWUocGFyc2VyLCBjb250ZXh0LCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMzEpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoa2luZCAmIDIpIDwgMSkge1xyXG4gICAgICAgICAgaWYgKHBhcnNlci50b2tlblZhbHVlID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAxMDczNzQxODI0KSA9PT0gMTA3Mzc0MTgyNCkge1xyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMjUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbHNlIGlmICgoa2luZCAmIDMyKSA8IDEgJiYgcGFyc2VyLnRva2VuID09PSA2NzE3NDQxMSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoa2luZCAmICg3NjggfCAxNiB8IDEyOCB8IDgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA1MCwgJ2FjY2Vzc29yJyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGNvbnRleHQgJiA1MjQyODgpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlci5mbGFncyAmIDMyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDUxKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZmxhZ3MgfD0gMzI7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAga2luZCB8PSA2NDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKChraW5kICYgNDA5NikgPCAxICYmXHJcbiAgICAgICAgICAgICAga2luZCAmICgzMiB8IDc2OCB8IDggfCAxNikgJiZcclxuICAgICAgICAgICAgICBwYXJzZXIudG9rZW5WYWx1ZSA9PT0gJ3Byb3RvdHlwZScpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA0OSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAxICYmIHBhcnNlci50b2tlbiAhPT0gNjcxNzQ0MTEpIHtcclxuICAgICAgICAgIHJldHVybiBwYXJzZUZpZWxkRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIGtleSwga2luZCwgZGVjb3JhdG9ycywgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZU1ldGhvZERlZmluaXRpb24ocGFyc2VyLCBjb250ZXh0LCBraW5kLCBpbkdyb3VwLCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCBjb250ZXh0ICYgMVxyXG4gICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ01ldGhvZERlZmluaXRpb24nLFxyXG4gICAgICAgICAgICAgIGtpbmQ6IChraW5kICYgMzIpIDwgMSAmJiBraW5kICYgNjRcclxuICAgICAgICAgICAgICAgICAgPyAnY29uc3RydWN0b3InXHJcbiAgICAgICAgICAgICAgICAgIDoga2luZCAmIDI1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZ2V0J1xyXG4gICAgICAgICAgICAgICAgICAgICAgOiBraW5kICYgNTEyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnc2V0J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21ldGhvZCcsXHJcbiAgICAgICAgICAgICAgc3RhdGljOiAoa2luZCAmIDMyKSA+IDAsXHJcbiAgICAgICAgICAgICAgY29tcHV0ZWQ6IChraW5kICYgMikgPiAwLFxyXG4gICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICBkZWNvcmF0b3JzLFxyXG4gICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnTWV0aG9kRGVmaW5pdGlvbicsXHJcbiAgICAgICAgICAgICAga2luZDogKGtpbmQgJiAzMikgPCAxICYmIGtpbmQgJiA2NFxyXG4gICAgICAgICAgICAgICAgICA/ICdjb25zdHJ1Y3RvcidcclxuICAgICAgICAgICAgICAgICAgOiBraW5kICYgMjU2XHJcbiAgICAgICAgICAgICAgICAgICAgICA/ICdnZXQnXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGtpbmQgJiA1MTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdzZXQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWV0aG9kJyxcclxuICAgICAgICAgICAgICBzdGF0aWM6IChraW5kICYgMzIpID4gMCxcclxuICAgICAgICAgICAgICBjb21wdXRlZDogKGtpbmQgJiAyKSA+IDAsXHJcbiAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VQcml2YXRlTmFtZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSB9ID0gcGFyc2VyO1xyXG4gICAgICBpZiAodG9rZW5WYWx1ZSA9PT0gJ2NvbnN0cnVjdG9yJylcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDEyNCk7XHJcbiAgICAgIG5leHRUb2tlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdQcml2YXRlTmFtZScsXHJcbiAgICAgICAgICBuYW1lOiB0b2tlblZhbHVlXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUZpZWxkRGVmaW5pdGlvbihwYXJzZXIsIGNvbnRleHQsIGtleSwgc3RhdGUsIGRlY29yYXRvcnMsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbGV0IHZhbHVlID0gbnVsbDtcclxuICAgICAgaWYgKHN0YXRlICYgOClcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDApO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxMDc3OTM2MTU3KSB7XHJcbiAgICAgICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0IHwgMzI3NjgpO1xyXG4gICAgICAgICAgY29uc3QgeyB0b2tlblBvcywgbGluZVBvcywgY29sUG9zIH0gPSBwYXJzZXI7XHJcbiAgICAgICAgICBpZiAocGFyc2VyLnRva2VuID09PSA1MzcwNzk5MjUpXHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgICAgIHZhbHVlID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQgfCAxNjM4NCwgMiwgMCwgMSwgMCwgMCwgMSwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDEwNzM3NDE4MjQpICE9PSAxMDczNzQxODI0KSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU1lbWJlck9yVXBkYXRlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQgfCAxNjM4NCwgdmFsdWUsIDAsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQgfCAxNjM4NCwgMCwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEwNzM3NDE4NDIpIHtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVNlcXVlbmNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHZhbHVlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnRmllbGREZWZpbml0aW9uJyxcclxuICAgICAgICAgIGtleSxcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgc3RhdGljOiAoc3RhdGUgJiAzMikgPiAwLFxyXG4gICAgICAgICAgY29tcHV0ZWQ6IChzdGF0ZSAmIDIpID4gMCxcclxuICAgICAgICAgIGRlY29yYXRvcnNcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlQmluZGluZ1BhdHRlcm4ocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgdHlwZSwgb3JpZ2luLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gJiAxNDMzNjApXHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VBbmRDbGFzc2lmeUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzY29wZSwgdHlwZSwgb3JpZ2luLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKChwYXJzZXIudG9rZW4gJiAyMDk3MTUyKSAhPT0gMjA5NzE1MilcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDI4LCBLZXl3b3JkRGVzY1RhYmxlW3BhcnNlci50b2tlbiAmIDI1NV0pO1xyXG4gICAgICBjb25zdCBsZWZ0ID0gcGFyc2VyLnRva2VuID09PSA2OTI3MTU3MVxyXG4gICAgICAgICAgPyBwYXJzZUFycmF5RXhwcmVzc2lvbk9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAxLCAwLCAxLCB0eXBlLCBvcmlnaW4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pXHJcbiAgICAgICAgICA6IHBhcnNlT2JqZWN0TGl0ZXJhbE9yUGF0dGVybihwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCAxLCAwLCAxLCB0eXBlLCBvcmlnaW4sIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICBpZiAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDE2KVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNDcpO1xyXG4gICAgICBpZiAocGFyc2VyLmRlc3RydWN0aWJsZSAmIDMyKVxyXG4gICAgICAgICAgcmVwb3J0KHBhcnNlciwgNDcpO1xyXG4gICAgICByZXR1cm4gbGVmdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VBbmRDbGFzc2lmeUlkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzY29wZSwga2luZCwgb3JpZ2luLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSwgdG9rZW4gfSA9IHBhcnNlcjtcclxuICAgICAgaWYgKGNvbnRleHQgJiAxMDI0KSB7XHJcbiAgICAgICAgICBpZiAoKHRva2VuICYgNTM3MDc5ODA4KSA9PT0gNTM3MDc5ODA4KSB7XHJcbiAgICAgICAgICAgICAgcmVwb3J0KHBhcnNlciwgMTE1KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKCh0b2tlbiAmIDM2ODY0KSA9PT0gMzY4NjQpIHtcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxMTQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICgodG9rZW4gJiAyMDQ4MCkgPT09IDIwNDgwKSB7XHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCA5OSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAoMjA0OCB8IDIwOTcxNTIpICYmIHRva2VuID09PSAyNDE3NzApIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDMwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodG9rZW4gPT09IDI0MTczNikge1xyXG4gICAgICAgICAgaWYgKGtpbmQgJiAoOCB8IDE2KSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCA5Nyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbnRleHQgJiAoNDE5NDMwNCB8IDIwNDgpICYmIHRva2VuID09PSAyMDkwMDUpIHtcclxuICAgICAgICAgIHJlcG9ydChwYXJzZXIsIDk1KTtcclxuICAgICAgfVxyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgaWYgKHNjb3BlKVxyXG4gICAgICAgICAgYWRkVmFyT3JCbG9jayhwYXJzZXIsIGNvbnRleHQsIHNjb3BlLCB0b2tlblZhbHVlLCBraW5kLCBvcmlnaW4pO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcclxuICAgICAgICAgIG5hbWU6IHRva2VuVmFsdWVcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYUm9vdEVsZW1lbnRPckZyYWdtZW50KHBhcnNlciwgY29udGV4dCwgaW5KU1hDaGlsZCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gODQ1NjI1Nikge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ0pTWEZyYWdtZW50JyxcclxuICAgICAgICAgICAgICBvcGVuaW5nRnJhZ21lbnQ6IHBhcnNlT3BlbmluZ0ZyYWdtZW50KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiksXHJcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHBhcnNlSlNYQ2hpbGRyZW4ocGFyc2VyLCBjb250ZXh0KSxcclxuICAgICAgICAgICAgICBjbG9zaW5nRnJhZ21lbnQ6IHBhcnNlSlNYQ2xvc2luZ0ZyYWdtZW50KHBhcnNlciwgY29udGV4dCwgaW5KU1hDaGlsZCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcylcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBjbG9zaW5nRWxlbWVudCA9IG51bGw7XHJcbiAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICBjb25zdCBvcGVuaW5nRWxlbWVudCA9IHBhcnNlSlNYT3BlbmluZ0ZyYWdtZW50T3JTZWxmQ2xvc2VFbGVtZW50KHBhcnNlciwgY29udGV4dCwgaW5KU1hDaGlsZCwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIGlmICghb3BlbmluZ0VsZW1lbnQuc2VsZkNsb3NpbmcpIHtcclxuICAgICAgICAgIGNoaWxkcmVuID0gcGFyc2VKU1hDaGlsZHJlbihwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgY2xvc2luZ0VsZW1lbnQgPSBwYXJzZUpTWENsb3NpbmdFbGVtZW50KHBhcnNlciwgY29udGV4dCwgaW5KU1hDaGlsZCwgcGFyc2VyLnRva2VuUG9zLCBwYXJzZXIubGluZVBvcywgcGFyc2VyLmNvbFBvcyk7XHJcbiAgICAgICAgICBjb25zdCBjbG9zZSA9IGlzRXF1YWxUYWdOYW1lKGNsb3NpbmdFbGVtZW50Lm5hbWUpO1xyXG4gICAgICAgICAgaWYgKGlzRXF1YWxUYWdOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpICE9PSBjbG9zZSlcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDksIGNsb3NlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdKU1hFbGVtZW50JyxcclxuICAgICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgICAgb3BlbmluZ0VsZW1lbnQsXHJcbiAgICAgICAgICBjbG9zaW5nRWxlbWVudFxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VPcGVuaW5nRnJhZ21lbnQocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIHNjYW5KU1hUb2tlbihwYXJzZXIpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdKU1hPcGVuaW5nRnJhZ21lbnQnXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUpTWENsb3NpbmdFbGVtZW50KHBhcnNlciwgY29udGV4dCwgaW5KU1hDaGlsZCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMjUpO1xyXG4gICAgICBjb25zdCBuYW1lID0gcGFyc2VKU1hFbGVtZW50TmFtZShwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBpZiAoaW5KU1hDaGlsZCkge1xyXG4gICAgICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDg0NTYyNTYpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcGFyc2VyLnRva2VuID0gc2NhbkpTWFRva2VuKHBhcnNlcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnSlNYQ2xvc2luZ0VsZW1lbnQnLFxyXG4gICAgICAgICAgbmFtZVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VKU1hDbG9zaW5nRnJhZ21lbnQocGFyc2VyLCBjb250ZXh0LCBpbkpTWENoaWxkLCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAyNSk7XHJcbiAgICAgIGlmIChpbkpTWENoaWxkKSB7XHJcbiAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgODQ1NjI1Nik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgODQ1NjI1Nik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnSlNYQ2xvc2luZ0ZyYWdtZW50J1xyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VKU1hDaGlsZHJlbihwYXJzZXIsIGNvbnRleHQpIHtcclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgd2hpbGUgKHBhcnNlci50b2tlbiAhPT0gMjUpIHtcclxuICAgICAgICAgIHBhcnNlci5pbmRleCA9IHBhcnNlci50b2tlblBvcyA9IHBhcnNlci5zdGFydFBvcztcclxuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSBwYXJzZXIuY29sUG9zID0gcGFyc2VyLnN0YXJ0Q29sdW1uO1xyXG4gICAgICAgICAgcGFyc2VyLmxpbmUgPSBwYXJzZXIubGluZVBvcyA9IHBhcnNlci5zdGFydExpbmU7XHJcbiAgICAgICAgICBzY2FuSlNYVG9rZW4ocGFyc2VyKTtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2gocGFyc2VKU1hDaGlsZChwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYQ2hpbGQocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDEzNSlcclxuICAgICAgICAgIHJldHVybiBwYXJzZUpTWFRleHQocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMjE2MjcwMClcclxuICAgICAgICAgIHJldHVybiBwYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIocGFyc2VyLCBjb250ZXh0LCAwLCAwLCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gODQ1NjI1NSlcclxuICAgICAgICAgIHJldHVybiBwYXJzZUpTWFJvb3RFbGVtZW50T3JGcmFnbWVudChwYXJzZXIsIGNvbnRleHQsIDAsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pO1xyXG4gICAgICByZXBvcnQocGFyc2VyLCAwKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VKU1hUZXh0KHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBzY2FuSlNYVG9rZW4ocGFyc2VyKTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnSlNYVGV4dCcsXHJcbiAgICAgICAgICB2YWx1ZTogcGFyc2VyLnRva2VuVmFsdWVcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYT3BlbmluZ0ZyYWdtZW50T3JTZWxmQ2xvc2VFbGVtZW50KHBhcnNlciwgY29udGV4dCwgaW5KU1hDaGlsZCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBpZiAoKHBhcnNlci50b2tlbiAmIDE0MzM2MCkgIT09IDE0MzM2MCAmJiAocGFyc2VyLnRva2VuICYgNDA5NikgIT09IDQwOTYpXHJcbiAgICAgICAgICByZXBvcnQocGFyc2VyLCAwKTtcclxuICAgICAgY29uc3QgdGFnTmFtZSA9IHBhcnNlSlNYRWxlbWVudE5hbWUocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHBhcnNlSlNYQXR0cmlidXRlcyhwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICBjb25zdCBzZWxmQ2xvc2luZyA9IHBhcnNlci50b2tlbiA9PT0gODQ1NzAxMztcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gODQ1NjI1Nikge1xyXG4gICAgICAgICAgc2NhbkpTWFRva2VuKHBhcnNlcik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgODQ1NzAxMyk7XHJcbiAgICAgICAgICBpZiAoaW5KU1hDaGlsZCkge1xyXG4gICAgICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCA4NDU2MjU2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNjYW5KU1hUb2tlbihwYXJzZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0pTWE9wZW5pbmdFbGVtZW50JyxcclxuICAgICAgICAgIG5hbWU6IHRhZ05hbWUsXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgc2VsZkNsb3NpbmdcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYRWxlbWVudE5hbWUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIHNjYW5KU1hJZGVudGlmaWVyKHBhcnNlcik7XHJcbiAgICAgIGxldCBrZXkgPSBwYXJzZUpTWElkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMjEpXHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VKU1hOYW1lc3BhY2VkTmFtZShwYXJzZXIsIGNvbnRleHQsIGtleSwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIHdoaWxlIChjb25zdW1lT3B0KHBhcnNlciwgY29udGV4dCwgNjcxMDg4NzcpKSB7XHJcbiAgICAgICAgICBzY2FuSlNYSWRlbnRpZmllcihwYXJzZXIpO1xyXG4gICAgICAgICAga2V5ID0gcGFyc2VKU1hNZW1iZXJFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwga2V5LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ga2V5O1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUpTWE1lbWJlckV4cHJlc3Npb24ocGFyc2VyLCBjb250ZXh0LCBvYmplY3QsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3QgcHJvcGVydHkgPSBwYXJzZUpTWElkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnSlNYTWVtYmVyRXhwcmVzc2lvbicsXHJcbiAgICAgICAgICBvYmplY3QsXHJcbiAgICAgICAgICBwcm9wZXJ0eVxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VKU1hBdHRyaWJ1dGVzKHBhcnNlciwgY29udGV4dCkge1xyXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XHJcbiAgICAgIHdoaWxlIChwYXJzZXIudG9rZW4gIT09IDg0NTcwMTMgJiYgcGFyc2VyLnRva2VuICE9PSA4NDU2MjU2KSB7XHJcbiAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2gocGFyc2VKc3hBdHRyaWJ1dGUocGFyc2VyLCBjb250ZXh0LCBwYXJzZXIudG9rZW5Qb3MsIHBhcnNlci5saW5lUG9zLCBwYXJzZXIuY29sUG9zKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYU3ByZWFkQXR0cmlidXRlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDE0KTtcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDAsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTA3NDc5MDQxNSk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0pTWFNwcmVhZEF0dHJpYnV0ZScsXHJcbiAgICAgICAgICBhcmd1bWVudDogZXhwcmVzc2lvblxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VKc3hBdHRyaWJ1dGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGlmIChwYXJzZXIudG9rZW4gPT09IDIxNjI3MDApXHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgc2NhbkpTWElkZW50aWZpZXIocGFyc2VyKTtcclxuICAgICAgbGV0IHZhbHVlID0gbnVsbDtcclxuICAgICAgbGV0IG5hbWUgPSBwYXJzZUpTWElkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKTtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMjEpIHtcclxuICAgICAgICAgIG5hbWUgPSBwYXJzZUpTWE5hbWVzcGFjZWROYW1lKHBhcnNlciwgY29udGV4dCwgbmFtZSwgc3RhcnQsIGxpbmUsIGNvbHVtbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3NzkzNjE1Nykge1xyXG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBzY2FuSlNYQXR0cmlidXRlVmFsdWUocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgICAgIGNvbnN0IHsgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgIGNhc2UgMTM0MjgzMjY3OlxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlTGl0ZXJhbChwYXJzZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIDg0NTYyNTU6XHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VKU1hSb290RWxlbWVudE9yRnJhZ21lbnQocGFyc2VyLCBjb250ZXh0LCAxLCB0b2tlblBvcywgbGluZVBvcywgY29sUG9zKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAyMTYyNzAwOlxyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihwYXJzZXIsIGNvbnRleHQsIDEsIDEsIHRva2VuUG9zLCBsaW5lUG9zLCBjb2xQb3MpO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNDgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0pTWEF0dHJpYnV0ZScsXHJcbiAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgIG5hbWVcclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYTmFtZXNwYWNlZE5hbWUocGFyc2VyLCBjb250ZXh0LCBuYW1lc3BhY2UsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDIxKTtcclxuICAgICAgY29uc3QgbmFtZSA9IHBhcnNlSlNYSWRlbnRpZmllcihwYXJzZXIsIGNvbnRleHQsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdKU1hOYW1lc3BhY2VkTmFtZScsXHJcbiAgICAgICAgICBuYW1lc3BhY2UsXHJcbiAgICAgICAgICBuYW1lXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIocGFyc2VyLCBjb250ZXh0LCBpbkpTWENoaWxkLCBpc0F0dHIsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgbmV4dFRva2VuKHBhcnNlciwgY29udGV4dCk7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyB9ID0gcGFyc2VyO1xyXG4gICAgICBpZiAocGFyc2VyLnRva2VuID09PSAxNClcclxuICAgICAgICAgIHJldHVybiBwYXJzZUpTWFNwcmVhZENoaWxkKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIGxldCBleHByZXNzaW9uID0gbnVsbDtcclxuICAgICAgaWYgKHBhcnNlci50b2tlbiA9PT0gMTA3NDc5MDQxNSkge1xyXG4gICAgICAgICAgaWYgKGlzQXR0cilcclxuICAgICAgICAgICAgICByZXBvcnQocGFyc2VyLCAxNTEpO1xyXG4gICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlSlNYRW1wdHlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgMSwgMCwgMCwgdG9rZW5Qb3MsIGxpbmVQb3MsIGNvbFBvcyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluSlNYQ2hpbGQpIHtcclxuICAgICAgICAgIGNvbnN1bWUocGFyc2VyLCBjb250ZXh0LCAxMDc0NzkwNDE1KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIHNjYW5KU1hUb2tlbihwYXJzZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0pTWEV4cHJlc3Npb25Db250YWluZXInLFxyXG4gICAgICAgICAgZXhwcmVzc2lvblxyXG4gICAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcGFyc2VKU1hTcHJlYWRDaGlsZChwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4pIHtcclxuICAgICAgY29uc3VtZShwYXJzZXIsIGNvbnRleHQsIDE0KTtcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihwYXJzZXIsIGNvbnRleHQsIDEsIDAsIDAsIHBhcnNlci50b2tlblBvcywgcGFyc2VyLmxpbmVQb3MsIHBhcnNlci5jb2xQb3MpO1xyXG4gICAgICBjb25zdW1lKHBhcnNlciwgY29udGV4dCwgMTA3NDc5MDQxNSk7XHJcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbiwge1xyXG4gICAgICAgICAgdHlwZTogJ0pTWFNwcmVhZENoaWxkJyxcclxuICAgICAgICAgIGV4cHJlc3Npb25cclxuICAgICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhcnNlSlNYRW1wdHlFeHByZXNzaW9uKHBhcnNlciwgY29udGV4dCwgc3RhcnQsIGxpbmUsIGNvbHVtbikge1xyXG4gICAgICByZXR1cm4gZmluaXNoTm9kZShwYXJzZXIsIGNvbnRleHQsIHN0YXJ0LCBsaW5lLCBjb2x1bW4sIHtcclxuICAgICAgICAgIHR5cGU6ICdKU1hFbXB0eUV4cHJlc3Npb24nXHJcbiAgICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZUpTWElkZW50aWZpZXIocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uKSB7XHJcbiAgICAgIGNvbnN0IHsgdG9rZW5WYWx1ZSB9ID0gcGFyc2VyO1xyXG4gICAgICBuZXh0VG9rZW4ocGFyc2VyLCBjb250ZXh0KTtcclxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUocGFyc2VyLCBjb250ZXh0LCBzdGFydCwgbGluZSwgY29sdW1uLCB7XHJcbiAgICAgICAgICB0eXBlOiAnSlNYSWRlbnRpZmllcicsXHJcbiAgICAgICAgICBuYW1lOiB0b2tlblZhbHVlXHJcbiAgICAgIH0pO1xyXG4gIH1cblxuXG5cbiAgdmFyIGVzdHJlZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcGFyc2VTY3JpcHQoc291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBwYXJzZVNvdXJjZShzb3VyY2UsIG9wdGlvbnMsIDApO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZU1vZHVsZShzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHBhcnNlU291cmNlKHNvdXJjZSwgb3B0aW9ucywgMTAyNCB8IDIwNDgpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZShzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHBhcnNlU291cmNlKHNvdXJjZSwgb3B0aW9ucywgMCk7XHJcbiAgfVxyXG4gIGNvbnN0IHZlcnNpb24gPSAnMS45LjE1JztcblxuICBleHBvcnRzLkVTVHJlZSA9IGVzdHJlZTtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlTW9kdWxlID0gcGFyc2VNb2R1bGU7XG4gIGV4cG9ydHMucGFyc2VTY3JpcHQgPSBwYXJzZVNjcmlwdDtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsV0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/meriyah/dist/meriyah.umd.js\n");

/***/ })

}]);