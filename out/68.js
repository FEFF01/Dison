(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[68],{

/***/ "./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/ast.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/ast.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"/***********************************************************************\\n\\n  A JavaScript tokenizer / parser / beautifier / compressor.\\n  https://github.com/mishoo/UglifyJS2\\n\\n  -------------------------------- (C) ---------------------------------\\n\\n                           Author: Mihai Bazon\\n                         <mihai.bazon@gmail.com>\\n                       http://mihai.bazon.net/blog\\n\\n  Distributed under the BSD license:\\n\\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\\n\\n    Redistribution and use in source and binary forms, with or without\\n    modification, are permitted provided that the following conditions\\n    are met:\\n\\n        * Redistributions of source code must retain the above\\n          copyright notice, this list of conditions and the following\\n          disclaimer.\\n\\n        * Redistributions in binary form must reproduce the above\\n          copyright notice, this list of conditions and the following\\n          disclaimer in the documentation and/or other materials\\n          provided with the distribution.\\n\\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\\n    SUCH DAMAGE.\\n\\n ***********************************************************************/\\n\\n\\\"use strict\\\";\\n\\nfunction DEFNODE(type, props, methods, base) {\\n    if (arguments.length < 4) base = AST_Node;\\n    if (!props) props = [];\\n    else props = props.split(/\\\\s+/);\\n    var self_props = props;\\n    if (base && base.PROPS)\\n        props = props.concat(base.PROPS);\\n    var code = \\\"return function AST_\\\" + type + \\\"(props){ if (props) { \\\";\\n    for (var i = props.length; --i >= 0;) {\\n        code += \\\"this.\\\" + props[i] + \\\" = props.\\\" + props[i] + \\\";\\\";\\n    }\\n    var proto = base && new base;\\n    if (proto && proto.initialize || (methods && methods.initialize))\\n        code += \\\"this.initialize();\\\";\\n    code += \\\"}}\\\";\\n    var ctor = new Function(code)();\\n    if (proto) {\\n        ctor.prototype = proto;\\n        ctor.BASE = base;\\n    }\\n    if (base) base.SUBCLASSES.push(ctor);\\n    ctor.prototype.CTOR = ctor;\\n    ctor.PROPS = props || null;\\n    ctor.SELF_PROPS = self_props;\\n    ctor.SUBCLASSES = [];\\n    if (type) {\\n        ctor.prototype.TYPE = ctor.TYPE = type;\\n    }\\n    if (methods) for (i in methods) if (HOP(methods, i)) {\\n        if (/^\\\\$/.test(i)) {\\n            ctor[i.substr(1)] = methods[i];\\n        } else {\\n            ctor.prototype[i] = methods[i];\\n        }\\n    }\\n    ctor.DEFMETHOD = function(name, method) {\\n        this.prototype[name] = method;\\n    };\\n    if (typeof exports !== \\\"undefined\\\") {\\n        exports[\\\"AST_\\\" + type] = ctor;\\n    }\\n    return ctor;\\n};\\n\\nvar AST_Token = DEFNODE(\\\"Token\\\", \\\"type value line col pos endline endcol endpos nlb comments_before comments_after file raw\\\", {\\n}, null);\\n\\nvar AST_Node = DEFNODE(\\\"Node\\\", \\\"start end\\\", {\\n    _clone: function(deep) {\\n        if (deep) {\\n            var self = this.clone();\\n            return self.transform(new TreeTransformer(function(node) {\\n                if (node !== self) {\\n                    return node.clone(true);\\n                }\\n            }));\\n        }\\n        return new this.CTOR(this);\\n    },\\n    clone: function(deep) {\\n        return this._clone(deep);\\n    },\\n    $documentation: \\\"Base class of all AST nodes\\\",\\n    $propdoc: {\\n        start: \\\"[AST_Token] The first token of this node\\\",\\n        end: \\\"[AST_Token] The last token of this node\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this);\\n    },\\n    walk: function(visitor) {\\n        return this._walk(visitor); // not sure the indirection will be any help\\n    }\\n}, null);\\n\\nAST_Node.warn_function = null;\\nAST_Node.warn = function(txt, props) {\\n    if (AST_Node.warn_function)\\n        AST_Node.warn_function(string_template(txt, props));\\n};\\n\\n/* -----[ statements ]----- */\\n\\nvar AST_Statement = DEFNODE(\\\"Statement\\\", null, {\\n    $documentation: \\\"Base class of all statements\\\",\\n});\\n\\nvar AST_Debugger = DEFNODE(\\\"Debugger\\\", null, {\\n    $documentation: \\\"Represents a debugger statement\\\",\\n}, AST_Statement);\\n\\nvar AST_Directive = DEFNODE(\\\"Directive\\\", \\\"value quote\\\", {\\n    $documentation: \\\"Represents a directive, like \\\\\\\"use strict\\\\\\\";\\\",\\n    $propdoc: {\\n        value: \\\"[string] The value of this directive as a plain string (it's not an AST_String!)\\\",\\n        quote: \\\"[string] the original quote character\\\"\\n    },\\n}, AST_Statement);\\n\\nvar AST_SimpleStatement = DEFNODE(\\\"SimpleStatement\\\", \\\"body\\\", {\\n    $documentation: \\\"A statement consisting of an expression, i.e. a = 1 + 2\\\",\\n    $propdoc: {\\n        body: \\\"[AST_Node] an expression node (should not be instanceof AST_Statement)\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.body._walk(visitor);\\n        });\\n    }\\n}, AST_Statement);\\n\\nfunction walk_body(node, visitor) {\\n    var body = node.body;\\n    if (body instanceof AST_Node) {\\n        body._walk(visitor);\\n    }\\n    else for (var i = 0, len = body.length; i < len; i++) {\\n        body[i]._walk(visitor);\\n    }\\n};\\n\\nvar AST_Block = DEFNODE(\\\"Block\\\", \\\"body\\\", {\\n    $documentation: \\\"A body of statements (usually bracketed)\\\",\\n    $propdoc: {\\n        body: \\\"[AST_Statement*] an array of statements\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            walk_body(this, visitor);\\n        });\\n    }\\n}, AST_Statement);\\n\\nvar AST_BlockStatement = DEFNODE(\\\"BlockStatement\\\", null, {\\n    $documentation: \\\"A block statement\\\",\\n}, AST_Block);\\n\\nvar AST_EmptyStatement = DEFNODE(\\\"EmptyStatement\\\", null, {\\n    $documentation: \\\"The empty statement (empty block or simply a semicolon)\\\"\\n}, AST_Statement);\\n\\nvar AST_StatementWithBody = DEFNODE(\\\"StatementWithBody\\\", \\\"body\\\", {\\n    $documentation: \\\"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\\\",\\n    $propdoc: {\\n        body: \\\"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\\\"\\n    }\\n}, AST_Statement);\\n\\nvar AST_LabeledStatement = DEFNODE(\\\"LabeledStatement\\\", \\\"label\\\", {\\n    $documentation: \\\"Statement with a label\\\",\\n    $propdoc: {\\n        label: \\\"[AST_Label] a label definition\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.label._walk(visitor);\\n            this.body._walk(visitor);\\n        });\\n    },\\n    clone: function(deep) {\\n        var node = this._clone(deep);\\n        if (deep) {\\n            var label = node.label;\\n            var def = this.label;\\n            node.walk(new TreeWalker(function(node) {\\n                if (node instanceof AST_LoopControl\\n                    && node.label && node.label.thedef === def) {\\n                    node.label.thedef = label;\\n                    label.references.push(node);\\n                }\\n            }));\\n        }\\n        return node;\\n    }\\n}, AST_StatementWithBody);\\n\\nvar AST_IterationStatement = DEFNODE(\\\"IterationStatement\\\", null, {\\n    $documentation: \\\"Internal class.  All loops inherit from it.\\\"\\n}, AST_StatementWithBody);\\n\\nvar AST_DWLoop = DEFNODE(\\\"DWLoop\\\", \\\"condition\\\", {\\n    $documentation: \\\"Base class for do/while statements\\\",\\n    $propdoc: {\\n        condition: \\\"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\\\"\\n    }\\n}, AST_IterationStatement);\\n\\nvar AST_Do = DEFNODE(\\\"Do\\\", null, {\\n    $documentation: \\\"A `do` statement\\\",\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.body._walk(visitor);\\n            this.condition._walk(visitor);\\n        });\\n    }\\n}, AST_DWLoop);\\n\\nvar AST_While = DEFNODE(\\\"While\\\", null, {\\n    $documentation: \\\"A `while` statement\\\",\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.condition._walk(visitor);\\n            this.body._walk(visitor);\\n        });\\n    }\\n}, AST_DWLoop);\\n\\nvar AST_For = DEFNODE(\\\"For\\\", \\\"init condition step\\\", {\\n    $documentation: \\\"A `for` statement\\\",\\n    $propdoc: {\\n        init: \\\"[AST_Node?] the `for` initialization code, or null if empty\\\",\\n        condition: \\\"[AST_Node?] the `for` termination clause, or null if empty\\\",\\n        step: \\\"[AST_Node?] the `for` update clause, or null if empty\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            if (this.init) this.init._walk(visitor);\\n            if (this.condition) this.condition._walk(visitor);\\n            if (this.step) this.step._walk(visitor);\\n            this.body._walk(visitor);\\n        });\\n    }\\n}, AST_IterationStatement);\\n\\nvar AST_ForIn = DEFNODE(\\\"ForIn\\\", \\\"init object\\\", {\\n    $documentation: \\\"A `for ... in` statement\\\",\\n    $propdoc: {\\n        init: \\\"[AST_Node] the `for/in` initialization code\\\",\\n        object: \\\"[AST_Node] the object that we're looping through\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.init._walk(visitor);\\n            this.object._walk(visitor);\\n            this.body._walk(visitor);\\n        });\\n    }\\n}, AST_IterationStatement);\\n\\nvar AST_ForOf = DEFNODE(\\\"ForOf\\\", null, {\\n    $documentation: \\\"A `for ... of` statement\\\",\\n}, AST_ForIn);\\n\\nvar AST_With = DEFNODE(\\\"With\\\", \\\"expression\\\", {\\n    $documentation: \\\"A `with` statement\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] the `with` expression\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n            this.body._walk(visitor);\\n        });\\n    }\\n}, AST_StatementWithBody);\\n\\n/* -----[ scope and functions ]----- */\\n\\nvar AST_Scope = DEFNODE(\\\"Scope\\\", \\\"variables functions uses_with uses_eval parent_scope enclosed cname\\\", {\\n    $documentation: \\\"Base class for all statements introducing a lexical scope\\\",\\n    $propdoc: {\\n        variables: \\\"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope\\\",\\n        functions: \\\"[Object/S] like `variables`, but only lists function declarations\\\",\\n        uses_with: \\\"[boolean/S] tells whether this scope uses the `with` statement\\\",\\n        uses_eval: \\\"[boolean/S] tells whether this scope contains a direct call to the global `eval`\\\",\\n        parent_scope: \\\"[AST_Scope?/S] link to the parent scope\\\",\\n        enclosed: \\\"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\\\",\\n        cname: \\\"[integer/S] current index for mangling variables (used internally by the mangler)\\\",\\n    },\\n    get_defun_scope: function() {\\n        var self = this;\\n        while (self.is_block_scope()) {\\n            self = self.parent_scope;\\n        }\\n        return self;\\n    },\\n    clone: function(deep) {\\n        var node = this._clone(deep);\\n        if (this.variables) node.variables = this.variables.clone();\\n        if (this.functions) node.functions = this.functions.clone();\\n        if (this.enclosed) node.enclosed = this.enclosed.slice();\\n        return node;\\n    }\\n}, AST_Block);\\n\\nvar AST_Toplevel = DEFNODE(\\\"Toplevel\\\", \\\"globals\\\", {\\n    $documentation: \\\"The toplevel scope\\\",\\n    $propdoc: {\\n        globals: \\\"[Object/S] a map of name -> SymbolDef for all undeclared names\\\",\\n    },\\n    wrap_commonjs: function(name) {\\n        var body = this.body;\\n        var wrapped_tl = \\\"(function(exports){'$ORIG';})(typeof \\\" + name + \\\"=='undefined'?(\\\" + name + \\\"={}):\\\" + name + \\\");\\\";\\n        wrapped_tl = parse(wrapped_tl);\\n        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function before(node){\\n            if (node instanceof AST_Directive && node.value == \\\"$ORIG\\\") {\\n                return MAP.splice(body);\\n            }\\n        }));\\n        return wrapped_tl;\\n    }\\n}, AST_Scope);\\n\\nvar AST_Expansion = DEFNODE(\\\"Expansion\\\", \\\"expression\\\", {\\n    $documentation: \\\"An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] the thing to be expanded\\\"\\n    },\\n    _walk: function(visitor) {\\n        var self = this;\\n        return visitor._visit(this, function(){\\n            self.expression.walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_Lambda = DEFNODE(\\\"Lambda\\\", \\\"name argnames uses_arguments is_generator async\\\", {\\n    $documentation: \\\"Base class for functions\\\",\\n    $propdoc: {\\n        name: \\\"[AST_SymbolDeclaration?] the name of this function\\\",\\n        argnames: \\\"[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments\\\",\\n        uses_arguments: \\\"[boolean/S] tells whether this function accesses the arguments array\\\",\\n        is_generator: \\\"[boolean] is this a generator method\\\",\\n        async: \\\"[boolean] is this method async\\\",\\n    },\\n    args_as_names: function () {\\n        var out = [];\\n        for (var i = 0; i < this.argnames.length; i++) {\\n            if (this.argnames[i] instanceof AST_Destructuring) {\\n                out = out.concat(this.argnames[i].all_symbols());\\n            } else {\\n                out.push(this.argnames[i]);\\n            }\\n        }\\n        return out;\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            if (this.name) this.name._walk(visitor);\\n            var argnames = this.argnames;\\n            for (var i = 0, len = argnames.length; i < len; i++) {\\n                argnames[i]._walk(visitor);\\n            }\\n            walk_body(this, visitor);\\n        });\\n    }\\n}, AST_Scope);\\n\\nvar AST_Accessor = DEFNODE(\\\"Accessor\\\", null, {\\n    $documentation: \\\"A setter/getter function.  The `name` property is always null.\\\"\\n}, AST_Lambda);\\n\\nvar AST_Function = DEFNODE(\\\"Function\\\", \\\"inlined\\\", {\\n    $documentation: \\\"A function expression\\\"\\n}, AST_Lambda);\\n\\nvar AST_Arrow = DEFNODE(\\\"Arrow\\\", \\\"inlined\\\", {\\n    $documentation: \\\"An ES6 Arrow function ((a) => b)\\\"\\n}, AST_Lambda);\\n\\nvar AST_Defun = DEFNODE(\\\"Defun\\\", \\\"inlined\\\", {\\n    $documentation: \\\"A function definition\\\"\\n}, AST_Lambda);\\n\\n/* -----[ DESTRUCTURING ]----- */\\nvar AST_Destructuring = DEFNODE(\\\"Destructuring\\\", \\\"names is_array\\\", {\\n    $documentation: \\\"A destructuring of several names. Used in destructuring assignment and with destructuring function argument names\\\",\\n    $propdoc: {\\n        \\\"names\\\": \\\"[AST_Node*] Array of properties or elements\\\",\\n        \\\"is_array\\\": \\\"[Boolean] Whether the destructuring represents an object or array\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.names.forEach(function(name){\\n                name._walk(visitor);\\n            });\\n        });\\n    },\\n    all_symbols: function() {\\n        var out = [];\\n        this.walk(new TreeWalker(function (node) {\\n            if (node instanceof AST_Symbol) {\\n                out.push(node);\\n            }\\n            if (node instanceof AST_Expansion) {\\n                out.push(node.expression);\\n            }\\n        }));\\n        return out;\\n    }\\n});\\n\\nvar AST_PrefixedTemplateString = DEFNODE(\\\"PrefixedTemplateString\\\", \\\"template_string prefix\\\", {\\n    $documentation: \\\"A templatestring with a prefix, such as String.raw`foobarbaz`\\\",\\n    $propdoc: {\\n        template_string: \\\"[AST_TemplateString] The template string\\\",\\n        prefix: \\\"[AST_SymbolRef|AST_PropAccess] The prefix, which can be a symbol such as `foo` or a dotted expression such as `String.raw`.\\\"\\n    },\\n    _walk: function(visitor) {\\n        this.prefix._walk(visitor);\\n        this.template_string._walk(visitor);\\n    }\\n})\\n\\nvar AST_TemplateString = DEFNODE(\\\"TemplateString\\\", \\\"segments\\\", {\\n    $documentation: \\\"A template string literal\\\",\\n    $propdoc: {\\n        segments: \\\"[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment.\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.segments.forEach(function(seg){\\n                seg._walk(visitor);\\n            });\\n        });\\n    }\\n});\\n\\nvar AST_TemplateSegment = DEFNODE(\\\"TemplateSegment\\\", \\\"value raw\\\", {\\n    $documentation: \\\"A segment of a template string literal\\\",\\n    $propdoc: {\\n        value: \\\"Content of the segment\\\",\\n        raw: \\\"Raw content of the segment\\\"\\n    }\\n});\\n\\n/* -----[ JUMPS ]----- */\\n\\nvar AST_Jump = DEFNODE(\\\"Jump\\\", null, {\\n    $documentation: \\\"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)\\\"\\n}, AST_Statement);\\n\\nvar AST_Exit = DEFNODE(\\\"Exit\\\", \\\"value\\\", {\\n    $documentation: \\\"Base class for “exits” (`return` and `throw`)\\\",\\n    $propdoc: {\\n        value: \\\"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, this.value && function(){\\n            this.value._walk(visitor);\\n        });\\n    }\\n}, AST_Jump);\\n\\nvar AST_Return = DEFNODE(\\\"Return\\\", null, {\\n    $documentation: \\\"A `return` statement\\\"\\n}, AST_Exit);\\n\\nvar AST_Throw = DEFNODE(\\\"Throw\\\", null, {\\n    $documentation: \\\"A `throw` statement\\\"\\n}, AST_Exit);\\n\\nvar AST_LoopControl = DEFNODE(\\\"LoopControl\\\", \\\"label\\\", {\\n    $documentation: \\\"Base class for loop control statements (`break` and `continue`)\\\",\\n    $propdoc: {\\n        label: \\\"[AST_LabelRef?] the label, or null if none\\\",\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, this.label && function(){\\n            this.label._walk(visitor);\\n        });\\n    }\\n}, AST_Jump);\\n\\nvar AST_Break = DEFNODE(\\\"Break\\\", null, {\\n    $documentation: \\\"A `break` statement\\\"\\n}, AST_LoopControl);\\n\\nvar AST_Continue = DEFNODE(\\\"Continue\\\", null, {\\n    $documentation: \\\"A `continue` statement\\\"\\n}, AST_LoopControl);\\n\\n/* -----[ IF ]----- */\\n\\nvar AST_If = DEFNODE(\\\"If\\\", \\\"condition alternative\\\", {\\n    $documentation: \\\"A `if` statement\\\",\\n    $propdoc: {\\n        condition: \\\"[AST_Node] the `if` condition\\\",\\n        alternative: \\\"[AST_Statement?] the `else` part, or null if not present\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.condition._walk(visitor);\\n            this.body._walk(visitor);\\n            if (this.alternative) this.alternative._walk(visitor);\\n        });\\n    }\\n}, AST_StatementWithBody);\\n\\n/* -----[ SWITCH ]----- */\\n\\nvar AST_Switch = DEFNODE(\\\"Switch\\\", \\\"expression\\\", {\\n    $documentation: \\\"A `switch` statement\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] the `switch` “discriminant”\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n            walk_body(this, visitor);\\n        });\\n    }\\n}, AST_Block);\\n\\nvar AST_SwitchBranch = DEFNODE(\\\"SwitchBranch\\\", null, {\\n    $documentation: \\\"Base class for `switch` branches\\\",\\n}, AST_Block);\\n\\nvar AST_Default = DEFNODE(\\\"Default\\\", null, {\\n    $documentation: \\\"A `default` switch branch\\\",\\n}, AST_SwitchBranch);\\n\\nvar AST_Case = DEFNODE(\\\"Case\\\", \\\"expression\\\", {\\n    $documentation: \\\"A `case` switch branch\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] the `case` expression\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n            walk_body(this, visitor);\\n        });\\n    }\\n}, AST_SwitchBranch);\\n\\n/* -----[ EXCEPTIONS ]----- */\\n\\nvar AST_Try = DEFNODE(\\\"Try\\\", \\\"bcatch bfinally\\\", {\\n    $documentation: \\\"A `try` statement\\\",\\n    $propdoc: {\\n        bcatch: \\\"[AST_Catch?] the catch block, or null if not present\\\",\\n        bfinally: \\\"[AST_Finally?] the finally block, or null if not present\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            walk_body(this, visitor);\\n            if (this.bcatch) this.bcatch._walk(visitor);\\n            if (this.bfinally) this.bfinally._walk(visitor);\\n        });\\n    }\\n}, AST_Block);\\n\\nvar AST_Catch = DEFNODE(\\\"Catch\\\", \\\"argname\\\", {\\n    $documentation: \\\"A `catch` node; only makes sense as part of a `try` statement\\\",\\n    $propdoc: {\\n        argname: \\\"[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.argname._walk(visitor);\\n            walk_body(this, visitor);\\n        });\\n    }\\n}, AST_Block);\\n\\nvar AST_Finally = DEFNODE(\\\"Finally\\\", null, {\\n    $documentation: \\\"A `finally` node; only makes sense as part of a `try` statement\\\"\\n}, AST_Block);\\n\\n/* -----[ VAR/CONST ]----- */\\n\\nvar AST_Definitions = DEFNODE(\\\"Definitions\\\", \\\"definitions\\\", {\\n    $documentation: \\\"Base class for `var` or `const` nodes (variable declarations/initializations)\\\",\\n    $propdoc: {\\n        definitions: \\\"[AST_VarDef*] array of variable definitions\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            var definitions = this.definitions;\\n            for (var i = 0, len = definitions.length; i < len; i++) {\\n                definitions[i]._walk(visitor);\\n            }\\n        });\\n    }\\n}, AST_Statement);\\n\\nvar AST_Var = DEFNODE(\\\"Var\\\", null, {\\n    $documentation: \\\"A `var` statement\\\"\\n}, AST_Definitions);\\n\\nvar AST_Let = DEFNODE(\\\"Let\\\", null, {\\n    $documentation: \\\"A `let` statement\\\"\\n}, AST_Definitions);\\n\\nvar AST_Const = DEFNODE(\\\"Const\\\", null, {\\n    $documentation: \\\"A `const` statement\\\"\\n}, AST_Definitions);\\n\\nvar AST_NameMapping = DEFNODE(\\\"NameMapping\\\", \\\"foreign_name name\\\", {\\n    $documentation: \\\"The part of the export/import statement that declare names from a module.\\\",\\n    $propdoc: {\\n        foreign_name: \\\"[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)\\\",\\n        name: \\\"[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module.\\\"\\n    },\\n    _walk: function (visitor) {\\n        return visitor._visit(this, function() {\\n            this.foreign_name._walk(visitor);\\n            this.name._walk(visitor);\\n        });\\n    }\\n})\\n\\nvar AST_Import = DEFNODE(\\\"Import\\\", \\\"imported_name imported_names module_name\\\", {\\n    $documentation: \\\"An `import` statement\\\",\\n    $propdoc: {\\n        imported_name: \\\"[AST_SymbolImport] The name of the variable holding the module's default export.\\\",\\n        imported_names: \\\"[AST_NameMapping*] The names of non-default imported variables\\\",\\n        module_name: \\\"[AST_String] String literal describing where this module came from\\\",\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function() {\\n            if (this.imported_name) {\\n                this.imported_name._walk(visitor);\\n            }\\n            if (this.imported_names) {\\n                this.imported_names.forEach(function(name_import) {\\n                    name_import._walk(visitor);\\n                });\\n            }\\n            this.module_name._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_Export = DEFNODE(\\\"Export\\\", \\\"exported_definition exported_value is_default exported_names module_name\\\", {\\n    $documentation: \\\"An `export` statement\\\",\\n    $propdoc: {\\n        exported_definition: \\\"[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition\\\",\\n        exported_value: \\\"[AST_Node?] An exported value\\\",\\n        exported_names: \\\"[AST_NameMapping*?] List of exported names\\\",\\n        module_name: \\\"[AST_String?] Name of the file to load exports from\\\",\\n        is_default: \\\"[Boolean] Whether this is the default exported value of this module\\\"\\n    },\\n    _walk: function (visitor) {\\n        visitor._visit(this, function () {\\n            if (this.exported_definition) {\\n                this.exported_definition._walk(visitor);\\n            }\\n            if (this.exported_value) {\\n                this.exported_value._walk(visitor);\\n            }\\n            if (this.exported_names) {\\n                this.exported_names.forEach(function(name_export) {\\n                    name_export._walk(visitor);\\n                });\\n            }\\n            if (this.module_name) {\\n                this.module_name._walk(visitor);\\n            }\\n        });\\n    }\\n}, AST_Statement);\\n\\nvar AST_VarDef = DEFNODE(\\\"VarDef\\\", \\\"name value\\\", {\\n    $documentation: \\\"A variable declaration; only appears in a AST_Definitions node\\\",\\n    $propdoc: {\\n        name: \\\"[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable\\\",\\n        value: \\\"[AST_Node?] initializer, or null of there's no initializer\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.name._walk(visitor);\\n            if (this.value) this.value._walk(visitor);\\n        });\\n    }\\n});\\n\\n/* -----[ OTHER ]----- */\\n\\nvar AST_Call = DEFNODE(\\\"Call\\\", \\\"expression args\\\", {\\n    $documentation: \\\"A function call expression\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] expression to invoke as function\\\",\\n        args: \\\"[AST_Node*] array of arguments\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            var args = this.args;\\n            for (var i = 0, len = args.length; i < len; i++) {\\n                args[i]._walk(visitor);\\n            }\\n            this.expression._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_New = DEFNODE(\\\"New\\\", null, {\\n    $documentation: \\\"An object instantiation.  Derives from a function call since it has exactly the same properties\\\"\\n}, AST_Call);\\n\\nvar AST_Sequence = DEFNODE(\\\"Sequence\\\", \\\"expressions\\\", {\\n    $documentation: \\\"A sequence expression (comma-separated expressions)\\\",\\n    $propdoc: {\\n        expressions: \\\"[AST_Node*] array of expressions (at least two)\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expressions.forEach(function(node) {\\n                node._walk(visitor);\\n            });\\n        });\\n    }\\n});\\n\\nvar AST_PropAccess = DEFNODE(\\\"PropAccess\\\", \\\"expression property\\\", {\\n    $documentation: \\\"Base class for property access expressions, i.e. `a.foo` or `a[\\\\\\\"foo\\\\\\\"]`\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] the “container” expression\\\",\\n        property: \\\"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\\\"\\n    }\\n});\\n\\nvar AST_Dot = DEFNODE(\\\"Dot\\\", null, {\\n    $documentation: \\\"A dotted property access expression\\\",\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n        });\\n    }\\n}, AST_PropAccess);\\n\\nvar AST_Sub = DEFNODE(\\\"Sub\\\", null, {\\n    $documentation: \\\"Index-style property access, i.e. `a[\\\\\\\"foo\\\\\\\"]`\\\",\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n            this.property._walk(visitor);\\n        });\\n    }\\n}, AST_PropAccess);\\n\\nvar AST_Unary = DEFNODE(\\\"Unary\\\", \\\"operator expression\\\", {\\n    $documentation: \\\"Base class for unary expressions\\\",\\n    $propdoc: {\\n        operator: \\\"[string] the operator\\\",\\n        expression: \\\"[AST_Node] expression that this unary operator applies to\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_UnaryPrefix = DEFNODE(\\\"UnaryPrefix\\\", null, {\\n    $documentation: \\\"Unary prefix expression, i.e. `typeof i` or `++i`\\\"\\n}, AST_Unary);\\n\\nvar AST_UnaryPostfix = DEFNODE(\\\"UnaryPostfix\\\", null, {\\n    $documentation: \\\"Unary postfix expression, i.e. `i++`\\\"\\n}, AST_Unary);\\n\\nvar AST_Binary = DEFNODE(\\\"Binary\\\", \\\"operator left right\\\", {\\n    $documentation: \\\"Binary expression, i.e. `a + b`\\\",\\n    $propdoc: {\\n        left: \\\"[AST_Node] left-hand side expression\\\",\\n        operator: \\\"[string] the operator\\\",\\n        right: \\\"[AST_Node] right-hand side expression\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.left._walk(visitor);\\n            this.right._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_Conditional = DEFNODE(\\\"Conditional\\\", \\\"condition consequent alternative\\\", {\\n    $documentation: \\\"Conditional expression using the ternary operator, i.e. `a ? b : c`\\\",\\n    $propdoc: {\\n        condition: \\\"[AST_Node]\\\",\\n        consequent: \\\"[AST_Node]\\\",\\n        alternative: \\\"[AST_Node]\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.condition._walk(visitor);\\n            this.consequent._walk(visitor);\\n            this.alternative._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_Assign = DEFNODE(\\\"Assign\\\", null, {\\n    $documentation: \\\"An assignment expression — `a = b + 5`\\\",\\n}, AST_Binary);\\n\\nvar AST_DefaultAssign = DEFNODE(\\\"DefaultAssign\\\", null, {\\n    $documentation: \\\"A default assignment expression like in `(a = 3) => a`\\\"\\n}, AST_Binary);\\n\\n/* -----[ LITERALS ]----- */\\n\\nvar AST_Array = DEFNODE(\\\"Array\\\", \\\"elements\\\", {\\n    $documentation: \\\"An array literal\\\",\\n    $propdoc: {\\n        elements: \\\"[AST_Node*] array of elements\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            var elements = this.elements;\\n            for (var i = 0, len = elements.length; i < len; i++) {\\n                elements[i]._walk(visitor);\\n            }\\n        });\\n    }\\n});\\n\\nvar AST_Object = DEFNODE(\\\"Object\\\", \\\"properties\\\", {\\n    $documentation: \\\"An object literal\\\",\\n    $propdoc: {\\n        properties: \\\"[AST_ObjectProperty*] array of properties\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            var properties = this.properties;\\n            for (var i = 0, len = properties.length; i < len; i++) {\\n                properties[i]._walk(visitor);\\n            }\\n        });\\n    }\\n});\\n\\nvar AST_ObjectProperty = DEFNODE(\\\"ObjectProperty\\\", \\\"key value\\\", {\\n    $documentation: \\\"Base class for literal object properties\\\",\\n    $propdoc: {\\n        key: \\\"[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.\\\",\\n        value: \\\"[AST_Node] property value.  For getters and setters this is an AST_Accessor.\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            if (this.key instanceof AST_Node)\\n                this.key._walk(visitor);\\n            this.value._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_ObjectKeyVal = DEFNODE(\\\"ObjectKeyVal\\\", \\\"quote\\\", {\\n    $documentation: \\\"A key: value object property\\\",\\n    $propdoc: {\\n        quote: \\\"[string] the original quote character\\\"\\n    }\\n}, AST_ObjectProperty);\\n\\nvar AST_ObjectSetter = DEFNODE(\\\"ObjectSetter\\\", \\\"quote static\\\", {\\n    $propdoc: {\\n        quote: \\\"[string|undefined] the original quote character, if any\\\",\\n        static: \\\"[boolean] whether this is a static setter (classes only)\\\"\\n    },\\n    $documentation: \\\"An object setter property\\\",\\n}, AST_ObjectProperty);\\n\\nvar AST_ObjectGetter = DEFNODE(\\\"ObjectGetter\\\", \\\"quote static\\\", {\\n    $propdoc: {\\n        quote: \\\"[string|undefined] the original quote character, if any\\\",\\n        static: \\\"[boolean] whether this is a static getter (classes only)\\\"\\n    },\\n    $documentation: \\\"An object getter property\\\",\\n}, AST_ObjectProperty);\\n\\nvar AST_ConciseMethod = DEFNODE(\\\"ConciseMethod\\\", \\\"quote static is_generator async\\\", {\\n    $propdoc: {\\n        quote: \\\"[string|undefined] the original quote character, if any\\\",\\n        static: \\\"[boolean] is this method static (classes only)\\\",\\n        is_generator: \\\"[boolean] is this a generator method\\\",\\n        async: \\\"[boolean] is this method async\\\",\\n    },\\n    $documentation: \\\"An ES6 concise method inside an object or class\\\"\\n}, AST_ObjectProperty);\\n\\nvar AST_Class = DEFNODE(\\\"Class\\\", \\\"name extends properties inlined\\\", {\\n    $propdoc: {\\n        name: \\\"[AST_SymbolClass|AST_SymbolDefClass?] optional class name.\\\",\\n        extends: \\\"[AST_Node]? optional parent class\\\",\\n        properties: \\\"[AST_ObjectProperty*] array of properties\\\"\\n    },\\n    $documentation: \\\"An ES6 class\\\",\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            if (this.name) {\\n                this.name._walk(visitor);\\n            }\\n            if (this.extends) {\\n                this.extends._walk(visitor);\\n            }\\n            this.properties.forEach(function(prop){\\n                prop._walk(visitor);\\n            });\\n        });\\n    },\\n}, AST_Scope);\\n\\nvar AST_DefClass = DEFNODE(\\\"DefClass\\\", null, {\\n    $documentation: \\\"A class definition\\\",\\n}, AST_Class);\\n\\nvar AST_ClassExpression = DEFNODE(\\\"ClassExpression\\\", null, {\\n    $documentation: \\\"A class expression.\\\"\\n}, AST_Class);\\n\\nvar AST_Symbol = DEFNODE(\\\"Symbol\\\", \\\"scope name thedef\\\", {\\n    $propdoc: {\\n        name: \\\"[string] name of this symbol\\\",\\n        scope: \\\"[AST_Scope/S] the current scope (not necessarily the definition scope)\\\",\\n        thedef: \\\"[SymbolDef/S] the definition of this symbol\\\"\\n    },\\n    $documentation: \\\"Base class for all symbols\\\"\\n});\\n\\nvar AST_NewTarget = DEFNODE(\\\"NewTarget\\\", null, {\\n    $documentation: \\\"A reference to new.target\\\"\\n});\\n\\nvar AST_SymbolDeclaration = DEFNODE(\\\"SymbolDeclaration\\\", \\\"init\\\", {\\n    $documentation: \\\"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)\\\",\\n}, AST_Symbol);\\n\\nvar AST_SymbolVar = DEFNODE(\\\"SymbolVar\\\", null, {\\n    $documentation: \\\"Symbol defining a variable\\\",\\n}, AST_SymbolDeclaration);\\n\\nvar AST_SymbolBlockDeclaration = DEFNODE(\\\"SymbolBlockDeclaration\\\", null, {\\n    $documentation: \\\"Base class for block-scoped declaration symbols\\\"\\n}, AST_SymbolDeclaration);\\n\\nvar AST_SymbolConst = DEFNODE(\\\"SymbolConst\\\", null, {\\n    $documentation: \\\"A constant declaration\\\"\\n}, AST_SymbolBlockDeclaration);\\n\\nvar AST_SymbolLet = DEFNODE(\\\"SymbolLet\\\", null, {\\n    $documentation: \\\"A block-scoped `let` declaration\\\"\\n}, AST_SymbolBlockDeclaration);\\n\\nvar AST_SymbolFunarg = DEFNODE(\\\"SymbolFunarg\\\", null, {\\n    $documentation: \\\"Symbol naming a function argument\\\",\\n}, AST_SymbolVar);\\n\\nvar AST_SymbolDefun = DEFNODE(\\\"SymbolDefun\\\", null, {\\n    $documentation: \\\"Symbol defining a function\\\",\\n}, AST_SymbolDeclaration);\\n\\nvar AST_SymbolMethod = DEFNODE(\\\"SymbolMethod\\\", null, {\\n    $documentation: \\\"Symbol in an object defining a method\\\",\\n}, AST_Symbol);\\n\\nvar AST_SymbolLambda = DEFNODE(\\\"SymbolLambda\\\", null, {\\n    $documentation: \\\"Symbol naming a function expression\\\",\\n}, AST_SymbolDeclaration);\\n\\nvar AST_SymbolDefClass = DEFNODE(\\\"SymbolDefClass\\\", null, {\\n    $documentation: \\\"Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class.\\\"\\n}, AST_SymbolBlockDeclaration);\\n\\nvar AST_SymbolClass = DEFNODE(\\\"SymbolClass\\\", null, {\\n    $documentation: \\\"Symbol naming a class's name. Lexically scoped to the class.\\\"\\n}, AST_SymbolDeclaration);\\n\\nvar AST_SymbolCatch = DEFNODE(\\\"SymbolCatch\\\", null, {\\n    $documentation: \\\"Symbol naming the exception in catch\\\",\\n}, AST_SymbolBlockDeclaration);\\n\\nvar AST_SymbolImport = DEFNODE(\\\"SymbolImport\\\", null, {\\n    $documentation: \\\"Symbol referring to an imported name\\\",\\n}, AST_SymbolBlockDeclaration);\\n\\nvar AST_SymbolImportForeign = DEFNODE(\\\"SymbolImportForeign\\\", null, {\\n    $documentation: \\\"A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes\\\",\\n}, AST_Symbol);\\n\\nvar AST_Label = DEFNODE(\\\"Label\\\", \\\"references\\\", {\\n    $documentation: \\\"Symbol naming a label (declaration)\\\",\\n    $propdoc: {\\n        references: \\\"[AST_LoopControl*] a list of nodes referring to this label\\\"\\n    },\\n    initialize: function() {\\n        this.references = [];\\n        this.thedef = this;\\n    }\\n}, AST_Symbol);\\n\\nvar AST_SymbolRef = DEFNODE(\\\"SymbolRef\\\", null, {\\n    $documentation: \\\"Reference to some symbol (not definition/declaration)\\\",\\n}, AST_Symbol);\\n\\nvar AST_SymbolExport = DEFNODE(\\\"SymbolExport\\\", null, {\\n    $documentation: \\\"Symbol referring to a name to export\\\",\\n}, AST_SymbolRef);\\n\\nvar AST_SymbolExportForeign = DEFNODE(\\\"SymbolExportForeign\\\", null, {\\n    $documentation: \\\"A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes\\\",\\n}, AST_Symbol);\\n\\nvar AST_LabelRef = DEFNODE(\\\"LabelRef\\\", null, {\\n    $documentation: \\\"Reference to a label symbol\\\",\\n}, AST_Symbol);\\n\\nvar AST_This = DEFNODE(\\\"This\\\", null, {\\n    $documentation: \\\"The `this` symbol\\\",\\n}, AST_Symbol);\\n\\nvar AST_Super = DEFNODE(\\\"Super\\\", null, {\\n    $documentation: \\\"The `super` symbol\\\",\\n}, AST_This);\\n\\nvar AST_Constant = DEFNODE(\\\"Constant\\\", null, {\\n    $documentation: \\\"Base class for all constants\\\",\\n    getValue: function() {\\n        return this.value;\\n    }\\n});\\n\\nvar AST_String = DEFNODE(\\\"String\\\", \\\"value quote\\\", {\\n    $documentation: \\\"A string literal\\\",\\n    $propdoc: {\\n        value: \\\"[string] the contents of this string\\\",\\n        quote: \\\"[string] the original quote character\\\"\\n    }\\n}, AST_Constant);\\n\\nvar AST_Number = DEFNODE(\\\"Number\\\", \\\"value literal\\\", {\\n    $documentation: \\\"A number literal\\\",\\n    $propdoc: {\\n        value: \\\"[number] the numeric value\\\",\\n        literal: \\\"[string] numeric value as string (optional)\\\"\\n    }\\n}, AST_Constant);\\n\\nvar AST_RegExp = DEFNODE(\\\"RegExp\\\", \\\"value\\\", {\\n    $documentation: \\\"A regexp literal\\\",\\n    $propdoc: {\\n        value: \\\"[RegExp] the actual regexp\\\"\\n    }\\n}, AST_Constant);\\n\\nvar AST_Atom = DEFNODE(\\\"Atom\\\", null, {\\n    $documentation: \\\"Base class for atoms\\\",\\n}, AST_Constant);\\n\\nvar AST_Null = DEFNODE(\\\"Null\\\", null, {\\n    $documentation: \\\"The `null` atom\\\",\\n    value: null\\n}, AST_Atom);\\n\\nvar AST_NaN = DEFNODE(\\\"NaN\\\", null, {\\n    $documentation: \\\"The impossible value\\\",\\n    value: 0/0\\n}, AST_Atom);\\n\\nvar AST_Undefined = DEFNODE(\\\"Undefined\\\", null, {\\n    $documentation: \\\"The `undefined` value\\\",\\n    value: (function(){}())\\n}, AST_Atom);\\n\\nvar AST_Hole = DEFNODE(\\\"Hole\\\", null, {\\n    $documentation: \\\"A hole in an array\\\",\\n    value: (function(){}())\\n}, AST_Atom);\\n\\nvar AST_Infinity = DEFNODE(\\\"Infinity\\\", null, {\\n    $documentation: \\\"The `Infinity` value\\\",\\n    value: 1/0\\n}, AST_Atom);\\n\\nvar AST_Boolean = DEFNODE(\\\"Boolean\\\", null, {\\n    $documentation: \\\"Base class for booleans\\\",\\n}, AST_Atom);\\n\\nvar AST_False = DEFNODE(\\\"False\\\", null, {\\n    $documentation: \\\"The `false` atom\\\",\\n    value: false\\n}, AST_Boolean);\\n\\nvar AST_True = DEFNODE(\\\"True\\\", null, {\\n    $documentation: \\\"The `true` atom\\\",\\n    value: true\\n}, AST_Boolean);\\n\\nvar AST_Await = DEFNODE(\\\"Await\\\", \\\"expression\\\", {\\n    $documentation: \\\"An `await` statement\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node] the mandatory expression being awaited\\\",\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, function(){\\n            this.expression._walk(visitor);\\n        });\\n    }\\n});\\n\\nvar AST_Yield = DEFNODE(\\\"Yield\\\", \\\"expression is_star\\\", {\\n    $documentation: \\\"A `yield` statement\\\",\\n    $propdoc: {\\n        expression: \\\"[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false\\\",\\n        is_star: \\\"[Boolean] Whether this is a yield or yield* statement\\\"\\n    },\\n    _walk: function(visitor) {\\n        return visitor._visit(this, this.expression && function(){\\n            this.expression._walk(visitor);\\n        });\\n    }\\n});\\n\\n/* -----[ TreeWalker ]----- */\\n\\nfunction TreeWalker(callback) {\\n    this.visit = callback;\\n    this.stack = [];\\n    this.directives = Object.create(null);\\n};\\nTreeWalker.prototype = {\\n    _visit: function(node, descend) {\\n        this.push(node);\\n        var ret = this.visit(node, descend ? function(){\\n            descend.call(node);\\n        } : noop);\\n        if (!ret && descend) {\\n            descend.call(node);\\n        }\\n        this.pop();\\n        return ret;\\n    },\\n    parent: function(n) {\\n        return this.stack[this.stack.length - 2 - (n || 0)];\\n    },\\n    push: function(node) {\\n        if (node instanceof AST_Lambda) {\\n            this.directives = Object.create(this.directives);\\n        } else if (node instanceof AST_Directive && !this.directives[node.value]) {\\n            this.directives[node.value] = node;\\n        } else if (node instanceof AST_Class) {\\n            this.directives = Object.create(this.directives);\\n            if (!this.directives[\\\"use strict\\\"]) {\\n                this.directives[\\\"use strict\\\"] = node;\\n            }\\n        }\\n        this.stack.push(node);\\n    },\\n    pop: function() {\\n        var node = this.stack.pop();\\n        if (node instanceof AST_Lambda || node instanceof AST_Class) {\\n            this.directives = Object.getPrototypeOf(this.directives);\\n        }\\n    },\\n    self: function() {\\n        return this.stack[this.stack.length - 1];\\n    },\\n    find_parent: function(type) {\\n        var stack = this.stack;\\n        for (var i = stack.length; --i >= 0;) {\\n            var x = stack[i];\\n            if (x instanceof type) return x;\\n        }\\n    },\\n    has_directive: function(type) {\\n        var dir = this.directives[type];\\n        if (dir) return dir;\\n        var node = this.stack[this.stack.length - 1];\\n        if (node instanceof AST_Scope && node.body) {\\n            for (var i = 0; i < node.body.length; ++i) {\\n                var st = node.body[i];\\n                if (!(st instanceof AST_Directive)) break;\\n                if (st.value == type) return st;\\n            }\\n        }\\n    },\\n    loopcontrol_target: function(node) {\\n        var stack = this.stack;\\n        if (node.label) for (var i = stack.length; --i >= 0;) {\\n            var x = stack[i];\\n            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)\\n                return x.body;\\n        } else for (var i = stack.length; --i >= 0;) {\\n            var x = stack[i];\\n            if (x instanceof AST_IterationStatement\\n                || node instanceof AST_Break && x instanceof AST_Switch)\\n                return x;\\n        }\\n    }\\n};\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9kaXN0L2Nqcy5qcz9lc01vZHVsZT1mYWxzZSEuL25vZGVfbW9kdWxlcy91Z2xpZnktZXMvbGliL2FzdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Z2xpZnktZXMvbGliL2FzdC5qcz85MDczIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXFxuXFxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxcbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxcbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXFxuXFxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XFxuXFxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxcblxcbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXFxuICAgIGFyZSBtZXQ6XFxuXFxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcXG4gICAgICAgICAgZGlzY2xhaW1lci5cXG5cXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXFxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXFxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXFxuICAgIFNVQ0ggREFNQUdFLlxcblxcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuZnVuY3Rpb24gREVGTk9ERSh0eXBlLCBwcm9wcywgbWV0aG9kcywgYmFzZSkge1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGJhc2UgPSBBU1RfTm9kZTtcXG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSBbXTtcXG4gICAgZWxzZSBwcm9wcyA9IHByb3BzLnNwbGl0KC9cXFxccysvKTtcXG4gICAgdmFyIHNlbGZfcHJvcHMgPSBwcm9wcztcXG4gICAgaWYgKGJhc2UgJiYgYmFzZS5QUk9QUylcXG4gICAgICAgIHByb3BzID0gcHJvcHMuY29uY2F0KGJhc2UuUFJPUFMpO1xcbiAgICB2YXIgY29kZSA9IFxcXCJyZXR1cm4gZnVuY3Rpb24gQVNUX1xcXCIgKyB0eXBlICsgXFxcIihwcm9wcyl7IGlmIChwcm9wcykgeyBcXFwiO1xcbiAgICBmb3IgKHZhciBpID0gcHJvcHMubGVuZ3RoOyAtLWkgPj0gMDspIHtcXG4gICAgICAgIGNvZGUgKz0gXFxcInRoaXMuXFxcIiArIHByb3BzW2ldICsgXFxcIiA9IHByb3BzLlxcXCIgKyBwcm9wc1tpXSArIFxcXCI7XFxcIjtcXG4gICAgfVxcbiAgICB2YXIgcHJvdG8gPSBiYXNlICYmIG5ldyBiYXNlO1xcbiAgICBpZiAocHJvdG8gJiYgcHJvdG8uaW5pdGlhbGl6ZSB8fCAobWV0aG9kcyAmJiBtZXRob2RzLmluaXRpYWxpemUpKVxcbiAgICAgICAgY29kZSArPSBcXFwidGhpcy5pbml0aWFsaXplKCk7XFxcIjtcXG4gICAgY29kZSArPSBcXFwifX1cXFwiO1xcbiAgICB2YXIgY3RvciA9IG5ldyBGdW5jdGlvbihjb2RlKSgpO1xcbiAgICBpZiAocHJvdG8pIHtcXG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XFxuICAgICAgICBjdG9yLkJBU0UgPSBiYXNlO1xcbiAgICB9XFxuICAgIGlmIChiYXNlKSBiYXNlLlNVQkNMQVNTRVMucHVzaChjdG9yKTtcXG4gICAgY3Rvci5wcm90b3R5cGUuQ1RPUiA9IGN0b3I7XFxuICAgIGN0b3IuUFJPUFMgPSBwcm9wcyB8fCBudWxsO1xcbiAgICBjdG9yLlNFTEZfUFJPUFMgPSBzZWxmX3Byb3BzO1xcbiAgICBjdG9yLlNVQkNMQVNTRVMgPSBbXTtcXG4gICAgaWYgKHR5cGUpIHtcXG4gICAgICAgIGN0b3IucHJvdG90eXBlLlRZUEUgPSBjdG9yLlRZUEUgPSB0eXBlO1xcbiAgICB9XFxuICAgIGlmIChtZXRob2RzKSBmb3IgKGkgaW4gbWV0aG9kcykgaWYgKEhPUChtZXRob2RzLCBpKSkge1xcbiAgICAgICAgaWYgKC9eXFxcXCQvLnRlc3QoaSkpIHtcXG4gICAgICAgICAgICBjdG9yW2kuc3Vic3RyKDEpXSA9IG1ldGhvZHNbaV07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlW2ldID0gbWV0aG9kc1tpXTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBjdG9yLkRFRk1FVEhPRCA9IGZ1bmN0aW9uKG5hbWUsIG1ldGhvZCkge1xcbiAgICAgICAgdGhpcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XFxuICAgIH07XFxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIGV4cG9ydHNbXFxcIkFTVF9cXFwiICsgdHlwZV0gPSBjdG9yO1xcbiAgICB9XFxuICAgIHJldHVybiBjdG9yO1xcbn07XFxuXFxudmFyIEFTVF9Ub2tlbiA9IERFRk5PREUoXFxcIlRva2VuXFxcIiwgXFxcInR5cGUgdmFsdWUgbGluZSBjb2wgcG9zIGVuZGxpbmUgZW5kY29sIGVuZHBvcyBubGIgY29tbWVudHNfYmVmb3JlIGNvbW1lbnRzX2FmdGVyIGZpbGUgcmF3XFxcIiwge1xcbn0sIG51bGwpO1xcblxcbnZhciBBU1RfTm9kZSA9IERFRk5PREUoXFxcIk5vZGVcXFwiLCBcXFwic3RhcnQgZW5kXFxcIiwge1xcbiAgICBfY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcXG4gICAgICAgIGlmIChkZWVwKSB7XFxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gc2VsZikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmUodHJ1ZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuQ1RPUih0aGlzKTtcXG4gICAgfSxcXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZShkZWVwKTtcXG4gICAgfSxcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIG9mIGFsbCBBU1Qgbm9kZXNcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgc3RhcnQ6IFxcXCJbQVNUX1Rva2VuXSBUaGUgZmlyc3QgdG9rZW4gb2YgdGhpcyBub2RlXFxcIixcXG4gICAgICAgIGVuZDogXFxcIltBU1RfVG9rZW5dIFRoZSBsYXN0IHRva2VuIG9mIHRoaXMgbm9kZVxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzKTtcXG4gICAgfSxcXG4gICAgd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhbGsodmlzaXRvcik7IC8vIG5vdCBzdXJlIHRoZSBpbmRpcmVjdGlvbiB3aWxsIGJlIGFueSBoZWxwXFxuICAgIH1cXG59LCBudWxsKTtcXG5cXG5BU1RfTm9kZS53YXJuX2Z1bmN0aW9uID0gbnVsbDtcXG5BU1RfTm9kZS53YXJuID0gZnVuY3Rpb24odHh0LCBwcm9wcykge1xcbiAgICBpZiAoQVNUX05vZGUud2Fybl9mdW5jdGlvbilcXG4gICAgICAgIEFTVF9Ob2RlLndhcm5fZnVuY3Rpb24oc3RyaW5nX3RlbXBsYXRlKHR4dCwgcHJvcHMpKTtcXG59O1xcblxcbi8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xcblxcbnZhciBBU1RfU3RhdGVtZW50ID0gREVGTk9ERShcXFwiU3RhdGVtZW50XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkJhc2UgY2xhc3Mgb2YgYWxsIHN0YXRlbWVudHNcXFwiLFxcbn0pO1xcblxcbnZhciBBU1RfRGVidWdnZXIgPSBERUZOT0RFKFxcXCJEZWJ1Z2dlclxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJSZXByZXNlbnRzIGEgZGVidWdnZXIgc3RhdGVtZW50XFxcIixcXG59LCBBU1RfU3RhdGVtZW50KTtcXG5cXG52YXIgQVNUX0RpcmVjdGl2ZSA9IERFRk5PREUoXFxcIkRpcmVjdGl2ZVxcXCIsIFxcXCJ2YWx1ZSBxdW90ZVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJSZXByZXNlbnRzIGEgZGlyZWN0aXZlLCBsaWtlIFxcXFxcXFwidXNlIHN0cmljdFxcXFxcXFwiO1xcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICB2YWx1ZTogXFxcIltzdHJpbmddIFRoZSB2YWx1ZSBvZiB0aGlzIGRpcmVjdGl2ZSBhcyBhIHBsYWluIHN0cmluZyAoaXQncyBub3QgYW4gQVNUX1N0cmluZyEpXFxcIixcXG4gICAgICAgIHF1b3RlOiBcXFwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlclxcXCJcXG4gICAgfSxcXG59LCBBU1RfU3RhdGVtZW50KTtcXG5cXG52YXIgQVNUX1NpbXBsZVN0YXRlbWVudCA9IERFRk5PREUoXFxcIlNpbXBsZVN0YXRlbWVudFxcXCIsIFxcXCJib2R5XFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgc3RhdGVtZW50IGNvbnNpc3Rpbmcgb2YgYW4gZXhwcmVzc2lvbiwgaS5lLiBhID0gMSArIDJcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgYm9keTogXFxcIltBU1RfTm9kZV0gYW4gZXhwcmVzc2lvbiBub2RlIChzaG91bGQgbm90IGJlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudClcXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9TdGF0ZW1lbnQpO1xcblxcbmZ1bmN0aW9uIHdhbGtfYm9keShub2RlLCB2aXNpdG9yKSB7XFxuICAgIHZhciBib2R5ID0gbm9kZS5ib2R5O1xcbiAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XFxuICAgICAgICBib2R5Ll93YWxrKHZpc2l0b3IpO1xcbiAgICB9XFxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIGJvZHlbaV0uX3dhbGsodmlzaXRvcik7XFxuICAgIH1cXG59O1xcblxcbnZhciBBU1RfQmxvY2sgPSBERUZOT0RFKFxcXCJCbG9ja1xcXCIsIFxcXCJib2R5XFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYm9keSBvZiBzdGF0ZW1lbnRzICh1c3VhbGx5IGJyYWNrZXRlZClcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgYm9keTogXFxcIltBU1RfU3RhdGVtZW50Kl0gYW4gYXJyYXkgb2Ygc3RhdGVtZW50c1xcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSwgQVNUX1N0YXRlbWVudCk7XFxuXFxudmFyIEFTVF9CbG9ja1N0YXRlbWVudCA9IERFRk5PREUoXFxcIkJsb2NrU3RhdGVtZW50XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYmxvY2sgc3RhdGVtZW50XFxcIixcXG59LCBBU1RfQmxvY2spO1xcblxcbnZhciBBU1RfRW1wdHlTdGF0ZW1lbnQgPSBERUZOT0RFKFxcXCJFbXB0eVN0YXRlbWVudFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJUaGUgZW1wdHkgc3RhdGVtZW50IChlbXB0eSBibG9jayBvciBzaW1wbHkgYSBzZW1pY29sb24pXFxcIlxcbn0sIEFTVF9TdGF0ZW1lbnQpO1xcblxcbnZhciBBU1RfU3RhdGVtZW50V2l0aEJvZHkgPSBERUZOT0RFKFxcXCJTdGF0ZW1lbnRXaXRoQm9keVxcXCIsIFxcXCJib2R5XFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkJhc2UgY2xhc3MgZm9yIGFsbCBzdGF0ZW1lbnRzIHRoYXQgY29udGFpbiBvbmUgbmVzdGVkIGJvZHk6IGBGb3JgLCBgRm9ySW5gLCBgRG9gLCBgV2hpbGVgLCBgV2l0aGBcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgYm9keTogXFxcIltBU1RfU3RhdGVtZW50XSB0aGUgYm9keTsgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQsIGV2ZW4gaWYgaXQncyBhbiBBU1RfRW1wdHlTdGF0ZW1lbnRcXFwiXFxuICAgIH1cXG59LCBBU1RfU3RhdGVtZW50KTtcXG5cXG52YXIgQVNUX0xhYmVsZWRTdGF0ZW1lbnQgPSBERUZOT0RFKFxcXCJMYWJlbGVkU3RhdGVtZW50XFxcIiwgXFxcImxhYmVsXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlN0YXRlbWVudCB3aXRoIGEgbGFiZWxcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgbGFiZWw6IFxcXCJbQVNUX0xhYmVsXSBhIGxhYmVsIGRlZmluaXRpb25cXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBjbG9uZTogZnVuY3Rpb24oZGVlcCkge1xcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jbG9uZShkZWVwKTtcXG4gICAgICAgIGlmIChkZWVwKSB7XFxuICAgICAgICAgICAgdmFyIGxhYmVsID0gbm9kZS5sYWJlbDtcXG4gICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5sYWJlbDtcXG4gICAgICAgICAgICBub2RlLndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Mb29wQ29udHJvbFxcbiAgICAgICAgICAgICAgICAgICAgJiYgbm9kZS5sYWJlbCAmJiBub2RlLmxhYmVsLnRoZWRlZiA9PT0gZGVmKSB7XFxuICAgICAgICAgICAgICAgICAgICBub2RlLmxhYmVsLnRoZWRlZiA9IGxhYmVsO1xcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwucmVmZXJlbmNlcy5wdXNoKG5vZGUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgIH1cXG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xcblxcbnZhciBBU1RfSXRlcmF0aW9uU3RhdGVtZW50ID0gREVGTk9ERShcXFwiSXRlcmF0aW9uU3RhdGVtZW50XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkludGVybmFsIGNsYXNzLiAgQWxsIGxvb3BzIGluaGVyaXQgZnJvbSBpdC5cXFwiXFxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcXG5cXG52YXIgQVNUX0RXTG9vcCA9IERFRk5PREUoXFxcIkRXTG9vcFxcXCIsIFxcXCJjb25kaXRpb25cXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQmFzZSBjbGFzcyBmb3IgZG8vd2hpbGUgc3RhdGVtZW50c1xcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBjb25kaXRpb246IFxcXCJbQVNUX05vZGVdIHRoZSBsb29wIGNvbmRpdGlvbi4gIFNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50XFxcIlxcbiAgICB9XFxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XFxuXFxudmFyIEFTVF9EbyA9IERFRk5PREUoXFxcIkRvXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYGRvYCBzdGF0ZW1lbnRcXFwiLFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfRFdMb29wKTtcXG5cXG52YXIgQVNUX1doaWxlID0gREVGTk9ERShcXFwiV2hpbGVcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgd2hpbGVgIHN0YXRlbWVudFxcXCIsXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9EV0xvb3ApO1xcblxcbnZhciBBU1RfRm9yID0gREVGTk9ERShcXFwiRm9yXFxcIiwgXFxcImluaXQgY29uZGl0aW9uIHN0ZXBcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgZm9yYCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgaW5pdDogXFxcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCBpbml0aWFsaXphdGlvbiBjb2RlLCBvciBudWxsIGlmIGVtcHR5XFxcIixcXG4gICAgICAgIGNvbmRpdGlvbjogXFxcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCB0ZXJtaW5hdGlvbiBjbGF1c2UsIG9yIG51bGwgaWYgZW1wdHlcXFwiLFxcbiAgICAgICAgc3RlcDogXFxcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCB1cGRhdGUgY2xhdXNlLCBvciBudWxsIGlmIGVtcHR5XFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0Ll93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikgdGhpcy5jb25kaXRpb24uX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcCkgdGhpcy5zdGVwLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XFxuXFxudmFyIEFTVF9Gb3JJbiA9IERFRk5PREUoXFxcIkZvckluXFxcIiwgXFxcImluaXQgb2JqZWN0XFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYGZvciAuLi4gaW5gIHN0YXRlbWVudFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBpbml0OiBcXFwiW0FTVF9Ob2RlXSB0aGUgYGZvci9pbmAgaW5pdGlhbGl6YXRpb24gY29kZVxcXCIsXFxuICAgICAgICBvYmplY3Q6IFxcXCJbQVNUX05vZGVdIHRoZSBvYmplY3QgdGhhdCB3ZSdyZSBsb29waW5nIHRocm91Z2hcXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmluaXQuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgdGhpcy5vYmplY3QuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcXG5cXG52YXIgQVNUX0Zvck9mID0gREVGTk9ERShcXFwiRm9yT2ZcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgZm9yIC4uLiBvZmAgc3RhdGVtZW50XFxcIixcXG59LCBBU1RfRm9ySW4pO1xcblxcbnZhciBBU1RfV2l0aCA9IERFRk5PREUoXFxcIldpdGhcXFwiLCBcXFwiZXhwcmVzc2lvblxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGB3aXRoYCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbjogXFxcIltBU1RfTm9kZV0gdGhlIGB3aXRoYCBleHByZXNzaW9uXFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcXG5cXG4vKiAtLS0tLVsgc2NvcGUgYW5kIGZ1bmN0aW9ucyBdLS0tLS0gKi9cXG5cXG52YXIgQVNUX1Njb3BlID0gREVGTk9ERShcXFwiU2NvcGVcXFwiLCBcXFwidmFyaWFibGVzIGZ1bmN0aW9ucyB1c2VzX3dpdGggdXNlc19ldmFsIHBhcmVudF9zY29wZSBlbmNsb3NlZCBjbmFtZVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBhbGwgc3RhdGVtZW50cyBpbnRyb2R1Y2luZyBhIGxleGljYWwgc2NvcGVcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgdmFyaWFibGVzOiBcXFwiW09iamVjdC9TXSBhIG1hcCBvZiBuYW1lIC0+IFN5bWJvbERlZiBmb3IgYWxsIHZhcmlhYmxlcy9mdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIHNjb3BlXFxcIixcXG4gICAgICAgIGZ1bmN0aW9uczogXFxcIltPYmplY3QvU10gbGlrZSBgdmFyaWFibGVzYCwgYnV0IG9ubHkgbGlzdHMgZnVuY3Rpb24gZGVjbGFyYXRpb25zXFxcIixcXG4gICAgICAgIHVzZXNfd2l0aDogXFxcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XFxcIixcXG4gICAgICAgIHVzZXNfZXZhbDogXFxcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSBjb250YWlucyBhIGRpcmVjdCBjYWxsIHRvIHRoZSBnbG9iYWwgYGV2YWxgXFxcIixcXG4gICAgICAgIHBhcmVudF9zY29wZTogXFxcIltBU1RfU2NvcGU/L1NdIGxpbmsgdG8gdGhlIHBhcmVudCBzY29wZVxcXCIsXFxuICAgICAgICBlbmNsb3NlZDogXFxcIltTeW1ib2xEZWYqL1NdIGEgbGlzdCBvZiBhbGwgc3ltYm9sIGRlZmluaXRpb25zIHRoYXQgYXJlIGFjY2Vzc2VkIGZyb20gdGhpcyBzY29wZSBvciBhbnkgc3Vic2NvcGVzXFxcIixcXG4gICAgICAgIGNuYW1lOiBcXFwiW2ludGVnZXIvU10gY3VycmVudCBpbmRleCBmb3IgbWFuZ2xpbmcgdmFyaWFibGVzICh1c2VkIGludGVybmFsbHkgYnkgdGhlIG1hbmdsZXIpXFxcIixcXG4gICAgfSxcXG4gICAgZ2V0X2RlZnVuX3Njb3BlOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgICAgIHdoaWxlIChzZWxmLmlzX2Jsb2NrX3Njb3BlKCkpIHtcXG4gICAgICAgICAgICBzZWxmID0gc2VsZi5wYXJlbnRfc2NvcGU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgfSxcXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2xvbmUoZGVlcCk7XFxuICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMpIG5vZGUudmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXMuY2xvbmUoKTtcXG4gICAgICAgIGlmICh0aGlzLmZ1bmN0aW9ucykgbm9kZS5mdW5jdGlvbnMgPSB0aGlzLmZ1bmN0aW9ucy5jbG9uZSgpO1xcbiAgICAgICAgaWYgKHRoaXMuZW5jbG9zZWQpIG5vZGUuZW5jbG9zZWQgPSB0aGlzLmVuY2xvc2VkLnNsaWNlKCk7XFxuICAgICAgICByZXR1cm4gbm9kZTtcXG4gICAgfVxcbn0sIEFTVF9CbG9jayk7XFxuXFxudmFyIEFTVF9Ub3BsZXZlbCA9IERFRk5PREUoXFxcIlRvcGxldmVsXFxcIiwgXFxcImdsb2JhbHNcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiVGhlIHRvcGxldmVsIHNjb3BlXFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIGdsb2JhbHM6IFxcXCJbT2JqZWN0L1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdW5kZWNsYXJlZCBuYW1lc1xcXCIsXFxuICAgIH0sXFxuICAgIHdyYXBfY29tbW9uanM6IGZ1bmN0aW9uKG5hbWUpIHtcXG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xcbiAgICAgICAgdmFyIHdyYXBwZWRfdGwgPSBcXFwiKGZ1bmN0aW9uKGV4cG9ydHMpeyckT1JJRyc7fSkodHlwZW9mIFxcXCIgKyBuYW1lICsgXFxcIj09J3VuZGVmaW5lZCc/KFxcXCIgKyBuYW1lICsgXFxcIj17fSk6XFxcIiArIG5hbWUgKyBcXFwiKTtcXFwiO1xcbiAgICAgICAgd3JhcHBlZF90bCA9IHBhcnNlKHdyYXBwZWRfdGwpO1xcbiAgICAgICAgd3JhcHBlZF90bCA9IHdyYXBwZWRfdGwudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24gYmVmb3JlKG5vZGUpe1xcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSAmJiBub2RlLnZhbHVlID09IFxcXCIkT1JJR1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5zcGxpY2UoYm9keSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSkpO1xcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRfdGw7XFxuICAgIH1cXG59LCBBU1RfU2NvcGUpO1xcblxcbnZhciBBU1RfRXhwYW5zaW9uID0gREVGTk9ERShcXFwiRXhwYW5zaW9uXFxcIiwgXFxcImV4cHJlc3Npb25cXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQW4gZXhwYW5kaWJsZSBhcmd1bWVudCwgc3VjaCBhcyAuLi5yZXN0LCBhIHNwbGF0LCBzdWNoIGFzIFsxLDIsLi4uYWxsXSwgb3IgYW4gZXhwYW5zaW9uIGluIGEgdmFyaWFibGUgZGVjbGFyYXRpb24sIHN1Y2ggYXMgdmFyIFtmaXJzdCwgLi4ucmVzdF0gPSBsaXN0XFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIGV4cHJlc3Npb246IFxcXCJbQVNUX05vZGVdIHRoZSB0aGluZyB0byBiZSBleHBhbmRlZFxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbi53YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX0xhbWJkYSA9IERFRk5PREUoXFxcIkxhbWJkYVxcXCIsIFxcXCJuYW1lIGFyZ25hbWVzIHVzZXNfYXJndW1lbnRzIGlzX2dlbmVyYXRvciBhc3luY1xcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBmdW5jdGlvbnNcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgbmFtZTogXFxcIltBU1RfU3ltYm9sRGVjbGFyYXRpb24/XSB0aGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uXFxcIixcXG4gICAgICAgIGFyZ25hbWVzOiBcXFwiW0FTVF9TeW1ib2xGdW5hcmd8QVNUX0Rlc3RydWN0dXJpbmd8QVNUX0V4cGFuc2lvbnxBU1RfRGVmYXVsdEFzc2lnbipdIGFycmF5IG9mIGZ1bmN0aW9uIGFyZ3VtZW50cywgZGVzdHJ1Y3R1cmluZ3MsIG9yIGV4cGFuZGluZyBhcmd1bWVudHNcXFwiLFxcbiAgICAgICAgdXNlc19hcmd1bWVudHM6IFxcXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgZnVuY3Rpb24gYWNjZXNzZXMgdGhlIGFyZ3VtZW50cyBhcnJheVxcXCIsXFxuICAgICAgICBpc19nZW5lcmF0b3I6IFxcXCJbYm9vbGVhbl0gaXMgdGhpcyBhIGdlbmVyYXRvciBtZXRob2RcXFwiLFxcbiAgICAgICAgYXN5bmM6IFxcXCJbYm9vbGVhbl0gaXMgdGhpcyBtZXRob2QgYXN5bmNcXFwiLFxcbiAgICB9LFxcbiAgICBhcmdzX2FzX25hbWVzOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgb3V0ID0gW107XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJnbmFtZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5hcmduYW1lc1tpXSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSB7XFxuICAgICAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQodGhpcy5hcmduYW1lc1tpXS5hbGxfc3ltYm9scygpKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh0aGlzLmFyZ25hbWVzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gb3V0O1xcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSkgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHZhciBhcmduYW1lcyA9IHRoaXMuYXJnbmFtZXM7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ25hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGFyZ25hbWVzW2ldLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9TY29wZSk7XFxuXFxudmFyIEFTVF9BY2Nlc3NvciA9IERFRk5PREUoXFxcIkFjY2Vzc29yXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgc2V0dGVyL2dldHRlciBmdW5jdGlvbi4gIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgYWx3YXlzIG51bGwuXFxcIlxcbn0sIEFTVF9MYW1iZGEpO1xcblxcbnZhciBBU1RfRnVuY3Rpb24gPSBERUZOT0RFKFxcXCJGdW5jdGlvblxcXCIsIFxcXCJpbmxpbmVkXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgZnVuY3Rpb24gZXhwcmVzc2lvblxcXCJcXG59LCBBU1RfTGFtYmRhKTtcXG5cXG52YXIgQVNUX0Fycm93ID0gREVGTk9ERShcXFwiQXJyb3dcXFwiLCBcXFwiaW5saW5lZFxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBbiBFUzYgQXJyb3cgZnVuY3Rpb24gKChhKSA9PiBiKVxcXCJcXG59LCBBU1RfTGFtYmRhKTtcXG5cXG52YXIgQVNUX0RlZnVuID0gREVGTk9ERShcXFwiRGVmdW5cXFwiLCBcXFwiaW5saW5lZFxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGZ1bmN0aW9uIGRlZmluaXRpb25cXFwiXFxufSwgQVNUX0xhbWJkYSk7XFxuXFxuLyogLS0tLS1bIERFU1RSVUNUVVJJTkcgXS0tLS0tICovXFxudmFyIEFTVF9EZXN0cnVjdHVyaW5nID0gREVGTk9ERShcXFwiRGVzdHJ1Y3R1cmluZ1xcXCIsIFxcXCJuYW1lcyBpc19hcnJheVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGRlc3RydWN0dXJpbmcgb2Ygc2V2ZXJhbCBuYW1lcy4gVXNlZCBpbiBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQgYW5kIHdpdGggZGVzdHJ1Y3R1cmluZyBmdW5jdGlvbiBhcmd1bWVudCBuYW1lc1xcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBcXFwibmFtZXNcXFwiOiBcXFwiW0FTVF9Ob2RlKl0gQXJyYXkgb2YgcHJvcGVydGllcyBvciBlbGVtZW50c1xcXCIsXFxuICAgICAgICBcXFwiaXNfYXJyYXlcXFwiOiBcXFwiW0Jvb2xlYW5dIFdoZXRoZXIgdGhlIGRlc3RydWN0dXJpbmcgcmVwcmVzZW50cyBhbiBvYmplY3Qgb3IgYXJyYXlcXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLm5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XFxuICAgICAgICAgICAgICAgIG5hbWUuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG4gICAgYWxsX3N5bWJvbHM6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIG91dCA9IFtdO1xcbiAgICAgICAgdGhpcy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XFxuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5vZGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHtcXG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobm9kZS5leHByZXNzaW9uKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KSk7XFxuICAgICAgICByZXR1cm4gb3V0O1xcbiAgICB9XFxufSk7XFxuXFxudmFyIEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nID0gREVGTk9ERShcXFwiUHJlZml4ZWRUZW1wbGF0ZVN0cmluZ1xcXCIsIFxcXCJ0ZW1wbGF0ZV9zdHJpbmcgcHJlZml4XFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgdGVtcGxhdGVzdHJpbmcgd2l0aCBhIHByZWZpeCwgc3VjaCBhcyBTdHJpbmcucmF3YGZvb2JhcmJhemBcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgdGVtcGxhdGVfc3RyaW5nOiBcXFwiW0FTVF9UZW1wbGF0ZVN0cmluZ10gVGhlIHRlbXBsYXRlIHN0cmluZ1xcXCIsXFxuICAgICAgICBwcmVmaXg6IFxcXCJbQVNUX1N5bWJvbFJlZnxBU1RfUHJvcEFjY2Vzc10gVGhlIHByZWZpeCwgd2hpY2ggY2FuIGJlIGEgc3ltYm9sIHN1Y2ggYXMgYGZvb2Agb3IgYSBkb3R0ZWQgZXhwcmVzc2lvbiBzdWNoIGFzIGBTdHJpbmcucmF3YC5cXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICB0aGlzLnByZWZpeC5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIHRoaXMudGVtcGxhdGVfc3RyaW5nLl93YWxrKHZpc2l0b3IpO1xcbiAgICB9XFxufSlcXG5cXG52YXIgQVNUX1RlbXBsYXRlU3RyaW5nID0gREVGTk9ERShcXFwiVGVtcGxhdGVTdHJpbmdcXFwiLCBcXFwic2VnbWVudHNcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSB0ZW1wbGF0ZSBzdHJpbmcgbGl0ZXJhbFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBzZWdtZW50czogXFxcIltBU1RfTm9kZSpdIE9uZSBvciBtb3JlIHNlZ21lbnRzLCBzdGFydGluZyB3aXRoIEFTVF9UZW1wbGF0ZVNlZ21lbnQuIEFTVF9Ob2RlIG1heSBmb2xsb3cgQVNUX1RlbXBsYXRlU2VnbWVudCwgYnV0IGVhY2ggQVNUX05vZGUgbXVzdCBiZSBmb2xsb3dlZCBieSBBU1RfVGVtcGxhdGVTZWdtZW50LlxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWcpe1xcbiAgICAgICAgICAgICAgICBzZWcuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0pO1xcblxcbnZhciBBU1RfVGVtcGxhdGVTZWdtZW50ID0gREVGTk9ERShcXFwiVGVtcGxhdGVTZWdtZW50XFxcIiwgXFxcInZhbHVlIHJhd1xcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIHNlZ21lbnQgb2YgYSB0ZW1wbGF0ZSBzdHJpbmcgbGl0ZXJhbFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICB2YWx1ZTogXFxcIkNvbnRlbnQgb2YgdGhlIHNlZ21lbnRcXFwiLFxcbiAgICAgICAgcmF3OiBcXFwiUmF3IGNvbnRlbnQgb2YgdGhlIHNlZ21lbnRcXFwiXFxuICAgIH1cXG59KTtcXG5cXG4vKiAtLS0tLVsgSlVNUFMgXS0tLS0tICovXFxuXFxudmFyIEFTVF9KdW1wID0gREVGTk9ERShcXFwiSnVtcFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciDigJxqdW1wc+KAnSAoZm9yIG5vdyB0aGF0J3MgYHJldHVybmAsIGB0aHJvd2AsIGBicmVha2AgYW5kIGBjb250aW51ZWApXFxcIlxcbn0sIEFTVF9TdGF0ZW1lbnQpO1xcblxcbnZhciBBU1RfRXhpdCA9IERFRk5PREUoXFxcIkV4aXRcXFwiLCBcXFwidmFsdWVcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQmFzZSBjbGFzcyBmb3Ig4oCcZXhpdHPigJ0gKGByZXR1cm5gIGFuZCBgdGhyb3dgKVxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICB2YWx1ZTogXFxcIltBU1RfTm9kZT9dIHRoZSB2YWx1ZSByZXR1cm5lZCBvciB0aHJvd24gYnkgdGhpcyBzdGF0ZW1lbnQ7IGNvdWxkIGJlIG51bGwgZm9yIEFTVF9SZXR1cm5cXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgdGhpcy52YWx1ZSAmJiBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9KdW1wKTtcXG5cXG52YXIgQVNUX1JldHVybiA9IERFRk5PREUoXFxcIlJldHVyblxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGByZXR1cm5gIHN0YXRlbWVudFxcXCJcXG59LCBBU1RfRXhpdCk7XFxuXFxudmFyIEFTVF9UaHJvdyA9IERFRk5PREUoXFxcIlRocm93XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYHRocm93YCBzdGF0ZW1lbnRcXFwiXFxufSwgQVNUX0V4aXQpO1xcblxcbnZhciBBU1RfTG9vcENvbnRyb2wgPSBERUZOT0RFKFxcXCJMb29wQ29udHJvbFxcXCIsIFxcXCJsYWJlbFxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBsb29wIGNvbnRyb2wgc3RhdGVtZW50cyAoYGJyZWFrYCBhbmQgYGNvbnRpbnVlYClcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgbGFiZWw6IFxcXCJbQVNUX0xhYmVsUmVmP10gdGhlIGxhYmVsLCBvciBudWxsIGlmIG5vbmVcXFwiLFxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIHRoaXMubGFiZWwgJiYgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmxhYmVsLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfSnVtcCk7XFxuXFxudmFyIEFTVF9CcmVhayA9IERFRk5PREUoXFxcIkJyZWFrXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYGJyZWFrYCBzdGF0ZW1lbnRcXFwiXFxufSwgQVNUX0xvb3BDb250cm9sKTtcXG5cXG52YXIgQVNUX0NvbnRpbnVlID0gREVGTk9ERShcXFwiQ29udGludWVcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgY29udGludWVgIHN0YXRlbWVudFxcXCJcXG59LCBBU1RfTG9vcENvbnRyb2wpO1xcblxcbi8qIC0tLS0tWyBJRiBdLS0tLS0gKi9cXG5cXG52YXIgQVNUX0lmID0gREVGTk9ERShcXFwiSWZcXFwiLCBcXFwiY29uZGl0aW9uIGFsdGVybmF0aXZlXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYGlmYCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgY29uZGl0aW9uOiBcXFwiW0FTVF9Ob2RlXSB0aGUgYGlmYCBjb25kaXRpb25cXFwiLFxcbiAgICAgICAgYWx0ZXJuYXRpdmU6IFxcXCJbQVNUX1N0YXRlbWVudD9dIHRoZSBgZWxzZWAgcGFydCwgb3IgbnVsbCBpZiBub3QgcHJlc2VudFxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGl2ZSkgdGhpcy5hbHRlcm5hdGl2ZS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcXG5cXG4vKiAtLS0tLVsgU1dJVENIIF0tLS0tLSAqL1xcblxcbnZhciBBU1RfU3dpdGNoID0gREVGTk9ERShcXFwiU3dpdGNoXFxcIiwgXFxcImV4cHJlc3Npb25cXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgc3dpdGNoYCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbjogXFxcIltBU1RfTm9kZV0gdGhlIGBzd2l0Y2hgIOKAnGRpc2NyaW1pbmFudOKAnVxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9CbG9jayk7XFxuXFxudmFyIEFTVF9Td2l0Y2hCcmFuY2ggPSBERUZOT0RFKFxcXCJTd2l0Y2hCcmFuY2hcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQmFzZSBjbGFzcyBmb3IgYHN3aXRjaGAgYnJhbmNoZXNcXFwiLFxcbn0sIEFTVF9CbG9jayk7XFxuXFxudmFyIEFTVF9EZWZhdWx0ID0gREVGTk9ERShcXFwiRGVmYXVsdFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGBkZWZhdWx0YCBzd2l0Y2ggYnJhbmNoXFxcIixcXG59LCBBU1RfU3dpdGNoQnJhbmNoKTtcXG5cXG52YXIgQVNUX0Nhc2UgPSBERUZOT0RFKFxcXCJDYXNlXFxcIiwgXFxcImV4cHJlc3Npb25cXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgY2FzZWAgc3dpdGNoIGJyYW5jaFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBleHByZXNzaW9uOiBcXFwiW0FTVF9Ob2RlXSB0aGUgYGNhc2VgIGV4cHJlc3Npb25cXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfU3dpdGNoQnJhbmNoKTtcXG5cXG4vKiAtLS0tLVsgRVhDRVBUSU9OUyBdLS0tLS0gKi9cXG5cXG52YXIgQVNUX1RyeSA9IERFRk5PREUoXFxcIlRyeVxcXCIsIFxcXCJiY2F0Y2ggYmZpbmFsbHlcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgdHJ5YCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgYmNhdGNoOiBcXFwiW0FTVF9DYXRjaD9dIHRoZSBjYXRjaCBibG9jaywgb3IgbnVsbCBpZiBub3QgcHJlc2VudFxcXCIsXFxuICAgICAgICBiZmluYWxseTogXFxcIltBU1RfRmluYWxseT9dIHRoZSBmaW5hbGx5IGJsb2NrLCBvciBudWxsIGlmIG5vdCBwcmVzZW50XFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xcbiAgICAgICAgICAgIGlmICh0aGlzLmJjYXRjaCkgdGhpcy5iY2F0Y2guX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgaWYgKHRoaXMuYmZpbmFsbHkpIHRoaXMuYmZpbmFsbHkuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9CbG9jayk7XFxuXFxudmFyIEFTVF9DYXRjaCA9IERFRk5PREUoXFxcIkNhdGNoXFxcIiwgXFxcImFyZ25hbWVcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgY2F0Y2hgIG5vZGU7IG9ubHkgbWFrZXMgc2Vuc2UgYXMgcGFydCBvZiBhIGB0cnlgIHN0YXRlbWVudFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBhcmduYW1lOiBcXFwiW0FTVF9TeW1ib2xDYXRjaHxBU1RfRGVzdHJ1Y3R1cmluZ3xBU1RfRXhwYW5zaW9ufEFTVF9EZWZhdWx0QXNzaWduXSBzeW1ib2wgZm9yIHRoZSBleGNlcHRpb25cXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB0aGlzLmFyZ25hbWUuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfQmxvY2spO1xcblxcbnZhciBBU1RfRmluYWxseSA9IERFRk5PREUoXFxcIkZpbmFsbHlcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBgZmluYWxseWAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XFxcIlxcbn0sIEFTVF9CbG9jayk7XFxuXFxuLyogLS0tLS1bIFZBUi9DT05TVCBdLS0tLS0gKi9cXG5cXG52YXIgQVNUX0RlZmluaXRpb25zID0gREVGTk9ERShcXFwiRGVmaW5pdGlvbnNcXFwiLCBcXFwiZGVmaW5pdGlvbnNcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQmFzZSBjbGFzcyBmb3IgYHZhcmAgb3IgYGNvbnN0YCBub2RlcyAodmFyaWFibGUgZGVjbGFyYXRpb25zL2luaXRpYWxpemF0aW9ucylcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZGVmaW5pdGlvbnM6IFxcXCJbQVNUX1ZhckRlZipdIGFycmF5IG9mIHZhcmlhYmxlIGRlZmluaXRpb25zXFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5kZWZpbml0aW9ucztcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVmaW5pdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnNbaV0uX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfU3RhdGVtZW50KTtcXG5cXG52YXIgQVNUX1ZhciA9IERFRk5PREUoXFxcIlZhclxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGB2YXJgIHN0YXRlbWVudFxcXCJcXG59LCBBU1RfRGVmaW5pdGlvbnMpO1xcblxcbnZhciBBU1RfTGV0ID0gREVGTk9ERShcXFwiTGV0XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYGxldGAgc3RhdGVtZW50XFxcIlxcbn0sIEFTVF9EZWZpbml0aW9ucyk7XFxuXFxudmFyIEFTVF9Db25zdCA9IERFRk5PREUoXFxcIkNvbnN0XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYGNvbnN0YCBzdGF0ZW1lbnRcXFwiXFxufSwgQVNUX0RlZmluaXRpb25zKTtcXG5cXG52YXIgQVNUX05hbWVNYXBwaW5nID0gREVGTk9ERShcXFwiTmFtZU1hcHBpbmdcXFwiLCBcXFwiZm9yZWlnbl9uYW1lIG5hbWVcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiVGhlIHBhcnQgb2YgdGhlIGV4cG9ydC9pbXBvcnQgc3RhdGVtZW50IHRoYXQgZGVjbGFyZSBuYW1lcyBmcm9tIGEgbW9kdWxlLlxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBmb3JlaWduX25hbWU6IFxcXCJbQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ258QVNUX1N5bWJvbEltcG9ydEZvcmVpZ25dIFRoZSBuYW1lIGJlaW5nIGV4cG9ydGVkL2ltcG9ydGVkIChhcyBzcGVjaWZpZWQgaW4gdGhlIG1vZHVsZSlcXFwiLFxcbiAgICAgICAgbmFtZTogXFxcIltBU1RfU3ltYm9sRXhwb3J0fEFTVF9TeW1ib2xJbXBvcnRdIFRoZSBuYW1lIGFzIGl0IGlzIHZpc2libGUgdG8gdGhpcyBtb2R1bGUuXFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24gKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICB0aGlzLmZvcmVpZ25fbmFtZS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB0aGlzLm5hbWUuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0pXFxuXFxudmFyIEFTVF9JbXBvcnQgPSBERUZOT0RFKFxcXCJJbXBvcnRcXFwiLCBcXFwiaW1wb3J0ZWRfbmFtZSBpbXBvcnRlZF9uYW1lcyBtb2R1bGVfbmFtZVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBbiBgaW1wb3J0YCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgaW1wb3J0ZWRfbmFtZTogXFxcIltBU1RfU3ltYm9sSW1wb3J0XSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgaG9sZGluZyB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQuXFxcIixcXG4gICAgICAgIGltcG9ydGVkX25hbWVzOiBcXFwiW0FTVF9OYW1lTWFwcGluZypdIFRoZSBuYW1lcyBvZiBub24tZGVmYXVsdCBpbXBvcnRlZCB2YXJpYWJsZXNcXFwiLFxcbiAgICAgICAgbW9kdWxlX25hbWU6IFxcXCJbQVNUX1N0cmluZ10gU3RyaW5nIGxpdGVyYWwgZGVzY3JpYmluZyB3aGVyZSB0aGlzIG1vZHVsZSBjYW1lIGZyb21cXFwiLFxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydGVkX25hbWUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRlZF9uYW1lLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAodGhpcy5pbXBvcnRlZF9uYW1lcykge1xcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydGVkX25hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZV9pbXBvcnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVfaW1wb3J0Ll93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5tb2R1bGVfbmFtZS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSk7XFxuXFxudmFyIEFTVF9FeHBvcnQgPSBERUZOT0RFKFxcXCJFeHBvcnRcXFwiLCBcXFwiZXhwb3J0ZWRfZGVmaW5pdGlvbiBleHBvcnRlZF92YWx1ZSBpc19kZWZhdWx0IGV4cG9ydGVkX25hbWVzIG1vZHVsZV9uYW1lXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkFuIGBleHBvcnRgIHN0YXRlbWVudFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBleHBvcnRlZF9kZWZpbml0aW9uOiBcXFwiW0FTVF9EZWZ1bnxBU1RfRGVmaW5pdGlvbnN8QVNUX0RlZkNsYXNzP10gQW4gZXhwb3J0ZWQgZGVmaW5pdGlvblxcXCIsXFxuICAgICAgICBleHBvcnRlZF92YWx1ZTogXFxcIltBU1RfTm9kZT9dIEFuIGV4cG9ydGVkIHZhbHVlXFxcIixcXG4gICAgICAgIGV4cG9ydGVkX25hbWVzOiBcXFwiW0FTVF9OYW1lTWFwcGluZyo/XSBMaXN0IG9mIGV4cG9ydGVkIG5hbWVzXFxcIixcXG4gICAgICAgIG1vZHVsZV9uYW1lOiBcXFwiW0FTVF9TdHJpbmc/XSBOYW1lIG9mIHRoZSBmaWxlIHRvIGxvYWQgZXhwb3J0cyBmcm9tXFxcIixcXG4gICAgICAgIGlzX2RlZmF1bHQ6IFxcXCJbQm9vbGVhbl0gV2hldGhlciB0aGlzIGlzIHRoZSBkZWZhdWx0IGV4cG9ydGVkIHZhbHVlIG9mIHRoaXMgbW9kdWxlXFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24gKHZpc2l0b3IpIHtcXG4gICAgICAgIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5leHBvcnRlZF9kZWZpbml0aW9uKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWRfZGVmaW5pdGlvbi5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfdmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnRlZF92YWx1ZS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfbmFtZXMpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnRlZF9uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWVfZXhwb3J0KSB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lX2V4cG9ydC5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZHVsZV9uYW1lKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlX25hbWUuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59LCBBU1RfU3RhdGVtZW50KTtcXG5cXG52YXIgQVNUX1ZhckRlZiA9IERFRk5PREUoXFxcIlZhckRlZlxcXCIsIFxcXCJuYW1lIHZhbHVlXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgdmFyaWFibGUgZGVjbGFyYXRpb247IG9ubHkgYXBwZWFycyBpbiBhIEFTVF9EZWZpbml0aW9ucyBub2RlXFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIG5hbWU6IFxcXCJbQVNUX0Rlc3RydWN0dXJpbmd8QVNUX1N5bWJvbENvbnN0fEFTVF9TeW1ib2xMZXR8QVNUX1N5bWJvbFZhcl0gbmFtZSBvZiB0aGUgdmFyaWFibGVcXFwiLFxcbiAgICAgICAgdmFsdWU6IFxcXCJbQVNUX05vZGU/XSBpbml0aWFsaXplciwgb3IgbnVsbCBvZiB0aGVyZSdzIG5vIGluaXRpYWxpemVyXFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG4vKiAtLS0tLVsgT1RIRVIgXS0tLS0tICovXFxuXFxudmFyIEFTVF9DYWxsID0gREVGTk9ERShcXFwiQ2FsbFxcXCIsIFxcXCJleHByZXNzaW9uIGFyZ3NcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBmdW5jdGlvbiBjYWxsIGV4cHJlc3Npb25cXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbjogXFxcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0byBpbnZva2UgYXMgZnVuY3Rpb25cXFwiLFxcbiAgICAgICAgYXJnczogXFxcIltBU1RfTm9kZSpdIGFycmF5IG9mIGFyZ3VtZW50c1xcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGFyZ3NbaV0uX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSk7XFxuXFxudmFyIEFTVF9OZXcgPSBERUZOT0RFKFxcXCJOZXdcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQW4gb2JqZWN0IGluc3RhbnRpYXRpb24uICBEZXJpdmVzIGZyb20gYSBmdW5jdGlvbiBjYWxsIHNpbmNlIGl0IGhhcyBleGFjdGx5IHRoZSBzYW1lIHByb3BlcnRpZXNcXFwiXFxufSwgQVNUX0NhbGwpO1xcblxcbnZhciBBU1RfU2VxdWVuY2UgPSBERUZOT0RFKFxcXCJTZXF1ZW5jZVxcXCIsIFxcXCJleHByZXNzaW9uc1xcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIHNlcXVlbmNlIGV4cHJlc3Npb24gKGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9ucylcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbnM6IFxcXCJbQVNUX05vZGUqXSBhcnJheSBvZiBleHByZXNzaW9ucyAoYXQgbGVhc3QgdHdvKVxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XFxuICAgICAgICAgICAgICAgIG5vZGUuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0pO1xcblxcbnZhciBBU1RfUHJvcEFjY2VzcyA9IERFRk5PREUoXFxcIlByb3BBY2Nlc3NcXFwiLCBcXFwiZXhwcmVzc2lvbiBwcm9wZXJ0eVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvbnMsIGkuZS4gYGEuZm9vYCBvciBgYVtcXFxcXFxcImZvb1xcXFxcXFwiXWBcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbjogXFxcIltBU1RfTm9kZV0gdGhlIOKAnGNvbnRhaW5lcuKAnSBleHByZXNzaW9uXFxcIixcXG4gICAgICAgIHByb3BlcnR5OiBcXFwiW0FTVF9Ob2RlfHN0cmluZ10gdGhlIHByb3BlcnR5IHRvIGFjY2Vzcy4gIEZvciBBU1RfRG90IHRoaXMgaXMgYWx3YXlzIGEgcGxhaW4gc3RyaW5nLCB3aGlsZSBmb3IgQVNUX1N1YiBpdCdzIGFuIGFyYml0cmFyeSBBU1RfTm9kZVxcXCJcXG4gICAgfVxcbn0pO1xcblxcbnZhciBBU1RfRG90ID0gREVGTk9ERShcXFwiRG90XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgZG90dGVkIHByb3BlcnR5IGFjY2VzcyBleHByZXNzaW9uXFxcIixcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSwgQVNUX1Byb3BBY2Nlc3MpO1xcblxcbnZhciBBU1RfU3ViID0gREVGTk9ERShcXFwiU3ViXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkluZGV4LXN0eWxlIHByb3BlcnR5IGFjY2VzcywgaS5lLiBgYVtcXFxcXFxcImZvb1xcXFxcXFwiXWBcXFwiLFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn0sIEFTVF9Qcm9wQWNjZXNzKTtcXG5cXG52YXIgQVNUX1VuYXJ5ID0gREVGTk9ERShcXFwiVW5hcnlcXFwiLCBcXFwib3BlcmF0b3IgZXhwcmVzc2lvblxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciB1bmFyeSBleHByZXNzaW9uc1xcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBvcGVyYXRvcjogXFxcIltzdHJpbmddIHRoZSBvcGVyYXRvclxcXCIsXFxuICAgICAgICBleHByZXNzaW9uOiBcXFwiW0FTVF9Ob2RlXSBleHByZXNzaW9uIHRoYXQgdGhpcyB1bmFyeSBvcGVyYXRvciBhcHBsaWVzIHRvXFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX1VuYXJ5UHJlZml4ID0gREVGTk9ERShcXFwiVW5hcnlQcmVmaXhcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiVW5hcnkgcHJlZml4IGV4cHJlc3Npb24sIGkuZS4gYHR5cGVvZiBpYCBvciBgKytpYFxcXCJcXG59LCBBU1RfVW5hcnkpO1xcblxcbnZhciBBU1RfVW5hcnlQb3N0Zml4ID0gREVGTk9ERShcXFwiVW5hcnlQb3N0Zml4XFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlVuYXJ5IHBvc3RmaXggZXhwcmVzc2lvbiwgaS5lLiBgaSsrYFxcXCJcXG59LCBBU1RfVW5hcnkpO1xcblxcbnZhciBBU1RfQmluYXJ5ID0gREVGTk9ERShcXFwiQmluYXJ5XFxcIiwgXFxcIm9wZXJhdG9yIGxlZnQgcmlnaHRcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQmluYXJ5IGV4cHJlc3Npb24sIGkuZS4gYGEgKyBiYFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBsZWZ0OiBcXFwiW0FTVF9Ob2RlXSBsZWZ0LWhhbmQgc2lkZSBleHByZXNzaW9uXFxcIixcXG4gICAgICAgIG9wZXJhdG9yOiBcXFwiW3N0cmluZ10gdGhlIG9wZXJhdG9yXFxcIixcXG4gICAgICAgIHJpZ2h0OiBcXFwiW0FTVF9Ob2RlXSByaWdodC1oYW5kIHNpZGUgZXhwcmVzc2lvblxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMubGVmdC5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX0NvbmRpdGlvbmFsID0gREVGTk9ERShcXFwiQ29uZGl0aW9uYWxcXFwiLCBcXFwiY29uZGl0aW9uIGNvbnNlcXVlbnQgYWx0ZXJuYXRpdmVcXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiB1c2luZyB0aGUgdGVybmFyeSBvcGVyYXRvciwgaS5lLiBgYSA/IGIgOiBjYFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBjb25kaXRpb246IFxcXCJbQVNUX05vZGVdXFxcIixcXG4gICAgICAgIGNvbnNlcXVlbnQ6IFxcXCJbQVNUX05vZGVdXFxcIixcXG4gICAgICAgIGFsdGVybmF0aXZlOiBcXFwiW0FTVF9Ob2RlXVxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0aXZlLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX0Fzc2lnbiA9IERFRk5PREUoXFxcIkFzc2lnblxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBbiBhc3NpZ25tZW50IGV4cHJlc3Npb24g4oCUIGBhID0gYiArIDVgXFxcIixcXG59LCBBU1RfQmluYXJ5KTtcXG5cXG52YXIgQVNUX0RlZmF1bHRBc3NpZ24gPSBERUZOT0RFKFxcXCJEZWZhdWx0QXNzaWduXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgZGVmYXVsdCBhc3NpZ25tZW50IGV4cHJlc3Npb24gbGlrZSBpbiBgKGEgPSAzKSA9PiBhYFxcXCJcXG59LCBBU1RfQmluYXJ5KTtcXG5cXG4vKiAtLS0tLVsgTElURVJBTFMgXS0tLS0tICovXFxuXFxudmFyIEFTVF9BcnJheSA9IERFRk5PREUoXFxcIkFycmF5XFxcIiwgXFxcImVsZW1lbnRzXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkFuIGFycmF5IGxpdGVyYWxcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZWxlbWVudHM6IFxcXCJbQVNUX05vZGUqXSBhcnJheSBvZiBlbGVtZW50c1xcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2ldLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSk7XFxuXFxudmFyIEFTVF9PYmplY3QgPSBERUZOT0RFKFxcXCJPYmplY3RcXFwiLCBcXFwicHJvcGVydGllc1xcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBbiBvYmplY3QgbGl0ZXJhbFxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICBwcm9wZXJ0aWVzOiBcXFwiW0FTVF9PYmplY3RQcm9wZXJ0eSpdIGFycmF5IG9mIHByb3BlcnRpZXNcXFwiXFxuICAgIH0sXFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XFxuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKXtcXG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2ldLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSk7XFxuXFxudmFyIEFTVF9PYmplY3RQcm9wZXJ0eSA9IERFRk5PREUoXFxcIk9iamVjdFByb3BlcnR5XFxcIiwgXFxcImtleSB2YWx1ZVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBsaXRlcmFsIG9iamVjdCBwcm9wZXJ0aWVzXFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIGtleTogXFxcIltzdHJpbmd8QVNUX05vZGVdIHByb3BlcnR5IG5hbWUuIEZvciBPYmplY3RLZXlWYWwgdGhpcyBpcyBhIHN0cmluZy4gRm9yIGdldHRlcnMsIHNldHRlcnMgYW5kIGNvbXB1dGVkIHByb3BlcnR5IHRoaXMgaXMgYW4gQVNUX05vZGUuXFxcIixcXG4gICAgICAgIHZhbHVlOiBcXFwiW0FTVF9Ob2RlXSBwcm9wZXJ0eSB2YWx1ZS4gIEZvciBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoaXMgaXMgYW4gQVNUX0FjY2Vzc29yLlxcXCJcXG4gICAgfSxcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIGlmICh0aGlzLmtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKVxcbiAgICAgICAgICAgICAgICB0aGlzLmtleS5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX09iamVjdEtleVZhbCA9IERFRk5PREUoXFxcIk9iamVjdEtleVZhbFxcXCIsIFxcXCJxdW90ZVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGtleTogdmFsdWUgb2JqZWN0IHByb3BlcnR5XFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIHF1b3RlOiBcXFwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlclxcXCJcXG4gICAgfVxcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XFxuXFxudmFyIEFTVF9PYmplY3RTZXR0ZXIgPSBERUZOT0RFKFxcXCJPYmplY3RTZXR0ZXJcXFwiLCBcXFwicXVvdGUgc3RhdGljXFxcIiwge1xcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgcXVvdGU6IFxcXCJbc3RyaW5nfHVuZGVmaW5lZF0gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlciwgaWYgYW55XFxcIixcXG4gICAgICAgIHN0YXRpYzogXFxcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYSBzdGF0aWMgc2V0dGVyIChjbGFzc2VzIG9ubHkpXFxcIlxcbiAgICB9LFxcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkFuIG9iamVjdCBzZXR0ZXIgcHJvcGVydHlcXFwiLFxcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XFxuXFxudmFyIEFTVF9PYmplY3RHZXR0ZXIgPSBERUZOT0RFKFxcXCJPYmplY3RHZXR0ZXJcXFwiLCBcXFwicXVvdGUgc3RhdGljXFxcIiwge1xcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgcXVvdGU6IFxcXCJbc3RyaW5nfHVuZGVmaW5lZF0gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlciwgaWYgYW55XFxcIixcXG4gICAgICAgIHN0YXRpYzogXFxcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYSBzdGF0aWMgZ2V0dGVyIChjbGFzc2VzIG9ubHkpXFxcIlxcbiAgICB9LFxcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkFuIG9iamVjdCBnZXR0ZXIgcHJvcGVydHlcXFwiLFxcbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XFxuXFxudmFyIEFTVF9Db25jaXNlTWV0aG9kID0gREVGTk9ERShcXFwiQ29uY2lzZU1ldGhvZFxcXCIsIFxcXCJxdW90ZSBzdGF0aWMgaXNfZ2VuZXJhdG9yIGFzeW5jXFxcIiwge1xcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgcXVvdGU6IFxcXCJbc3RyaW5nfHVuZGVmaW5lZF0gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlciwgaWYgYW55XFxcIixcXG4gICAgICAgIHN0YXRpYzogXFxcIltib29sZWFuXSBpcyB0aGlzIG1ldGhvZCBzdGF0aWMgKGNsYXNzZXMgb25seSlcXFwiLFxcbiAgICAgICAgaXNfZ2VuZXJhdG9yOiBcXFwiW2Jvb2xlYW5dIGlzIHRoaXMgYSBnZW5lcmF0b3IgbWV0aG9kXFxcIixcXG4gICAgICAgIGFzeW5jOiBcXFwiW2Jvb2xlYW5dIGlzIHRoaXMgbWV0aG9kIGFzeW5jXFxcIixcXG4gICAgfSxcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBbiBFUzYgY29uY2lzZSBtZXRob2QgaW5zaWRlIGFuIG9iamVjdCBvciBjbGFzc1xcXCJcXG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xcblxcbnZhciBBU1RfQ2xhc3MgPSBERUZOT0RFKFxcXCJDbGFzc1xcXCIsIFxcXCJuYW1lIGV4dGVuZHMgcHJvcGVydGllcyBpbmxpbmVkXFxcIiwge1xcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgbmFtZTogXFxcIltBU1RfU3ltYm9sQ2xhc3N8QVNUX1N5bWJvbERlZkNsYXNzP10gb3B0aW9uYWwgY2xhc3MgbmFtZS5cXFwiLFxcbiAgICAgICAgZXh0ZW5kczogXFxcIltBU1RfTm9kZV0/IG9wdGlvbmFsIHBhcmVudCBjbGFzc1xcXCIsXFxuICAgICAgICBwcm9wZXJ0aWVzOiBcXFwiW0FTVF9PYmplY3RQcm9wZXJ0eSpdIGFycmF5IG9mIHByb3BlcnRpZXNcXFwiXFxuICAgIH0sXFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQW4gRVM2IGNsYXNzXFxcIixcXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcXG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbmRzKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kcy5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCl7XFxuICAgICAgICAgICAgICAgIHByb3AuX3dhbGsodmlzaXRvcik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG59LCBBU1RfU2NvcGUpO1xcblxcbnZhciBBU1RfRGVmQ2xhc3MgPSBERUZOT0RFKFxcXCJEZWZDbGFzc1xcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGNsYXNzIGRlZmluaXRpb25cXFwiLFxcbn0sIEFTVF9DbGFzcyk7XFxuXFxudmFyIEFTVF9DbGFzc0V4cHJlc3Npb24gPSBERUZOT0RFKFxcXCJDbGFzc0V4cHJlc3Npb25cXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBjbGFzcyBleHByZXNzaW9uLlxcXCJcXG59LCBBU1RfQ2xhc3MpO1xcblxcbnZhciBBU1RfU3ltYm9sID0gREVGTk9ERShcXFwiU3ltYm9sXFxcIiwgXFxcInNjb3BlIG5hbWUgdGhlZGVmXFxcIiwge1xcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgbmFtZTogXFxcIltzdHJpbmddIG5hbWUgb2YgdGhpcyBzeW1ib2xcXFwiLFxcbiAgICAgICAgc2NvcGU6IFxcXCJbQVNUX1Njb3BlL1NdIHRoZSBjdXJyZW50IHNjb3BlIChub3QgbmVjZXNzYXJpbHkgdGhlIGRlZmluaXRpb24gc2NvcGUpXFxcIixcXG4gICAgICAgIHRoZWRlZjogXFxcIltTeW1ib2xEZWYvU10gdGhlIGRlZmluaXRpb24gb2YgdGhpcyBzeW1ib2xcXFwiXFxuICAgIH0sXFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN5bWJvbHNcXFwiXFxufSk7XFxuXFxudmFyIEFTVF9OZXdUYXJnZXQgPSBERUZOT0RFKFxcXCJOZXdUYXJnZXRcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSByZWZlcmVuY2UgdG8gbmV3LnRhcmdldFxcXCJcXG59KTtcXG5cXG52YXIgQVNUX1N5bWJvbERlY2xhcmF0aW9uID0gREVGTk9ERShcXFwiU3ltYm9sRGVjbGFyYXRpb25cXFwiLCBcXFwiaW5pdFxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGRlY2xhcmF0aW9uIHN5bWJvbCAoc3ltYm9sIGluIHZhci9jb25zdCwgZnVuY3Rpb24gbmFtZSBvciBhcmd1bWVudCwgc3ltYm9sIGluIGNhdGNoKVxcXCIsXFxufSwgQVNUX1N5bWJvbCk7XFxuXFxudmFyIEFTVF9TeW1ib2xWYXIgPSBERUZOT0RFKFxcXCJTeW1ib2xWYXJcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIGRlZmluaW5nIGEgdmFyaWFibGVcXFwiLFxcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XFxuXFxudmFyIEFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uID0gREVGTk9ERShcXFwiU3ltYm9sQmxvY2tEZWNsYXJhdGlvblxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBibG9jay1zY29wZWQgZGVjbGFyYXRpb24gc3ltYm9sc1xcXCJcXG59LCBBU1RfU3ltYm9sRGVjbGFyYXRpb24pO1xcblxcbnZhciBBU1RfU3ltYm9sQ29uc3QgPSBERUZOT0RFKFxcXCJTeW1ib2xDb25zdFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGNvbnN0YW50IGRlY2xhcmF0aW9uXFxcIlxcbn0sIEFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uKTtcXG5cXG52YXIgQVNUX1N5bWJvbExldCA9IERFRk5PREUoXFxcIlN5bWJvbExldFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIGJsb2NrLXNjb3BlZCBgbGV0YCBkZWNsYXJhdGlvblxcXCJcXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XFxuXFxudmFyIEFTVF9TeW1ib2xGdW5hcmcgPSBERUZOT0RFKFxcXCJTeW1ib2xGdW5hcmdcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIG5hbWluZyBhIGZ1bmN0aW9uIGFyZ3VtZW50XFxcIixcXG59LCBBU1RfU3ltYm9sVmFyKTtcXG5cXG52YXIgQVNUX1N5bWJvbERlZnVuID0gREVGTk9ERShcXFwiU3ltYm9sRGVmdW5cXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIGRlZmluaW5nIGEgZnVuY3Rpb25cXFwiLFxcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XFxuXFxudmFyIEFTVF9TeW1ib2xNZXRob2QgPSBERUZOT0RFKFxcXCJTeW1ib2xNZXRob2RcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIGluIGFuIG9iamVjdCBkZWZpbmluZyBhIG1ldGhvZFxcXCIsXFxufSwgQVNUX1N5bWJvbCk7XFxuXFxudmFyIEFTVF9TeW1ib2xMYW1iZGEgPSBERUZOT0RFKFxcXCJTeW1ib2xMYW1iZGFcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIG5hbWluZyBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cXFwiLFxcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XFxuXFxudmFyIEFTVF9TeW1ib2xEZWZDbGFzcyA9IERFRk5PREUoXFxcIlN5bWJvbERlZkNsYXNzXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlN5bWJvbCBuYW1pbmcgYSBjbGFzcydzIG5hbWUgaW4gYSBjbGFzcyBkZWNsYXJhdGlvbi4gTGV4aWNhbGx5IHNjb3BlZCB0byBpdHMgY29udGFpbmluZyBzY29wZSwgYW5kIGFjY2Vzc2libGUgd2l0aGluIHRoZSBjbGFzcy5cXFwiXFxufSwgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pO1xcblxcbnZhciBBU1RfU3ltYm9sQ2xhc3MgPSBERUZOT0RFKFxcXCJTeW1ib2xDbGFzc1xcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJTeW1ib2wgbmFtaW5nIGEgY2xhc3MncyBuYW1lLiBMZXhpY2FsbHkgc2NvcGVkIHRvIHRoZSBjbGFzcy5cXFwiXFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcXG5cXG52YXIgQVNUX1N5bWJvbENhdGNoID0gREVGTk9ERShcXFwiU3ltYm9sQ2F0Y2hcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIG5hbWluZyB0aGUgZXhjZXB0aW9uIGluIGNhdGNoXFxcIixcXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XFxuXFxudmFyIEFTVF9TeW1ib2xJbXBvcnQgPSBERUZOT0RFKFxcXCJTeW1ib2xJbXBvcnRcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiU3ltYm9sIHJlZmVycmluZyB0byBhbiBpbXBvcnRlZCBuYW1lXFxcIixcXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XFxuXFxudmFyIEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduID0gREVGTk9ERShcXFwiU3ltYm9sSW1wb3J0Rm9yZWlnblxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIHN5bWJvbCBpbXBvcnRlZCBmcm9tIGEgbW9kdWxlLCBidXQgaXQgaXMgZGVmaW5lZCBpbiB0aGUgb3RoZXIgbW9kdWxlLCBhbmQgaXRzIHJlYWwgbmFtZSBpcyBpcnJlbGV2YW50IGZvciB0aGlzIG1vZHVsZSdzIHB1cnBvc2VzXFxcIixcXG59LCBBU1RfU3ltYm9sKTtcXG5cXG52YXIgQVNUX0xhYmVsID0gREVGTk9ERShcXFwiTGFiZWxcXFwiLCBcXFwicmVmZXJlbmNlc1xcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJTeW1ib2wgbmFtaW5nIGEgbGFiZWwgKGRlY2xhcmF0aW9uKVxcXCIsXFxuICAgICRwcm9wZG9jOiB7XFxuICAgICAgICByZWZlcmVuY2VzOiBcXFwiW0FTVF9Mb29wQ29udHJvbCpdIGEgbGlzdCBvZiBub2RlcyByZWZlcnJpbmcgdG8gdGhpcyBsYWJlbFxcXCJcXG4gICAgfSxcXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcXG4gICAgICAgIHRoaXMudGhlZGVmID0gdGhpcztcXG4gICAgfVxcbn0sIEFTVF9TeW1ib2wpO1xcblxcbnZhciBBU1RfU3ltYm9sUmVmID0gREVGTk9ERShcXFwiU3ltYm9sUmVmXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlJlZmVyZW5jZSB0byBzb21lIHN5bWJvbCAobm90IGRlZmluaXRpb24vZGVjbGFyYXRpb24pXFxcIixcXG59LCBBU1RfU3ltYm9sKTtcXG5cXG52YXIgQVNUX1N5bWJvbEV4cG9ydCA9IERFRk5PREUoXFxcIlN5bWJvbEV4cG9ydFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJTeW1ib2wgcmVmZXJyaW5nIHRvIGEgbmFtZSB0byBleHBvcnRcXFwiLFxcbn0sIEFTVF9TeW1ib2xSZWYpO1xcblxcbnZhciBBU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbiA9IERFRk5PREUoXFxcIlN5bWJvbEV4cG9ydEZvcmVpZ25cXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQSBzeW1ib2wgZXhwb3J0ZWQgZnJvbSB0aGlzIG1vZHVsZSwgYnV0IGl0IGlzIHVzZWQgaW4gdGhlIG90aGVyIG1vZHVsZSwgYW5kIGl0cyByZWFsIG5hbWUgaXMgaXJyZWxldmFudCBmb3IgdGhpcyBtb2R1bGUncyBwdXJwb3Nlc1xcXCIsXFxufSwgQVNUX1N5bWJvbCk7XFxuXFxudmFyIEFTVF9MYWJlbFJlZiA9IERFRk5PREUoXFxcIkxhYmVsUmVmXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlJlZmVyZW5jZSB0byBhIGxhYmVsIHN5bWJvbFxcXCIsXFxufSwgQVNUX1N5bWJvbCk7XFxuXFxudmFyIEFTVF9UaGlzID0gREVGTk9ERShcXFwiVGhpc1xcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJUaGUgYHRoaXNgIHN5bWJvbFxcXCIsXFxufSwgQVNUX1N5bWJvbCk7XFxuXFxudmFyIEFTVF9TdXBlciA9IERFRk5PREUoXFxcIlN1cGVyXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlRoZSBgc3VwZXJgIHN5bWJvbFxcXCIsXFxufSwgQVNUX1RoaXMpO1xcblxcbnZhciBBU1RfQ29uc3RhbnQgPSBERUZOT0RFKFxcXCJDb25zdGFudFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBhbGwgY29uc3RhbnRzXFxcIixcXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX1N0cmluZyA9IERFRk5PREUoXFxcIlN0cmluZ1xcXCIsIFxcXCJ2YWx1ZSBxdW90ZVxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIHN0cmluZyBsaXRlcmFsXFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIHZhbHVlOiBcXFwiW3N0cmluZ10gdGhlIGNvbnRlbnRzIG9mIHRoaXMgc3RyaW5nXFxcIixcXG4gICAgICAgIHF1b3RlOiBcXFwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlclxcXCJcXG4gICAgfVxcbn0sIEFTVF9Db25zdGFudCk7XFxuXFxudmFyIEFTVF9OdW1iZXIgPSBERUZOT0RFKFxcXCJOdW1iZXJcXFwiLCBcXFwidmFsdWUgbGl0ZXJhbFxcXCIsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJBIG51bWJlciBsaXRlcmFsXFxcIixcXG4gICAgJHByb3Bkb2M6IHtcXG4gICAgICAgIHZhbHVlOiBcXFwiW251bWJlcl0gdGhlIG51bWVyaWMgdmFsdWVcXFwiLFxcbiAgICAgICAgbGl0ZXJhbDogXFxcIltzdHJpbmddIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nIChvcHRpb25hbClcXFwiXFxuICAgIH1cXG59LCBBU1RfQ29uc3RhbnQpO1xcblxcbnZhciBBU1RfUmVnRXhwID0gREVGTk9ERShcXFwiUmVnRXhwXFxcIiwgXFxcInZhbHVlXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgcmVnZXhwIGxpdGVyYWxcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgdmFsdWU6IFxcXCJbUmVnRXhwXSB0aGUgYWN0dWFsIHJlZ2V4cFxcXCJcXG4gICAgfVxcbn0sIEFTVF9Db25zdGFudCk7XFxuXFxudmFyIEFTVF9BdG9tID0gREVGTk9ERShcXFwiQXRvbVxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBhdG9tc1xcXCIsXFxufSwgQVNUX0NvbnN0YW50KTtcXG5cXG52YXIgQVNUX051bGwgPSBERUZOT0RFKFxcXCJOdWxsXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlRoZSBgbnVsbGAgYXRvbVxcXCIsXFxuICAgIHZhbHVlOiBudWxsXFxufSwgQVNUX0F0b20pO1xcblxcbnZhciBBU1RfTmFOID0gREVGTk9ERShcXFwiTmFOXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIlRoZSBpbXBvc3NpYmxlIHZhbHVlXFxcIixcXG4gICAgdmFsdWU6IDAvMFxcbn0sIEFTVF9BdG9tKTtcXG5cXG52YXIgQVNUX1VuZGVmaW5lZCA9IERFRk5PREUoXFxcIlVuZGVmaW5lZFxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJUaGUgYHVuZGVmaW5lZGAgdmFsdWVcXFwiLFxcbiAgICB2YWx1ZTogKGZ1bmN0aW9uKCl7fSgpKVxcbn0sIEFTVF9BdG9tKTtcXG5cXG52YXIgQVNUX0hvbGUgPSBERUZOT0RFKFxcXCJIb2xlXFxcIiwgbnVsbCwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgaG9sZSBpbiBhbiBhcnJheVxcXCIsXFxuICAgIHZhbHVlOiAoZnVuY3Rpb24oKXt9KCkpXFxufSwgQVNUX0F0b20pO1xcblxcbnZhciBBU1RfSW5maW5pdHkgPSBERUZOT0RFKFxcXCJJbmZpbml0eVxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJUaGUgYEluZmluaXR5YCB2YWx1ZVxcXCIsXFxuICAgIHZhbHVlOiAxLzBcXG59LCBBU1RfQXRvbSk7XFxuXFxudmFyIEFTVF9Cb29sZWFuID0gREVGTk9ERShcXFwiQm9vbGVhblxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJCYXNlIGNsYXNzIGZvciBib29sZWFuc1xcXCIsXFxufSwgQVNUX0F0b20pO1xcblxcbnZhciBBU1RfRmFsc2UgPSBERUZOT0RFKFxcXCJGYWxzZVxcXCIsIG51bGwsIHtcXG4gICAgJGRvY3VtZW50YXRpb246IFxcXCJUaGUgYGZhbHNlYCBhdG9tXFxcIixcXG4gICAgdmFsdWU6IGZhbHNlXFxufSwgQVNUX0Jvb2xlYW4pO1xcblxcbnZhciBBU1RfVHJ1ZSA9IERFRk5PREUoXFxcIlRydWVcXFwiLCBudWxsLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiVGhlIGB0cnVlYCBhdG9tXFxcIixcXG4gICAgdmFsdWU6IHRydWVcXG59LCBBU1RfQm9vbGVhbik7XFxuXFxudmFyIEFTVF9Bd2FpdCA9IERFRk5PREUoXFxcIkF3YWl0XFxcIiwgXFxcImV4cHJlc3Npb25cXFwiLCB7XFxuICAgICRkb2N1bWVudGF0aW9uOiBcXFwiQW4gYGF3YWl0YCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbjogXFxcIltBU1RfTm9kZV0gdGhlIG1hbmRhdG9yeSBleHByZXNzaW9uIGJlaW5nIGF3YWl0ZWRcXFwiLFxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCl7XFxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG59KTtcXG5cXG52YXIgQVNUX1lpZWxkID0gREVGTk9ERShcXFwiWWllbGRcXFwiLCBcXFwiZXhwcmVzc2lvbiBpc19zdGFyXFxcIiwge1xcbiAgICAkZG9jdW1lbnRhdGlvbjogXFxcIkEgYHlpZWxkYCBzdGF0ZW1lbnRcXFwiLFxcbiAgICAkcHJvcGRvYzoge1xcbiAgICAgICAgZXhwcmVzc2lvbjogXFxcIltBU1RfTm9kZT9dIHRoZSB2YWx1ZSByZXR1cm5lZCBvciB0aHJvd24gYnkgdGhpcyBzdGF0ZW1lbnQ7IGNvdWxkIGJlIG51bGwgKHJlcHJlc2VudGluZyB1bmRlZmluZWQpIGJ1dCBvbmx5IHdoZW4gaXNfc3RhciBpcyBzZXQgdG8gZmFsc2VcXFwiLFxcbiAgICAgICAgaXNfc3RhcjogXFxcIltCb29sZWFuXSBXaGV0aGVyIHRoaXMgaXMgYSB5aWVsZCBvciB5aWVsZCogc3RhdGVtZW50XFxcIlxcbiAgICB9LFxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIHRoaXMuZXhwcmVzc2lvbiAmJiBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSk7XFxuXFxuLyogLS0tLS1bIFRyZWVXYWxrZXIgXS0tLS0tICovXFxuXFxuZnVuY3Rpb24gVHJlZVdhbGtlcihjYWxsYmFjaykge1xcbiAgICB0aGlzLnZpc2l0ID0gY2FsbGJhY2s7XFxuICAgIHRoaXMuc3RhY2sgPSBbXTtcXG4gICAgdGhpcy5kaXJlY3RpdmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG59O1xcblRyZWVXYWxrZXIucHJvdG90eXBlID0ge1xcbiAgICBfdmlzaXQ6IGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpIHtcXG4gICAgICAgIHRoaXMucHVzaChub2RlKTtcXG4gICAgICAgIHZhciByZXQgPSB0aGlzLnZpc2l0KG5vZGUsIGRlc2NlbmQgPyBmdW5jdGlvbigpe1xcbiAgICAgICAgICAgIGRlc2NlbmQuY2FsbChub2RlKTtcXG4gICAgICAgIH0gOiBub29wKTtcXG4gICAgICAgIGlmICghcmV0ICYmIGRlc2NlbmQpIHtcXG4gICAgICAgICAgICBkZXNjZW5kLmNhbGwobm9kZSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLnBvcCgpO1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgfSxcXG4gICAgcGFyZW50OiBmdW5jdGlvbihuKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDIgLSAobiB8fCAwKV07XFxuICAgIH0sXFxuICAgIHB1c2g6IGZ1bmN0aW9uKG5vZGUpIHtcXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSkge1xcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IE9iamVjdC5jcmVhdGUodGhpcy5kaXJlY3RpdmVzKTtcXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUgJiYgIXRoaXMuZGlyZWN0aXZlc1tub2RlLnZhbHVlXSkge1xcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1tub2RlLnZhbHVlXSA9IG5vZGU7XFxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHtcXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMuZGlyZWN0aXZlcyk7XFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGl2ZXNbXFxcInVzZSBzdHJpY3RcXFwiXSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXNbXFxcInVzZSBzdHJpY3RcXFwiXSA9IG5vZGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xcbiAgICB9LFxcbiAgICBwb3A6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHtcXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5kaXJlY3RpdmVzKTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgc2VsZjogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xcbiAgICB9LFxcbiAgICBmaW5kX3BhcmVudDogZnVuY3Rpb24odHlwZSkge1xcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+PSAwOykge1xcbiAgICAgICAgICAgIHZhciB4ID0gc3RhY2tbaV07XFxuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4geDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgaGFzX2RpcmVjdGl2ZTogZnVuY3Rpb24odHlwZSkge1xcbiAgICAgICAgdmFyIGRpciA9IHRoaXMuZGlyZWN0aXZlc1t0eXBlXTtcXG4gICAgICAgIGlmIChkaXIpIHJldHVybiBkaXI7XFxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUuYm9keSkge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5ib2R5Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgICAgIHZhciBzdCA9IG5vZGUuYm9keVtpXTtcXG4gICAgICAgICAgICAgICAgaWYgKCEoc3QgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSkgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGlmIChzdC52YWx1ZSA9PSB0eXBlKSByZXR1cm4gc3Q7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBsb29wY29udHJvbF90YXJnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcXG4gICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2s7XFxuICAgICAgICBpZiAobm9kZS5sYWJlbCkgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XFxuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcXG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9MYWJlbGVkU3RhdGVtZW50ICYmIHgubGFiZWwubmFtZSA9PSBub2RlLmxhYmVsLm5hbWUpXFxuICAgICAgICAgICAgICAgIHJldHVybiB4LmJvZHk7XFxuICAgICAgICB9IGVsc2UgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XFxuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcXG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnRcXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiB4IGluc3RhbmNlb2YgQVNUX1N3aXRjaClcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XFxuICAgICAgICB9XFxuICAgIH1cXG59O1xcblwiOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/ast.js\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/parse.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/parse.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"/***********************************************************************\\n\\n  A JavaScript tokenizer / parser / beautifier / compressor.\\n  https://github.com/mishoo/UglifyJS2\\n\\n  -------------------------------- (C) ---------------------------------\\n\\n                           Author: Mihai Bazon\\n                         <mihai.bazon@gmail.com>\\n                       http://mihai.bazon.net/blog\\n\\n  Distributed under the BSD license:\\n\\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\\n    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\\n\\n    Redistribution and use in source and binary forms, with or without\\n    modification, are permitted provided that the following conditions\\n    are met:\\n\\n        * Redistributions of source code must retain the above\\n          copyright notice, this list of conditions and the following\\n          disclaimer.\\n\\n        * Redistributions in binary form must reproduce the above\\n          copyright notice, this list of conditions and the following\\n          disclaimer in the documentation and/or other materials\\n          provided with the distribution.\\n\\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\\n    SUCH DAMAGE.\\n\\n ***********************************************************************/\\n\\n\\\"use strict\\\";\\n\\nvar KEYWORDS = 'break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with';\\nvar KEYWORDS_ATOM = 'false null true';\\nvar RESERVED_WORDS = 'enum implements import interface package private protected public static super this ' + KEYWORDS_ATOM + \\\" \\\" + KEYWORDS;\\nvar KEYWORDS_BEFORE_EXPRESSION = 'return new delete throw else case yield await';\\n\\nKEYWORDS = makePredicate(KEYWORDS);\\nRESERVED_WORDS = makePredicate(RESERVED_WORDS);\\nKEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\\nKEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\\n\\nvar OPERATOR_CHARS = makePredicate(characters(\\\"+-*&%=<>!?|~^\\\"));\\n\\nvar RE_NUM_LITERAL = /[0-9a-f]/i;\\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\\nvar RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;\\nvar RE_BIN_NUMBER = /^0b[01]+$/i;\\nvar RE_DEC_NUMBER = /^\\\\d*\\\\.?\\\\d*(?:e[+-]?\\\\d*(?:\\\\d\\\\.?|\\\\.?\\\\d)\\\\d*)?$/i;\\n\\nvar OPERATORS = makePredicate([\\n    \\\"in\\\",\\n    \\\"instanceof\\\",\\n    \\\"typeof\\\",\\n    \\\"new\\\",\\n    \\\"void\\\",\\n    \\\"delete\\\",\\n    \\\"++\\\",\\n    \\\"--\\\",\\n    \\\"+\\\",\\n    \\\"-\\\",\\n    \\\"!\\\",\\n    \\\"~\\\",\\n    \\\"&\\\",\\n    \\\"|\\\",\\n    \\\"^\\\",\\n    \\\"*\\\",\\n    \\\"**\\\",\\n    \\\"/\\\",\\n    \\\"%\\\",\\n    \\\">>\\\",\\n    \\\"<<\\\",\\n    \\\">>>\\\",\\n    \\\"<\\\",\\n    \\\">\\\",\\n    \\\"<=\\\",\\n    \\\">=\\\",\\n    \\\"==\\\",\\n    \\\"===\\\",\\n    \\\"!=\\\",\\n    \\\"!==\\\",\\n    \\\"?\\\",\\n    \\\"=\\\",\\n    \\\"+=\\\",\\n    \\\"-=\\\",\\n    \\\"/=\\\",\\n    \\\"*=\\\",\\n    \\\"**=\\\",\\n    \\\"%=\\\",\\n    \\\">>=\\\",\\n    \\\"<<=\\\",\\n    \\\">>>=\\\",\\n    \\\"|=\\\",\\n    \\\"^=\\\",\\n    \\\"&=\\\",\\n    \\\"&&\\\",\\n    \\\"||\\\"\\n]);\\n\\nvar WHITESPACE_CHARS = makePredicate(characters(\\\" \\\\u00a0\\\\n\\\\r\\\\t\\\\f\\\\u000b\\\\u200b\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u2028\\\\u2029\\\\u202f\\\\u205f\\\\u3000\\\\uFEFF\\\"));\\n\\nvar NEWLINE_CHARS = makePredicate(characters(\\\"\\\\n\\\\r\\\\u2028\\\\u2029\\\"));\\n\\nvar PUNC_AFTER_EXPRESSION = makePredicate(characters(\\\";]),:\\\"));\\n\\nvar PUNC_BEFORE_EXPRESSION = makePredicate(characters(\\\"[{(,;:\\\"));\\n\\nvar PUNC_CHARS = makePredicate(characters(\\\"[]{}(),;:\\\"));\\n\\n/* -----[ Tokenizer ]----- */\\n\\n// surrogate safe regexps adapted from https://github.com/mathiasbynens/unicode-8.0.0/tree/89b412d8a71ecca9ed593d9e9fa073ab64acfebe/Binary_Property\\nvar UNICODE = {\\n    ID_Start: /[A-Za-z\\\\xAA\\\\xB5\\\\xBA\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u037F\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u052F\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0620-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0800-\\\\u0815\\\\u081A\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08A0-\\\\u08B4\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0980\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0AF9\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D\\\\u0C58-\\\\u0C5A\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0CF1\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D5F-\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F5\\\\u13F8-\\\\u13FD\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19B0-\\\\u19C9\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1AA7\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5\\\\u1CF6\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2118-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CEE\\\\u2CF2\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u309B-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FD5\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA66E\\\\uA67F-\\\\uA69D\\\\uA6A0-\\\\uA6EF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA7AD\\\\uA7B0-\\\\uA7B7\\\\uA7F7-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA8FD\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9CF\\\\uA9E0-\\\\uA9E4\\\\uA9E6-\\\\uA9EF\\\\uA9FA-\\\\uA9FE\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA76\\\\uAA7A\\\\uAA7E-\\\\uAAAF\\\\uAAB1\\\\uAAB5\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEA\\\\uAAF2-\\\\uAAF4\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uAB30-\\\\uAB5A\\\\uAB5C-\\\\uAB65\\\\uAB70-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]|\\\\uD800[\\\\uDC00-\\\\uDC0B\\\\uDC0D-\\\\uDC26\\\\uDC28-\\\\uDC3A\\\\uDC3C\\\\uDC3D\\\\uDC3F-\\\\uDC4D\\\\uDC50-\\\\uDC5D\\\\uDC80-\\\\uDCFA\\\\uDD40-\\\\uDD74\\\\uDE80-\\\\uDE9C\\\\uDEA0-\\\\uDED0\\\\uDF00-\\\\uDF1F\\\\uDF30-\\\\uDF4A\\\\uDF50-\\\\uDF75\\\\uDF80-\\\\uDF9D\\\\uDFA0-\\\\uDFC3\\\\uDFC8-\\\\uDFCF\\\\uDFD1-\\\\uDFD5]|\\\\uD801[\\\\uDC00-\\\\uDC9D\\\\uDD00-\\\\uDD27\\\\uDD30-\\\\uDD63\\\\uDE00-\\\\uDF36\\\\uDF40-\\\\uDF55\\\\uDF60-\\\\uDF67]|\\\\uD802[\\\\uDC00-\\\\uDC05\\\\uDC08\\\\uDC0A-\\\\uDC35\\\\uDC37\\\\uDC38\\\\uDC3C\\\\uDC3F-\\\\uDC55\\\\uDC60-\\\\uDC76\\\\uDC80-\\\\uDC9E\\\\uDCE0-\\\\uDCF2\\\\uDCF4\\\\uDCF5\\\\uDD00-\\\\uDD15\\\\uDD20-\\\\uDD39\\\\uDD80-\\\\uDDB7\\\\uDDBE\\\\uDDBF\\\\uDE00\\\\uDE10-\\\\uDE13\\\\uDE15-\\\\uDE17\\\\uDE19-\\\\uDE33\\\\uDE60-\\\\uDE7C\\\\uDE80-\\\\uDE9C\\\\uDEC0-\\\\uDEC7\\\\uDEC9-\\\\uDEE4\\\\uDF00-\\\\uDF35\\\\uDF40-\\\\uDF55\\\\uDF60-\\\\uDF72\\\\uDF80-\\\\uDF91]|\\\\uD803[\\\\uDC00-\\\\uDC48\\\\uDC80-\\\\uDCB2\\\\uDCC0-\\\\uDCF2]|\\\\uD804[\\\\uDC03-\\\\uDC37\\\\uDC83-\\\\uDCAF\\\\uDCD0-\\\\uDCE8\\\\uDD03-\\\\uDD26\\\\uDD50-\\\\uDD72\\\\uDD76\\\\uDD83-\\\\uDDB2\\\\uDDC1-\\\\uDDC4\\\\uDDDA\\\\uDDDC\\\\uDE00-\\\\uDE11\\\\uDE13-\\\\uDE2B\\\\uDE80-\\\\uDE86\\\\uDE88\\\\uDE8A-\\\\uDE8D\\\\uDE8F-\\\\uDE9D\\\\uDE9F-\\\\uDEA8\\\\uDEB0-\\\\uDEDE\\\\uDF05-\\\\uDF0C\\\\uDF0F\\\\uDF10\\\\uDF13-\\\\uDF28\\\\uDF2A-\\\\uDF30\\\\uDF32\\\\uDF33\\\\uDF35-\\\\uDF39\\\\uDF3D\\\\uDF50\\\\uDF5D-\\\\uDF61]|\\\\uD805[\\\\uDC80-\\\\uDCAF\\\\uDCC4\\\\uDCC5\\\\uDCC7\\\\uDD80-\\\\uDDAE\\\\uDDD8-\\\\uDDDB\\\\uDE00-\\\\uDE2F\\\\uDE44\\\\uDE80-\\\\uDEAA\\\\uDF00-\\\\uDF19]|\\\\uD806[\\\\uDCA0-\\\\uDCDF\\\\uDCFF\\\\uDEC0-\\\\uDEF8]|\\\\uD808[\\\\uDC00-\\\\uDF99]|\\\\uD809[\\\\uDC00-\\\\uDC6E\\\\uDC80-\\\\uDD43]|[\\\\uD80C\\\\uD840-\\\\uD868\\\\uD86A-\\\\uD86C\\\\uD86F-\\\\uD872][\\\\uDC00-\\\\uDFFF]|\\\\uD80D[\\\\uDC00-\\\\uDC2E]|\\\\uD811[\\\\uDC00-\\\\uDE46]|\\\\uD81A[\\\\uDC00-\\\\uDE38\\\\uDE40-\\\\uDE5E\\\\uDED0-\\\\uDEED\\\\uDF00-\\\\uDF2F\\\\uDF40-\\\\uDF43\\\\uDF63-\\\\uDF77\\\\uDF7D-\\\\uDF8F]|\\\\uD81B[\\\\uDF00-\\\\uDF44\\\\uDF50\\\\uDF93-\\\\uDF9F]|\\\\uD82C[\\\\uDC00\\\\uDC01]|\\\\uD82F[\\\\uDC00-\\\\uDC6A\\\\uDC70-\\\\uDC7C\\\\uDC80-\\\\uDC88\\\\uDC90-\\\\uDC99]|\\\\uD835[\\\\uDC00-\\\\uDC54\\\\uDC56-\\\\uDC9C\\\\uDC9E\\\\uDC9F\\\\uDCA2\\\\uDCA5\\\\uDCA6\\\\uDCA9-\\\\uDCAC\\\\uDCAE-\\\\uDCB9\\\\uDCBB\\\\uDCBD-\\\\uDCC3\\\\uDCC5-\\\\uDD05\\\\uDD07-\\\\uDD0A\\\\uDD0D-\\\\uDD14\\\\uDD16-\\\\uDD1C\\\\uDD1E-\\\\uDD39\\\\uDD3B-\\\\uDD3E\\\\uDD40-\\\\uDD44\\\\uDD46\\\\uDD4A-\\\\uDD50\\\\uDD52-\\\\uDEA5\\\\uDEA8-\\\\uDEC0\\\\uDEC2-\\\\uDEDA\\\\uDEDC-\\\\uDEFA\\\\uDEFC-\\\\uDF14\\\\uDF16-\\\\uDF34\\\\uDF36-\\\\uDF4E\\\\uDF50-\\\\uDF6E\\\\uDF70-\\\\uDF88\\\\uDF8A-\\\\uDFA8\\\\uDFAA-\\\\uDFC2\\\\uDFC4-\\\\uDFCB]|\\\\uD83A[\\\\uDC00-\\\\uDCC4]|\\\\uD83B[\\\\uDE00-\\\\uDE03\\\\uDE05-\\\\uDE1F\\\\uDE21\\\\uDE22\\\\uDE24\\\\uDE27\\\\uDE29-\\\\uDE32\\\\uDE34-\\\\uDE37\\\\uDE39\\\\uDE3B\\\\uDE42\\\\uDE47\\\\uDE49\\\\uDE4B\\\\uDE4D-\\\\uDE4F\\\\uDE51\\\\uDE52\\\\uDE54\\\\uDE57\\\\uDE59\\\\uDE5B\\\\uDE5D\\\\uDE5F\\\\uDE61\\\\uDE62\\\\uDE64\\\\uDE67-\\\\uDE6A\\\\uDE6C-\\\\uDE72\\\\uDE74-\\\\uDE77\\\\uDE79-\\\\uDE7C\\\\uDE7E\\\\uDE80-\\\\uDE89\\\\uDE8B-\\\\uDE9B\\\\uDEA1-\\\\uDEA3\\\\uDEA5-\\\\uDEA9\\\\uDEAB-\\\\uDEBB]|\\\\uD869[\\\\uDC00-\\\\uDED6\\\\uDF00-\\\\uDFFF]|\\\\uD86D[\\\\uDC00-\\\\uDF34\\\\uDF40-\\\\uDFFF]|\\\\uD86E[\\\\uDC00-\\\\uDC1D\\\\uDC20-\\\\uDFFF]|\\\\uD873[\\\\uDC00-\\\\uDEA1]|\\\\uD87E[\\\\uDC00-\\\\uDE1D]/,\\n    ID_Continue: /[0-9A-Z_a-z\\\\xAA\\\\xB5\\\\xB7\\\\xBA\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0300-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u037F\\\\u0386-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u0483-\\\\u0487\\\\u048A-\\\\u052F\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0610-\\\\u061A\\\\u0620-\\\\u0669\\\\u066E-\\\\u06D3\\\\u06D5-\\\\u06DC\\\\u06DF-\\\\u06E8\\\\u06EA-\\\\u06FC\\\\u06FF\\\\u0710-\\\\u074A\\\\u074D-\\\\u07B1\\\\u07C0-\\\\u07F5\\\\u07FA\\\\u0800-\\\\u082D\\\\u0840-\\\\u085B\\\\u08A0-\\\\u08B4\\\\u08E3-\\\\u0963\\\\u0966-\\\\u096F\\\\u0971-\\\\u0983\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BC-\\\\u09C4\\\\u09C7\\\\u09C8\\\\u09CB-\\\\u09CE\\\\u09D7\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E3\\\\u09E6-\\\\u09F1\\\\u0A01-\\\\u0A03\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A3C\\\\u0A3E-\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A66-\\\\u0A75\\\\u0A81-\\\\u0A83\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABC-\\\\u0AC5\\\\u0AC7-\\\\u0AC9\\\\u0ACB-\\\\u0ACD\\\\u0AD0\\\\u0AE0-\\\\u0AE3\\\\u0AE6-\\\\u0AEF\\\\u0AF9\\\\u0B01-\\\\u0B03\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3C-\\\\u0B44\\\\u0B47\\\\u0B48\\\\u0B4B-\\\\u0B4D\\\\u0B56\\\\u0B57\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B63\\\\u0B66-\\\\u0B6F\\\\u0B71\\\\u0B82\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BBE-\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCD\\\\u0BD0\\\\u0BD7\\\\u0BE6-\\\\u0BEF\\\\u0C00-\\\\u0C03\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D-\\\\u0C44\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C58-\\\\u0C5A\\\\u0C60-\\\\u0C63\\\\u0C66-\\\\u0C6F\\\\u0C81-\\\\u0C83\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBC-\\\\u0CC4\\\\u0CC6-\\\\u0CC8\\\\u0CCA-\\\\u0CCD\\\\u0CD5\\\\u0CD6\\\\u0CDE\\\\u0CE0-\\\\u0CE3\\\\u0CE6-\\\\u0CEF\\\\u0CF1\\\\u0CF2\\\\u0D01-\\\\u0D03\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D-\\\\u0D44\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4E\\\\u0D57\\\\u0D5F-\\\\u0D63\\\\u0D66-\\\\u0D6F\\\\u0D7A-\\\\u0D7F\\\\u0D82\\\\u0D83\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0DCA\\\\u0DCF-\\\\u0DD4\\\\u0DD6\\\\u0DD8-\\\\u0DDF\\\\u0DE6-\\\\u0DEF\\\\u0DF2\\\\u0DF3\\\\u0E01-\\\\u0E3A\\\\u0E40-\\\\u0E4E\\\\u0E50-\\\\u0E59\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB9\\\\u0EBB-\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EC8-\\\\u0ECD\\\\u0ED0-\\\\u0ED9\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F18\\\\u0F19\\\\u0F20-\\\\u0F29\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F3E-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F71-\\\\u0F84\\\\u0F86-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u1000-\\\\u1049\\\\u1050-\\\\u109D\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u10D0-\\\\u10FA\\\\u10FC-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u135D-\\\\u135F\\\\u1369-\\\\u1371\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F5\\\\u13F8-\\\\u13FD\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16EE-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1714\\\\u1720-\\\\u1734\\\\u1740-\\\\u1753\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1772\\\\u1773\\\\u1780-\\\\u17D3\\\\u17D7\\\\u17DC\\\\u17DD\\\\u17E0-\\\\u17E9\\\\u180B-\\\\u180D\\\\u1810-\\\\u1819\\\\u1820-\\\\u1877\\\\u1880-\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1920-\\\\u192B\\\\u1930-\\\\u193B\\\\u1946-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19B0-\\\\u19C9\\\\u19D0-\\\\u19DA\\\\u1A00-\\\\u1A1B\\\\u1A20-\\\\u1A5E\\\\u1A60-\\\\u1A7C\\\\u1A7F-\\\\u1A89\\\\u1A90-\\\\u1A99\\\\u1AA7\\\\u1AB0-\\\\u1ABD\\\\u1B00-\\\\u1B4B\\\\u1B50-\\\\u1B59\\\\u1B6B-\\\\u1B73\\\\u1B80-\\\\u1BF3\\\\u1C00-\\\\u1C37\\\\u1C40-\\\\u1C49\\\\u1C4D-\\\\u1C7D\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CF6\\\\u1CF8\\\\u1CF9\\\\u1D00-\\\\u1DF5\\\\u1DFC-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u203F\\\\u2040\\\\u2054\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2118-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2160-\\\\u2188\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2CE4\\\\u2CEB-\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\u2D30-\\\\u2D67\\\\u2D6F\\\\u2D7F-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2DE0-\\\\u2DFF\\\\u3005-\\\\u3007\\\\u3021-\\\\u302F\\\\u3031-\\\\u3035\\\\u3038-\\\\u303C\\\\u3041-\\\\u3096\\\\u3099-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FD5\\\\uA000-\\\\uA48C\\\\uA4D0-\\\\uA4FD\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA62B\\\\uA640-\\\\uA66F\\\\uA674-\\\\uA67D\\\\uA67F-\\\\uA6F1\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA7AD\\\\uA7B0-\\\\uA7B7\\\\uA7F7-\\\\uA827\\\\uA840-\\\\uA873\\\\uA880-\\\\uA8C4\\\\uA8D0-\\\\uA8D9\\\\uA8E0-\\\\uA8F7\\\\uA8FB\\\\uA8FD\\\\uA900-\\\\uA92D\\\\uA930-\\\\uA953\\\\uA960-\\\\uA97C\\\\uA980-\\\\uA9C0\\\\uA9CF-\\\\uA9D9\\\\uA9E0-\\\\uA9FE\\\\uAA00-\\\\uAA36\\\\uAA40-\\\\uAA4D\\\\uAA50-\\\\uAA59\\\\uAA60-\\\\uAA76\\\\uAA7A-\\\\uAAC2\\\\uAADB-\\\\uAADD\\\\uAAE0-\\\\uAAEF\\\\uAAF2-\\\\uAAF6\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uAB30-\\\\uAB5A\\\\uAB5C-\\\\uAB65\\\\uAB70-\\\\uABEA\\\\uABEC\\\\uABED\\\\uABF0-\\\\uABF9\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE2F\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF10-\\\\uFF19\\\\uFF21-\\\\uFF3A\\\\uFF3F\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]|\\\\uD800[\\\\uDC00-\\\\uDC0B\\\\uDC0D-\\\\uDC26\\\\uDC28-\\\\uDC3A\\\\uDC3C\\\\uDC3D\\\\uDC3F-\\\\uDC4D\\\\uDC50-\\\\uDC5D\\\\uDC80-\\\\uDCFA\\\\uDD40-\\\\uDD74\\\\uDDFD\\\\uDE80-\\\\uDE9C\\\\uDEA0-\\\\uDED0\\\\uDEE0\\\\uDF00-\\\\uDF1F\\\\uDF30-\\\\uDF4A\\\\uDF50-\\\\uDF7A\\\\uDF80-\\\\uDF9D\\\\uDFA0-\\\\uDFC3\\\\uDFC8-\\\\uDFCF\\\\uDFD1-\\\\uDFD5]|\\\\uD801[\\\\uDC00-\\\\uDC9D\\\\uDCA0-\\\\uDCA9\\\\uDD00-\\\\uDD27\\\\uDD30-\\\\uDD63\\\\uDE00-\\\\uDF36\\\\uDF40-\\\\uDF55\\\\uDF60-\\\\uDF67]|\\\\uD802[\\\\uDC00-\\\\uDC05\\\\uDC08\\\\uDC0A-\\\\uDC35\\\\uDC37\\\\uDC38\\\\uDC3C\\\\uDC3F-\\\\uDC55\\\\uDC60-\\\\uDC76\\\\uDC80-\\\\uDC9E\\\\uDCE0-\\\\uDCF2\\\\uDCF4\\\\uDCF5\\\\uDD00-\\\\uDD15\\\\uDD20-\\\\uDD39\\\\uDD80-\\\\uDDB7\\\\uDDBE\\\\uDDBF\\\\uDE00-\\\\uDE03\\\\uDE05\\\\uDE06\\\\uDE0C-\\\\uDE13\\\\uDE15-\\\\uDE17\\\\uDE19-\\\\uDE33\\\\uDE38-\\\\uDE3A\\\\uDE3F\\\\uDE60-\\\\uDE7C\\\\uDE80-\\\\uDE9C\\\\uDEC0-\\\\uDEC7\\\\uDEC9-\\\\uDEE6\\\\uDF00-\\\\uDF35\\\\uDF40-\\\\uDF55\\\\uDF60-\\\\uDF72\\\\uDF80-\\\\uDF91]|\\\\uD803[\\\\uDC00-\\\\uDC48\\\\uDC80-\\\\uDCB2\\\\uDCC0-\\\\uDCF2]|\\\\uD804[\\\\uDC00-\\\\uDC46\\\\uDC66-\\\\uDC6F\\\\uDC7F-\\\\uDCBA\\\\uDCD0-\\\\uDCE8\\\\uDCF0-\\\\uDCF9\\\\uDD00-\\\\uDD34\\\\uDD36-\\\\uDD3F\\\\uDD50-\\\\uDD73\\\\uDD76\\\\uDD80-\\\\uDDC4\\\\uDDCA-\\\\uDDCC\\\\uDDD0-\\\\uDDDA\\\\uDDDC\\\\uDE00-\\\\uDE11\\\\uDE13-\\\\uDE37\\\\uDE80-\\\\uDE86\\\\uDE88\\\\uDE8A-\\\\uDE8D\\\\uDE8F-\\\\uDE9D\\\\uDE9F-\\\\uDEA8\\\\uDEB0-\\\\uDEEA\\\\uDEF0-\\\\uDEF9\\\\uDF00-\\\\uDF03\\\\uDF05-\\\\uDF0C\\\\uDF0F\\\\uDF10\\\\uDF13-\\\\uDF28\\\\uDF2A-\\\\uDF30\\\\uDF32\\\\uDF33\\\\uDF35-\\\\uDF39\\\\uDF3C-\\\\uDF44\\\\uDF47\\\\uDF48\\\\uDF4B-\\\\uDF4D\\\\uDF50\\\\uDF57\\\\uDF5D-\\\\uDF63\\\\uDF66-\\\\uDF6C\\\\uDF70-\\\\uDF74]|\\\\uD805[\\\\uDC80-\\\\uDCC5\\\\uDCC7\\\\uDCD0-\\\\uDCD9\\\\uDD80-\\\\uDDB5\\\\uDDB8-\\\\uDDC0\\\\uDDD8-\\\\uDDDD\\\\uDE00-\\\\uDE40\\\\uDE44\\\\uDE50-\\\\uDE59\\\\uDE80-\\\\uDEB7\\\\uDEC0-\\\\uDEC9\\\\uDF00-\\\\uDF19\\\\uDF1D-\\\\uDF2B\\\\uDF30-\\\\uDF39]|\\\\uD806[\\\\uDCA0-\\\\uDCE9\\\\uDCFF\\\\uDEC0-\\\\uDEF8]|\\\\uD808[\\\\uDC00-\\\\uDF99]|\\\\uD809[\\\\uDC00-\\\\uDC6E\\\\uDC80-\\\\uDD43]|[\\\\uD80C\\\\uD840-\\\\uD868\\\\uD86A-\\\\uD86C\\\\uD86F-\\\\uD872][\\\\uDC00-\\\\uDFFF]|\\\\uD80D[\\\\uDC00-\\\\uDC2E]|\\\\uD811[\\\\uDC00-\\\\uDE46]|\\\\uD81A[\\\\uDC00-\\\\uDE38\\\\uDE40-\\\\uDE5E\\\\uDE60-\\\\uDE69\\\\uDED0-\\\\uDEED\\\\uDEF0-\\\\uDEF4\\\\uDF00-\\\\uDF36\\\\uDF40-\\\\uDF43\\\\uDF50-\\\\uDF59\\\\uDF63-\\\\uDF77\\\\uDF7D-\\\\uDF8F]|\\\\uD81B[\\\\uDF00-\\\\uDF44\\\\uDF50-\\\\uDF7E\\\\uDF8F-\\\\uDF9F]|\\\\uD82C[\\\\uDC00\\\\uDC01]|\\\\uD82F[\\\\uDC00-\\\\uDC6A\\\\uDC70-\\\\uDC7C\\\\uDC80-\\\\uDC88\\\\uDC90-\\\\uDC99\\\\uDC9D\\\\uDC9E]|\\\\uD834[\\\\uDD65-\\\\uDD69\\\\uDD6D-\\\\uDD72\\\\uDD7B-\\\\uDD82\\\\uDD85-\\\\uDD8B\\\\uDDAA-\\\\uDDAD\\\\uDE42-\\\\uDE44]|\\\\uD835[\\\\uDC00-\\\\uDC54\\\\uDC56-\\\\uDC9C\\\\uDC9E\\\\uDC9F\\\\uDCA2\\\\uDCA5\\\\uDCA6\\\\uDCA9-\\\\uDCAC\\\\uDCAE-\\\\uDCB9\\\\uDCBB\\\\uDCBD-\\\\uDCC3\\\\uDCC5-\\\\uDD05\\\\uDD07-\\\\uDD0A\\\\uDD0D-\\\\uDD14\\\\uDD16-\\\\uDD1C\\\\uDD1E-\\\\uDD39\\\\uDD3B-\\\\uDD3E\\\\uDD40-\\\\uDD44\\\\uDD46\\\\uDD4A-\\\\uDD50\\\\uDD52-\\\\uDEA5\\\\uDEA8-\\\\uDEC0\\\\uDEC2-\\\\uDEDA\\\\uDEDC-\\\\uDEFA\\\\uDEFC-\\\\uDF14\\\\uDF16-\\\\uDF34\\\\uDF36-\\\\uDF4E\\\\uDF50-\\\\uDF6E\\\\uDF70-\\\\uDF88\\\\uDF8A-\\\\uDFA8\\\\uDFAA-\\\\uDFC2\\\\uDFC4-\\\\uDFCB\\\\uDFCE-\\\\uDFFF]|\\\\uD836[\\\\uDE00-\\\\uDE36\\\\uDE3B-\\\\uDE6C\\\\uDE75\\\\uDE84\\\\uDE9B-\\\\uDE9F\\\\uDEA1-\\\\uDEAF]|\\\\uD83A[\\\\uDC00-\\\\uDCC4\\\\uDCD0-\\\\uDCD6]|\\\\uD83B[\\\\uDE00-\\\\uDE03\\\\uDE05-\\\\uDE1F\\\\uDE21\\\\uDE22\\\\uDE24\\\\uDE27\\\\uDE29-\\\\uDE32\\\\uDE34-\\\\uDE37\\\\uDE39\\\\uDE3B\\\\uDE42\\\\uDE47\\\\uDE49\\\\uDE4B\\\\uDE4D-\\\\uDE4F\\\\uDE51\\\\uDE52\\\\uDE54\\\\uDE57\\\\uDE59\\\\uDE5B\\\\uDE5D\\\\uDE5F\\\\uDE61\\\\uDE62\\\\uDE64\\\\uDE67-\\\\uDE6A\\\\uDE6C-\\\\uDE72\\\\uDE74-\\\\uDE77\\\\uDE79-\\\\uDE7C\\\\uDE7E\\\\uDE80-\\\\uDE89\\\\uDE8B-\\\\uDE9B\\\\uDEA1-\\\\uDEA3\\\\uDEA5-\\\\uDEA9\\\\uDEAB-\\\\uDEBB]|\\\\uD869[\\\\uDC00-\\\\uDED6\\\\uDF00-\\\\uDFFF]|\\\\uD86D[\\\\uDC00-\\\\uDF34\\\\uDF40-\\\\uDFFF]|\\\\uD86E[\\\\uDC00-\\\\uDC1D\\\\uDC20-\\\\uDFFF]|\\\\uD873[\\\\uDC00-\\\\uDEA1]|\\\\uD87E[\\\\uDC00-\\\\uDE1D]|\\\\uDB40[\\\\uDD00-\\\\uDDEF]/,\\n};\\n\\nfunction get_full_char(str, pos) {\\n    var char = str.charAt(pos);\\n    if (is_surrogate_pair_head(char)) {\\n        var next = str.charAt(pos + 1);\\n        if (is_surrogate_pair_tail(next)) {\\n            return char + next;\\n        }\\n    }\\n    if (is_surrogate_pair_tail(char)) {\\n        var prev = str.charAt(pos - 1);\\n        if (is_surrogate_pair_head(prev)) {\\n            return prev + char;\\n        }\\n    }\\n    return char;\\n}\\n\\nfunction get_full_char_code(str, pos) {\\n    // https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\\n    if (is_surrogate_pair_head(str.charAt(pos))) {\\n        return 0x10000 + (str.charCodeAt(pos) - 0xd800 << 10) + str.charCodeAt(pos + 1) - 0xdc00;\\n    }\\n    return str.charCodeAt(pos);\\n}\\n\\nfunction get_full_char_length(str) {\\n    var surrogates = 0;\\n\\n    for (var i = 0; i < str.length; i++) {\\n        if (is_surrogate_pair_head(str.charCodeAt(i))) {\\n            if (is_surrogate_pair_tail(str.charCodeAt(i + 1))) {\\n                surrogates++;\\n                i++;\\n            }\\n        }\\n    }\\n\\n    return str.length - surrogates;\\n}\\n\\nfunction from_char_code(code) {\\n    // Based on https://github.com/mathiasbynens/String.fromCodePoint/blob/master/fromcodepoint.js\\n    if (code > 0xFFFF) {\\n        code -= 0x10000;\\n        return (String.fromCharCode((code >> 10) + 0xD800) +\\n            String.fromCharCode((code % 0x400) + 0xDC00));\\n    }\\n    return String.fromCharCode(code);\\n}\\n\\nfunction is_surrogate_pair_head(code) {\\n    if (typeof code === \\\"string\\\")\\n        code = code.charCodeAt(0);\\n\\n    return code >= 0xd800 && code <= 0xdbff;\\n}\\n\\nfunction is_surrogate_pair_tail(code) {\\n    if (typeof code === \\\"string\\\")\\n        code = code.charCodeAt(0);\\n    return code >= 0xdc00 && code <= 0xdfff;\\n}\\n\\nfunction is_digit(code) {\\n    return code >= 48 && code <= 57;\\n};\\n\\nfunction is_identifier(name) {\\n    if (typeof name !== \\\"string\\\" || RESERVED_WORDS(name))\\n        return false;\\n\\n    return true;\\n};\\n\\nfunction is_identifier_start(ch) {\\n    var code = ch.charCodeAt(0);\\n    return UNICODE.ID_Start.test(ch) || code == 36 || code == 95;\\n};\\n\\nfunction is_identifier_char(ch) {\\n    var code = ch.charCodeAt(0);\\n    return UNICODE.ID_Continue.test(ch)\\n        || code == 36\\n        || code == 95\\n        || code == 8204 // \\\\u200c: zero-width non-joiner <ZWNJ>\\n        || code == 8205 // \\\\u200d: zero-width joiner <ZWJ> (in my ECMA-262 PDF, this is also 200c)\\n    ;\\n};\\n\\nfunction is_identifier_string(str){\\n    return /^[a-z_$][a-z0-9_$]*$/i.test(str);\\n};\\n\\nfunction parse_js_number(num) {\\n    if (RE_HEX_NUMBER.test(num)) {\\n        return parseInt(num.substr(2), 16);\\n    } else if (RE_OCT_NUMBER.test(num)) {\\n        return parseInt(num.substr(1), 8);\\n    } else if (RE_ES6_OCT_NUMBER.test(num)) {\\n        return parseInt(num.substr(2), 8);\\n    } else if (RE_BIN_NUMBER.test(num)) {\\n        return parseInt(num.substr(2), 2);\\n    } else if (RE_DEC_NUMBER.test(num)) {\\n        return parseFloat(num);\\n    } else {\\n        var val = parseFloat(num);\\n        if (val == num) return val;\\n    }\\n};\\n\\nfunction JS_Parse_Error(message, filename, line, col, pos) {\\n    this.message = message;\\n    this.filename = filename;\\n    this.line = line;\\n    this.col = col;\\n    this.pos = pos;\\n};\\nJS_Parse_Error.prototype = Object.create(Error.prototype);\\nJS_Parse_Error.prototype.constructor = JS_Parse_Error;\\nJS_Parse_Error.prototype.name = \\\"SyntaxError\\\";\\nconfigure_error_stack(JS_Parse_Error);\\n\\nfunction js_error(message, filename, line, col, pos) {\\n    throw new JS_Parse_Error(message, filename, line, col, pos);\\n};\\n\\nfunction is_token(token, type, val) {\\n    return token.type == type && (val == null || token.value == val);\\n};\\n\\nvar EX_EOF = {};\\n\\nfunction tokenizer($TEXT, filename, html5_comments, shebang) {\\n\\n    var S = {\\n        text            : $TEXT,\\n        filename        : filename,\\n        pos             : 0,\\n        tokpos          : 0,\\n        line            : 1,\\n        tokline         : 0,\\n        col             : 0,\\n        tokcol          : 0,\\n        newline_before  : false,\\n        regex_allowed   : false,\\n        brace_counter   : 0,\\n        template_braces : [],\\n        comments_before : [],\\n        directives      : {},\\n        directive_stack : []\\n    };\\n\\n    function peek() { return get_full_char(S.text, S.pos); };\\n\\n    function next(signal_eof, in_string) {\\n        var ch = get_full_char(S.text, S.pos++);\\n        if (signal_eof && !ch)\\n            throw EX_EOF;\\n        if (NEWLINE_CHARS(ch)) {\\n            S.newline_before = S.newline_before || !in_string;\\n            ++S.line;\\n            S.col = 0;\\n            if (!in_string && ch == \\\"\\\\r\\\" && peek() == \\\"\\\\n\\\") {\\n                // treat a \\\\r\\\\n sequence as a single \\\\n\\n                ++S.pos;\\n                ch = \\\"\\\\n\\\";\\n            }\\n        } else {\\n            if (ch.length > 1) {\\n                ++S.pos;\\n                ++S.col;\\n            }\\n            ++S.col;\\n        }\\n        return ch;\\n    };\\n\\n    function forward(i) {\\n        while (i-- > 0) next();\\n    };\\n\\n    function looking_at(str) {\\n        return S.text.substr(S.pos, str.length) == str;\\n    };\\n\\n    function find_eol() {\\n        var text = S.text;\\n        for (var i = S.pos, n = S.text.length; i < n; ++i) {\\n            var ch = text[i];\\n            if (NEWLINE_CHARS(ch))\\n                return i;\\n        }\\n        return -1;\\n    };\\n\\n    function find(what, signal_eof) {\\n        var pos = S.text.indexOf(what, S.pos);\\n        if (signal_eof && pos == -1) throw EX_EOF;\\n        return pos;\\n    };\\n\\n    function start_token() {\\n        S.tokline = S.line;\\n        S.tokcol = S.col;\\n        S.tokpos = S.pos;\\n    };\\n\\n    var prev_was_dot = false;\\n    function token(type, value, is_comment) {\\n        S.regex_allowed = ((type == \\\"operator\\\" && !UNARY_POSTFIX(value)) ||\\n                           (type == \\\"keyword\\\" && KEYWORDS_BEFORE_EXPRESSION(value)) ||\\n                           (type == \\\"punc\\\" && PUNC_BEFORE_EXPRESSION(value))) ||\\n                           (type == \\\"arrow\\\");\\n        if (type == \\\"punc\\\" && value == \\\".\\\") {\\n            prev_was_dot = true;\\n        } else if (!is_comment) {\\n            prev_was_dot = false;\\n        }\\n        var ret = {\\n            type    : type,\\n            value   : value,\\n            line    : S.tokline,\\n            col     : S.tokcol,\\n            pos     : S.tokpos,\\n            endline : S.line,\\n            endcol  : S.col,\\n            endpos  : S.pos,\\n            nlb     : S.newline_before,\\n            file    : filename\\n        };\\n        if (/^(?:num|string|regexp)$/i.test(type)) {\\n            ret.raw = $TEXT.substring(ret.pos, ret.endpos);\\n        }\\n        if (!is_comment) {\\n            ret.comments_before = S.comments_before;\\n            ret.comments_after = S.comments_before = [];\\n        }\\n        S.newline_before = false;\\n        return new AST_Token(ret);\\n    };\\n\\n    function skip_whitespace() {\\n        while (WHITESPACE_CHARS(peek()))\\n            next();\\n    };\\n\\n    function read_while(pred) {\\n        var ret = \\\"\\\", ch, i = 0;\\n        while ((ch = peek()) && pred(ch, i++))\\n            ret += next();\\n        return ret;\\n    };\\n\\n    function parse_error(err) {\\n        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\\n    };\\n\\n    function read_num(prefix) {\\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \\\".\\\";\\n        var num = read_while(function(ch, i){\\n            var code = ch.charCodeAt(0);\\n            switch (code) {\\n              case 98: case 66: // bB\\n                return (has_x = true); // Can occur in hex sequence, don't return false yet\\n              case 111: case 79: // oO\\n              case 120: case 88: // xX\\n                return has_x ? false : (has_x = true);\\n              case 101: case 69: // eE\\n                return has_x ? true : has_e ? false : (has_e = after_e = true);\\n              case 45: // -\\n                return after_e || (i == 0 && !prefix);\\n              case 43: // +\\n                return after_e;\\n              case (after_e = false, 46): // .\\n                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;\\n            }\\n            return RE_NUM_LITERAL.test(ch);\\n        });\\n        if (prefix) num = prefix + num;\\n        if (RE_OCT_NUMBER.test(num) && next_token.has_directive(\\\"use strict\\\")) {\\n            parse_error(\\\"Legacy octal literals are not allowed in strict mode\\\");\\n        }\\n        var valid = parse_js_number(num);\\n        if (!isNaN(valid)) {\\n            return token(\\\"num\\\", valid);\\n        } else {\\n            parse_error(\\\"Invalid syntax: \\\" + num);\\n        }\\n    };\\n\\n    function read_escaped_char(in_string) {\\n        var ch = next(true, in_string);\\n        switch (ch.charCodeAt(0)) {\\n          case 110 : return \\\"\\\\n\\\";\\n          case 114 : return \\\"\\\\r\\\";\\n          case 116 : return \\\"\\\\t\\\";\\n          case 98  : return \\\"\\\\b\\\";\\n          case 118 : return \\\"\\\\u000b\\\"; // \\\\v\\n          case 102 : return \\\"\\\\f\\\";\\n          case 120 : return String.fromCharCode(hex_bytes(2)); // \\\\x\\n          case 117 : // \\\\u\\n            if (peek() == \\\"{\\\") {\\n                next(true);\\n                if (peek() === \\\"}\\\")\\n                    parse_error(\\\"Expecting hex-character between {}\\\");\\n                while (peek() == \\\"0\\\") next(true); // No significance\\n                var result, length = find(\\\"}\\\", true) - S.pos;\\n                // Avoid 32 bit integer overflow (1 << 32 === 1)\\n                // We know first character isn't 0 and thus out of range anyway\\n                if (length > 6 || (result = hex_bytes(length)) > 0x10FFFF) {\\n                    parse_error(\\\"Unicode reference out of bounce\\\");\\n                }\\n                next(true);\\n                return from_char_code(result);\\n            }\\n            return String.fromCharCode(hex_bytes(4));\\n          case 10  : return \\\"\\\"; // newline\\n          case 13  :            // \\\\r\\n            if (peek() == \\\"\\\\n\\\") { // DOS newline\\n                next(true, in_string);\\n                return \\\"\\\";\\n            }\\n        }\\n        if (ch >= \\\"0\\\" && ch <= \\\"7\\\")\\n            return read_octal_escape_sequence(ch);\\n        return ch;\\n    };\\n\\n    function read_octal_escape_sequence(ch) {\\n        // Read\\n        var p = peek();\\n        if (p >= \\\"0\\\" && p <= \\\"7\\\") {\\n            ch += next(true);\\n            if (ch[0] <= \\\"3\\\" && (p = peek()) >= \\\"0\\\" && p <= \\\"7\\\")\\n                ch += next(true);\\n        }\\n\\n        // Parse\\n        if (ch === \\\"0\\\") return \\\"\\\\0\\\";\\n        if (ch.length > 0 && next_token.has_directive(\\\"use strict\\\"))\\n            parse_error(\\\"Legacy octal escape sequences are not allowed in strict mode\\\");\\n        return String.fromCharCode(parseInt(ch, 8));\\n    }\\n\\n    function hex_bytes(n) {\\n        var num = 0;\\n        for (; n > 0; --n) {\\n            var digit = parseInt(next(true), 16);\\n            if (isNaN(digit))\\n                parse_error(\\\"Invalid hex-character pattern in string\\\");\\n            num = (num << 4) | digit;\\n        }\\n        return num;\\n    };\\n\\n    var read_string = with_eof_error(\\\"Unterminated string constant\\\", function(quote_char){\\n        var quote = next(), ret = \\\"\\\";\\n        for (;;) {\\n            var ch = next(true, true);\\n            if (ch == \\\"\\\\\\\\\\\") ch = read_escaped_char(true);\\n            else if (NEWLINE_CHARS(ch)) parse_error(\\\"Unterminated string constant\\\");\\n            else if (ch == quote) break;\\n            ret += ch;\\n        }\\n        var tok = token(\\\"string\\\", ret);\\n        tok.quote = quote_char;\\n        return tok;\\n    });\\n\\n    var read_template_characters = with_eof_error(\\\"Unterminated template\\\", function(begin){\\n        if (begin) {\\n            S.template_braces.push(S.brace_counter);\\n        }\\n        var content = \\\"\\\", raw = \\\"\\\", ch, tok;\\n        next(true, true);\\n        while ((ch = next(true, true)) != \\\"`\\\") {\\n            if (ch == \\\"\\\\r\\\") {\\n                if (peek() == \\\"\\\\n\\\") ++S.pos;\\n                ch = \\\"\\\\n\\\";\\n            } else if (ch == \\\"$\\\" && peek() == \\\"{\\\") {\\n                next(true, true);\\n                S.brace_counter++;\\n                tok = token(begin ? \\\"template_head\\\" : \\\"template_substitution\\\", content);\\n                tok.begin = begin;\\n                tok.raw = raw;\\n                tok.end = false;\\n                return tok;\\n            }\\n\\n            raw += ch;\\n            if (ch == \\\"\\\\\\\\\\\") {\\n                var tmp = S.pos;\\n                ch = read_escaped_char();\\n                raw += S.text.substr(tmp, S.pos - tmp);\\n            }\\n\\n            content += ch;\\n        }\\n        S.template_braces.pop();\\n        tok = token(begin ? \\\"template_head\\\" : \\\"template_substitution\\\", content);\\n        tok.begin = begin;\\n        tok.raw = raw;\\n        tok.end = true;\\n        return tok;\\n    });\\n\\n    function skip_line_comment(type) {\\n        var regex_allowed = S.regex_allowed;\\n        var i = find_eol(), ret;\\n        if (i == -1) {\\n            ret = S.text.substr(S.pos);\\n            S.pos = S.text.length;\\n        } else {\\n            ret = S.text.substring(S.pos, i);\\n            S.pos = i;\\n        }\\n        S.col = S.tokcol + (S.pos - S.tokpos);\\n        S.comments_before.push(token(type, ret, true));\\n        S.regex_allowed = regex_allowed;\\n        return next_token;\\n    };\\n\\n    var skip_multiline_comment = with_eof_error(\\\"Unterminated multiline comment\\\", function(){\\n        var regex_allowed = S.regex_allowed;\\n        var i = find(\\\"*/\\\", true);\\n        var text = S.text.substring(S.pos, i).replace(/\\\\r\\\\n|\\\\r|\\\\u2028|\\\\u2029/g, '\\\\n');\\n        // update stream position\\n        forward(get_full_char_length(text) /* text length doesn't count \\\\r\\\\n as 2 char while S.pos - i does */ + 2);\\n        S.comments_before.push(token(\\\"comment2\\\", text, true));\\n        S.newline_before = S.newline_before || text.indexOf(\\\"\\\\n\\\") >= 0;\\n        S.regex_allowed = regex_allowed;\\n        return next_token;\\n    });\\n\\n    var read_name = with_eof_error(\\\"Unterminated identifier name\\\", function() {\\n        var name = \\\"\\\", ch, escaped = false, hex;\\n        var read_escaped_identifier_char = function() {\\n            escaped = true;\\n            next();\\n            if (peek() !== \\\"u\\\") {\\n                parse_error(\\\"Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}\\\");\\n            }\\n            return read_escaped_char();\\n        }\\n\\n        // Read first character (ID_Start)\\n        if ((name = peek()) === \\\"\\\\\\\\\\\") {\\n            name = read_escaped_identifier_char();\\n            if (!is_identifier_start(name)) {\\n                parse_error(\\\"First identifier char is an invalid identifier char\\\");\\n            }\\n        } else if (is_identifier_start(name)){\\n            next();\\n        } else {\\n            return \\\"\\\";\\n        }\\n\\n        // Read ID_Continue\\n        while ((ch = peek()) != null) {\\n            if ((ch = peek()) === \\\"\\\\\\\\\\\") {\\n                ch = read_escaped_identifier_char();\\n                if (!is_identifier_char(ch)) {\\n                    parse_error(\\\"Invalid escaped identifier char\\\");\\n                }\\n            } else {\\n                if (!is_identifier_char(ch)) {\\n                    break;\\n                }\\n                next();\\n            }\\n            name += ch;\\n        }\\n        if (RESERVED_WORDS(name) && escaped) {\\n            parse_error(\\\"Escaped characters are not allowed in keywords\\\");\\n        }\\n        return name;\\n    });\\n\\n    var read_regexp = with_eof_error(\\\"Unterminated regular expression\\\", function(source) {\\n        var prev_backslash = false, ch, in_class = false;\\n        while ((ch = next(true))) if (NEWLINE_CHARS(ch)) {\\n            parse_error(\\\"Unexpected line terminator\\\");\\n        } else if (prev_backslash) {\\n            source += \\\"\\\\\\\\\\\" + ch;\\n            prev_backslash = false;\\n        } else if (ch == \\\"[\\\") {\\n            in_class = true;\\n            source += ch;\\n        } else if (ch == \\\"]\\\" && in_class) {\\n            in_class = false;\\n            source += ch;\\n        } else if (ch == \\\"/\\\" && !in_class) {\\n            break;\\n        } else if (ch == \\\"\\\\\\\\\\\") {\\n            prev_backslash = true;\\n        } else {\\n            source += ch;\\n        }\\n        var mods = read_name();\\n        try {\\n            var regexp = new RegExp(source, mods);\\n            regexp.raw_source = source;\\n            return token(\\\"regexp\\\", regexp);\\n        } catch(e) {\\n            parse_error(e.message);\\n        }\\n    });\\n\\n    function read_operator(prefix) {\\n        function grow(op) {\\n            if (!peek()) return op;\\n            var bigger = op + peek();\\n            if (OPERATORS(bigger)) {\\n                next();\\n                return grow(bigger);\\n            } else {\\n                return op;\\n            }\\n        };\\n        return token(\\\"operator\\\", grow(prefix || next()));\\n    };\\n\\n    function handle_slash() {\\n        next();\\n        switch (peek()) {\\n          case \\\"/\\\":\\n            next();\\n            return skip_line_comment(\\\"comment1\\\");\\n          case \\\"*\\\":\\n            next();\\n            return skip_multiline_comment();\\n        }\\n        return S.regex_allowed ? read_regexp(\\\"\\\") : read_operator(\\\"/\\\");\\n    };\\n\\n    function handle_eq_sign() {\\n        next();\\n        if (peek() === \\\">\\\") {\\n            next();\\n            return token(\\\"arrow\\\", \\\"=>\\\");\\n        } else {\\n            return read_operator(\\\"=\\\");\\n        }\\n    };\\n\\n    function handle_dot() {\\n        next();\\n        if (is_digit(peek().charCodeAt(0))) {\\n            return read_num(\\\".\\\");\\n        }\\n        if (peek() === \\\".\\\") {\\n            next();  // Consume second dot\\n            next();  // Consume third dot\\n            return token(\\\"expand\\\", \\\"...\\\");\\n        }\\n\\n        return token(\\\"punc\\\", \\\".\\\");\\n    };\\n\\n    function read_word() {\\n        var word = read_name();\\n        if (prev_was_dot) return token(\\\"name\\\", word);\\n        return KEYWORDS_ATOM(word) ? token(\\\"atom\\\", word)\\n            : !KEYWORDS(word) ? token(\\\"name\\\", word)\\n            : OPERATORS(word) ? token(\\\"operator\\\", word)\\n            : token(\\\"keyword\\\", word);\\n    };\\n\\n    function with_eof_error(eof_error, cont) {\\n        return function(x) {\\n            try {\\n                return cont(x);\\n            } catch(ex) {\\n                if (ex === EX_EOF) parse_error(eof_error);\\n                else throw ex;\\n            }\\n        };\\n    };\\n\\n    function next_token(force_regexp) {\\n        if (force_regexp != null)\\n            return read_regexp(force_regexp);\\n        if (shebang && S.pos == 0 && looking_at(\\\"#!\\\")) {\\n            start_token();\\n            forward(2);\\n            skip_line_comment(\\\"comment5\\\");\\n        }\\n        for (;;) {\\n            skip_whitespace();\\n            start_token();\\n            if (html5_comments) {\\n                if (looking_at(\\\"<!--\\\")) {\\n                    forward(4);\\n                    skip_line_comment(\\\"comment3\\\");\\n                    continue;\\n                }\\n                if (looking_at(\\\"-->\\\") && S.newline_before) {\\n                    forward(3);\\n                    skip_line_comment(\\\"comment4\\\");\\n                    continue;\\n                }\\n            }\\n            var ch = peek();\\n            if (!ch) return token(\\\"eof\\\");\\n            var code = ch.charCodeAt(0);\\n            switch (code) {\\n              case 34: case 39: return read_string(ch);\\n              case 46: return handle_dot();\\n              case 47: {\\n                  var tok = handle_slash();\\n                  if (tok === next_token) continue;\\n                  return tok;\\n              }\\n              case 61: return handle_eq_sign();\\n              case 96: return read_template_characters(true);\\n              case 123:\\n                S.brace_counter++;\\n                break;\\n              case 125:\\n                S.brace_counter--;\\n                if (S.template_braces.length > 0\\n                    && S.template_braces[S.template_braces.length - 1] === S.brace_counter)\\n                    return read_template_characters(false);\\n                break;\\n            }\\n            if (is_digit(code)) return read_num();\\n            if (PUNC_CHARS(ch)) return token(\\\"punc\\\", next());\\n            if (OPERATOR_CHARS(ch)) return read_operator();\\n            if (code == 92 || is_identifier_start(ch)) return read_word();\\n            break;\\n        }\\n        parse_error(\\\"Unexpected character '\\\" + ch + \\\"'\\\");\\n    };\\n\\n    next_token.next = next;\\n    next_token.peek = peek;\\n\\n    next_token.context = function(nc) {\\n        if (nc) S = nc;\\n        return S;\\n    };\\n\\n    next_token.add_directive = function(directive) {\\n        S.directive_stack[S.directive_stack.length - 1].push(directive);\\n\\n        if (S.directives[directive] === undefined) {\\n            S.directives[directive] = 1;\\n        } else {\\n            S.directives[directive]++;\\n        }\\n    }\\n\\n    next_token.push_directives_stack = function() {\\n        S.directive_stack.push([]);\\n    }\\n\\n    next_token.pop_directives_stack = function() {\\n        var directives = S.directive_stack[S.directive_stack.length - 1];\\n\\n        for (var i = 0; i < directives.length; i++) {\\n            S.directives[directives[i]]--;\\n        }\\n\\n        S.directive_stack.pop();\\n    }\\n\\n    next_token.has_directive = function(directive) {\\n        return S.directives[directive] > 0;\\n    }\\n\\n    return next_token;\\n\\n};\\n\\n/* -----[ Parser (constants) ]----- */\\n\\nvar UNARY_PREFIX = makePredicate([\\n    \\\"typeof\\\",\\n    \\\"void\\\",\\n    \\\"delete\\\",\\n    \\\"--\\\",\\n    \\\"++\\\",\\n    \\\"!\\\",\\n    \\\"~\\\",\\n    \\\"-\\\",\\n    \\\"+\\\"\\n]);\\n\\nvar UNARY_POSTFIX = makePredicate([ \\\"--\\\", \\\"++\\\" ]);\\n\\nvar ASSIGNMENT = makePredicate([ \\\"=\\\", \\\"+=\\\", \\\"-=\\\", \\\"/=\\\", \\\"*=\\\", \\\"**=\\\", \\\"%=\\\", \\\">>=\\\", \\\"<<=\\\", \\\">>>=\\\", \\\"|=\\\", \\\"^=\\\", \\\"&=\\\" ]);\\n\\nvar PRECEDENCE = (function(a, ret){\\n    for (var i = 0; i < a.length; ++i) {\\n        var b = a[i];\\n        for (var j = 0; j < b.length; ++j) {\\n            ret[b[j]] = i + 1;\\n        }\\n    }\\n    return ret;\\n})(\\n    [\\n        [\\\"||\\\"],\\n        [\\\"&&\\\"],\\n        [\\\"|\\\"],\\n        [\\\"^\\\"],\\n        [\\\"&\\\"],\\n        [\\\"==\\\", \\\"===\\\", \\\"!=\\\", \\\"!==\\\"],\\n        [\\\"<\\\", \\\">\\\", \\\"<=\\\", \\\">=\\\", \\\"in\\\", \\\"instanceof\\\"],\\n        [\\\">>\\\", \\\"<<\\\", \\\">>>\\\"],\\n        [\\\"+\\\", \\\"-\\\"],\\n        [\\\"*\\\", \\\"/\\\", \\\"%\\\"],\\n        [\\\"**\\\"]\\n    ],\\n    {}\\n);\\n\\nvar ATOMIC_START_TOKEN = makePredicate([ \\\"atom\\\", \\\"num\\\", \\\"string\\\", \\\"regexp\\\", \\\"name\\\" ]);\\n\\n/* -----[ Parser ]----- */\\n\\nfunction parse($TEXT, options) {\\n\\n    options = defaults(options, {\\n        bare_returns   : false,\\n        ecma           : 8,\\n        expression     : false,\\n        filename       : null,\\n        html5_comments : true,\\n        shebang        : true,\\n        strict         : false,\\n        toplevel       : null,\\n    }, true);\\n\\n    var S = {\\n        input         : (typeof $TEXT == \\\"string\\\"\\n                         ? tokenizer($TEXT, options.filename,\\n                                     options.html5_comments, options.shebang)\\n                         : $TEXT),\\n        token         : null,\\n        prev          : null,\\n        peeked        : null,\\n        in_function   : 0,\\n        in_async      : -1,\\n        in_generator  : -1,\\n        in_directives : true,\\n        in_loop       : 0,\\n        labels        : []\\n    };\\n\\n    S.token = next();\\n\\n    function is(type, value) {\\n        return is_token(S.token, type, value);\\n    };\\n\\n    function peek() { return S.peeked || (S.peeked = S.input()); };\\n\\n    function next() {\\n        S.prev = S.token;\\n        if (S.peeked) {\\n            S.token = S.peeked;\\n            S.peeked = null;\\n        } else {\\n            S.token = S.input();\\n        }\\n        S.in_directives = S.in_directives && (\\n            S.token.type == \\\"string\\\" || is(\\\"punc\\\", \\\";\\\")\\n        );\\n        return S.token;\\n    };\\n\\n    function prev() {\\n        return S.prev;\\n    };\\n\\n    function croak(msg, line, col, pos) {\\n        var ctx = S.input.context();\\n        js_error(msg,\\n                 ctx.filename,\\n                 line != null ? line : ctx.tokline,\\n                 col != null ? col : ctx.tokcol,\\n                 pos != null ? pos : ctx.tokpos);\\n    };\\n\\n    function token_error(token, msg) {\\n        croak(msg, token.line, token.col);\\n    };\\n\\n    function unexpected(token) {\\n        if (token == null)\\n            token = S.token;\\n        token_error(token, \\\"Unexpected token: \\\" + token.type + \\\" (\\\" + token.value + \\\")\\\");\\n    };\\n\\n    function expect_token(type, val) {\\n        if (is(type, val)) {\\n            return next();\\n        }\\n        token_error(S.token, \\\"Unexpected token \\\" + S.token.type + \\\" «\\\" + S.token.value + \\\"»\\\" + \\\", expected \\\" + type + \\\" «\\\" + val + \\\"»\\\");\\n    };\\n\\n    function expect(punc) { return expect_token(\\\"punc\\\", punc); };\\n\\n    function has_newline_before(token) {\\n        return token.nlb || !all(token.comments_before, function(comment) {\\n            return !comment.nlb;\\n        });\\n    }\\n\\n    function can_insert_semicolon() {\\n        return !options.strict\\n            && (is(\\\"eof\\\") || is(\\\"punc\\\", \\\"}\\\") || has_newline_before(S.token));\\n    };\\n\\n    function is_in_generator() {\\n        return S.in_generator === S.in_function;\\n    }\\n\\n    function is_in_async() {\\n        return S.in_async === S.in_function;\\n    }\\n\\n    function semicolon(optional) {\\n        if (is(\\\"punc\\\", \\\";\\\")) next();\\n        else if (!optional && !can_insert_semicolon()) unexpected();\\n    };\\n\\n    function parenthesised() {\\n        expect(\\\"(\\\");\\n        var exp = expression(true);\\n        expect(\\\")\\\");\\n        return exp;\\n    };\\n\\n    function embed_tokens(parser) {\\n        return function() {\\n            var start = S.token;\\n            var expr = parser.apply(null, arguments);\\n            var end = prev();\\n            expr.start = start;\\n            expr.end = end;\\n            return expr;\\n        };\\n    };\\n\\n    function handle_regexp() {\\n        if (is(\\\"operator\\\", \\\"/\\\") || is(\\\"operator\\\", \\\"/=\\\")) {\\n            S.peeked = null;\\n            S.token = S.input(S.token.value.substr(1)); // force regexp\\n        }\\n    };\\n\\n    var statement = embed_tokens(function(is_export_default) {\\n        handle_regexp();\\n        switch (S.token.type) {\\n          case \\\"string\\\":\\n            if (S.in_directives) {\\n                var token = peek();\\n                if (S.token.raw.indexOf(\\\"\\\\\\\\\\\") == -1\\n                    && (is_token(token, \\\"punc\\\", \\\";\\\")\\n                        || is_token(token, \\\"punc\\\", \\\"}\\\")\\n                        || has_newline_before(token)\\n                        || is_token(token, \\\"eof\\\"))) {\\n                    S.input.add_directive(S.token.value);\\n                } else {\\n                    S.in_directives = false;\\n                }\\n            }\\n            var dir = S.in_directives, stat = simple_statement();\\n            return dir ? new AST_Directive(stat.body) : stat;\\n          case \\\"template_head\\\":\\n          case \\\"num\\\":\\n          case \\\"regexp\\\":\\n          case \\\"operator\\\":\\n          case \\\"atom\\\":\\n            return simple_statement();\\n\\n          case \\\"name\\\":\\n            if (S.token.value == \\\"async\\\" && is_token(peek(), \\\"keyword\\\", \\\"function\\\")) {\\n                next();\\n                next();\\n                return function_(AST_Defun, false, true, is_export_default);\\n            }\\n            if (S.token.value == \\\"import\\\" && !is_token(peek(), \\\"punc\\\", \\\"(\\\")) {\\n                next();\\n                var node = import_();\\n                semicolon();\\n                return node;\\n            }\\n            return is_token(peek(), \\\"punc\\\", \\\":\\\")\\n                ? labeled_statement()\\n                : simple_statement();\\n\\n          case \\\"punc\\\":\\n            switch (S.token.value) {\\n              case \\\"{\\\":\\n                return new AST_BlockStatement({\\n                    start : S.token,\\n                    body  : block_(),\\n                    end   : prev()\\n                });\\n              case \\\"[\\\":\\n              case \\\"(\\\":\\n                return simple_statement();\\n              case \\\";\\\":\\n                S.in_directives = false;\\n                next();\\n                return new AST_EmptyStatement();\\n              default:\\n                unexpected();\\n            }\\n\\n          case \\\"keyword\\\":\\n            switch (S.token.value) {\\n              case \\\"break\\\":\\n                next();\\n                return break_cont(AST_Break);\\n\\n              case \\\"continue\\\":\\n                next();\\n                return break_cont(AST_Continue);\\n\\n              case \\\"debugger\\\":\\n                next();\\n                semicolon();\\n                return new AST_Debugger();\\n\\n              case \\\"do\\\":\\n                next();\\n                var body = in_loop(statement);\\n                expect_token(\\\"keyword\\\", \\\"while\\\");\\n                var condition = parenthesised();\\n                semicolon(true);\\n                return new AST_Do({\\n                    body      : body,\\n                    condition : condition\\n                });\\n\\n              case \\\"while\\\":\\n                next();\\n                return new AST_While({\\n                    condition : parenthesised(),\\n                    body      : in_loop(statement)\\n                });\\n\\n              case \\\"for\\\":\\n                next();\\n                return for_();\\n\\n              case \\\"class\\\":\\n                next();\\n                return class_(AST_DefClass);\\n\\n              case \\\"function\\\":\\n                next();\\n                return function_(AST_Defun, false, false, is_export_default);\\n\\n              case \\\"if\\\":\\n                next();\\n                return if_();\\n\\n              case \\\"return\\\":\\n                if (S.in_function == 0 && !options.bare_returns)\\n                    croak(\\\"'return' outside of function\\\");\\n                next();\\n                var value = null;\\n                if (is(\\\"punc\\\", \\\";\\\")) {\\n                    next();\\n                } else if (!can_insert_semicolon()) {\\n                    value = expression(true);\\n                    semicolon();\\n                }\\n                return new AST_Return({\\n                    value: value\\n                });\\n\\n              case \\\"switch\\\":\\n                next();\\n                return new AST_Switch({\\n                    expression : parenthesised(),\\n                    body       : in_loop(switch_body_)\\n                });\\n\\n              case \\\"throw\\\":\\n                next();\\n                if (has_newline_before(S.token))\\n                    croak(\\\"Illegal newline after 'throw'\\\");\\n                var value = expression(true);\\n                semicolon();\\n                return new AST_Throw({\\n                    value: value\\n                });\\n\\n              case \\\"try\\\":\\n                next();\\n                return try_();\\n\\n              case \\\"var\\\":\\n                next();\\n                var node = var_();\\n                semicolon();\\n                return node;\\n\\n              case \\\"let\\\":\\n                next();\\n                var node = let_();\\n                semicolon();\\n                return node;\\n\\n              case \\\"const\\\":\\n                next();\\n                var node = const_();\\n                semicolon();\\n                return node;\\n\\n              case \\\"with\\\":\\n                if (S.input.has_directive(\\\"use strict\\\")) {\\n                    croak(\\\"Strict mode may not include a with statement\\\");\\n                }\\n                next();\\n                return new AST_With({\\n                    expression : parenthesised(),\\n                    body       : statement()\\n                });\\n\\n              case \\\"export\\\":\\n                if (!is_token(peek(), \\\"punc\\\", \\\"(\\\")) {\\n                    next();\\n                    return export_();\\n                }\\n            }\\n        }\\n        unexpected();\\n    });\\n\\n    function labeled_statement() {\\n        var label = as_symbol(AST_Label);\\n        if (label.name === \\\"await\\\" && is_in_async()) {\\n            token_error(S.prev, \\\"await cannot be used as label inside async function\\\");\\n        }\\n        if (find_if(function(l){ return l.name == label.name }, S.labels)) {\\n            // ECMA-262, 12.12: An ECMAScript program is considered\\n            // syntactically incorrect if it contains a\\n            // LabelledStatement that is enclosed by a\\n            // LabelledStatement with the same Identifier as label.\\n            croak(\\\"Label \\\" + label.name + \\\" defined twice\\\");\\n        }\\n        expect(\\\":\\\");\\n        S.labels.push(label);\\n        var stat = statement();\\n        S.labels.pop();\\n        if (!(stat instanceof AST_IterationStatement)) {\\n            // check for `continue` that refers to this label.\\n            // those should be reported as syntax errors.\\n            // https://github.com/mishoo/UglifyJS2/issues/287\\n            label.references.forEach(function(ref){\\n                if (ref instanceof AST_Continue) {\\n                    ref = ref.label.start;\\n                    croak(\\\"Continue label `\\\" + label.name + \\\"` refers to non-IterationStatement.\\\",\\n                          ref.line, ref.col, ref.pos);\\n                }\\n            });\\n        }\\n        return new AST_LabeledStatement({ body: stat, label: label });\\n    };\\n\\n    function simple_statement(tmp) {\\n        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });\\n    };\\n\\n    function break_cont(type) {\\n        var label = null, ldef;\\n        if (!can_insert_semicolon()) {\\n            label = as_symbol(AST_LabelRef, true);\\n        }\\n        if (label != null) {\\n            ldef = find_if(function(l){ return l.name == label.name }, S.labels);\\n            if (!ldef)\\n                croak(\\\"Undefined label \\\" + label.name);\\n            label.thedef = ldef;\\n        }\\n        else if (S.in_loop == 0)\\n            croak(type.TYPE + \\\" not inside a loop or switch\\\");\\n        semicolon();\\n        var stat = new type({ label: label });\\n        if (ldef) ldef.references.push(stat);\\n        return stat;\\n    };\\n\\n    function for_() {\\n        expect(\\\"(\\\");\\n        var init = null;\\n        if (!is(\\\"punc\\\", \\\";\\\")) {\\n            init =\\n                is(\\\"keyword\\\", \\\"var\\\") ? (next(), var_(true)) :\\n                is(\\\"keyword\\\", \\\"let\\\") ? (next(), let_(true)) :\\n                is(\\\"keyword\\\", \\\"const\\\") ? (next(), const_(true)) :\\n                                       expression(true, true);\\n            var is_in = is(\\\"operator\\\", \\\"in\\\");\\n            var is_of = is(\\\"name\\\", \\\"of\\\");\\n            if (is_in || is_of) {\\n                if (init instanceof AST_Definitions) {\\n                    if (init.definitions.length > 1)\\n                        croak(\\\"Only one variable declaration allowed in for..in loop\\\", init.start.line, init.start.col, init.start.pos);\\n                } else if (!(is_assignable(init) || (init = to_destructuring(init)) instanceof AST_Destructuring)) {\\n                    croak(\\\"Invalid left-hand side in for..in loop\\\", init.start.line, init.start.col, init.start.pos);\\n                }\\n                next();\\n                if (is_in) {\\n                    return for_in(init);\\n                } else {\\n                    return for_of(init);\\n                }\\n            }\\n        }\\n        return regular_for(init);\\n    };\\n\\n    function regular_for(init) {\\n        expect(\\\";\\\");\\n        var test = is(\\\"punc\\\", \\\";\\\") ? null : expression(true);\\n        expect(\\\";\\\");\\n        var step = is(\\\"punc\\\", \\\")\\\") ? null : expression(true);\\n        expect(\\\")\\\");\\n        return new AST_For({\\n            init      : init,\\n            condition : test,\\n            step      : step,\\n            body      : in_loop(statement)\\n        });\\n    };\\n\\n    function for_of(init) {\\n        var lhs = init instanceof AST_Definitions ? init.definitions[0].name : null;\\n        var obj = expression(true);\\n        expect(\\\")\\\");\\n        return new AST_ForOf({\\n            init   : init,\\n            name   : lhs,\\n            object : obj,\\n            body   : in_loop(statement)\\n        });\\n    };\\n\\n    function for_in(init) {\\n        var obj = expression(true);\\n        expect(\\\")\\\");\\n        return new AST_ForIn({\\n            init   : init,\\n            object : obj,\\n            body   : in_loop(statement)\\n        });\\n    };\\n\\n    var arrow_function = function(start, argnames, is_async) {\\n        if (has_newline_before(S.token)) {\\n            croak(\\\"Unexpected newline before arrow (=>)\\\");\\n        }\\n\\n        expect_token(\\\"arrow\\\", \\\"=>\\\");\\n\\n        var body = _function_body(is(\\\"punc\\\", \\\"{\\\"), false, is_async);\\n\\n        return new AST_Arrow({\\n            start    : start,\\n            end      : body.end,\\n            async    : is_async,\\n            argnames : argnames,\\n            body     : body\\n        });\\n    };\\n\\n    var function_ = function(ctor, is_generator_property, is_async, is_export_default) {\\n        if (is_generator_property && is_async) croak(\\\"generators cannot be async\\\");\\n        var start = S.token;\\n\\n        var in_statement = ctor === AST_Defun;\\n        var is_generator = is(\\\"operator\\\", \\\"*\\\");\\n        if (is_generator) {\\n            next();\\n        }\\n\\n        var name = is(\\\"name\\\") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;\\n        if (in_statement && !name) {\\n            if (is_export_default) {\\n                ctor = AST_Function;\\n            } else {\\n                unexpected();\\n            }\\n        }\\n\\n        if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\\n            unexpected(prev());\\n\\n        var args = [];\\n        var body = _function_body(true, is_generator || is_generator_property, is_async, name, args);\\n        return new ctor({\\n            start : args.start,\\n            end   : body.end,\\n            is_generator: is_generator,\\n            async : is_async,\\n            name  : name,\\n            argnames: args,\\n            body  : body\\n        });\\n    };\\n\\n    function track_used_binding_identifiers(is_parameter, strict) {\\n        var parameters = {};\\n        var duplicate = false;\\n        var default_assignment = false;\\n        var spread = false;\\n        var strict_mode = !!strict;\\n        var tracker = {\\n            add_parameter: function(token) {\\n                if (parameters[\\\"$\\\" + token.value] !== undefined) {\\n                    if (duplicate === false) {\\n                        duplicate = token;\\n                    }\\n                    tracker.check_strict();\\n                } else {\\n                    parameters[\\\"$\\\" + token.value] = true;\\n                    if (is_parameter) {\\n                        switch (token.value) {\\n                          case \\\"arguments\\\":\\n                          case \\\"eval\\\":\\n                          case \\\"yield\\\":\\n                            if (strict_mode) {\\n                                token_error(token, \\\"Unexpected \\\" + token.value + \\\" identifier as parameter inside strict mode\\\");\\n                            }\\n                            break;\\n                          default:\\n                            if (RESERVED_WORDS(token.value)) {\\n                                unexpected();\\n                            }\\n                        }\\n                    }\\n                }\\n            },\\n            mark_default_assignment: function(token) {\\n                if (default_assignment === false) {\\n                    default_assignment = token;\\n                }\\n            },\\n            mark_spread: function(token) {\\n                if (spread === false) {\\n                    spread = token;\\n                }\\n            },\\n            mark_strict_mode: function() {\\n                strict_mode = true;\\n            },\\n            is_strict: function() {\\n                return default_assignment !== false || spread !== false || strict_mode\\n            },\\n            check_strict: function() {\\n                if (tracker.is_strict() && duplicate !== false) {\\n                    token_error(duplicate, \\\"Parameter \\\" + duplicate.value + \\\" was used already\\\");\\n                }\\n            }\\n        };\\n\\n        return tracker;\\n    }\\n\\n    function parameters(params) {\\n        var start = S.token;\\n        var used_parameters = track_used_binding_identifiers(true, S.input.has_directive(\\\"use strict\\\"));\\n\\n        expect(\\\"(\\\");\\n\\n        while (!is(\\\"punc\\\", \\\")\\\")) {\\n            var param = parameter(used_parameters);\\n            params.push(param);\\n\\n            if (!is(\\\"punc\\\", \\\")\\\")) {\\n                expect(\\\",\\\");\\n                if (is(\\\"punc\\\", \\\")\\\") && options.ecma < 8) unexpected();\\n            }\\n\\n            if (param instanceof AST_Expansion) {\\n                break;\\n            }\\n        }\\n\\n        next();\\n    }\\n\\n    function parameter(used_parameters, symbol_type) {\\n        var param;\\n        var expand = false;\\n        if (used_parameters === undefined) {\\n            used_parameters = track_used_binding_identifiers(true, S.input.has_directive(\\\"use strict\\\"));\\n        }\\n        if (is(\\\"expand\\\", \\\"...\\\")) {\\n            expand = S.token;\\n            used_parameters.mark_spread(S.token);\\n            next();\\n        }\\n        param = binding_element(used_parameters, symbol_type);\\n\\n        if (is(\\\"operator\\\", \\\"=\\\") && expand === false) {\\n            used_parameters.mark_default_assignment(S.token);\\n            next();\\n            param = new AST_DefaultAssign({\\n                start: param.start,\\n                left: param,\\n                operator: \\\"=\\\",\\n                right: expression(false),\\n                end: S.token\\n            });\\n        }\\n\\n        if (expand !== false) {\\n            if (!is(\\\"punc\\\", \\\")\\\")) {\\n                unexpected();\\n            }\\n            param = new AST_Expansion({\\n                start: expand,\\n                expression: param,\\n                end: expand\\n            });\\n        }\\n        used_parameters.check_strict();\\n\\n        return param;\\n    }\\n\\n    function binding_element(used_parameters, symbol_type) {\\n        var elements = [];\\n        var first = true;\\n        var is_expand = false;\\n        var expand_token;\\n        var first_token = S.token;\\n        if (used_parameters === undefined) {\\n            used_parameters = track_used_binding_identifiers(false, S.input.has_directive(\\\"use strict\\\"));\\n        }\\n        symbol_type = symbol_type === undefined ? AST_SymbolFunarg : symbol_type;\\n        if (is(\\\"punc\\\", \\\"[\\\")) {\\n            next();\\n            while (!is(\\\"punc\\\", \\\"]\\\")) {\\n                if (first) {\\n                    first = false;\\n                } else {\\n                    expect(\\\",\\\");\\n                }\\n\\n                if (is(\\\"expand\\\", \\\"...\\\")) {\\n                    is_expand = true;\\n                    expand_token = S.token;\\n                    used_parameters.mark_spread(S.token);\\n                    next();\\n                }\\n                if (is(\\\"punc\\\")) {\\n                    switch (S.token.value) {\\n                      case \\\",\\\":\\n                        elements.push(new AST_Hole({\\n                            start: S.token,\\n                            end: S.token\\n                        }));\\n                        continue;\\n                      case \\\"]\\\": // Trailing comma after last element\\n                        break;\\n                      case \\\"[\\\":\\n                      case \\\"{\\\":\\n                        elements.push(binding_element(used_parameters, symbol_type));\\n                        break;\\n                      default:\\n                        unexpected();\\n                    }\\n                } else if (is(\\\"name\\\")) {\\n                    used_parameters.add_parameter(S.token);\\n                    elements.push(as_symbol(symbol_type));\\n                } else {\\n                    croak(\\\"Invalid function parameter\\\");\\n                }\\n                if (is(\\\"operator\\\", \\\"=\\\") && is_expand === false) {\\n                    used_parameters.mark_default_assignment(S.token);\\n                    next();\\n                    elements[elements.length - 1] = new AST_DefaultAssign({\\n                        start: elements[elements.length - 1].start,\\n                        left: elements[elements.length - 1],\\n                        operator: \\\"=\\\",\\n                        right: expression(false),\\n                        end: S.token\\n                    });\\n                }\\n                if (is_expand) {\\n                    if (!is(\\\"punc\\\", \\\"]\\\")) {\\n                        croak(\\\"Rest element must be last element\\\");\\n                    }\\n                    elements[elements.length - 1] = new AST_Expansion({\\n                        start: expand_token,\\n                        expression: elements[elements.length - 1],\\n                        end: expand_token\\n                    });\\n                }\\n            }\\n            expect(\\\"]\\\");\\n            used_parameters.check_strict();\\n            return new AST_Destructuring({\\n                start: first_token,\\n                names: elements,\\n                is_array: true,\\n                end: prev()\\n            });\\n        } else if (is(\\\"punc\\\", \\\"{\\\")) {\\n            next();\\n            while (!is(\\\"punc\\\", \\\"}\\\")) {\\n                if (first) {\\n                    first = false;\\n                } else {\\n                    expect(\\\",\\\");\\n                }\\n                if (is(\\\"expand\\\", \\\"...\\\")) {\\n                    is_expand = true;\\n                    expand_token = S.token;\\n                    used_parameters.mark_spread(S.token);\\n                    next();\\n                }\\n                if (is(\\\"name\\\") && (is_token(peek(), \\\"punc\\\") || is_token(peek(), \\\"operator\\\")) && [\\\",\\\", \\\"}\\\", \\\"=\\\"].indexOf(peek().value) !== -1) {\\n                    used_parameters.add_parameter(S.token);\\n                    var start = prev();\\n                    var value = as_symbol(symbol_type);\\n                    if (is_expand) {\\n                        elements.push(new AST_Expansion({\\n                            start: expand_token,\\n                            expression: value,\\n                            end: value.end,\\n                        }));\\n                    } else {\\n                        elements.push(new AST_ObjectKeyVal({\\n                            start: start,\\n                            key: value.name,\\n                            value: value,\\n                            end: value.end,\\n                        }));\\n                    }\\n                } else if (is(\\\"punc\\\", \\\"}\\\")) {\\n                    continue; // Allow trailing hole\\n                } else {\\n                    var property_token = S.token;\\n                    var property = as_property_name();\\n                    if (property === null) {\\n                        unexpected(prev());\\n                    } else if (prev().type === \\\"name\\\" && !is(\\\"punc\\\", \\\":\\\")) {\\n                        elements.push(new AST_ObjectKeyVal({\\n                            start: prev(),\\n                            key: property,\\n                            value: new symbol_type({\\n                                start: prev(),\\n                                name: property,\\n                                end: prev()\\n                            }),\\n                            end: prev()\\n                        }));\\n                    } else {\\n                        expect(\\\":\\\");\\n                        elements.push(new AST_ObjectKeyVal({\\n                            start: property_token,\\n                            quote: property_token.quote,\\n                            key: property,\\n                            value: binding_element(used_parameters, symbol_type),\\n                            end: prev()\\n                        }));\\n                    }\\n                }\\n                if (is_expand) {\\n                    if (!is(\\\"punc\\\", \\\"}\\\")) {\\n                        croak(\\\"Rest element must be last element\\\");\\n                    }\\n                }\\n                else if (is(\\\"operator\\\", \\\"=\\\")) {\\n                    used_parameters.mark_default_assignment(S.token);\\n                    next();\\n                    elements[elements.length - 1].value = new AST_DefaultAssign({\\n                        start: elements[elements.length - 1].value.start,\\n                        left: elements[elements.length - 1].value,\\n                        operator: \\\"=\\\",\\n                        right: expression(false),\\n                        end: S.token\\n                    });\\n                }\\n            }\\n            expect(\\\"}\\\");\\n            used_parameters.check_strict();\\n            return new AST_Destructuring({\\n                start: first_token,\\n                names: elements,\\n                is_array: false,\\n                end: prev()\\n            });\\n        } else if (is(\\\"name\\\")) {\\n            used_parameters.add_parameter(S.token);\\n            return as_symbol(symbol_type);\\n        } else {\\n            croak(\\\"Invalid function parameter\\\");\\n        }\\n    }\\n\\n    function params_or_seq_(allow_arrows, maybe_sequence) {\\n        var spread_token;\\n        var invalid_sequence;\\n        var trailing_comma;\\n        var a = [];\\n        expect(\\\"(\\\");\\n        while (!is(\\\"punc\\\", \\\")\\\")) {\\n            if (spread_token) unexpected(spread_token);\\n            if (is(\\\"expand\\\", \\\"...\\\")) {\\n                spread_token = S.token;\\n                if (maybe_sequence) invalid_sequence = S.token;\\n                next();\\n                a.push(new AST_Expansion({\\n                    start: prev(),\\n                    expression: expression(),\\n                    end: S.token,\\n                }));\\n            } else {\\n                a.push(expression());\\n            }\\n            if (!is(\\\"punc\\\", \\\")\\\")) {\\n                expect(\\\",\\\");\\n                if (is(\\\"punc\\\", \\\")\\\")) {\\n                    if (options.ecma < 8) unexpected();\\n                    trailing_comma = prev();\\n                    if (maybe_sequence) invalid_sequence = trailing_comma;\\n                }\\n            }\\n        }\\n        expect(\\\")\\\");\\n        if (allow_arrows && is(\\\"arrow\\\", \\\"=>\\\")) {\\n            if (spread_token && trailing_comma) unexpected(trailing_comma);\\n        } else if (invalid_sequence) {\\n            unexpected(invalid_sequence);\\n        }\\n        return a;\\n    }\\n\\n    function _function_body(block, generator, is_async, name, args) {\\n        var loop = S.in_loop;\\n        var labels = S.labels;\\n        var current_generator = S.in_generator;\\n        var current_async = S.in_async;\\n        ++S.in_function;\\n        if (generator)\\n            S.in_generator = S.in_function;\\n        if (is_async)\\n            S.in_async = S.in_function;\\n        if (args) parameters(args);\\n        if (block)\\n            S.in_directives = true;\\n        S.in_loop = 0;\\n        S.labels = [];\\n        if (block) {\\n            S.input.push_directives_stack();\\n            var a = block_();\\n            if (name) _verify_symbol(name);\\n            if (args) args.forEach(_verify_symbol);\\n            S.input.pop_directives_stack();\\n        } else {\\n            var a = expression(false);\\n        }\\n        --S.in_function;\\n        S.in_loop = loop;\\n        S.labels = labels;\\n        S.in_generator = current_generator;\\n        S.in_async = current_async;\\n        return a;\\n    }\\n\\n    function _await_expression() {\\n        // Previous token must be \\\"await\\\" and not be interpreted as an identifier\\n        if (!is_in_async()) {\\n            croak(\\\"Unexpected await expression outside async function\\\",\\n                S.prev.line, S.prev.col, S.prev.pos);\\n        }\\n        // the await expression is parsed as a unary expression in Babel\\n        return new AST_Await({\\n            expression : maybe_unary(true),\\n        });\\n    }\\n\\n    function _yield_expression() {\\n        // Previous token must be keyword yield and not be interpret as an identifier\\n        if (!is_in_generator()) {\\n            croak(\\\"Unexpected yield expression outside generator function\\\",\\n                S.prev.line, S.prev.col, S.prev.pos);\\n        }\\n        var star = false;\\n        var has_expression = true;\\n\\n        // Attempt to get expression or star (and then the mandatory expression)\\n        // behind yield on the same line.\\n        //\\n        // If nothing follows on the same line of the yieldExpression,\\n        // it should default to the value `undefined` for yield to return.\\n        // In that case, the `undefined` stored as `null` in ast.\\n        //\\n        // Note 1: It isn't allowed for yield* to close without an expression\\n        // Note 2: If there is a nlb between yield and star, it is interpret as\\n        //         yield <explicit undefined> <inserted automatic semicolon> *\\n        if (can_insert_semicolon() ||\\n            (is(\\\"punc\\\") && PUNC_AFTER_EXPRESSION(S.token.value))) {\\n            has_expression = false;\\n\\n        } else if (is(\\\"operator\\\", \\\"*\\\")) {\\n            star = true;\\n            next();\\n        }\\n\\n        return new AST_Yield({\\n            is_star    : star,\\n            expression : has_expression ? expression() : null\\n        });\\n    }\\n\\n    function if_() {\\n        var cond = parenthesised(), body = statement(), belse = null;\\n        if (is(\\\"keyword\\\", \\\"else\\\")) {\\n            next();\\n            belse = statement();\\n        }\\n        return new AST_If({\\n            condition   : cond,\\n            body        : body,\\n            alternative : belse\\n        });\\n    };\\n\\n    function block_() {\\n        expect(\\\"{\\\");\\n        var a = [];\\n        while (!is(\\\"punc\\\", \\\"}\\\")) {\\n            if (is(\\\"eof\\\")) unexpected();\\n            a.push(statement());\\n        }\\n        next();\\n        return a;\\n    };\\n\\n    function switch_body_() {\\n        expect(\\\"{\\\");\\n        var a = [], cur = null, branch = null, tmp;\\n        while (!is(\\\"punc\\\", \\\"}\\\")) {\\n            if (is(\\\"eof\\\")) unexpected();\\n            if (is(\\\"keyword\\\", \\\"case\\\")) {\\n                if (branch) branch.end = prev();\\n                cur = [];\\n                branch = new AST_Case({\\n                    start      : (tmp = S.token, next(), tmp),\\n                    expression : expression(true),\\n                    body       : cur\\n                });\\n                a.push(branch);\\n                expect(\\\":\\\");\\n            }\\n            else if (is(\\\"keyword\\\", \\\"default\\\")) {\\n                if (branch) branch.end = prev();\\n                cur = [];\\n                branch = new AST_Default({\\n                    start : (tmp = S.token, next(), expect(\\\":\\\"), tmp),\\n                    body  : cur\\n                });\\n                a.push(branch);\\n            }\\n            else {\\n                if (!cur) unexpected();\\n                cur.push(statement());\\n            }\\n        }\\n        if (branch) branch.end = prev();\\n        next();\\n        return a;\\n    };\\n\\n    function try_() {\\n        var body = block_(), bcatch = null, bfinally = null;\\n        if (is(\\\"keyword\\\", \\\"catch\\\")) {\\n            var start = S.token;\\n            next();\\n            expect(\\\"(\\\");\\n            var name = parameter(undefined, AST_SymbolCatch);\\n            expect(\\\")\\\");\\n            bcatch = new AST_Catch({\\n                start   : start,\\n                argname : name,\\n                body    : block_(),\\n                end     : prev()\\n            });\\n        }\\n        if (is(\\\"keyword\\\", \\\"finally\\\")) {\\n            var start = S.token;\\n            next();\\n            bfinally = new AST_Finally({\\n                start : start,\\n                body  : block_(),\\n                end   : prev()\\n            });\\n        }\\n        if (!bcatch && !bfinally)\\n            croak(\\\"Missing catch/finally blocks\\\");\\n        return new AST_Try({\\n            body     : body,\\n            bcatch   : bcatch,\\n            bfinally : bfinally\\n        });\\n    };\\n\\n    function vardefs(no_in, kind) {\\n        var a = [];\\n        var def;\\n        for (;;) {\\n            var sym_type =\\n                kind === \\\"var\\\" ? AST_SymbolVar :\\n                kind === \\\"const\\\" ? AST_SymbolConst :\\n                kind === \\\"let\\\" ? AST_SymbolLet : null;\\n            if (is(\\\"punc\\\", \\\"{\\\") || is(\\\"punc\\\", \\\"[\\\")) {\\n                def = new AST_VarDef({\\n                    start: S.token,\\n                    name: binding_element(undefined ,sym_type),\\n                    value: is(\\\"operator\\\", \\\"=\\\") ? (expect_token(\\\"operator\\\", \\\"=\\\"), expression(false, no_in)) : null,\\n                    end: prev()\\n                });\\n            } else {\\n                def = new AST_VarDef({\\n                    start : S.token,\\n                    name  : as_symbol(sym_type),\\n                    value : is(\\\"operator\\\", \\\"=\\\")\\n                        ? (next(), expression(false, no_in))\\n                        : !no_in && kind === \\\"const\\\"\\n                            ? croak(\\\"Missing initializer in const declaration\\\") : null,\\n                    end   : prev()\\n                });\\n                if (def.name.name == \\\"import\\\") croak(\\\"Unexpected token: import\\\");\\n            }\\n            a.push(def);\\n            if (!is(\\\"punc\\\", \\\",\\\"))\\n                break;\\n            next();\\n        }\\n        return a;\\n    };\\n\\n    var var_ = function(no_in) {\\n        return new AST_Var({\\n            start       : prev(),\\n            definitions : vardefs(no_in, \\\"var\\\"),\\n            end         : prev()\\n        });\\n    };\\n\\n    var let_ = function(no_in) {\\n        return new AST_Let({\\n            start       : prev(),\\n            definitions : vardefs(no_in, \\\"let\\\"),\\n            end         : prev()\\n        });\\n    };\\n\\n    var const_ = function(no_in) {\\n        return new AST_Const({\\n            start       : prev(),\\n            definitions : vardefs(no_in, \\\"const\\\"),\\n            end         : prev()\\n        });\\n    };\\n\\n    var new_ = function(allow_calls) {\\n        var start = S.token;\\n        expect_token(\\\"operator\\\", \\\"new\\\");\\n        if (is(\\\"punc\\\", \\\".\\\")) {\\n            next();\\n            expect_token(\\\"name\\\", \\\"target\\\");\\n            return subscripts(new AST_NewTarget({\\n                start : start,\\n                end   : prev()\\n            }), allow_calls);\\n        }\\n        var newexp = expr_atom(false), args;\\n        if (is(\\\"punc\\\", \\\"(\\\")) {\\n            next();\\n            args = expr_list(\\\")\\\", options.ecma >= 8);\\n        } else {\\n            args = [];\\n        }\\n        var call = new AST_New({\\n            start      : start,\\n            expression : newexp,\\n            args       : args,\\n            end        : prev()\\n        });\\n        mark_pure(call);\\n        return subscripts(call, allow_calls);\\n    };\\n\\n    function as_atom_node() {\\n        var tok = S.token, ret;\\n        switch (tok.type) {\\n          case \\\"name\\\":\\n            ret = _make_symbol(AST_SymbolRef);\\n            break;\\n          case \\\"num\\\":\\n            ret = new AST_Number({ start: tok, end: tok, value: tok.value });\\n            break;\\n          case \\\"string\\\":\\n            ret = new AST_String({\\n                start : tok,\\n                end   : tok,\\n                value : tok.value,\\n                quote : tok.quote\\n            });\\n            break;\\n          case \\\"regexp\\\":\\n            ret = new AST_RegExp({ start: tok, end: tok, value: tok.value });\\n            break;\\n          case \\\"atom\\\":\\n            switch (tok.value) {\\n              case \\\"false\\\":\\n                ret = new AST_False({ start: tok, end: tok });\\n                break;\\n              case \\\"true\\\":\\n                ret = new AST_True({ start: tok, end: tok });\\n                break;\\n              case \\\"null\\\":\\n                ret = new AST_Null({ start: tok, end: tok });\\n                break;\\n            }\\n            break;\\n        }\\n        next();\\n        return ret;\\n    };\\n\\n    function to_fun_args(ex, _, __, default_seen_above) {\\n        var insert_default = function(ex, default_value) {\\n            if (default_value) {\\n                return new AST_DefaultAssign({\\n                    start: ex.start,\\n                    left: ex,\\n                    operator: \\\"=\\\",\\n                    right: default_value,\\n                    end: default_value.end\\n                });\\n            }\\n            return ex;\\n        }\\n        if (ex instanceof AST_Object) {\\n            return insert_default(new AST_Destructuring({\\n                start: ex.start,\\n                end: ex.end,\\n                is_array: false,\\n                names: ex.properties.map(to_fun_args)\\n            }), default_seen_above);\\n        } else if (ex instanceof AST_ObjectKeyVal) {\\n            ex.value = to_fun_args(ex.value, 0, [ex.key]);\\n            return insert_default(ex, default_seen_above);\\n        } else if (ex instanceof AST_Hole) {\\n            return ex;\\n        } else if (ex instanceof AST_Destructuring) {\\n            ex.names = ex.names.map(to_fun_args);\\n            return insert_default(ex, default_seen_above);\\n        } else if (ex instanceof AST_SymbolRef) {\\n            return insert_default(new AST_SymbolFunarg({\\n                name: ex.name,\\n                start: ex.start,\\n                end: ex.end\\n            }), default_seen_above);\\n        } else if (ex instanceof AST_Expansion) {\\n            ex.expression = to_fun_args(ex.expression);\\n            return insert_default(ex, default_seen_above);\\n        } else if (ex instanceof AST_Array) {\\n            return insert_default(new AST_Destructuring({\\n                start: ex.start,\\n                end: ex.end,\\n                is_array: true,\\n                names: ex.elements.map(to_fun_args)\\n            }), default_seen_above);\\n        } else if (ex instanceof AST_Assign) {\\n            return insert_default(to_fun_args(ex.left, undefined, undefined, ex.right), default_seen_above);\\n        } else if (ex instanceof AST_DefaultAssign) {\\n            ex.left = to_fun_args(ex.left, 0, [ex.left]);\\n            return ex;\\n        } else {\\n            croak(\\\"Invalid function parameter\\\", ex.start.line, ex.start.col);\\n        }\\n    }\\n\\n    var expr_atom = function(allow_calls, allow_arrows) {\\n        if (is(\\\"operator\\\", \\\"new\\\")) {\\n            return new_(allow_calls);\\n        }\\n        var start = S.token;\\n        var async = is(\\\"name\\\", \\\"async\\\") && as_atom_node();\\n        if (is(\\\"punc\\\")) {\\n            switch (S.token.value) {\\n              case \\\"(\\\":\\n                if (async && !allow_calls) break;\\n                var exprs = params_or_seq_(allow_arrows, !async);\\n                if (allow_arrows && is(\\\"arrow\\\", \\\"=>\\\")) {\\n                    return arrow_function(start, exprs.map(to_fun_args), !!async);\\n                }\\n                var ex = async ? new AST_Call({\\n                    expression: async,\\n                    args: exprs\\n                }) : exprs.length == 1 ? exprs[0] : new AST_Sequence({\\n                    expressions: exprs\\n                });\\n                if (ex.start) {\\n                    var len = start.comments_before.length;\\n                    [].unshift.apply(ex.start.comments_before, start.comments_before);\\n                    start.comments_before = ex.start.comments_before;\\n                    start.comments_before_length = len;\\n                    if (len == 0 && start.comments_before.length > 0) {\\n                        var comment = start.comments_before[0];\\n                        if (!comment.nlb) {\\n                            comment.nlb = start.nlb;\\n                            start.nlb = false;\\n                        }\\n                    }\\n                    start.comments_after = ex.start.comments_after;\\n                }\\n                ex.start = start;\\n                var end = prev();\\n                if (ex.end) {\\n                    end.comments_before = ex.end.comments_before;\\n                    [].push.apply(ex.end.comments_after, end.comments_after);\\n                    end.comments_after = ex.end.comments_after;\\n                }\\n                ex.end = end;\\n                if (ex instanceof AST_Call) mark_pure(ex);\\n                return subscripts(ex, allow_calls);\\n              case \\\"[\\\":\\n                return subscripts(array_(), allow_calls);\\n              case \\\"{\\\":\\n                return subscripts(object_or_destructuring_(), allow_calls);\\n            }\\n            if (!async) unexpected();\\n        }\\n        if (allow_arrows && is(\\\"name\\\") && is_token(peek(), \\\"arrow\\\")) {\\n            var param = new AST_SymbolFunarg({\\n                name: S.token.value,\\n                start: start,\\n                end: start,\\n            });\\n            next();\\n            return arrow_function(start, [param], !!async);\\n        }\\n        if (is(\\\"keyword\\\", \\\"function\\\")) {\\n            next();\\n            var func = function_(AST_Function, false, !!async);\\n            func.start = start;\\n            func.end = prev();\\n            return subscripts(func, allow_calls);\\n        }\\n        if (async) return subscripts(async, allow_calls);\\n        if (is(\\\"keyword\\\", \\\"class\\\")) {\\n            next();\\n            var cls = class_(AST_ClassExpression);\\n            cls.start = start;\\n            cls.end = prev();\\n            return subscripts(cls, allow_calls);\\n        }\\n        if (is(\\\"template_head\\\")) {\\n            return subscripts(template_string(), allow_calls);\\n        }\\n        if (ATOMIC_START_TOKEN(S.token.type)) {\\n            return subscripts(as_atom_node(), allow_calls);\\n        }\\n        unexpected();\\n    };\\n\\n    function template_string() {\\n        var segments = [], start = S.token;\\n\\n        segments.push(new AST_TemplateSegment({\\n            start: S.token,\\n            raw: S.token.raw,\\n            value: S.token.value,\\n            end: S.token\\n        }));\\n        while (S.token.end === false) {\\n            next();\\n            handle_regexp();\\n            segments.push(expression(true));\\n\\n            if (!is_token(\\\"template_substitution\\\")) {\\n                unexpected();\\n            }\\n\\n            segments.push(new AST_TemplateSegment({\\n                start: S.token,\\n                raw: S.token.raw,\\n                value: S.token.value,\\n                end: S.token\\n            }));\\n        }\\n        next();\\n\\n        return new AST_TemplateString({\\n            start: start,\\n            segments: segments,\\n            end: S.token\\n        });\\n    }\\n\\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\\n        var first = true, a = [];\\n        while (!is(\\\"punc\\\", closing)) {\\n            if (first) first = false; else expect(\\\",\\\");\\n            if (allow_trailing_comma && is(\\\"punc\\\", closing)) break;\\n            if (is(\\\"punc\\\", \\\",\\\") && allow_empty) {\\n                a.push(new AST_Hole({ start: S.token, end: S.token }));\\n            } else if (is(\\\"expand\\\", \\\"...\\\")) {\\n                next();\\n                a.push(new AST_Expansion({start: prev(), expression: expression(),end: S.token}));\\n            } else {\\n                a.push(expression(false));\\n            }\\n        }\\n        next();\\n        return a;\\n    };\\n\\n    var array_ = embed_tokens(function() {\\n        expect(\\\"[\\\");\\n        return new AST_Array({\\n            elements: expr_list(\\\"]\\\", !options.strict, true)\\n        });\\n    });\\n\\n    var create_accessor = embed_tokens(function(is_generator, is_async) {\\n        return function_(AST_Accessor, is_generator, is_async);\\n    });\\n\\n    var object_or_destructuring_ = embed_tokens(function object_or_destructuring_() {\\n        var start = S.token, first = true, a = [];\\n        expect(\\\"{\\\");\\n        while (!is(\\\"punc\\\", \\\"}\\\")) {\\n            if (first) first = false; else expect(\\\",\\\");\\n            if (!options.strict && is(\\\"punc\\\", \\\"}\\\"))\\n                // allow trailing comma\\n                break;\\n\\n            start = S.token;\\n            if (start.type == \\\"expand\\\") {\\n                next();\\n                a.push(new AST_Expansion({\\n                    start: start,\\n                    expression: expression(false),\\n                    end: prev(),\\n                }));\\n                continue;\\n            }\\n\\n            var name = as_property_name();\\n            var value;\\n\\n            // Check property and fetch value\\n            if (!is(\\\"punc\\\", \\\":\\\")) {\\n                var concise = concise_method_or_getset(name, start);\\n                if (concise) {\\n                    a.push(concise);\\n                    continue;\\n                }\\n\\n                value = new AST_SymbolRef({\\n                    start: prev(),\\n                    name: name,\\n                    end: prev()\\n                });\\n            } else if (name === null) {\\n                unexpected(prev());\\n            } else {\\n                next(); // `:` - see first condition\\n                value = expression(false);\\n            }\\n\\n            // Check for default value and alter value accordingly if necessary\\n            if (is(\\\"operator\\\", \\\"=\\\")) {\\n                next();\\n                value = new AST_Assign({\\n                    start: start,\\n                    left: value,\\n                    operator: \\\"=\\\",\\n                    right: expression(false),\\n                    end: prev()\\n                });\\n            }\\n\\n            // Create property\\n            a.push(new AST_ObjectKeyVal({\\n                start: start,\\n                quote: start.quote,\\n                key: name instanceof AST_Node ? name : \\\"\\\" + name,\\n                value: value,\\n                end: prev()\\n            }));\\n        }\\n        next();\\n        return new AST_Object({ properties: a })\\n    });\\n\\n    function class_(KindOfClass) {\\n        var start, method, class_name, extends_, a = [];\\n\\n        S.input.push_directives_stack(); // Push directive stack, but not scope stack\\n        S.input.add_directive(\\\"use strict\\\");\\n\\n        if (S.token.type == \\\"name\\\" && S.token.value != \\\"extends\\\") {\\n            class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);\\n        }\\n\\n        if (KindOfClass === AST_DefClass && !class_name) {\\n            unexpected();\\n        }\\n\\n        if (S.token.value == \\\"extends\\\") {\\n            next();\\n            extends_ = expression(true);\\n        }\\n\\n        expect(\\\"{\\\");\\n\\n        if (is(\\\"punc\\\", \\\";\\\")) { next(); }  // Leading semicolons are okay in class bodies.\\n        while (!is(\\\"punc\\\", \\\"}\\\")) {\\n            start = S.token;\\n            method = concise_method_or_getset(as_property_name(), start, true);\\n            if (!method) { unexpected(); }\\n            a.push(method);\\n            if (is(\\\"punc\\\", \\\";\\\")) { next(); }\\n        }\\n\\n        S.input.pop_directives_stack();\\n\\n        next();\\n\\n        return new KindOfClass({\\n            start: start,\\n            name: class_name,\\n            extends: extends_,\\n            properties: a,\\n            end: prev(),\\n        });\\n    }\\n\\n    function concise_method_or_getset(name, start, is_class) {\\n        var get_ast = function(name, token) {\\n            if (typeof name === \\\"string\\\" || typeof name === \\\"number\\\") {\\n                return new AST_SymbolMethod({\\n                    start: token,\\n                    name: \\\"\\\" + name,\\n                    end: prev()\\n                });\\n            } else if (name === null) {\\n                unexpected();\\n            }\\n            return name;\\n        }\\n        var is_async = false;\\n        var is_static = false;\\n        var is_generator = false;\\n        var property_token = start;\\n        if (is_class && name === \\\"static\\\" && !is(\\\"punc\\\", \\\"(\\\")) {\\n            is_static = true;\\n            property_token = S.token;\\n            name = as_property_name();\\n        }\\n        if (name === \\\"async\\\" && !is(\\\"punc\\\", \\\"(\\\") && !is(\\\"punc\\\", \\\",\\\") && !is(\\\"punc\\\", \\\"}\\\")) {\\n            is_async = true;\\n            property_token = S.token;\\n            name = as_property_name();\\n        }\\n        if (name === null) {\\n            is_generator = true;\\n            property_token = S.token;\\n            name = as_property_name();\\n            if (name === null) {\\n                unexpected();\\n            }\\n        }\\n        if (is(\\\"punc\\\", \\\"(\\\")) {\\n            name = get_ast(name, start);\\n            var node = new AST_ConciseMethod({\\n                start       : start,\\n                static      : is_static,\\n                is_generator: is_generator,\\n                async       : is_async,\\n                key         : name,\\n                quote       : name instanceof AST_SymbolMethod ?\\n                              property_token.quote : undefined,\\n                value       : create_accessor(is_generator, is_async),\\n                end         : prev()\\n            });\\n            return node;\\n        }\\n        property_token = S.token;\\n        if (name == \\\"get\\\") {\\n            if (!is(\\\"punc\\\") || is(\\\"punc\\\", \\\"[\\\")) {\\n                name = get_ast(as_property_name(), start);\\n                return new AST_ObjectGetter({\\n                    start : start,\\n                    static: is_static,\\n                    key   : name,\\n                    quote : name instanceof AST_SymbolMethod ?\\n                            property_token.quote : undefined,\\n                    value : create_accessor(),\\n                    end   : prev()\\n                });\\n            }\\n        }\\n        else if (name == \\\"set\\\") {\\n            if (!is(\\\"punc\\\") || is(\\\"punc\\\", \\\"[\\\")) {\\n                name = get_ast(as_property_name(), start);\\n                return new AST_ObjectSetter({\\n                    start : start,\\n                    static: is_static,\\n                    key   : name,\\n                    quote : name instanceof AST_SymbolMethod ?\\n                            property_token.quote : undefined,\\n                    value : create_accessor(),\\n                    end   : prev()\\n                });\\n            }\\n        }\\n    }\\n\\n    function import_() {\\n        var start = prev();\\n        var imported_name;\\n        var imported_names;\\n        if (is(\\\"name\\\")) {\\n            imported_name = as_symbol(AST_SymbolImport);\\n        }\\n\\n        if (is(\\\"punc\\\", \\\",\\\")) {\\n            next();\\n        }\\n\\n        imported_names = map_names(true);\\n\\n        if (imported_names || imported_name) {\\n            expect_token(\\\"name\\\", \\\"from\\\");\\n        }\\n        var mod_str = S.token;\\n        if (mod_str.type !== 'string') {\\n            unexpected();\\n        }\\n        next();\\n        return new AST_Import({\\n            start: start,\\n            imported_name: imported_name,\\n            imported_names: imported_names,\\n            module_name: new AST_String({\\n                start: mod_str,\\n                value: mod_str.value,\\n                quote: mod_str.quote,\\n                end: mod_str,\\n            }),\\n            end: S.token,\\n        });\\n    }\\n\\n    function map_name(is_import) {\\n        function make_symbol(type) {\\n            return new type({\\n                name: as_property_name(),\\n                start: prev(),\\n                end: prev()\\n            });\\n        }\\n\\n        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;\\n        var type = is_import ? AST_SymbolImport : AST_SymbolExport;\\n        var start = S.token;\\n        var foreign_name;\\n        var name;\\n\\n        if (is_import) {\\n            foreign_name = make_symbol(foreign_type);\\n        } else {\\n            name = make_symbol(type);\\n        }\\n        if (is(\\\"name\\\", \\\"as\\\")) {\\n            next();  // The \\\"as\\\" word\\n            if (is_import) {\\n                name = make_symbol(type);\\n            } else {\\n                foreign_name = make_symbol(foreign_type);\\n            }\\n        } else if (is_import) {\\n            name = new type(foreign_name);\\n        } else {\\n            foreign_name = new foreign_type(name);\\n        }\\n\\n        return new AST_NameMapping({\\n            start: start,\\n            foreign_name: foreign_name,\\n            name: name,\\n            end: prev(),\\n        })\\n    }\\n\\n    function map_nameAsterisk(is_import, name) {\\n        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;\\n        var type = is_import ? AST_SymbolImport : AST_SymbolExport;\\n        var start = S.token;\\n        var foreign_name;\\n        var end = prev();\\n\\n        name = name || new type({\\n            name: '*',\\n            start: start,\\n            end: end,\\n        });\\n\\n        foreign_name = new foreign_type({\\n            name: '*',\\n            start: start,\\n            end: end,\\n        });\\n\\n        return new AST_NameMapping({\\n            start: start,\\n            foreign_name: foreign_name,\\n            name: name,\\n            end: end,\\n        })\\n    }\\n\\n    function map_names(is_import) {\\n        var names;\\n        if (is(\\\"punc\\\", \\\"{\\\")) {\\n            next();\\n            names = [];\\n            while (!is(\\\"punc\\\", \\\"}\\\")) {\\n                names.push(map_name(is_import));\\n                if (is(\\\"punc\\\", \\\",\\\")) {\\n                    next();\\n                }\\n            }\\n            next();\\n        } else if (is(\\\"operator\\\", \\\"*\\\")) {\\n            var name;\\n            next();\\n            if (is_import && is(\\\"name\\\", \\\"as\\\")) {\\n                next();  // The \\\"as\\\" word\\n                name = as_symbol(AST_SymbolImportForeign);\\n            }\\n            names = [map_nameAsterisk(is_import, name)];\\n        }\\n        return names;\\n    }\\n\\n    function export_() {\\n        var start = S.token;\\n        var is_default;\\n        var exported_names;\\n\\n        if (is(\\\"keyword\\\", \\\"default\\\")) {\\n            is_default = true;\\n            next();\\n        } else if (exported_names = map_names(false)) {\\n            if (is(\\\"name\\\", \\\"from\\\")) {\\n                next();\\n\\n                var mod_str = S.token;\\n                if (mod_str.type !== 'string') {\\n                    unexpected();\\n                }\\n                next();\\n\\n                return new AST_Export({\\n                    start: start,\\n                    is_default: is_default,\\n                    exported_names: exported_names,\\n                    module_name: new AST_String({\\n                        start: mod_str,\\n                        value: mod_str.value,\\n                        quote: mod_str.quote,\\n                        end: mod_str,\\n                    }),\\n                    end: prev(),\\n                });\\n            } else {\\n                return new AST_Export({\\n                    start: start,\\n                    is_default: is_default,\\n                    exported_names: exported_names,\\n                    end: prev(),\\n                });\\n            }\\n        }\\n\\n        var node;\\n        var exported_value;\\n        var exported_definition;\\n        if (is(\\\"punc\\\", \\\"{\\\")\\n            || is_default\\n                && (is(\\\"keyword\\\", \\\"class\\\") || is(\\\"keyword\\\", \\\"function\\\"))\\n                && is_token(peek(), \\\"punc\\\")) {\\n            exported_value = expression(false);\\n            semicolon();\\n        } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {\\n            unexpected(node.start);\\n        } else if (node instanceof AST_Definitions || node instanceof AST_Lambda || node instanceof AST_DefClass) {\\n            exported_definition = node;\\n        } else if (node instanceof AST_SimpleStatement) {\\n            exported_value = node.body;\\n        } else {\\n            unexpected(node.start);\\n        }\\n\\n        return new AST_Export({\\n            start: start,\\n            is_default: is_default,\\n            exported_value: exported_value,\\n            exported_definition: exported_definition,\\n            end: prev(),\\n        });\\n    }\\n\\n    function as_property_name() {\\n        var tmp = S.token;\\n        switch (tmp.type) {\\n          case \\\"punc\\\":\\n            if (tmp.value === \\\"[\\\") {\\n                next();\\n                var ex = expression(false);\\n                expect(\\\"]\\\");\\n                return ex;\\n            } else unexpected(tmp);\\n          case \\\"operator\\\":\\n            if (tmp.value === \\\"*\\\") {\\n                next();\\n                return null;\\n            }\\n            if ([\\\"delete\\\", \\\"in\\\", \\\"instanceof\\\", \\\"new\\\", \\\"typeof\\\", \\\"void\\\"].indexOf(tmp.value) === -1) {\\n                unexpected(tmp);\\n            }\\n          case \\\"name\\\":\\n            if (tmp.value == \\\"yield\\\") {\\n                if (is_in_generator()) {\\n                    token_error(tmp, \\\"Yield cannot be used as identifier inside generators\\\");\\n                } else if (!is_token(peek(), \\\"punc\\\", \\\":\\\")\\n                    && !is_token(peek(), \\\"punc\\\", \\\"(\\\")\\n                    && S.input.has_directive(\\\"use strict\\\")) {\\n                    token_error(tmp, \\\"Unexpected yield identifier inside strict mode\\\");\\n                }\\n            }\\n          case \\\"string\\\":\\n          case \\\"num\\\":\\n          case \\\"keyword\\\":\\n          case \\\"atom\\\":\\n            next();\\n            return tmp.value;\\n          default:\\n            unexpected(tmp);\\n        }\\n    };\\n\\n    function as_name() {\\n        var tmp = S.token;\\n        if (tmp.type != \\\"name\\\") unexpected();\\n        next();\\n        return tmp.value;\\n    };\\n\\n    function _make_symbol(type) {\\n        var name = S.token.value;\\n        return new (name == \\\"this\\\" ? AST_This :\\n                    name == \\\"super\\\" ? AST_Super :\\n                    type)({\\n            name  : String(name),\\n            start : S.token,\\n            end   : S.token\\n        });\\n    };\\n\\n    function _verify_symbol(sym) {\\n        var name = sym.name;\\n        if (is_in_generator() && name == \\\"yield\\\") {\\n            token_error(sym.start, \\\"Yield cannot be used as identifier inside generators\\\");\\n        }\\n        if (S.input.has_directive(\\\"use strict\\\")) {\\n            if (name == \\\"yield\\\") {\\n                token_error(sym.start, \\\"Unexpected yield identifier inside strict mode\\\");\\n            }\\n            if (sym instanceof AST_SymbolDeclaration && (name == \\\"arguments\\\" || name == \\\"eval\\\")) {\\n                token_error(sym.start, \\\"Unexpected \\\" + name + \\\" in strict mode\\\");\\n            }\\n        }\\n    }\\n\\n    function as_symbol(type, noerror) {\\n        if (!is(\\\"name\\\")) {\\n            if (!noerror) croak(\\\"Name expected\\\");\\n            return null;\\n        }\\n        var sym = _make_symbol(type);\\n        _verify_symbol(sym);\\n        next();\\n        return sym;\\n    };\\n\\n    function mark_pure(call) {\\n        var start = call.start;\\n        var comments = start.comments_before;\\n        var i = HOP(start, \\\"comments_before_length\\\") ? start.comments_before_length : comments.length;\\n        while (--i >= 0) {\\n            var comment = comments[i];\\n            if (/[@#]__PURE__/.test(comment.value)) {\\n                call.pure = comment;\\n                break;\\n            }\\n        }\\n    }\\n\\n    var subscripts = function(expr, allow_calls) {\\n        var start = expr.start;\\n        if (is(\\\"punc\\\", \\\".\\\")) {\\n            next();\\n            return subscripts(new AST_Dot({\\n                start      : start,\\n                expression : expr,\\n                property   : as_name(),\\n                end        : prev()\\n            }), allow_calls);\\n        }\\n        if (is(\\\"punc\\\", \\\"[\\\")) {\\n            next();\\n            var prop = expression(true);\\n            expect(\\\"]\\\");\\n            return subscripts(new AST_Sub({\\n                start      : start,\\n                expression : expr,\\n                property   : prop,\\n                end        : prev()\\n            }), allow_calls);\\n        }\\n        if (allow_calls && is(\\\"punc\\\", \\\"(\\\")) {\\n            next();\\n            var call = new AST_Call({\\n                start      : start,\\n                expression : expr,\\n                args       : call_args(),\\n                end        : prev()\\n            });\\n            mark_pure(call);\\n            return subscripts(call, true);\\n        }\\n        if (is(\\\"template_head\\\")) {\\n            return subscripts(new AST_PrefixedTemplateString({\\n                start: start,\\n                prefix: expr,\\n                template_string: template_string()\\n            }), allow_calls);\\n        }\\n        return expr;\\n    };\\n\\n    var call_args = embed_tokens(function _call_args() {\\n        var args = [];\\n        while (!is(\\\"punc\\\", \\\")\\\")) {\\n            if (is(\\\"expand\\\", \\\"...\\\")) {\\n                next();\\n                args.push(new AST_Expansion({\\n                    start: prev(),\\n                    expression: expression(false)\\n                }));\\n            } else {\\n                args.push(expression(false));\\n            }\\n            if (!is(\\\"punc\\\", \\\")\\\")) {\\n                expect(\\\",\\\");\\n                if (is(\\\"punc\\\", \\\")\\\") && options.ecma < 8) unexpected();\\n            }\\n        }\\n        next();\\n        return args;\\n    });\\n\\n    var maybe_unary = function(allow_calls, allow_arrows) {\\n        var start = S.token;\\n        if (start.type == \\\"name\\\" && start.value == \\\"await\\\") {\\n            if (is_in_async()) {\\n                next();\\n                return _await_expression();\\n            } else if (S.input.has_directive(\\\"use strict\\\")) {\\n                token_error(S.token, \\\"Unexpected await identifier inside strict mode\\\")\\n            }\\n        }\\n        if (is(\\\"operator\\\") && UNARY_PREFIX(start.value)) {\\n            next();\\n            handle_regexp();\\n            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));\\n            ex.start = start;\\n            ex.end = prev();\\n            return ex;\\n        }\\n        var val = expr_atom(allow_calls, allow_arrows);\\n        while (is(\\\"operator\\\") && UNARY_POSTFIX(S.token.value) && !has_newline_before(S.token)) {\\n            if (val instanceof AST_Arrow) unexpected();\\n            val = make_unary(AST_UnaryPostfix, S.token, val);\\n            val.start = start;\\n            val.end = S.token;\\n            next();\\n        }\\n        return val;\\n    };\\n\\n    function make_unary(ctor, token, expr) {\\n        var op = token.value;\\n        switch (op) {\\n          case \\\"++\\\":\\n          case \\\"--\\\":\\n            if (!is_assignable(expr))\\n                croak(\\\"Invalid use of \\\" + op + \\\" operator\\\", token.line, token.col, token.pos);\\n            break;\\n          case \\\"delete\\\":\\n            if (expr instanceof AST_SymbolRef && S.input.has_directive(\\\"use strict\\\"))\\n                croak(\\\"Calling delete on expression not allowed in strict mode\\\", expr.start.line, expr.start.col, expr.start.pos);\\n            break;\\n        }\\n        return new ctor({ operator: op, expression: expr });\\n    };\\n\\n    var expr_op = function(left, min_prec, no_in) {\\n        var op = is(\\\"operator\\\") ? S.token.value : null;\\n        if (op == \\\"in\\\" && no_in) op = null;\\n        if (op == \\\"**\\\" && left instanceof AST_UnaryPrefix\\n            /* unary token in front not allowed - parenthesis required */\\n            && !is_token(left.start, \\\"punc\\\", \\\"(\\\")\\n            && left.operator !== \\\"--\\\" && left.operator !== \\\"++\\\")\\n                unexpected(left.start);\\n        var prec = op != null ? PRECEDENCE[op] : null;\\n        if (prec != null && (prec > min_prec || (op === \\\"**\\\" && min_prec === prec))) {\\n            next();\\n            var right = expr_op(maybe_unary(true), prec, no_in);\\n            return expr_op(new AST_Binary({\\n                start    : left.start,\\n                left     : left,\\n                operator : op,\\n                right    : right,\\n                end      : right.end\\n            }), min_prec, no_in);\\n        }\\n        return left;\\n    };\\n\\n    function expr_ops(no_in) {\\n        return expr_op(maybe_unary(true, true), 0, no_in);\\n    };\\n\\n    var maybe_conditional = function(no_in) {\\n        var start = S.token;\\n        var expr = expr_ops(no_in);\\n        if (is(\\\"operator\\\", \\\"?\\\")) {\\n            next();\\n            var yes = expression(false);\\n            expect(\\\":\\\");\\n            return new AST_Conditional({\\n                start       : start,\\n                condition   : expr,\\n                consequent  : yes,\\n                alternative : expression(false, no_in),\\n                end         : prev()\\n            });\\n        }\\n        return expr;\\n    };\\n\\n    function is_assignable(expr) {\\n        return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;\\n    };\\n\\n    function to_destructuring(node) {\\n        if (node instanceof AST_Object) {\\n            node = new AST_Destructuring({\\n                start: node.start,\\n                names: node.properties.map(to_destructuring),\\n                is_array: false,\\n                end: node.end\\n            });\\n        } else if (node instanceof AST_Array) {\\n            var names = [];\\n\\n            for (var i = 0; i < node.elements.length; i++) {\\n                // Only allow expansion as last element\\n                if (node.elements[i] instanceof AST_Expansion) {\\n                    if (i + 1 !== node.elements.length) {\\n                        token_error(node.elements[i].start, \\\"Spread must the be last element in destructuring array\\\");\\n                    }\\n                    node.elements[i].expression = to_destructuring(node.elements[i].expression);\\n                }\\n\\n                names.push(to_destructuring(node.elements[i]));\\n            }\\n\\n            node = new AST_Destructuring({\\n                start: node.start,\\n                names: names,\\n                is_array: true,\\n                end: node.end\\n            });\\n        } else if (node instanceof AST_ObjectProperty) {\\n            node.value = to_destructuring(node.value);\\n        } else if (node instanceof AST_Assign) {\\n            node = new AST_DefaultAssign({\\n                start: node.start,\\n                left: node.left,\\n                operator: \\\"=\\\",\\n                right: node.right,\\n                end: node.end\\n            });\\n        }\\n        return node;\\n    }\\n\\n    // In ES6, AssignmentExpression can also be an ArrowFunction\\n    var maybe_assign = function(no_in) {\\n        var start = S.token;\\n\\n        if (start.type == \\\"name\\\" && start.value == \\\"yield\\\") {\\n            if (is_in_generator()) {\\n                next();\\n                return _yield_expression();\\n            } else if (S.input.has_directive(\\\"use strict\\\")) {\\n                token_error(S.token, \\\"Unexpected yield identifier inside strict mode\\\");\\n            }\\n        }\\n\\n        var left = maybe_conditional(no_in);\\n        var val = S.token.value;\\n\\n        if (is(\\\"operator\\\") && ASSIGNMENT(val)) {\\n            if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {\\n                next();\\n                return new AST_Assign({\\n                    start    : start,\\n                    left     : left,\\n                    operator : val,\\n                    right    : maybe_assign(no_in),\\n                    end      : prev()\\n                });\\n            }\\n            croak(\\\"Invalid assignment\\\");\\n        }\\n        return left;\\n    };\\n\\n    var expression = function(commas, no_in) {\\n        var start = S.token;\\n        var exprs = [];\\n        while (true) {\\n            exprs.push(maybe_assign(no_in));\\n            if (!commas || !is(\\\"punc\\\", \\\",\\\")) break;\\n            next();\\n            commas = true;\\n        }\\n        return exprs.length == 1 ? exprs[0] : new AST_Sequence({\\n            start       : start,\\n            expressions : exprs,\\n            end         : peek()\\n        });\\n    };\\n\\n    function in_loop(cont) {\\n        ++S.in_loop;\\n        var ret = cont();\\n        --S.in_loop;\\n        return ret;\\n    };\\n\\n    if (options.expression) {\\n        return expression(true);\\n    }\\n\\n    return (function(){\\n        var start = S.token;\\n        var body = [];\\n        S.input.push_directives_stack();\\n        while (!is(\\\"eof\\\"))\\n            body.push(statement());\\n        S.input.pop_directives_stack();\\n        var end = prev();\\n        var toplevel = options.toplevel;\\n        if (toplevel) {\\n            toplevel.body = toplevel.body.concat(body);\\n            toplevel.end = end;\\n        } else {\\n            toplevel = new AST_Toplevel({ start: start, body: body, end: end });\\n        }\\n        return toplevel;\\n    })();\\n\\n};\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9kaXN0L2Nqcy5qcz9lc01vZHVsZT1mYWxzZSEuL25vZGVfbW9kdWxlcy91Z2xpZnktZXMvbGliL3BhcnNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VnbGlmeS1lcy9saWIvcGFyc2UuanM/OTg4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXFxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxcblxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cXG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xcblxcbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxcblxcbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cXG4gICAgUGFyc2VyIGJhc2VkIG9uIHBhcnNlLWpzIChodHRwOi8vbWFyaWpuLmhhdmVyYmVrZS5ubC9wYXJzZS1qcy8pLlxcblxcbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXFxuICAgIGFyZSBtZXQ6XFxuXFxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmVcXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcXG4gICAgICAgICAgZGlzY2xhaW1lci5cXG5cXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xcbiAgICAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblxcbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSIOKAnEFTIElT4oCdIEFORCBBTllcXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuICAgIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIEJFXFxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcXG4gICAgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXFxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxcbiAgICBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0ZcXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXFxuICAgIFNVQ0ggREFNQUdFLlxcblxcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEtFWVdPUkRTID0gJ2JyZWFrIGNhc2UgY2F0Y2ggY2xhc3MgY29uc3QgY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkZWxldGUgZG8gZWxzZSBleHBvcnQgZXh0ZW5kcyBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbiBpbnN0YW5jZW9mIGxldCBuZXcgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdHlwZW9mIHZhciB2b2lkIHdoaWxlIHdpdGgnO1xcbnZhciBLRVlXT1JEU19BVE9NID0gJ2ZhbHNlIG51bGwgdHJ1ZSc7XFxudmFyIFJFU0VSVkVEX1dPUkRTID0gJ2VudW0gaW1wbGVtZW50cyBpbXBvcnQgaW50ZXJmYWNlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyBzdXBlciB0aGlzICcgKyBLRVlXT1JEU19BVE9NICsgXFxcIiBcXFwiICsgS0VZV09SRFM7XFxudmFyIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gJ3JldHVybiBuZXcgZGVsZXRlIHRocm93IGVsc2UgY2FzZSB5aWVsZCBhd2FpdCc7XFxuXFxuS0VZV09SRFMgPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTKTtcXG5SRVNFUlZFRF9XT1JEUyA9IG1ha2VQcmVkaWNhdGUoUkVTRVJWRURfV09SRFMpO1xcbktFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShLRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTik7XFxuS0VZV09SRFNfQVRPTSA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQVRPTSk7XFxuXFxudmFyIE9QRVJBVE9SX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFxcXCIrLSomJT08PiE/fH5eXFxcIikpO1xcblxcbnZhciBSRV9OVU1fTElURVJBTCA9IC9bMC05YS1mXS9pO1xcbnZhciBSRV9IRVhfTlVNQkVSID0gL14weFswLTlhLWZdKyQvaTtcXG52YXIgUkVfT0NUX05VTUJFUiA9IC9eMFswLTddKyQvO1xcbnZhciBSRV9FUzZfT0NUX05VTUJFUiA9IC9eMG9bMC03XSskL2k7XFxudmFyIFJFX0JJTl9OVU1CRVIgPSAvXjBiWzAxXSskL2k7XFxudmFyIFJFX0RFQ19OVU1CRVIgPSAvXlxcXFxkKlxcXFwuP1xcXFxkKig/OmVbKy1dP1xcXFxkKig/OlxcXFxkXFxcXC4/fFxcXFwuP1xcXFxkKVxcXFxkKik/JC9pO1xcblxcbnZhciBPUEVSQVRPUlMgPSBtYWtlUHJlZGljYXRlKFtcXG4gICAgXFxcImluXFxcIixcXG4gICAgXFxcImluc3RhbmNlb2ZcXFwiLFxcbiAgICBcXFwidHlwZW9mXFxcIixcXG4gICAgXFxcIm5ld1xcXCIsXFxuICAgIFxcXCJ2b2lkXFxcIixcXG4gICAgXFxcImRlbGV0ZVxcXCIsXFxuICAgIFxcXCIrK1xcXCIsXFxuICAgIFxcXCItLVxcXCIsXFxuICAgIFxcXCIrXFxcIixcXG4gICAgXFxcIi1cXFwiLFxcbiAgICBcXFwiIVxcXCIsXFxuICAgIFxcXCJ+XFxcIixcXG4gICAgXFxcIiZcXFwiLFxcbiAgICBcXFwifFxcXCIsXFxuICAgIFxcXCJeXFxcIixcXG4gICAgXFxcIipcXFwiLFxcbiAgICBcXFwiKipcXFwiLFxcbiAgICBcXFwiL1xcXCIsXFxuICAgIFxcXCIlXFxcIixcXG4gICAgXFxcIj4+XFxcIixcXG4gICAgXFxcIjw8XFxcIixcXG4gICAgXFxcIj4+PlxcXCIsXFxuICAgIFxcXCI8XFxcIixcXG4gICAgXFxcIj5cXFwiLFxcbiAgICBcXFwiPD1cXFwiLFxcbiAgICBcXFwiPj1cXFwiLFxcbiAgICBcXFwiPT1cXFwiLFxcbiAgICBcXFwiPT09XFxcIixcXG4gICAgXFxcIiE9XFxcIixcXG4gICAgXFxcIiE9PVxcXCIsXFxuICAgIFxcXCI/XFxcIixcXG4gICAgXFxcIj1cXFwiLFxcbiAgICBcXFwiKz1cXFwiLFxcbiAgICBcXFwiLT1cXFwiLFxcbiAgICBcXFwiLz1cXFwiLFxcbiAgICBcXFwiKj1cXFwiLFxcbiAgICBcXFwiKio9XFxcIixcXG4gICAgXFxcIiU9XFxcIixcXG4gICAgXFxcIj4+PVxcXCIsXFxuICAgIFxcXCI8PD1cXFwiLFxcbiAgICBcXFwiPj4+PVxcXCIsXFxuICAgIFxcXCJ8PVxcXCIsXFxuICAgIFxcXCJePVxcXCIsXFxuICAgIFxcXCImPVxcXCIsXFxuICAgIFxcXCImJlxcXCIsXFxuICAgIFxcXCJ8fFxcXCJcXG5dKTtcXG5cXG52YXIgV0hJVEVTUEFDRV9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcXFwiIFxcXFx1MDBhMFxcXFxuXFxcXHJcXFxcdFxcXFxmXFxcXHUwMDBiXFxcXHUyMDBiXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwXFxcXHVGRUZGXFxcIikpO1xcblxcbnZhciBORVdMSU5FX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFxcXCJcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcIikpO1xcblxcbnZhciBQVU5DX0FGVEVSX0VYUFJFU1NJT04gPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXFxcIjtdKSw6XFxcIikpO1xcblxcbnZhciBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFxcXCJbeygsOzpcXFwiKSk7XFxuXFxudmFyIFBVTkNfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXFxcIltde30oKSw7OlxcXCIpKTtcXG5cXG4vKiAtLS0tLVsgVG9rZW5pemVyIF0tLS0tLSAqL1xcblxcbi8vIHN1cnJvZ2F0ZSBzYWZlIHJlZ2V4cHMgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOC4wLjAvdHJlZS84OWI0MTJkOGE3MWVjY2E5ZWQ1OTNkOWU5ZmEwNzNhYjY0YWNmZWJlL0JpbmFyeV9Qcm9wZXJ0eVxcbnZhciBVTklDT0RFID0ge1xcbiAgICBJRF9TdGFydDogL1tBLVphLXpcXFxceEFBXFxcXHhCNVxcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDhBLVxcXFx1MDUyRlxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVGMC1cXFxcdTA1RjJcXFxcdTA2MjAtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFBXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhBMC1cXFxcdTA4QjRcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5ODBcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBBRjlcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OC1cXFxcdTBDNUFcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRFxcXFx1MEQ0RVxcXFx1MEQ1Ri1cXFxcdTBENjFcXFxcdTBEN0EtXFxcXHUwRDdGXFxcXHUwRDg1LVxcXFx1MEQ5NlxcXFx1MEQ5QS1cXFxcdTBEQjFcXFxcdTBEQjMtXFxcXHUwREJCXFxcXHUwREJEXFxcXHUwREMwLVxcXFx1MERDNlxcXFx1MEUwMS1cXFxcdTBFMzBcXFxcdTBFMzJcXFxcdTBFMzNcXFxcdTBFNDAtXFxcXHUwRTQ2XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg3XFxcXHUwRTg4XFxcXHUwRThBXFxcXHUwRThEXFxcXHUwRTk0LVxcXFx1MEU5N1xcXFx1MEU5OS1cXFxcdTBFOUZcXFxcdTBFQTEtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3XFxcXHUwRUFBXFxcXHUwRUFCXFxcXHUwRUFELVxcXFx1MEVCMFxcXFx1MEVCMlxcXFx1MEVCM1xcXFx1MEVCRFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTBFQzZcXFxcdTBFREMtXFxcXHUwRURGXFxcXHUwRjAwXFxcXHUwRjQwLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGODgtXFxcXHUwRjhDXFxcXHUxMDAwLVxcXFx1MTAyQVxcXFx1MTAzRlxcXFx1MTA1MC1cXFxcdTEwNTVcXFxcdTEwNUEtXFxcXHUxMDVEXFxcXHUxMDYxXFxcXHUxMDY1XFxcXHUxMDY2XFxcXHUxMDZFLVxcXFx1MTA3MFxcXFx1MTA3NS1cXFxcdTEwODFcXFxcdTEwOEVcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEM3XFxcXHUxMENEXFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQy1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjVcXFxcdTEzRjgtXFxcXHUxM0ZEXFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN0IzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBQlxcXFx1MTlCMC1cXFxcdTE5QzlcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQTIwLVxcXFx1MUE1NFxcXFx1MUFBN1xcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUJCQS1cXFxcdTFCRTVcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDN0RcXFxcdTFDRTktXFxcXHUxQ0VDXFxcXHUxQ0VFLVxcXFx1MUNGMVxcXFx1MUNGNVxcXFx1MUNGNlxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOC1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQ0U0XFxcXHUyQ0VCLVxcXFx1MkNFRVxcXFx1MkNGMlxcXFx1MkNGM1xcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMjdcXFxcdTJEMkRcXFxcdTJEMzAtXFxcXHUyRDY3XFxcXHUyRDZGXFxcXHUyRDgwLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUzMDA1LVxcXFx1MzAwN1xcXFx1MzAyMS1cXFxcdTMwMjlcXFxcdTMwMzEtXFxcXHUzMDM1XFxcXHUzMDM4LVxcXFx1MzAzQ1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOUItXFxcXHUzMDlGXFxcXHUzMEExLVxcXFx1MzBGQVxcXFx1MzBGQy1cXFxcdTMwRkZcXFxcdTMxMDUtXFxcXHUzMTJEXFxcXHUzMTMxLVxcXFx1MzE4RVxcXFx1MzFBMC1cXFxcdTMxQkFcXFxcdTMxRjAtXFxcXHUzMUZGXFxcXHUzNDAwLVxcXFx1NERCNVxcXFx1NEUwMC1cXFxcdTlGRDVcXFxcdUEwMDAtXFxcXHVBNDhDXFxcXHVBNEQwLVxcXFx1QTRGRFxcXFx1QTUwMC1cXFxcdUE2MENcXFxcdUE2MTAtXFxcXHVBNjFGXFxcXHVBNjJBXFxcXHVBNjJCXFxcXHVBNjQwLVxcXFx1QTY2RVxcXFx1QTY3Ri1cXFxcdUE2OURcXFxcdUE2QTAtXFxcXHVBNkVGXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEItXFxcXHVBN0FEXFxcXHVBN0IwLVxcXFx1QTdCN1xcXFx1QTdGNy1cXFxcdUE4MDFcXFxcdUE4MDMtXFxcXHVBODA1XFxcXHVBODA3LVxcXFx1QTgwQVxcXFx1QTgwQy1cXFxcdUE4MjJcXFxcdUE4NDAtXFxcXHVBODczXFxcXHVBODgyLVxcXFx1QThCM1xcXFx1QThGMi1cXFxcdUE4RjdcXFxcdUE4RkJcXFxcdUE4RkRcXFxcdUE5MEEtXFxcXHVBOTI1XFxcXHVBOTMwLVxcXFx1QTk0NlxcXFx1QTk2MC1cXFxcdUE5N0NcXFxcdUE5ODQtXFxcXHVBOUIyXFxcXHVBOUNGXFxcXHVBOUUwLVxcXFx1QTlFNFxcXFx1QTlFNi1cXFxcdUE5RUZcXFxcdUE5RkEtXFxcXHVBOUZFXFxcXHVBQTAwLVxcXFx1QUEyOFxcXFx1QUE0MC1cXFxcdUFBNDJcXFxcdUFBNDQtXFxcXHVBQTRCXFxcXHVBQTYwLVxcXFx1QUE3NlxcXFx1QUE3QVxcXFx1QUE3RS1cXFxcdUFBQUZcXFxcdUFBQjFcXFxcdUFBQjVcXFxcdUFBQjZcXFxcdUFBQjktXFxcXHVBQUJEXFxcXHVBQUMwXFxcXHVBQUMyXFxcXHVBQURCLVxcXFx1QUFERFxcXFx1QUFFMC1cXFxcdUFBRUFcXFxcdUFBRjItXFxcXHVBQUY0XFxcXHVBQjAxLVxcXFx1QUIwNlxcXFx1QUIwOS1cXFxcdUFCMEVcXFxcdUFCMTEtXFxcXHVBQjE2XFxcXHVBQjIwLVxcXFx1QUIyNlxcXFx1QUIyOC1cXFxcdUFCMkVcXFxcdUFCMzAtXFxcXHVBQjVBXFxcXHVBQjVDLVxcXFx1QUI2NVxcXFx1QUI3MC1cXFxcdUFCRTJcXFxcdUFDMDAtXFxcXHVEN0EzXFxcXHVEN0IwLVxcXFx1RDdDNlxcXFx1RDdDQi1cXFxcdUQ3RkJcXFxcdUY5MDAtXFxcXHVGQTZEXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFEXFxcXHVGQjFGLVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYyMS1cXFxcdUZGM0FcXFxcdUZGNDEtXFxcXHVGRjVBXFxcXHVGRjY2LVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENdfFxcXFx1RDgwMFtcXFxcdURDMDAtXFxcXHVEQzBCXFxcXHVEQzBELVxcXFx1REMyNlxcXFx1REMyOC1cXFxcdURDM0FcXFxcdURDM0NcXFxcdURDM0RcXFxcdURDM0YtXFxcXHVEQzREXFxcXHVEQzUwLVxcXFx1REM1RFxcXFx1REM4MC1cXFxcdURDRkFcXFxcdURENDAtXFxcXHVERDc0XFxcXHVERTgwLVxcXFx1REU5Q1xcXFx1REVBMC1cXFxcdURFRDBcXFxcdURGMDAtXFxcXHVERjFGXFxcXHVERjMwLVxcXFx1REY0QVxcXFx1REY1MC1cXFxcdURGNzVcXFxcdURGODAtXFxcXHVERjlEXFxcXHVERkEwLVxcXFx1REZDM1xcXFx1REZDOC1cXFxcdURGQ0ZcXFxcdURGRDEtXFxcXHVERkQ1XXxcXFxcdUQ4MDFbXFxcXHVEQzAwLVxcXFx1REM5RFxcXFx1REQwMC1cXFxcdUREMjdcXFxcdUREMzAtXFxcXHVERDYzXFxcXHVERTAwLVxcXFx1REYzNlxcXFx1REY0MC1cXFxcdURGNTVcXFxcdURGNjAtXFxcXHVERjY3XXxcXFxcdUQ4MDJbXFxcXHVEQzAwLVxcXFx1REMwNVxcXFx1REMwOFxcXFx1REMwQS1cXFxcdURDMzVcXFxcdURDMzdcXFxcdURDMzhcXFxcdURDM0NcXFxcdURDM0YtXFxcXHVEQzU1XFxcXHVEQzYwLVxcXFx1REM3NlxcXFx1REM4MC1cXFxcdURDOUVcXFxcdURDRTAtXFxcXHVEQ0YyXFxcXHVEQ0Y0XFxcXHVEQ0Y1XFxcXHVERDAwLVxcXFx1REQxNVxcXFx1REQyMC1cXFxcdUREMzlcXFxcdUREODAtXFxcXHVEREI3XFxcXHVEREJFXFxcXHVEREJGXFxcXHVERTAwXFxcXHVERTEwLVxcXFx1REUxM1xcXFx1REUxNS1cXFxcdURFMTdcXFxcdURFMTktXFxcXHVERTMzXFxcXHVERTYwLVxcXFx1REU3Q1xcXFx1REU4MC1cXFxcdURFOUNcXFxcdURFQzAtXFxcXHVERUM3XFxcXHVERUM5LVxcXFx1REVFNFxcXFx1REYwMC1cXFxcdURGMzVcXFxcdURGNDAtXFxcXHVERjU1XFxcXHVERjYwLVxcXFx1REY3MlxcXFx1REY4MC1cXFxcdURGOTFdfFxcXFx1RDgwM1tcXFxcdURDMDAtXFxcXHVEQzQ4XFxcXHVEQzgwLVxcXFx1RENCMlxcXFx1RENDMC1cXFxcdURDRjJdfFxcXFx1RDgwNFtcXFxcdURDMDMtXFxcXHVEQzM3XFxcXHVEQzgzLVxcXFx1RENBRlxcXFx1RENEMC1cXFxcdURDRThcXFxcdUREMDMtXFxcXHVERDI2XFxcXHVERDUwLVxcXFx1REQ3MlxcXFx1REQ3NlxcXFx1REQ4My1cXFxcdUREQjJcXFxcdUREQzEtXFxcXHVEREM0XFxcXHVERERBXFxcXHVERERDXFxcXHVERTAwLVxcXFx1REUxMVxcXFx1REUxMy1cXFxcdURFMkJcXFxcdURFODAtXFxcXHVERTg2XFxcXHVERTg4XFxcXHVERThBLVxcXFx1REU4RFxcXFx1REU4Ri1cXFxcdURFOURcXFxcdURFOUYtXFxcXHVERUE4XFxcXHVERUIwLVxcXFx1REVERVxcXFx1REYwNS1cXFxcdURGMENcXFxcdURGMEZcXFxcdURGMTBcXFxcdURGMTMtXFxcXHVERjI4XFxcXHVERjJBLVxcXFx1REYzMFxcXFx1REYzMlxcXFx1REYzM1xcXFx1REYzNS1cXFxcdURGMzlcXFxcdURGM0RcXFxcdURGNTBcXFxcdURGNUQtXFxcXHVERjYxXXxcXFxcdUQ4MDVbXFxcXHVEQzgwLVxcXFx1RENBRlxcXFx1RENDNFxcXFx1RENDNVxcXFx1RENDN1xcXFx1REQ4MC1cXFxcdUREQUVcXFxcdURERDgtXFxcXHVERERCXFxcXHVERTAwLVxcXFx1REUyRlxcXFx1REU0NFxcXFx1REU4MC1cXFxcdURFQUFcXFxcdURGMDAtXFxcXHVERjE5XXxcXFxcdUQ4MDZbXFxcXHVEQ0EwLVxcXFx1RENERlxcXFx1RENGRlxcXFx1REVDMC1cXFxcdURFRjhdfFxcXFx1RDgwOFtcXFxcdURDMDAtXFxcXHVERjk5XXxcXFxcdUQ4MDlbXFxcXHVEQzAwLVxcXFx1REM2RVxcXFx1REM4MC1cXFxcdURENDNdfFtcXFxcdUQ4MENcXFxcdUQ4NDAtXFxcXHVEODY4XFxcXHVEODZBLVxcXFx1RDg2Q1xcXFx1RDg2Ri1cXFxcdUQ4NzJdW1xcXFx1REMwMC1cXFxcdURGRkZdfFxcXFx1RDgwRFtcXFxcdURDMDAtXFxcXHVEQzJFXXxcXFxcdUQ4MTFbXFxcXHVEQzAwLVxcXFx1REU0Nl18XFxcXHVEODFBW1xcXFx1REMwMC1cXFxcdURFMzhcXFxcdURFNDAtXFxcXHVERTVFXFxcXHVERUQwLVxcXFx1REVFRFxcXFx1REYwMC1cXFxcdURGMkZcXFxcdURGNDAtXFxcXHVERjQzXFxcXHVERjYzLVxcXFx1REY3N1xcXFx1REY3RC1cXFxcdURGOEZdfFxcXFx1RDgxQltcXFxcdURGMDAtXFxcXHVERjQ0XFxcXHVERjUwXFxcXHVERjkzLVxcXFx1REY5Rl18XFxcXHVEODJDW1xcXFx1REMwMFxcXFx1REMwMV18XFxcXHVEODJGW1xcXFx1REMwMC1cXFxcdURDNkFcXFxcdURDNzAtXFxcXHVEQzdDXFxcXHVEQzgwLVxcXFx1REM4OFxcXFx1REM5MC1cXFxcdURDOTldfFxcXFx1RDgzNVtcXFxcdURDMDAtXFxcXHVEQzU0XFxcXHVEQzU2LVxcXFx1REM5Q1xcXFx1REM5RVxcXFx1REM5RlxcXFx1RENBMlxcXFx1RENBNVxcXFx1RENBNlxcXFx1RENBOS1cXFxcdURDQUNcXFxcdURDQUUtXFxcXHVEQ0I5XFxcXHVEQ0JCXFxcXHVEQ0JELVxcXFx1RENDM1xcXFx1RENDNS1cXFxcdUREMDVcXFxcdUREMDctXFxcXHVERDBBXFxcXHVERDBELVxcXFx1REQxNFxcXFx1REQxNi1cXFxcdUREMUNcXFxcdUREMUUtXFxcXHVERDM5XFxcXHVERDNCLVxcXFx1REQzRVxcXFx1REQ0MC1cXFxcdURENDRcXFxcdURENDZcXFxcdURENEEtXFxcXHVERDUwXFxcXHVERDUyLVxcXFx1REVBNVxcXFx1REVBOC1cXFxcdURFQzBcXFxcdURFQzItXFxcXHVERURBXFxcXHVERURDLVxcXFx1REVGQVxcXFx1REVGQy1cXFxcdURGMTRcXFxcdURGMTYtXFxcXHVERjM0XFxcXHVERjM2LVxcXFx1REY0RVxcXFx1REY1MC1cXFxcdURGNkVcXFxcdURGNzAtXFxcXHVERjg4XFxcXHVERjhBLVxcXFx1REZBOFxcXFx1REZBQS1cXFxcdURGQzJcXFxcdURGQzQtXFxcXHVERkNCXXxcXFxcdUQ4M0FbXFxcXHVEQzAwLVxcXFx1RENDNF18XFxcXHVEODNCW1xcXFx1REUwMC1cXFxcdURFMDNcXFxcdURFMDUtXFxcXHVERTFGXFxcXHVERTIxXFxcXHVERTIyXFxcXHVERTI0XFxcXHVERTI3XFxcXHVERTI5LVxcXFx1REUzMlxcXFx1REUzNC1cXFxcdURFMzdcXFxcdURFMzlcXFxcdURFM0JcXFxcdURFNDJcXFxcdURFNDdcXFxcdURFNDlcXFxcdURFNEJcXFxcdURFNEQtXFxcXHVERTRGXFxcXHVERTUxXFxcXHVERTUyXFxcXHVERTU0XFxcXHVERTU3XFxcXHVERTU5XFxcXHVERTVCXFxcXHVERTVEXFxcXHVERTVGXFxcXHVERTYxXFxcXHVERTYyXFxcXHVERTY0XFxcXHVERTY3LVxcXFx1REU2QVxcXFx1REU2Qy1cXFxcdURFNzJcXFxcdURFNzQtXFxcXHVERTc3XFxcXHVERTc5LVxcXFx1REU3Q1xcXFx1REU3RVxcXFx1REU4MC1cXFxcdURFODlcXFxcdURFOEItXFxcXHVERTlCXFxcXHVERUExLVxcXFx1REVBM1xcXFx1REVBNS1cXFxcdURFQTlcXFxcdURFQUItXFxcXHVERUJCXXxcXFxcdUQ4NjlbXFxcXHVEQzAwLVxcXFx1REVENlxcXFx1REYwMC1cXFxcdURGRkZdfFxcXFx1RDg2RFtcXFxcdURDMDAtXFxcXHVERjM0XFxcXHVERjQwLVxcXFx1REZGRl18XFxcXHVEODZFW1xcXFx1REMwMC1cXFxcdURDMURcXFxcdURDMjAtXFxcXHVERkZGXXxcXFxcdUQ4NzNbXFxcXHVEQzAwLVxcXFx1REVBMV18XFxcXHVEODdFW1xcXFx1REMwMC1cXFxcdURFMURdLyxcXG4gICAgSURfQ29udGludWU6IC9bMC05QS1aX2EtelxcXFx4QUFcXFxceEI1XFxcXHhCN1xcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzAwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODYtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2MjAtXFxcXHUwNjY5XFxcXHUwNjZFLVxcXFx1MDZEM1xcXFx1MDZENS1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMC1cXFxcdTA3NEFcXFxcdTA3NEQtXFxcXHUwN0IxXFxcXHUwN0MwLVxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDgwMC1cXFxcdTA4MkRcXFxcdTA4NDAtXFxcXHUwODVCXFxcXHUwOEEwLVxcXFx1MDhCNFxcXFx1MDhFMy1cXFxcdTA5NjNcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOTcxLVxcXFx1MDk4M1xcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkMtXFxcXHUwOUM0XFxcXHUwOUM3XFxcXHUwOUM4XFxcXHUwOUNCLVxcXFx1MDlDRVxcXFx1MDlEN1xcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTNcXFxcdTA5RTYtXFxcXHUwOUYxXFxcXHUwQTAxLVxcXFx1MEEwM1xcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEEzQ1xcXFx1MEEzRS1cXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE2Ni1cXFxcdTBBNzVcXFxcdTBBODEtXFxcXHUwQTgzXFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkMtXFxcXHUwQUM1XFxcXHUwQUM3LVxcXFx1MEFDOVxcXFx1MEFDQi1cXFxcdTBBQ0RcXFxcdTBBRDBcXFxcdTBBRTAtXFxcXHUwQUUzXFxcXHUwQUU2LVxcXFx1MEFFRlxcXFx1MEFGOVxcXFx1MEIwMS1cXFxcdTBCMDNcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNDLVxcXFx1MEI0NFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNTdcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYzXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEI3MVxcXFx1MEI4MlxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkJFLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNEXFxcXHUwQkQwXFxcXHUwQkQ3XFxcXHUwQkU2LVxcXFx1MEJFRlxcXFx1MEMwMC1cXFxcdTBDMDNcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzM5XFxcXHUwQzNELVxcXFx1MEM0NFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzU4LVxcXFx1MEM1QVxcXFx1MEM2MC1cXFxcdTBDNjNcXFxcdTBDNjYtXFxcXHUwQzZGXFxcXHUwQzgxLVxcXFx1MEM4M1xcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JDLVxcXFx1MENDNFxcXFx1MENDNi1cXFxcdTBDQzhcXFxcdTBDQ0EtXFxcXHUwQ0NEXFxcXHUwQ0Q1XFxcXHUwQ0Q2XFxcXHUwQ0RFXFxcXHUwQ0UwLVxcXFx1MENFM1xcXFx1MENFNi1cXFxcdTBDRUZcXFxcdTBDRjFcXFxcdTBDRjJcXFxcdTBEMDEtXFxcXHUwRDAzXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDNBXFxcXHUwRDNELVxcXFx1MEQ0NFxcXFx1MEQ0Ni1cXFxcdTBENDhcXFxcdTBENEEtXFxcXHUwRDRFXFxcXHUwRDU3XFxcXHUwRDVGLVxcXFx1MEQ2M1xcXFx1MEQ2Ni1cXFxcdTBENkZcXFxcdTBEN0EtXFxcXHUwRDdGXFxcXHUwRDgyXFxcXHUwRDgzXFxcXHUwRDg1LVxcXFx1MEQ5NlxcXFx1MEQ5QS1cXFxcdTBEQjFcXFxcdTBEQjMtXFxcXHUwREJCXFxcXHUwREJEXFxcXHUwREMwLVxcXFx1MERDNlxcXFx1MERDQVxcXFx1MERDRi1cXFxcdTBERDRcXFxcdTBERDZcXFxcdTBERDgtXFxcXHUwRERGXFxcXHUwREU2LVxcXFx1MERFRlxcXFx1MERGMlxcXFx1MERGM1xcXFx1MEUwMS1cXFxcdTBFM0FcXFxcdTBFNDAtXFxcXHUwRTRFXFxcXHUwRTUwLVxcXFx1MEU1OVxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjlcXFxcdTBFQkItXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVDOC1cXFxcdTBFQ0RcXFxcdTBFRDAtXFxcXHUwRUQ5XFxcXHUwRURDLVxcXFx1MEVERlxcXFx1MEYwMFxcXFx1MEYxOFxcXFx1MEYxOVxcXFx1MEYyMC1cXFxcdTBGMjlcXFxcdTBGMzVcXFxcdTBGMzdcXFxcdTBGMzlcXFxcdTBGM0UtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY3MS1cXFxcdTBGODRcXFxcdTBGODYtXFxcXHUwRjk3XFxcXHUwRjk5LVxcXFx1MEZCQ1xcXFx1MEZDNlxcXFx1MTAwMC1cXFxcdTEwNDlcXFxcdTEwNTAtXFxcXHUxMDlEXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBDN1xcXFx1MTBDRFxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkMtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM1RC1cXFxcdTEzNUZcXFxcdTEzNjktXFxcXHUxMzcxXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjVcXFxcdTEzRjgtXFxcXHUxM0ZEXFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxNFxcXFx1MTcyMC1cXFxcdTE3MzRcXFxcdTE3NDAtXFxcXHUxNzUzXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3ODAtXFxcXHUxN0QzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxN0REXFxcXHUxN0UwLVxcXFx1MTdFOVxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTkyMC1cXFxcdTE5MkJcXFxcdTE5MzAtXFxcXHUxOTNCXFxcXHUxOTQ2LVxcXFx1MTk2RFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOUFCXFxcXHUxOUIwLVxcXFx1MTlDOVxcXFx1MTlEMC1cXFxcdTE5REFcXFxcdTFBMDAtXFxcXHUxQTFCXFxcXHUxQTIwLVxcXFx1MUE1RVxcXFx1MUE2MC1cXFxcdTFBN0NcXFxcdTFBN0YtXFxcXHUxQTg5XFxcXHUxQTkwLVxcXFx1MUE5OVxcXFx1MUFBN1xcXFx1MUFCMC1cXFxcdTFBQkRcXFxcdTFCMDAtXFxcXHUxQjRCXFxcXHUxQjUwLVxcXFx1MUI1OVxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODAtXFxcXHUxQkYzXFxcXHUxQzAwLVxcXFx1MUMzN1xcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNEQtXFxcXHUxQzdEXFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRjZcXFxcdTFDRjhcXFxcdTFDRjlcXFxcdTFEMDAtXFxcXHUxREY1XFxcXHUxREZDLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOC1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQ0U0XFxcXHUyQ0VCLVxcXFx1MkNGM1xcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMjdcXFxcdTJEMkRcXFxcdTJEMzAtXFxcXHUyRDY3XFxcXHUyRDZGXFxcXHUyRDdGLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDJGXFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDk5LVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkQ1XFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkZcXFxcdUE2NzQtXFxcXHVBNjdEXFxcXHVBNjdGLVxcXFx1QTZGMVxcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCLVxcXFx1QTdBRFxcXFx1QTdCMC1cXFxcdUE3QjdcXFxcdUE3RjctXFxcXHVBODI3XFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4MC1cXFxcdUE4QzRcXFxcdUE4RDAtXFxcXHVBOEQ5XFxcXHVBOEUwLVxcXFx1QThGN1xcXFx1QThGQlxcXFx1QThGRFxcXFx1QTkwMC1cXFxcdUE5MkRcXFxcdUE5MzAtXFxcXHVBOTUzXFxcXHVBOTYwLVxcXFx1QTk3Q1xcXFx1QTk4MC1cXFxcdUE5QzBcXFxcdUE5Q0YtXFxcXHVBOUQ5XFxcXHVBOUUwLVxcXFx1QTlGRVxcXFx1QUEwMC1cXFxcdUFBMzZcXFxcdUFBNDAtXFxcXHVBQTREXFxcXHVBQTUwLVxcXFx1QUE1OVxcXFx1QUE2MC1cXFxcdUFBNzZcXFxcdUFBN0EtXFxcXHVBQUMyXFxcXHVBQURCLVxcXFx1QUFERFxcXFx1QUFFMC1cXFxcdUFBRUZcXFxcdUFBRjItXFxcXHVBQUY2XFxcXHVBQjAxLVxcXFx1QUIwNlxcXFx1QUIwOS1cXFxcdUFCMEVcXFxcdUFCMTEtXFxcXHVBQjE2XFxcXHVBQjIwLVxcXFx1QUIyNlxcXFx1QUIyOC1cXFxcdUFCMkVcXFxcdUFCMzAtXFxcXHVBQjVBXFxcXHVBQjVDLVxcXFx1QUI2NVxcXFx1QUI3MC1cXFxcdUFCRUFcXFxcdUFCRUNcXFxcdUFCRURcXFxcdUFCRjAtXFxcXHVBQkY5XFxcXHVBQzAwLVxcXFx1RDdBM1xcXFx1RDdCMC1cXFxcdUQ3QzZcXFxcdUQ3Q0ItXFxcXHVEN0ZCXFxcXHVGOTAwLVxcXFx1RkE2RFxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRC1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTAwLVxcXFx1RkUwRlxcXFx1RkUyMC1cXFxcdUZFMkZcXFxcdUZFMzNcXFxcdUZFMzRcXFxcdUZFNEQtXFxcXHVGRTRGXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMTAtXFxcXHVGRjE5XFxcXHVGRjIxLVxcXFx1RkYzQVxcXFx1RkYzRlxcXFx1RkY0MS1cXFxcdUZGNUFcXFxcdUZGNjYtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ118XFxcXHVEODAwW1xcXFx1REMwMC1cXFxcdURDMEJcXFxcdURDMEQtXFxcXHVEQzI2XFxcXHVEQzI4LVxcXFx1REMzQVxcXFx1REMzQ1xcXFx1REMzRFxcXFx1REMzRi1cXFxcdURDNERcXFxcdURDNTAtXFxcXHVEQzVEXFxcXHVEQzgwLVxcXFx1RENGQVxcXFx1REQ0MC1cXFxcdURENzRcXFxcdURERkRcXFxcdURFODAtXFxcXHVERTlDXFxcXHVERUEwLVxcXFx1REVEMFxcXFx1REVFMFxcXFx1REYwMC1cXFxcdURGMUZcXFxcdURGMzAtXFxcXHVERjRBXFxcXHVERjUwLVxcXFx1REY3QVxcXFx1REY4MC1cXFxcdURGOURcXFxcdURGQTAtXFxcXHVERkMzXFxcXHVERkM4LVxcXFx1REZDRlxcXFx1REZEMS1cXFxcdURGRDVdfFxcXFx1RDgwMVtcXFxcdURDMDAtXFxcXHVEQzlEXFxcXHVEQ0EwLVxcXFx1RENBOVxcXFx1REQwMC1cXFxcdUREMjdcXFxcdUREMzAtXFxcXHVERDYzXFxcXHVERTAwLVxcXFx1REYzNlxcXFx1REY0MC1cXFxcdURGNTVcXFxcdURGNjAtXFxcXHVERjY3XXxcXFxcdUQ4MDJbXFxcXHVEQzAwLVxcXFx1REMwNVxcXFx1REMwOFxcXFx1REMwQS1cXFxcdURDMzVcXFxcdURDMzdcXFxcdURDMzhcXFxcdURDM0NcXFxcdURDM0YtXFxcXHVEQzU1XFxcXHVEQzYwLVxcXFx1REM3NlxcXFx1REM4MC1cXFxcdURDOUVcXFxcdURDRTAtXFxcXHVEQ0YyXFxcXHVEQ0Y0XFxcXHVEQ0Y1XFxcXHVERDAwLVxcXFx1REQxNVxcXFx1REQyMC1cXFxcdUREMzlcXFxcdUREODAtXFxcXHVEREI3XFxcXHVEREJFXFxcXHVEREJGXFxcXHVERTAwLVxcXFx1REUwM1xcXFx1REUwNVxcXFx1REUwNlxcXFx1REUwQy1cXFxcdURFMTNcXFxcdURFMTUtXFxcXHVERTE3XFxcXHVERTE5LVxcXFx1REUzM1xcXFx1REUzOC1cXFxcdURFM0FcXFxcdURFM0ZcXFxcdURFNjAtXFxcXHVERTdDXFxcXHVERTgwLVxcXFx1REU5Q1xcXFx1REVDMC1cXFxcdURFQzdcXFxcdURFQzktXFxcXHVERUU2XFxcXHVERjAwLVxcXFx1REYzNVxcXFx1REY0MC1cXFxcdURGNTVcXFxcdURGNjAtXFxcXHVERjcyXFxcXHVERjgwLVxcXFx1REY5MV18XFxcXHVEODAzW1xcXFx1REMwMC1cXFxcdURDNDhcXFxcdURDODAtXFxcXHVEQ0IyXFxcXHVEQ0MwLVxcXFx1RENGMl18XFxcXHVEODA0W1xcXFx1REMwMC1cXFxcdURDNDZcXFxcdURDNjYtXFxcXHVEQzZGXFxcXHVEQzdGLVxcXFx1RENCQVxcXFx1RENEMC1cXFxcdURDRThcXFxcdURDRjAtXFxcXHVEQ0Y5XFxcXHVERDAwLVxcXFx1REQzNFxcXFx1REQzNi1cXFxcdUREM0ZcXFxcdURENTAtXFxcXHVERDczXFxcXHVERDc2XFxcXHVERDgwLVxcXFx1RERDNFxcXFx1RERDQS1cXFxcdUREQ0NcXFxcdURERDAtXFxcXHVERERBXFxcXHVERERDXFxcXHVERTAwLVxcXFx1REUxMVxcXFx1REUxMy1cXFxcdURFMzdcXFxcdURFODAtXFxcXHVERTg2XFxcXHVERTg4XFxcXHVERThBLVxcXFx1REU4RFxcXFx1REU4Ri1cXFxcdURFOURcXFxcdURFOUYtXFxcXHVERUE4XFxcXHVERUIwLVxcXFx1REVFQVxcXFx1REVGMC1cXFxcdURFRjlcXFxcdURGMDAtXFxcXHVERjAzXFxcXHVERjA1LVxcXFx1REYwQ1xcXFx1REYwRlxcXFx1REYxMFxcXFx1REYxMy1cXFxcdURGMjhcXFxcdURGMkEtXFxcXHVERjMwXFxcXHVERjMyXFxcXHVERjMzXFxcXHVERjM1LVxcXFx1REYzOVxcXFx1REYzQy1cXFxcdURGNDRcXFxcdURGNDdcXFxcdURGNDhcXFxcdURGNEItXFxcXHVERjREXFxcXHVERjUwXFxcXHVERjU3XFxcXHVERjVELVxcXFx1REY2M1xcXFx1REY2Ni1cXFxcdURGNkNcXFxcdURGNzAtXFxcXHVERjc0XXxcXFxcdUQ4MDVbXFxcXHVEQzgwLVxcXFx1RENDNVxcXFx1RENDN1xcXFx1RENEMC1cXFxcdURDRDlcXFxcdUREODAtXFxcXHVEREI1XFxcXHVEREI4LVxcXFx1RERDMFxcXFx1REREOC1cXFxcdURERERcXFxcdURFMDAtXFxcXHVERTQwXFxcXHVERTQ0XFxcXHVERTUwLVxcXFx1REU1OVxcXFx1REU4MC1cXFxcdURFQjdcXFxcdURFQzAtXFxcXHVERUM5XFxcXHVERjAwLVxcXFx1REYxOVxcXFx1REYxRC1cXFxcdURGMkJcXFxcdURGMzAtXFxcXHVERjM5XXxcXFxcdUQ4MDZbXFxcXHVEQ0EwLVxcXFx1RENFOVxcXFx1RENGRlxcXFx1REVDMC1cXFxcdURFRjhdfFxcXFx1RDgwOFtcXFxcdURDMDAtXFxcXHVERjk5XXxcXFxcdUQ4MDlbXFxcXHVEQzAwLVxcXFx1REM2RVxcXFx1REM4MC1cXFxcdURENDNdfFtcXFxcdUQ4MENcXFxcdUQ4NDAtXFxcXHVEODY4XFxcXHVEODZBLVxcXFx1RDg2Q1xcXFx1RDg2Ri1cXFxcdUQ4NzJdW1xcXFx1REMwMC1cXFxcdURGRkZdfFxcXFx1RDgwRFtcXFxcdURDMDAtXFxcXHVEQzJFXXxcXFxcdUQ4MTFbXFxcXHVEQzAwLVxcXFx1REU0Nl18XFxcXHVEODFBW1xcXFx1REMwMC1cXFxcdURFMzhcXFxcdURFNDAtXFxcXHVERTVFXFxcXHVERTYwLVxcXFx1REU2OVxcXFx1REVEMC1cXFxcdURFRURcXFxcdURFRjAtXFxcXHVERUY0XFxcXHVERjAwLVxcXFx1REYzNlxcXFx1REY0MC1cXFxcdURGNDNcXFxcdURGNTAtXFxcXHVERjU5XFxcXHVERjYzLVxcXFx1REY3N1xcXFx1REY3RC1cXFxcdURGOEZdfFxcXFx1RDgxQltcXFxcdURGMDAtXFxcXHVERjQ0XFxcXHVERjUwLVxcXFx1REY3RVxcXFx1REY4Ri1cXFxcdURGOUZdfFxcXFx1RDgyQ1tcXFxcdURDMDBcXFxcdURDMDFdfFxcXFx1RDgyRltcXFxcdURDMDAtXFxcXHVEQzZBXFxcXHVEQzcwLVxcXFx1REM3Q1xcXFx1REM4MC1cXFxcdURDODhcXFxcdURDOTAtXFxcXHVEQzk5XFxcXHVEQzlEXFxcXHVEQzlFXXxcXFxcdUQ4MzRbXFxcXHVERDY1LVxcXFx1REQ2OVxcXFx1REQ2RC1cXFxcdURENzJcXFxcdUREN0ItXFxcXHVERDgyXFxcXHVERDg1LVxcXFx1REQ4QlxcXFx1RERBQS1cXFxcdUREQURcXFxcdURFNDItXFxcXHVERTQ0XXxcXFxcdUQ4MzVbXFxcXHVEQzAwLVxcXFx1REM1NFxcXFx1REM1Ni1cXFxcdURDOUNcXFxcdURDOUVcXFxcdURDOUZcXFxcdURDQTJcXFxcdURDQTVcXFxcdURDQTZcXFxcdURDQTktXFxcXHVEQ0FDXFxcXHVEQ0FFLVxcXFx1RENCOVxcXFx1RENCQlxcXFx1RENCRC1cXFxcdURDQzNcXFxcdURDQzUtXFxcXHVERDA1XFxcXHVERDA3LVxcXFx1REQwQVxcXFx1REQwRC1cXFxcdUREMTRcXFxcdUREMTYtXFxcXHVERDFDXFxcXHVERDFFLVxcXFx1REQzOVxcXFx1REQzQi1cXFxcdUREM0VcXFxcdURENDAtXFxcXHVERDQ0XFxcXHVERDQ2XFxcXHVERDRBLVxcXFx1REQ1MFxcXFx1REQ1Mi1cXFxcdURFQTVcXFxcdURFQTgtXFxcXHVERUMwXFxcXHVERUMyLVxcXFx1REVEQVxcXFx1REVEQy1cXFxcdURFRkFcXFxcdURFRkMtXFxcXHVERjE0XFxcXHVERjE2LVxcXFx1REYzNFxcXFx1REYzNi1cXFxcdURGNEVcXFxcdURGNTAtXFxcXHVERjZFXFxcXHVERjcwLVxcXFx1REY4OFxcXFx1REY4QS1cXFxcdURGQThcXFxcdURGQUEtXFxcXHVERkMyXFxcXHVERkM0LVxcXFx1REZDQlxcXFx1REZDRS1cXFxcdURGRkZdfFxcXFx1RDgzNltcXFxcdURFMDAtXFxcXHVERTM2XFxcXHVERTNCLVxcXFx1REU2Q1xcXFx1REU3NVxcXFx1REU4NFxcXFx1REU5Qi1cXFxcdURFOUZcXFxcdURFQTEtXFxcXHVERUFGXXxcXFxcdUQ4M0FbXFxcXHVEQzAwLVxcXFx1RENDNFxcXFx1RENEMC1cXFxcdURDRDZdfFxcXFx1RDgzQltcXFxcdURFMDAtXFxcXHVERTAzXFxcXHVERTA1LVxcXFx1REUxRlxcXFx1REUyMVxcXFx1REUyMlxcXFx1REUyNFxcXFx1REUyN1xcXFx1REUyOS1cXFxcdURFMzJcXFxcdURFMzQtXFxcXHVERTM3XFxcXHVERTM5XFxcXHVERTNCXFxcXHVERTQyXFxcXHVERTQ3XFxcXHVERTQ5XFxcXHVERTRCXFxcXHVERTRELVxcXFx1REU0RlxcXFx1REU1MVxcXFx1REU1MlxcXFx1REU1NFxcXFx1REU1N1xcXFx1REU1OVxcXFx1REU1QlxcXFx1REU1RFxcXFx1REU1RlxcXFx1REU2MVxcXFx1REU2MlxcXFx1REU2NFxcXFx1REU2Ny1cXFxcdURFNkFcXFxcdURFNkMtXFxcXHVERTcyXFxcXHVERTc0LVxcXFx1REU3N1xcXFx1REU3OS1cXFxcdURFN0NcXFxcdURFN0VcXFxcdURFODAtXFxcXHVERTg5XFxcXHVERThCLVxcXFx1REU5QlxcXFx1REVBMS1cXFxcdURFQTNcXFxcdURFQTUtXFxcXHVERUE5XFxcXHVERUFCLVxcXFx1REVCQl18XFxcXHVEODY5W1xcXFx1REMwMC1cXFxcdURFRDZcXFxcdURGMDAtXFxcXHVERkZGXXxcXFxcdUQ4NkRbXFxcXHVEQzAwLVxcXFx1REYzNFxcXFx1REY0MC1cXFxcdURGRkZdfFxcXFx1RDg2RVtcXFxcdURDMDAtXFxcXHVEQzFEXFxcXHVEQzIwLVxcXFx1REZGRl18XFxcXHVEODczW1xcXFx1REMwMC1cXFxcdURFQTFdfFxcXFx1RDg3RVtcXFxcdURDMDAtXFxcXHVERTFEXXxcXFxcdURCNDBbXFxcXHVERDAwLVxcXFx1RERFRl0vLFxcbn07XFxuXFxuZnVuY3Rpb24gZ2V0X2Z1bGxfY2hhcihzdHIsIHBvcykge1xcbiAgICB2YXIgY2hhciA9IHN0ci5jaGFyQXQocG9zKTtcXG4gICAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoY2hhcikpIHtcXG4gICAgICAgIHZhciBuZXh0ID0gc3RyLmNoYXJBdChwb3MgKyAxKTtcXG4gICAgICAgIGlmIChpc19zdXJyb2dhdGVfcGFpcl90YWlsKG5leHQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGNoYXIgKyBuZXh0O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChpc19zdXJyb2dhdGVfcGFpcl90YWlsKGNoYXIpKSB7XFxuICAgICAgICB2YXIgcHJldiA9IHN0ci5jaGFyQXQocG9zIC0gMSk7XFxuICAgICAgICBpZiAoaXNfc3Vycm9nYXRlX3BhaXJfaGVhZChwcmV2KSkge1xcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICsgY2hhcjtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gY2hhcjtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0X2Z1bGxfY2hhcl9jb2RlKHN0ciwgcG9zKSB7XFxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xcbiAgICBpZiAoaXNfc3Vycm9nYXRlX3BhaXJfaGVhZChzdHIuY2hhckF0KHBvcykpKSB7XFxuICAgICAgICByZXR1cm4gMHgxMDAwMCArIChzdHIuY2hhckNvZGVBdChwb3MpIC0gMHhkODAwIDw8IDEwKSArIHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpIC0gMHhkYzAwO1xcbiAgICB9XFxuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdChwb3MpO1xcbn1cXG5cXG5mdW5jdGlvbiBnZXRfZnVsbF9jaGFyX2xlbmd0aChzdHIpIHtcXG4gICAgdmFyIHN1cnJvZ2F0ZXMgPSAwO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoc3RyLmNoYXJDb2RlQXQoaSkpKSB7XFxuICAgICAgICAgICAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX3RhaWwoc3RyLmNoYXJDb2RlQXQoaSArIDEpKSkge1xcbiAgICAgICAgICAgICAgICBzdXJyb2dhdGVzKys7XFxuICAgICAgICAgICAgICAgIGkrKztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggLSBzdXJyb2dhdGVzO1xcbn1cXG5cXG5mdW5jdGlvbiBmcm9tX2NoYXJfY29kZShjb2RlKSB7XFxuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5mcm9tQ29kZVBvaW50L2Jsb2IvbWFzdGVyL2Zyb21jb2RlcG9pbnQuanNcXG4gICAgaWYgKGNvZGUgPiAweEZGRkYpIHtcXG4gICAgICAgIGNvZGUgLT0gMHgxMDAwMDtcXG4gICAgICAgIHJldHVybiAoU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDApICtcXG4gICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlICUgMHg0MDApICsgMHhEQzAwKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XFxufVxcblxcbmZ1bmN0aW9uIGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoY29kZSkge1xcbiAgICBpZiAodHlwZW9mIGNvZGUgPT09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICAgICAgY29kZSA9IGNvZGUuY2hhckNvZGVBdCgwKTtcXG5cXG4gICAgcmV0dXJuIGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmO1xcbn1cXG5cXG5mdW5jdGlvbiBpc19zdXJyb2dhdGVfcGFpcl90YWlsKGNvZGUpIHtcXG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSBcXFwic3RyaW5nXFxcIilcXG4gICAgICAgIGNvZGUgPSBjb2RlLmNoYXJDb2RlQXQoMCk7XFxuICAgIHJldHVybiBjb2RlID49IDB4ZGMwMCAmJiBjb2RlIDw9IDB4ZGZmZjtcXG59XFxuXFxuZnVuY3Rpb24gaXNfZGlnaXQoY29kZSkge1xcbiAgICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xcbn07XFxuXFxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcihuYW1lKSB7XFxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXFxcInN0cmluZ1xcXCIgfHwgUkVTRVJWRURfV09SRFMobmFtZSkpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFxuICAgIHJldHVybiB0cnVlO1xcbn07XFxuXFxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdGFydChjaCkge1xcbiAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XFxuICAgIHJldHVybiBVTklDT0RFLklEX1N0YXJ0LnRlc3QoY2gpIHx8IGNvZGUgPT0gMzYgfHwgY29kZSA9PSA5NTtcXG59O1xcblxcbmZ1bmN0aW9uIGlzX2lkZW50aWZpZXJfY2hhcihjaCkge1xcbiAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XFxuICAgIHJldHVybiBVTklDT0RFLklEX0NvbnRpbnVlLnRlc3QoY2gpXFxuICAgICAgICB8fCBjb2RlID09IDM2XFxuICAgICAgICB8fCBjb2RlID09IDk1XFxuICAgICAgICB8fCBjb2RlID09IDgyMDQgLy8gXFxcXHUyMDBjOiB6ZXJvLXdpZHRoIG5vbi1qb2luZXIgPFpXTko+XFxuICAgICAgICB8fCBjb2RlID09IDgyMDUgLy8gXFxcXHUyMDBkOiB6ZXJvLXdpZHRoIGpvaW5lciA8WldKPiAoaW4gbXkgRUNNQS0yNjIgUERGLCB0aGlzIGlzIGFsc28gMjAwYylcXG4gICAgO1xcbn07XFxuXFxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdHJpbmcoc3RyKXtcXG4gICAgcmV0dXJuIC9eW2Etel8kXVthLXowLTlfJF0qJC9pLnRlc3Qoc3RyKTtcXG59O1xcblxcbmZ1bmN0aW9uIHBhcnNlX2pzX251bWJlcihudW0pIHtcXG4gICAgaWYgKFJFX0hFWF9OVU1CRVIudGVzdChudW0pKSB7XFxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigyKSwgMTYpO1xcbiAgICB9IGVsc2UgaWYgKFJFX09DVF9OVU1CRVIudGVzdChudW0pKSB7XFxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigxKSwgOCk7XFxuICAgIH0gZWxzZSBpZiAoUkVfRVM2X09DVF9OVU1CRVIudGVzdChudW0pKSB7XFxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigyKSwgOCk7XFxuICAgIH0gZWxzZSBpZiAoUkVfQklOX05VTUJFUi50ZXN0KG51bSkpIHtcXG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDIpLCAyKTtcXG4gICAgfSBlbHNlIGlmIChSRV9ERUNfTlVNQkVSLnRlc3QobnVtKSkge1xcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciB2YWwgPSBwYXJzZUZsb2F0KG51bSk7XFxuICAgICAgICBpZiAodmFsID09IG51bSkgcmV0dXJuIHZhbDtcXG4gICAgfVxcbn07XFxuXFxuZnVuY3Rpb24gSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgZmlsZW5hbWUsIGxpbmUsIGNvbCwgcG9zKSB7XFxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcXG4gICAgdGhpcy5saW5lID0gbGluZTtcXG4gICAgdGhpcy5jb2wgPSBjb2w7XFxuICAgIHRoaXMucG9zID0gcG9zO1xcbn07XFxuSlNfUGFyc2VfRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xcbkpTX1BhcnNlX0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpTX1BhcnNlX0Vycm9yO1xcbkpTX1BhcnNlX0Vycm9yLnByb3RvdHlwZS5uYW1lID0gXFxcIlN5bnRheEVycm9yXFxcIjtcXG5jb25maWd1cmVfZXJyb3Jfc3RhY2soSlNfUGFyc2VfRXJyb3IpO1xcblxcbmZ1bmN0aW9uIGpzX2Vycm9yKG1lc3NhZ2UsIGZpbGVuYW1lLCBsaW5lLCBjb2wsIHBvcykge1xcbiAgICB0aHJvdyBuZXcgSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgZmlsZW5hbWUsIGxpbmUsIGNvbCwgcG9zKTtcXG59O1xcblxcbmZ1bmN0aW9uIGlzX3Rva2VuKHRva2VuLCB0eXBlLCB2YWwpIHtcXG4gICAgcmV0dXJuIHRva2VuLnR5cGUgPT0gdHlwZSAmJiAodmFsID09IG51bGwgfHwgdG9rZW4udmFsdWUgPT0gdmFsKTtcXG59O1xcblxcbnZhciBFWF9FT0YgPSB7fTtcXG5cXG5mdW5jdGlvbiB0b2tlbml6ZXIoJFRFWFQsIGZpbGVuYW1lLCBodG1sNV9jb21tZW50cywgc2hlYmFuZykge1xcblxcbiAgICB2YXIgUyA9IHtcXG4gICAgICAgIHRleHQgICAgICAgICAgICA6ICRURVhULFxcbiAgICAgICAgZmlsZW5hbWUgICAgICAgIDogZmlsZW5hbWUsXFxuICAgICAgICBwb3MgICAgICAgICAgICAgOiAwLFxcbiAgICAgICAgdG9rcG9zICAgICAgICAgIDogMCxcXG4gICAgICAgIGxpbmUgICAgICAgICAgICA6IDEsXFxuICAgICAgICB0b2tsaW5lICAgICAgICAgOiAwLFxcbiAgICAgICAgY29sICAgICAgICAgICAgIDogMCxcXG4gICAgICAgIHRva2NvbCAgICAgICAgICA6IDAsXFxuICAgICAgICBuZXdsaW5lX2JlZm9yZSAgOiBmYWxzZSxcXG4gICAgICAgIHJlZ2V4X2FsbG93ZWQgICA6IGZhbHNlLFxcbiAgICAgICAgYnJhY2VfY291bnRlciAgIDogMCxcXG4gICAgICAgIHRlbXBsYXRlX2JyYWNlcyA6IFtdLFxcbiAgICAgICAgY29tbWVudHNfYmVmb3JlIDogW10sXFxuICAgICAgICBkaXJlY3RpdmVzICAgICAgOiB7fSxcXG4gICAgICAgIGRpcmVjdGl2ZV9zdGFjayA6IFtdXFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBnZXRfZnVsbF9jaGFyKFMudGV4dCwgUy5wb3MpOyB9O1xcblxcbiAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xcbiAgICAgICAgdmFyIGNoID0gZ2V0X2Z1bGxfY2hhcihTLnRleHQsIFMucG9zKyspO1xcbiAgICAgICAgaWYgKHNpZ25hbF9lb2YgJiYgIWNoKVxcbiAgICAgICAgICAgIHRocm93IEVYX0VPRjtcXG4gICAgICAgIGlmIChORVdMSU5FX0NIQVJTKGNoKSkge1xcbiAgICAgICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBTLm5ld2xpbmVfYmVmb3JlIHx8ICFpbl9zdHJpbmc7XFxuICAgICAgICAgICAgKytTLmxpbmU7XFxuICAgICAgICAgICAgUy5jb2wgPSAwO1xcbiAgICAgICAgICAgIGlmICghaW5fc3RyaW5nICYmIGNoID09IFxcXCJcXFxcclxcXCIgJiYgcGVlaygpID09IFxcXCJcXFxcblxcXCIpIHtcXG4gICAgICAgICAgICAgICAgLy8gdHJlYXQgYSBcXFxcclxcXFxuIHNlcXVlbmNlIGFzIGEgc2luZ2xlIFxcXFxuXFxuICAgICAgICAgICAgICAgICsrUy5wb3M7XFxuICAgICAgICAgICAgICAgIGNoID0gXFxcIlxcXFxuXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmIChjaC5sZW5ndGggPiAxKSB7XFxuICAgICAgICAgICAgICAgICsrUy5wb3M7XFxuICAgICAgICAgICAgICAgICsrUy5jb2w7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICsrUy5jb2w7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gY2g7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGZvcndhcmQoaSkge1xcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIG5leHQoKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gbG9va2luZ19hdChzdHIpIHtcXG4gICAgICAgIHJldHVybiBTLnRleHQuc3Vic3RyKFMucG9zLCBzdHIubGVuZ3RoKSA9PSBzdHI7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGZpbmRfZW9sKCkge1xcbiAgICAgICAgdmFyIHRleHQgPSBTLnRleHQ7XFxuICAgICAgICBmb3IgKHZhciBpID0gUy5wb3MsIG4gPSBTLnRleHQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XFxuICAgICAgICAgICAgdmFyIGNoID0gdGV4dFtpXTtcXG4gICAgICAgICAgICBpZiAoTkVXTElORV9DSEFSUyhjaCkpXFxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIC0xO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBmaW5kKHdoYXQsIHNpZ25hbF9lb2YpIHtcXG4gICAgICAgIHZhciBwb3MgPSBTLnRleHQuaW5kZXhPZih3aGF0LCBTLnBvcyk7XFxuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiBwb3MgPT0gLTEpIHRocm93IEVYX0VPRjtcXG4gICAgICAgIHJldHVybiBwb3M7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHN0YXJ0X3Rva2VuKCkge1xcbiAgICAgICAgUy50b2tsaW5lID0gUy5saW5lO1xcbiAgICAgICAgUy50b2tjb2wgPSBTLmNvbDtcXG4gICAgICAgIFMudG9rcG9zID0gUy5wb3M7XFxuICAgIH07XFxuXFxuICAgIHZhciBwcmV2X3dhc19kb3QgPSBmYWxzZTtcXG4gICAgZnVuY3Rpb24gdG9rZW4odHlwZSwgdmFsdWUsIGlzX2NvbW1lbnQpIHtcXG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9ICgodHlwZSA9PSBcXFwib3BlcmF0b3JcXFwiICYmICFVTkFSWV9QT1NURklYKHZhbHVlKSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcXFwia2V5d29yZFxcXCIgJiYgS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04odmFsdWUpKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFxcXCJwdW5jXFxcIiAmJiBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OKHZhbHVlKSkpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXFxcImFycm93XFxcIik7XFxuICAgICAgICBpZiAodHlwZSA9PSBcXFwicHVuY1xcXCIgJiYgdmFsdWUgPT0gXFxcIi5cXFwiKSB7XFxuICAgICAgICAgICAgcHJldl93YXNfZG90ID0gdHJ1ZTtcXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzX2NvbW1lbnQpIHtcXG4gICAgICAgICAgICBwcmV2X3dhc19kb3QgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciByZXQgPSB7XFxuICAgICAgICAgICAgdHlwZSAgICA6IHR5cGUsXFxuICAgICAgICAgICAgdmFsdWUgICA6IHZhbHVlLFxcbiAgICAgICAgICAgIGxpbmUgICAgOiBTLnRva2xpbmUsXFxuICAgICAgICAgICAgY29sICAgICA6IFMudG9rY29sLFxcbiAgICAgICAgICAgIHBvcyAgICAgOiBTLnRva3BvcyxcXG4gICAgICAgICAgICBlbmRsaW5lIDogUy5saW5lLFxcbiAgICAgICAgICAgIGVuZGNvbCAgOiBTLmNvbCxcXG4gICAgICAgICAgICBlbmRwb3MgIDogUy5wb3MsXFxuICAgICAgICAgICAgbmxiICAgICA6IFMubmV3bGluZV9iZWZvcmUsXFxuICAgICAgICAgICAgZmlsZSAgICA6IGZpbGVuYW1lXFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKC9eKD86bnVtfHN0cmluZ3xyZWdleHApJC9pLnRlc3QodHlwZSkpIHtcXG4gICAgICAgICAgICByZXQucmF3ID0gJFRFWFQuc3Vic3RyaW5nKHJldC5wb3MsIHJldC5lbmRwb3MpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFpc19jb21tZW50KSB7XFxuICAgICAgICAgICAgcmV0LmNvbW1lbnRzX2JlZm9yZSA9IFMuY29tbWVudHNfYmVmb3JlO1xcbiAgICAgICAgICAgIHJldC5jb21tZW50c19hZnRlciA9IFMuY29tbWVudHNfYmVmb3JlID0gW107XFxuICAgICAgICB9XFxuICAgICAgICBTLm5ld2xpbmVfYmVmb3JlID0gZmFsc2U7XFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9Ub2tlbihyZXQpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBza2lwX3doaXRlc3BhY2UoKSB7XFxuICAgICAgICB3aGlsZSAoV0hJVEVTUEFDRV9DSEFSUyhwZWVrKCkpKVxcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gcmVhZF93aGlsZShwcmVkKSB7XFxuICAgICAgICB2YXIgcmV0ID0gXFxcIlxcXCIsIGNoLCBpID0gMDtcXG4gICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICYmIHByZWQoY2gsIGkrKykpXFxuICAgICAgICAgICAgcmV0ICs9IG5leHQoKTtcXG4gICAgICAgIHJldHVybiByZXQ7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHBhcnNlX2Vycm9yKGVycikge1xcbiAgICAgICAganNfZXJyb3IoZXJyLCBmaWxlbmFtZSwgUy50b2tsaW5lLCBTLnRva2NvbCwgUy50b2twb3MpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiByZWFkX251bShwcmVmaXgpIHtcXG4gICAgICAgIHZhciBoYXNfZSA9IGZhbHNlLCBhZnRlcl9lID0gZmFsc2UsIGhhc194ID0gZmFsc2UsIGhhc19kb3QgPSBwcmVmaXggPT0gXFxcIi5cXFwiO1xcbiAgICAgICAgdmFyIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpe1xcbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcXG4gICAgICAgICAgICAgIGNhc2UgOTg6IGNhc2UgNjY6IC8vIGJCXFxuICAgICAgICAgICAgICAgIHJldHVybiAoaGFzX3ggPSB0cnVlKTsgLy8gQ2FuIG9jY3VyIGluIGhleCBzZXF1ZW5jZSwgZG9uJ3QgcmV0dXJuIGZhbHNlIHlldFxcbiAgICAgICAgICAgICAgY2FzZSAxMTE6IGNhc2UgNzk6IC8vIG9PXFxuICAgICAgICAgICAgICBjYXNlIDEyMDogY2FzZSA4ODogLy8geFhcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gZmFsc2UgOiAoaGFzX3ggPSB0cnVlKTtcXG4gICAgICAgICAgICAgIGNhc2UgMTAxOiBjYXNlIDY5OiAvLyBlRVxcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzX3ggPyB0cnVlIDogaGFzX2UgPyBmYWxzZSA6IChoYXNfZSA9IGFmdGVyX2UgPSB0cnVlKTtcXG4gICAgICAgICAgICAgIGNhc2UgNDU6IC8vIC1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2UgfHwgKGkgPT0gMCAmJiAhcHJlZml4KTtcXG4gICAgICAgICAgICAgIGNhc2UgNDM6IC8vICtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2U7XFxuICAgICAgICAgICAgICBjYXNlIChhZnRlcl9lID0gZmFsc2UsIDQ2KTogLy8gLlxcbiAgICAgICAgICAgICAgICByZXR1cm4gKCFoYXNfZG90ICYmICFoYXNfeCAmJiAhaGFzX2UpID8gKGhhc19kb3QgPSB0cnVlKSA6IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gUkVfTlVNX0xJVEVSQUwudGVzdChjaCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGlmIChwcmVmaXgpIG51bSA9IHByZWZpeCArIG51bTtcXG4gICAgICAgIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSAmJiBuZXh0X3Rva2VuLmhhc19kaXJlY3RpdmUoXFxcInVzZSBzdHJpY3RcXFwiKSkge1xcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFxcXCJMZWdhY3kgb2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIobnVtKTtcXG4gICAgICAgIGlmICghaXNOYU4odmFsaWQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFxcXCJudW1cXFwiLCB2YWxpZCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFxcXCJJbnZhbGlkIHN5bnRheDogXFxcIiArIG51bSk7XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHJlYWRfZXNjYXBlZF9jaGFyKGluX3N0cmluZykge1xcbiAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlLCBpbl9zdHJpbmcpO1xcbiAgICAgICAgc3dpdGNoIChjaC5jaGFyQ29kZUF0KDApKSB7XFxuICAgICAgICAgIGNhc2UgMTEwIDogcmV0dXJuIFxcXCJcXFxcblxcXCI7XFxuICAgICAgICAgIGNhc2UgMTE0IDogcmV0dXJuIFxcXCJcXFxcclxcXCI7XFxuICAgICAgICAgIGNhc2UgMTE2IDogcmV0dXJuIFxcXCJcXFxcdFxcXCI7XFxuICAgICAgICAgIGNhc2UgOTggIDogcmV0dXJuIFxcXCJcXFxcYlxcXCI7XFxuICAgICAgICAgIGNhc2UgMTE4IDogcmV0dXJuIFxcXCJcXFxcdTAwMGJcXFwiOyAvLyBcXFxcdlxcbiAgICAgICAgICBjYXNlIDEwMiA6IHJldHVybiBcXFwiXFxcXGZcXFwiO1xcbiAgICAgICAgICBjYXNlIDEyMCA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGhleF9ieXRlcygyKSk7IC8vIFxcXFx4XFxuICAgICAgICAgIGNhc2UgMTE3IDogLy8gXFxcXHVcXG4gICAgICAgICAgICBpZiAocGVlaygpID09IFxcXCJ7XFxcIikge1xcbiAgICAgICAgICAgICAgICBuZXh0KHRydWUpO1xcbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcXFwifVxcXCIpXFxuICAgICAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcXFwiRXhwZWN0aW5nIGhleC1jaGFyYWN0ZXIgYmV0d2VlbiB7fVxcXCIpO1xcbiAgICAgICAgICAgICAgICB3aGlsZSAocGVlaygpID09IFxcXCIwXFxcIikgbmV4dCh0cnVlKTsgLy8gTm8gc2lnbmlmaWNhbmNlXFxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIGxlbmd0aCA9IGZpbmQoXFxcIn1cXFwiLCB0cnVlKSAtIFMucG9zO1xcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCAzMiBiaXQgaW50ZWdlciBvdmVyZmxvdyAoMSA8PCAzMiA9PT0gMSlcXG4gICAgICAgICAgICAgICAgLy8gV2Uga25vdyBmaXJzdCBjaGFyYWN0ZXIgaXNuJ3QgMCBhbmQgdGh1cyBvdXQgb2YgcmFuZ2UgYW55d2F5XFxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiA2IHx8IChyZXN1bHQgPSBoZXhfYnl0ZXMobGVuZ3RoKSkgPiAweDEwRkZGRikge1xcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXFxcIlVuaWNvZGUgcmVmZXJlbmNlIG91dCBvZiBib3VuY2VcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBuZXh0KHRydWUpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbV9jaGFyX2NvZGUocmVzdWx0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDQpKTtcXG4gICAgICAgICAgY2FzZSAxMCAgOiByZXR1cm4gXFxcIlxcXCI7IC8vIG5ld2xpbmVcXG4gICAgICAgICAgY2FzZSAxMyAgOiAgICAgICAgICAgIC8vIFxcXFxyXFxuICAgICAgICAgICAgaWYgKHBlZWsoKSA9PSBcXFwiXFxcXG5cXFwiKSB7IC8vIERPUyBuZXdsaW5lXFxuICAgICAgICAgICAgICAgIG5leHQodHJ1ZSwgaW5fc3RyaW5nKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjaCA+PSBcXFwiMFxcXCIgJiYgY2ggPD0gXFxcIjdcXFwiKVxcbiAgICAgICAgICAgIHJldHVybiByZWFkX29jdGFsX2VzY2FwZV9zZXF1ZW5jZShjaCk7XFxuICAgICAgICByZXR1cm4gY2g7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHJlYWRfb2N0YWxfZXNjYXBlX3NlcXVlbmNlKGNoKSB7XFxuICAgICAgICAvLyBSZWFkXFxuICAgICAgICB2YXIgcCA9IHBlZWsoKTtcXG4gICAgICAgIGlmIChwID49IFxcXCIwXFxcIiAmJiBwIDw9IFxcXCI3XFxcIikge1xcbiAgICAgICAgICAgIGNoICs9IG5leHQodHJ1ZSk7XFxuICAgICAgICAgICAgaWYgKGNoWzBdIDw9IFxcXCIzXFxcIiAmJiAocCA9IHBlZWsoKSkgPj0gXFxcIjBcXFwiICYmIHAgPD0gXFxcIjdcXFwiKVxcbiAgICAgICAgICAgICAgICBjaCArPSBuZXh0KHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gUGFyc2VcXG4gICAgICAgIGlmIChjaCA9PT0gXFxcIjBcXFwiKSByZXR1cm4gXFxcIlxcXFwwXFxcIjtcXG4gICAgICAgIGlmIChjaC5sZW5ndGggPiAwICYmIG5leHRfdG9rZW4uaGFzX2RpcmVjdGl2ZShcXFwidXNlIHN0cmljdFxcXCIpKVxcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFxcXCJMZWdhY3kgb2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcXFwiKTtcXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNoLCA4KSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaGV4X2J5dGVzKG4pIHtcXG4gICAgICAgIHZhciBudW0gPSAwO1xcbiAgICAgICAgZm9yICg7IG4gPiAwOyAtLW4pIHtcXG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBwYXJzZUludChuZXh0KHRydWUpLCAxNik7XFxuICAgICAgICAgICAgaWYgKGlzTmFOKGRpZ2l0KSlcXG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXFxcIkludmFsaWQgaGV4LWNoYXJhY3RlciBwYXR0ZXJuIGluIHN0cmluZ1xcXCIpO1xcbiAgICAgICAgICAgIG51bSA9IChudW0gPDwgNCkgfCBkaWdpdDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBudW07XFxuICAgIH07XFxuXFxuICAgIHZhciByZWFkX3N0cmluZyA9IHdpdGhfZW9mX2Vycm9yKFxcXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XFxcIiwgZnVuY3Rpb24ocXVvdGVfY2hhcil7XFxuICAgICAgICB2YXIgcXVvdGUgPSBuZXh0KCksIHJldCA9IFxcXCJcXFwiO1xcbiAgICAgICAgZm9yICg7Oykge1xcbiAgICAgICAgICAgIHZhciBjaCA9IG5leHQodHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICAgICAgaWYgKGNoID09IFxcXCJcXFxcXFxcXFxcXCIpIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIodHJ1ZSk7XFxuICAgICAgICAgICAgZWxzZSBpZiAoTkVXTElORV9DSEFSUyhjaCkpIHBhcnNlX2Vycm9yKFxcXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XFxcIik7XFxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gcXVvdGUpIGJyZWFrO1xcbiAgICAgICAgICAgIHJldCArPSBjaDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB0b2sgPSB0b2tlbihcXFwic3RyaW5nXFxcIiwgcmV0KTtcXG4gICAgICAgIHRvay5xdW90ZSA9IHF1b3RlX2NoYXI7XFxuICAgICAgICByZXR1cm4gdG9rO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIHJlYWRfdGVtcGxhdGVfY2hhcmFjdGVycyA9IHdpdGhfZW9mX2Vycm9yKFxcXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcXFwiLCBmdW5jdGlvbihiZWdpbil7XFxuICAgICAgICBpZiAoYmVnaW4pIHtcXG4gICAgICAgICAgICBTLnRlbXBsYXRlX2JyYWNlcy5wdXNoKFMuYnJhY2VfY291bnRlcik7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgY29udGVudCA9IFxcXCJcXFwiLCByYXcgPSBcXFwiXFxcIiwgY2gsIHRvaztcXG4gICAgICAgIG5leHQodHJ1ZSwgdHJ1ZSk7XFxuICAgICAgICB3aGlsZSAoKGNoID0gbmV4dCh0cnVlLCB0cnVlKSkgIT0gXFxcImBcXFwiKSB7XFxuICAgICAgICAgICAgaWYgKGNoID09IFxcXCJcXFxcclxcXCIpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PSBcXFwiXFxcXG5cXFwiKSArK1MucG9zO1xcbiAgICAgICAgICAgICAgICBjaCA9IFxcXCJcXFxcblxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiJFxcXCIgJiYgcGVlaygpID09IFxcXCJ7XFxcIikge1xcbiAgICAgICAgICAgICAgICBuZXh0KHRydWUsIHRydWUpO1xcbiAgICAgICAgICAgICAgICBTLmJyYWNlX2NvdW50ZXIrKztcXG4gICAgICAgICAgICAgICAgdG9rID0gdG9rZW4oYmVnaW4gPyBcXFwidGVtcGxhdGVfaGVhZFxcXCIgOiBcXFwidGVtcGxhdGVfc3Vic3RpdHV0aW9uXFxcIiwgY29udGVudCk7XFxuICAgICAgICAgICAgICAgIHRvay5iZWdpbiA9IGJlZ2luO1xcbiAgICAgICAgICAgICAgICB0b2sucmF3ID0gcmF3O1xcbiAgICAgICAgICAgICAgICB0b2suZW5kID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJhdyArPSBjaDtcXG4gICAgICAgICAgICBpZiAoY2ggPT0gXFxcIlxcXFxcXFxcXFxcIikge1xcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gUy5wb3M7XFxuICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2NoYXIoKTtcXG4gICAgICAgICAgICAgICAgcmF3ICs9IFMudGV4dC5zdWJzdHIodG1wLCBTLnBvcyAtIHRtcCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gY2g7XFxuICAgICAgICB9XFxuICAgICAgICBTLnRlbXBsYXRlX2JyYWNlcy5wb3AoKTtcXG4gICAgICAgIHRvayA9IHRva2VuKGJlZ2luID8gXFxcInRlbXBsYXRlX2hlYWRcXFwiIDogXFxcInRlbXBsYXRlX3N1YnN0aXR1dGlvblxcXCIsIGNvbnRlbnQpO1xcbiAgICAgICAgdG9rLmJlZ2luID0gYmVnaW47XFxuICAgICAgICB0b2sucmF3ID0gcmF3O1xcbiAgICAgICAgdG9rLmVuZCA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdG9rO1xcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gc2tpcF9saW5lX2NvbW1lbnQodHlwZSkge1xcbiAgICAgICAgdmFyIHJlZ2V4X2FsbG93ZWQgPSBTLnJlZ2V4X2FsbG93ZWQ7XFxuICAgICAgICB2YXIgaSA9IGZpbmRfZW9sKCksIHJldDtcXG4gICAgICAgIGlmIChpID09IC0xKSB7XFxuICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cihTLnBvcyk7XFxuICAgICAgICAgICAgUy5wb3MgPSBTLnRleHQubGVuZ3RoO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXQgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKTtcXG4gICAgICAgICAgICBTLnBvcyA9IGk7XFxuICAgICAgICB9XFxuICAgICAgICBTLmNvbCA9IFMudG9rY29sICsgKFMucG9zIC0gUy50b2twb3MpO1xcbiAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaCh0b2tlbih0eXBlLCByZXQsIHRydWUpKTtcXG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XFxuICAgICAgICByZXR1cm4gbmV4dF90b2tlbjtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHNraXBfbXVsdGlsaW5lX2NvbW1lbnQgPSB3aXRoX2VvZl9lcnJvcihcXFwiVW50ZXJtaW5hdGVkIG11bHRpbGluZSBjb21tZW50XFxcIiwgZnVuY3Rpb24oKXtcXG4gICAgICAgIHZhciByZWdleF9hbGxvd2VkID0gUy5yZWdleF9hbGxvd2VkO1xcbiAgICAgICAgdmFyIGkgPSBmaW5kKFxcXCIqL1xcXCIsIHRydWUpO1xcbiAgICAgICAgdmFyIHRleHQgPSBTLnRleHQuc3Vic3RyaW5nKFMucG9zLCBpKS5yZXBsYWNlKC9cXFxcclxcXFxufFxcXFxyfFxcXFx1MjAyOHxcXFxcdTIwMjkvZywgJ1xcXFxuJyk7XFxuICAgICAgICAvLyB1cGRhdGUgc3RyZWFtIHBvc2l0aW9uXFxuICAgICAgICBmb3J3YXJkKGdldF9mdWxsX2NoYXJfbGVuZ3RoKHRleHQpIC8qIHRleHQgbGVuZ3RoIGRvZXNuJ3QgY291bnQgXFxcXHJcXFxcbiBhcyAyIGNoYXIgd2hpbGUgUy5wb3MgLSBpIGRvZXMgKi8gKyAyKTtcXG4gICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2godG9rZW4oXFxcImNvbW1lbnQyXFxcIiwgdGV4dCwgdHJ1ZSkpO1xcbiAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgdGV4dC5pbmRleE9mKFxcXCJcXFxcblxcXCIpID49IDA7XFxuICAgICAgICBTLnJlZ2V4X2FsbG93ZWQgPSByZWdleF9hbGxvd2VkO1xcbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW47XFxuICAgIH0pO1xcblxcbiAgICB2YXIgcmVhZF9uYW1lID0gd2l0aF9lb2ZfZXJyb3IoXFxcIlVudGVybWluYXRlZCBpZGVudGlmaWVyIG5hbWVcXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBuYW1lID0gXFxcIlxcXCIsIGNoLCBlc2NhcGVkID0gZmFsc2UsIGhleDtcXG4gICAgICAgIHZhciByZWFkX2VzY2FwZWRfaWRlbnRpZmllcl9jaGFyID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIGlmIChwZWVrKCkgIT09IFxcXCJ1XFxcIikge1xcbiAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcXFwiRXhwZWN0aW5nIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSAtLSB1WFhYWCBvciB1e1hYWFh9XFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiByZWFkX2VzY2FwZWRfY2hhcigpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gUmVhZCBmaXJzdCBjaGFyYWN0ZXIgKElEX1N0YXJ0KVxcbiAgICAgICAgaWYgKChuYW1lID0gcGVlaygpKSA9PT0gXFxcIlxcXFxcXFxcXFxcIikge1xcbiAgICAgICAgICAgIG5hbWUgPSByZWFkX2VzY2FwZWRfaWRlbnRpZmllcl9jaGFyKCk7XFxuICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX3N0YXJ0KG5hbWUpKSB7XFxuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFxcXCJGaXJzdCBpZGVudGlmaWVyIGNoYXIgaXMgYW4gaW52YWxpZCBpZGVudGlmaWVyIGNoYXJcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGlzX2lkZW50aWZpZXJfc3RhcnQobmFtZSkpe1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gUmVhZCBJRF9Db250aW51ZVxcbiAgICAgICAgd2hpbGUgKChjaCA9IHBlZWsoKSkgIT0gbnVsbCkge1xcbiAgICAgICAgICAgIGlmICgoY2ggPSBwZWVrKCkpID09PSBcXFwiXFxcXFxcXFxcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2lkZW50aWZpZXJfY2hhcigpO1xcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFxcXCJJbnZhbGlkIGVzY2FwZWQgaWRlbnRpZmllciBjaGFyXFxcIik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbmFtZSArPSBjaDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChSRVNFUlZFRF9XT1JEUyhuYW1lKSAmJiBlc2NhcGVkKSB7XFxuICAgICAgICAgICAgcGFyc2VfZXJyb3IoXFxcIkVzY2FwZWQgY2hhcmFjdGVycyBhcmUgbm90IGFsbG93ZWQgaW4ga2V5d29yZHNcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBuYW1lO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIHJlYWRfcmVnZXhwID0gd2l0aF9lb2ZfZXJyb3IoXFxcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cXFwiLCBmdW5jdGlvbihzb3VyY2UpIHtcXG4gICAgICAgIHZhciBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlLCBjaCwgaW5fY2xhc3MgPSBmYWxzZTtcXG4gICAgICAgIHdoaWxlICgoY2ggPSBuZXh0KHRydWUpKSkgaWYgKE5FV0xJTkVfQ0hBUlMoY2gpKSB7XFxuICAgICAgICAgICAgcGFyc2VfZXJyb3IoXFxcIlVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yXFxcIik7XFxuICAgICAgICB9IGVsc2UgaWYgKHByZXZfYmFja3NsYXNoKSB7XFxuICAgICAgICAgICAgc291cmNlICs9IFxcXCJcXFxcXFxcXFxcXCIgKyBjaDtcXG4gICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiW1xcXCIpIHtcXG4gICAgICAgICAgICBpbl9jbGFzcyA9IHRydWU7XFxuICAgICAgICAgICAgc291cmNlICs9IGNoO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiXVxcXCIgJiYgaW5fY2xhc3MpIHtcXG4gICAgICAgICAgICBpbl9jbGFzcyA9IGZhbHNlO1xcbiAgICAgICAgICAgIHNvdXJjZSArPSBjaDtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIi9cXFwiICYmICFpbl9jbGFzcykge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiXFxcXFxcXFxcXFwiKSB7XFxuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSB0cnVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzb3VyY2UgKz0gY2g7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbW9kcyA9IHJlYWRfbmFtZSgpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChzb3VyY2UsIG1vZHMpO1xcbiAgICAgICAgICAgIHJlZ2V4cC5yYXdfc291cmNlID0gc291cmNlO1xcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihcXFwicmVnZXhwXFxcIiwgcmVnZXhwKTtcXG4gICAgICAgIH0gY2F0Y2goZSkge1xcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKGUubWVzc2FnZSk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiByZWFkX29wZXJhdG9yKHByZWZpeCkge1xcbiAgICAgICAgZnVuY3Rpb24gZ3JvdyhvcCkge1xcbiAgICAgICAgICAgIGlmICghcGVlaygpKSByZXR1cm4gb3A7XFxuICAgICAgICAgICAgdmFyIGJpZ2dlciA9IG9wICsgcGVlaygpO1xcbiAgICAgICAgICAgIGlmIChPUEVSQVRPUlMoYmlnZ2VyKSkge1xcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBncm93KGJpZ2dlcik7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gdG9rZW4oXFxcIm9wZXJhdG9yXFxcIiwgZ3JvdyhwcmVmaXggfHwgbmV4dCgpKSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zbGFzaCgpIHtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICAgIHN3aXRjaCAocGVlaygpKSB7XFxuICAgICAgICAgIGNhc2UgXFxcIi9cXFwiOlxcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICByZXR1cm4gc2tpcF9saW5lX2NvbW1lbnQoXFxcImNvbW1lbnQxXFxcIik7XFxuICAgICAgICAgIGNhc2UgXFxcIipcXFwiOlxcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICByZXR1cm4gc2tpcF9tdWx0aWxpbmVfY29tbWVudCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFMucmVnZXhfYWxsb3dlZCA/IHJlYWRfcmVnZXhwKFxcXCJcXFwiKSA6IHJlYWRfb3BlcmF0b3IoXFxcIi9cXFwiKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gaGFuZGxlX2VxX3NpZ24oKSB7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgICBpZiAocGVlaygpID09PSBcXFwiPlxcXCIpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFxcXCJhcnJvd1xcXCIsIFxcXCI9PlxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gcmVhZF9vcGVyYXRvcihcXFwiPVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBoYW5kbGVfZG90KCkge1xcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgaWYgKGlzX2RpZ2l0KHBlZWsoKS5jaGFyQ29kZUF0KDApKSkge1xcbiAgICAgICAgICAgIHJldHVybiByZWFkX251bShcXFwiLlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBlZWsoKSA9PT0gXFxcIi5cXFwiKSB7XFxuICAgICAgICAgICAgbmV4dCgpOyAgLy8gQ29uc3VtZSBzZWNvbmQgZG90XFxuICAgICAgICAgICAgbmV4dCgpOyAgLy8gQ29uc3VtZSB0aGlyZCBkb3RcXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4oXFxcImV4cGFuZFxcXCIsIFxcXCIuLi5cXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0b2tlbihcXFwicHVuY1xcXCIsIFxcXCIuXFxcIik7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHJlYWRfd29yZCgpIHtcXG4gICAgICAgIHZhciB3b3JkID0gcmVhZF9uYW1lKCk7XFxuICAgICAgICBpZiAocHJldl93YXNfZG90KSByZXR1cm4gdG9rZW4oXFxcIm5hbWVcXFwiLCB3b3JkKTtcXG4gICAgICAgIHJldHVybiBLRVlXT1JEU19BVE9NKHdvcmQpID8gdG9rZW4oXFxcImF0b21cXFwiLCB3b3JkKVxcbiAgICAgICAgICAgIDogIUtFWVdPUkRTKHdvcmQpID8gdG9rZW4oXFxcIm5hbWVcXFwiLCB3b3JkKVxcbiAgICAgICAgICAgIDogT1BFUkFUT1JTKHdvcmQpID8gdG9rZW4oXFxcIm9wZXJhdG9yXFxcIiwgd29yZClcXG4gICAgICAgICAgICA6IHRva2VuKFxcXCJrZXl3b3JkXFxcIiwgd29yZCk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHdpdGhfZW9mX2Vycm9yKGVvZl9lcnJvciwgY29udCkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udCh4KTtcXG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XFxuICAgICAgICAgICAgICAgIGlmIChleCA9PT0gRVhfRU9GKSBwYXJzZV9lcnJvcihlb2ZfZXJyb3IpO1xcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IGV4O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIG5leHRfdG9rZW4oZm9yY2VfcmVnZXhwKSB7XFxuICAgICAgICBpZiAoZm9yY2VfcmVnZXhwICE9IG51bGwpXFxuICAgICAgICAgICAgcmV0dXJuIHJlYWRfcmVnZXhwKGZvcmNlX3JlZ2V4cCk7XFxuICAgICAgICBpZiAoc2hlYmFuZyAmJiBTLnBvcyA9PSAwICYmIGxvb2tpbmdfYXQoXFxcIiMhXFxcIikpIHtcXG4gICAgICAgICAgICBzdGFydF90b2tlbigpO1xcbiAgICAgICAgICAgIGZvcndhcmQoMik7XFxuICAgICAgICAgICAgc2tpcF9saW5lX2NvbW1lbnQoXFxcImNvbW1lbnQ1XFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKDs7KSB7XFxuICAgICAgICAgICAgc2tpcF93aGl0ZXNwYWNlKCk7XFxuICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcXG4gICAgICAgICAgICBpZiAoaHRtbDVfY29tbWVudHMpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tpbmdfYXQoXFxcIjwhLS1cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZCg0KTtcXG4gICAgICAgICAgICAgICAgICAgIHNraXBfbGluZV9jb21tZW50KFxcXCJjb21tZW50M1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tpbmdfYXQoXFxcIi0tPlxcXCIpICYmIFMubmV3bGluZV9iZWZvcmUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmQoMyk7XFxuICAgICAgICAgICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcXFwiY29tbWVudDRcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBjaCA9IHBlZWsoKTtcXG4gICAgICAgICAgICBpZiAoIWNoKSByZXR1cm4gdG9rZW4oXFxcImVvZlxcXCIpO1xcbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMzQ6IGNhc2UgMzk6IHJldHVybiByZWFkX3N0cmluZyhjaCk7XFxuICAgICAgICAgICAgICBjYXNlIDQ2OiByZXR1cm4gaGFuZGxlX2RvdCgpO1xcbiAgICAgICAgICAgICAgY2FzZSA0Nzoge1xcbiAgICAgICAgICAgICAgICAgIHZhciB0b2sgPSBoYW5kbGVfc2xhc2goKTtcXG4gICAgICAgICAgICAgICAgICBpZiAodG9rID09PSBuZXh0X3Rva2VuKSBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgY2FzZSA2MTogcmV0dXJuIGhhbmRsZV9lcV9zaWduKCk7XFxuICAgICAgICAgICAgICBjYXNlIDk2OiByZXR1cm4gcmVhZF90ZW1wbGF0ZV9jaGFyYWN0ZXJzKHRydWUpO1xcbiAgICAgICAgICAgICAgY2FzZSAxMjM6XFxuICAgICAgICAgICAgICAgIFMuYnJhY2VfY291bnRlcisrO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgIGNhc2UgMTI1OlxcbiAgICAgICAgICAgICAgICBTLmJyYWNlX2NvdW50ZXItLTtcXG4gICAgICAgICAgICAgICAgaWYgKFMudGVtcGxhdGVfYnJhY2VzLmxlbmd0aCA+IDBcXG4gICAgICAgICAgICAgICAgICAgICYmIFMudGVtcGxhdGVfYnJhY2VzW1MudGVtcGxhdGVfYnJhY2VzLmxlbmd0aCAtIDFdID09PSBTLmJyYWNlX2NvdW50ZXIpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZF90ZW1wbGF0ZV9jaGFyYWN0ZXJzKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChpc19kaWdpdChjb2RlKSkgcmV0dXJuIHJlYWRfbnVtKCk7XFxuICAgICAgICAgICAgaWYgKFBVTkNfQ0hBUlMoY2gpKSByZXR1cm4gdG9rZW4oXFxcInB1bmNcXFwiLCBuZXh0KCkpO1xcbiAgICAgICAgICAgIGlmIChPUEVSQVRPUl9DSEFSUyhjaCkpIHJldHVybiByZWFkX29wZXJhdG9yKCk7XFxuICAgICAgICAgICAgaWYgKGNvZGUgPT0gOTIgfHwgaXNfaWRlbnRpZmllcl9zdGFydChjaCkpIHJldHVybiByZWFkX3dvcmQoKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIHBhcnNlX2Vycm9yKFxcXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXFxcIiArIGNoICsgXFxcIidcXFwiKTtcXG4gICAgfTtcXG5cXG4gICAgbmV4dF90b2tlbi5uZXh0ID0gbmV4dDtcXG4gICAgbmV4dF90b2tlbi5wZWVrID0gcGVlaztcXG5cXG4gICAgbmV4dF90b2tlbi5jb250ZXh0ID0gZnVuY3Rpb24obmMpIHtcXG4gICAgICAgIGlmIChuYykgUyA9IG5jO1xcbiAgICAgICAgcmV0dXJuIFM7XFxuICAgIH07XFxuXFxuICAgIG5leHRfdG9rZW4uYWRkX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xcbiAgICAgICAgUy5kaXJlY3RpdmVfc3RhY2tbUy5kaXJlY3RpdmVfc3RhY2subGVuZ3RoIC0gMV0ucHVzaChkaXJlY3RpdmUpO1xcblxcbiAgICAgICAgaWYgKFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBTLmRpcmVjdGl2ZXNbZGlyZWN0aXZlXSA9IDE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdKys7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgbmV4dF90b2tlbi5wdXNoX2RpcmVjdGl2ZXNfc3RhY2sgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIFMuZGlyZWN0aXZlX3N0YWNrLnB1c2goW10pO1xcbiAgICB9XFxuXFxuICAgIG5leHRfdG9rZW4ucG9wX2RpcmVjdGl2ZXNfc3RhY2sgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gUy5kaXJlY3RpdmVfc3RhY2tbUy5kaXJlY3RpdmVfc3RhY2subGVuZ3RoIC0gMV07XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBTLmRpcmVjdGl2ZXNbZGlyZWN0aXZlc1tpXV0tLTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFMuZGlyZWN0aXZlX3N0YWNrLnBvcCgpO1xcbiAgICB9XFxuXFxuICAgIG5leHRfdG9rZW4uaGFzX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xcbiAgICAgICAgcmV0dXJuIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdID4gMDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbmV4dF90b2tlbjtcXG5cXG59O1xcblxcbi8qIC0tLS0tWyBQYXJzZXIgKGNvbnN0YW50cykgXS0tLS0tICovXFxuXFxudmFyIFVOQVJZX1BSRUZJWCA9IG1ha2VQcmVkaWNhdGUoW1xcbiAgICBcXFwidHlwZW9mXFxcIixcXG4gICAgXFxcInZvaWRcXFwiLFxcbiAgICBcXFwiZGVsZXRlXFxcIixcXG4gICAgXFxcIi0tXFxcIixcXG4gICAgXFxcIisrXFxcIixcXG4gICAgXFxcIiFcXFwiLFxcbiAgICBcXFwiflxcXCIsXFxuICAgIFxcXCItXFxcIixcXG4gICAgXFxcIitcXFwiXFxuXSk7XFxuXFxudmFyIFVOQVJZX1BPU1RGSVggPSBtYWtlUHJlZGljYXRlKFsgXFxcIi0tXFxcIiwgXFxcIisrXFxcIiBdKTtcXG5cXG52YXIgQVNTSUdOTUVOVCA9IG1ha2VQcmVkaWNhdGUoWyBcXFwiPVxcXCIsIFxcXCIrPVxcXCIsIFxcXCItPVxcXCIsIFxcXCIvPVxcXCIsIFxcXCIqPVxcXCIsIFxcXCIqKj1cXFwiLCBcXFwiJT1cXFwiLCBcXFwiPj49XFxcIiwgXFxcIjw8PVxcXCIsIFxcXCI+Pj49XFxcIiwgXFxcInw9XFxcIiwgXFxcIl49XFxcIiwgXFxcIiY9XFxcIiBdKTtcXG5cXG52YXIgUFJFQ0VERU5DRSA9IChmdW5jdGlvbihhLCByZXQpe1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBiID0gYVtpXTtcXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7ICsraikge1xcbiAgICAgICAgICAgIHJldFtiW2pdXSA9IGkgKyAxO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxufSkoXFxuICAgIFtcXG4gICAgICAgIFtcXFwifHxcXFwiXSxcXG4gICAgICAgIFtcXFwiJiZcXFwiXSxcXG4gICAgICAgIFtcXFwifFxcXCJdLFxcbiAgICAgICAgW1xcXCJeXFxcIl0sXFxuICAgICAgICBbXFxcIiZcXFwiXSxcXG4gICAgICAgIFtcXFwiPT1cXFwiLCBcXFwiPT09XFxcIiwgXFxcIiE9XFxcIiwgXFxcIiE9PVxcXCJdLFxcbiAgICAgICAgW1xcXCI8XFxcIiwgXFxcIj5cXFwiLCBcXFwiPD1cXFwiLCBcXFwiPj1cXFwiLCBcXFwiaW5cXFwiLCBcXFwiaW5zdGFuY2VvZlxcXCJdLFxcbiAgICAgICAgW1xcXCI+PlxcXCIsIFxcXCI8PFxcXCIsIFxcXCI+Pj5cXFwiXSxcXG4gICAgICAgIFtcXFwiK1xcXCIsIFxcXCItXFxcIl0sXFxuICAgICAgICBbXFxcIipcXFwiLCBcXFwiL1xcXCIsIFxcXCIlXFxcIl0sXFxuICAgICAgICBbXFxcIioqXFxcIl1cXG4gICAgXSxcXG4gICAge31cXG4pO1xcblxcbnZhciBBVE9NSUNfU1RBUlRfVE9LRU4gPSBtYWtlUHJlZGljYXRlKFsgXFxcImF0b21cXFwiLCBcXFwibnVtXFxcIiwgXFxcInN0cmluZ1xcXCIsIFxcXCJyZWdleHBcXFwiLCBcXFwibmFtZVxcXCIgXSk7XFxuXFxuLyogLS0tLS1bIFBhcnNlciBdLS0tLS0gKi9cXG5cXG5mdW5jdGlvbiBwYXJzZSgkVEVYVCwgb3B0aW9ucykge1xcblxcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xcbiAgICAgICAgYmFyZV9yZXR1cm5zICAgOiBmYWxzZSxcXG4gICAgICAgIGVjbWEgICAgICAgICAgIDogOCxcXG4gICAgICAgIGV4cHJlc3Npb24gICAgIDogZmFsc2UsXFxuICAgICAgICBmaWxlbmFtZSAgICAgICA6IG51bGwsXFxuICAgICAgICBodG1sNV9jb21tZW50cyA6IHRydWUsXFxuICAgICAgICBzaGViYW5nICAgICAgICA6IHRydWUsXFxuICAgICAgICBzdHJpY3QgICAgICAgICA6IGZhbHNlLFxcbiAgICAgICAgdG9wbGV2ZWwgICAgICAgOiBudWxsLFxcbiAgICB9LCB0cnVlKTtcXG5cXG4gICAgdmFyIFMgPSB7XFxuICAgICAgICBpbnB1dCAgICAgICAgIDogKHR5cGVvZiAkVEVYVCA9PSBcXFwic3RyaW5nXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICA/IHRva2VuaXplcigkVEVYVCwgb3B0aW9ucy5maWxlbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5odG1sNV9jb21tZW50cywgb3B0aW9ucy5zaGViYW5nKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICA6ICRURVhUKSxcXG4gICAgICAgIHRva2VuICAgICAgICAgOiBudWxsLFxcbiAgICAgICAgcHJldiAgICAgICAgICA6IG51bGwsXFxuICAgICAgICBwZWVrZWQgICAgICAgIDogbnVsbCxcXG4gICAgICAgIGluX2Z1bmN0aW9uICAgOiAwLFxcbiAgICAgICAgaW5fYXN5bmMgICAgICA6IC0xLFxcbiAgICAgICAgaW5fZ2VuZXJhdG9yICA6IC0xLFxcbiAgICAgICAgaW5fZGlyZWN0aXZlcyA6IHRydWUsXFxuICAgICAgICBpbl9sb29wICAgICAgIDogMCxcXG4gICAgICAgIGxhYmVscyAgICAgICAgOiBbXVxcbiAgICB9O1xcblxcbiAgICBTLnRva2VuID0gbmV4dCgpO1xcblxcbiAgICBmdW5jdGlvbiBpcyh0eXBlLCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGlzX3Rva2VuKFMudG9rZW4sIHR5cGUsIHZhbHVlKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gcGVlaygpIHsgcmV0dXJuIFMucGVla2VkIHx8IChTLnBlZWtlZCA9IFMuaW5wdXQoKSk7IH07XFxuXFxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgICBTLnByZXYgPSBTLnRva2VuO1xcbiAgICAgICAgaWYgKFMucGVla2VkKSB7XFxuICAgICAgICAgICAgUy50b2tlbiA9IFMucGVla2VkO1xcbiAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgUy50b2tlbiA9IFMuaW5wdXQoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoXFxuICAgICAgICAgICAgUy50b2tlbi50eXBlID09IFxcXCJzdHJpbmdcXFwiIHx8IGlzKFxcXCJwdW5jXFxcIiwgXFxcIjtcXFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHJldHVybiBTLnRva2VuO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBwcmV2KCkge1xcbiAgICAgICAgcmV0dXJuIFMucHJldjtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gY3JvYWsobXNnLCBsaW5lLCBjb2wsIHBvcykge1xcbiAgICAgICAgdmFyIGN0eCA9IFMuaW5wdXQuY29udGV4dCgpO1xcbiAgICAgICAganNfZXJyb3IobXNnLFxcbiAgICAgICAgICAgICAgICAgY3R4LmZpbGVuYW1lLFxcbiAgICAgICAgICAgICAgICAgbGluZSAhPSBudWxsID8gbGluZSA6IGN0eC50b2tsaW5lLFxcbiAgICAgICAgICAgICAgICAgY29sICE9IG51bGwgPyBjb2wgOiBjdHgudG9rY29sLFxcbiAgICAgICAgICAgICAgICAgcG9zICE9IG51bGwgPyBwb3MgOiBjdHgudG9rcG9zKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gdG9rZW5fZXJyb3IodG9rZW4sIG1zZykge1xcbiAgICAgICAgY3JvYWsobXNnLCB0b2tlbi5saW5lLCB0b2tlbi5jb2wpO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKHRva2VuKSB7XFxuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcXG4gICAgICAgICAgICB0b2tlbiA9IFMudG9rZW47XFxuICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXFxcIlVuZXhwZWN0ZWQgdG9rZW46IFxcXCIgKyB0b2tlbi50eXBlICsgXFxcIiAoXFxcIiArIHRva2VuLnZhbHVlICsgXFxcIilcXFwiKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gZXhwZWN0X3Rva2VuKHR5cGUsIHZhbCkge1xcbiAgICAgICAgaWYgKGlzKHR5cGUsIHZhbCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdG9rZW5fZXJyb3IoUy50b2tlbiwgXFxcIlVuZXhwZWN0ZWQgdG9rZW4gXFxcIiArIFMudG9rZW4udHlwZSArIFxcXCIgwqtcXFwiICsgUy50b2tlbi52YWx1ZSArIFxcXCLCu1xcXCIgKyBcXFwiLCBleHBlY3RlZCBcXFwiICsgdHlwZSArIFxcXCIgwqtcXFwiICsgdmFsICsgXFxcIsK7XFxcIik7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7IHJldHVybiBleHBlY3RfdG9rZW4oXFxcInB1bmNcXFwiLCBwdW5jKTsgfTtcXG5cXG4gICAgZnVuY3Rpb24gaGFzX25ld2xpbmVfYmVmb3JlKHRva2VuKSB7XFxuICAgICAgICByZXR1cm4gdG9rZW4ubmxiIHx8ICFhbGwodG9rZW4uY29tbWVudHNfYmVmb3JlLCBmdW5jdGlvbihjb21tZW50KSB7XFxuICAgICAgICAgICAgcmV0dXJuICFjb21tZW50Lm5sYjtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkge1xcbiAgICAgICAgcmV0dXJuICFvcHRpb25zLnN0cmljdFxcbiAgICAgICAgICAgICYmIChpcyhcXFwiZW9mXFxcIikgfHwgaXMoXFxcInB1bmNcXFwiLCBcXFwifVxcXCIpIHx8IGhhc19uZXdsaW5lX2JlZm9yZShTLnRva2VuKSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGlzX2luX2dlbmVyYXRvcigpIHtcXG4gICAgICAgIHJldHVybiBTLmluX2dlbmVyYXRvciA9PT0gUy5pbl9mdW5jdGlvbjtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc19pbl9hc3luYygpIHtcXG4gICAgICAgIHJldHVybiBTLmluX2FzeW5jID09PSBTLmluX2Z1bmN0aW9uO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNlbWljb2xvbihvcHRpb25hbCkge1xcbiAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIjtcXFwiKSkgbmV4dCgpO1xcbiAgICAgICAgZWxzZSBpZiAoIW9wdGlvbmFsICYmICFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2lzZWQoKSB7XFxuICAgICAgICBleHBlY3QoXFxcIihcXFwiKTtcXG4gICAgICAgIHZhciBleHAgPSBleHByZXNzaW9uKHRydWUpO1xcbiAgICAgICAgZXhwZWN0KFxcXCIpXFxcIik7XFxuICAgICAgICByZXR1cm4gZXhwO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBlbWJlZF90b2tlbnMocGFyc2VyKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcXG4gICAgICAgICAgICB2YXIgZXhwciA9IHBhcnNlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XFxuICAgICAgICAgICAgZXhwci5zdGFydCA9IHN0YXJ0O1xcbiAgICAgICAgICAgIGV4cHIuZW5kID0gZW5kO1xcbiAgICAgICAgICAgIHJldHVybiBleHByO1xcbiAgICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gaGFuZGxlX3JlZ2V4cCgpIHtcXG4gICAgICAgIGlmIChpcyhcXFwib3BlcmF0b3JcXFwiLCBcXFwiL1xcXCIpIHx8IGlzKFxcXCJvcGVyYXRvclxcXCIsIFxcXCIvPVxcXCIpKSB7XFxuICAgICAgICAgICAgUy5wZWVrZWQgPSBudWxsO1xcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KFMudG9rZW4udmFsdWUuc3Vic3RyKDEpKTsgLy8gZm9yY2UgcmVnZXhwXFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIHZhciBzdGF0ZW1lbnQgPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24oaXNfZXhwb3J0X2RlZmF1bHQpIHtcXG4gICAgICAgIGhhbmRsZV9yZWdleHAoKTtcXG4gICAgICAgIHN3aXRjaCAoUy50b2tlbi50eXBlKSB7XFxuICAgICAgICAgIGNhc2UgXFxcInN0cmluZ1xcXCI6XFxuICAgICAgICAgICAgaWYgKFMuaW5fZGlyZWN0aXZlcykge1xcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XFxuICAgICAgICAgICAgICAgIGlmIChTLnRva2VuLnJhdy5pbmRleE9mKFxcXCJcXFxcXFxcXFxcXCIpID09IC0xXFxuICAgICAgICAgICAgICAgICAgICAmJiAoaXNfdG9rZW4odG9rZW4sIFxcXCJwdW5jXFxcIiwgXFxcIjtcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGlzX3Rva2VuKHRva2VuLCBcXFwicHVuY1xcXCIsIFxcXCJ9XFxcIilcXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBoYXNfbmV3bGluZV9iZWZvcmUodG9rZW4pXFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgaXNfdG9rZW4odG9rZW4sIFxcXCJlb2ZcXFwiKSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIFMuaW5wdXQuYWRkX2RpcmVjdGl2ZShTLnRva2VuLnZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBkaXIgPSBTLmluX2RpcmVjdGl2ZXMsIHN0YXQgPSBzaW1wbGVfc3RhdGVtZW50KCk7XFxuICAgICAgICAgICAgcmV0dXJuIGRpciA/IG5ldyBBU1RfRGlyZWN0aXZlKHN0YXQuYm9keSkgOiBzdGF0O1xcbiAgICAgICAgICBjYXNlIFxcXCJ0ZW1wbGF0ZV9oZWFkXFxcIjpcXG4gICAgICAgICAgY2FzZSBcXFwibnVtXFxcIjpcXG4gICAgICAgICAgY2FzZSBcXFwicmVnZXhwXFxcIjpcXG4gICAgICAgICAgY2FzZSBcXFwib3BlcmF0b3JcXFwiOlxcbiAgICAgICAgICBjYXNlIFxcXCJhdG9tXFxcIjpcXG4gICAgICAgICAgICByZXR1cm4gc2ltcGxlX3N0YXRlbWVudCgpO1xcblxcbiAgICAgICAgICBjYXNlIFxcXCJuYW1lXFxcIjpcXG4gICAgICAgICAgICBpZiAoUy50b2tlbi52YWx1ZSA9PSBcXFwiYXN5bmNcXFwiICYmIGlzX3Rva2VuKHBlZWsoKSwgXFxcImtleXdvcmRcXFwiLCBcXFwiZnVuY3Rpb25cXFwiKSkge1xcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uXyhBU1RfRGVmdW4sIGZhbHNlLCB0cnVlLCBpc19leHBvcnRfZGVmYXVsdCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChTLnRva2VuLnZhbHVlID09IFxcXCJpbXBvcnRcXFwiICYmICFpc190b2tlbihwZWVrKCksIFxcXCJwdW5jXFxcIiwgXFxcIihcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gaW1wb3J0XygpO1xcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBpc190b2tlbihwZWVrKCksIFxcXCJwdW5jXFxcIiwgXFxcIjpcXFwiKVxcbiAgICAgICAgICAgICAgICA/IGxhYmVsZWRfc3RhdGVtZW50KClcXG4gICAgICAgICAgICAgICAgOiBzaW1wbGVfc3RhdGVtZW50KCk7XFxuXFxuICAgICAgICAgIGNhc2UgXFxcInB1bmNcXFwiOlxcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xcbiAgICAgICAgICAgICAgY2FzZSBcXFwie1xcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Jsb2NrU3RhdGVtZW50KHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgIDogYmxvY2tfKCksXFxuICAgICAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIGNhc2UgXFxcIltcXFwiOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiKFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XFxuICAgICAgICAgICAgICBjYXNlIFxcXCI7XFxcIjpcXG4gICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRW1wdHlTdGF0ZW1lbnQoKTtcXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNhc2UgXFxcImtleXdvcmRcXFwiOlxcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xcbiAgICAgICAgICAgICAgY2FzZSBcXFwiYnJlYWtcXFwiOlxcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBicmVha19jb250KEFTVF9CcmVhayk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJjb250aW51ZVxcXCI6XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0NvbnRpbnVlKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcImRlYnVnZ2VyXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVidWdnZXIoKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcImRvXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGluX2xvb3Aoc3RhdGVtZW50KTtcXG4gICAgICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFxcXCJrZXl3b3JkXFxcIiwgXFxcIndoaWxlXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBwYXJlbnRoZXNpc2VkKCk7XFxuICAgICAgICAgICAgICAgIHNlbWljb2xvbih0cnVlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRG8oe1xcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgIDogYm9keSxcXG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA6IGNvbmRpdGlvblxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcIndoaWxlXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9XaGlsZSh7XFxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gOiBwYXJlbnRoZXNpc2VkKCksXFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKHN0YXRlbWVudClcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJmb3JcXFwiOlxcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JfKCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJjbGFzc1xcXCI6XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzXyhBU1RfRGVmQ2xhc3MpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZnVuY3Rpb25cXFwiOlxcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl8oQVNUX0RlZnVuLCBmYWxzZSwgZmFsc2UsIGlzX2V4cG9ydF9kZWZhdWx0KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcImlmXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gaWZfKCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJyZXR1cm5cXFwiOlxcbiAgICAgICAgICAgICAgICBpZiAoUy5pbl9mdW5jdGlvbiA9PSAwICYmICFvcHRpb25zLmJhcmVfcmV0dXJucylcXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFxcXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXFxcIik7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIjtcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cHJlc3Npb24odHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZXR1cm4oe1xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwic3dpdGNoXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Td2l0Y2goe1xcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHBhcmVudGhlc2lzZWQoKSxcXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBpbl9sb29wKHN3aXRjaF9ib2R5XylcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJ0aHJvd1xcXCI6XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgaWYgKGhhc19uZXdsaW5lX2JlZm9yZShTLnRva2VuKSlcXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFxcXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgJ3Rocm93J1xcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBleHByZXNzaW9uKHRydWUpO1xcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGhyb3coe1xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwidHJ5XFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5XygpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwidmFyXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZhcl8oKTtcXG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwibGV0XFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxldF8oKTtcXG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiY29uc3RcXFwiOlxcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gY29uc3RfKCk7XFxuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcIndpdGhcXFwiOlxcbiAgICAgICAgICAgICAgICBpZiAoUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFxcXCJ1c2Ugc3RyaWN0XFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFxcXCJTdHJpY3QgbW9kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudFxcXCIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfV2l0aCh7XFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogcGFyZW50aGVzaXNlZCgpLFxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IHN0YXRlbWVudCgpXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZXhwb3J0XFxcIjpcXG4gICAgICAgICAgICAgICAgaWYgKCFpc190b2tlbihwZWVrKCksIFxcXCJwdW5jXFxcIiwgXFxcIihcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydF8oKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGxhYmVsZWRfc3RhdGVtZW50KCkge1xcbiAgICAgICAgdmFyIGxhYmVsID0gYXNfc3ltYm9sKEFTVF9MYWJlbCk7XFxuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gXFxcImF3YWl0XFxcIiAmJiBpc19pbl9hc3luYygpKSB7XFxuICAgICAgICAgICAgdG9rZW5fZXJyb3IoUy5wcmV2LCBcXFwiYXdhaXQgY2Fubm90IGJlIHVzZWQgYXMgbGFiZWwgaW5zaWRlIGFzeW5jIGZ1bmN0aW9uXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZmluZF9pZihmdW5jdGlvbihsKXsgcmV0dXJuIGwubmFtZSA9PSBsYWJlbC5uYW1lIH0sIFMubGFiZWxzKSkge1xcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyLCAxMi4xMjogQW4gRUNNQVNjcmlwdCBwcm9ncmFtIGlzIGNvbnNpZGVyZWRcXG4gICAgICAgICAgICAvLyBzeW50YWN0aWNhbGx5IGluY29ycmVjdCBpZiBpdCBjb250YWlucyBhXFxuICAgICAgICAgICAgLy8gTGFiZWxsZWRTdGF0ZW1lbnQgdGhhdCBpcyBlbmNsb3NlZCBieSBhXFxuICAgICAgICAgICAgLy8gTGFiZWxsZWRTdGF0ZW1lbnQgd2l0aCB0aGUgc2FtZSBJZGVudGlmaWVyIGFzIGxhYmVsLlxcbiAgICAgICAgICAgIGNyb2FrKFxcXCJMYWJlbCBcXFwiICsgbGFiZWwubmFtZSArIFxcXCIgZGVmaW5lZCB0d2ljZVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZXhwZWN0KFxcXCI6XFxcIik7XFxuICAgICAgICBTLmxhYmVscy5wdXNoKGxhYmVsKTtcXG4gICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50KCk7XFxuICAgICAgICBTLmxhYmVscy5wb3AoKTtcXG4gICAgICAgIGlmICghKHN0YXQgaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KSkge1xcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBgY29udGludWVgIHRoYXQgcmVmZXJzIHRvIHRoaXMgbGFiZWwuXFxuICAgICAgICAgICAgLy8gdGhvc2Ugc2hvdWxkIGJlIHJlcG9ydGVkIGFzIHN5bnRheCBlcnJvcnMuXFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzI4N1xcbiAgICAgICAgICAgIGxhYmVsLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbihyZWYpe1xcbiAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlKSB7XFxuICAgICAgICAgICAgICAgICAgICByZWYgPSByZWYubGFiZWwuc3RhcnQ7XFxuICAgICAgICAgICAgICAgICAgICBjcm9hayhcXFwiQ29udGludWUgbGFiZWwgYFxcXCIgKyBsYWJlbC5uYW1lICsgXFxcImAgcmVmZXJzIHRvIG5vbi1JdGVyYXRpb25TdGF0ZW1lbnQuXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5saW5lLCByZWYuY29sLCByZWYucG9zKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfTGFiZWxlZFN0YXRlbWVudCh7IGJvZHk6IHN0YXQsIGxhYmVsOiBsYWJlbCB9KTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gc2ltcGxlX3N0YXRlbWVudCh0bXApIHtcXG4gICAgICAgIHJldHVybiBuZXcgQVNUX1NpbXBsZVN0YXRlbWVudCh7IGJvZHk6ICh0bXAgPSBleHByZXNzaW9uKHRydWUpLCBzZW1pY29sb24oKSwgdG1wKSB9KTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gYnJlYWtfY29udCh0eXBlKSB7XFxuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBsZGVmO1xcbiAgICAgICAgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB7XFxuICAgICAgICAgICAgbGFiZWwgPSBhc19zeW1ib2woQVNUX0xhYmVsUmVmLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChsYWJlbCAhPSBudWxsKSB7XFxuICAgICAgICAgICAgbGRlZiA9IGZpbmRfaWYoZnVuY3Rpb24obCl7IHJldHVybiBsLm5hbWUgPT0gbGFiZWwubmFtZSB9LCBTLmxhYmVscyk7XFxuICAgICAgICAgICAgaWYgKCFsZGVmKVxcbiAgICAgICAgICAgICAgICBjcm9hayhcXFwiVW5kZWZpbmVkIGxhYmVsIFxcXCIgKyBsYWJlbC5uYW1lKTtcXG4gICAgICAgICAgICBsYWJlbC50aGVkZWYgPSBsZGVmO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoUy5pbl9sb29wID09IDApXFxuICAgICAgICAgICAgY3JvYWsodHlwZS5UWVBFICsgXFxcIiBub3QgaW5zaWRlIGEgbG9vcCBvciBzd2l0Y2hcXFwiKTtcXG4gICAgICAgIHNlbWljb2xvbigpO1xcbiAgICAgICAgdmFyIHN0YXQgPSBuZXcgdHlwZSh7IGxhYmVsOiBsYWJlbCB9KTtcXG4gICAgICAgIGlmIChsZGVmKSBsZGVmLnJlZmVyZW5jZXMucHVzaChzdGF0KTtcXG4gICAgICAgIHJldHVybiBzdGF0O1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBmb3JfKCkge1xcbiAgICAgICAgZXhwZWN0KFxcXCIoXFxcIik7XFxuICAgICAgICB2YXIgaW5pdCA9IG51bGw7XFxuICAgICAgICBpZiAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIjtcXFwiKSkge1xcbiAgICAgICAgICAgIGluaXQgPVxcbiAgICAgICAgICAgICAgICBpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJ2YXJcXFwiKSA/IChuZXh0KCksIHZhcl8odHJ1ZSkpIDpcXG4gICAgICAgICAgICAgICAgaXMoXFxcImtleXdvcmRcXFwiLCBcXFwibGV0XFxcIikgPyAobmV4dCgpLCBsZXRfKHRydWUpKSA6XFxuICAgICAgICAgICAgICAgIGlzKFxcXCJrZXl3b3JkXFxcIiwgXFxcImNvbnN0XFxcIikgPyAobmV4dCgpLCBjb25zdF8odHJ1ZSkpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uKHRydWUsIHRydWUpO1xcbiAgICAgICAgICAgIHZhciBpc19pbiA9IGlzKFxcXCJvcGVyYXRvclxcXCIsIFxcXCJpblxcXCIpO1xcbiAgICAgICAgICAgIHZhciBpc19vZiA9IGlzKFxcXCJuYW1lXFxcIiwgXFxcIm9mXFxcIik7XFxuICAgICAgICAgICAgaWYgKGlzX2luIHx8IGlzX29mKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbml0IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWZpbml0aW9ucy5sZW5ndGggPiAxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFxcXCJPbmx5IG9uZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhbGxvd2VkIGluIGZvci4uaW4gbG9vcFxcXCIsIGluaXQuc3RhcnQubGluZSwgaW5pdC5zdGFydC5jb2wsIGluaXQuc3RhcnQucG9zKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghKGlzX2Fzc2lnbmFibGUoaW5pdCkgfHwgKGluaXQgPSB0b19kZXN0cnVjdHVyaW5nKGluaXQpKSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXFxcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLi5pbiBsb29wXFxcIiwgaW5pdC5zdGFydC5saW5lLCBpbml0LnN0YXJ0LmNvbCwgaW5pdC5zdGFydC5wb3MpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgaWYgKGlzX2luKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yX2luKGluaXQpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcl9vZihpbml0KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZWd1bGFyX2Zvcihpbml0KTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gcmVndWxhcl9mb3IoaW5pdCkge1xcbiAgICAgICAgZXhwZWN0KFxcXCI7XFxcIik7XFxuICAgICAgICB2YXIgdGVzdCA9IGlzKFxcXCJwdW5jXFxcIiwgXFxcIjtcXFwiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xcbiAgICAgICAgZXhwZWN0KFxcXCI7XFxcIik7XFxuICAgICAgICB2YXIgc3RlcCA9IGlzKFxcXCJwdW5jXFxcIiwgXFxcIilcXFwiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xcbiAgICAgICAgZXhwZWN0KFxcXCIpXFxcIik7XFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3Ioe1xcbiAgICAgICAgICAgIGluaXQgICAgICA6IGluaXQsXFxuICAgICAgICAgICAgY29uZGl0aW9uIDogdGVzdCxcXG4gICAgICAgICAgICBzdGVwICAgICAgOiBzdGVwLFxcbiAgICAgICAgICAgIGJvZHkgICAgICA6IGluX2xvb3Aoc3RhdGVtZW50KVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGZvcl9vZihpbml0KSB7XFxuICAgICAgICB2YXIgbGhzID0gaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyA/IGluaXQuZGVmaW5pdGlvbnNbMF0ubmFtZSA6IG51bGw7XFxuICAgICAgICB2YXIgb2JqID0gZXhwcmVzc2lvbih0cnVlKTtcXG4gICAgICAgIGV4cGVjdChcXFwiKVxcXCIpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfRm9yT2Yoe1xcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXFxuICAgICAgICAgICAgbmFtZSAgIDogbGhzLFxcbiAgICAgICAgICAgIG9iamVjdCA6IG9iaixcXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKHN0YXRlbWVudClcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBmb3JfaW4oaW5pdCkge1xcbiAgICAgICAgdmFyIG9iaiA9IGV4cHJlc3Npb24odHJ1ZSk7XFxuICAgICAgICBleHBlY3QoXFxcIilcXFwiKTtcXG4gICAgICAgIHJldHVybiBuZXcgQVNUX0ZvckluKHtcXG4gICAgICAgICAgICBpbml0ICAgOiBpbml0LFxcbiAgICAgICAgICAgIG9iamVjdCA6IG9iaixcXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKHN0YXRlbWVudClcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB2YXIgYXJyb3dfZnVuY3Rpb24gPSBmdW5jdGlvbihzdGFydCwgYXJnbmFtZXMsIGlzX2FzeW5jKSB7XFxuICAgICAgICBpZiAoaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKSB7XFxuICAgICAgICAgICAgY3JvYWsoXFxcIlVuZXhwZWN0ZWQgbmV3bGluZSBiZWZvcmUgYXJyb3cgKD0+KVxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZXhwZWN0X3Rva2VuKFxcXCJhcnJvd1xcXCIsIFxcXCI9PlxcXCIpO1xcblxcbiAgICAgICAgdmFyIGJvZHkgPSBfZnVuY3Rpb25fYm9keShpcyhcXFwicHVuY1xcXCIsIFxcXCJ7XFxcIiksIGZhbHNlLCBpc19hc3luYyk7XFxuXFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9BcnJvdyh7XFxuICAgICAgICAgICAgc3RhcnQgICAgOiBzdGFydCxcXG4gICAgICAgICAgICBlbmQgICAgICA6IGJvZHkuZW5kLFxcbiAgICAgICAgICAgIGFzeW5jICAgIDogaXNfYXN5bmMsXFxuICAgICAgICAgICAgYXJnbmFtZXMgOiBhcmduYW1lcyxcXG4gICAgICAgICAgICBib2R5ICAgICA6IGJvZHlcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZnVuY3Rpb25fID0gZnVuY3Rpb24oY3RvciwgaXNfZ2VuZXJhdG9yX3Byb3BlcnR5LCBpc19hc3luYywgaXNfZXhwb3J0X2RlZmF1bHQpIHtcXG4gICAgICAgIGlmIChpc19nZW5lcmF0b3JfcHJvcGVydHkgJiYgaXNfYXN5bmMpIGNyb2FrKFxcXCJnZW5lcmF0b3JzIGNhbm5vdCBiZSBhc3luY1xcXCIpO1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcXG5cXG4gICAgICAgIHZhciBpbl9zdGF0ZW1lbnQgPSBjdG9yID09PSBBU1RfRGVmdW47XFxuICAgICAgICB2YXIgaXNfZ2VuZXJhdG9yID0gaXMoXFxcIm9wZXJhdG9yXFxcIiwgXFxcIipcXFwiKTtcXG4gICAgICAgIGlmIChpc19nZW5lcmF0b3IpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgbmFtZSA9IGlzKFxcXCJuYW1lXFxcIikgPyBhc19zeW1ib2woaW5fc3RhdGVtZW50ID8gQVNUX1N5bWJvbERlZnVuIDogQVNUX1N5bWJvbExhbWJkYSkgOiBudWxsO1xcbiAgICAgICAgaWYgKGluX3N0YXRlbWVudCAmJiAhbmFtZSkge1xcbiAgICAgICAgICAgIGlmIChpc19leHBvcnRfZGVmYXVsdCkge1xcbiAgICAgICAgICAgICAgICBjdG9yID0gQVNUX0Z1bmN0aW9uO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobmFtZSAmJiBjdG9yICE9PSBBU1RfQWNjZXNzb3IgJiYgIShuYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uKSlcXG4gICAgICAgICAgICB1bmV4cGVjdGVkKHByZXYoKSk7XFxuXFxuICAgICAgICB2YXIgYXJncyA9IFtdO1xcbiAgICAgICAgdmFyIGJvZHkgPSBfZnVuY3Rpb25fYm9keSh0cnVlLCBpc19nZW5lcmF0b3IgfHwgaXNfZ2VuZXJhdG9yX3Byb3BlcnR5LCBpc19hc3luYywgbmFtZSwgYXJncyk7XFxuICAgICAgICByZXR1cm4gbmV3IGN0b3Ioe1xcbiAgICAgICAgICAgIHN0YXJ0IDogYXJncy5zdGFydCxcXG4gICAgICAgICAgICBlbmQgICA6IGJvZHkuZW5kLFxcbiAgICAgICAgICAgIGlzX2dlbmVyYXRvcjogaXNfZ2VuZXJhdG9yLFxcbiAgICAgICAgICAgIGFzeW5jIDogaXNfYXN5bmMsXFxuICAgICAgICAgICAgbmFtZSAgOiBuYW1lLFxcbiAgICAgICAgICAgIGFyZ25hbWVzOiBhcmdzLFxcbiAgICAgICAgICAgIGJvZHkgIDogYm9keVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHRyYWNrX3VzZWRfYmluZGluZ19pZGVudGlmaWVycyhpc19wYXJhbWV0ZXIsIHN0cmljdCkge1xcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB7fTtcXG4gICAgICAgIHZhciBkdXBsaWNhdGUgPSBmYWxzZTtcXG4gICAgICAgIHZhciBkZWZhdWx0X2Fzc2lnbm1lbnQgPSBmYWxzZTtcXG4gICAgICAgIHZhciBzcHJlYWQgPSBmYWxzZTtcXG4gICAgICAgIHZhciBzdHJpY3RfbW9kZSA9ICEhc3RyaWN0O1xcbiAgICAgICAgdmFyIHRyYWNrZXIgPSB7XFxuICAgICAgICAgICAgYWRkX3BhcmFtZXRlcjogZnVuY3Rpb24odG9rZW4pIHtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnNbXFxcIiRcXFwiICsgdG9rZW4udmFsdWVdICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGUgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlID0gdG9rZW47XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmNoZWNrX3N0cmljdCgpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc1tcXFwiJFxcXCIgKyB0b2tlbi52YWx1ZV0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3BhcmFtZXRlcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcImFyZ3VtZW50c1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJldmFsXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcInlpZWxkXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdF9tb2RlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXFxcIlVuZXhwZWN0ZWQgXFxcIiArIHRva2VuLnZhbHVlICsgXFxcIiBpZGVudGlmaWVyIGFzIHBhcmFtZXRlciBpbnNpZGUgc3RyaWN0IG1vZGVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRVNFUlZFRF9XT1JEUyh0b2tlbi52YWx1ZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgbWFya19kZWZhdWx0X2Fzc2lnbm1lbnQ6IGZ1bmN0aW9uKHRva2VuKSB7XFxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0X2Fzc2lnbm1lbnQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0X2Fzc2lnbm1lbnQgPSB0b2tlbjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgbWFya19zcHJlYWQ6IGZ1bmN0aW9uKHRva2VuKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzcHJlYWQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICBzcHJlYWQgPSB0b2tlbjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgbWFya19zdHJpY3RfbW9kZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHN0cmljdF9tb2RlID0gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGlzX3N0cmljdDogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0X2Fzc2lnbm1lbnQgIT09IGZhbHNlIHx8IHNwcmVhZCAhPT0gZmFsc2UgfHwgc3RyaWN0X21vZGVcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNoZWNrX3N0cmljdDogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0cmFja2VyLmlzX3N0cmljdCgpICYmIGR1cGxpY2F0ZSAhPT0gZmFsc2UpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKGR1cGxpY2F0ZSwgXFxcIlBhcmFtZXRlciBcXFwiICsgZHVwbGljYXRlLnZhbHVlICsgXFxcIiB3YXMgdXNlZCBhbHJlYWR5XFxcIik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIHRyYWNrZXI7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGFyYW1ldGVycyhwYXJhbXMpIHtcXG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XFxuICAgICAgICB2YXIgdXNlZF9wYXJhbWV0ZXJzID0gdHJhY2tfdXNlZF9iaW5kaW5nX2lkZW50aWZpZXJzKHRydWUsIFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcXFwidXNlIHN0cmljdFxcXCIpKTtcXG5cXG4gICAgICAgIGV4cGVjdChcXFwiKFxcXCIpO1xcblxcbiAgICAgICAgd2hpbGUgKCFpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikpIHtcXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbWV0ZXIodXNlZF9wYXJhbWV0ZXJzKTtcXG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XFxuXFxuICAgICAgICAgICAgaWYgKCFpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgZXhwZWN0KFxcXCIsXFxcIik7XFxuICAgICAgICAgICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikgJiYgb3B0aW9ucy5lY21hIDwgOCkgdW5leHBlY3RlZCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG5leHQoKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwYXJhbWV0ZXIodXNlZF9wYXJhbWV0ZXJzLCBzeW1ib2xfdHlwZSkge1xcbiAgICAgICAgdmFyIHBhcmFtO1xcbiAgICAgICAgdmFyIGV4cGFuZCA9IGZhbHNlO1xcbiAgICAgICAgaWYgKHVzZWRfcGFyYW1ldGVycyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzID0gdHJhY2tfdXNlZF9iaW5kaW5nX2lkZW50aWZpZXJzKHRydWUsIFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcXFwidXNlIHN0cmljdFxcXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpcyhcXFwiZXhwYW5kXFxcIiwgXFxcIi4uLlxcXCIpKSB7XFxuICAgICAgICAgICAgZXhwYW5kID0gUy50b2tlbjtcXG4gICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19zcHJlYWQoUy50b2tlbik7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcGFyYW0gPSBiaW5kaW5nX2VsZW1lbnQodXNlZF9wYXJhbWV0ZXJzLCBzeW1ib2xfdHlwZSk7XFxuXFxuICAgICAgICBpZiAoaXMoXFxcIm9wZXJhdG9yXFxcIiwgXFxcIj1cXFwiKSAmJiBleHBhbmQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLm1hcmtfZGVmYXVsdF9hc3NpZ25tZW50KFMudG9rZW4pO1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICBwYXJhbSA9IG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXJhbS5zdGFydCxcXG4gICAgICAgICAgICAgICAgbGVmdDogcGFyYW0sXFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcXFwiPVxcXCIsXFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByZXNzaW9uKGZhbHNlKSxcXG4gICAgICAgICAgICAgICAgZW5kOiBTLnRva2VuXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXhwYW5kICE9PSBmYWxzZSkge1xcbiAgICAgICAgICAgIGlmICghaXMoXFxcInB1bmNcXFwiLCBcXFwiKVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcGFyYW0gPSBuZXcgQVNUX0V4cGFuc2lvbih7XFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBleHBhbmQsXFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHBhcmFtLFxcbiAgICAgICAgICAgICAgICBlbmQ6IGV4cGFuZFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xcblxcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGJpbmRpbmdfZWxlbWVudCh1c2VkX3BhcmFtZXRlcnMsIHN5bWJvbF90eXBlKSB7XFxuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcXG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XFxuICAgICAgICB2YXIgaXNfZXhwYW5kID0gZmFsc2U7XFxuICAgICAgICB2YXIgZXhwYW5kX3Rva2VuO1xcbiAgICAgICAgdmFyIGZpcnN0X3Rva2VuID0gUy50b2tlbjtcXG4gICAgICAgIGlmICh1c2VkX3BhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycyA9IHRyYWNrX3VzZWRfYmluZGluZ19pZGVudGlmaWVycyhmYWxzZSwgUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFxcXCJ1c2Ugc3RyaWN0XFxcIikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3ltYm9sX3R5cGUgPSBzeW1ib2xfdHlwZSA9PT0gdW5kZWZpbmVkID8gQVNUX1N5bWJvbEZ1bmFyZyA6IHN5bWJvbF90eXBlO1xcbiAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIltcXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICB3aGlsZSAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIl1cXFwiKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoXFxcIixcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoaXMoXFxcImV4cGFuZFxcXCIsIFxcXCIuLi5cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgaXNfZXhwYW5kID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZF90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICAgICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19zcHJlYWQoUy50b2tlbik7XFxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCIsXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBBU1RfSG9sZSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IFMudG9rZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIl1cXFwiOiAvLyBUcmFpbGluZyBjb21tYSBhZnRlciBsYXN0IGVsZW1lbnRcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiW1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIntcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYmluZGluZ19lbGVtZW50KHVzZWRfcGFyYW1ldGVycywgc3ltYm9sX3R5cGUpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXFxcIm5hbWVcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGFzX3N5bWJvbChzeW1ib2xfdHlwZSkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXFxcIkludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyXFxcIik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGlzKFxcXCJvcGVyYXRvclxcXCIsIFxcXCI9XFxcIikgJiYgaXNfZXhwYW5kID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLm1hcmtfZGVmYXVsdF9hc3NpZ25tZW50KFMudG9rZW4pO1xcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gPSBuZXcgQVNUX0RlZmF1bHRBc3NpZ24oe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS5zdGFydCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXFxcIj1cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByZXNzaW9uKGZhbHNlKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IFMudG9rZW5cXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChpc19leHBhbmQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXMoXFxcInB1bmNcXFwiLCBcXFwiXVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXFxcIlJlc3QgZWxlbWVudCBtdXN0IGJlIGxhc3QgZWxlbWVudFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gPSBuZXcgQVNUX0V4cGFuc2lvbih7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGV4cGFuZF90b2tlbixcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGV4cGFuZF90b2tlblxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZXhwZWN0KFxcXCJdXFxcIik7XFxuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xcbiAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RfdG9rZW4sXFxuICAgICAgICAgICAgICAgIG5hbWVzOiBlbGVtZW50cyxcXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIntcXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICB3aGlsZSAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIn1cXFwiKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoXFxcIixcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoaXMoXFxcImV4cGFuZFxcXCIsIFxcXCIuLi5cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgaXNfZXhwYW5kID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZF90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICAgICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19zcHJlYWQoUy50b2tlbik7XFxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGlzKFxcXCJuYW1lXFxcIikgJiYgKGlzX3Rva2VuKHBlZWsoKSwgXFxcInB1bmNcXFwiKSB8fCBpc190b2tlbihwZWVrKCksIFxcXCJvcGVyYXRvclxcXCIpKSAmJiBbXFxcIixcXFwiLCBcXFwifVxcXCIsIFxcXCI9XFxcIl0uaW5kZXhPZihwZWVrKCkudmFsdWUpICE9PSAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwcmV2KCk7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhc19zeW1ib2woc3ltYm9sX3R5cGUpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2V4cGFuZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZXhwYW5kX3Rva2VuLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB2YWx1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBBU1RfT2JqZWN0S2V5VmFsKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHZhbHVlLm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIn1cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEFsbG93IHRyYWlsaW5nIGhvbGVcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgPT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKHByZXYoKSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYoKS50eXBlID09PSBcXFwibmFtZVxcXCIgJiYgIWlzKFxcXCJwdW5jXFxcIiwgXFxcIjpcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IEFTVF9PYmplY3RLZXlWYWwoe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IHN5bWJvbF90eXBlKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFxcXCI6XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgQVNUX09iamVjdEtleVZhbCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wZXJ0eV90b2tlbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGU6IHByb3BlcnR5X3Rva2VuLnF1b3RlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYmluZGluZ19lbGVtZW50KHVzZWRfcGFyYW1ldGVycywgc3ltYm9sX3R5cGUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoaXNfZXhwYW5kKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIn1cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb2FrKFxcXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnRcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpcyhcXFwib3BlcmF0b3JcXFwiLCBcXFwiPVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19kZWZhdWx0X2Fzc2lnbm1lbnQoUy50b2tlbik7XFxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLnZhbHVlLnN0YXJ0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLnZhbHVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcXFwiPVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cHJlc3Npb24oZmFsc2UpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZXhwZWN0KFxcXCJ9XFxcIik7XFxuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xcbiAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RfdG9rZW4sXFxuICAgICAgICAgICAgICAgIG5hbWVzOiBlbGVtZW50cyxcXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIGlmIChpcyhcXFwibmFtZVxcXCIpKSB7XFxuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XFxuICAgICAgICAgICAgcmV0dXJuIGFzX3N5bWJvbChzeW1ib2xfdHlwZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNyb2FrKFxcXCJJbnZhbGlkIGZ1bmN0aW9uIHBhcmFtZXRlclxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBhcmFtc19vcl9zZXFfKGFsbG93X2Fycm93cywgbWF5YmVfc2VxdWVuY2UpIHtcXG4gICAgICAgIHZhciBzcHJlYWRfdG9rZW47XFxuICAgICAgICB2YXIgaW52YWxpZF9zZXF1ZW5jZTtcXG4gICAgICAgIHZhciB0cmFpbGluZ19jb21tYTtcXG4gICAgICAgIHZhciBhID0gW107XFxuICAgICAgICBleHBlY3QoXFxcIihcXFwiKTtcXG4gICAgICAgIHdoaWxlICghaXMoXFxcInB1bmNcXFwiLCBcXFwiKVxcXCIpKSB7XFxuICAgICAgICAgICAgaWYgKHNwcmVhZF90b2tlbikgdW5leHBlY3RlZChzcHJlYWRfdG9rZW4pO1xcbiAgICAgICAgICAgIGlmIChpcyhcXFwiZXhwYW5kXFxcIiwgXFxcIi4uLlxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIHNwcmVhZF90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICAgICAgICAgIGlmIChtYXliZV9zZXF1ZW5jZSkgaW52YWxpZF9zZXF1ZW5jZSA9IFMudG9rZW47XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfRXhwYW5zaW9uKHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uKCksXFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFMudG9rZW4sXFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhLnB1c2goZXhwcmVzc2lvbigpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKCFpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgZXhwZWN0KFxcXCIsXFxcIik7XFxuICAgICAgICAgICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVjbWEgPCA4KSB1bmV4cGVjdGVkKCk7XFxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ19jb21tYSA9IHByZXYoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZV9zZXF1ZW5jZSkgaW52YWxpZF9zZXF1ZW5jZSA9IHRyYWlsaW5nX2NvbW1hO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZXhwZWN0KFxcXCIpXFxcIik7XFxuICAgICAgICBpZiAoYWxsb3dfYXJyb3dzICYmIGlzKFxcXCJhcnJvd1xcXCIsIFxcXCI9PlxcXCIpKSB7XFxuICAgICAgICAgICAgaWYgKHNwcmVhZF90b2tlbiAmJiB0cmFpbGluZ19jb21tYSkgdW5leHBlY3RlZCh0cmFpbGluZ19jb21tYSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGludmFsaWRfc2VxdWVuY2UpIHtcXG4gICAgICAgICAgICB1bmV4cGVjdGVkKGludmFsaWRfc2VxdWVuY2UpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gX2Z1bmN0aW9uX2JvZHkoYmxvY2ssIGdlbmVyYXRvciwgaXNfYXN5bmMsIG5hbWUsIGFyZ3MpIHtcXG4gICAgICAgIHZhciBsb29wID0gUy5pbl9sb29wO1xcbiAgICAgICAgdmFyIGxhYmVscyA9IFMubGFiZWxzO1xcbiAgICAgICAgdmFyIGN1cnJlbnRfZ2VuZXJhdG9yID0gUy5pbl9nZW5lcmF0b3I7XFxuICAgICAgICB2YXIgY3VycmVudF9hc3luYyA9IFMuaW5fYXN5bmM7XFxuICAgICAgICArK1MuaW5fZnVuY3Rpb247XFxuICAgICAgICBpZiAoZ2VuZXJhdG9yKVxcbiAgICAgICAgICAgIFMuaW5fZ2VuZXJhdG9yID0gUy5pbl9mdW5jdGlvbjtcXG4gICAgICAgIGlmIChpc19hc3luYylcXG4gICAgICAgICAgICBTLmluX2FzeW5jID0gUy5pbl9mdW5jdGlvbjtcXG4gICAgICAgIGlmIChhcmdzKSBwYXJhbWV0ZXJzKGFyZ3MpO1xcbiAgICAgICAgaWYgKGJsb2NrKVxcbiAgICAgICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IHRydWU7XFxuICAgICAgICBTLmluX2xvb3AgPSAwO1xcbiAgICAgICAgUy5sYWJlbHMgPSBbXTtcXG4gICAgICAgIGlmIChibG9jaykge1xcbiAgICAgICAgICAgIFMuaW5wdXQucHVzaF9kaXJlY3RpdmVzX3N0YWNrKCk7XFxuICAgICAgICAgICAgdmFyIGEgPSBibG9ja18oKTtcXG4gICAgICAgICAgICBpZiAobmFtZSkgX3ZlcmlmeV9zeW1ib2wobmFtZSk7XFxuICAgICAgICAgICAgaWYgKGFyZ3MpIGFyZ3MuZm9yRWFjaChfdmVyaWZ5X3N5bWJvbCk7XFxuICAgICAgICAgICAgUy5pbnB1dC5wb3BfZGlyZWN0aXZlc19zdGFjaygpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgYSA9IGV4cHJlc3Npb24oZmFsc2UpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLS1TLmluX2Z1bmN0aW9uO1xcbiAgICAgICAgUy5pbl9sb29wID0gbG9vcDtcXG4gICAgICAgIFMubGFiZWxzID0gbGFiZWxzO1xcbiAgICAgICAgUy5pbl9nZW5lcmF0b3IgPSBjdXJyZW50X2dlbmVyYXRvcjtcXG4gICAgICAgIFMuaW5fYXN5bmMgPSBjdXJyZW50X2FzeW5jO1xcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gX2F3YWl0X2V4cHJlc3Npb24oKSB7XFxuICAgICAgICAvLyBQcmV2aW91cyB0b2tlbiBtdXN0IGJlIFxcXCJhd2FpdFxcXCIgYW5kIG5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpZGVudGlmaWVyXFxuICAgICAgICBpZiAoIWlzX2luX2FzeW5jKCkpIHtcXG4gICAgICAgICAgICBjcm9hayhcXFwiVW5leHBlY3RlZCBhd2FpdCBleHByZXNzaW9uIG91dHNpZGUgYXN5bmMgZnVuY3Rpb25cXFwiLFxcbiAgICAgICAgICAgICAgICBTLnByZXYubGluZSwgUy5wcmV2LmNvbCwgUy5wcmV2LnBvcyk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyB0aGUgYXdhaXQgZXhwcmVzc2lvbiBpcyBwYXJzZWQgYXMgYSB1bmFyeSBleHByZXNzaW9uIGluIEJhYmVsXFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9Bd2FpdCh7XFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IG1heWJlX3VuYXJ5KHRydWUpLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gX3lpZWxkX2V4cHJlc3Npb24oKSB7XFxuICAgICAgICAvLyBQcmV2aW91cyB0b2tlbiBtdXN0IGJlIGtleXdvcmQgeWllbGQgYW5kIG5vdCBiZSBpbnRlcnByZXQgYXMgYW4gaWRlbnRpZmllclxcbiAgICAgICAgaWYgKCFpc19pbl9nZW5lcmF0b3IoKSkge1xcbiAgICAgICAgICAgIGNyb2FrKFxcXCJVbmV4cGVjdGVkIHlpZWxkIGV4cHJlc3Npb24gb3V0c2lkZSBnZW5lcmF0b3IgZnVuY3Rpb25cXFwiLFxcbiAgICAgICAgICAgICAgICBTLnByZXYubGluZSwgUy5wcmV2LmNvbCwgUy5wcmV2LnBvcyk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgc3RhciA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGhhc19leHByZXNzaW9uID0gdHJ1ZTtcXG5cXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGV4cHJlc3Npb24gb3Igc3RhciAoYW5kIHRoZW4gdGhlIG1hbmRhdG9yeSBleHByZXNzaW9uKVxcbiAgICAgICAgLy8gYmVoaW5kIHlpZWxkIG9uIHRoZSBzYW1lIGxpbmUuXFxuICAgICAgICAvL1xcbiAgICAgICAgLy8gSWYgbm90aGluZyBmb2xsb3dzIG9uIHRoZSBzYW1lIGxpbmUgb2YgdGhlIHlpZWxkRXhwcmVzc2lvbixcXG4gICAgICAgIC8vIGl0IHNob3VsZCBkZWZhdWx0IHRvIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBmb3IgeWllbGQgdG8gcmV0dXJuLlxcbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgYHVuZGVmaW5lZGAgc3RvcmVkIGFzIGBudWxsYCBpbiBhc3QuXFxuICAgICAgICAvL1xcbiAgICAgICAgLy8gTm90ZSAxOiBJdCBpc24ndCBhbGxvd2VkIGZvciB5aWVsZCogdG8gY2xvc2Ugd2l0aG91dCBhbiBleHByZXNzaW9uXFxuICAgICAgICAvLyBOb3RlIDI6IElmIHRoZXJlIGlzIGEgbmxiIGJldHdlZW4geWllbGQgYW5kIHN0YXIsIGl0IGlzIGludGVycHJldCBhc1xcbiAgICAgICAgLy8gICAgICAgICB5aWVsZCA8ZXhwbGljaXQgdW5kZWZpbmVkPiA8aW5zZXJ0ZWQgYXV0b21hdGljIHNlbWljb2xvbj4gKlxcbiAgICAgICAgaWYgKGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkgfHxcXG4gICAgICAgICAgICAoaXMoXFxcInB1bmNcXFwiKSAmJiBQVU5DX0FGVEVSX0VYUFJFU1NJT04oUy50b2tlbi52YWx1ZSkpKSB7XFxuICAgICAgICAgICAgaGFzX2V4cHJlc3Npb24gPSBmYWxzZTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoaXMoXFxcIm9wZXJhdG9yXFxcIiwgXFxcIipcXFwiKSkge1xcbiAgICAgICAgICAgIHN0YXIgPSB0cnVlO1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBuZXcgQVNUX1lpZWxkKHtcXG4gICAgICAgICAgICBpc19zdGFyICAgIDogc3RhcixcXG4gICAgICAgICAgICBleHByZXNzaW9uIDogaGFzX2V4cHJlc3Npb24gPyBleHByZXNzaW9uKCkgOiBudWxsXFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpZl8oKSB7XFxuICAgICAgICB2YXIgY29uZCA9IHBhcmVudGhlc2lzZWQoKSwgYm9keSA9IHN0YXRlbWVudCgpLCBiZWxzZSA9IG51bGw7XFxuICAgICAgICBpZiAoaXMoXFxcImtleXdvcmRcXFwiLCBcXFwiZWxzZVxcXCIpKSB7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIGJlbHNlID0gc3RhdGVtZW50KCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9JZih7XFxuICAgICAgICAgICAgY29uZGl0aW9uICAgOiBjb25kLFxcbiAgICAgICAgICAgIGJvZHkgICAgICAgIDogYm9keSxcXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGJlbHNlXFxuICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gYmxvY2tfKCkge1xcbiAgICAgICAgZXhwZWN0KFxcXCJ7XFxcIik7XFxuICAgICAgICB2YXIgYSA9IFtdO1xcbiAgICAgICAgd2hpbGUgKCFpcyhcXFwicHVuY1xcXCIsIFxcXCJ9XFxcIikpIHtcXG4gICAgICAgICAgICBpZiAoaXMoXFxcImVvZlxcXCIpKSB1bmV4cGVjdGVkKCk7XFxuICAgICAgICAgICAgYS5wdXNoKHN0YXRlbWVudCgpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIG5leHQoKTtcXG4gICAgICAgIHJldHVybiBhO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBzd2l0Y2hfYm9keV8oKSB7XFxuICAgICAgICBleHBlY3QoXFxcIntcXFwiKTtcXG4gICAgICAgIHZhciBhID0gW10sIGN1ciA9IG51bGwsIGJyYW5jaCA9IG51bGwsIHRtcDtcXG4gICAgICAgIHdoaWxlICghaXMoXFxcInB1bmNcXFwiLCBcXFwifVxcXCIpKSB7XFxuICAgICAgICAgICAgaWYgKGlzKFxcXCJlb2ZcXFwiKSkgdW5leHBlY3RlZCgpO1xcbiAgICAgICAgICAgIGlmIChpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJjYXNlXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcXG4gICAgICAgICAgICAgICAgY3VyID0gW107XFxuICAgICAgICAgICAgICAgIGJyYW5jaCA9IG5ldyBBU1RfQ2FzZSh7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogKHRtcCA9IFMudG9rZW4sIG5leHQoKSwgdG1wKSxcXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByZXNzaW9uKHRydWUpLFxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IGN1clxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgYS5wdXNoKGJyYW5jaCk7XFxuICAgICAgICAgICAgICAgIGV4cGVjdChcXFwiOlxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJkZWZhdWx0XFxcIikpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcXG4gICAgICAgICAgICAgICAgY3VyID0gW107XFxuICAgICAgICAgICAgICAgIGJyYW5jaCA9IG5ldyBBU1RfRGVmYXVsdCh7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydCA6ICh0bXAgPSBTLnRva2VuLCBuZXh0KCksIGV4cGVjdChcXFwiOlxcXCIpLCB0bXApLFxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgOiBjdXJcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGEucHVzaChicmFuY2gpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgICAgICAgICAgY3VyLnB1c2goc3RhdGVtZW50KCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChicmFuY2gpIGJyYW5jaC5lbmQgPSBwcmV2KCk7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgICByZXR1cm4gYTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gdHJ5XygpIHtcXG4gICAgICAgIHZhciBib2R5ID0gYmxvY2tfKCksIGJjYXRjaCA9IG51bGwsIGJmaW5hbGx5ID0gbnVsbDtcXG4gICAgICAgIGlmIChpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJjYXRjaFxcXCIpKSB7XFxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgZXhwZWN0KFxcXCIoXFxcIik7XFxuICAgICAgICAgICAgdmFyIG5hbWUgPSBwYXJhbWV0ZXIodW5kZWZpbmVkLCBBU1RfU3ltYm9sQ2F0Y2gpO1xcbiAgICAgICAgICAgIGV4cGVjdChcXFwiKVxcXCIpO1xcbiAgICAgICAgICAgIGJjYXRjaCA9IG5ldyBBU1RfQ2F0Y2goe1xcbiAgICAgICAgICAgICAgICBzdGFydCAgIDogc3RhcnQsXFxuICAgICAgICAgICAgICAgIGFyZ25hbWUgOiBuYW1lLFxcbiAgICAgICAgICAgICAgICBib2R5ICAgIDogYmxvY2tfKCksXFxuICAgICAgICAgICAgICAgIGVuZCAgICAgOiBwcmV2KClcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJmaW5hbGx5XFxcIikpIHtcXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICBiZmluYWxseSA9IG5ldyBBU1RfRmluYWxseSh7XFxuICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXFxuICAgICAgICAgICAgICAgIGJvZHkgIDogYmxvY2tfKCksXFxuICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWJjYXRjaCAmJiAhYmZpbmFsbHkpXFxuICAgICAgICAgICAgY3JvYWsoXFxcIk1pc3NpbmcgY2F0Y2gvZmluYWxseSBibG9ja3NcXFwiKTtcXG4gICAgICAgIHJldHVybiBuZXcgQVNUX1RyeSh7XFxuICAgICAgICAgICAgYm9keSAgICAgOiBib2R5LFxcbiAgICAgICAgICAgIGJjYXRjaCAgIDogYmNhdGNoLFxcbiAgICAgICAgICAgIGJmaW5hbGx5IDogYmZpbmFsbHlcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiB2YXJkZWZzKG5vX2luLCBraW5kKSB7XFxuICAgICAgICB2YXIgYSA9IFtdO1xcbiAgICAgICAgdmFyIGRlZjtcXG4gICAgICAgIGZvciAoOzspIHtcXG4gICAgICAgICAgICB2YXIgc3ltX3R5cGUgPVxcbiAgICAgICAgICAgICAgICBraW5kID09PSBcXFwidmFyXFxcIiA/IEFTVF9TeW1ib2xWYXIgOlxcbiAgICAgICAgICAgICAgICBraW5kID09PSBcXFwiY29uc3RcXFwiID8gQVNUX1N5bWJvbENvbnN0IDpcXG4gICAgICAgICAgICAgICAga2luZCA9PT0gXFxcImxldFxcXCIgPyBBU1RfU3ltYm9sTGV0IDogbnVsbDtcXG4gICAgICAgICAgICBpZiAoaXMoXFxcInB1bmNcXFwiLCBcXFwie1xcXCIpIHx8IGlzKFxcXCJwdW5jXFxcIiwgXFxcIltcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBkZWYgPSBuZXcgQVNUX1ZhckRlZih7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogUy50b2tlbixcXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGJpbmRpbmdfZWxlbWVudCh1bmRlZmluZWQgLHN5bV90eXBlKSxcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpcyhcXFwib3BlcmF0b3JcXFwiLCBcXFwiPVxcXCIpID8gKGV4cGVjdF90b2tlbihcXFwib3BlcmF0b3JcXFwiLCBcXFwiPVxcXCIpLCBleHByZXNzaW9uKGZhbHNlLCBub19pbikpIDogbnVsbCxcXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGRlZiA9IG5ldyBBU1RfVmFyRGVmKHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgIDogYXNfc3ltYm9sKHN5bV90eXBlKSxcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDogaXMoXFxcIm9wZXJhdG9yXFxcIiwgXFxcIj1cXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKG5leHQoKSwgZXhwcmVzc2lvbihmYWxzZSwgbm9faW4pKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIW5vX2luICYmIGtpbmQgPT09IFxcXCJjb25zdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjcm9hayhcXFwiTWlzc2luZyBpbml0aWFsaXplciBpbiBjb25zdCBkZWNsYXJhdGlvblxcXCIpIDogbnVsbCxcXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBpZiAoZGVmLm5hbWUubmFtZSA9PSBcXFwiaW1wb3J0XFxcIikgY3JvYWsoXFxcIlVuZXhwZWN0ZWQgdG9rZW46IGltcG9ydFxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBhLnB1c2goZGVmKTtcXG4gICAgICAgICAgICBpZiAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIixcXFwiKSlcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgIH07XFxuXFxuICAgIHZhciB2YXJfID0gZnVuY3Rpb24obm9faW4pIHtcXG4gICAgICAgIHJldHVybiBuZXcgQVNUX1Zhcih7XFxuICAgICAgICAgICAgc3RhcnQgICAgICAgOiBwcmV2KCksXFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBcXFwidmFyXFxcIiksXFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB2YXIgbGV0XyA9IGZ1bmN0aW9uKG5vX2luKSB7XFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9MZXQoe1xcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhub19pbiwgXFxcImxldFxcXCIpLFxcbiAgICAgICAgICAgIGVuZCAgICAgICAgIDogcHJldigpXFxuICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGNvbnN0XyA9IGZ1bmN0aW9uKG5vX2luKSB7XFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9Db25zdCh7XFxuICAgICAgICAgICAgc3RhcnQgICAgICAgOiBwcmV2KCksXFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBcXFwiY29uc3RcXFwiKSxcXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHZhciBuZXdfID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMpIHtcXG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XFxuICAgICAgICBleHBlY3RfdG9rZW4oXFxcIm9wZXJhdG9yXFxcIiwgXFxcIm5ld1xcXCIpO1xcbiAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIi5cXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICBleHBlY3RfdG9rZW4oXFxcIm5hbWVcXFwiLCBcXFwidGFyZ2V0XFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9OZXdUYXJnZXQoe1xcbiAgICAgICAgICAgICAgICBzdGFydCA6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbmV3ZXhwID0gZXhwcl9hdG9tKGZhbHNlKSwgYXJncztcXG4gICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIoXFxcIikpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgYXJncyA9IGV4cHJfbGlzdChcXFwiKVxcXCIsIG9wdGlvbnMuZWNtYSA+PSA4KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYXJncyA9IFtdO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGNhbGwgPSBuZXcgQVNUX05ldyh7XFxuICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBuZXdleHAsXFxuICAgICAgICAgICAgYXJncyAgICAgICA6IGFyZ3MsXFxuICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxcbiAgICAgICAgfSk7XFxuICAgICAgICBtYXJrX3B1cmUoY2FsbCk7XFxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhjYWxsLCBhbGxvd19jYWxscyk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGFzX2F0b21fbm9kZSgpIHtcXG4gICAgICAgIHZhciB0b2sgPSBTLnRva2VuLCByZXQ7XFxuICAgICAgICBzd2l0Y2ggKHRvay50eXBlKSB7XFxuICAgICAgICAgIGNhc2UgXFxcIm5hbWVcXFwiOlxcbiAgICAgICAgICAgIHJldCA9IF9tYWtlX3N5bWJvbChBU1RfU3ltYm9sUmVmKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcXFwibnVtXFxcIjpcXG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bWJlcih7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogdG9rLnZhbHVlIH0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFxcXCJzdHJpbmdcXFwiOlxcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfU3RyaW5nKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQgOiB0b2ssXFxuICAgICAgICAgICAgICAgIGVuZCAgIDogdG9rLFxcbiAgICAgICAgICAgICAgICB2YWx1ZSA6IHRvay52YWx1ZSxcXG4gICAgICAgICAgICAgICAgcXVvdGUgOiB0b2sucXVvdGVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcXFwicmVnZXhwXFxcIjpcXG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX1JlZ0V4cCh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogdG9rLnZhbHVlIH0pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlIFxcXCJhdG9tXFxcIjpcXG4gICAgICAgICAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZmFsc2VcXFwiOlxcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQVNUX0ZhbHNlKHsgc3RhcnQ6IHRvaywgZW5kOiB0b2sgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgY2FzZSBcXFwidHJ1ZVxcXCI6XFxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfVHJ1ZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgIGNhc2UgXFxcIm51bGxcXFwiOlxcbiAgICAgICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bGwoeyBzdGFydDogdG9rLCBlbmQ6IHRvayB9KTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gdG9fZnVuX2FyZ3MoZXgsIF8sIF9fLCBkZWZhdWx0X3NlZW5fYWJvdmUpIHtcXG4gICAgICAgIHZhciBpbnNlcnRfZGVmYXVsdCA9IGZ1bmN0aW9uKGV4LCBkZWZhdWx0X3ZhbHVlKSB7XFxuICAgICAgICAgICAgaWYgKGRlZmF1bHRfdmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogZXguc3RhcnQsXFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBleCxcXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcXFwiPVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZGVmYXVsdF92YWx1ZSxcXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGVmYXVsdF92YWx1ZS5lbmRcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBleDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChleCBpbnN0YW5jZW9mIEFTVF9PYmplY3QpIHtcXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQobmV3IEFTVF9EZXN0cnVjdHVyaW5nKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGV4LnN0YXJ0LFxcbiAgICAgICAgICAgICAgICBlbmQ6IGV4LmVuZCxcXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBuYW1lczogZXgucHJvcGVydGllcy5tYXAodG9fZnVuX2FyZ3MpXFxuICAgICAgICAgICAgfSksIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xcbiAgICAgICAgICAgIGV4LnZhbHVlID0gdG9fZnVuX2FyZ3MoZXgudmFsdWUsIDAsIFtleC5rZXldKTtcXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQoZXgsIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0hvbGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gZXg7XFxuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcXG4gICAgICAgICAgICBleC5uYW1lcyA9IGV4Lm5hbWVzLm1hcCh0b19mdW5fYXJncyk7XFxuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KGV4LCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChleCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQobmV3IEFTVF9TeW1ib2xGdW5hcmcoe1xcbiAgICAgICAgICAgICAgICBuYW1lOiBleC5uYW1lLFxcbiAgICAgICAgICAgICAgICBzdGFydDogZXguc3RhcnQsXFxuICAgICAgICAgICAgICAgIGVuZDogZXguZW5kXFxuICAgICAgICAgICAgfSksIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xcbiAgICAgICAgICAgIGV4LmV4cHJlc3Npb24gPSB0b19mdW5fYXJncyhleC5leHByZXNzaW9uKTtcXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQoZXgsIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBleC5zdGFydCxcXG4gICAgICAgICAgICAgICAgZW5kOiBleC5lbmQsXFxuICAgICAgICAgICAgICAgIGlzX2FycmF5OiB0cnVlLFxcbiAgICAgICAgICAgICAgICBuYW1lczogZXguZWxlbWVudHMubWFwKHRvX2Z1bl9hcmdzKVxcbiAgICAgICAgICAgIH0pLCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChleCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pIHtcXG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQodG9fZnVuX2FyZ3MoZXgubGVmdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4LnJpZ2h0KSwgZGVmYXVsdF9zZWVuX2Fib3ZlKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZXggaW5zdGFuY2VvZiBBU1RfRGVmYXVsdEFzc2lnbikge1xcbiAgICAgICAgICAgIGV4LmxlZnQgPSB0b19mdW5fYXJncyhleC5sZWZ0LCAwLCBbZXgubGVmdF0pO1xcbiAgICAgICAgICAgIHJldHVybiBleDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY3JvYWsoXFxcIkludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyXFxcIiwgZXguc3RhcnQubGluZSwgZXguc3RhcnQuY29sKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgZXhwcl9hdG9tID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMsIGFsbG93X2Fycm93cykge1xcbiAgICAgICAgaWYgKGlzKFxcXCJvcGVyYXRvclxcXCIsIFxcXCJuZXdcXFwiKSkge1xcbiAgICAgICAgICAgIHJldHVybiBuZXdfKGFsbG93X2NhbGxzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XFxuICAgICAgICB2YXIgYXN5bmMgPSBpcyhcXFwibmFtZVxcXCIsIFxcXCJhc3luY1xcXCIpICYmIGFzX2F0b21fbm9kZSgpO1xcbiAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIikpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udmFsdWUpIHtcXG4gICAgICAgICAgICAgIGNhc2UgXFxcIihcXFwiOlxcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMgJiYgIWFsbG93X2NhbGxzKSBicmVhaztcXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJzID0gcGFyYW1zX29yX3NlcV8oYWxsb3dfYXJyb3dzLCAhYXN5bmMpO1xcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dfYXJyb3dzICYmIGlzKFxcXCJhcnJvd1xcXCIsIFxcXCI9PlxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyb3dfZnVuY3Rpb24oc3RhcnQsIGV4cHJzLm1hcCh0b19mdW5fYXJncyksICEhYXN5bmMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHZhciBleCA9IGFzeW5jID8gbmV3IEFTVF9DYWxsKHtcXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGFzeW5jLFxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZXhwcnNcXG4gICAgICAgICAgICAgICAgfSkgOiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogbmV3IEFTVF9TZXF1ZW5jZSh7XFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogZXhwcnNcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGlmIChleC5zdGFydCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGg7XFxuICAgICAgICAgICAgICAgICAgICBbXS51bnNoaWZ0LmFwcGx5KGV4LnN0YXJ0LmNvbW1lbnRzX2JlZm9yZSwgc3RhcnQuY29tbWVudHNfYmVmb3JlKTtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LmNvbW1lbnRzX2JlZm9yZSA9IGV4LnN0YXJ0LmNvbW1lbnRzX2JlZm9yZTtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LmNvbW1lbnRzX2JlZm9yZV9sZW5ndGggPSBsZW47XFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuID09IDAgJiYgc3RhcnQuY29tbWVudHNfYmVmb3JlLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQubmxiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQubmxiID0gc3RhcnQubmxiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydC5ubGIgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBzdGFydC5jb21tZW50c19hZnRlciA9IGV4LnN0YXJ0LmNvbW1lbnRzX2FmdGVyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XFxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwcmV2KCk7XFxuICAgICAgICAgICAgICAgIGlmIChleC5lbmQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGVuZC5jb21tZW50c19iZWZvcmUgPSBleC5lbmQuY29tbWVudHNfYmVmb3JlO1xcbiAgICAgICAgICAgICAgICAgICAgW10ucHVzaC5hcHBseShleC5lbmQuY29tbWVudHNfYWZ0ZXIsIGVuZC5jb21tZW50c19hZnRlcik7XFxuICAgICAgICAgICAgICAgICAgICBlbmQuY29tbWVudHNfYWZ0ZXIgPSBleC5lbmQuY29tbWVudHNfYWZ0ZXI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZXguZW5kID0gZW5kO1xcbiAgICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBBU1RfQ2FsbCkgbWFya19wdXJlKGV4KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZXgsIGFsbG93X2NhbGxzKTtcXG4gICAgICAgICAgICAgIGNhc2UgXFxcIltcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcnJheV8oKSwgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgICAgICAgY2FzZSBcXFwie1xcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG9iamVjdF9vcl9kZXN0cnVjdHVyaW5nXygpLCBhbGxvd19jYWxscyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICghYXN5bmMpIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChhbGxvd19hcnJvd3MgJiYgaXMoXFxcIm5hbWVcXFwiKSAmJiBpc190b2tlbihwZWVrKCksIFxcXCJhcnJvd1xcXCIpKSB7XFxuICAgICAgICAgICAgdmFyIHBhcmFtID0gbmV3IEFTVF9TeW1ib2xGdW5hcmcoe1xcbiAgICAgICAgICAgICAgICBuYW1lOiBTLnRva2VuLnZhbHVlLFxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgICAgIGVuZDogc3RhcnQsXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIHJldHVybiBhcnJvd19mdW5jdGlvbihzdGFydCwgW3BhcmFtXSwgISFhc3luYyk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXMoXFxcImtleXdvcmRcXFwiLCBcXFwiZnVuY3Rpb25cXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uXyhBU1RfRnVuY3Rpb24sIGZhbHNlLCAhIWFzeW5jKTtcXG4gICAgICAgICAgICBmdW5jLnN0YXJ0ID0gc3RhcnQ7XFxuICAgICAgICAgICAgZnVuYy5lbmQgPSBwcmV2KCk7XFxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZnVuYywgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGFzeW5jKSByZXR1cm4gc3Vic2NyaXB0cyhhc3luYywgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgaWYgKGlzKFxcXCJrZXl3b3JkXFxcIiwgXFxcImNsYXNzXFxcIikpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgdmFyIGNscyA9IGNsYXNzXyhBU1RfQ2xhc3NFeHByZXNzaW9uKTtcXG4gICAgICAgICAgICBjbHMuc3RhcnQgPSBzdGFydDtcXG4gICAgICAgICAgICBjbHMuZW5kID0gcHJldigpO1xcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGNscywgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzKFxcXCJ0ZW1wbGF0ZV9oZWFkXFxcIikpIHtcXG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyh0ZW1wbGF0ZV9zdHJpbmcoKSwgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKEFUT01JQ19TVEFSVF9UT0tFTihTLnRva2VuLnR5cGUpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoYXNfYXRvbV9ub2RlKCksIGFsbG93X2NhbGxzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gdGVtcGxhdGVfc3RyaW5nKCkge1xcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHN0YXJ0ID0gUy50b2tlbjtcXG5cXG4gICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEFTVF9UZW1wbGF0ZVNlZ21lbnQoe1xcbiAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxcbiAgICAgICAgICAgIHJhdzogUy50b2tlbi5yYXcsXFxuICAgICAgICAgICAgdmFsdWU6IFMudG9rZW4udmFsdWUsXFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuXFxuICAgICAgICB9KSk7XFxuICAgICAgICB3aGlsZSAoUy50b2tlbi5lbmQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIGhhbmRsZV9yZWdleHAoKTtcXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGV4cHJlc3Npb24odHJ1ZSkpO1xcblxcbiAgICAgICAgICAgIGlmICghaXNfdG9rZW4oXFxcInRlbXBsYXRlX3N1YnN0aXR1dGlvblxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgQVNUX1RlbXBsYXRlU2VnbWVudCh7XFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxcbiAgICAgICAgICAgICAgICByYXc6IFMudG9rZW4ucmF3LFxcbiAgICAgICAgICAgICAgICB2YWx1ZTogUy50b2tlbi52YWx1ZSxcXG4gICAgICAgICAgICAgICAgZW5kOiBTLnRva2VuXFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV4dCgpO1xcblxcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGVtcGxhdGVTdHJpbmcoe1xcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcXG4gICAgICAgICAgICBzZWdtZW50czogc2VnbWVudHMsXFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuXFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBleHByX2xpc3QoY2xvc2luZywgYWxsb3dfdHJhaWxpbmdfY29tbWEsIGFsbG93X2VtcHR5KSB7XFxuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlLCBhID0gW107XFxuICAgICAgICB3aGlsZSAoIWlzKFxcXCJwdW5jXFxcIiwgY2xvc2luZykpIHtcXG4gICAgICAgICAgICBpZiAoZmlyc3QpIGZpcnN0ID0gZmFsc2U7IGVsc2UgZXhwZWN0KFxcXCIsXFxcIik7XFxuICAgICAgICAgICAgaWYgKGFsbG93X3RyYWlsaW5nX2NvbW1hICYmIGlzKFxcXCJwdW5jXFxcIiwgY2xvc2luZykpIGJyZWFrO1xcbiAgICAgICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIsXFxcIikgJiYgYWxsb3dfZW1wdHkpIHtcXG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfSG9sZSh7IHN0YXJ0OiBTLnRva2VuLCBlbmQ6IFMudG9rZW4gfSkpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXFxcImV4cGFuZFxcXCIsIFxcXCIuLi5cXFwiKSkge1xcbiAgICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgICAgIGEucHVzaChuZXcgQVNUX0V4cGFuc2lvbih7c3RhcnQ6IHByZXYoKSwgZXhwcmVzc2lvbjogZXhwcmVzc2lvbigpLGVuZDogUy50b2tlbn0pKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG5leHQoKTtcXG4gICAgICAgIHJldHVybiBhO1xcbiAgICB9O1xcblxcbiAgICB2YXIgYXJyYXlfID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgZXhwZWN0KFxcXCJbXFxcIik7XFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9BcnJheSh7XFxuICAgICAgICAgICAgZWxlbWVudHM6IGV4cHJfbGlzdChcXFwiXVxcXCIsICFvcHRpb25zLnN0cmljdCwgdHJ1ZSlcXG4gICAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIGNyZWF0ZV9hY2Nlc3NvciA9IGVtYmVkX3Rva2VucyhmdW5jdGlvbihpc19nZW5lcmF0b3IsIGlzX2FzeW5jKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb25fKEFTVF9BY2Nlc3NvciwgaXNfZ2VuZXJhdG9yLCBpc19hc3luYyk7XFxuICAgIH0pO1xcblxcbiAgICB2YXIgb2JqZWN0X29yX2Rlc3RydWN0dXJpbmdfID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uIG9iamVjdF9vcl9kZXN0cnVjdHVyaW5nXygpIHtcXG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW4sIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xcbiAgICAgICAgZXhwZWN0KFxcXCJ7XFxcIik7XFxuICAgICAgICB3aGlsZSAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIn1cXFwiKSkge1xcbiAgICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTsgZWxzZSBleHBlY3QoXFxcIixcXFwiKTtcXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzKFxcXCJwdW5jXFxcIiwgXFxcIn1cXFwiKSlcXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdHJhaWxpbmcgY29tbWFcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xcbiAgICAgICAgICAgIGlmIChzdGFydC50eXBlID09IFxcXCJleHBhbmRcXFwiKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfRXhwYW5zaW9uKHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24oZmFsc2UpLFxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KCksXFxuICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXNfcHJvcGVydHlfbmFtZSgpO1xcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcXG5cXG4gICAgICAgICAgICAvLyBDaGVjayBwcm9wZXJ0eSBhbmQgZmV0Y2ggdmFsdWVcXG4gICAgICAgICAgICBpZiAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIjpcXFwiKSkge1xcbiAgICAgICAgICAgICAgICB2YXIgY29uY2lzZSA9IGNvbmNpc2VfbWV0aG9kX29yX2dldHNldChuYW1lLCBzdGFydCk7XFxuICAgICAgICAgICAgICAgIGlmIChjb25jaXNlKSB7XFxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goY29uY2lzZSk7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBBU1RfU3ltYm9sUmVmKHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQocHJldigpKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBuZXh0KCk7IC8vIGA6YCAtIHNlZSBmaXJzdCBjb25kaXRpb25cXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBleHByZXNzaW9uKGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlZmF1bHQgdmFsdWUgYW5kIGFsdGVyIHZhbHVlIGFjY29yZGluZ2x5IGlmIG5lY2Vzc2FyeVxcbiAgICAgICAgICAgIGlmIChpcyhcXFwib3BlcmF0b3JcXFwiLCBcXFwiPVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQVNUX0Fzc2lnbih7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB2YWx1ZSxcXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcXFwiPVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZXhwcmVzc2lvbihmYWxzZSksXFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHByb3BlcnR5XFxuICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfT2JqZWN0S2V5VmFsKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICBxdW90ZTogc3RhcnQucXVvdGUsXFxuICAgICAgICAgICAgICAgIGtleTogbmFtZSBpbnN0YW5jZW9mIEFTVF9Ob2RlID8gbmFtZSA6IFxcXCJcXFwiICsgbmFtZSxcXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgIH1cXG4gICAgICAgIG5leHQoKTtcXG4gICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdCh7IHByb3BlcnRpZXM6IGEgfSlcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGNsYXNzXyhLaW5kT2ZDbGFzcykge1xcbiAgICAgICAgdmFyIHN0YXJ0LCBtZXRob2QsIGNsYXNzX25hbWUsIGV4dGVuZHNfLCBhID0gW107XFxuXFxuICAgICAgICBTLmlucHV0LnB1c2hfZGlyZWN0aXZlc19zdGFjaygpOyAvLyBQdXNoIGRpcmVjdGl2ZSBzdGFjaywgYnV0IG5vdCBzY29wZSBzdGFja1xcbiAgICAgICAgUy5pbnB1dC5hZGRfZGlyZWN0aXZlKFxcXCJ1c2Ugc3RyaWN0XFxcIik7XFxuXFxuICAgICAgICBpZiAoUy50b2tlbi50eXBlID09IFxcXCJuYW1lXFxcIiAmJiBTLnRva2VuLnZhbHVlICE9IFxcXCJleHRlbmRzXFxcIikge1xcbiAgICAgICAgICAgIGNsYXNzX25hbWUgPSBhc19zeW1ib2woS2luZE9mQ2xhc3MgPT09IEFTVF9EZWZDbGFzcyA/IEFTVF9TeW1ib2xEZWZDbGFzcyA6IEFTVF9TeW1ib2xDbGFzcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoS2luZE9mQ2xhc3MgPT09IEFTVF9EZWZDbGFzcyAmJiAhY2xhc3NfbmFtZSkge1xcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChTLnRva2VuLnZhbHVlID09IFxcXCJleHRlbmRzXFxcIikge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICBleHRlbmRzXyA9IGV4cHJlc3Npb24odHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBleHBlY3QoXFxcIntcXFwiKTtcXG5cXG4gICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCI7XFxcIikpIHsgbmV4dCgpOyB9ICAvLyBMZWFkaW5nIHNlbWljb2xvbnMgYXJlIG9rYXkgaW4gY2xhc3MgYm9kaWVzLlxcbiAgICAgICAgd2hpbGUgKCFpcyhcXFwicHVuY1xcXCIsIFxcXCJ9XFxcIikpIHtcXG4gICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XFxuICAgICAgICAgICAgbWV0aG9kID0gY29uY2lzZV9tZXRob2Rfb3JfZ2V0c2V0KGFzX3Byb3BlcnR5X25hbWUoKSwgc3RhcnQsIHRydWUpO1xcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7IHVuZXhwZWN0ZWQoKTsgfVxcbiAgICAgICAgICAgIGEucHVzaChtZXRob2QpO1xcbiAgICAgICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCI7XFxcIikpIHsgbmV4dCgpOyB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBTLmlucHV0LnBvcF9kaXJlY3RpdmVzX3N0YWNrKCk7XFxuXFxuICAgICAgICBuZXh0KCk7XFxuXFxuICAgICAgICByZXR1cm4gbmV3IEtpbmRPZkNsYXNzKHtcXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgbmFtZTogY2xhc3NfbmFtZSxcXG4gICAgICAgICAgICBleHRlbmRzOiBleHRlbmRzXyxcXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBhLFxcbiAgICAgICAgICAgIGVuZDogcHJldigpLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY29uY2lzZV9tZXRob2Rfb3JfZ2V0c2V0KG5hbWUsIHN0YXJ0LCBpc19jbGFzcykge1xcbiAgICAgICAgdmFyIGdldF9hc3QgPSBmdW5jdGlvbihuYW1lLCB0b2tlbikge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXFxcInN0cmluZ1xcXCIgfHwgdHlwZW9mIG5hbWUgPT09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1N5bWJvbE1ldGhvZCh7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdG9rZW4sXFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcXFwiXFxcIiArIG5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBpc19hc3luYyA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGlzX3N0YXRpYyA9IGZhbHNlO1xcbiAgICAgICAgdmFyIGlzX2dlbmVyYXRvciA9IGZhbHNlO1xcbiAgICAgICAgdmFyIHByb3BlcnR5X3Rva2VuID0gc3RhcnQ7XFxuICAgICAgICBpZiAoaXNfY2xhc3MgJiYgbmFtZSA9PT0gXFxcInN0YXRpY1xcXCIgJiYgIWlzKFxcXCJwdW5jXFxcIiwgXFxcIihcXFwiKSkge1xcbiAgICAgICAgICAgIGlzX3N0YXRpYyA9IHRydWU7XFxuICAgICAgICAgICAgcHJvcGVydHlfdG9rZW4gPSBTLnRva2VuO1xcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAobmFtZSA9PT0gXFxcImFzeW5jXFxcIiAmJiAhaXMoXFxcInB1bmNcXFwiLCBcXFwiKFxcXCIpICYmICFpcyhcXFwicHVuY1xcXCIsIFxcXCIsXFxcIikgJiYgIWlzKFxcXCJwdW5jXFxcIiwgXFxcIn1cXFwiKSkge1xcbiAgICAgICAgICAgIGlzX2FzeW5jID0gdHJ1ZTtcXG4gICAgICAgICAgICBwcm9wZXJ0eV90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICAgICAgbmFtZSA9IGFzX3Byb3BlcnR5X25hbWUoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XFxuICAgICAgICAgICAgaXNfZ2VuZXJhdG9yID0gdHJ1ZTtcXG4gICAgICAgICAgICBwcm9wZXJ0eV90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICAgICAgbmFtZSA9IGFzX3Byb3BlcnR5X25hbWUoKTtcXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIihcXFwiKSkge1xcbiAgICAgICAgICAgIG5hbWUgPSBnZXRfYXN0KG5hbWUsIHN0YXJ0KTtcXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyBBU1RfQ29uY2lzZU1ldGhvZCh7XFxuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXFxuICAgICAgICAgICAgICAgIHN0YXRpYyAgICAgIDogaXNfc3RhdGljLFxcbiAgICAgICAgICAgICAgICBpc19nZW5lcmF0b3I6IGlzX2dlbmVyYXRvcixcXG4gICAgICAgICAgICAgICAgYXN5bmMgICAgICAgOiBpc19hc3luYyxcXG4gICAgICAgICAgICAgICAga2V5ICAgICAgICAgOiBuYW1lLFxcbiAgICAgICAgICAgICAgICBxdW90ZSAgICAgICA6IG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kID9cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eV90b2tlbi5xdW90ZSA6IHVuZGVmaW5lZCxcXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgOiBjcmVhdGVfYWNjZXNzb3IoaXNfZ2VuZXJhdG9yLCBpc19hc3luYyksXFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogcHJldigpXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgICAgICB9XFxuICAgICAgICBwcm9wZXJ0eV90b2tlbiA9IFMudG9rZW47XFxuICAgICAgICBpZiAobmFtZSA9PSBcXFwiZ2V0XFxcIikge1xcbiAgICAgICAgICAgIGlmICghaXMoXFxcInB1bmNcXFwiKSB8fCBpcyhcXFwicHVuY1xcXCIsIFxcXCJbXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgbmFtZSA9IGdldF9hc3QoYXNfcHJvcGVydHlfbmFtZSgpLCBzdGFydCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdEdldHRlcih7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydCA6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBpc19zdGF0aWMsXFxuICAgICAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBxdW90ZSA6IG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kID9cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlfdG9rZW4ucXVvdGUgOiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IGNyZWF0ZV9hY2Nlc3NvcigpLFxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcXFwic2V0XFxcIikge1xcbiAgICAgICAgICAgIGlmICghaXMoXFxcInB1bmNcXFwiKSB8fCBpcyhcXFwicHVuY1xcXCIsIFxcXCJbXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgbmFtZSA9IGdldF9hc3QoYXNfcHJvcGVydHlfbmFtZSgpLCBzdGFydCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX09iamVjdFNldHRlcih7XFxuICAgICAgICAgICAgICAgICAgICBzdGFydCA6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljOiBpc19zdGF0aWMsXFxuICAgICAgICAgICAgICAgICAgICBrZXkgICA6IG5hbWUsXFxuICAgICAgICAgICAgICAgICAgICBxdW90ZSA6IG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kID9cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlfdG9rZW4ucXVvdGUgOiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IGNyZWF0ZV9hY2Nlc3NvcigpLFxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGltcG9ydF8oKSB7XFxuICAgICAgICB2YXIgc3RhcnQgPSBwcmV2KCk7XFxuICAgICAgICB2YXIgaW1wb3J0ZWRfbmFtZTtcXG4gICAgICAgIHZhciBpbXBvcnRlZF9uYW1lcztcXG4gICAgICAgIGlmIChpcyhcXFwibmFtZVxcXCIpKSB7XFxuICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZSA9IGFzX3N5bWJvbChBU1RfU3ltYm9sSW1wb3J0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIsXFxcIikpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbXBvcnRlZF9uYW1lcyA9IG1hcF9uYW1lcyh0cnVlKTtcXG5cXG4gICAgICAgIGlmIChpbXBvcnRlZF9uYW1lcyB8fCBpbXBvcnRlZF9uYW1lKSB7XFxuICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFxcXCJuYW1lXFxcIiwgXFxcImZyb21cXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBtb2Rfc3RyID0gUy50b2tlbjtcXG4gICAgICAgIGlmIChtb2Rfc3RyLnR5cGUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfSW1wb3J0KHtcXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZTogaW1wb3J0ZWRfbmFtZSxcXG4gICAgICAgICAgICBpbXBvcnRlZF9uYW1lczogaW1wb3J0ZWRfbmFtZXMsXFxuICAgICAgICAgICAgbW9kdWxlX25hbWU6IG5ldyBBU1RfU3RyaW5nKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1vZF9zdHIsXFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtb2Rfc3RyLnZhbHVlLFxcbiAgICAgICAgICAgICAgICBxdW90ZTogbW9kX3N0ci5xdW90ZSxcXG4gICAgICAgICAgICAgICAgZW5kOiBtb2Rfc3RyLFxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIGVuZDogUy50b2tlbixcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG1hcF9uYW1lKGlzX2ltcG9ydCkge1xcbiAgICAgICAgZnVuY3Rpb24gbWFrZV9zeW1ib2wodHlwZSkge1xcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZSh7XFxuICAgICAgICAgICAgICAgIG5hbWU6IGFzX3Byb3BlcnR5X25hbWUoKSxcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHByZXYoKSxcXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBmb3JlaWduX3R5cGUgPSBpc19pbXBvcnQgPyBBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbiA6IEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduO1xcbiAgICAgICAgdmFyIHR5cGUgPSBpc19pbXBvcnQgPyBBU1RfU3ltYm9sSW1wb3J0IDogQVNUX1N5bWJvbEV4cG9ydDtcXG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XFxuICAgICAgICB2YXIgZm9yZWlnbl9uYW1lO1xcbiAgICAgICAgdmFyIG5hbWU7XFxuXFxuICAgICAgICBpZiAoaXNfaW1wb3J0KSB7XFxuICAgICAgICAgICAgZm9yZWlnbl9uYW1lID0gbWFrZV9zeW1ib2woZm9yZWlnbl90eXBlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgbmFtZSA9IG1ha2Vfc3ltYm9sKHR5cGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGlzKFxcXCJuYW1lXFxcIiwgXFxcImFzXFxcIikpIHtcXG4gICAgICAgICAgICBuZXh0KCk7ICAvLyBUaGUgXFxcImFzXFxcIiB3b3JkXFxuICAgICAgICAgICAgaWYgKGlzX2ltcG9ydCkge1xcbiAgICAgICAgICAgICAgICBuYW1lID0gbWFrZV9zeW1ib2wodHlwZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZm9yZWlnbl9uYW1lID0gbWFrZV9zeW1ib2woZm9yZWlnbl90eXBlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGlzX2ltcG9ydCkge1xcbiAgICAgICAgICAgIG5hbWUgPSBuZXcgdHlwZShmb3JlaWduX25hbWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3JlaWduX25hbWUgPSBuZXcgZm9yZWlnbl90eXBlKG5hbWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfTmFtZU1hcHBpbmcoe1xcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcXG4gICAgICAgICAgICBmb3JlaWduX25hbWU6IGZvcmVpZ25fbmFtZSxcXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxcbiAgICAgICAgICAgIGVuZDogcHJldigpLFxcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBtYXBfbmFtZUFzdGVyaXNrKGlzX2ltcG9ydCwgbmFtZSkge1xcbiAgICAgICAgdmFyIGZvcmVpZ25fdHlwZSA9IGlzX2ltcG9ydCA/IEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduIDogQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ247XFxuICAgICAgICB2YXIgdHlwZSA9IGlzX2ltcG9ydCA/IEFTVF9TeW1ib2xJbXBvcnQgOiBBU1RfU3ltYm9sRXhwb3J0O1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcXG4gICAgICAgIHZhciBmb3JlaWduX25hbWU7XFxuICAgICAgICB2YXIgZW5kID0gcHJldigpO1xcblxcbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgbmV3IHR5cGUoe1xcbiAgICAgICAgICAgIG5hbWU6ICcqJyxcXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgZW5kOiBlbmQsXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGZvcmVpZ25fbmFtZSA9IG5ldyBmb3JlaWduX3R5cGUoe1xcbiAgICAgICAgICAgIG5hbWU6ICcqJyxcXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgZW5kOiBlbmQsXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHJldHVybiBuZXcgQVNUX05hbWVNYXBwaW5nKHtcXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgICAgZm9yZWlnbl9uYW1lOiBmb3JlaWduX25hbWUsXFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcXG4gICAgICAgICAgICBlbmQ6IGVuZCxcXG4gICAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWFwX25hbWVzKGlzX2ltcG9ydCkge1xcbiAgICAgICAgdmFyIG5hbWVzO1xcbiAgICAgICAgaWYgKGlzKFxcXCJwdW5jXFxcIiwgXFxcIntcXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xcbiAgICAgICAgICAgIHdoaWxlICghaXMoXFxcInB1bmNcXFwiLCBcXFwifVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobWFwX25hbWUoaXNfaW1wb3J0KSk7XFxuICAgICAgICAgICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIsXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGlzKFxcXCJvcGVyYXRvclxcXCIsIFxcXCIqXFxcIikpIHtcXG4gICAgICAgICAgICB2YXIgbmFtZTtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgaWYgKGlzX2ltcG9ydCAmJiBpcyhcXFwibmFtZVxcXCIsIFxcXCJhc1xcXCIpKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTsgIC8vIFRoZSBcXFwiYXNcXFwiIHdvcmRcXG4gICAgICAgICAgICAgICAgbmFtZSA9IGFzX3N5bWJvbChBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG5hbWVzID0gW21hcF9uYW1lQXN0ZXJpc2soaXNfaW1wb3J0LCBuYW1lKV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbmFtZXM7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZXhwb3J0XygpIHtcXG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XFxuICAgICAgICB2YXIgaXNfZGVmYXVsdDtcXG4gICAgICAgIHZhciBleHBvcnRlZF9uYW1lcztcXG5cXG4gICAgICAgIGlmIChpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJkZWZhdWx0XFxcIikpIHtcXG4gICAgICAgICAgICBpc19kZWZhdWx0ID0gdHJ1ZTtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGV4cG9ydGVkX25hbWVzID0gbWFwX25hbWVzKGZhbHNlKSkge1xcbiAgICAgICAgICAgIGlmIChpcyhcXFwibmFtZVxcXCIsIFxcXCJmcm9tXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgbW9kX3N0ciA9IFMudG9rZW47XFxuICAgICAgICAgICAgICAgIGlmIChtb2Rfc3RyLnR5cGUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICAgICAgaXNfZGVmYXVsdDogaXNfZGVmYXVsdCxcXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkX25hbWVzOiBleHBvcnRlZF9uYW1lcyxcXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV9uYW1lOiBuZXcgQVNUX1N0cmluZyh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG1vZF9zdHIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1vZF9zdHIudmFsdWUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGU6IG1vZF9zdHIucXVvdGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBtb2Rfc3RyLFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKSxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcXG4gICAgICAgICAgICAgICAgICAgIGlzX2RlZmF1bHQ6IGlzX2RlZmF1bHQsXFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZF9uYW1lczogZXhwb3J0ZWRfbmFtZXMsXFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKSxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIG5vZGU7XFxuICAgICAgICB2YXIgZXhwb3J0ZWRfdmFsdWU7XFxuICAgICAgICB2YXIgZXhwb3J0ZWRfZGVmaW5pdGlvbjtcXG4gICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCJ7XFxcIilcXG4gICAgICAgICAgICB8fCBpc19kZWZhdWx0XFxuICAgICAgICAgICAgICAgICYmIChpcyhcXFwia2V5d29yZFxcXCIsIFxcXCJjbGFzc1xcXCIpIHx8IGlzKFxcXCJrZXl3b3JkXFxcIiwgXFxcImZ1bmN0aW9uXFxcIikpXFxuICAgICAgICAgICAgICAgICYmIGlzX3Rva2VuKHBlZWsoKSwgXFxcInB1bmNcXFwiKSkge1xcbiAgICAgICAgICAgIGV4cG9ydGVkX3ZhbHVlID0gZXhwcmVzc2lvbihmYWxzZSk7XFxuICAgICAgICAgICAgc2VtaWNvbG9uKCk7XFxuICAgICAgICB9IGVsc2UgaWYgKChub2RlID0gc3RhdGVtZW50KGlzX2RlZmF1bHQpKSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiBpc19kZWZhdWx0KSB7XFxuICAgICAgICAgICAgdW5leHBlY3RlZChub2RlLnN0YXJ0KTtcXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzKSB7XFxuICAgICAgICAgICAgZXhwb3J0ZWRfZGVmaW5pdGlvbiA9IG5vZGU7XFxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XFxuICAgICAgICAgICAgZXhwb3J0ZWRfdmFsdWUgPSBub2RlLmJvZHk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQobm9kZS5zdGFydCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcXG4gICAgICAgICAgICBpc19kZWZhdWx0OiBpc19kZWZhdWx0LFxcbiAgICAgICAgICAgIGV4cG9ydGVkX3ZhbHVlOiBleHBvcnRlZF92YWx1ZSxcXG4gICAgICAgICAgICBleHBvcnRlZF9kZWZpbml0aW9uOiBleHBvcnRlZF9kZWZpbml0aW9uLFxcbiAgICAgICAgICAgIGVuZDogcHJldigpLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gYXNfcHJvcGVydHlfbmFtZSgpIHtcXG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xcbiAgICAgICAgc3dpdGNoICh0bXAudHlwZSkge1xcbiAgICAgICAgICBjYXNlIFxcXCJwdW5jXFxcIjpcXG4gICAgICAgICAgICBpZiAodG1wLnZhbHVlID09PSBcXFwiW1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgZXggPSBleHByZXNzaW9uKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgZXhwZWN0KFxcXCJdXFxcIik7XFxuICAgICAgICAgICAgICAgIHJldHVybiBleDtcXG4gICAgICAgICAgICB9IGVsc2UgdW5leHBlY3RlZCh0bXApO1xcbiAgICAgICAgICBjYXNlIFxcXCJvcGVyYXRvclxcXCI6XFxuICAgICAgICAgICAgaWYgKHRtcC52YWx1ZSA9PT0gXFxcIipcXFwiKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChbXFxcImRlbGV0ZVxcXCIsIFxcXCJpblxcXCIsIFxcXCJpbnN0YW5jZW9mXFxcIiwgXFxcIm5ld1xcXCIsIFxcXCJ0eXBlb2ZcXFwiLCBcXFwidm9pZFxcXCJdLmluZGV4T2YodG1wLnZhbHVlKSA9PT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCh0bXApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgY2FzZSBcXFwibmFtZVxcXCI6XFxuICAgICAgICAgICAgaWYgKHRtcC52YWx1ZSA9PSBcXFwieWllbGRcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpc19pbl9nZW5lcmF0b3IoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IodG1wLCBcXFwiWWllbGQgY2Fubm90IGJlIHVzZWQgYXMgaWRlbnRpZmllciBpbnNpZGUgZ2VuZXJhdG9yc1xcXCIpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc190b2tlbihwZWVrKCksIFxcXCJwdW5jXFxcIiwgXFxcIjpcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzX3Rva2VuKHBlZWsoKSwgXFxcInB1bmNcXFwiLCBcXFwiKFxcXCIpXFxuICAgICAgICAgICAgICAgICAgICAmJiBTLmlucHV0Lmhhc19kaXJlY3RpdmUoXFxcInVzZSBzdHJpY3RcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IodG1wLCBcXFwiVW5leHBlY3RlZCB5aWVsZCBpZGVudGlmaWVyIGluc2lkZSBzdHJpY3QgbW9kZVxcXCIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBjYXNlIFxcXCJzdHJpbmdcXFwiOlxcbiAgICAgICAgICBjYXNlIFxcXCJudW1cXFwiOlxcbiAgICAgICAgICBjYXNlIFxcXCJrZXl3b3JkXFxcIjpcXG4gICAgICAgICAgY2FzZSBcXFwiYXRvbVxcXCI6XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIHJldHVybiB0bXAudmFsdWU7XFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgdW5leHBlY3RlZCh0bXApO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBhc19uYW1lKCkge1xcbiAgICAgICAgdmFyIHRtcCA9IFMudG9rZW47XFxuICAgICAgICBpZiAodG1wLnR5cGUgIT0gXFxcIm5hbWVcXFwiKSB1bmV4cGVjdGVkKCk7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgICByZXR1cm4gdG1wLnZhbHVlO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBfbWFrZV9zeW1ib2wodHlwZSkge1xcbiAgICAgICAgdmFyIG5hbWUgPSBTLnRva2VuLnZhbHVlO1xcbiAgICAgICAgcmV0dXJuIG5ldyAobmFtZSA9PSBcXFwidGhpc1xcXCIgPyBBU1RfVGhpcyA6XFxuICAgICAgICAgICAgICAgICAgICBuYW1lID09IFxcXCJzdXBlclxcXCIgPyBBU1RfU3VwZXIgOlxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSkoe1xcbiAgICAgICAgICAgIG5hbWUgIDogU3RyaW5nKG5hbWUpLFxcbiAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcXG4gICAgICAgICAgICBlbmQgICA6IFMudG9rZW5cXG4gICAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBfdmVyaWZ5X3N5bWJvbChzeW0pIHtcXG4gICAgICAgIHZhciBuYW1lID0gc3ltLm5hbWU7XFxuICAgICAgICBpZiAoaXNfaW5fZ2VuZXJhdG9yKCkgJiYgbmFtZSA9PSBcXFwieWllbGRcXFwiKSB7XFxuICAgICAgICAgICAgdG9rZW5fZXJyb3Ioc3ltLnN0YXJ0LCBcXFwiWWllbGQgY2Fubm90IGJlIHVzZWQgYXMgaWRlbnRpZmllciBpbnNpZGUgZ2VuZXJhdG9yc1xcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcXFwidXNlIHN0cmljdFxcXCIpKSB7XFxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXFxcInlpZWxkXFxcIikge1xcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihzeW0uc3RhcnQsIFxcXCJVbmV4cGVjdGVkIHlpZWxkIGlkZW50aWZpZXIgaW5zaWRlIHN0cmljdCBtb2RlXFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24gJiYgKG5hbWUgPT0gXFxcImFyZ3VtZW50c1xcXCIgfHwgbmFtZSA9PSBcXFwiZXZhbFxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKHN5bS5zdGFydCwgXFxcIlVuZXhwZWN0ZWQgXFxcIiArIG5hbWUgKyBcXFwiIGluIHN0cmljdCBtb2RlXFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGFzX3N5bWJvbCh0eXBlLCBub2Vycm9yKSB7XFxuICAgICAgICBpZiAoIWlzKFxcXCJuYW1lXFxcIikpIHtcXG4gICAgICAgICAgICBpZiAoIW5vZXJyb3IpIGNyb2FrKFxcXCJOYW1lIGV4cGVjdGVkXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgc3ltID0gX21ha2Vfc3ltYm9sKHR5cGUpO1xcbiAgICAgICAgX3ZlcmlmeV9zeW1ib2woc3ltKTtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICAgIHJldHVybiBzeW07XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIG1hcmtfcHVyZShjYWxsKSB7XFxuICAgICAgICB2YXIgc3RhcnQgPSBjYWxsLnN0YXJ0O1xcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gc3RhcnQuY29tbWVudHNfYmVmb3JlO1xcbiAgICAgICAgdmFyIGkgPSBIT1Aoc3RhcnQsIFxcXCJjb21tZW50c19iZWZvcmVfbGVuZ3RoXFxcIikgPyBzdGFydC5jb21tZW50c19iZWZvcmVfbGVuZ3RoIDogY29tbWVudHMubGVuZ3RoO1xcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XFxuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBjb21tZW50c1tpXTtcXG4gICAgICAgICAgICBpZiAoL1tAI11fX1BVUkVfXy8udGVzdChjb21tZW50LnZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICBjYWxsLnB1cmUgPSBjb21tZW50O1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHN1YnNjcmlwdHMgPSBmdW5jdGlvbihleHByLCBhbGxvd19jYWxscykge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXhwci5zdGFydDtcXG4gICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIuXFxcIikpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9Eb3Qoe1xcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByLFxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogYXNfbmFtZSgpLFxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXFxuICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCJbXFxcIikpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgdmFyIHByb3AgPSBleHByZXNzaW9uKHRydWUpO1xcbiAgICAgICAgICAgIGV4cGVjdChcXFwiXVxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfU3ViKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IHByb3AsXFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGFsbG93X2NhbGxzICYmIGlzKFxcXCJwdW5jXFxcIiwgXFxcIihcXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICB2YXIgY2FsbCA9IG5ldyBBU1RfQ2FsbCh7XFxuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXFxuICAgICAgICAgICAgICAgIGFyZ3MgICAgICAgOiBjYWxsX2FyZ3MoKSxcXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIG1hcmtfcHVyZShjYWxsKTtcXG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhjYWxsLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpcyhcXFwidGVtcGxhdGVfaGVhZFxcXCIpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGV4cHIsXFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlX3N0cmluZzogdGVtcGxhdGVfc3RyaW5nKClcXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGV4cHI7XFxuICAgIH07XFxuXFxuICAgIHZhciBjYWxsX2FyZ3MgPSBlbWJlZF90b2tlbnMoZnVuY3Rpb24gX2NhbGxfYXJncygpIHtcXG4gICAgICAgIHZhciBhcmdzID0gW107XFxuICAgICAgICB3aGlsZSAoIWlzKFxcXCJwdW5jXFxcIiwgXFxcIilcXFwiKSkge1xcbiAgICAgICAgICAgIGlmIChpcyhcXFwiZXhwYW5kXFxcIiwgXFxcIi4uLlxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG5ldyBBU1RfRXhwYW5zaW9uKHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uKGZhbHNlKVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24oZmFsc2UpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKCFpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgZXhwZWN0KFxcXCIsXFxcIik7XFxuICAgICAgICAgICAgICAgIGlmIChpcyhcXFwicHVuY1xcXCIsIFxcXCIpXFxcIikgJiYgb3B0aW9ucy5lY21hIDwgOCkgdW5leHBlY3RlZCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG5leHQoKTtcXG4gICAgICAgIHJldHVybiBhcmdzO1xcbiAgICB9KTtcXG5cXG4gICAgdmFyIG1heWJlX3VuYXJ5ID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMsIGFsbG93X2Fycm93cykge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcXG4gICAgICAgIGlmIChzdGFydC50eXBlID09IFxcXCJuYW1lXFxcIiAmJiBzdGFydC52YWx1ZSA9PSBcXFwiYXdhaXRcXFwiKSB7XFxuICAgICAgICAgICAgaWYgKGlzX2luX2FzeW5jKCkpIHtcXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2F3YWl0X2V4cHJlc3Npb24oKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcXFwidXNlIHN0cmljdFxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFxcXCJVbmV4cGVjdGVkIGF3YWl0IGlkZW50aWZpZXIgaW5zaWRlIHN0cmljdCBtb2RlXFxcIilcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXMoXFxcIm9wZXJhdG9yXFxcIikgJiYgVU5BUllfUFJFRklYKHN0YXJ0LnZhbHVlKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICBoYW5kbGVfcmVnZXhwKCk7XFxuICAgICAgICAgICAgdmFyIGV4ID0gbWFrZV91bmFyeShBU1RfVW5hcnlQcmVmaXgsIHN0YXJ0LCBtYXliZV91bmFyeShhbGxvd19jYWxscykpO1xcbiAgICAgICAgICAgIGV4LnN0YXJ0ID0gc3RhcnQ7XFxuICAgICAgICAgICAgZXguZW5kID0gcHJldigpO1xcbiAgICAgICAgICAgIHJldHVybiBleDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciB2YWwgPSBleHByX2F0b20oYWxsb3dfY2FsbHMsIGFsbG93X2Fycm93cyk7XFxuICAgICAgICB3aGlsZSAoaXMoXFxcIm9wZXJhdG9yXFxcIikgJiYgVU5BUllfUE9TVEZJWChTLnRva2VuLnZhbHVlKSAmJiAhaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKSB7XFxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFTVF9BcnJvdykgdW5leHBlY3RlZCgpO1xcbiAgICAgICAgICAgIHZhbCA9IG1ha2VfdW5hcnkoQVNUX1VuYXJ5UG9zdGZpeCwgUy50b2tlbiwgdmFsKTtcXG4gICAgICAgICAgICB2YWwuc3RhcnQgPSBzdGFydDtcXG4gICAgICAgICAgICB2YWwuZW5kID0gUy50b2tlbjtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdmFsO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBtYWtlX3VuYXJ5KGN0b3IsIHRva2VuLCBleHByKSB7XFxuICAgICAgICB2YXIgb3AgPSB0b2tlbi52YWx1ZTtcXG4gICAgICAgIHN3aXRjaCAob3ApIHtcXG4gICAgICAgICAgY2FzZSBcXFwiKytcXFwiOlxcbiAgICAgICAgICBjYXNlIFxcXCItLVxcXCI6XFxuICAgICAgICAgICAgaWYgKCFpc19hc3NpZ25hYmxlKGV4cHIpKVxcbiAgICAgICAgICAgICAgICBjcm9hayhcXFwiSW52YWxpZCB1c2Ugb2YgXFxcIiArIG9wICsgXFxcIiBvcGVyYXRvclxcXCIsIHRva2VuLmxpbmUsIHRva2VuLmNvbCwgdG9rZW4ucG9zKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSBcXFwiZGVsZXRlXFxcIjpcXG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFxcXCJ1c2Ugc3RyaWN0XFxcIikpXFxuICAgICAgICAgICAgICAgIGNyb2FrKFxcXCJDYWxsaW5nIGRlbGV0ZSBvbiBleHByZXNzaW9uIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXFxcIiwgZXhwci5zdGFydC5saW5lLCBleHByLnN0YXJ0LmNvbCwgZXhwci5zdGFydC5wb3MpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHsgb3BlcmF0b3I6IG9wLCBleHByZXNzaW9uOiBleHByIH0pO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZXhwcl9vcCA9IGZ1bmN0aW9uKGxlZnQsIG1pbl9wcmVjLCBub19pbikge1xcbiAgICAgICAgdmFyIG9wID0gaXMoXFxcIm9wZXJhdG9yXFxcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcXG4gICAgICAgIGlmIChvcCA9PSBcXFwiaW5cXFwiICYmIG5vX2luKSBvcCA9IG51bGw7XFxuICAgICAgICBpZiAob3AgPT0gXFxcIioqXFxcIiAmJiBsZWZ0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XFxuICAgICAgICAgICAgLyogdW5hcnkgdG9rZW4gaW4gZnJvbnQgbm90IGFsbG93ZWQgLSBwYXJlbnRoZXNpcyByZXF1aXJlZCAqL1xcbiAgICAgICAgICAgICYmICFpc190b2tlbihsZWZ0LnN0YXJ0LCBcXFwicHVuY1xcXCIsIFxcXCIoXFxcIilcXG4gICAgICAgICAgICAmJiBsZWZ0Lm9wZXJhdG9yICE9PSBcXFwiLS1cXFwiICYmIGxlZnQub3BlcmF0b3IgIT09IFxcXCIrK1xcXCIpXFxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQobGVmdC5zdGFydCk7XFxuICAgICAgICB2YXIgcHJlYyA9IG9wICE9IG51bGwgPyBQUkVDRURFTkNFW29wXSA6IG51bGw7XFxuICAgICAgICBpZiAocHJlYyAhPSBudWxsICYmIChwcmVjID4gbWluX3ByZWMgfHwgKG9wID09PSBcXFwiKipcXFwiICYmIG1pbl9wcmVjID09PSBwcmVjKSkpIHtcXG4gICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gZXhwcl9vcChtYXliZV91bmFyeSh0cnVlKSwgcHJlYywgbm9faW4pO1xcbiAgICAgICAgICAgIHJldHVybiBleHByX29wKG5ldyBBU1RfQmluYXJ5KHtcXG4gICAgICAgICAgICAgICAgc3RhcnQgICAgOiBsZWZ0LnN0YXJ0LFxcbiAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IGxlZnQsXFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogb3AsXFxuICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogcmlnaHQsXFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogcmlnaHQuZW5kXFxuICAgICAgICAgICAgfSksIG1pbl9wcmVjLCBub19pbik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbGVmdDtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gZXhwcl9vcHMobm9faW4pIHtcXG4gICAgICAgIHJldHVybiBleHByX29wKG1heWJlX3VuYXJ5KHRydWUsIHRydWUpLCAwLCBub19pbik7XFxuICAgIH07XFxuXFxuICAgIHZhciBtYXliZV9jb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vX2luKSB7XFxuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xcbiAgICAgICAgdmFyIGV4cHIgPSBleHByX29wcyhub19pbik7XFxuICAgICAgICBpZiAoaXMoXFxcIm9wZXJhdG9yXFxcIiwgXFxcIj9cXFwiKSkge1xcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICB2YXIgeWVzID0gZXhwcmVzc2lvbihmYWxzZSk7XFxuICAgICAgICAgICAgZXhwZWN0KFxcXCI6XFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uZGl0aW9uYWwoe1xcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICA6IHN0YXJ0LFxcbiAgICAgICAgICAgICAgICBjb25kaXRpb24gICA6IGV4cHIsXFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogeWVzLFxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSxcXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBleHByO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBpc19hc3NpZ25hYmxlKGV4cHIpIHtcXG4gICAgICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgfHwgZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWY7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHRvX2Rlc3RydWN0dXJpbmcobm9kZSkge1xcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSB7XFxuICAgICAgICAgICAgbm9kZSA9IG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLnN0YXJ0LFxcbiAgICAgICAgICAgICAgICBuYW1lczogbm9kZS5wcm9wZXJ0aWVzLm1hcCh0b19kZXN0cnVjdHVyaW5nKSxcXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuZW5kXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXJyYXkpIHtcXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBbXTtcXG5cXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgLy8gT25seSBhbGxvdyBleHBhbnNpb24gYXMgbGFzdCBlbGVtZW50XFxuICAgICAgICAgICAgICAgIGlmIChub2RlLmVsZW1lbnRzW2ldIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSBub2RlLmVsZW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKG5vZGUuZWxlbWVudHNbaV0uc3RhcnQsIFxcXCJTcHJlYWQgbXVzdCB0aGUgYmUgbGFzdCBlbGVtZW50IGluIGRlc3RydWN0dXJpbmcgYXJyYXlcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudHNbaV0uZXhwcmVzc2lvbiA9IHRvX2Rlc3RydWN0dXJpbmcobm9kZS5lbGVtZW50c1tpXS5leHByZXNzaW9uKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHRvX2Rlc3RydWN0dXJpbmcobm9kZS5lbGVtZW50c1tpXSkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBub2RlID0gbmV3IEFTVF9EZXN0cnVjdHVyaW5nKHtcXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuc3RhcnQsXFxuICAgICAgICAgICAgICAgIG5hbWVzOiBuYW1lcyxcXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IHRydWUsXFxuICAgICAgICAgICAgICAgIGVuZDogbm9kZS5lbmRcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSkge1xcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB0b19kZXN0cnVjdHVyaW5nKG5vZGUudmFsdWUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQVNUX0RlZmF1bHRBc3NpZ24oe1xcbiAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5zdGFydCxcXG4gICAgICAgICAgICAgICAgbGVmdDogbm9kZS5sZWZ0LFxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXFxcIj1cXFwiLFxcbiAgICAgICAgICAgICAgICByaWdodDogbm9kZS5yaWdodCxcXG4gICAgICAgICAgICAgICAgZW5kOiBub2RlLmVuZFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5vZGU7XFxuICAgIH1cXG5cXG4gICAgLy8gSW4gRVM2LCBBc3NpZ25tZW50RXhwcmVzc2lvbiBjYW4gYWxzbyBiZSBhbiBBcnJvd0Z1bmN0aW9uXFxuICAgIHZhciBtYXliZV9hc3NpZ24gPSBmdW5jdGlvbihub19pbikge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcXG5cXG4gICAgICAgIGlmIChzdGFydC50eXBlID09IFxcXCJuYW1lXFxcIiAmJiBzdGFydC52YWx1ZSA9PSBcXFwieWllbGRcXFwiKSB7XFxuICAgICAgICAgICAgaWYgKGlzX2luX2dlbmVyYXRvcigpKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF95aWVsZF9leHByZXNzaW9uKCk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChTLmlucHV0Lmhhc19kaXJlY3RpdmUoXFxcInVzZSBzdHJpY3RcXFwiKSkge1xcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihTLnRva2VuLCBcXFwiVW5leHBlY3RlZCB5aWVsZCBpZGVudGlmaWVyIGluc2lkZSBzdHJpY3QgbW9kZVxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBsZWZ0ID0gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pO1xcbiAgICAgICAgdmFyIHZhbCA9IFMudG9rZW4udmFsdWU7XFxuXFxuICAgICAgICBpZiAoaXMoXFxcIm9wZXJhdG9yXFxcIikgJiYgQVNTSUdOTUVOVCh2YWwpKSB7XFxuICAgICAgICAgICAgaWYgKGlzX2Fzc2lnbmFibGUobGVmdCkgfHwgKGxlZnQgPSB0b19kZXN0cnVjdHVyaW5nKGxlZnQpKSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSB7XFxuICAgICAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQXNzaWduKHtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogc3RhcnQsXFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IGxlZnQsXFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IHZhbCxcXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogbWF5YmVfYXNzaWduKG5vX2luKSxcXG4gICAgICAgICAgICAgICAgICAgIGVuZCAgICAgIDogcHJldigpXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjcm9hayhcXFwiSW52YWxpZCBhc3NpZ25tZW50XFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbGVmdDtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGV4cHJlc3Npb24gPSBmdW5jdGlvbihjb21tYXMsIG5vX2luKSB7XFxuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xcbiAgICAgICAgdmFyIGV4cHJzID0gW107XFxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgICAgICAgIGV4cHJzLnB1c2gobWF5YmVfYXNzaWduKG5vX2luKSk7XFxuICAgICAgICAgICAgaWYgKCFjb21tYXMgfHwgIWlzKFxcXCJwdW5jXFxcIiwgXFxcIixcXFwiKSkgYnJlYWs7XFxuICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIGNvbW1hcyA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IG5ldyBBU1RfU2VxdWVuY2Uoe1xcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogc3RhcnQsXFxuICAgICAgICAgICAgZXhwcmVzc2lvbnMgOiBleHBycyxcXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHBlZWsoKVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGluX2xvb3AoY29udCkge1xcbiAgICAgICAgKytTLmluX2xvb3A7XFxuICAgICAgICB2YXIgcmV0ID0gY29udCgpO1xcbiAgICAgICAgLS1TLmluX2xvb3A7XFxuICAgICAgICByZXR1cm4gcmV0O1xcbiAgICB9O1xcblxcbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uKSB7XFxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbih0cnVlKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gKGZ1bmN0aW9uKCl7XFxuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcXG4gICAgICAgIFMuaW5wdXQucHVzaF9kaXJlY3RpdmVzX3N0YWNrKCk7XFxuICAgICAgICB3aGlsZSAoIWlzKFxcXCJlb2ZcXFwiKSlcXG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KCkpO1xcbiAgICAgICAgUy5pbnB1dC5wb3BfZGlyZWN0aXZlc19zdGFjaygpO1xcbiAgICAgICAgdmFyIGVuZCA9IHByZXYoKTtcXG4gICAgICAgIHZhciB0b3BsZXZlbCA9IG9wdGlvbnMudG9wbGV2ZWw7XFxuICAgICAgICBpZiAodG9wbGV2ZWwpIHtcXG4gICAgICAgICAgICB0b3BsZXZlbC5ib2R5ID0gdG9wbGV2ZWwuYm9keS5jb25jYXQoYm9keSk7XFxuICAgICAgICAgICAgdG9wbGV2ZWwuZW5kID0gZW5kO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0b3BsZXZlbCA9IG5ldyBBU1RfVG9wbGV2ZWwoeyBzdGFydDogc3RhcnQsIGJvZHk6IGJvZHksIGVuZDogZW5kIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRvcGxldmVsO1xcbiAgICB9KSgpO1xcblxcbn07XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/parse.js\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/utils.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/utils.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"/***********************************************************************\\n\\n  A JavaScript tokenizer / parser / beautifier / compressor.\\n  https://github.com/mishoo/UglifyJS2\\n\\n  -------------------------------- (C) ---------------------------------\\n\\n                           Author: Mihai Bazon\\n                         <mihai.bazon@gmail.com>\\n                       http://mihai.bazon.net/blog\\n\\n  Distributed under the BSD license:\\n\\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\\n\\n    Redistribution and use in source and binary forms, with or without\\n    modification, are permitted provided that the following conditions\\n    are met:\\n\\n        * Redistributions of source code must retain the above\\n          copyright notice, this list of conditions and the following\\n          disclaimer.\\n\\n        * Redistributions in binary form must reproduce the above\\n          copyright notice, this list of conditions and the following\\n          disclaimer in the documentation and/or other materials\\n          provided with the distribution.\\n\\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\\n    SUCH DAMAGE.\\n\\n ***********************************************************************/\\n\\n\\\"use strict\\\";\\n\\nfunction characters(str) {\\n    return str.split(\\\"\\\");\\n};\\n\\nfunction member(name, array) {\\n    return array.indexOf(name) >= 0;\\n};\\n\\nfunction find_if(func, array) {\\n    for (var i = 0, n = array.length; i < n; ++i) {\\n        if (func(array[i]))\\n            return array[i];\\n    }\\n};\\n\\nfunction repeat_string(str, i) {\\n    if (i <= 0) return \\\"\\\";\\n    if (i == 1) return str;\\n    var d = repeat_string(str, i >> 1);\\n    d += d;\\n    if (i & 1) d += str;\\n    return d;\\n};\\n\\nfunction configure_error_stack(fn) {\\n    Object.defineProperty(fn.prototype, \\\"stack\\\", {\\n        get: function() {\\n            var err = new Error(this.message);\\n            err.name = this.name;\\n            try {\\n                throw err;\\n            } catch(e) {\\n                return e.stack;\\n            }\\n        }\\n    });\\n}\\n\\nfunction DefaultsError(msg, defs) {\\n    this.message = msg;\\n    this.defs = defs;\\n};\\nDefaultsError.prototype = Object.create(Error.prototype);\\nDefaultsError.prototype.constructor = DefaultsError;\\nDefaultsError.prototype.name = \\\"DefaultsError\\\";\\nconfigure_error_stack(DefaultsError);\\n\\nDefaultsError.croak = function(msg, defs) {\\n    throw new DefaultsError(msg, defs);\\n};\\n\\nfunction defaults(args, defs, croak) {\\n    if (args === true)\\n        args = {};\\n    var ret = args || {};\\n    if (croak) for (var i in ret) if (HOP(ret, i) && !HOP(defs, i))\\n        DefaultsError.croak(\\\"`\\\" + i + \\\"` is not a supported option\\\", defs);\\n    for (var i in defs) if (HOP(defs, i)) {\\n        ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];\\n    }\\n    return ret;\\n};\\n\\nfunction merge(obj, ext) {\\n    var count = 0;\\n    for (var i in ext) if (HOP(ext, i)) {\\n        obj[i] = ext[i];\\n        count++;\\n    }\\n    return count;\\n};\\n\\nfunction noop() {}\\nfunction return_false() { return false; }\\nfunction return_true() { return true; }\\nfunction return_this() { return this; }\\nfunction return_null() { return null; }\\n\\nvar MAP = (function(){\\n    function MAP(a, f, backwards) {\\n        var ret = [], top = [], i;\\n        function doit() {\\n            var val = f(a[i], i);\\n            var is_last = val instanceof Last;\\n            if (is_last) val = val.v;\\n            if (val instanceof AtTop) {\\n                val = val.v;\\n                if (val instanceof Splice) {\\n                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);\\n                } else {\\n                    top.push(val);\\n                }\\n            }\\n            else if (val !== skip) {\\n                if (val instanceof Splice) {\\n                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);\\n                } else {\\n                    ret.push(val);\\n                }\\n            }\\n            return is_last;\\n        };\\n        if (a instanceof Array) {\\n            if (backwards) {\\n                for (i = a.length; --i >= 0;) if (doit()) break;\\n                ret.reverse();\\n                top.reverse();\\n            } else {\\n                for (i = 0; i < a.length; ++i) if (doit()) break;\\n            }\\n        }\\n        else {\\n            for (i in a) if (HOP(a, i)) if (doit()) break;\\n        }\\n        return top.concat(ret);\\n    };\\n    MAP.at_top = function(val) { return new AtTop(val) };\\n    MAP.splice = function(val) { return new Splice(val) };\\n    MAP.last = function(val) { return new Last(val) };\\n    var skip = MAP.skip = {};\\n    function AtTop(val) { this.v = val };\\n    function Splice(val) { this.v = val };\\n    function Last(val) { this.v = val };\\n    return MAP;\\n})();\\n\\nfunction push_uniq(array, el) {\\n    if (array.indexOf(el) < 0)\\n        array.push(el);\\n};\\n\\nfunction string_template(text, props) {\\n    return text.replace(/\\\\{(.+?)\\\\}/g, function(str, p){\\n        return props && props[p];\\n    });\\n};\\n\\nfunction remove(array, el) {\\n    for (var i = array.length; --i >= 0;) {\\n        if (array[i] === el) array.splice(i, 1);\\n    }\\n};\\n\\nfunction mergeSort(array, cmp) {\\n    if (array.length < 2) return array.slice();\\n    function merge(a, b) {\\n        var r = [], ai = 0, bi = 0, i = 0;\\n        while (ai < a.length && bi < b.length) {\\n            cmp(a[ai], b[bi]) <= 0\\n                ? r[i++] = a[ai++]\\n                : r[i++] = b[bi++];\\n        }\\n        if (ai < a.length) r.push.apply(r, a.slice(ai));\\n        if (bi < b.length) r.push.apply(r, b.slice(bi));\\n        return r;\\n    };\\n    function _ms(a) {\\n        if (a.length <= 1)\\n            return a;\\n        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);\\n        left = _ms(left);\\n        right = _ms(right);\\n        return merge(left, right);\\n    };\\n    return _ms(array);\\n};\\n\\n// this function is taken from Acorn [1], written by Marijn Haverbeke\\n// [1] https://github.com/marijnh/acorn\\nfunction makePredicate(words) {\\n    if (!(words instanceof Array)) words = words.split(\\\" \\\");\\n    var f = \\\"\\\", cats = [];\\n    out: for (var i = 0; i < words.length; ++i) {\\n        for (var j = 0; j < cats.length; ++j)\\n            if (cats[j][0].length == words[i].length) {\\n                cats[j].push(words[i]);\\n                continue out;\\n            }\\n        cats.push([words[i]]);\\n    }\\n    function quote(word) {\\n        return JSON.stringify(word).replace(/[\\\\u2028\\\\u2029]/g, function(s) {\\n            switch (s) {\\n                case \\\"\\\\u2028\\\": return \\\"\\\\\\\\u2028\\\";\\n                case \\\"\\\\u2029\\\": return \\\"\\\\\\\\u2029\\\";\\n            }\\n            return s;\\n        });\\n    }\\n    function compareTo(arr) {\\n        if (arr.length == 1) return f += \\\"return str === \\\" + quote(arr[0]) + \\\";\\\";\\n        f += \\\"switch(str){\\\";\\n        for (var i = 0; i < arr.length; ++i) f += \\\"case \\\" + quote(arr[i]) + \\\":\\\";\\n        f += \\\"return true}return false;\\\";\\n    }\\n    // When there are more than three length categories, an outer\\n    // switch first dispatches on the lengths, to save on comparisons.\\n    if (cats.length > 3) {\\n        cats.sort(function(a, b) {return b.length - a.length;});\\n        f += \\\"switch(str.length){\\\";\\n        for (var i = 0; i < cats.length; ++i) {\\n            var cat = cats[i];\\n            f += \\\"case \\\" + cat[0].length + \\\":\\\";\\n            compareTo(cat);\\n        }\\n        f += \\\"}\\\";\\n        // Otherwise, simply generate a flat `switch` statement.\\n    } else {\\n        compareTo(words);\\n    }\\n    return new Function(\\\"str\\\", f);\\n};\\n\\nfunction all(array, predicate) {\\n    for (var i = array.length; --i >= 0;)\\n        if (!predicate(array[i]))\\n            return false;\\n    return true;\\n};\\n\\nfunction Dictionary() {\\n    this._values = Object.create(null);\\n    this._size = 0;\\n};\\nDictionary.prototype = {\\n    set: function(key, val) {\\n        if (!this.has(key)) ++this._size;\\n        this._values[\\\"$\\\" + key] = val;\\n        return this;\\n    },\\n    add: function(key, val) {\\n        if (this.has(key)) {\\n            this.get(key).push(val);\\n        } else {\\n            this.set(key, [ val ]);\\n        }\\n        return this;\\n    },\\n    get: function(key) { return this._values[\\\"$\\\" + key] },\\n    del: function(key) {\\n        if (this.has(key)) {\\n            --this._size;\\n            delete this._values[\\\"$\\\" + key];\\n        }\\n        return this;\\n    },\\n    has: function(key) { return (\\\"$\\\" + key) in this._values },\\n    each: function(f) {\\n        for (var i in this._values)\\n            f(this._values[i], i.substr(1));\\n    },\\n    size: function() {\\n        return this._size;\\n    },\\n    map: function(f) {\\n        var ret = [];\\n        for (var i in this._values)\\n            ret.push(f(this._values[i], i.substr(1)));\\n        return ret;\\n    },\\n    clone: function() {\\n        var ret = new Dictionary();\\n        for (var i in this._values)\\n            ret._values[i] = this._values[i];\\n        ret._size = this._size;\\n        return ret;\\n    },\\n    toObject: function() { return this._values }\\n};\\nDictionary.fromObject = function(obj) {\\n    var dict = new Dictionary();\\n    dict._size = merge(dict._values, obj);\\n    return dict;\\n};\\n\\nfunction HOP(obj, prop) {\\n    return Object.prototype.hasOwnProperty.call(obj, prop);\\n}\\n\\n// return true if the node at the top of the stack (that means the\\n// innermost node in the current output) is lexically the first in\\n// a statement.\\nfunction first_in_statement(stack) {\\n    var node = stack.parent(-1);\\n    for (var i = 0, p; p = stack.parent(i); i++) {\\n        if (p instanceof AST_Statement && p.body === node)\\n            return true;\\n        if ((p instanceof AST_Sequence      && p.expressions[0] === node) ||\\n            (p.TYPE == \\\"Call\\\"               && p.expression === node ) ||\\n            (p instanceof AST_Dot           && p.expression === node ) ||\\n            (p instanceof AST_Sub           && p.expression === node ) ||\\n            (p instanceof AST_Conditional   && p.condition === node  ) ||\\n            (p instanceof AST_Binary        && p.left === node       ) ||\\n            (p instanceof AST_UnaryPostfix  && p.expression === node ))\\n        {\\n            node = p;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9kaXN0L2Nqcy5qcz9lc01vZHVsZT1mYWxzZSEuL25vZGVfbW9kdWxlcy91Z2xpZnktZXMvbGliL3V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VnbGlmeS1lcy9saWIvdXRpbHMuanM/NmJjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXFxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxcblxcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cXG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xcblxcbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxcblxcbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cXG5cXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xcbiAgICBhcmUgbWV0OlxcblxcbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXFxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXFxuICAgICAgICAgIGRpc2NsYWltZXIuXFxuXFxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXFxuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXFxuICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXFxuICAgIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcXG4gICAgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1JcXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXFxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxcbiAgICBTVUNIIERBTUFHRS5cXG5cXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbmZ1bmN0aW9uIGNoYXJhY3RlcnMoc3RyKSB7XFxuICAgIHJldHVybiBzdHIuc3BsaXQoXFxcIlxcXCIpO1xcbn07XFxuXFxuZnVuY3Rpb24gbWVtYmVyKG5hbWUsIGFycmF5KSB7XFxuICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5hbWUpID49IDA7XFxufTtcXG5cXG5mdW5jdGlvbiBmaW5kX2lmKGZ1bmMsIGFycmF5KSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgKytpKSB7XFxuICAgICAgICBpZiAoZnVuYyhhcnJheVtpXSkpXFxuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2ldO1xcbiAgICB9XFxufTtcXG5cXG5mdW5jdGlvbiByZXBlYXRfc3RyaW5nKHN0ciwgaSkge1xcbiAgICBpZiAoaSA8PSAwKSByZXR1cm4gXFxcIlxcXCI7XFxuICAgIGlmIChpID09IDEpIHJldHVybiBzdHI7XFxuICAgIHZhciBkID0gcmVwZWF0X3N0cmluZyhzdHIsIGkgPj4gMSk7XFxuICAgIGQgKz0gZDtcXG4gICAgaWYgKGkgJiAxKSBkICs9IHN0cjtcXG4gICAgcmV0dXJuIGQ7XFxufTtcXG5cXG5mdW5jdGlvbiBjb25maWd1cmVfZXJyb3Jfc3RhY2soZm4pIHtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLnByb3RvdHlwZSwgXFxcInN0YWNrXFxcIiwge1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSk7XFxuICAgICAgICAgICAgZXJyLm5hbWUgPSB0aGlzLm5hbWU7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGFjaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBEZWZhdWx0c0Vycm9yKG1zZywgZGVmcykge1xcbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XFxuICAgIHRoaXMuZGVmcyA9IGRlZnM7XFxufTtcXG5EZWZhdWx0c0Vycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcXG5EZWZhdWx0c0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlZmF1bHRzRXJyb3I7XFxuRGVmYXVsdHNFcnJvci5wcm90b3R5cGUubmFtZSA9IFxcXCJEZWZhdWx0c0Vycm9yXFxcIjtcXG5jb25maWd1cmVfZXJyb3Jfc3RhY2soRGVmYXVsdHNFcnJvcik7XFxuXFxuRGVmYXVsdHNFcnJvci5jcm9hayA9IGZ1bmN0aW9uKG1zZywgZGVmcykge1xcbiAgICB0aHJvdyBuZXcgRGVmYXVsdHNFcnJvcihtc2csIGRlZnMpO1xcbn07XFxuXFxuZnVuY3Rpb24gZGVmYXVsdHMoYXJncywgZGVmcywgY3JvYWspIHtcXG4gICAgaWYgKGFyZ3MgPT09IHRydWUpXFxuICAgICAgICBhcmdzID0ge307XFxuICAgIHZhciByZXQgPSBhcmdzIHx8IHt9O1xcbiAgICBpZiAoY3JvYWspIGZvciAodmFyIGkgaW4gcmV0KSBpZiAoSE9QKHJldCwgaSkgJiYgIUhPUChkZWZzLCBpKSlcXG4gICAgICAgIERlZmF1bHRzRXJyb3IuY3JvYWsoXFxcImBcXFwiICsgaSArIFxcXCJgIGlzIG5vdCBhIHN1cHBvcnRlZCBvcHRpb25cXFwiLCBkZWZzKTtcXG4gICAgZm9yICh2YXIgaSBpbiBkZWZzKSBpZiAoSE9QKGRlZnMsIGkpKSB7XFxuICAgICAgICByZXRbaV0gPSAoYXJncyAmJiBIT1AoYXJncywgaSkpID8gYXJnc1tpXSA6IGRlZnNbaV07XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG59O1xcblxcbmZ1bmN0aW9uIG1lcmdlKG9iaiwgZXh0KSB7XFxuICAgIHZhciBjb3VudCA9IDA7XFxuICAgIGZvciAodmFyIGkgaW4gZXh0KSBpZiAoSE9QKGV4dCwgaSkpIHtcXG4gICAgICAgIG9ialtpXSA9IGV4dFtpXTtcXG4gICAgICAgIGNvdW50Kys7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNvdW50O1xcbn07XFxuXFxuZnVuY3Rpb24gbm9vcCgpIHt9XFxuZnVuY3Rpb24gcmV0dXJuX2ZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cXG5mdW5jdGlvbiByZXR1cm5fdHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cXG5mdW5jdGlvbiByZXR1cm5fdGhpcygpIHsgcmV0dXJuIHRoaXM7IH1cXG5mdW5jdGlvbiByZXR1cm5fbnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cXG5cXG52YXIgTUFQID0gKGZ1bmN0aW9uKCl7XFxuICAgIGZ1bmN0aW9uIE1BUChhLCBmLCBiYWNrd2FyZHMpIHtcXG4gICAgICAgIHZhciByZXQgPSBbXSwgdG9wID0gW10sIGk7XFxuICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xcbiAgICAgICAgICAgIHZhciB2YWwgPSBmKGFbaV0sIGkpO1xcbiAgICAgICAgICAgIHZhciBpc19sYXN0ID0gdmFsIGluc3RhbmNlb2YgTGFzdDtcXG4gICAgICAgICAgICBpZiAoaXNfbGFzdCkgdmFsID0gdmFsLnY7XFxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEF0VG9wKSB7XFxuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC52O1xcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgU3BsaWNlKSB7XFxuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaC5hcHBseSh0b3AsIGJhY2t3YXJkcyA/IHZhbC52LnNsaWNlKCkucmV2ZXJzZSgpIDogdmFsLnYpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2godmFsKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHNraXApIHtcXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNwbGljZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHZhbCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGlzX2xhc3Q7XFxuICAgICAgICB9O1xcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSkge1xcbiAgICAgICAgICAgIGlmIChiYWNrd2FyZHMpIHtcXG4gICAgICAgICAgICAgICAgZm9yIChpID0gYS5sZW5ndGg7IC0taSA+PSAwOykgaWYgKGRvaXQoKSkgYnJlYWs7XFxuICAgICAgICAgICAgICAgIHJldC5yZXZlcnNlKCk7XFxuICAgICAgICAgICAgICAgIHRvcC5yZXZlcnNlKCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIGlmIChkb2l0KCkpIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBhKSBpZiAoSE9QKGEsIGkpKSBpZiAoZG9pdCgpKSBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0b3AuY29uY2F0KHJldCk7XFxuICAgIH07XFxuICAgIE1BUC5hdF90b3AgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBBdFRvcCh2YWwpIH07XFxuICAgIE1BUC5zcGxpY2UgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBTcGxpY2UodmFsKSB9O1xcbiAgICBNQVAubGFzdCA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IExhc3QodmFsKSB9O1xcbiAgICB2YXIgc2tpcCA9IE1BUC5za2lwID0ge307XFxuICAgIGZ1bmN0aW9uIEF0VG9wKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcXG4gICAgZnVuY3Rpb24gU3BsaWNlKHZhbCkgeyB0aGlzLnYgPSB2YWwgfTtcXG4gICAgZnVuY3Rpb24gTGFzdCh2YWwpIHsgdGhpcy52ID0gdmFsIH07XFxuICAgIHJldHVybiBNQVA7XFxufSkoKTtcXG5cXG5mdW5jdGlvbiBwdXNoX3VuaXEoYXJyYXksIGVsKSB7XFxuICAgIGlmIChhcnJheS5pbmRleE9mKGVsKSA8IDApXFxuICAgICAgICBhcnJheS5wdXNoKGVsKTtcXG59O1xcblxcbmZ1bmN0aW9uIHN0cmluZ190ZW1wbGF0ZSh0ZXh0LCBwcm9wcykge1xcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXFxceyguKz8pXFxcXH0vZywgZnVuY3Rpb24oc3RyLCBwKXtcXG4gICAgICAgIHJldHVybiBwcm9wcyAmJiBwcm9wc1twXTtcXG4gICAgfSk7XFxufTtcXG5cXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsKSB7XFxuICAgIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGg7IC0taSA+PSAwOykge1xcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBlbCkgYXJyYXkuc3BsaWNlKGksIDEpO1xcbiAgICB9XFxufTtcXG5cXG5mdW5jdGlvbiBtZXJnZVNvcnQoYXJyYXksIGNtcCkge1xcbiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgMikgcmV0dXJuIGFycmF5LnNsaWNlKCk7XFxuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcXG4gICAgICAgIHZhciByID0gW10sIGFpID0gMCwgYmkgPSAwLCBpID0gMDtcXG4gICAgICAgIHdoaWxlIChhaSA8IGEubGVuZ3RoICYmIGJpIDwgYi5sZW5ndGgpIHtcXG4gICAgICAgICAgICBjbXAoYVthaV0sIGJbYmldKSA8PSAwXFxuICAgICAgICAgICAgICAgID8gcltpKytdID0gYVthaSsrXVxcbiAgICAgICAgICAgICAgICA6IHJbaSsrXSA9IGJbYmkrK107XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYWkgPCBhLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGEuc2xpY2UoYWkpKTtcXG4gICAgICAgIGlmIChiaSA8IGIubGVuZ3RoKSByLnB1c2guYXBwbHkociwgYi5zbGljZShiaSkpO1xcbiAgICAgICAgcmV0dXJuIHI7XFxuICAgIH07XFxuICAgIGZ1bmN0aW9uIF9tcyhhKSB7XFxuICAgICAgICBpZiAoYS5sZW5ndGggPD0gMSlcXG4gICAgICAgICAgICByZXR1cm4gYTtcXG4gICAgICAgIHZhciBtID0gTWF0aC5mbG9vcihhLmxlbmd0aCAvIDIpLCBsZWZ0ID0gYS5zbGljZSgwLCBtKSwgcmlnaHQgPSBhLnNsaWNlKG0pO1xcbiAgICAgICAgbGVmdCA9IF9tcyhsZWZ0KTtcXG4gICAgICAgIHJpZ2h0ID0gX21zKHJpZ2h0KTtcXG4gICAgICAgIHJldHVybiBtZXJnZShsZWZ0LCByaWdodCk7XFxuICAgIH07XFxuICAgIHJldHVybiBfbXMoYXJyYXkpO1xcbn07XFxuXFxuLy8gdGhpcyBmdW5jdGlvbiBpcyB0YWtlbiBmcm9tIEFjb3JuIFsxXSwgd3JpdHRlbiBieSBNYXJpam4gSGF2ZXJiZWtlXFxuLy8gWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL2Fjb3JuXFxuZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xcbiAgICBpZiAoISh3b3JkcyBpbnN0YW5jZW9mIEFycmF5KSkgd29yZHMgPSB3b3Jkcy5zcGxpdChcXFwiIFxcXCIpO1xcbiAgICB2YXIgZiA9IFxcXCJcXFwiLCBjYXRzID0gW107XFxuICAgIG91dDogZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKVxcbiAgICAgICAgICAgIGlmIChjYXRzW2pdWzBdLmxlbmd0aCA9PSB3b3Jkc1tpXS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcXG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIGNhdHMucHVzaChbd29yZHNbaV1dKTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBxdW90ZSh3b3JkKSB7XFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkod29yZCkucmVwbGFjZSgvW1xcXFx1MjAyOFxcXFx1MjAyOV0vZywgZnVuY3Rpb24ocykge1xcbiAgICAgICAgICAgIHN3aXRjaCAocykge1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJcXFxcdTIwMjhcXFwiOiByZXR1cm4gXFxcIlxcXFxcXFxcdTIwMjhcXFwiO1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJcXFxcdTIwMjlcXFwiOiByZXR1cm4gXFxcIlxcXFxcXFxcdTIwMjlcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gcztcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09IDEpIHJldHVybiBmICs9IFxcXCJyZXR1cm4gc3RyID09PSBcXFwiICsgcXVvdGUoYXJyWzBdKSArIFxcXCI7XFxcIjtcXG4gICAgICAgIGYgKz0gXFxcInN3aXRjaChzdHIpe1xcXCI7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcXFwiY2FzZSBcXFwiICsgcXVvdGUoYXJyW2ldKSArIFxcXCI6XFxcIjtcXG4gICAgICAgIGYgKz0gXFxcInJldHVybiB0cnVlfXJldHVybiBmYWxzZTtcXFwiO1xcbiAgICB9XFxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiB0aHJlZSBsZW5ndGggY2F0ZWdvcmllcywgYW4gb3V0ZXJcXG4gICAgLy8gc3dpdGNoIGZpcnN0IGRpc3BhdGNoZXMgb24gdGhlIGxlbmd0aHMsIHRvIHNhdmUgb24gY29tcGFyaXNvbnMuXFxuICAgIGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcXG4gICAgICAgIGNhdHMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7fSk7XFxuICAgICAgICBmICs9IFxcXCJzd2l0Y2goc3RyLmxlbmd0aCl7XFxcIjtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0cy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgIHZhciBjYXQgPSBjYXRzW2ldO1xcbiAgICAgICAgICAgIGYgKz0gXFxcImNhc2UgXFxcIiArIGNhdFswXS5sZW5ndGggKyBcXFwiOlxcXCI7XFxuICAgICAgICAgICAgY29tcGFyZVRvKGNhdCk7XFxuICAgICAgICB9XFxuICAgICAgICBmICs9IFxcXCJ9XFxcIjtcXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2ltcGx5IGdlbmVyYXRlIGEgZmxhdCBgc3dpdGNoYCBzdGF0ZW1lbnQuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBjb21wYXJlVG8od29yZHMpO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXFxcInN0clxcXCIsIGYpO1xcbn07XFxuXFxuZnVuY3Rpb24gYWxsKGFycmF5LCBwcmVkaWNhdGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KVxcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaV0pKVxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5mdW5jdGlvbiBEaWN0aW9uYXJ5KCkge1xcbiAgICB0aGlzLl92YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcbiAgICB0aGlzLl9zaXplID0gMDtcXG59O1xcbkRpY3Rpb25hcnkucHJvdG90eXBlID0ge1xcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XFxuICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpICsrdGhpcy5fc2l6ZTtcXG4gICAgICAgIHRoaXMuX3ZhbHVlc1tcXFwiJFxcXCIgKyBrZXldID0gdmFsO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGFkZDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcXG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XFxuICAgICAgICAgICAgdGhpcy5nZXQoa2V5KS5wdXNoKHZhbCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgWyB2YWwgXSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tcXFwiJFxcXCIgKyBrZXldIH0sXFxuICAgIGRlbDogZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xcbiAgICAgICAgICAgIC0tdGhpcy5fc2l6ZTtcXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzW1xcXCIkXFxcIiArIGtleV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgaGFzOiBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIChcXFwiJFxcXCIgKyBrZXkpIGluIHRoaXMuX3ZhbHVlcyB9LFxcbiAgICBlYWNoOiBmdW5jdGlvbihmKSB7XFxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3ZhbHVlcylcXG4gICAgICAgICAgICBmKHRoaXMuX3ZhbHVlc1tpXSwgaS5zdWJzdHIoMSkpO1xcbiAgICB9LFxcbiAgICBzaXplOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xcbiAgICB9LFxcbiAgICBtYXA6IGZ1bmN0aW9uKGYpIHtcXG4gICAgICAgIHZhciByZXQgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fdmFsdWVzKVxcbiAgICAgICAgICAgIHJldC5wdXNoKGYodGhpcy5fdmFsdWVzW2ldLCBpLnN1YnN0cigxKSkpO1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgfSxcXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIHJldCA9IG5ldyBEaWN0aW9uYXJ5KCk7XFxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3ZhbHVlcylcXG4gICAgICAgICAgICByZXQuX3ZhbHVlc1tpXSA9IHRoaXMuX3ZhbHVlc1tpXTtcXG4gICAgICAgIHJldC5fc2l6ZSA9IHRoaXMuX3NpemU7XFxuICAgICAgICByZXR1cm4gcmV0O1xcbiAgICB9LFxcbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl92YWx1ZXMgfVxcbn07XFxuRGljdGlvbmFyeS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XFxuICAgIHZhciBkaWN0ID0gbmV3IERpY3Rpb25hcnkoKTtcXG4gICAgZGljdC5fc2l6ZSA9IG1lcmdlKGRpY3QuX3ZhbHVlcywgb2JqKTtcXG4gICAgcmV0dXJuIGRpY3Q7XFxufTtcXG5cXG5mdW5jdGlvbiBIT1Aob2JqLCBwcm9wKSB7XFxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcXG59XFxuXFxuLy8gcmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2sgKHRoYXQgbWVhbnMgdGhlXFxuLy8gaW5uZXJtb3N0IG5vZGUgaW4gdGhlIGN1cnJlbnQgb3V0cHV0KSBpcyBsZXhpY2FsbHkgdGhlIGZpcnN0IGluXFxuLy8gYSBzdGF0ZW1lbnQuXFxuZnVuY3Rpb24gZmlyc3RfaW5fc3RhdGVtZW50KHN0YWNrKSB7XFxuICAgIHZhciBub2RlID0gc3RhY2sucGFyZW50KC0xKTtcXG4gICAgZm9yICh2YXIgaSA9IDAsIHA7IHAgPSBzdGFjay5wYXJlbnQoaSk7IGkrKykge1xcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50ICYmIHAuYm9keSA9PT0gbm9kZSlcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIGlmICgocCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSAgICAgICYmIHAuZXhwcmVzc2lvbnNbMF0gPT09IG5vZGUpIHx8XFxuICAgICAgICAgICAgKHAuVFlQRSA9PSBcXFwiQ2FsbFxcXCIgICAgICAgICAgICAgICAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUgKSB8fFxcbiAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0RvdCAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSBub2RlICkgfHxcXG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9TdWIgICAgICAgICAgICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSApIHx8XFxuICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgICAmJiBwLmNvbmRpdGlvbiA9PT0gbm9kZSAgKSB8fFxcbiAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAgICAgICAgJiYgcC5sZWZ0ID09PSBub2RlICAgICAgICkgfHxcXG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeVBvc3RmaXggICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSApKVxcbiAgICAgICAge1xcbiAgICAgICAgICAgIG5vZGUgPSBwO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgIH1cXG59XFxuXCI7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/raw-loader/dist/cjs.js?esModule=false!./node_modules/uglify-es/lib/utils.js\n");

/***/ })

}]);