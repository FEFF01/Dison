(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[49],{

/***/ "./node_modules/tern/defs/ecmascript.json":
/*!************************************************!*\
  !*** ./node_modules/tern/defs/ecmascript.json ***!
  \************************************************/
/*! exports provided: !name, !define, Infinity, undefined, NaN, Object, Function, Array, String, Number, Boolean, RegExp, Date, Error, SyntaxError, ReferenceError, URIError, EvalError, RangeError, TypeError, parseInt, parseFloat, isNaN, isFinite, eval, encodeURI, encodeURIComponent, decodeURI, decodeURIComponent, Math, JSON, ArrayBuffer, DataView, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Map, Promise, Proxy, Reflect, Set, Symbol, Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray, WeakMap, WeakSet, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"!name\\\":\\\"ecmascript\\\",\\\"!define\\\":{\\\"Error.prototype\\\":\\\"Error.prototype\\\",\\\"propertyDescriptor\\\":{\\\"enumerable\\\":\\\"bool\\\",\\\"configurable\\\":\\\"bool\\\",\\\"value\\\":\\\"?\\\",\\\"writable\\\":\\\"bool\\\",\\\"get\\\":\\\"fn() -> ?\\\",\\\"set\\\":\\\"fn(value: ?)\\\"},\\\"Promise.prototype\\\":{\\\"catch\\\":{\\\"!doc\\\":\\\"The catch() method returns a Promise and deals with rejected cases only. It behaves the same as calling Promise.prototype.then(undefined, onRejected).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\\\",\\\"!type\\\":\\\"fn(onRejected: fn(reason: ?)) -> !this\\\"},\\\"then\\\":{\\\"!doc\\\":\\\"The then() method returns a Promise. It takes two arguments, both are callback functions for the success and failure cases of the Promise.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\\\",\\\"!type\\\":\\\"fn(onFulfilled: fn(value: ?), onRejected: fn(reason: ?)) -> !custom:Promise_then\\\",\\\"!effects\\\":[\\\"call !0 !this.:t\\\"]},\\\"finally\\\":{\\\"!doc\\\":\\\"The finally() method returns a Promise. When the promise is settled, whether fulfilled or rejected, the specified callback function is executed. \\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\\\",\\\"!type\\\":\\\"fn(onFinally: fn()) -> !custom:Promise_then\\\"}},\\\"Promise_reject\\\":{\\\"!type\\\":\\\"fn(reason: ?) -> !this\\\",\\\"!doc\\\":\\\"The Promise.reject(reason) method returns a Promise object that is rejected with the given reason.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject\\\"},\\\"iter_prototype\\\":{\\\":Symbol.iterator\\\":\\\"fn() -> !this\\\"},\\\"iter\\\":{\\\"!proto\\\":\\\"iter_prototype\\\",\\\"next\\\":{\\\"!type\\\":\\\"fn() -> +iter_result[value=!this.:t]\\\",\\\"!doc\\\":\\\"Return the next item in the sequence.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\\\"},\\\"iter_result\\\":{\\\"done\\\":\\\"bool\\\",\\\"value\\\":\\\"?\\\"},\\\"generator_prototype\\\":{\\\"!proto\\\":\\\"iter_prototype\\\",\\\"next\\\":\\\"fn(value?: ?) -> iter_result\\\",\\\"return\\\":\\\"fn(value?: ?) -> iter_result\\\",\\\"throw\\\":\\\"fn(exception: +Error)\\\"},\\\"async_iter_prototype\\\":{\\\":Symbol.asyncIterator\\\":\\\"fn() -> !this\\\"},\\\"async_iter\\\":{\\\"!proto\\\":\\\"async_iter_prototype\\\",\\\"next\\\":{\\\"!type\\\":\\\"fn() -> +Promise[:t=+iter_result[value=!this.:t]]\\\",\\\"!doc\\\":\\\"Return the next item in the sequence.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\\\"},\\\"async_generator_prototype\\\":{\\\"!proto\\\":\\\"async_iter_prototype\\\",\\\"next\\\":\\\"fn(value?: ?) -> +Promise[:t=iter_result]\\\",\\\"return\\\":\\\"fn(value?: ?) -> +Promise[:t=iter_result]\\\",\\\"throw\\\":\\\"fn(exception: +Error)\\\"},\\\"Proxy_handler\\\":{\\\"!doc\\\":\\\"The proxy's handler object is a placeholder object which contains traps for proxies.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler\\\",\\\"getPrototypeOf\\\":\\\"fn(target: ?)\\\",\\\"setPrototypeOf\\\":\\\"fn(target: ?, prototype: ?)\\\",\\\"isExtensible\\\":\\\"fn(target: ?)\\\",\\\"preventExtensions\\\":\\\"fn(target: ?)\\\",\\\"getOwnPropertyDescriptor\\\":\\\"fn(target: ?, property: string) -> propertyDescriptor\\\",\\\"defineProperty\\\":\\\"fn(target: ?, property: string, descriptor: propertyDescriptor)\\\",\\\"has\\\":\\\"fn(target: ?, property: string)\\\",\\\"get\\\":\\\"fn(target: ?, property: string)\\\",\\\"set\\\":\\\"fn(target: ?, property: string, value: ?)\\\",\\\"deleteProperty\\\":\\\"fn(target: ?, property: string)\\\",\\\"enumerate\\\":\\\"fn(target: ?)\\\",\\\"ownKeys\\\":\\\"fn(target: ?)\\\",\\\"apply\\\":\\\"fn(target: ?, self: ?, arguments: [?])\\\",\\\"construct\\\":\\\"fn(target: ?, arguments: [?])\\\"},\\\"Proxy_revocable\\\":{\\\"proxy\\\":\\\"+Proxy\\\",\\\"revoke\\\":\\\"fn()\\\"},\\\"TypedArray\\\":{\\\"!type\\\":\\\"fn(size: number)\\\",\\\"!doc\\\":\\\"A TypedArray object describes an array-like view of an underlying binary data buffer. There is no global property named TypedArray, nor is there a directly visible TypedArray constructor.  Instead, there are a number of different global properties, whose values are typed array constructors for specific element types, listed below. On the following pages you will find common properties and methods that can be used with any typed array containing elements of any type.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\\\",\\\"from\\\":{\\\"!type\\\":\\\"fn(arrayLike: ?, mapFn?: fn(elt: ?, i: number) -> number, thisArg?: ?) -> +TypedArray\\\",\\\"!effects\\\":[\\\"call !1 this=!2 !0.<i> number\\\"],\\\"!doc\\\":\\\"Creates a new typed array from an array-like or iterable object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from\\\"},\\\"of\\\":{\\\"!type\\\":\\\"fn(elements: number) -> +TypedArray\\\",\\\"!doc\\\":\\\"Creates a new typed array from a variable number of arguments.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/of\\\"},\\\"BYTES_PER_ELEMENT\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The TypedArray.BYTES_PER_ELEMENT property represents the size in bytes of each element in an typed array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT\\\"},\\\"name\\\":{\\\"!type\\\":\\\"string\\\",\\\"!doc\\\":\\\"The TypedArray.name property represents a string value of the typed array constructor name.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/name\\\"},\\\"prototype\\\":{\\\"<i>\\\":\\\"number\\\",\\\"buffer\\\":{\\\"!type\\\":\\\"+ArrayBuffer\\\",\\\"!doc\\\":\\\"The buffer accessor property represents the ArrayBuffer referenced by a TypedArray at construction time.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/buffer\\\"},\\\"byteLength\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The byteLength accessor property represents the length (in bytes) of a typed array from the start of its ArrayBuffer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/byteLength\\\"},\\\"byteOffset\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The byteOffset accessor property represents the offset (in bytes) of a typed array from the start of its ArrayBuffer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/byteOffset\\\"},\\\"copyWithin\\\":{\\\"!type\\\":\\\"fn(target: number, start: number, end?: number) -> ?\\\",\\\"!doc\\\":\\\"The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. This method has the same algorithm as Array.prototype.copyWithin. TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/copyWithin\\\"},\\\"entries\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=number]\\\",\\\"!doc\\\":\\\"The entries() method returns a new Array Iterator object that contains the key/value pairs for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/entries\\\"},\\\"every\\\":{\\\"!type\\\":\\\"fn(callback: fn(element: number, index: number, array: TypedArray) -> bool, thisArg?: ?) -> bool\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number !this\\\"],\\\"!doc\\\":\\\"The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/every\\\"},\\\"fill\\\":{\\\"!type\\\":\\\"fn(value: number, start?: number, end?: number)\\\",\\\"!doc\\\":\\\"The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/fill\\\"},\\\"filter\\\":{\\\"!type\\\":\\\"fn(test: fn(element: number, i: number) -> bool, context?: ?) -> !this\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number\\\"],\\\"!doc\\\":\\\"Creates a new array with all of the elements of this array for which the provided filtering function returns true. See also Array.prototype.filter().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/filter\\\"},\\\"find\\\":{\\\"!type\\\":\\\"fn(callback: fn(element: number, index: number, array: +TypedArray) -> bool, thisArg?: ?) -> number\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number !this\\\"],\\\"!doc\\\":\\\"The find() method returns a value in the typed array, if an element satisfies the provided testing function. Otherwise undefined is returned. TypedArray is one of the typed array types here.\\\\nSee also the findIndex() method, which returns the index of a found element in the typed array instead of its value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/find\\\"},\\\"findIndex\\\":{\\\"!type\\\":\\\"fn(callback: fn(element: number, index: number, array: +TypedArray) -> bool, thisArg?: ?) -> number\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number !this\\\"],\\\"!doc\\\":\\\"The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned.\\\\nSee also the find() method, which returns the value of a found element in the typed array instead of its index.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/findIndex\\\"},\\\"forEach\\\":{\\\"!type\\\":\\\"fn(callback: fn(value: number, key: number, array: +TypedArray), thisArg?: ?)\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number !this\\\"],\\\"!doc\\\":\\\"Executes a provided function once per array element.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/forEach\\\"},\\\"indexOf\\\":{\\\"!type\\\":\\\"fn(searchElement: number, fromIndex?: number) -> number\\\",\\\"!doc\\\":\\\"The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. This method has the same algorithm as Array.prototype.indexOf(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/indexOf\\\"},\\\"join\\\":{\\\"!type\\\":\\\"fn(separator?: string) -> string\\\",\\\"!doc\\\":\\\"The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/join\\\"},\\\"keys\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=number]\\\",\\\"!doc\\\":\\\"The keys() method returns a new Array Iterator object that contains the keys for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/keys\\\"},\\\"lastIndexOf\\\":{\\\"!type\\\":\\\"fn(searchElement: number, fromIndex?: number) -> number\\\",\\\"!doc\\\":\\\"The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. This method has the same algorithm as Array.prototype.lastIndexOf(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf\\\"},\\\"length\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"Returns the number of elements hold in the typed array. Fixed at construction time and thus read only.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/length\\\"},\\\"map\\\":{\\\"!type\\\":\\\"fn(f: fn(element: number, i: number) -> number, context?: ?) -> +TypedArray\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number\\\"],\\\"!doc\\\":\\\"Creates a new array with the results of calling a provided function on every element in this array. See also Array.prototype.map().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map\\\"},\\\"reduce\\\":{\\\"!type\\\":\\\"fn(combine: fn(sum: ?, elt: number, i: number) -> ?, init?: ?) -> !0.!ret\\\",\\\"!effects\\\":[\\\"call !0 !1 number number\\\"],\\\"!doc\\\":\\\"Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value. See also Array.prototype.reduce().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduce\\\"},\\\"reduceRight\\\":{\\\"!type\\\":\\\"fn(combine: fn(sum: ?, elt: number, i: number) -> ?, init?: ?) -> !0.!ret\\\",\\\"!effects\\\":[\\\"call !0 !1 number number\\\"],\\\"!doc\\\":\\\"Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value. See also Array.prototype.reduceRight().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduceRight\\\"},\\\"reverse\\\":{\\\"!type\\\":\\\"fn()\\\",\\\"!doc\\\":\\\"The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reverse\\\"},\\\"set\\\":{\\\"!type\\\":\\\"fn(array: [number], offset?: number)\\\",\\\"!doc\\\":\\\"The set() method stores multiple values in the typed array, reading input values from a specified array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set\\\"},\\\"slice\\\":{\\\"!type\\\":\\\"fn(from: number, to?: number) -> +TypedArray\\\",\\\"!doc\\\":\\\"Extracts a section of an array and returns a new array. See also Array.prototype.slice().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice\\\"},\\\"some\\\":{\\\"!type\\\":\\\"fn(test: fn(elt: number, i: number) -> bool, context?: ?) -> bool\\\",\\\"!effects\\\":[\\\"call !0 this=!1 number number\\\"],\\\"!doc\\\":\\\"The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some(). TypedArray is one of the typed array types here.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/some\\\"},\\\"sort\\\":{\\\"!type\\\":\\\"fn(compare?: fn(a: number, b: number) -> number)\\\",\\\"!effects\\\":[\\\"call !0 number number\\\"],\\\"!doc\\\":\\\"Sorts the elements of an array in place and returns the array. See also Array.prototype.sort().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sort\\\"},\\\"subarray\\\":{\\\"!type\\\":\\\"fn(begin?: number, end?: number) -> +TypedArray\\\",\\\"!doc\\\":\\\"The subarray() method returns a new TypedArray on the same ArrayBuffer store and with the same element types as for this TypedArray object. The begin offset is inclusive and the end offset is exclusive. TypedArray is one of the typed array types.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray\\\"},\\\"values\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=number]\\\",\\\"!doc\\\":\\\"The values() method returns a new Array Iterator object that contains the values for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/values\\\"},\\\":Symbol.iterator\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=number]\\\",\\\"!doc\\\":\\\"Returns a new Array Iterator object that contains the values for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/@@iterator\\\"}}}},\\\"Infinity\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Infinity\\\",\\\"!doc\\\":\\\"A numeric value representing infinity.\\\"},\\\"undefined\\\":{\\\"!type\\\":\\\"?\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/undefined\\\",\\\"!doc\\\":\\\"The value undefined.\\\"},\\\"NaN\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN\\\",\\\"!doc\\\":\\\"A value representing Not-A-Number.\\\"},\\\"Object\\\":{\\\"!type\\\":\\\"fn()\\\",\\\"getPrototypeOf\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> ?\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\\\",\\\"!doc\\\":\\\"Returns the prototype (i.e. the internal prototype) of the specified object.\\\"},\\\"create\\\":{\\\"!type\\\":\\\"fn(proto: ?) -> !custom:Object_create\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\\\",\\\"!doc\\\":\\\"Creates a new object with the specified prototype object and properties.\\\"},\\\"defineProperty\\\":{\\\"!type\\\":\\\"fn(obj: ?, prop: string, desc: propertyDescriptor) -> !custom:Object_defineProperty\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty\\\",\\\"!doc\\\":\\\"Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article.\\\"},\\\"defineProperties\\\":{\\\"!type\\\":\\\"fn(obj: ?, props: ?) -> !custom:Object_defineProperties\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty\\\",\\\"!doc\\\":\\\"Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article.\\\"},\\\"getOwnPropertyDescriptor\\\":{\\\"!type\\\":\\\"fn(obj: ?, prop: string) -> propertyDescriptor\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\\\",\\\"!doc\\\":\\\"Returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\\\"},\\\"keys\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> [string]\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys\\\",\\\"!doc\\\":\\\"Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\\\"},\\\"getOwnPropertyNames\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> [string]\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\\\",\\\"!doc\\\":\\\"Returns an array of all properties (enumerable or not) found directly upon a given object.\\\"},\\\"seal\\\":{\\\"!type\\\":\\\"fn(obj: ?)\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal\\\",\\\"!doc\\\":\\\"Seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\\\"},\\\"isSealed\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isSealed\\\",\\\"!doc\\\":\\\"Determine if an object is sealed.\\\"},\\\"freeze\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> !0\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze\\\",\\\"!doc\\\":\\\"Freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\\\"},\\\"isFrozen\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isFrozen\\\",\\\"!doc\\\":\\\"Determine if an object is frozen.\\\"},\\\"preventExtensions\\\":{\\\"!type\\\":\\\"fn(obj: ?)\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\\\",\\\"!doc\\\":\\\"Prevents new properties from ever being added to an object.\\\"},\\\"isExtensible\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\\\",\\\"!doc\\\":\\\"The Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\\\"},\\\"assign\\\":{\\\"!type\\\":\\\"fn(target: ?, source: ?, source?: ?) -> !0\\\",\\\"!effects\\\":[\\\"copy !1 !0\\\",\\\"copy !2 !0\\\",\\\"copy !3 !0\\\"],\\\"!doc\\\":\\\"The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\\"},\\\"getOwnPropertySymbols\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> !custom:getOwnPropertySymbols\\\",\\\"!doc\\\":\\\"The Object.getOwnPropertySymbols() method returns an array of all symbol properties found directly upon a given object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\\\"},\\\"is\\\":{\\\"!type\\\":\\\"fn(value1: ?, value2: ?) -> bool\\\",\\\"!doc\\\":\\\"The Object.is() method determines whether two values are the same value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\\\"},\\\"setPrototypeOf\\\":{\\\"!type\\\":\\\"fn(obj: ?, prototype: ?)\\\",\\\"!doc\\\":\\\"The Object.setPrototype() method sets the prototype (i.e., the internal [[Prototype]] property) of a specified object to another object or null.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf\\\"},\\\"prototype\\\":{\\\"!stdProto\\\":\\\"Object\\\",\\\"toString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString\\\",\\\"!doc\\\":\\\"Returns a string representing the object.\\\"},\\\"toLocaleString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toLocaleString\\\",\\\"!doc\\\":\\\"Returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\\\"},\\\"valueOf\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf\\\",\\\"!doc\\\":\\\"Returns the primitive value of the specified object\\\"},\\\"hasOwnProperty\\\":{\\\"!type\\\":\\\"fn(prop: string) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\\\",\\\"!doc\\\":\\\"Returns a boolean indicating whether the object has the specified property.\\\"},\\\"propertyIsEnumerable\\\":{\\\"!type\\\":\\\"fn(prop: string) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable\\\",\\\"!doc\\\":\\\"Returns a Boolean indicating whether the specified property is enumerable.\\\"},\\\"isPrototypeOf\\\":{\\\"!type\\\":\\\"fn(obj: ?) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf\\\",\\\"!doc\\\":\\\"Tests for an object in another object's prototype chain.\\\"}},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object\\\",\\\"!doc\\\":\\\"Creates an object wrapper.\\\"},\\\"Function\\\":{\\\"!type\\\":\\\"fn(body: string) -> fn()\\\",\\\"prototype\\\":{\\\"!stdProto\\\":\\\"Function\\\",\\\"apply\\\":{\\\"!type\\\":\\\"fn(this: ?, args: [?])\\\",\\\"!effects\\\":[\\\"call and return !this this=!0 !1.<i> !1.<i> !1.<i>\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply\\\",\\\"!doc\\\":\\\"Calls a function with a given this value and arguments provided as an array (or an array like object).\\\"},\\\"call\\\":{\\\"!type\\\":\\\"fn(this: ?, args?: ?) -> !this.!ret\\\",\\\"!effects\\\":[\\\"call and return !this this=!0 !1 !2 !3 !4\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call\\\",\\\"!doc\\\":\\\"Calls a function with a given this value and arguments provided individually.\\\"},\\\"bind\\\":{\\\"!type\\\":\\\"fn(this: ?, args?: ?) -> !custom:Function_bind\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind\\\",\\\"!doc\\\":\\\"Creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function was called.\\\"},\\\"prototype\\\":\\\"?\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function\\\",\\\"!doc\\\":\\\"Every function in JavaScript is actually a Function object.\\\"},\\\"Array\\\":{\\\"!type\\\":\\\"fn(size: number) -> !custom:Array_ctor\\\",\\\"isArray\\\":{\\\"!type\\\":\\\"fn(value: ?) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray\\\",\\\"!doc\\\":\\\"Returns true if an object is an array, false if it is not.\\\"},\\\"from\\\":{\\\"!type\\\":\\\"fn(arrayLike: ?, mapFn?: fn(elt: ?, i: number) -> ?, thisArg?: ?) -> [!0.<i>]\\\",\\\"!effects\\\":[\\\"call !1 this=!2 !0.<i> number\\\"],\\\"!doc\\\":\\\"The Array.from() method creates a new Array instance from an array-like or iterable object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from\\\"},\\\"of\\\":{\\\"!type\\\":\\\"fn(elementN: ?) -> [!0]\\\",\\\"!doc\\\":\\\"The Array.of() method creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\\\"},\\\"prototype\\\":{\\\"!stdProto\\\":\\\"Array\\\",\\\"length\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/length\\\",\\\"!doc\\\":\\\"An unsigned, 32-bit integer that specifies the number of elements in an array.\\\"},\\\"concat\\\":{\\\"!type\\\":\\\"fn(other: [?]) -> !this\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat\\\",\\\"!doc\\\":\\\"Returns a new array comprised of this array joined with other array(s) and/or value(s).\\\"},\\\"join\\\":{\\\"!type\\\":\\\"fn(separator?: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/join\\\",\\\"!doc\\\":\\\"Joins all elements of an array into a string.\\\"},\\\"splice\\\":{\\\"!type\\\":\\\"fn(pos: number, amount: number, newelt?: ?) -> [?]\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice\\\",\\\"!doc\\\":\\\"Changes the content of an array, adding new elements while removing old elements.\\\"},\\\"pop\\\":{\\\"!type\\\":\\\"fn() -> !this.<i>\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/pop\\\",\\\"!doc\\\":\\\"Removes the last element from an array and returns that element.\\\"},\\\"push\\\":{\\\"!type\\\":\\\"fn(newelt: ?) -> number\\\",\\\"!effects\\\":[\\\"propagate !0 !this.<i>\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push\\\",\\\"!doc\\\":\\\"Mutates an array by appending the given elements and returning the new length of the array.\\\"},\\\"shift\\\":{\\\"!type\\\":\\\"fn() -> !this.<i>\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/shift\\\",\\\"!doc\\\":\\\"Removes the first element from an array and returns that element. This method changes the length of the array.\\\"},\\\"unshift\\\":{\\\"!type\\\":\\\"fn(newelt: ?) -> number\\\",\\\"!effects\\\":[\\\"propagate !0 !this.<i>\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/unshift\\\",\\\"!doc\\\":\\\"Adds one or more elements to the beginning of an array and returns the new length of the array.\\\"},\\\"slice\\\":{\\\"!type\\\":\\\"fn(from?: number, to?: number) -> !this\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/slice\\\",\\\"!doc\\\":\\\"Returns a shallow copy of a portion of an array.\\\"},\\\"reverse\\\":{\\\"!type\\\":\\\"fn()\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/reverse\\\",\\\"!doc\\\":\\\"Reverses an array in place.  The first array element becomes the last and the last becomes the first.\\\"},\\\"sort\\\":{\\\"!type\\\":\\\"fn(compare?: fn(a: ?, b: ?) -> number)\\\",\\\"!effects\\\":[\\\"call !0 !this.<i> !this.<i>\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort\\\",\\\"!doc\\\":\\\"Sorts the elements of an array in place and returns the array.\\\"},\\\"indexOf\\\":{\\\"!type\\\":\\\"fn(elt: ?, from?: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf\\\",\\\"!doc\\\":\\\"Returns the first index at which a given element can be found in the array, or -1 if it is not present.\\\"},\\\"lastIndexOf\\\":{\\\"!type\\\":\\\"fn(elt: ?, from?: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/lastIndexOf\\\",\\\"!doc\\\":\\\"Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex.\\\"},\\\"every\\\":{\\\"!type\\\":\\\"fn(test: fn(elt: ?, i: number, array: +Array) -> bool, context?: ?) -> bool\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/every\\\",\\\"!doc\\\":\\\"Tests whether all elements in the array pass the test implemented by the provided function.\\\"},\\\"some\\\":{\\\"!type\\\":\\\"fn(test: fn(elt: ?, i: number, array: +Array) -> bool, context?: ?) -> bool\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/some\\\",\\\"!doc\\\":\\\"Tests whether some element in the array passes the test implemented by the provided function.\\\"},\\\"filter\\\":{\\\"!type\\\":\\\"fn(test: fn(elt: ?, i: number, array: +Array) -> bool, context?: ?) -> !this\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter\\\",\\\"!doc\\\":\\\"Creates a new array with all elements that pass the test implemented by the provided function.\\\"},\\\"forEach\\\":{\\\"!type\\\":\\\"fn(f: fn(elt: ?, i: number, array: +Array), context?: ?)\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach\\\",\\\"!doc\\\":\\\"Executes a provided function once per array element.\\\"},\\\"map\\\":{\\\"!type\\\":\\\"fn(f: fn(elt: ?, i: number, array: +Array) -> ?, context?: ?) -> [!0.!ret]\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map\\\",\\\"!doc\\\":\\\"Creates a new array with the results of calling a provided function on every element in this array.\\\"},\\\"reduce\\\":{\\\"!type\\\":\\\"fn(combine: fn(sum: ?, elt: ?, i: number, array: +Array) -> ?, init?: ?) -> !0.!ret\\\",\\\"!effects\\\":[\\\"call !0 !1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce\\\",\\\"!doc\\\":\\\"Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.\\\"},\\\"reduceRight\\\":{\\\"!type\\\":\\\"fn(combine: fn(sum: ?, elt: ?, i: number, array: +Array) -> ?, init?: ?) -> !0.!ret\\\",\\\"!effects\\\":[\\\"call !0 !1 !this.<i> number !this\\\"],\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/ReduceRight\\\",\\\"!doc\\\":\\\"Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value.\\\"},\\\"copyWithin\\\":{\\\"!type\\\":\\\"fn(target: number, start: number, end?: number) -> !this\\\",\\\"!doc\\\":\\\"The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin\\\"},\\\"entries\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=[number, !this.<i>]]\\\",\\\"!doc\\\":\\\"The entries() method returns a new Array Iterator object that contains the key/value pairs for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries\\\"},\\\"fill\\\":{\\\"!type\\\":\\\"fn(value: ?, start?: number, end?: number) -> !this\\\",\\\"!doc\\\":\\\"The fill() method fills all the elements of an array from a start index to an end index with a static value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill\\\"},\\\"find\\\":{\\\"!type\\\":\\\"fn(callback: fn(element: ?, index: number, array: [?]) -> bool, thisArg?: ?) -> !this.<i>\\\",\\\"!effects\\\":[\\\"call !0 this=!2 !this.<i> number\\\"],\\\"!doc\\\":\\\"The find() method returns a value in the array, if an element in the array satisfies the provided testing function. Otherwise undefined is returned.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\\\"},\\\"findIndex\\\":{\\\"!type\\\":\\\"fn(callback: fn(element: ?, index: number, array: [?]), thisArg?: ?) -> number\\\",\\\"!effects\\\":[\\\"call !0 this=!2 !this.<i> number\\\"],\\\"!doc\\\":\\\"The findIndex() method returns an index in the array, if an element in the array satisfies the provided testing function. Otherwise -1 is returned.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex\\\"},\\\"keys\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=number]\\\",\\\"!doc\\\":\\\"The keys() method returns a new Array Iterator that contains the keys for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys\\\"},\\\"values\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.<i>]\\\",\\\"!doc\\\":\\\"The values() method returns a new Array Iterator object that contains the values for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values\\\"},\\\":Symbol.iterator\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.<i>]\\\",\\\"!doc\\\":\\\"Returns a new Array Iterator object that contains the values for each index in the array.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator\\\"},\\\"includes\\\":{\\\"!type\\\":\\\"fn(value: ?, fromIndex?: number) -> bool\\\",\\\"!doc\\\":\\\"Determines whether an array includes a certain element, returning true or false as appropriate.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\\\"}},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array\\\",\\\"!doc\\\":\\\"The JavaScript Array global object is a constructor for arrays, which are high-level, list-like objects.\\\"},\\\"String\\\":{\\\"!type\\\":\\\"fn(value: ?) -> string\\\",\\\"fromCharCode\\\":{\\\"!type\\\":\\\"fn(code: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode\\\",\\\"!doc\\\":\\\"Returns a string created by using the specified sequence of Unicode values.\\\"},\\\"fromCodePoint\\\":{\\\"!type\\\":\\\"fn(point: number, point?: number) -> string\\\",\\\"!doc\\\":\\\"The static String.fromCodePoint() method returns a string created by using the specified sequence of code points.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint\\\"},\\\"raw\\\":{\\\"!type\\\":\\\"fn(template: [string], substitutions: ?, templateString: ?) -> string\\\",\\\"!doc\\\":\\\"The static String.raw() method is a tag function of template strings, used to get the raw string form of template strings.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\\\"},\\\"prototype\\\":{\\\"!stdProto\\\":\\\"String\\\",\\\"length\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String/length\\\",\\\"!doc\\\":\\\"Represents the length of a string.\\\"},\\\"<i>\\\":\\\"string\\\",\\\"charAt\\\":{\\\"!type\\\":\\\"fn(i: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charAt\\\",\\\"!doc\\\":\\\"Returns the specified character from a string.\\\"},\\\"charCodeAt\\\":{\\\"!type\\\":\\\"fn(i: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt\\\",\\\"!doc\\\":\\\"Returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\\\"},\\\"indexOf\\\":{\\\"!type\\\":\\\"fn(char: string, from?: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/indexOf\\\",\\\"!doc\\\":\\\"Returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex,\\\\nreturns -1 if the value is not found.\\\"},\\\"lastIndexOf\\\":{\\\"!type\\\":\\\"fn(char: string, from?: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/lastIndexOf\\\",\\\"!doc\\\":\\\"Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found. The calling string is searched backward, starting at fromIndex.\\\"},\\\"substring\\\":{\\\"!type\\\":\\\"fn(from: number, to?: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substring\\\",\\\"!doc\\\":\\\"Returns a subset of a string between one index and another, or through the end of the string.\\\"},\\\"substr\\\":{\\\"!type\\\":\\\"fn(from: number, length?: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substr\\\",\\\"!doc\\\":\\\"Returns the characters in a string beginning at the specified location through the specified number of characters.\\\"},\\\"slice\\\":{\\\"!type\\\":\\\"fn(from: number, to?: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/slice\\\",\\\"!doc\\\":\\\"Extracts a section of a string and returns a new string.\\\"},\\\"padStart\\\":{\\\"!type\\\":\\\"fn(targetLength: number, padString?: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\\\",\\\"!doc\\\":\\\"Pads the current string with another string (repeated, if needed) so that the resulting string reaches the given length.\\\"},\\\"padEnd\\\":{\\\"!type\\\":\\\"fn(targetLength: number, padString?: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd\\\",\\\"!doc\\\":\\\"pads the current string with a given string (repeated, if needed) so that the resulting string reaches a given length.\\\"},\\\"trim\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim\\\",\\\"!doc\\\":\\\"Removes whitespace from both ends of the string.\\\"},\\\"trimStart\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart\\\",\\\"!doc\\\":\\\"Removes whitespace from the beginning of a string. \\\"},\\\"trimLeft\\\":\\\"String.prototype.trimStart\\\",\\\"trimEnd\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd\\\",\\\"!doc\\\":\\\"Removes whitespace from the end of a string.\\\"},\\\"trimRight\\\":\\\"String.prototype.trimEnd\\\",\\\"toUpperCase\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toUpperCase\\\",\\\"!doc\\\":\\\"Returns the calling string value converted to uppercase.\\\"},\\\"toLowerCase\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLowerCase\\\",\\\"!doc\\\":\\\"Returns the calling string value converted to lowercase.\\\"},\\\"toLocaleUpperCase\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase\\\",\\\"!doc\\\":\\\"Returns the calling string value converted to upper case, according to any locale-specific case mappings.\\\"},\\\"toLocaleLowerCase\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase\\\",\\\"!doc\\\":\\\"Returns the calling string value converted to lower case, according to any locale-specific case mappings.\\\"},\\\"split\\\":{\\\"!type\\\":\\\"fn(pattern?: string|+RegExp, limit?: number) -> [string]\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split\\\",\\\"!doc\\\":\\\"Splits a String object into an array of strings by separating the string into substrings.\\\"},\\\"concat\\\":{\\\"!type\\\":\\\"fn(other: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/concat\\\",\\\"!doc\\\":\\\"Combines the text of two or more strings and returns a new string.\\\"},\\\"localeCompare\\\":{\\\"!type\\\":\\\"fn(other: string) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/localeCompare\\\",\\\"!doc\\\":\\\"Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order.\\\"},\\\"match\\\":{\\\"!type\\\":\\\"fn(pattern: +RegExp) -> [string]\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match\\\",\\\"!doc\\\":\\\"Used to retrieve the matches when matching a string against a regular expression.\\\"},\\\"replace\\\":{\\\"!type\\\":\\\"fn(pattern: string|+RegExp, replacement: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace\\\",\\\"!doc\\\":\\\"Returns a new string with some or all matches of a pattern replaced by a replacement.  The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match.\\\"},\\\"search\\\":{\\\"!type\\\":\\\"fn(pattern: +RegExp) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search\\\",\\\"!doc\\\":\\\"Executes the search for a match between a regular expression and this String object.\\\"},\\\"codePointAt\\\":{\\\"!type\\\":\\\"fn(pos: number) -> number\\\",\\\"!doc\\\":\\\"The codePointAt() method returns a non-negative integer that is the UTF-16 encoded code point value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt\\\"},\\\"endsWith\\\":{\\\"!type\\\":\\\"fn(searchString: string, position?: number) -> bool\\\",\\\"!doc\\\":\\\"The endsWith() method determines whether a string ends with the characters of another string, returning true or false as appropriate.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\\\"},\\\"includes\\\":{\\\"!type\\\":\\\"fn(searchString: string, position?: number) -> bool\\\",\\\"!doc\\\":\\\"The includes() method determines whether one string may be found within another string, returning true or false as appropriate.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains\\\"},\\\"normalize\\\":{\\\"!type\\\":\\\"fn(form: string) -> string\\\",\\\"!doc\\\":\\\"The normalize() method returns the Unicode Normalization Form of a given string (if the value isn't a string, it will be converted to one first).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\\\"},\\\"repeat\\\":{\\\"!type\\\":\\\"fn(count: number) -> string\\\",\\\"!doc\\\":\\\"The repeat() method constructs and returns a new string which contains the specified number of copies of the string on which it was called, concatenated together.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\\\"},\\\"startsWith\\\":{\\\"!type\\\":\\\"fn(searchString: string, position?: number) -> bool\\\",\\\"!doc\\\":\\\"The startsWith() method determines whether a string begins with the characters of another string, returning true or false as appropriate.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\\\"},\\\":Symbol.iterator\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=string]\\\",\\\"!doc\\\":\\\"Returns a new Iterator object that iterates over the code points of a String value, returning each code point as a String value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator\\\"}},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String\\\",\\\"!doc\\\":\\\"The String global object is a constructor for strings, or a sequence of characters.\\\"},\\\"Number\\\":{\\\"!type\\\":\\\"fn(value: ?) -> number\\\",\\\"MAX_VALUE\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MAX_VALUE\\\",\\\"!doc\\\":\\\"The maximum numeric value representable in JavaScript.\\\"},\\\"MIN_VALUE\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MIN_VALUE\\\",\\\"!doc\\\":\\\"The smallest positive numeric value representable in JavaScript.\\\"},\\\"POSITIVE_INFINITY\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY\\\",\\\"!doc\\\":\\\"A value representing the positive Infinity value.\\\"},\\\"NEGATIVE_INFINITY\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY\\\",\\\"!doc\\\":\\\"A value representing the negative Infinity value.\\\"},\\\"prototype\\\":{\\\"!stdProto\\\":\\\"Number\\\",\\\"toString\\\":{\\\"!type\\\":\\\"fn(radix?: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toString\\\",\\\"!doc\\\":\\\"Returns a string representing the specified Number object\\\"},\\\"toFixed\\\":{\\\"!type\\\":\\\"fn(digits: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\\\",\\\"!doc\\\":\\\"Formats a number using fixed-point notation\\\"},\\\"toExponential\\\":{\\\"!type\\\":\\\"fn(digits: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toExponential\\\",\\\"!doc\\\":\\\"Returns a string representing the Number object in exponential notation\\\"},\\\"toPrecision\\\":{\\\"!type\\\":\\\"fn(digits: number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toPrecision\\\",\\\"!doc\\\":\\\"The toPrecision() method returns a string representing the number to the specified precision.\\\"}},\\\"EPSILON\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The Number.EPSILON property represents the difference between one and the smallest value greater than one that can be represented as a Number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\\\"},\\\"MAX_SAFE_INTEGER\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The Number.MAX_SAFE_INTEGER constant represents the maximum safe integer in JavaScript (253 - 1).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\\\"},\\\"MIN_SAFE_INTEGER\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The Number.MIN_SAFE_INTEGER constant represents the minimum safe integer in JavaScript (-(253 - 1)).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER\\\"},\\\"isFinite\\\":{\\\"!type\\\":\\\"fn(testValue: ?) -> bool\\\",\\\"!doc\\\":\\\"The Number.isFinite() method determines whether the passed value is finite.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite\\\"},\\\"isInteger\\\":{\\\"!type\\\":\\\"fn(testValue: ?) -> bool\\\",\\\"!doc\\\":\\\"The Number.isInteger() method determines whether the passed value is an integer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\\"},\\\"isNaN\\\":{\\\"!type\\\":\\\"fn(testValue: ?) -> bool\\\",\\\"!doc\\\":\\\"The Number.isNaN() method determines whether the passed value is NaN. More robust version of the original global isNaN().\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\\\"},\\\"isSafeInteger\\\":{\\\"!type\\\":\\\"fn(testValue: ?) -> bool\\\",\\\"!doc\\\":\\\"The Number.isSafeInteger() method determines whether the provided value is a number that is a safe integer. A safe integer is an integer that\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger\\\"},\\\"parseFloat\\\":{\\\"!type\\\":\\\"fn(string: string) -> number\\\",\\\"!doc\\\":\\\"The Number.parseFloat() method parses a string argument and returns a floating point number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat\\\"},\\\"parseInt\\\":{\\\"!type\\\":\\\"fn(string: string, radix?: number) -> number\\\",\\\"!doc\\\":\\\"The Number.parseInt() method parses a string argument and returns an integer of the specified radix or base.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number\\\",\\\"!doc\\\":\\\"The Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor.\\\"},\\\"Boolean\\\":{\\\"!type\\\":\\\"fn(value: ?) -> bool\\\",\\\"prototype\\\":{\\\"!stdProto\\\":\\\"Boolean\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Boolean\\\",\\\"!doc\\\":\\\"The Boolean object is an object wrapper for a boolean value.\\\"},\\\"RegExp\\\":{\\\"!type\\\":\\\"fn(source: string, flags?: string)\\\",\\\"prototype\\\":{\\\"!stdProto\\\":\\\"RegExp\\\",\\\"exec\\\":{\\\"!type\\\":\\\"fn(input: string) -> [string]\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec\\\",\\\"!doc\\\":\\\"Executes a search for a match in a specified string. Returns a result array, or null.\\\"},\\\"test\\\":{\\\"!type\\\":\\\"fn(input: string) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/test\\\",\\\"!doc\\\":\\\"Executes the search for a match between a regular expression and a specified string. Returns true or false.\\\"},\\\"global\\\":{\\\"!type\\\":\\\"bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp\\\",\\\"!doc\\\":\\\"Creates a regular expression object for matching text with a pattern.\\\"},\\\"ignoreCase\\\":{\\\"!type\\\":\\\"bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp\\\",\\\"!doc\\\":\\\"Creates a regular expression object for matching text with a pattern.\\\"},\\\"multiline\\\":{\\\"!type\\\":\\\"bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/multiline\\\",\\\"!doc\\\":\\\"Reflects whether or not to search in strings across multiple lines.\\\"},\\\"source\\\":{\\\"!type\\\":\\\"string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/source\\\",\\\"!doc\\\":\\\"A read-only property that contains the text of the pattern, excluding the forward slashes.\\\"},\\\"lastIndex\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/lastIndex\\\",\\\"!doc\\\":\\\"A read/write integer property that specifies the index at which to start the next match.\\\"},\\\"flags\\\":{\\\"!type\\\":\\\"string\\\",\\\"!doc\\\":\\\"The flags property returns a string consisting of the flags of the current regular expression object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags\\\"},\\\"sticky\\\":{\\\"!type\\\":\\\"bool\\\",\\\"!doc\\\":\\\"The sticky property reflects whether or not the search is sticky (searches in strings only from the index indicated by the lastIndex property of this regular expression). sticky is a read-only property of an individual regular expression object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\\\"},\\\"unicode\\\":{\\\"!type\\\":\\\"bool\\\",\\\"!doc\\\":\\\"The 'u' flag enables various Unicode-related features.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode\\\"}},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp\\\",\\\"!doc\\\":\\\"Creates a regular expression object for matching text with a pattern.\\\"},\\\"Date\\\":{\\\"!type\\\":\\\"fn(ms: number)\\\",\\\"parse\\\":{\\\"!type\\\":\\\"fn(source: string) -> +Date\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse\\\",\\\"!doc\\\":\\\"Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC.\\\"},\\\"UTC\\\":{\\\"!type\\\":\\\"fn(year: number, month: number, date: number, hour?: number, min?: number, sec?: number, ms?: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/UTC\\\",\\\"!doc\\\":\\\"Accepts the same parameters as the longest form of the constructor, and returns the number of milliseconds in a Date object since January 1, 1970, 00:00:00, universal time.\\\"},\\\"now\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now\\\",\\\"!doc\\\":\\\"Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC.\\\"},\\\"prototype\\\":{\\\"toUTCString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString\\\",\\\"!doc\\\":\\\"Converts a date to a string, using the universal time convention.\\\"},\\\"toISOString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toISOString\\\",\\\"!doc\\\":\\\"JavaScript provides a direct way to convert a date object into a string in ISO format, the ISO 8601 Extended Format.\\\"},\\\"toDateString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toDateString\\\",\\\"!doc\\\":\\\"Returns the date portion of a Date object in human readable form in American English.\\\"},\\\"toGMTString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString\\\",\\\"!doc\\\":\\\"Returns a string representing the Date based on the GMT (UT) time zone.\\\"},\\\"toTimeString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toTimeString\\\",\\\"!doc\\\":\\\"Returns the time portion of a Date object in human readable form in American English.\\\"},\\\"toLocaleDateString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleDateString\\\",\\\"!doc\\\":\\\"Converts a date to a string, returning the \\\\\\\"date\\\\\\\" portion using the operating system's locale's conventions.\\\"},\\\"toLocaleFormat\\\":{\\\"!type\\\":\\\"fn(formatString: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleFormat\\\",\\\"!doc\\\":\\\"Converts a date to a string, using a format string.\\\"},\\\"toLocaleString\\\":{\\\"!type\\\":\\\"fn(locales?: string, options?: ?) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\\\",\\\"!doc\\\":\\\"Returns a string with a locality sensitive representation of this date.\\\"},\\\"toLocaleTimeString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString\\\",\\\"!doc\\\":\\\"Converts a date to a string, returning the \\\\\\\"time\\\\\\\" portion using the current locale's conventions.\\\"},\\\"toSource\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toSource\\\",\\\"!doc\\\":\\\"A string representing the source code of the given Date object.\\\"},\\\"toString\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toString\\\",\\\"!doc\\\":\\\"A string representing the given date.\\\"},\\\"valueOf\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf\\\",\\\"!doc\\\":\\\"Returns the primitive value of a Date object.\\\"},\\\"getTime\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTime\\\",\\\"!doc\\\":\\\"Returns the numeric value corresponding to the time for the specified date according to universal time.\\\"},\\\"getFullYear\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getFullYear\\\",\\\"!doc\\\":\\\"Returns the year of the specified date according to local time.\\\"},\\\"getYear\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getYear\\\",\\\"!doc\\\":\\\"Returns the year in the specified date according to local time.\\\"},\\\"getMonth\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMonth\\\",\\\"!doc\\\":\\\"Returns the month in the specified date according to local time.\\\"},\\\"getUTCMonth\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMonth\\\",\\\"!doc\\\":\\\"Returns the month of the specified date according to universal time.\\\"},\\\"getDate\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDate\\\",\\\"!doc\\\":\\\"Returns the day of the month for the specified date according to local time.\\\"},\\\"getUTCDate\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDate\\\",\\\"!doc\\\":\\\"Returns the day (date) of the month in the specified date according to universal time.\\\"},\\\"getDay\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDay\\\",\\\"!doc\\\":\\\"Returns the day of the week for the specified date according to local time.\\\"},\\\"getUTCDay\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDay\\\",\\\"!doc\\\":\\\"Returns the day of the week in the specified date according to universal time.\\\"},\\\"getUTCFullYear\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear\\\",\\\"!doc\\\":\\\"The getUTCFullYear() method returns the year in the specified date according to universal time.\\\"},\\\"getHours\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getHours\\\",\\\"!doc\\\":\\\"Returns the hour for the specified date according to local time.\\\"},\\\"getUTCHours\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCHours\\\",\\\"!doc\\\":\\\"Returns the hours in the specified date according to universal time.\\\"},\\\"getMinutes\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMinutes\\\",\\\"!doc\\\":\\\"Returns the minutes in the specified date according to local time.\\\"},\\\"getUTCMinutes\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date\\\",\\\"!doc\\\":\\\"Creates JavaScript Date instances which let you work with dates and times.\\\"},\\\"getSeconds\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getSeconds\\\",\\\"!doc\\\":\\\"Returns the seconds in the specified date according to local time.\\\"},\\\"getUTCSeconds\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCSeconds\\\",\\\"!doc\\\":\\\"Returns the seconds in the specified date according to universal time.\\\"},\\\"getMilliseconds\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMilliseconds\\\",\\\"!doc\\\":\\\"Returns the milliseconds in the specified date according to local time.\\\"},\\\"getUTCMilliseconds\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds\\\",\\\"!doc\\\":\\\"Returns the milliseconds in the specified date according to universal time.\\\"},\\\"getTimezoneOffset\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\\\",\\\"!doc\\\":\\\"Returns the time-zone offset from UTC, in minutes, for the current locale.\\\"},\\\"setTime\\\":{\\\"!type\\\":\\\"fn(date: +Date) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setTime\\\",\\\"!doc\\\":\\\"Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.\\\"},\\\"setFullYear\\\":{\\\"!type\\\":\\\"fn(year: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setFullYear\\\",\\\"!doc\\\":\\\"Sets the full year for a specified date according to local time.\\\"},\\\"setUTCFullYear\\\":{\\\"!type\\\":\\\"fn(year: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCFullYear\\\",\\\"!doc\\\":\\\"Sets the full year for a specified date according to universal time.\\\"},\\\"setYear\\\":{\\\"!type\\\":\\\"fn(yearValue: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setYear\\\",\\\"!doc\\\":\\\"Sets the year (usually 2-3 digits) for a specified date according to local time.\\\"},\\\"setMonth\\\":{\\\"!type\\\":\\\"fn(month: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMonth\\\",\\\"!doc\\\":\\\"Set the month for a specified date according to local time.\\\"},\\\"setUTCMonth\\\":{\\\"!type\\\":\\\"fn(month: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMonth\\\",\\\"!doc\\\":\\\"Sets the month for a specified date according to universal time.\\\"},\\\"setDate\\\":{\\\"!type\\\":\\\"fn(day: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setDate\\\",\\\"!doc\\\":\\\"Sets the day of the month for a specified date according to local time.\\\"},\\\"setUTCDate\\\":{\\\"!type\\\":\\\"fn(day: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCDate\\\",\\\"!doc\\\":\\\"Sets the day of the month for a specified date according to universal time.\\\"},\\\"setHours\\\":{\\\"!type\\\":\\\"fn(hour: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setHours\\\",\\\"!doc\\\":\\\"Sets the hours for a specified date according to local time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated Date instance.\\\"},\\\"setUTCHours\\\":{\\\"!type\\\":\\\"fn(hour: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCHours\\\",\\\"!doc\\\":\\\"Sets the hour for a specified date according to universal time.\\\"},\\\"setMinutes\\\":{\\\"!type\\\":\\\"fn(min: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMinutes\\\",\\\"!doc\\\":\\\"Sets the minutes for a specified date according to local time.\\\"},\\\"setUTCMinutes\\\":{\\\"!type\\\":\\\"fn(min: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMinutes\\\",\\\"!doc\\\":\\\"Sets the minutes for a specified date according to universal time.\\\"},\\\"setSeconds\\\":{\\\"!type\\\":\\\"fn(sec: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setSeconds\\\",\\\"!doc\\\":\\\"Sets the seconds for a specified date according to local time.\\\"},\\\"setUTCSeconds\\\":{\\\"!type\\\":\\\"fn(sec: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCSeconds\\\",\\\"!doc\\\":\\\"Sets the seconds for a specified date according to universal time.\\\"},\\\"setMilliseconds\\\":{\\\"!type\\\":\\\"fn(ms: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMilliseconds\\\",\\\"!doc\\\":\\\"Sets the milliseconds for a specified date according to local time.\\\"},\\\"setUTCMilliseconds\\\":{\\\"!type\\\":\\\"fn(ms: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds\\\",\\\"!doc\\\":\\\"Sets the milliseconds for a specified date according to universal time.\\\"},\\\"toJSON\\\":{\\\"!type\\\":\\\"fn() -> string\\\",\\\"!doc\\\":\\\"Returns a string (using toISOString()) representing the Date object's value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON\\\"}},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date\\\",\\\"!doc\\\":\\\"Creates JavaScript Date instances which let you work with dates and times.\\\"},\\\"Error\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":{\\\"name\\\":{\\\"!type\\\":\\\"string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/name\\\",\\\"!doc\\\":\\\"A name for the type of error.\\\"},\\\"message\\\":{\\\"!type\\\":\\\"string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/message\\\",\\\"!doc\\\":\\\"A human-readable description of the error.\\\"}},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error\\\",\\\"!doc\\\":\\\"Creates an error object.\\\"},\\\"SyntaxError\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":\\\"Error.prototype\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/SyntaxError\\\",\\\"!doc\\\":\\\"Represents an error when trying to interpret syntactically invalid code.\\\"},\\\"ReferenceError\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":\\\"Error.prototype\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/ReferenceError\\\",\\\"!doc\\\":\\\"Represents an error when a non-existent variable is referenced.\\\"},\\\"URIError\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":\\\"Error.prototype\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/URIError\\\",\\\"!doc\\\":\\\"Represents an error when a malformed URI is encountered.\\\"},\\\"EvalError\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":\\\"Error.prototype\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/EvalError\\\",\\\"!doc\\\":\\\"Represents an error regarding the eval function.\\\"},\\\"RangeError\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":\\\"Error.prototype\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RangeError\\\",\\\"!doc\\\":\\\"Represents an error when a number is not within the correct range allowed.\\\"},\\\"TypeError\\\":{\\\"!type\\\":\\\"fn(message: string)\\\",\\\"prototype\\\":\\\"Error.prototype\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/TypeError\\\",\\\"!doc\\\":\\\"Represents an error an error when a value is not of the expected type.\\\"},\\\"parseInt\\\":{\\\"!type\\\":\\\"fn(string: string, radix?: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseInt\\\",\\\"!doc\\\":\\\"Parses a string argument and returns an integer of the specified radix or base.\\\"},\\\"parseFloat\\\":{\\\"!type\\\":\\\"fn(string: string) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseFloat\\\",\\\"!doc\\\":\\\"Parses a string argument and returns a floating point number.\\\"},\\\"isNaN\\\":{\\\"!type\\\":\\\"fn(value: number) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isNaN\\\",\\\"!doc\\\":\\\"Determines whether a value is NaN or not. Be careful, this function is broken. You may be interested in ECMAScript 6 Number.isNaN.\\\"},\\\"isFinite\\\":{\\\"!type\\\":\\\"fn(value: number) -> bool\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isFinite\\\",\\\"!doc\\\":\\\"Determines whether the passed value is a finite number.\\\"},\\\"eval\\\":{\\\"!type\\\":\\\"fn(code: string) -> ?\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval\\\",\\\"!doc\\\":\\\"Evaluates JavaScript code represented as a string.\\\"},\\\"encodeURI\\\":{\\\"!type\\\":\\\"fn(uri: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURI\\\",\\\"!doc\\\":\\\"Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \\\\\\\"surrogate\\\\\\\" characters).\\\"},\\\"encodeURIComponent\\\":{\\\"!type\\\":\\\"fn(uri: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent\\\",\\\"!doc\\\":\\\"Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \\\\\\\"surrogate\\\\\\\" characters).\\\"},\\\"decodeURI\\\":{\\\"!type\\\":\\\"fn(uri: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURI\\\",\\\"!doc\\\":\\\"Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine.\\\"},\\\"decodeURIComponent\\\":{\\\"!type\\\":\\\"fn(uri: string) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURIComponent\\\",\\\"!doc\\\":\\\"Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine.\\\"},\\\"Math\\\":{\\\"E\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/E\\\",\\\"!doc\\\":\\\"The base of natural logarithms, e, approximately 2.718.\\\"},\\\"LN2\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN2\\\",\\\"!doc\\\":\\\"The natural logarithm of 2, approximately 0.693.\\\"},\\\"LN10\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN10\\\",\\\"!doc\\\":\\\"The natural logarithm of 10, approximately 2.302.\\\"},\\\"LOG2E\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG2E\\\",\\\"!doc\\\":\\\"The base 2 logarithm of E (approximately 1.442).\\\"},\\\"LOG10E\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG10E\\\",\\\"!doc\\\":\\\"The base 10 logarithm of E (approximately 0.434).\\\"},\\\"SQRT1_2\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT1_2\\\",\\\"!doc\\\":\\\"The square root of 1/2; equivalently, 1 over the square root of 2, approximately 0.707.\\\"},\\\"SQRT2\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT2\\\",\\\"!doc\\\":\\\"The square root of 2, approximately 1.414.\\\"},\\\"PI\\\":{\\\"!type\\\":\\\"number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/PI\\\",\\\"!doc\\\":\\\"The ratio of the circumference of a circle to its diameter, approximately 3.14159.\\\"},\\\"abs\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/abs\\\",\\\"!doc\\\":\\\"Returns the absolute value of a number.\\\"},\\\"cos\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/cos\\\",\\\"!doc\\\":\\\"Returns the cosine of a number.\\\"},\\\"sin\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sin\\\",\\\"!doc\\\":\\\"Returns the sine of a number.\\\"},\\\"tan\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/tan\\\",\\\"!doc\\\":\\\"Returns the tangent of a number.\\\"},\\\"acos\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/acos\\\",\\\"!doc\\\":\\\"Returns the arccosine (in radians) of a number.\\\"},\\\"asin\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/asin\\\",\\\"!doc\\\":\\\"Returns the arcsine (in radians) of a number.\\\"},\\\"atan\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan\\\",\\\"!doc\\\":\\\"Returns the arctangent (in radians) of a number.\\\"},\\\"atan2\\\":{\\\"!type\\\":\\\"fn(y: number, x: number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan2\\\",\\\"!doc\\\":\\\"Returns the arctangent of the quotient of its arguments.\\\"},\\\"ceil\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/ceil\\\",\\\"!doc\\\":\\\"Returns the smallest integer greater than or equal to a number.\\\"},\\\"floor\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/floor\\\",\\\"!doc\\\":\\\"Returns the largest integer less than or equal to a number.\\\"},\\\"round\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/round\\\",\\\"!doc\\\":\\\"Returns the value of a number rounded to the nearest integer.\\\"},\\\"exp\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/exp\\\",\\\"!doc\\\":\\\"Returns E^x, where x is the argument, and E is Euler's constant, the base of the natural logarithms.\\\"},\\\"log\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/log\\\",\\\"!doc\\\":\\\"Returns the natural logarithm (base E) of a number.\\\"},\\\"sqrt\\\":{\\\"!type\\\":\\\"fn(number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sqrt\\\",\\\"!doc\\\":\\\"Returns the square root of a number.\\\"},\\\"pow\\\":{\\\"!type\\\":\\\"fn(number, number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/pow\\\",\\\"!doc\\\":\\\"Returns base to the exponent power, that is, baseexponent.\\\"},\\\"max\\\":{\\\"!type\\\":\\\"fn(number, number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/max\\\",\\\"!doc\\\":\\\"Returns the largest of zero or more numbers.\\\"},\\\"min\\\":{\\\"!type\\\":\\\"fn(number, number) -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/min\\\",\\\"!doc\\\":\\\"Returns the smallest of zero or more numbers.\\\"},\\\"random\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random\\\",\\\"!doc\\\":\\\"Returns a floating-point, pseudo-random number in the range [0, 1) that is, from 0 (inclusive) up to but not including 1 (exclusive), which you can then scale to your desired range.\\\"},\\\"acosh\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.acosh() function returns the hyperbolic arc-cosine of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\\\"},\\\"asinh\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.asinh() function returns the hyperbolic arcsine of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\\\"},\\\"atanh\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.atanh() function returns the hyperbolic arctangent of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\\\"},\\\"cbrt\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.cbrt() function returns the cube root of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt\\\"},\\\"clz32\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.clz32() function returns the number of leading zero bits in the 32-bit binary representation of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\\\"},\\\"cosh\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.cosh() function returns the hyperbolic cosine of a number, that can be expressed using the constant e:\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\\\"},\\\"expm1\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.expm1() function returns ex - 1, where x is the argument, and e the base of the natural logarithms.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1\\\"},\\\"fround\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.fround() function returns the nearest single precision float representation of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\\\"},\\\"hypot\\\":{\\\"!type\\\":\\\"fn(value: number) -> number\\\",\\\"!doc\\\":\\\"The Math.hypot() function returns the square root of the sum of squares of its arguments.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot\\\"},\\\"imul\\\":{\\\"!type\\\":\\\"fn(a: number, b: number) -> number\\\",\\\"!doc\\\":\\\"The Math.imul() function returns the result of the C-like 32-bit multiplication of the two parameters.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\\\"},\\\"log10\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.log10() function returns the base 10 logarithm of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\\\"},\\\"log1p\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.log1p() function returns the natural logarithm (base e) of 1 + a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p\\\"},\\\"log2\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.log2() function returns the base 2 logarithm of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2\\\"},\\\"sign\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\\"},\\\"sinh\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.sinh() function returns the hyperbolic sine of a number, that can be expressed using the constant e:\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\\\"},\\\"tanh\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.tanh() function returns the hyperbolic tangent of a number.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\\\"},\\\"trunc\\\":{\\\"!type\\\":\\\"fn(x: number) -> number\\\",\\\"!doc\\\":\\\"The Math.trunc() function returns the integral part of a number by removing any fractional digits. It does not round any numbers. The function can be expressed with the floor() and ceil() function:\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math\\\",\\\"!doc\\\":\\\"A built-in object that has properties and methods for mathematical constants and functions.\\\"},\\\"JSON\\\":{\\\"parse\\\":{\\\"!type\\\":\\\"fn(json: string, reviver?: fn(key: string, value: ?) -> ?) -> ?\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse\\\",\\\"!doc\\\":\\\"Parse a string as JSON, optionally transforming the value produced by parsing.\\\"},\\\"stringify\\\":{\\\"!type\\\":\\\"fn(value: ?, replacer?: fn(key: string, value: ?) -> ?, space?: string|number) -> string\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify\\\",\\\"!doc\\\":\\\"Convert a value to JSON, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified.\\\"},\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/JSON\\\",\\\"!doc\\\":\\\"JSON (JavaScript Object Notation) is a data-interchange format.  It closely resembles a subset of JavaScript syntax, although it is not a strict subset. (See JSON in the JavaScript Reference for full details.)  It is useful when writing any kind of JavaScript-based application, including websites and browser extensions.  For example, you might store user information in JSON format in a cookie, or you might store extension preferences in JSON in a string-valued browser preference.\\\"},\\\"ArrayBuffer\\\":{\\\"!type\\\":\\\"fn(length: number)\\\",\\\"!doc\\\":\\\"The ArrayBuffer object is used to represent a generic, fixed-length raw binary data buffer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\\\",\\\"isView\\\":{\\\"!type\\\":\\\"fn(arg: +ArrayBuffer) -> bool\\\",\\\"!doc\\\":\\\"The ArrayBuffer.isView() method returns true if arg is one of the ArrayBuffer views, such as typed array objects or a DataView; false otherwise.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView\\\"},\\\"prototype\\\":{\\\"byteLength\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The byteLength accessor property represents the length of an ArrayBuffer in bytes.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength\\\"},\\\"slice\\\":{\\\"!type\\\":\\\"fn(begin: number, end?: number) -> +ArrayBuffer\\\",\\\"!doc\\\":\\\"The slice() method returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin, inclusive, up to end, exclusive.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice\\\"}}},\\\"DataView\\\":{\\\"!type\\\":\\\"fn(buffer: +ArrayBuffer, byteOffset?: number, byteLength?: number)\\\",\\\"!doc\\\":\\\"The DataView view provides a low-level interface for reading data from and writing it to an ArrayBuffer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\\\",\\\"prototype\\\":{\\\"buffer\\\":{\\\"!type\\\":\\\"+ArrayBuffer\\\",\\\"!doc\\\":\\\"The buffer accessor property represents the ArrayBuffer referenced by the DataView at construction time.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/buffer\\\"},\\\"byteLength\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The byteLength accessor property represents the length (in bytes) of this view from the start of its ArrayBuffer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/byteLength\\\"},\\\"byteOffset\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The byteOffset accessor property represents the offset (in bytes) of this view from the start of its ArrayBuffer.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/byteOffset\\\"},\\\"getFloat32\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getFloat32() method gets a signed 32-bit integer (float) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat32\\\"},\\\"getFloat64\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getFloat64() method gets a signed 64-bit float (double) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat64\\\"},\\\"getInt16\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getInt16() method gets a signed 16-bit integer (short) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt16\\\"},\\\"getInt32\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getInt32() method gets a signed 32-bit integer (long) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt32\\\"},\\\"getInt8\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getInt8() method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt8\\\"},\\\"getUint16\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getUint16() method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint16\\\"},\\\"getUint32\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, littleEndian?: bool) -> number\\\",\\\"!doc\\\":\\\"The getUint32() method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32\\\"},\\\"getUint8\\\":{\\\"!type\\\":\\\"fn(byteOffset: number) -> number\\\",\\\"!doc\\\":\\\"The getUint8() method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint8\\\"},\\\"setFloat32\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number, littleEndian?: bool)\\\",\\\"!doc\\\":\\\"The setFloat32() method stores a signed 32-bit integer (float) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat32\\\"},\\\"setFloat64\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number, littleEndian?: bool)\\\",\\\"!doc\\\":\\\"The setFloat64() method stores a signed 64-bit integer (double) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat64\\\"},\\\"setInt16\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number, littleEndian?: bool)\\\",\\\"!doc\\\":\\\"The setInt16() method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt16\\\"},\\\"setInt32\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number, littleEndian?: bool)\\\",\\\"!doc\\\":\\\"The setInt32() method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt32\\\"},\\\"setInt8\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number)\\\",\\\"!doc\\\":\\\"The setInt8() method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt8\\\"},\\\"setUint16\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number, littleEndian?: bool)\\\",\\\"!doc\\\":\\\"The setUint16() method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16\\\"},\\\"setUint32\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number, littleEndian?: bool)\\\",\\\"!doc\\\":\\\"The setUint32() method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint32\\\"},\\\"setUint8\\\":{\\\"!type\\\":\\\"fn(byteOffset: number, value: number)\\\",\\\"!doc\\\":\\\"The setUint8() method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the DataView.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint8\\\"}}},\\\"Float32Array\\\":\\\"TypedArray\\\",\\\"Float64Array\\\":\\\"TypedArray\\\",\\\"Int16Array\\\":\\\"TypedArray\\\",\\\"Int32Array\\\":\\\"TypedArray\\\",\\\"Int8Array\\\":\\\"TypedArray\\\",\\\"Map\\\":{\\\"!type\\\":\\\"fn(iterable?: [?])\\\",\\\"!doc\\\":\\\"The Map object is a simple key/value map. Any value (both objects and primitive values) may be used as either a key or a value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\\\",\\\"prototype\\\":{\\\"clear\\\":{\\\"!type\\\":\\\"fn()\\\",\\\"!doc\\\":\\\"The clear() method removes all elements from a Map object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear\\\"},\\\"delete\\\":{\\\"!type\\\":\\\"fn(key: ?)\\\",\\\"!doc\\\":\\\"The delete() method removes the specified element from a Map object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete\\\"},\\\"entries\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=[!this.:key, !this.:value]]\\\",\\\"!doc\\\":\\\"The entries() method returns a new Iterator object that contains the [key, value] pairs for each element in the Map object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries\\\"},\\\"forEach\\\":{\\\"!type\\\":\\\"fn(callback: fn(value: ?, key: ?, map: +Map), thisArg?: ?)\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.:value !this.:key !this\\\"],\\\"!doc\\\":\\\"The forEach() method executes a provided function once per each key/value pair in the Map object, in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach\\\"},\\\"get\\\":{\\\"!type\\\":\\\"fn(key: ?) -> !this.:value\\\",\\\"!doc\\\":\\\"The get() method returns a specified element from a Map object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get\\\"},\\\"has\\\":{\\\"!type\\\":\\\"fn(key: ?) -> bool\\\",\\\"!doc\\\":\\\"The has() method returns a boolean indicating whether an element with the specified key exists or not.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has\\\"},\\\"keys\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.:key]\\\",\\\"!doc\\\":\\\"The keys() method returns a new Iterator object that contains the keys for each element in the Map object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys\\\"},\\\"set\\\":{\\\"!type\\\":\\\"fn(key: ?, value: ?) -> !this\\\",\\\"!effects\\\":[\\\"propagate !0 !this.:key\\\",\\\"propagate !1 !this.:value\\\"],\\\"!doc\\\":\\\"The set() method adds a new element with a specified key and value to a Map object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set\\\"},\\\"size\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The size accessor property returns the number of elements in a Map object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size\\\"},\\\"values\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.:value]\\\",\\\"!doc\\\":\\\"The values() method returns a new Iterator object that contains the values for each element in the Map object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values\\\"},\\\":Symbol.iterator\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=[!this.:key, !this.:value]]\\\",\\\"!doc\\\":\\\"Returns a new Iterator object that contains the [key, value] pairs for each element in the Map object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator\\\"}}},\\\"Promise\\\":{\\\"!type\\\":\\\"fn(executor: fn(resolve: fn(value: ?), reject: fn(reason: ?))) -> !custom:Promise_ctor\\\",\\\"!doc\\\":\\\"The Promise object is used for deferred and asynchronous computations. A Promise is in one of the three states:\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\\\",\\\"all\\\":{\\\"!type\\\":\\\"fn(iterable: [+Promise]) -> +Promise[:t=[!0.<i>.:t]]\\\",\\\"!doc\\\":\\\"The Promise.all(iterable) method returns a promise that resolves when all of the promises in the iterable argument have resolved.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\\\"},\\\"race\\\":{\\\"!type\\\":\\\"fn(iterable: [+Promise]) -> !0.<i>\\\",\\\"!doc\\\":\\\"The Promise.race(iterable) method returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\\\"},\\\"reject\\\":\\\"Promise_reject\\\",\\\"resolve\\\":{\\\"!type\\\":\\\"fn(value: ?) -> !custom:Promise_resolve\\\",\\\"!doc\\\":\\\"The Promise.resolve(value) method returns a Promise object that is resolved with the given value. If the value is a thenable (i.e. has a then method), the returned promise will 'follow' that thenable, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\\\"},\\\"prototype\\\":\\\"Promise.prototype\\\"},\\\"Proxy\\\":{\\\"!type\\\":\\\"fn(target: ?, handler: Proxy_handler)\\\",\\\"!doc\\\":\\\"The Proxy object is used to define the custom behavior in JavaScript fundamental operation (e.g. property lookup, assignment, enumeration, function invocation, etc).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\\\",\\\"revocable\\\":{\\\"!type\\\":\\\"fn(target: ?, handler: Proxy_handler) -> Proxy_revocable\\\",\\\"!doc\\\":\\\"The Proxy.revocable() method is used to create a revocable Proxy object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable\\\"}},\\\"Reflect\\\":{\\\"!doc\\\":\\\"Reflect is a built-in object that provides methods for interceptable JavaScript operations.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\\\",\\\"apply\\\":{\\\"!type\\\":\\\"fn(target: fn(), thisArg?: ?, argumentList?: [?]) -> !0.!ret\\\",\\\"!doc\\\":\\\"Calls a target function with arguments as specified.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply\\\"},\\\"construct\\\":{\\\"!type\\\":\\\"fn(target: fn(), argumentList?: [?]) -> ?\\\",\\\"!doc\\\":\\\"Acts like the new operator as a function. It is equivalent to calling new target(...args).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct\\\"},\\\"defineProperty\\\":{\\\"!type\\\":\\\"fn(target: ?, property: string, descriptor: propertyDescriptor) -> bool\\\",\\\"!doc\\\":\\\"The static Reflect.defineProperty() method is like Object.defineProperty() but returns a Boolean.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty\\\"},\\\"deleteProperty\\\":{\\\"!type\\\":\\\"fn(target: ?, property: string) -> bool\\\",\\\"!doc\\\":\\\"Works like the delete operator as a function.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty\\\"},\\\"enumerate\\\":{\\\"!type\\\":\\\"fn(target: ?) -> +iter[:t=string]\\\",\\\"!doc\\\":\\\"Returns an iterator with the enumerable own and inherited properties of the target object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/enumerate\\\"},\\\"get\\\":{\\\"!type\\\":\\\"fn(target: ?, property: string) -> ?\\\",\\\"!doc\\\":\\\"Gets a property from an object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get\\\"},\\\"getOwnPropertyDescriptor\\\":{\\\"!type\\\":\\\"fn(target: ?, property: string) -> ?\\\",\\\"!doc\\\":\\\"Returns a property descriptor of the given property if it exists on the object, undefined otherwise.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getOwnPropertyDescriptor\\\"},\\\"getPrototypeOf\\\":{\\\"!type\\\":\\\"fn(target: ?) -> ?\\\",\\\"!doc\\\":\\\"Returns the prototype of the specified object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf\\\"},\\\"has\\\":{\\\"!type\\\":\\\"fn(target: ?, property: string) -> bool\\\",\\\"!doc\\\":\\\"The static Reflect.has() method works like the in operator as a function.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has\\\"},\\\"isExtensible\\\":{\\\"!type\\\":\\\"fn(target: ?) -> bool\\\",\\\"!doc\\\":\\\"Determines if an object is extensible (whether it can have new properties added to it).\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/isExtensible\\\"},\\\"ownKeys\\\":{\\\"!type\\\":\\\"fn(target: ?) -> [string]\\\",\\\"!doc\\\":\\\"Returns an array of the target object's own property keys.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys\\\"},\\\"preventExtensions\\\":{\\\"!type\\\":\\\"fn(target: ?) -> bool\\\",\\\"!doc\\\":\\\"Prevents new properties from ever being added to an object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/preventExtensions\\\"},\\\"set\\\":{\\\"!type\\\":\\\"fn(target: ?, property: string, value: ?) -> bool\\\",\\\"!doc\\\":\\\"Set a property on an object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set\\\"},\\\"setPrototypeOf\\\":{\\\"!type\\\":\\\"fn(target: ?, prototype: ?) -> bool\\\",\\\"!doc\\\":\\\"Sets the prototype of a specified object to another object or to null.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf\\\"}},\\\"Set\\\":{\\\"!type\\\":\\\"fn(iterable?: [?])\\\",\\\"!doc\\\":\\\"The Set object lets you store unique values of any type, whether primitive values or object references.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\\\",\\\"prototype\\\":{\\\"add\\\":{\\\"!type\\\":\\\"fn(value: ?) -> !this\\\",\\\"!effects\\\":[\\\"propagate !0 !this.:t\\\"],\\\"!doc\\\":\\\"The add() method appends a new element with a specified value to the end of a Set object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add\\\"},\\\"clear\\\":{\\\"!type\\\":\\\"fn()\\\",\\\"!doc\\\":\\\"The clear() method removes all elements from a Set object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/clear\\\"},\\\"delete\\\":{\\\"!type\\\":\\\"fn(value: ?) -> bool\\\",\\\"!doc\\\":\\\"The delete() method removes the specified element from a Set object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete\\\"},\\\"entries\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=[!this.:t]]\\\",\\\"!doc\\\":\\\"The entries() method returns a new Iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. For Set objects there is no key like in Map objects. However, to keep the API similar to the Map object, each entry has the same value for its key and value here, so that an array [value, value] is returned.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/entries\\\"},\\\"forEach\\\":{\\\"!type\\\":\\\"fn(callback: fn(value: ?, value2: ?, set: +Set), thisArg?: ?)\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.:t number !this\\\"],\\\"!doc\\\":\\\"The forEach() method executes a provided function once per each value in the Set object, in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach\\\"},\\\"has\\\":{\\\"!type\\\":\\\"fn(value: ?) -> bool\\\",\\\"!doc\\\":\\\"The has() method returns a boolean indicating whether an element with the specified value exists in a Set object or not.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has\\\"},\\\"keys\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.:t]\\\",\\\"!doc\\\":\\\"The values() method returns a new Iterator object that contains the values for each element in the Set object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/keys\\\"},\\\"size\\\":{\\\"!type\\\":\\\"number\\\",\\\"!doc\\\":\\\"The size accessor property returns the number of elements in a Set object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size\\\"},\\\"values\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.:t]\\\",\\\"!doc\\\":\\\"The values() method returns a new Iterator object that contains the values for each element in the Set object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/values\\\"},\\\":Symbol.iterator\\\":{\\\"!type\\\":\\\"fn() -> +iter[:t=!this.:t]\\\",\\\"!doc\\\":\\\"Returns a new Iterator object that contains the values for each element in the Set object in insertion order.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/@@iterator\\\"}}},\\\"Symbol\\\":{\\\"!type\\\":\\\"fn(description?: string) -> !custom:getSymbol\\\",\\\"!doc\\\":\\\"A symbol is a unique and immutable data type and may be used as an identifier for object properties. The symbol object is an implicit object wrapper for the symbol primitive data type.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\\\",\\\"for\\\":{\\\"!type\\\":\\\"fn(key: string) -> !custom:getSymbol\\\",\\\"!doc\\\":\\\"The Symbol.for(key) method searches for existing symbols in a runtime-wide symbol registry with the given key and returns it if found. Otherwise a new symbol gets created in the global symbol registry with this key.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for\\\"},\\\"keyFor\\\":{\\\"!type\\\":\\\"fn(sym: +Symbol) -> string\\\",\\\"!doc\\\":\\\"The Symbol.keyFor(sym) method retrieves a shared symbol key from the global symbol registry for the given symbol.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/keyFor\\\"},\\\"hasInstance\\\":\\\":Symbol.hasInstance\\\",\\\"isConcatSpreadable\\\":\\\":Symbol.isConcatSpreadable\\\",\\\"iterator\\\":\\\":Symbol.iterator\\\",\\\"asyncIterator\\\":\\\":Symbol.asyncIterator\\\",\\\"match\\\":\\\":Symbol.match\\\",\\\"replace\\\":\\\":Symbol.replace\\\",\\\"search\\\":\\\":Symbol.search\\\",\\\"species\\\":\\\":Symbol.species\\\",\\\"split\\\":\\\":Symbol.split\\\",\\\"toStringTag\\\":\\\":Symbol.toStringTag\\\",\\\"unscopables\\\":\\\":Symbol.unscopables\\\",\\\"prototype\\\":{\\\"!stdProto\\\":\\\"Symbol\\\"}},\\\"Uint16Array\\\":\\\"TypedArray\\\",\\\"Uint32Array\\\":\\\"TypedArray\\\",\\\"Uint8Array\\\":\\\"TypedArray\\\",\\\"Uint8ClampedArray\\\":\\\"TypedArray\\\",\\\"WeakMap\\\":{\\\"!type\\\":\\\"fn(iterable?: [?])\\\",\\\"!doc\\\":\\\"The WeakMap object is a collection of key/value pairs in which the keys are objects and the values can be arbitrary values.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\\\",\\\"prototype\\\":{\\\"delete\\\":{\\\"!type\\\":\\\"fn(key: ?) -> bool\\\",\\\"!doc\\\":\\\"The delete() method removes the specified element from a WeakMap object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/delete\\\"},\\\"get\\\":{\\\"!type\\\":\\\"fn(key: ?) -> !this.:value\\\",\\\"!doc\\\":\\\"The get() method returns a specified element from a WeakMap object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/get\\\"},\\\"has\\\":{\\\"!type\\\":\\\"fn(key: ?) -> bool\\\",\\\"!doc\\\":\\\"The has() method returns a boolean indicating whether an element with the specified key exists in the WeakMap object or not.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/has\\\"},\\\"set\\\":{\\\"!type\\\":\\\"fn(key: ?, value: ?)\\\",\\\"!effects\\\":[\\\"propagate !0 !this.:key\\\",\\\"propagate !1 !this.:value\\\"],\\\"!doc\\\":\\\"The set() method adds a new element with a specified key and value to a WeakMap object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set\\\"}}},\\\"WeakSet\\\":{\\\"!type\\\":\\\"fn(iterable?: [?])\\\",\\\"!doc\\\":\\\"The WeakSet object lets you store weakly held objects in a collection.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\\\",\\\"prototype\\\":{\\\"add\\\":{\\\"!type\\\":\\\"fn(value: ?)\\\",\\\"!doc\\\":\\\"The add() method appends a new object to the end of a WeakSet object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/add\\\"},\\\"delete\\\":{\\\"!type\\\":\\\"fn(value: ?) -> bool\\\",\\\"!doc\\\":\\\"The delete() method removes the specified element from a WeakSet object.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/delete\\\"},\\\"has\\\":{\\\"!type\\\":\\\"fn(value: ?) -> bool\\\",\\\"!doc\\\":\\\"The has() method returns a boolean indicating whether an object exists in a WeakSet or not.\\\",\\\"!url\\\":\\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/has\\\"}}}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9kZWZzL2VjbWFzY3JpcHQuanNvbi5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tern/defs/ecmascript.json\n");

/***/ }),

/***/ "./node_modules/tern/lib/comment.js":
/*!******************************************!*\
  !*** ./node_modules/tern/lib/comment.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(mod) {\n  if (true) // CommonJS\n    return mod(exports);\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(tern.comment || (tern.comment = {}));\n})(function(exports) {\n  function isSpace(ch) {\n    return (ch < 14 && ch > 8) || ch === 32 || ch === 160;\n  }\n\n  function onOwnLine(text, pos) {\n    for (; pos > 0; --pos) {\n      var ch = text.charCodeAt(pos - 1);\n      if (ch == 10) break;\n      if (!isSpace(ch)) return false;\n    }\n    return true;\n  }\n\n  // Gather comments directly before a function\n  exports.commentsBefore = function(text, pos) {\n    var found = null, emptyLines = 0, topIsLineComment;\n    out: while (pos > 0) {\n      var prev = text.charCodeAt(pos - 1);\n      if (prev == 10) {\n        for (var scan = --pos, sawNonWS = false; scan > 0; --scan) {\n          prev = text.charCodeAt(scan - 1);\n          if (prev == 47 && text.charCodeAt(scan - 2) == 47) {\n            if (!onOwnLine(text, scan - 2)) break out;\n            var content = text.slice(scan, pos);\n            if (!emptyLines && topIsLineComment) found[0] = content + \"\\n\" + found[0];\n            else (found || (found = [])).unshift(content);\n            topIsLineComment = true;\n            emptyLines = 0;\n            pos = scan - 2;\n            break;\n          } else if (prev == 10) {\n            if (!sawNonWS && ++emptyLines > 1) break out;\n            break;\n          } else if (!sawNonWS && !isSpace(prev)) {\n            sawNonWS = true;\n          }\n        }\n      } else if (prev == 47 && text.charCodeAt(pos - 2) == 42) {\n        for (var scan = pos - 2; scan > 1; --scan) {\n          if (text.charCodeAt(scan - 1) == 42 && text.charCodeAt(scan - 2) == 47) {\n            if (!onOwnLine(text, scan - 2)) break out;\n            (found || (found = [])).unshift(text.slice(scan, pos - 2));\n            topIsLineComment = false;\n            emptyLines = 0;\n            break;\n          }\n        }\n        pos = scan - 2;\n      } else if (isSpace(prev)) {\n        --pos;\n      } else {\n        break;\n      }\n    }\n    return found;\n  };\n\n  exports.commentAfter = function(text, pos) {\n    while (pos < text.length) {\n      var next = text.charCodeAt(pos);\n      if (next == 47) {\n        var after = text.charCodeAt(pos + 1), end;\n        if (after == 47) // line comment\n          end = text.indexOf(\"\\n\", pos + 2);\n        else if (after == 42) // block comment\n          end = text.indexOf(\"*/\", pos + 2);\n        else\n          return;\n        return text.slice(pos + 2, end < 0 ? text.length : end);\n      } else if (isSpace(next)) {\n        ++pos;\n      }\n    }\n  };\n\n  exports.ensureCommentsBefore = function(text, node) {\n    if (node.hasOwnProperty(\"commentsBefore\")) return node.commentsBefore;\n    return node.commentsBefore = exports.commentsBefore(text, node.start);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9saWIvY29tbWVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJuL2xpYi9jb21tZW50LmpzPzFjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgcmV0dXJuIG1vZChleHBvcnRzKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIHJldHVybiBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgbW9kKTtcbiAgbW9kKHRlcm4uY29tbWVudCB8fCAodGVybi5jb21tZW50ID0ge30pKTtcbn0pKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgZnVuY3Rpb24gaXNTcGFjZShjaCkge1xuICAgIHJldHVybiAoY2ggPCAxNCAmJiBjaCA+IDgpIHx8IGNoID09PSAzMiB8fCBjaCA9PT0gMTYwO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Pd25MaW5lKHRleHQsIHBvcykge1xuICAgIGZvciAoOyBwb3MgPiAwOyAtLXBvcykge1xuICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyAtIDEpO1xuICAgICAgaWYgKGNoID09IDEwKSBicmVhaztcbiAgICAgIGlmICghaXNTcGFjZShjaCkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBHYXRoZXIgY29tbWVudHMgZGlyZWN0bHkgYmVmb3JlIGEgZnVuY3Rpb25cbiAgZXhwb3J0cy5jb21tZW50c0JlZm9yZSA9IGZ1bmN0aW9uKHRleHQsIHBvcykge1xuICAgIHZhciBmb3VuZCA9IG51bGwsIGVtcHR5TGluZXMgPSAwLCB0b3BJc0xpbmVDb21tZW50O1xuICAgIG91dDogd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgIHZhciBwcmV2ID0gdGV4dC5jaGFyQ29kZUF0KHBvcyAtIDEpO1xuICAgICAgaWYgKHByZXYgPT0gMTApIHtcbiAgICAgICAgZm9yICh2YXIgc2NhbiA9IC0tcG9zLCBzYXdOb25XUyA9IGZhbHNlOyBzY2FuID4gMDsgLS1zY2FuKSB7XG4gICAgICAgICAgcHJldiA9IHRleHQuY2hhckNvZGVBdChzY2FuIC0gMSk7XG4gICAgICAgICAgaWYgKHByZXYgPT0gNDcgJiYgdGV4dC5jaGFyQ29kZUF0KHNjYW4gLSAyKSA9PSA0Nykge1xuICAgICAgICAgICAgaWYgKCFvbk93bkxpbmUodGV4dCwgc2NhbiAtIDIpKSBicmVhayBvdXQ7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHRleHQuc2xpY2Uoc2NhbiwgcG9zKTtcbiAgICAgICAgICAgIGlmICghZW1wdHlMaW5lcyAmJiB0b3BJc0xpbmVDb21tZW50KSBmb3VuZFswXSA9IGNvbnRlbnQgKyBcIlxcblwiICsgZm91bmRbMF07XG4gICAgICAgICAgICBlbHNlIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnVuc2hpZnQoY29udGVudCk7XG4gICAgICAgICAgICB0b3BJc0xpbmVDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGVtcHR5TGluZXMgPSAwO1xuICAgICAgICAgICAgcG9zID0gc2NhbiAtIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXYgPT0gMTApIHtcbiAgICAgICAgICAgIGlmICghc2F3Tm9uV1MgJiYgKytlbXB0eUxpbmVzID4gMSkgYnJlYWsgb3V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICghc2F3Tm9uV1MgJiYgIWlzU3BhY2UocHJldikpIHtcbiAgICAgICAgICAgIHNhd05vbldTID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldiA9PSA0NyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zIC0gMikgPT0gNDIpIHtcbiAgICAgICAgZm9yICh2YXIgc2NhbiA9IHBvcyAtIDI7IHNjYW4gPiAxOyAtLXNjYW4pIHtcbiAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHNjYW4gLSAxKSA9PSA0MiAmJiB0ZXh0LmNoYXJDb2RlQXQoc2NhbiAtIDIpID09IDQ3KSB7XG4gICAgICAgICAgICBpZiAoIW9uT3duTGluZSh0ZXh0LCBzY2FuIC0gMikpIGJyZWFrIG91dDtcbiAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnVuc2hpZnQodGV4dC5zbGljZShzY2FuLCBwb3MgLSAyKSk7XG4gICAgICAgICAgICB0b3BJc0xpbmVDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBlbXB0eUxpbmVzID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBzY2FuIC0gMjtcbiAgICAgIH0gZWxzZSBpZiAoaXNTcGFjZShwcmV2KSkge1xuICAgICAgICAtLXBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH07XG5cbiAgZXhwb3J0cy5jb21tZW50QWZ0ZXIgPSBmdW5jdGlvbih0ZXh0LCBwb3MpIHtcbiAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXh0ID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAobmV4dCA9PSA0Nykge1xuICAgICAgICB2YXIgYWZ0ZXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zICsgMSksIGVuZDtcbiAgICAgICAgaWYgKGFmdGVyID09IDQ3KSAvLyBsaW5lIGNvbW1lbnRcbiAgICAgICAgICBlbmQgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgcG9zICsgMik7XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09IDQyKSAvLyBibG9jayBjb21tZW50XG4gICAgICAgICAgZW5kID0gdGV4dC5pbmRleE9mKFwiKi9cIiwgcG9zICsgMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyArIDIsIGVuZCA8IDAgPyB0ZXh0Lmxlbmd0aCA6IGVuZCk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3BhY2UobmV4dCkpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuZW5zdXJlQ29tbWVudHNCZWZvcmUgPSBmdW5jdGlvbih0ZXh0LCBub2RlKSB7XG4gICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkoXCJjb21tZW50c0JlZm9yZVwiKSkgcmV0dXJuIG5vZGUuY29tbWVudHNCZWZvcmU7XG4gICAgcmV0dXJuIG5vZGUuY29tbWVudHNCZWZvcmUgPSBleHBvcnRzLmNvbW1lbnRzQmVmb3JlKHRleHQsIG5vZGUuc3RhcnQpO1xuICB9O1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tern/lib/comment.js\n");

/***/ }),

/***/ "./node_modules/tern/lib/def.js":
/*!**************************************!*\
  !*** ./node_modules/tern/lib/def.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Type description parser\n//\n// Type description JSON files (such as ecmascript.json and browser.json)\n// are used to\n//\n// A) describe types that come from native code\n//\n// B) to cheaply load the types for big libraries, or libraries that\n//    can't be inferred well\n\n(function(mod) {\n  if (true) // CommonJS\n    return exports.init = mod;\n  if (true) // AMD\n    return !(module.exports = {init: mod});\n  tern.def = {init: mod};\n})(function(exports, infer) {\n  \"use strict\";\n\n  function hop(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {\n    this.pos = start || 0;\n    this.spec = spec;\n    this.base = base;\n    this.forceNew = forceNew;\n  };\n\n  function unwrapType(type, self, args) {\n    return type.call ? type(self, args) : type;\n  }\n\n  function extractProp(type, prop) {\n    if (prop == \"!ret\") {\n      if (type.retval) return type.retval;\n      var rv = new infer.AVal;\n      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));\n      return rv;\n    } else {\n      return type.getProp(prop);\n    }\n  }\n\n  function computedFunc(name, args, retType, generator) {\n    return function(self, cArgs) {\n      var realArgs = [];\n      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));\n      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);\n    };\n  }\n  function computedUnion(types) {\n    return function(self, args) {\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    };\n  }\n  function computedArray(inner) {\n    return function(self, args) {\n      return new infer.Arr(inner(self, args));\n    };\n  }\n  function computedTuple(types) {\n    return function(self, args) {\n      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }));\n    };\n  }\n  function computedObject(names, types) {\n    return function(self, args) {\n      var obj = new infer.Obj;\n      names.forEach(function (prop, i) {\n        obj.defProp(prop).addType(unwrapType(types[i], self, args));\n      });\n      return obj;\n    };\n  }\n\n  TypeParser.prototype = {\n    eat: function(str) {\n      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {\n        this.pos += str.length;\n        return true;\n      }\n    },\n    word: function(re) {\n      var word = \"\", ch, re = re || /[\\w$]/;\n      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }\n      return word;\n    },\n    error: function() {\n      throw new Error(\"Unrecognized type spec: \" + this.spec + \" (at \" + this.pos + \")\");\n    },\n    parseFnType: function(comp, name, top, generator) {\n      var args = [], names = [], computed = false;\n      if (!this.eat(\")\")) for (var i = 0; ; ++i) {\n        var colon = this.spec.indexOf(\": \", this.pos), argname;\n        if (colon != -1) {\n          argname = this.spec.slice(this.pos, colon);\n          if (/^(\\.\\.\\.)?[$\\w?]+$/.test(argname))\n            this.pos = colon + 2;\n          else\n            argname = null;\n        }\n        names.push(argname);\n        var argType = this.parseType(comp);\n        if (argType.call) computed = true;\n        args.push(argType);\n        if (!this.eat(\", \")) {\n          this.eat(\")\") || this.error();\n          break;\n        }\n      }\n      var retType, computeRet, computeRetStart, fn;\n      if (this.eat(\" -> \")) {\n        var retStart = this.pos;\n        retType = this.parseType(true);\n        if (retType.call && !computed) {\n          computeRet = retType;\n          retType = infer.ANull;\n          computeRetStart = retStart;\n        }\n      } else {\n        retType = infer.ANull;\n      }\n      if (computed) return computedFunc(name, args, retType, generator);\n\n      if (top && (fn = this.base))\n        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);\n      else\n        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);\n      if (computeRet) fn.computeRet = computeRet;\n      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);\n      return fn;\n    },\n    parseType: function(comp, name, top) {\n      var main = this.parseTypeMaybeProp(comp, name, top);\n      if (!this.eat(\"|\")) return main;\n      var types = [main], computed = main.call;\n      for (;;) {\n        var next = this.parseTypeMaybeProp(comp, name, top);\n        types.push(next);\n        if (next.call) computed = true;\n        if (!this.eat(\"|\")) break;\n      }\n      if (computed) return computedUnion(types);\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) types[i].propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    },\n    parseTypeMaybeProp: function(comp, name, top) {\n      var result = this.parseTypeInner(comp, name, top);\n      while (comp && this.eat(\".\")) result = this.extendWithProp(result);\n      return result;\n    },\n    extendWithProp: function(base) {\n      var propName = this.word(/[\\w<>$!:]/) || this.error();\n      if (base.apply) return function(self, args) {\n        return extractProp(base(self, args), propName);\n      };\n      return extractProp(base, propName);\n    },\n    parseTypeInner: function(comp, name, top) {\n      var gen;\n      if (this.eat(\"fn(\") || (gen = this.eat(\"fn*(\"))) {\n        return this.parseFnType(comp, name, top, gen);\n      } else if (this.eat(\"[\")) {\n        var inner = this.parseType(comp), types, computed = inner.call;\n        while (this.eat(\", \")) {\n          if (!types) types = [inner];\n          var next = this.parseType(comp);\n          types.push(next);\n          computed = computed || next.call;\n        }\n        this.eat(\"]\") || this.error();\n        if (computed) return types ? computedTuple(types) : computedArray(inner);\n        if (top && this.base) {\n          infer.Arr.call(this.base, types || inner);\n          return this.base;\n        }\n        return new infer.Arr(types || inner);\n      } else if (this.eat(\"{\")) {\n        var types = [], names = [], computed = false;\n        if (!this.eat(\"}\")) {\n          for (var i = 0; ; ++i) {\n            var colon = this.spec.indexOf(\": \", this.pos), propName;\n            if (colon != -1) {\n              propName = this.spec.slice(this.pos, colon);\n              if (/^[$\\w?]+$/.test(propName))\n                this.pos = colon + 2;\n              else\n                propName = null;\n            }\n            var propType = this.parseType(comp);\n            if (propType.call) computed = true;\n            names.push(propName);\n            types.push(propType);\n            if (!this.eat(\", \")) {\n              this.eat(\"}\") || this.error();\n              break;\n            }\n          }\n        }\n        if (computed) return computedObject(names, types);\n        var obj = new infer.Obj;\n        names.forEach(function (prop, i) {\n          obj.defProp(prop).addType(types[i]);\n        });\n        return obj;\n      } else if (this.eat(\"+\")) {\n        var path = this.word(/[\\w$<>\\.:!]/);\n        var base = infer.cx().localDefs[path + \".prototype\"];\n        if (!base) {\n          var base = parsePath(path);\n          if (!(base instanceof infer.Obj)) return base;\n          var proto = descendProps(base, [\"prototype\"]);\n          if (proto && (proto = proto.getObjType()))\n            base = proto;\n        }\n        if (comp && this.eat(\"[\")) return this.parsePoly(base);\n        if (top && this.base) {\n          this.base.proto = base;\n          var name = base.hasCtor && base.hasCtor.name || base.name;\n          if (name) this.base.name = name;\n          return this.base;\n        }\n        if (top && this.forceNew) return new infer.Obj(base);\n        return infer.getInstance(base);\n      } else if (this.eat(\":\")) {\n        var name = this.word(/[\\w$\\.]/);\n        return infer.getSymbol(name);\n      } else if (comp && this.eat(\"!\")) {\n        var arg = this.word(/\\d/);\n        if (arg) {\n          arg = Number(arg);\n          return function(_self, args) {return args[arg] || infer.ANull;};\n        } else if (this.eat(\"this\")) {\n          return function(self) {return self;};\n        } else if (this.eat(\"custom:\")) {\n          var fname = this.word(/[\\w$]/);\n          return customFunctions[fname] || function() { return infer.ANull; };\n        } else {\n          return this.fromWord(\"!\" + this.word(/[\\w$<>\\.!:]/));\n        }\n      } else if (this.eat(\"?\")) {\n        return infer.ANull;\n      } else {\n        return this.fromWord(this.word(/[\\w$<>\\.!:`]/));\n      }\n    },\n    fromWord: function(spec) {\n      var cx = infer.cx();\n      switch (spec) {\n      case \"number\": return cx.num;\n      case \"string\": return cx.str;\n      case \"bool\": return cx.bool;\n      case \"<top>\": return cx.topScope;\n      }\n      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];\n      return parsePath(spec);\n    },\n    parsePoly: function(base) {\n      var propName = \"<i>\", match;\n      if (match = this.spec.slice(this.pos).match(/^\\s*([\\w$:]+)\\s*=\\s*/)) {\n        propName = match[1];\n        this.pos += match[0].length;\n      }\n      var value = this.parseType(true);\n      if (!this.eat(\"]\")) this.error();\n      if (value.call) return function(self, args) {\n        var instance = new infer.Obj(base);\n        value(self, args).propagate(instance.defProp(propName));\n        return instance;\n      };\n      var instance = new infer.Obj(base);\n      value.propagate(instance.defProp(propName));\n      return instance;\n    }\n  };\n\n  function addArgCallEffects(type) {\n    if (type instanceof infer.Fn && type.args) for (var i = 0; i < type.args.length; ++i) {\n      var arg = type.args[i];\n      if (arg instanceof infer.Fn && arg.args && arg.args.length) addArgCallEffect(type, i);\n    }\n  }\n\n  function addArgCallEffect(type, argNum) {\n    addEffect(type, function(_self, args) {\n      if (args[argNum]) args[argNum].propagate(\n        new infer.IsCallee(infer.cx().topScope, type.args[argNum].args, null, infer.ANull));\n    });\n  }\n\n  function parseType(spec, name, base, forceNew) {\n    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);\n    if (type instanceof infer.AVal) type.types.forEach(addArgCallEffects);\n    else addArgCallEffects(type);\n    return type;\n  }\n\n  function addEffect(fn, handler, replaceRet) {\n    var oldCmp = fn.computeRet, rv = fn.retval;\n    fn.computeRet = function(self, args, argNodes) {\n      var handled = handler(self, args, argNodes);\n      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;\n      return replaceRet ? handled : old;\n    };\n  }\n\n  var parseEffect = exports.parseEffect = function(effect, fn) {\n    var m;\n    if (effect.indexOf(\"propagate \") == 0) {\n      var p = new TypeParser(effect, 10);\n      var origin = p.parseType(true);\n      if (!p.eat(\" \")) p.error();\n      var target = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));\n      });\n    } else if (effect.indexOf(\"call \") == 0) {\n      var andRet = effect.indexOf(\"and return \", 5) == 5;\n      var p = new TypeParser(effect, andRet ? 16 : 5);\n      var getCallee = p.parseType(true), getSelf = null, getArgs = [];\n      if (p.eat(\" this=\")) getSelf = p.parseType(true);\n      while (p.eat(\" \")) getArgs.push(p.parseType(true));\n      addEffect(fn, function(self, args) {\n        var callee = unwrapType(getCallee, self, args);\n        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];\n        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));\n        var result = andRet ? new infer.AVal : infer.ANull;\n        callee.propagate(new infer.IsCallee(slf, as, null, result));\n        return result;\n      }, andRet);\n    } else if (m = effect.match(/^custom (\\S+)\\s*(.*)/)) {\n      var customFunc = customFunctions[m[1]];\n      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);\n    } else if (effect.indexOf(\"copy \") == 0) {\n      var p = new TypeParser(effect, 5);\n      var getFrom = p.parseType(true);\n      p.eat(\" \");\n      var getTo = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);\n        from.forAllProps(function(prop, val, local) {\n          if (local && prop != \"<i>\")\n            to.propagate(new infer.DefProp(prop, val));\n        });\n      });\n    } else {\n      throw new Error(\"Unknown effect type: \" + effect);\n    }\n  };\n\n  var currentTopScope;\n\n  var parsePath = exports.parsePath = function(path, scope) {\n    var cx = infer.cx(), cached = cx.paths[path], origPath = path;\n    if (cached != null) return cached;\n    cx.paths[path] = infer.ANull;\n\n    var base = scope || currentTopScope || cx.topScope;\n\n    if (cx.localDefs) for (var name in cx.localDefs) {\n      if (path.indexOf(name) == 0) {\n        if (path == name) return cx.paths[path] = cx.localDefs[path];\n        if (path.charAt(name.length) == \".\") {\n          base = cx.localDefs[name];\n          path = path.slice(name.length + 1);\n          break;\n        }\n      }\n    }\n\n    var result = descendProps(base, path.split(\".\"));\n    // Uncomment this to get feedback on your poorly written .json files\n    // if (result == infer.ANull) console.error(\"bad path: \" + origPath + \" (\" + cx.curOrigin + \")\")\n    cx.paths[origPath] = result == infer.ANull ? null : result;\n    return result;\n  };\n\n  function descendProps(base, parts) {\n    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {\n      var prop = parts[i];\n      if (prop.charAt(0) == \"!\") {\n        if (prop == \"!proto\") {\n          base = (base instanceof infer.Obj && base.proto) || infer.ANull;\n        } else {\n          var fn = base.getFunctionType();\n          if (!fn) {\n            base = infer.ANull;\n          } else if (prop == \"!ret\") {\n            base = fn.retval && fn.retval.getType(false) || infer.ANull;\n          } else {\n            var arg = fn.args && fn.args[Number(prop.slice(1))];\n            base = (arg && arg.getType(false)) || infer.ANull;\n          }\n        }\n      } else if (base instanceof infer.Obj &&\n                 (prop == \"prototype\" && base instanceof infer.Fn || base.hasProp(prop))) {\n        var propVal = base.getProp(prop);\n        if (!propVal || propVal.isEmpty())\n          base = infer.ANull;\n        else\n          base = propVal.types[0];\n      } else {\n        base = infer.ANull;\n      }\n    }\n    return base;\n  }\n\n  function emptyObj(ctor) {\n    var empty = Object.create(ctor.prototype);\n    empty.props = Object.create(null);\n    empty.isShell = true;\n    return empty;\n  }\n\n  function isSimpleAnnotation(spec) {\n    if (!spec[\"!type\"] || /^(fn\\(|\\[|\\+)/.test(spec[\"!type\"])) return false;\n    for (var prop in spec)\n      if (prop != \"!type\" && prop != \"!doc\" && prop != \"!url\" && prop != \"!span\" && prop != \"!data\")\n        return false;\n    return true;\n  }\n\n  function passOne(base, spec, path) {\n    if (!base) {\n      var tp = spec[\"!type\"];\n      if (tp) {\n        if (/^fn\\(/.test(tp)) base = emptyObj(infer.Fn);\n        else if (tp.charAt(0) == \"[\") base = emptyObj(infer.Arr);\n        else if (tp.charAt(0) == \"+\") base = emptyObj(infer.Obj);\n        else throw new Error(\"Invalid !type spec: \" + tp);\n      } else if (spec[\"!stdProto\"]) {\n        base = infer.cx().protos[spec[\"!stdProto\"]];\n      } else {\n        base = emptyObj(infer.Obj);\n      }\n      base.name = path;\n    }\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name];\n      if (typeof inner == \"string\" || isSimpleAnnotation(inner)) continue;\n      var prop = base.defProp(name);\n      passOne(prop.getObjType(), inner, path ? path + \".\" + name : name).propagate(prop);\n    }\n    return base;\n  }\n\n  function passTwo(base, spec, path) {\n    if (base.isShell) {\n      delete base.isShell;\n      var tp = spec[\"!type\"];\n      if (tp) {\n        parseType(tp, path, base);\n      } else {\n        var proto = spec[\"!proto\"] && parseType(spec[\"!proto\"]);\n        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);\n      }\n    }\n\n    var effects = spec[\"!effects\"];\n    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)\n      parseEffect(effects[i], base);\n    copyInfo(spec, base);\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + \".\" + name : name;\n      if (typeof inner == \"string\") {\n        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);\n      } else {\n        if (!isSimpleAnnotation(inner))\n          passTwo(known.getObjType(), inner, innerPath);\n        else if (known.isEmpty())\n          parseType(inner[\"!type\"], innerPath, null, true).propagate(known);\n        else\n          continue;\n        if (inner[\"!doc\"]) known.doc = inner[\"!doc\"];\n        if (inner[\"!url\"]) known.url = inner[\"!url\"];\n        if (inner[\"!span\"]) known.span = inner[\"!span\"];\n      }\n    }\n    return base;\n  }\n\n  function copyInfo(spec, type) {\n    if (spec[\"!doc\"]) type.doc = spec[\"!doc\"];\n    if (spec[\"!url\"]) type.url = spec[\"!url\"];\n    if (spec[\"!span\"]) type.span = spec[\"!span\"];\n    if (spec[\"!data\"]) type.metaData = spec[\"!data\"];\n  }\n\n  function doLoadEnvironment(data, scope) {\n    var cx = infer.cx(), server = cx.parent;\n\n    infer.addOrigin(cx.curOrigin = data[\"!name\"] || \"env#\" + cx.origins.length);\n    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);\n\n    if (server) server.signal(\"preLoadDef\", data);\n\n    passOne(scope, data);\n\n    var def = data[\"!define\"];\n    if (def) {\n      for (var name in def) {\n        var spec = def[name];\n        cx.localDefs[name] = typeof spec == \"string\" ? parsePath(spec) : passOne(null, spec, name);\n      }\n      for (var name in def) {\n        var spec = def[name];\n        if (typeof spec != \"string\") passTwo(cx.localDefs[name], def[name], name);\n      }\n    }\n\n    passTwo(scope, data);\n\n    if (server) server.signal(\"postLoadDef\", data);\n\n    cx.curOrigin = cx.localDefs = null;\n  }\n\n  exports.load = function(data, scope) {\n    if (!scope) scope = infer.cx().topScope;\n    var oldScope = currentTopScope;\n    currentTopScope = scope;\n    try {\n      doLoadEnvironment(data, scope);\n    } finally {\n      currentTopScope = oldScope;\n    }\n  };\n\n  exports.parse = function(data, origin, path) {\n    var cx = infer.cx();\n    if (origin) {\n      cx.origin = origin;\n      cx.localDefs = cx.definitions[origin];\n    }\n\n    try {\n      if (typeof data == \"string\")\n        return parseType(data, path);\n      else\n        return passTwo(passOne(null, data, path), data, path);\n    } finally {\n      if (origin) cx.origin = cx.localDefs = null;\n    }\n  };\n\n  // Used to register custom logic for more involved effect or type\n  // computation.\n  var customFunctions = Object.create(null);\n  infer.registerFunction = function(name, f) { customFunctions[name] = f; };\n\n  var IsCreated = infer.constraint({\n    construct: function(created, target, spec) {\n      this.created = created;\n      this.target = target;\n      this.spec = spec;\n    },\n    addType: function(tp) {\n      if (tp instanceof infer.Obj && this.created++ < 5) {\n        var derived = new infer.Obj(tp), spec = this.spec;\n        if (spec instanceof infer.AVal) spec = spec.getObjType(false);\n        if (spec instanceof infer.Obj) for (var prop in spec.props) {\n          var cur = spec.props[prop].types[0];\n          var p = derived.defProp(prop);\n          if (cur && cur instanceof infer.Obj && cur.props.value) {\n            var vtp = cur.props.value.getType(false);\n            if (vtp) p.addType(vtp);\n          }\n        }\n        this.target.addType(derived);\n      }\n    }\n  });\n\n  infer.registerFunction(\"Object_create\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && argNodes[0].value == null)\n      return new infer.Obj();\n\n    var result = new infer.AVal;\n    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));\n    return result;\n  });\n\n  var PropSpec = infer.constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Obj)) return;\n      if (tp.hasProp(\"value\"))\n        tp.getProp(\"value\").propagate(this.target);\n      else if (tp.hasProp(\"get\"))\n        tp.getProp(\"get\").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));\n    }\n  });\n\n  infer.registerFunction(\"Object_defineProperty\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length >= 3 && argNodes[1].type == \"Literal\" &&\n        typeof argNodes[1].value == \"string\") {\n      var obj = args[0], connect = new infer.AVal;\n      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));\n      args[2].propagate(new PropSpec(connect));\n    }\n    return infer.ANull;\n  });\n\n  infer.registerFunction(\"Object_defineProperties\", function(_self, args, argNodes) {\n    if (args.length >= 2) {\n      var obj = args[0];\n      args[1].forAllProps(function(prop, val, local) {\n        if (!local) return;\n        var connect = new infer.AVal;\n        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));\n        val.propagate(new PropSpec(connect));\n      });\n    }\n    return infer.ANull;\n  });\n\n  var IsBound = infer.constraint({\n    construct: function(self, args, target) {\n      this.self = self; this.args = args; this.target = target;\n    },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Fn)) return;\n      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),\n                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));\n      this.self.propagate(tp.self);\n      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)\n        this.args[i].propagate(tp.args[i]);\n    }\n  });\n\n  infer.registerFunction(\"Function_bind\", function(self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    self.propagate(new IsBound(args[0], args.slice(1), result));\n    return result;\n  });\n\n  infer.registerFunction(\"Array_ctor\", function(_self, args) {\n    var arr = new infer.Arr;\n    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {\n      var content = arr.getProp(\"<i>\");\n      for (var i = 0; i < args.length; ++i) args[i].propagate(content);\n    }\n    return arr;\n  });\n\n  function makePromise() {\n    var defs = infer.cx().definitions.ecmascript;\n    return defs && new infer.Obj(defs[\"Promise.prototype\"]);\n  }\n\n  infer.registerFunction(\"Promise_ctor\", function(_self, args, argNodes) {\n    var self = makePromise();\n    if (!self || args.length < 1) return infer.ANull;\n    var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n    var valArg = new infer.AVal;\n    valArg.propagate(valProp);\n    var exec = new infer.Fn(\"execute\", infer.ANull, [valArg], [\"value\"], infer.ANull);\n    var reject = infer.cx().definitions.ecmascript.Promise_reject;\n    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));\n    return self;\n  });\n\n  // Definition for Promise.resolve()\n  // The behavior is different for Promise and non-Promise arguments, so we\n  // need a custom definition to handle the different cases properly.\n  infer.registerFunction(\"Promise_resolve\", function(_self, args, argNodes) {\n    var self = makePromise();\n    if (!self) return infer.ANull;\n    if (args.length) {\n      var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n      var valArg = new infer.AVal;\n      valArg.propagate(valProp);\n      args[0].propagate(new PromiseResolvesTo(valArg));\n    }\n    return self;\n  });\n\n  var PromiseResolvesTo = infer.constraint({\n    construct: function(output) { this.output = output; },\n    addType: function(tp) {\n      if (tp.constructor == infer.Obj && tp.name == \"Promise\" && tp.hasProp(\":t\"))\n        tp.getProp(\":t\").propagate(this.output);\n      else\n        tp.propagate(this.output);\n    }\n  });\n\n  var WG_PROMISE_KEEP_VALUE = 50;\n\n  infer.registerFunction(\"Promise_then\", function(self, args, argNodes) {\n    var fn = args.length && args[0].getFunctionType();\n    var defs = infer.cx().definitions.ecmascript;\n    if (!fn || !defs) return self;\n\n    var result = new infer.Obj(defs[\"Promise.prototype\"]);\n    var value = result.defProp(\":t\", argNodes && argNodes[0]), ty;\n    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(\":t\"))\n      ty.getProp(\":t\").propagate(value, WG_PROMISE_KEEP_VALUE);\n    fn.retval.propagate(new PromiseResolvesTo(value));\n    return result;\n  });\n\n  infer.registerFunction(\"getOwnPropertySymbols\", function(_self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    args[0].forAllProps(function(prop, _val, local) {\n      if (local && prop.charAt(0) == \":\") result.addType(infer.getSymbol(prop.slice(1)));\n    });\n    return result;\n  });\n\n  infer.registerFunction(\"getSymbol\", function(_self, _args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && typeof argNodes[0].value == \"string\")\n      return infer.getSymbol(argNodes[0].value);\n    else\n      return infer.ANull;\n  });\n\n  return exports;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9saWIvZGVmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rlcm4vbGliL2RlZi5qcz84ZWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFR5cGUgZGVzY3JpcHRpb24gcGFyc2VyXG4vL1xuLy8gVHlwZSBkZXNjcmlwdGlvbiBKU09OIGZpbGVzIChzdWNoIGFzIGVjbWFzY3JpcHQuanNvbiBhbmQgYnJvd3Nlci5qc29uKVxuLy8gYXJlIHVzZWQgdG9cbi8vXG4vLyBBKSBkZXNjcmliZSB0eXBlcyB0aGF0IGNvbWUgZnJvbSBuYXRpdmUgY29kZVxuLy9cbi8vIEIpIHRvIGNoZWFwbHkgbG9hZCB0aGUgdHlwZXMgZm9yIGJpZyBsaWJyYXJpZXMsIG9yIGxpYnJhcmllcyB0aGF0XG4vLyAgICBjYW4ndCBiZSBpbmZlcnJlZCB3ZWxsXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIHJldHVybiBleHBvcnRzLmluaXQgPSBtb2Q7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICByZXR1cm4gZGVmaW5lKHtpbml0OiBtb2R9KTtcbiAgdGVybi5kZWYgPSB7aW5pdDogbW9kfTtcbn0pKGZ1bmN0aW9uKGV4cG9ydHMsIGluZmVyKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGhvcChvYmosIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gIH1cblxuICB2YXIgVHlwZVBhcnNlciA9IGV4cG9ydHMuVHlwZVBhcnNlciA9IGZ1bmN0aW9uKHNwZWMsIHN0YXJ0LCBiYXNlLCBmb3JjZU5ldykge1xuICAgIHRoaXMucG9zID0gc3RhcnQgfHwgMDtcbiAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5mb3JjZU5ldyA9IGZvcmNlTmV3O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHVud3JhcFR5cGUodHlwZSwgc2VsZiwgYXJncykge1xuICAgIHJldHVybiB0eXBlLmNhbGwgPyB0eXBlKHNlbGYsIGFyZ3MpIDogdHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RQcm9wKHR5cGUsIHByb3ApIHtcbiAgICBpZiAocHJvcCA9PSBcIiFyZXRcIikge1xuICAgICAgaWYgKHR5cGUucmV0dmFsKSByZXR1cm4gdHlwZS5yZXR2YWw7XG4gICAgICB2YXIgcnYgPSBuZXcgaW5mZXIuQVZhbDtcbiAgICAgIHR5cGUucHJvcGFnYXRlKG5ldyBpbmZlci5Jc0NhbGxlZShpbmZlci5BTnVsbCwgW10sIG51bGwsIHJ2KSk7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlLmdldFByb3AocHJvcCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZWRGdW5jKG5hbWUsIGFyZ3MsIHJldFR5cGUsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihzZWxmLCBjQXJncykge1xuICAgICAgdmFyIHJlYWxBcmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHJlYWxBcmdzLnB1c2godW53cmFwVHlwZShhcmdzW2ldLCBzZWxmLCBjQXJncykpO1xuICAgICAgcmV0dXJuIG5ldyBpbmZlci5GbihuYW1lLCBpbmZlci5BTnVsbCwgcmVhbEFyZ3MsIHVud3JhcFR5cGUocmV0VHlwZSwgc2VsZiwgY0FyZ3MpLCBnZW5lcmF0b3IpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY29tcHV0ZWRVbmlvbih0eXBlcykge1xuICAgIHJldHVybiBmdW5jdGlvbihzZWxmLCBhcmdzKSB7XG4gICAgICB2YXIgdW5pb24gPSBuZXcgaW5mZXIuQVZhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHVud3JhcFR5cGUodHlwZXNbaV0sIHNlbGYsIGFyZ3MpLnByb3BhZ2F0ZSh1bmlvbik7XG4gICAgICB1bmlvbi5tYXhXZWlnaHQgPSAxZTU7XG4gICAgICByZXR1cm4gdW5pb247XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlZEFycmF5KGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGYsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgaW5mZXIuQXJyKGlubmVyKHNlbGYsIGFyZ3MpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNvbXB1dGVkVHVwbGUodHlwZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc2VsZiwgYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBpbmZlci5BcnIodHlwZXMubWFwKGZ1bmN0aW9uKHRwKSB7IHJldHVybiB1bndyYXBUeXBlKHRwLCBzZWxmLCBhcmdzKSB9KSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlZE9iamVjdChuYW1lcywgdHlwZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc2VsZiwgYXJncykge1xuICAgICAgdmFyIG9iaiA9IG5ldyBpbmZlci5PYmo7XG4gICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICAgIG9iai5kZWZQcm9wKHByb3ApLmFkZFR5cGUodW53cmFwVHlwZSh0eXBlc1tpXSwgc2VsZiwgYXJncykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH1cblxuICBUeXBlUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlYXQ6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPT0gMSA/IHRoaXMuc3BlYy5jaGFyQXQodGhpcy5wb3MpID09IHN0ciA6IHRoaXMuc3BlYy5pbmRleE9mKHN0ciwgdGhpcy5wb3MpID09IHRoaXMucG9zKSB7XG4gICAgICAgIHRoaXMucG9zICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgd29yZDogZnVuY3Rpb24ocmUpIHtcbiAgICAgIHZhciB3b3JkID0gXCJcIiwgY2gsIHJlID0gcmUgfHwgL1tcXHckXS87XG4gICAgICB3aGlsZSAoKGNoID0gdGhpcy5zcGVjLmNoYXJBdCh0aGlzLnBvcykpICYmIHJlLnRlc3QoY2gpKSB7IHdvcmQgKz0gY2g7ICsrdGhpcy5wb3M7IH1cbiAgICAgIHJldHVybiB3b3JkO1xuICAgIH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHR5cGUgc3BlYzogXCIgKyB0aGlzLnNwZWMgKyBcIiAoYXQgXCIgKyB0aGlzLnBvcyArIFwiKVwiKTtcbiAgICB9LFxuICAgIHBhcnNlRm5UeXBlOiBmdW5jdGlvbihjb21wLCBuYW1lLCB0b3AsIGdlbmVyYXRvcikge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbmFtZXMgPSBbXSwgY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5lYXQoXCIpXCIpKSBmb3IgKHZhciBpID0gMDsgOyArK2kpIHtcbiAgICAgICAgdmFyIGNvbG9uID0gdGhpcy5zcGVjLmluZGV4T2YoXCI6IFwiLCB0aGlzLnBvcyksIGFyZ25hbWU7XG4gICAgICAgIGlmIChjb2xvbiAhPSAtMSkge1xuICAgICAgICAgIGFyZ25hbWUgPSB0aGlzLnNwZWMuc2xpY2UodGhpcy5wb3MsIGNvbG9uKTtcbiAgICAgICAgICBpZiAoL14oXFwuXFwuXFwuKT9bJFxcdz9dKyQvLnRlc3QoYXJnbmFtZSkpXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGNvbG9uICsgMjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcmduYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcy5wdXNoKGFyZ25hbWUpO1xuICAgICAgICB2YXIgYXJnVHlwZSA9IHRoaXMucGFyc2VUeXBlKGNvbXApO1xuICAgICAgICBpZiAoYXJnVHlwZS5jYWxsKSBjb21wdXRlZCA9IHRydWU7XG4gICAgICAgIGFyZ3MucHVzaChhcmdUeXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLmVhdChcIiwgXCIpKSB7XG4gICAgICAgICAgdGhpcy5lYXQoXCIpXCIpIHx8IHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJldFR5cGUsIGNvbXB1dGVSZXQsIGNvbXB1dGVSZXRTdGFydCwgZm47XG4gICAgICBpZiAodGhpcy5lYXQoXCIgLT4gXCIpKSB7XG4gICAgICAgIHZhciByZXRTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICByZXRUeXBlID0gdGhpcy5wYXJzZVR5cGUodHJ1ZSk7XG4gICAgICAgIGlmIChyZXRUeXBlLmNhbGwgJiYgIWNvbXB1dGVkKSB7XG4gICAgICAgICAgY29tcHV0ZVJldCA9IHJldFR5cGU7XG4gICAgICAgICAgcmV0VHlwZSA9IGluZmVyLkFOdWxsO1xuICAgICAgICAgIGNvbXB1dGVSZXRTdGFydCA9IHJldFN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRUeXBlID0gaW5mZXIuQU51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY29tcHV0ZWQpIHJldHVybiBjb21wdXRlZEZ1bmMobmFtZSwgYXJncywgcmV0VHlwZSwgZ2VuZXJhdG9yKTtcblxuICAgICAgaWYgKHRvcCAmJiAoZm4gPSB0aGlzLmJhc2UpKVxuICAgICAgICBpbmZlci5Gbi5jYWxsKHRoaXMuYmFzZSwgbmFtZSwgaW5mZXIuQU51bGwsIGFyZ3MsIG5hbWVzLCByZXRUeXBlLCBnZW5lcmF0b3IpO1xuICAgICAgZWxzZVxuICAgICAgICBmbiA9IG5ldyBpbmZlci5GbihuYW1lLCBpbmZlci5BTnVsbCwgYXJncywgbmFtZXMsIHJldFR5cGUsIGdlbmVyYXRvcik7XG4gICAgICBpZiAoY29tcHV0ZVJldCkgZm4uY29tcHV0ZVJldCA9IGNvbXB1dGVSZXQ7XG4gICAgICBpZiAoY29tcHV0ZVJldFN0YXJ0ICE9IG51bGwpIGZuLmNvbXB1dGVSZXRTb3VyY2UgPSB0aGlzLnNwZWMuc2xpY2UoY29tcHV0ZVJldFN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICByZXR1cm4gZm47XG4gICAgfSxcbiAgICBwYXJzZVR5cGU6IGZ1bmN0aW9uKGNvbXAsIG5hbWUsIHRvcCkge1xuICAgICAgdmFyIG1haW4gPSB0aGlzLnBhcnNlVHlwZU1heWJlUHJvcChjb21wLCBuYW1lLCB0b3ApO1xuICAgICAgaWYgKCF0aGlzLmVhdChcInxcIikpIHJldHVybiBtYWluO1xuICAgICAgdmFyIHR5cGVzID0gW21haW5dLCBjb21wdXRlZCA9IG1haW4uY2FsbDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBhcnNlVHlwZU1heWJlUHJvcChjb21wLCBuYW1lLCB0b3ApO1xuICAgICAgICB0eXBlcy5wdXNoKG5leHQpO1xuICAgICAgICBpZiAobmV4dC5jYWxsKSBjb21wdXRlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5lYXQoXCJ8XCIpKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjb21wdXRlZCkgcmV0dXJuIGNvbXB1dGVkVW5pb24odHlwZXMpO1xuICAgICAgdmFyIHVuaW9uID0gbmV3IGluZmVyLkFWYWw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB0eXBlc1tpXS5wcm9wYWdhdGUodW5pb24pO1xuICAgICAgdW5pb24ubWF4V2VpZ2h0ID0gMWU1O1xuICAgICAgcmV0dXJuIHVuaW9uO1xuICAgIH0sXG4gICAgcGFyc2VUeXBlTWF5YmVQcm9wOiBmdW5jdGlvbihjb21wLCBuYW1lLCB0b3ApIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlVHlwZUlubmVyKGNvbXAsIG5hbWUsIHRvcCk7XG4gICAgICB3aGlsZSAoY29tcCAmJiB0aGlzLmVhdChcIi5cIikpIHJlc3VsdCA9IHRoaXMuZXh0ZW5kV2l0aFByb3AocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBleHRlbmRXaXRoUHJvcDogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgdmFyIHByb3BOYW1lID0gdGhpcy53b3JkKC9bXFx3PD4kITpdLykgfHwgdGhpcy5lcnJvcigpO1xuICAgICAgaWYgKGJhc2UuYXBwbHkpIHJldHVybiBmdW5jdGlvbihzZWxmLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0UHJvcChiYXNlKHNlbGYsIGFyZ3MpLCBwcm9wTmFtZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGV4dHJhY3RQcm9wKGJhc2UsIHByb3BOYW1lKTtcbiAgICB9LFxuICAgIHBhcnNlVHlwZUlubmVyOiBmdW5jdGlvbihjb21wLCBuYW1lLCB0b3ApIHtcbiAgICAgIHZhciBnZW47XG4gICAgICBpZiAodGhpcy5lYXQoXCJmbihcIikgfHwgKGdlbiA9IHRoaXMuZWF0KFwiZm4qKFwiKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGblR5cGUoY29tcCwgbmFtZSwgdG9wLCBnZW4pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChcIltcIikpIHtcbiAgICAgICAgdmFyIGlubmVyID0gdGhpcy5wYXJzZVR5cGUoY29tcCksIHR5cGVzLCBjb21wdXRlZCA9IGlubmVyLmNhbGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmVhdChcIiwgXCIpKSB7XG4gICAgICAgICAgaWYgKCF0eXBlcykgdHlwZXMgPSBbaW5uZXJdO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5wYXJzZVR5cGUoY29tcCk7XG4gICAgICAgICAgdHlwZXMucHVzaChuZXh0KTtcbiAgICAgICAgICBjb21wdXRlZCA9IGNvbXB1dGVkIHx8IG5leHQuY2FsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdChcIl1cIikgfHwgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoY29tcHV0ZWQpIHJldHVybiB0eXBlcyA/IGNvbXB1dGVkVHVwbGUodHlwZXMpIDogY29tcHV0ZWRBcnJheShpbm5lcik7XG4gICAgICAgIGlmICh0b3AgJiYgdGhpcy5iYXNlKSB7XG4gICAgICAgICAgaW5mZXIuQXJyLmNhbGwodGhpcy5iYXNlLCB0eXBlcyB8fCBpbm5lcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGluZmVyLkFycih0eXBlcyB8fCBpbm5lcik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KFwie1wiKSkge1xuICAgICAgICB2YXIgdHlwZXMgPSBbXSwgbmFtZXMgPSBbXSwgY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmVhdChcIn1cIikpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjb2xvbiA9IHRoaXMuc3BlYy5pbmRleE9mKFwiOiBcIiwgdGhpcy5wb3MpLCBwcm9wTmFtZTtcbiAgICAgICAgICAgIGlmIChjb2xvbiAhPSAtMSkge1xuICAgICAgICAgICAgICBwcm9wTmFtZSA9IHRoaXMuc3BlYy5zbGljZSh0aGlzLnBvcywgY29sb24pO1xuICAgICAgICAgICAgICBpZiAoL15bJFxcdz9dKyQvLnRlc3QocHJvcE5hbWUpKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gY29sb24gKyAyO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gdGhpcy5wYXJzZVR5cGUoY29tcCk7XG4gICAgICAgICAgICBpZiAocHJvcFR5cGUuY2FsbCkgY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZXMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKHByb3BUeXBlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lYXQoXCIsIFwiKSkge1xuICAgICAgICAgICAgICB0aGlzLmVhdChcIn1cIikgfHwgdGhpcy5lcnJvcigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVkKSByZXR1cm4gY29tcHV0ZWRPYmplY3QobmFtZXMsIHR5cGVzKTtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBpbmZlci5PYmo7XG4gICAgICAgIG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgICAgICBvYmouZGVmUHJvcChwcm9wKS5hZGRUeXBlKHR5cGVzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KFwiK1wiKSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMud29yZCgvW1xcdyQ8PlxcLjohXS8pO1xuICAgICAgICB2YXIgYmFzZSA9IGluZmVyLmN4KCkubG9jYWxEZWZzW3BhdGggKyBcIi5wcm90b3R5cGVcIl07XG4gICAgICAgIGlmICghYmFzZSkge1xuICAgICAgICAgIHZhciBiYXNlID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgICAgICAgIGlmICghKGJhc2UgaW5zdGFuY2VvZiBpbmZlci5PYmopKSByZXR1cm4gYmFzZTtcbiAgICAgICAgICB2YXIgcHJvdG8gPSBkZXNjZW5kUHJvcHMoYmFzZSwgW1wicHJvdG90eXBlXCJdKTtcbiAgICAgICAgICBpZiAocHJvdG8gJiYgKHByb3RvID0gcHJvdG8uZ2V0T2JqVHlwZSgpKSlcbiAgICAgICAgICAgIGJhc2UgPSBwcm90bztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcCAmJiB0aGlzLmVhdChcIltcIikpIHJldHVybiB0aGlzLnBhcnNlUG9seShiYXNlKTtcbiAgICAgICAgaWYgKHRvcCAmJiB0aGlzLmJhc2UpIHtcbiAgICAgICAgICB0aGlzLmJhc2UucHJvdG8gPSBiYXNlO1xuICAgICAgICAgIHZhciBuYW1lID0gYmFzZS5oYXNDdG9yICYmIGJhc2UuaGFzQ3Rvci5uYW1lIHx8IGJhc2UubmFtZTtcbiAgICAgICAgICBpZiAobmFtZSkgdGhpcy5iYXNlLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcCAmJiB0aGlzLmZvcmNlTmV3KSByZXR1cm4gbmV3IGluZmVyLk9iaihiYXNlKTtcbiAgICAgICAgcmV0dXJuIGluZmVyLmdldEluc3RhbmNlKGJhc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChcIjpcIikpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLndvcmQoL1tcXHckXFwuXS8pO1xuICAgICAgICByZXR1cm4gaW5mZXIuZ2V0U3ltYm9sKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChjb21wICYmIHRoaXMuZWF0KFwiIVwiKSkge1xuICAgICAgICB2YXIgYXJnID0gdGhpcy53b3JkKC9cXGQvKTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIGFyZyA9IE51bWJlcihhcmcpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfc2VsZiwgYXJncykge3JldHVybiBhcmdzW2FyZ10gfHwgaW5mZXIuQU51bGw7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChcInRoaXNcIikpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZikge3JldHVybiBzZWxmO307XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoXCJjdXN0b206XCIpKSB7XG4gICAgICAgICAgdmFyIGZuYW1lID0gdGhpcy53b3JkKC9bXFx3JF0vKTtcbiAgICAgICAgICByZXR1cm4gY3VzdG9tRnVuY3Rpb25zW2ZuYW1lXSB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIGluZmVyLkFOdWxsOyB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Xb3JkKFwiIVwiICsgdGhpcy53b3JkKC9bXFx3JDw+XFwuITpdLykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KFwiP1wiKSkge1xuICAgICAgICByZXR1cm4gaW5mZXIuQU51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tV29yZCh0aGlzLndvcmQoL1tcXHckPD5cXC4hOmBdLykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnJvbVdvcmQ6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgIHZhciBjeCA9IGluZmVyLmN4KCk7XG4gICAgICBzd2l0Y2ggKHNwZWMpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIGN4Lm51bTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGN4LnN0cjtcbiAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBjeC5ib29sO1xuICAgICAgY2FzZSBcIjx0b3A+XCI6IHJldHVybiBjeC50b3BTY29wZTtcbiAgICAgIH1cbiAgICAgIGlmIChjeC5sb2NhbERlZnMgJiYgc3BlYyBpbiBjeC5sb2NhbERlZnMpIHJldHVybiBjeC5sb2NhbERlZnNbc3BlY107XG4gICAgICByZXR1cm4gcGFyc2VQYXRoKHNwZWMpO1xuICAgIH0sXG4gICAgcGFyc2VQb2x5OiBmdW5jdGlvbihiYXNlKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBcIjxpPlwiLCBtYXRjaDtcbiAgICAgIGlmIChtYXRjaCA9IHRoaXMuc3BlYy5zbGljZSh0aGlzLnBvcykubWF0Y2goL15cXHMqKFtcXHckOl0rKVxccyo9XFxzKi8pKSB7XG4gICAgICAgIHByb3BOYW1lID0gbWF0Y2hbMV07XG4gICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VUeXBlKHRydWUpO1xuICAgICAgaWYgKCF0aGlzLmVhdChcIl1cIikpIHRoaXMuZXJyb3IoKTtcbiAgICAgIGlmICh2YWx1ZS5jYWxsKSByZXR1cm4gZnVuY3Rpb24oc2VsZiwgYXJncykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgaW5mZXIuT2JqKGJhc2UpO1xuICAgICAgICB2YWx1ZShzZWxmLCBhcmdzKS5wcm9wYWdhdGUoaW5zdGFuY2UuZGVmUHJvcChwcm9wTmFtZSkpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9O1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IGluZmVyLk9iaihiYXNlKTtcbiAgICAgIHZhbHVlLnByb3BhZ2F0ZShpbnN0YW5jZS5kZWZQcm9wKHByb3BOYW1lKSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZEFyZ0NhbGxFZmZlY3RzKHR5cGUpIHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIGluZmVyLkZuICYmIHR5cGUuYXJncykgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmcgPSB0eXBlLmFyZ3NbaV07XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgaW5mZXIuRm4gJiYgYXJnLmFyZ3MgJiYgYXJnLmFyZ3MubGVuZ3RoKSBhZGRBcmdDYWxsRWZmZWN0KHR5cGUsIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEFyZ0NhbGxFZmZlY3QodHlwZSwgYXJnTnVtKSB7XG4gICAgYWRkRWZmZWN0KHR5cGUsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzKSB7XG4gICAgICBpZiAoYXJnc1thcmdOdW1dKSBhcmdzW2FyZ051bV0ucHJvcGFnYXRlKFxuICAgICAgICBuZXcgaW5mZXIuSXNDYWxsZWUoaW5mZXIuY3goKS50b3BTY29wZSwgdHlwZS5hcmdzW2FyZ051bV0uYXJncywgbnVsbCwgaW5mZXIuQU51bGwpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZShzcGVjLCBuYW1lLCBiYXNlLCBmb3JjZU5ldykge1xuICAgIHZhciB0eXBlID0gbmV3IFR5cGVQYXJzZXIoc3BlYywgbnVsbCwgYmFzZSwgZm9yY2VOZXcpLnBhcnNlVHlwZShmYWxzZSwgbmFtZSwgdHJ1ZSk7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBpbmZlci5BVmFsKSB0eXBlLnR5cGVzLmZvckVhY2goYWRkQXJnQ2FsbEVmZmVjdHMpO1xuICAgIGVsc2UgYWRkQXJnQ2FsbEVmZmVjdHModHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFZmZlY3QoZm4sIGhhbmRsZXIsIHJlcGxhY2VSZXQpIHtcbiAgICB2YXIgb2xkQ21wID0gZm4uY29tcHV0ZVJldCwgcnYgPSBmbi5yZXR2YWw7XG4gICAgZm4uY29tcHV0ZVJldCA9IGZ1bmN0aW9uKHNlbGYsIGFyZ3MsIGFyZ05vZGVzKSB7XG4gICAgICB2YXIgaGFuZGxlZCA9IGhhbmRsZXIoc2VsZiwgYXJncywgYXJnTm9kZXMpO1xuICAgICAgdmFyIG9sZCA9IG9sZENtcCA/IG9sZENtcChzZWxmLCBhcmdzLCBhcmdOb2RlcykgOiBydjtcbiAgICAgIHJldHVybiByZXBsYWNlUmV0ID8gaGFuZGxlZCA6IG9sZDtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhcnNlRWZmZWN0ID0gZXhwb3J0cy5wYXJzZUVmZmVjdCA9IGZ1bmN0aW9uKGVmZmVjdCwgZm4pIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoZWZmZWN0LmluZGV4T2YoXCJwcm9wYWdhdGUgXCIpID09IDApIHtcbiAgICAgIHZhciBwID0gbmV3IFR5cGVQYXJzZXIoZWZmZWN0LCAxMCk7XG4gICAgICB2YXIgb3JpZ2luID0gcC5wYXJzZVR5cGUodHJ1ZSk7XG4gICAgICBpZiAoIXAuZWF0KFwiIFwiKSkgcC5lcnJvcigpO1xuICAgICAgdmFyIHRhcmdldCA9IHAucGFyc2VUeXBlKHRydWUpO1xuICAgICAgYWRkRWZmZWN0KGZuLCBmdW5jdGlvbihzZWxmLCBhcmdzKSB7XG4gICAgICAgIHVud3JhcFR5cGUob3JpZ2luLCBzZWxmLCBhcmdzKS5wcm9wYWdhdGUodW53cmFwVHlwZSh0YXJnZXQsIHNlbGYsIGFyZ3MpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZWZmZWN0LmluZGV4T2YoXCJjYWxsIFwiKSA9PSAwKSB7XG4gICAgICB2YXIgYW5kUmV0ID0gZWZmZWN0LmluZGV4T2YoXCJhbmQgcmV0dXJuIFwiLCA1KSA9PSA1O1xuICAgICAgdmFyIHAgPSBuZXcgVHlwZVBhcnNlcihlZmZlY3QsIGFuZFJldCA/IDE2IDogNSk7XG4gICAgICB2YXIgZ2V0Q2FsbGVlID0gcC5wYXJzZVR5cGUodHJ1ZSksIGdldFNlbGYgPSBudWxsLCBnZXRBcmdzID0gW107XG4gICAgICBpZiAocC5lYXQoXCIgdGhpcz1cIikpIGdldFNlbGYgPSBwLnBhcnNlVHlwZSh0cnVlKTtcbiAgICAgIHdoaWxlIChwLmVhdChcIiBcIikpIGdldEFyZ3MucHVzaChwLnBhcnNlVHlwZSh0cnVlKSk7XG4gICAgICBhZGRFZmZlY3QoZm4sIGZ1bmN0aW9uKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNhbGxlZSA9IHVud3JhcFR5cGUoZ2V0Q2FsbGVlLCBzZWxmLCBhcmdzKTtcbiAgICAgICAgdmFyIHNsZiA9IGdldFNlbGYgPyB1bndyYXBUeXBlKGdldFNlbGYsIHNlbGYsIGFyZ3MpIDogaW5mZXIuQU51bGwsIGFzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2V0QXJncy5sZW5ndGg7ICsraSkgYXMucHVzaCh1bndyYXBUeXBlKGdldEFyZ3NbaV0sIHNlbGYsIGFyZ3MpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFuZFJldCA/IG5ldyBpbmZlci5BVmFsIDogaW5mZXIuQU51bGw7XG4gICAgICAgIGNhbGxlZS5wcm9wYWdhdGUobmV3IGluZmVyLklzQ2FsbGVlKHNsZiwgYXMsIG51bGwsIHJlc3VsdCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgYW5kUmV0KTtcbiAgICB9IGVsc2UgaWYgKG0gPSBlZmZlY3QubWF0Y2goL15jdXN0b20gKFxcUyspXFxzKiguKikvKSkge1xuICAgICAgdmFyIGN1c3RvbUZ1bmMgPSBjdXN0b21GdW5jdGlvbnNbbVsxXV07XG4gICAgICBpZiAoY3VzdG9tRnVuYykgYWRkRWZmZWN0KGZuLCBtWzJdID8gY3VzdG9tRnVuYyhtWzJdKSA6IGN1c3RvbUZ1bmMpO1xuICAgIH0gZWxzZSBpZiAoZWZmZWN0LmluZGV4T2YoXCJjb3B5IFwiKSA9PSAwKSB7XG4gICAgICB2YXIgcCA9IG5ldyBUeXBlUGFyc2VyKGVmZmVjdCwgNSk7XG4gICAgICB2YXIgZ2V0RnJvbSA9IHAucGFyc2VUeXBlKHRydWUpO1xuICAgICAgcC5lYXQoXCIgXCIpO1xuICAgICAgdmFyIGdldFRvID0gcC5wYXJzZVR5cGUodHJ1ZSk7XG4gICAgICBhZGRFZmZlY3QoZm4sIGZ1bmN0aW9uKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGZyb20gPSB1bndyYXBUeXBlKGdldEZyb20sIHNlbGYsIGFyZ3MpLCB0byA9IHVud3JhcFR5cGUoZ2V0VG8sIHNlbGYsIGFyZ3MpO1xuICAgICAgICBmcm9tLmZvckFsbFByb3BzKGZ1bmN0aW9uKHByb3AsIHZhbCwgbG9jYWwpIHtcbiAgICAgICAgICBpZiAobG9jYWwgJiYgcHJvcCAhPSBcIjxpPlwiKVxuICAgICAgICAgICAgdG8ucHJvcGFnYXRlKG5ldyBpbmZlci5EZWZQcm9wKHByb3AsIHZhbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVmZmVjdCB0eXBlOiBcIiArIGVmZmVjdCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjdXJyZW50VG9wU2NvcGU7XG5cbiAgdmFyIHBhcnNlUGF0aCA9IGV4cG9ydHMucGFyc2VQYXRoID0gZnVuY3Rpb24ocGF0aCwgc2NvcGUpIHtcbiAgICB2YXIgY3ggPSBpbmZlci5jeCgpLCBjYWNoZWQgPSBjeC5wYXRoc1twYXRoXSwgb3JpZ1BhdGggPSBwYXRoO1xuICAgIGlmIChjYWNoZWQgIT0gbnVsbCkgcmV0dXJuIGNhY2hlZDtcbiAgICBjeC5wYXRoc1twYXRoXSA9IGluZmVyLkFOdWxsO1xuXG4gICAgdmFyIGJhc2UgPSBzY29wZSB8fCBjdXJyZW50VG9wU2NvcGUgfHwgY3gudG9wU2NvcGU7XG5cbiAgICBpZiAoY3gubG9jYWxEZWZzKSBmb3IgKHZhciBuYW1lIGluIGN4LmxvY2FsRGVmcykge1xuICAgICAgaWYgKHBhdGguaW5kZXhPZihuYW1lKSA9PSAwKSB7XG4gICAgICAgIGlmIChwYXRoID09IG5hbWUpIHJldHVybiBjeC5wYXRoc1twYXRoXSA9IGN4LmxvY2FsRGVmc1twYXRoXTtcbiAgICAgICAgaWYgKHBhdGguY2hhckF0KG5hbWUubGVuZ3RoKSA9PSBcIi5cIikge1xuICAgICAgICAgIGJhc2UgPSBjeC5sb2NhbERlZnNbbmFtZV07XG4gICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UobmFtZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBkZXNjZW5kUHJvcHMoYmFzZSwgcGF0aC5zcGxpdChcIi5cIikpO1xuICAgIC8vIFVuY29tbWVudCB0aGlzIHRvIGdldCBmZWVkYmFjayBvbiB5b3VyIHBvb3JseSB3cml0dGVuIC5qc29uIGZpbGVzXG4gICAgLy8gaWYgKHJlc3VsdCA9PSBpbmZlci5BTnVsbCkgY29uc29sZS5lcnJvcihcImJhZCBwYXRoOiBcIiArIG9yaWdQYXRoICsgXCIgKFwiICsgY3guY3VyT3JpZ2luICsgXCIpXCIpXG4gICAgY3gucGF0aHNbb3JpZ1BhdGhdID0gcmVzdWx0ID09IGluZmVyLkFOdWxsID8gbnVsbCA6IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRlc2NlbmRQcm9wcyhiYXNlLCBwYXJ0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoICYmIGJhc2UgIT0gaW5mZXIuQU51bGw7ICsraSkge1xuICAgICAgdmFyIHByb3AgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PSBcIiFcIikge1xuICAgICAgICBpZiAocHJvcCA9PSBcIiFwcm90b1wiKSB7XG4gICAgICAgICAgYmFzZSA9IChiYXNlIGluc3RhbmNlb2YgaW5mZXIuT2JqICYmIGJhc2UucHJvdG8pIHx8IGluZmVyLkFOdWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmbiA9IGJhc2UuZ2V0RnVuY3Rpb25UeXBlKCk7XG4gICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgYmFzZSA9IGluZmVyLkFOdWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PSBcIiFyZXRcIikge1xuICAgICAgICAgICAgYmFzZSA9IGZuLnJldHZhbCAmJiBmbi5yZXR2YWwuZ2V0VHlwZShmYWxzZSkgfHwgaW5mZXIuQU51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBmbi5hcmdzICYmIGZuLmFyZ3NbTnVtYmVyKHByb3Auc2xpY2UoMSkpXTtcbiAgICAgICAgICAgIGJhc2UgPSAoYXJnICYmIGFyZy5nZXRUeXBlKGZhbHNlKSkgfHwgaW5mZXIuQU51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJhc2UgaW5zdGFuY2VvZiBpbmZlci5PYmogJiZcbiAgICAgICAgICAgICAgICAgKHByb3AgPT0gXCJwcm90b3R5cGVcIiAmJiBiYXNlIGluc3RhbmNlb2YgaW5mZXIuRm4gfHwgYmFzZS5oYXNQcm9wKHByb3ApKSkge1xuICAgICAgICB2YXIgcHJvcFZhbCA9IGJhc2UuZ2V0UHJvcChwcm9wKTtcbiAgICAgICAgaWYgKCFwcm9wVmFsIHx8IHByb3BWYWwuaXNFbXB0eSgpKVxuICAgICAgICAgIGJhc2UgPSBpbmZlci5BTnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJhc2UgPSBwcm9wVmFsLnR5cGVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9IGluZmVyLkFOdWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5T2JqKGN0b3IpIHtcbiAgICB2YXIgZW1wdHkgPSBPYmplY3QuY3JlYXRlKGN0b3IucHJvdG90eXBlKTtcbiAgICBlbXB0eS5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZW1wdHkuaXNTaGVsbCA9IHRydWU7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW1wbGVBbm5vdGF0aW9uKHNwZWMpIHtcbiAgICBpZiAoIXNwZWNbXCIhdHlwZVwiXSB8fCAvXihmblxcKHxcXFt8XFwrKS8udGVzdChzcGVjW1wiIXR5cGVcIl0pKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKVxuICAgICAgaWYgKHByb3AgIT0gXCIhdHlwZVwiICYmIHByb3AgIT0gXCIhZG9jXCIgJiYgcHJvcCAhPSBcIiF1cmxcIiAmJiBwcm9wICE9IFwiIXNwYW5cIiAmJiBwcm9wICE9IFwiIWRhdGFcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFzc09uZShiYXNlLCBzcGVjLCBwYXRoKSB7XG4gICAgaWYgKCFiYXNlKSB7XG4gICAgICB2YXIgdHAgPSBzcGVjW1wiIXR5cGVcIl07XG4gICAgICBpZiAodHApIHtcbiAgICAgICAgaWYgKC9eZm5cXCgvLnRlc3QodHApKSBiYXNlID0gZW1wdHlPYmooaW5mZXIuRm4pO1xuICAgICAgICBlbHNlIGlmICh0cC5jaGFyQXQoMCkgPT0gXCJbXCIpIGJhc2UgPSBlbXB0eU9iaihpbmZlci5BcnIpO1xuICAgICAgICBlbHNlIGlmICh0cC5jaGFyQXQoMCkgPT0gXCIrXCIpIGJhc2UgPSBlbXB0eU9iaihpbmZlci5PYmopO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgIXR5cGUgc3BlYzogXCIgKyB0cCk7XG4gICAgICB9IGVsc2UgaWYgKHNwZWNbXCIhc3RkUHJvdG9cIl0pIHtcbiAgICAgICAgYmFzZSA9IGluZmVyLmN4KCkucHJvdG9zW3NwZWNbXCIhc3RkUHJvdG9cIl1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9IGVtcHR5T2JqKGluZmVyLk9iaik7XG4gICAgICB9XG4gICAgICBiYXNlLm5hbWUgPSBwYXRoO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykgaWYgKGhvcChzcGVjLCBuYW1lKSAmJiBuYW1lLmNoYXJDb2RlQXQoMCkgIT0gMzMpIHtcbiAgICAgIHZhciBpbm5lciA9IHNwZWNbbmFtZV07XG4gICAgICBpZiAodHlwZW9mIGlubmVyID09IFwic3RyaW5nXCIgfHwgaXNTaW1wbGVBbm5vdGF0aW9uKGlubmVyKSkgY29udGludWU7XG4gICAgICB2YXIgcHJvcCA9IGJhc2UuZGVmUHJvcChuYW1lKTtcbiAgICAgIHBhc3NPbmUocHJvcC5nZXRPYmpUeXBlKCksIGlubmVyLCBwYXRoID8gcGF0aCArIFwiLlwiICsgbmFtZSA6IG5hbWUpLnByb3BhZ2F0ZShwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwYXNzVHdvKGJhc2UsIHNwZWMsIHBhdGgpIHtcbiAgICBpZiAoYmFzZS5pc1NoZWxsKSB7XG4gICAgICBkZWxldGUgYmFzZS5pc1NoZWxsO1xuICAgICAgdmFyIHRwID0gc3BlY1tcIiF0eXBlXCJdO1xuICAgICAgaWYgKHRwKSB7XG4gICAgICAgIHBhcnNlVHlwZSh0cCwgcGF0aCwgYmFzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvdG8gPSBzcGVjW1wiIXByb3RvXCJdICYmIHBhcnNlVHlwZShzcGVjW1wiIXByb3RvXCJdKTtcbiAgICAgICAgaW5mZXIuT2JqLmNhbGwoYmFzZSwgcHJvdG8gaW5zdGFuY2VvZiBpbmZlci5PYmogPyBwcm90byA6IHRydWUsIHBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZmZlY3RzID0gc3BlY1tcIiFlZmZlY3RzXCJdO1xuICAgIGlmIChlZmZlY3RzICYmIGJhc2UgaW5zdGFuY2VvZiBpbmZlci5GbikgZm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgKytpKVxuICAgICAgcGFyc2VFZmZlY3QoZWZmZWN0c1tpXSwgYmFzZSk7XG4gICAgY29weUluZm8oc3BlYywgYmFzZSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIGlmIChob3Aoc3BlYywgbmFtZSkgJiYgbmFtZS5jaGFyQ29kZUF0KDApICE9IDMzKSB7XG4gICAgICB2YXIgaW5uZXIgPSBzcGVjW25hbWVdLCBrbm93biA9IGJhc2UuZGVmUHJvcChuYW1lKSwgaW5uZXJQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIG5hbWUgOiBuYW1lO1xuICAgICAgaWYgKHR5cGVvZiBpbm5lciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChrbm93bi5pc0VtcHR5KCkpIHBhcnNlVHlwZShpbm5lciwgaW5uZXJQYXRoKS5wcm9wYWdhdGUoa25vd24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc1NpbXBsZUFubm90YXRpb24oaW5uZXIpKVxuICAgICAgICAgIHBhc3NUd28oa25vd24uZ2V0T2JqVHlwZSgpLCBpbm5lciwgaW5uZXJQYXRoKTtcbiAgICAgICAgZWxzZSBpZiAoa25vd24uaXNFbXB0eSgpKVxuICAgICAgICAgIHBhcnNlVHlwZShpbm5lcltcIiF0eXBlXCJdLCBpbm5lclBhdGgsIG51bGwsIHRydWUpLnByb3BhZ2F0ZShrbm93bik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlubmVyW1wiIWRvY1wiXSkga25vd24uZG9jID0gaW5uZXJbXCIhZG9jXCJdO1xuICAgICAgICBpZiAoaW5uZXJbXCIhdXJsXCJdKSBrbm93bi51cmwgPSBpbm5lcltcIiF1cmxcIl07XG4gICAgICAgIGlmIChpbm5lcltcIiFzcGFuXCJdKSBrbm93bi5zcGFuID0gaW5uZXJbXCIhc3BhblwiXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5SW5mbyhzcGVjLCB0eXBlKSB7XG4gICAgaWYgKHNwZWNbXCIhZG9jXCJdKSB0eXBlLmRvYyA9IHNwZWNbXCIhZG9jXCJdO1xuICAgIGlmIChzcGVjW1wiIXVybFwiXSkgdHlwZS51cmwgPSBzcGVjW1wiIXVybFwiXTtcbiAgICBpZiAoc3BlY1tcIiFzcGFuXCJdKSB0eXBlLnNwYW4gPSBzcGVjW1wiIXNwYW5cIl07XG4gICAgaWYgKHNwZWNbXCIhZGF0YVwiXSkgdHlwZS5tZXRhRGF0YSA9IHNwZWNbXCIhZGF0YVwiXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvTG9hZEVudmlyb25tZW50KGRhdGEsIHNjb3BlKSB7XG4gICAgdmFyIGN4ID0gaW5mZXIuY3goKSwgc2VydmVyID0gY3gucGFyZW50O1xuXG4gICAgaW5mZXIuYWRkT3JpZ2luKGN4LmN1ck9yaWdpbiA9IGRhdGFbXCIhbmFtZVwiXSB8fCBcImVudiNcIiArIGN4Lm9yaWdpbnMubGVuZ3RoKTtcbiAgICBjeC5sb2NhbERlZnMgPSBjeC5kZWZpbml0aW9uc1tjeC5jdXJPcmlnaW5dID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGlmIChzZXJ2ZXIpIHNlcnZlci5zaWduYWwoXCJwcmVMb2FkRGVmXCIsIGRhdGEpO1xuXG4gICAgcGFzc09uZShzY29wZSwgZGF0YSk7XG5cbiAgICB2YXIgZGVmID0gZGF0YVtcIiFkZWZpbmVcIl07XG4gICAgaWYgKGRlZikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWYpIHtcbiAgICAgICAgdmFyIHNwZWMgPSBkZWZbbmFtZV07XG4gICAgICAgIGN4LmxvY2FsRGVmc1tuYW1lXSA9IHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgoc3BlYykgOiBwYXNzT25lKG51bGwsIHNwZWMsIG5hbWUpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWYpIHtcbiAgICAgICAgdmFyIHNwZWMgPSBkZWZbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2Ygc3BlYyAhPSBcInN0cmluZ1wiKSBwYXNzVHdvKGN4LmxvY2FsRGVmc1tuYW1lXSwgZGVmW25hbWVdLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXNzVHdvKHNjb3BlLCBkYXRhKTtcblxuICAgIGlmIChzZXJ2ZXIpIHNlcnZlci5zaWduYWwoXCJwb3N0TG9hZERlZlwiLCBkYXRhKTtcblxuICAgIGN4LmN1ck9yaWdpbiA9IGN4LmxvY2FsRGVmcyA9IG51bGw7XG4gIH1cblxuICBleHBvcnRzLmxvYWQgPSBmdW5jdGlvbihkYXRhLCBzY29wZSkge1xuICAgIGlmICghc2NvcGUpIHNjb3BlID0gaW5mZXIuY3goKS50b3BTY29wZTtcbiAgICB2YXIgb2xkU2NvcGUgPSBjdXJyZW50VG9wU2NvcGU7XG4gICAgY3VycmVudFRvcFNjb3BlID0gc2NvcGU7XG4gICAgdHJ5IHtcbiAgICAgIGRvTG9hZEVudmlyb25tZW50KGRhdGEsIHNjb3BlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFRvcFNjb3BlID0gb2xkU2NvcGU7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihkYXRhLCBvcmlnaW4sIHBhdGgpIHtcbiAgICB2YXIgY3ggPSBpbmZlci5jeCgpO1xuICAgIGlmIChvcmlnaW4pIHtcbiAgICAgIGN4Lm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgIGN4LmxvY2FsRGVmcyA9IGN4LmRlZmluaXRpb25zW29yaWdpbl07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gcGFyc2VUeXBlKGRhdGEsIHBhdGgpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gcGFzc1R3byhwYXNzT25lKG51bGwsIGRhdGEsIHBhdGgpLCBkYXRhLCBwYXRoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKG9yaWdpbikgY3gub3JpZ2luID0gY3gubG9jYWxEZWZzID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWdpc3RlciBjdXN0b20gbG9naWMgZm9yIG1vcmUgaW52b2x2ZWQgZWZmZWN0IG9yIHR5cGVcbiAgLy8gY29tcHV0YXRpb24uXG4gIHZhciBjdXN0b21GdW5jdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpbmZlci5yZWdpc3RlckZ1bmN0aW9uID0gZnVuY3Rpb24obmFtZSwgZikgeyBjdXN0b21GdW5jdGlvbnNbbmFtZV0gPSBmOyB9O1xuXG4gIHZhciBJc0NyZWF0ZWQgPSBpbmZlci5jb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGNyZWF0ZWQsIHRhcmdldCwgc3BlYykge1xuICAgICAgdGhpcy5jcmVhdGVkID0gY3JlYXRlZDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKHRwKSB7XG4gICAgICBpZiAodHAgaW5zdGFuY2VvZiBpbmZlci5PYmogJiYgdGhpcy5jcmVhdGVkKysgPCA1KSB7XG4gICAgICAgIHZhciBkZXJpdmVkID0gbmV3IGluZmVyLk9iaih0cCksIHNwZWMgPSB0aGlzLnNwZWM7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgaW5mZXIuQVZhbCkgc3BlYyA9IHNwZWMuZ2V0T2JqVHlwZShmYWxzZSk7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgaW5mZXIuT2JqKSBmb3IgKHZhciBwcm9wIGluIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICB2YXIgY3VyID0gc3BlYy5wcm9wc1twcm9wXS50eXBlc1swXTtcbiAgICAgICAgICB2YXIgcCA9IGRlcml2ZWQuZGVmUHJvcChwcm9wKTtcbiAgICAgICAgICBpZiAoY3VyICYmIGN1ciBpbnN0YW5jZW9mIGluZmVyLk9iaiAmJiBjdXIucHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2dHAgPSBjdXIucHJvcHMudmFsdWUuZ2V0VHlwZShmYWxzZSk7XG4gICAgICAgICAgICBpZiAodnRwKSBwLmFkZFR5cGUodnRwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YXJnZXQuYWRkVHlwZShkZXJpdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGluZmVyLnJlZ2lzdGVyRnVuY3Rpb24oXCJPYmplY3RfY3JlYXRlXCIsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzLCBhcmdOb2Rlcykge1xuICAgIGlmIChhcmdOb2RlcyAmJiBhcmdOb2Rlcy5sZW5ndGggJiYgYXJnTm9kZXNbMF0udHlwZSA9PSBcIkxpdGVyYWxcIiAmJiBhcmdOb2Rlc1swXS52YWx1ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIG5ldyBpbmZlci5PYmooKTtcblxuICAgIHZhciByZXN1bHQgPSBuZXcgaW5mZXIuQVZhbDtcbiAgICBpZiAoYXJnc1swXSkgYXJnc1swXS5wcm9wYWdhdGUobmV3IElzQ3JlYXRlZCgwLCByZXN1bHQsIGFyZ3NbMV0pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICB2YXIgUHJvcFNwZWMgPSBpbmZlci5jb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHRhcmdldCkgeyB0aGlzLnRhcmdldCA9IHRhcmdldDsgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0cCkge1xuICAgICAgaWYgKCEodHAgaW5zdGFuY2VvZiBpbmZlci5PYmopKSByZXR1cm47XG4gICAgICBpZiAodHAuaGFzUHJvcChcInZhbHVlXCIpKVxuICAgICAgICB0cC5nZXRQcm9wKFwidmFsdWVcIikucHJvcGFnYXRlKHRoaXMudGFyZ2V0KTtcbiAgICAgIGVsc2UgaWYgKHRwLmhhc1Byb3AoXCJnZXRcIikpXG4gICAgICAgIHRwLmdldFByb3AoXCJnZXRcIikucHJvcGFnYXRlKG5ldyBpbmZlci5Jc0NhbGxlZShpbmZlci5BTnVsbCwgW10sIG51bGwsIHRoaXMudGFyZ2V0KSk7XG4gICAgfVxuICB9KTtcblxuICBpbmZlci5yZWdpc3RlckZ1bmN0aW9uKFwiT2JqZWN0X2RlZmluZVByb3BlcnR5XCIsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzLCBhcmdOb2Rlcykge1xuICAgIGlmIChhcmdOb2RlcyAmJiBhcmdOb2Rlcy5sZW5ndGggPj0gMyAmJiBhcmdOb2Rlc1sxXS50eXBlID09IFwiTGl0ZXJhbFwiICYmXG4gICAgICAgIHR5cGVvZiBhcmdOb2Rlc1sxXS52YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgb2JqID0gYXJnc1swXSwgY29ubmVjdCA9IG5ldyBpbmZlci5BVmFsO1xuICAgICAgb2JqLnByb3BhZ2F0ZShuZXcgaW5mZXIuRGVmUHJvcChhcmdOb2Rlc1sxXS52YWx1ZSwgY29ubmVjdCwgYXJnTm9kZXNbMV0pKTtcbiAgICAgIGFyZ3NbMl0ucHJvcGFnYXRlKG5ldyBQcm9wU3BlYyhjb25uZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZlci5BTnVsbDtcbiAgfSk7XG5cbiAgaW5mZXIucmVnaXN0ZXJGdW5jdGlvbihcIk9iamVjdF9kZWZpbmVQcm9wZXJ0aWVzXCIsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzLCBhcmdOb2Rlcykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgb2JqID0gYXJnc1swXTtcbiAgICAgIGFyZ3NbMV0uZm9yQWxsUHJvcHMoZnVuY3Rpb24ocHJvcCwgdmFsLCBsb2NhbCkge1xuICAgICAgICBpZiAoIWxvY2FsKSByZXR1cm47XG4gICAgICAgIHZhciBjb25uZWN0ID0gbmV3IGluZmVyLkFWYWw7XG4gICAgICAgIG9iai5wcm9wYWdhdGUobmV3IGluZmVyLkRlZlByb3AocHJvcCwgY29ubmVjdCwgYXJnTm9kZXMgJiYgYXJnTm9kZXNbMV0pKTtcbiAgICAgICAgdmFsLnByb3BhZ2F0ZShuZXcgUHJvcFNwZWMoY29ubmVjdCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZlci5BTnVsbDtcbiAgfSk7XG5cbiAgdmFyIElzQm91bmQgPSBpbmZlci5jb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHNlbGYsIGFyZ3MsIHRhcmdldCkge1xuICAgICAgdGhpcy5zZWxmID0gc2VsZjsgdGhpcy5hcmdzID0gYXJnczsgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0cCkge1xuICAgICAgaWYgKCEodHAgaW5zdGFuY2VvZiBpbmZlci5GbikpIHJldHVybjtcbiAgICAgIHRoaXMudGFyZ2V0LmFkZFR5cGUobmV3IGluZmVyLkZuKHRwLm5hbWUsIGluZmVyLkFOdWxsLCB0cC5hcmdzLnNsaWNlKHRoaXMuYXJncy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHAuYXJnTmFtZXMuc2xpY2UodGhpcy5hcmdzLmxlbmd0aCksIHRwLnJldHZhbCwgdHAuZ2VuZXJhdG9yKSk7XG4gICAgICB0aGlzLnNlbGYucHJvcGFnYXRlKHRwLnNlbGYpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbih0cC5hcmdzLmxlbmd0aCwgdGhpcy5hcmdzLmxlbmd0aCk7ICsraSlcbiAgICAgICAgdGhpcy5hcmdzW2ldLnByb3BhZ2F0ZSh0cC5hcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluZmVyLnJlZ2lzdGVyRnVuY3Rpb24oXCJGdW5jdGlvbl9iaW5kXCIsIGZ1bmN0aW9uKHNlbGYsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MubGVuZ3RoKSByZXR1cm4gaW5mZXIuQU51bGw7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBpbmZlci5BVmFsO1xuICAgIHNlbGYucHJvcGFnYXRlKG5ldyBJc0JvdW5kKGFyZ3NbMF0sIGFyZ3Muc2xpY2UoMSksIHJlc3VsdCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIGluZmVyLnJlZ2lzdGVyRnVuY3Rpb24oXCJBcnJheV9jdG9yXCIsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzKSB7XG4gICAgdmFyIGFyciA9IG5ldyBpbmZlci5BcnI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9IDEgfHwgIWFyZ3NbMF0uaGFzVHlwZShpbmZlci5jeCgpLm51bSkpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYXJyLmdldFByb3AoXCI8aT5cIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIGFyZ3NbaV0ucHJvcGFnYXRlKGNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9KTtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZSgpIHtcbiAgICB2YXIgZGVmcyA9IGluZmVyLmN4KCkuZGVmaW5pdGlvbnMuZWNtYXNjcmlwdDtcbiAgICByZXR1cm4gZGVmcyAmJiBuZXcgaW5mZXIuT2JqKGRlZnNbXCJQcm9taXNlLnByb3RvdHlwZVwiXSk7XG4gIH1cblxuICBpbmZlci5yZWdpc3RlckZ1bmN0aW9uKFwiUHJvbWlzZV9jdG9yXCIsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzLCBhcmdOb2Rlcykge1xuICAgIHZhciBzZWxmID0gbWFrZVByb21pc2UoKTtcbiAgICBpZiAoIXNlbGYgfHwgYXJncy5sZW5ndGggPCAxKSByZXR1cm4gaW5mZXIuQU51bGw7XG4gICAgdmFyIHZhbFByb3AgPSBzZWxmLmRlZlByb3AoXCI6dFwiLCBhcmdOb2RlcyAmJiBhcmdOb2Rlc1swXSk7XG4gICAgdmFyIHZhbEFyZyA9IG5ldyBpbmZlci5BVmFsO1xuICAgIHZhbEFyZy5wcm9wYWdhdGUodmFsUHJvcCk7XG4gICAgdmFyIGV4ZWMgPSBuZXcgaW5mZXIuRm4oXCJleGVjdXRlXCIsIGluZmVyLkFOdWxsLCBbdmFsQXJnXSwgW1widmFsdWVcIl0sIGluZmVyLkFOdWxsKTtcbiAgICB2YXIgcmVqZWN0ID0gaW5mZXIuY3goKS5kZWZpbml0aW9ucy5lY21hc2NyaXB0LlByb21pc2VfcmVqZWN0O1xuICAgIGFyZ3NbMF0ucHJvcGFnYXRlKG5ldyBpbmZlci5Jc0NhbGxlZShpbmZlci5BTnVsbCwgW2V4ZWMsIHJlamVjdF0sIG51bGwsIGluZmVyLkFOdWxsKSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0pO1xuXG4gIC8vIERlZmluaXRpb24gZm9yIFByb21pc2UucmVzb2x2ZSgpXG4gIC8vIFRoZSBiZWhhdmlvciBpcyBkaWZmZXJlbnQgZm9yIFByb21pc2UgYW5kIG5vbi1Qcm9taXNlIGFyZ3VtZW50cywgc28gd2VcbiAgLy8gbmVlZCBhIGN1c3RvbSBkZWZpbml0aW9uIHRvIGhhbmRsZSB0aGUgZGlmZmVyZW50IGNhc2VzIHByb3Blcmx5LlxuICBpbmZlci5yZWdpc3RlckZ1bmN0aW9uKFwiUHJvbWlzZV9yZXNvbHZlXCIsIGZ1bmN0aW9uKF9zZWxmLCBhcmdzLCBhcmdOb2Rlcykge1xuICAgIHZhciBzZWxmID0gbWFrZVByb21pc2UoKTtcbiAgICBpZiAoIXNlbGYpIHJldHVybiBpbmZlci5BTnVsbDtcbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgIHZhciB2YWxQcm9wID0gc2VsZi5kZWZQcm9wKFwiOnRcIiwgYXJnTm9kZXMgJiYgYXJnTm9kZXNbMF0pO1xuICAgICAgdmFyIHZhbEFyZyA9IG5ldyBpbmZlci5BVmFsO1xuICAgICAgdmFsQXJnLnByb3BhZ2F0ZSh2YWxQcm9wKTtcbiAgICAgIGFyZ3NbMF0ucHJvcGFnYXRlKG5ldyBQcm9taXNlUmVzb2x2ZXNUbyh2YWxBcmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0pO1xuXG4gIHZhciBQcm9taXNlUmVzb2x2ZXNUbyA9IGluZmVyLmNvbnN0cmFpbnQoe1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24ob3V0cHV0KSB7IHRoaXMub3V0cHV0ID0gb3V0cHV0OyB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKHRwKSB7XG4gICAgICBpZiAodHAuY29uc3RydWN0b3IgPT0gaW5mZXIuT2JqICYmIHRwLm5hbWUgPT0gXCJQcm9taXNlXCIgJiYgdHAuaGFzUHJvcChcIjp0XCIpKVxuICAgICAgICB0cC5nZXRQcm9wKFwiOnRcIikucHJvcGFnYXRlKHRoaXMub3V0cHV0KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdHAucHJvcGFnYXRlKHRoaXMub3V0cHV0KTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBXR19QUk9NSVNFX0tFRVBfVkFMVUUgPSA1MDtcblxuICBpbmZlci5yZWdpc3RlckZ1bmN0aW9uKFwiUHJvbWlzZV90aGVuXCIsIGZ1bmN0aW9uKHNlbGYsIGFyZ3MsIGFyZ05vZGVzKSB7XG4gICAgdmFyIGZuID0gYXJncy5sZW5ndGggJiYgYXJnc1swXS5nZXRGdW5jdGlvblR5cGUoKTtcbiAgICB2YXIgZGVmcyA9IGluZmVyLmN4KCkuZGVmaW5pdGlvbnMuZWNtYXNjcmlwdDtcbiAgICBpZiAoIWZuIHx8ICFkZWZzKSByZXR1cm4gc2VsZjtcblxuICAgIHZhciByZXN1bHQgPSBuZXcgaW5mZXIuT2JqKGRlZnNbXCJQcm9taXNlLnByb3RvdHlwZVwiXSk7XG4gICAgdmFyIHZhbHVlID0gcmVzdWx0LmRlZlByb3AoXCI6dFwiLCBhcmdOb2RlcyAmJiBhcmdOb2Rlc1swXSksIHR5O1xuICAgIGlmIChmbi5yZXR2YWwuaXNFbXB0eSgpICYmICh0eSA9IHNlbGYuZ2V0VHlwZSgpKSBpbnN0YW5jZW9mIGluZmVyLk9iaiAmJiB0eS5oYXNQcm9wKFwiOnRcIikpXG4gICAgICB0eS5nZXRQcm9wKFwiOnRcIikucHJvcGFnYXRlKHZhbHVlLCBXR19QUk9NSVNFX0tFRVBfVkFMVUUpO1xuICAgIGZuLnJldHZhbC5wcm9wYWdhdGUobmV3IFByb21pc2VSZXNvbHZlc1RvKHZhbHVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG5cbiAgaW5mZXIucmVnaXN0ZXJGdW5jdGlvbihcImdldE93blByb3BlcnR5U3ltYm9sc1wiLCBmdW5jdGlvbihfc2VsZiwgYXJncykge1xuICAgIGlmICghYXJncy5sZW5ndGgpIHJldHVybiBpbmZlci5BTnVsbDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IGluZmVyLkFWYWw7XG4gICAgYXJnc1swXS5mb3JBbGxQcm9wcyhmdW5jdGlvbihwcm9wLCBfdmFsLCBsb2NhbCkge1xuICAgICAgaWYgKGxvY2FsICYmIHByb3AuY2hhckF0KDApID09IFwiOlwiKSByZXN1bHQuYWRkVHlwZShpbmZlci5nZXRTeW1ib2wocHJvcC5zbGljZSgxKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIGluZmVyLnJlZ2lzdGVyRnVuY3Rpb24oXCJnZXRTeW1ib2xcIiwgZnVuY3Rpb24oX3NlbGYsIF9hcmdzLCBhcmdOb2Rlcykge1xuICAgIGlmIChhcmdOb2RlcyAmJiBhcmdOb2Rlcy5sZW5ndGggJiYgYXJnTm9kZXNbMF0udHlwZSA9PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2YgYXJnTm9kZXNbMF0udmFsdWUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBpbmZlci5nZXRTeW1ib2woYXJnTm9kZXNbMF0udmFsdWUpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBpbmZlci5BTnVsbDtcbiAgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tern/lib/def.js\n");

/***/ }),

/***/ "./node_modules/tern/lib/infer.js":
/*!****************************************!*\
  !*** ./node_modules/tern/lib/infer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Main type inference engine\n\n// Walks an AST, building up a graph of abstract values and constraints\n// that cause types to flow from one node to another. Also defines a\n// number of utilities for accessing ASTs and scopes.\n\n// Analysis is done in a context, which is tracked by the dynamically\n// bound cx variable. Use withContext to set the current context.\n\n// For memory-saving reasons, individual types export an interface\n// similar to abstract values (which can hold multiple types), and can\n// thus be used in place abstract values that only ever contain a\n// single type.\n\n(function(root, mod) {\n  if (true) // CommonJS\n    return mod(exports, __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.mjs\"), __webpack_require__(/*! acorn-loose */ \"./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.mjs\"), __webpack_require__(/*! acorn-walk */ \"./node_modules/tern/node_modules/acorn-walk/dist/walk.mjs\"),\n               __webpack_require__(/*! ./def */ \"./node_modules/tern/lib/def.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\"));\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! acorn/dist/acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.js\"), __webpack_require__(/*! acorn-loose/dist/acorn-loose */ \"./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.js\"), __webpack_require__(/*! acorn-walk/dist/walk */ \"./node_modules/tern/node_modules/acorn-walk/dist/walk.js\"), __webpack_require__(/*! ./def */ \"./node_modules/tern/lib/def.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.tern || (root.tern = {}), acorn, acorn.loose, acorn.walk, tern.def, tern.signal); // Plain browser env\n})(this, function(exports, acorn, acorn_loose, walk, def, signal) {\n  \"use strict\";\n\n  var toString = exports.toString = function(type, maxDepth, parent) {\n    if (!type || type == parent || maxDepth && maxDepth < -3) return \"?\";\n    return type.toString(maxDepth, parent);\n  };\n\n  // A variant of AVal used for unknown, dead-end values. Also serves\n  // as prototype for AVals, Types, and Constraints because it\n  // implements 'empty' versions of all the methods that the code\n  // expects.\n  var ANull = exports.ANull = signal.mixin({\n    addType: function() {},\n    propagate: function() {},\n    getProp: function() { return ANull; },\n    forAllProps: function() {},\n    hasType: function() { return false; },\n    isEmpty: function() { return true; },\n    getFunctionType: function() {},\n    getObjType: function() {},\n    getSymbolType: function() {},\n    getType: function() {},\n    gatherProperties: function() {},\n    propagatesTo: function() {},\n    typeHint: function() {},\n    propHint: function() {},\n    toString: function() { return \"?\"; }\n  });\n\n  function extend(proto, props) {\n    var obj = Object.create(proto);\n    if (props) for (var prop in props) obj[prop] = props[prop];\n    return obj;\n  }\n\n  // ABSTRACT VALUES\n\n  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,\n      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,\n      WG_PHANTOM_OBJ = 1,\n      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;\n\n  var AVal = exports.AVal = function() {\n    this.types = [];\n    this.forward = null;\n    this.maxWeight = 0;\n  };\n  AVal.prototype = extend(ANull, {\n    addType: function(type, weight) {\n      weight = weight || WG_DEFAULT;\n      if (this.maxWeight < weight) {\n        this.maxWeight = weight;\n        if (this.types.length == 1 && this.types[0] == type) return;\n        this.types.length = 0;\n      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {\n        return;\n      }\n\n      this.signal(\"addType\", type);\n      this.types.push(type);\n      var forward = this.forward;\n      if (forward) withWorklist(function(add) {\n        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);\n      });\n    },\n\n    propagate: function(target, weight) {\n      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;\n      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);\n      (this.forward || (this.forward = [])).push(target);\n      var types = this.types;\n      if (types.length) withWorklist(function(add) {\n        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);\n      });\n    },\n\n    getProp: function(prop) {\n      if (ignoredProp(prop)) return ANull;\n      var found = (this.props || (this.props = Object.create(null)))[prop];\n      if (!found) {\n        found = this.props[prop] = new AVal;\n        this.propagate(new GetProp(prop, found));\n      }\n      return found;\n    },\n\n    forAllProps: function(c) {\n      this.propagate(new ForAllProps(c));\n    },\n\n    hasType: function(type) {\n      return this.types.indexOf(type) > -1;\n    },\n    isEmpty: function() { return this.types.length === 0; },\n    getFunctionType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Fn) return this.types[i];\n    },\n    getObjType: function() {\n      var seen = null;\n      for (var i = this.types.length - 1; i >= 0; --i) {\n        var type = this.types[i];\n        if (!(type instanceof Obj)) continue;\n        if (type.name) return type;\n        if (!seen) seen = type;\n      }\n      return seen;\n    },\n\n    getSymbolType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Sym) return this.types[i];\n    },\n\n    getType: function(guess) {\n      if (this.types.length === 0 && guess !== false) return this.makeupType();\n      if (this.types.length === 1) return this.types[0];\n      return canonicalType(this.types);\n    },\n\n    toString: function(maxDepth, parent) {\n      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);\n      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);\n      var simplified = simplifyTypes(this.types);\n      if (simplified.length > 2) return \"?\";\n      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join(\"|\");\n    },\n\n    makeupPropType: function(obj) {\n      var propName = this.propertyName;\n\n      var protoProp = obj.proto && obj.proto.hasProp(propName);\n      if (protoProp) {\n        var fromProto = protoProp.getType();\n        if (fromProto) return fromProto;\n      }\n\n      if (propName != \"<i>\") {\n        var computedProp = obj.hasProp(\"<i>\");\n        if (computedProp) return computedProp.getType();\n      } else if (obj.props[\"<i>\"] != this) {\n        for (var prop in obj.props) {\n          var val = obj.props[prop];\n          if (!val.isEmpty()) return val.getType();\n        }\n      }\n    },\n\n    makeupType: function() {\n      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);\n      if (computed) return computed;\n\n      if (!this.forward) return null;\n      for (var i = this.forward.length - 1; i >= 0; --i) {\n        var hint = this.forward[i].typeHint();\n        if (hint && !hint.isEmpty()) {guessing = true; return hint;}\n      }\n\n      var props = Object.create(null), foundProp = null;\n      for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop && prop != \"length\" && prop != \"<i>\" && prop != \"\" && prop != cx.completingProperty) {\n          props[prop] = true;\n          foundProp = prop;\n        }\n      }\n      if (!foundProp) return null;\n\n      var objs = objsWithProp(foundProp);\n      if (objs) {\n        var matches = [];\n        search: for (var i = 0; i < objs.length; ++i) {\n          var obj = objs[i];\n          for (var prop in props) if (!obj.hasProp(prop)) continue search;\n          if (obj.hasCtor) obj = getInstance(obj);\n          matches.push(obj);\n        }\n        var canon = canonicalType(matches);\n        if (canon) {guessing = true; return canon;}\n      }\n    },\n\n    typeHint: function() { return this.types.length ? this.getType() : null; },\n    propagatesTo: function() { return this; },\n\n    gatherProperties: function(f, depth) {\n      for (var i = 0; i < this.types.length; ++i)\n        this.types[i].gatherProperties(f, depth);\n    },\n\n    guessProperties: function(f) {\n      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop) f(prop, null, 0);\n      }\n      var guessed = this.makeupType();\n      if (guessed) guessed.gatherProperties(f);\n    }\n  });\n\n  function similarAVal(a, b, depth) {\n    var typeA = a.getType(false), typeB = b.getType(false);\n    if (!typeA || !typeB) return true;\n    return similarType(typeA, typeB, depth);\n  }\n\n  function similarType(a, b, depth) {\n    if (!a || depth >= 5) return b;\n    if (!a || a == b) return a;\n    if (!b) return a;\n    if (a.constructor != b.constructor) return false;\n    if (a.constructor == Arr) {\n      var innerA = a.getProp(\"<i>\").getType(false);\n      if (!innerA) return b;\n      var innerB = b.getProp(\"<i>\").getType(false);\n      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;\n    } else if (a.constructor == Obj) {\n      var propsA = 0, propsB = 0, same = 0;\n      for (var prop in a.props) {\n        propsA++;\n        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))\n          same++;\n      }\n      for (var prop in b.props) propsB++;\n      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;\n      return propsA > propsB ? a : b;\n    } else if (a.constructor == Fn) {\n      if (a.args.length != b.args.length ||\n          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||\n          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))\n        return false;\n      return a;\n    } else {\n      return false;\n    }\n  }\n\n  var simplifyTypes = exports.simplifyTypes = function(types) {\n    var found = [];\n    outer: for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      for (var j = 0; j < found.length; j++) {\n        var similar = similarType(tp, found[j], 0);\n        if (similar) {\n          found[j] = similar;\n          continue outer;\n        }\n      }\n      found.push(tp);\n    }\n    return found;\n  };\n\n  function canonicalType(types) {\n    var arrays = 0, fns = 0, objs = 0, prim = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      if (tp instanceof Arr) ++arrays;\n      else if (tp instanceof Fn) ++fns;\n      else if (tp instanceof Obj) ++objs;\n      else if (tp instanceof Prim) {\n        if (prim && tp.name != prim.name) return null;\n        prim = tp;\n      }\n    }\n    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);\n    if (kinds > 1) return null;\n    if (prim) return prim;\n\n    var maxScore = 0, maxTp = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i], score = 0;\n      if (arrays) {\n        score = tp.getProp(\"<i>\").isEmpty() ? 1 : 2;\n      } else if (fns) {\n        score = 1;\n        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;\n        if (!tp.retval.isEmpty()) ++score;\n      } else if (objs) {\n        score = tp.name ? 100 : 2;\n      }\n      if (score >= maxScore) { maxScore = score; maxTp = tp; }\n    }\n    return maxTp;\n  }\n\n  // PROPAGATION STRATEGIES\n\n  var constraint = exports.constraint = function(methods) {\n    var ctor = function() {\n      this.origin = cx.curOrigin;\n      this.construct.apply(this, arguments);\n    };\n    ctor.prototype = Object.create(ANull);\n    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];\n    return ctor;\n  };\n\n  var GetProp = constraint({\n    construct: function(prop, target) {\n      this.prop = prop; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type.getProp)\n        type.getProp(this.prop).propagate(this.target, weight);\n    },\n    propHint: function() { return this.prop; },\n    propagatesTo: function() {\n      if (this.prop == \"<i>\" || !/[^\\w_]/.test(this.prop))\n        return {target: this.target, pathExt: \".\" + this.prop};\n    }\n  });\n\n  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({\n    construct: function(prop, type, originNode) {\n      this.prop = prop; this.type = type; this.originNode = originNode;\n    },\n    addType: function(type, weight) {\n      if (!(type instanceof Obj)) return;\n      var prop = type.defProp(this.prop, this.originNode);\n      if (!prop.origin) prop.origin = this.origin;\n      this.type.propagate(prop, weight);\n    },\n    propHint: function() { return this.prop; }\n  });\n\n  var ForAllProps = constraint({\n    construct: function(c) { this.c = c; },\n    addType: function(type) {\n      if (!(type instanceof Obj)) return;\n      type.forAllProps(this.c);\n    }\n  });\n\n  function withDisabledComputing(fn, body) {\n    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};\n    var result = body();\n    cx.disabledComputing = cx.disabledComputing.prev;\n    return result;\n  }\n  var IsCallee = exports.IsCallee = constraint({\n    construct: function(self, args, argNodes, retval) {\n      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(fn, weight) {\n      if (!(fn instanceof Fn)) return;\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);\n        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);\n      }\n      if (!fn.isArrowFn())\n        this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);\n      var compute = fn.computeRet, result = fn.retval;\n      if (compute) for (var d = this.disabled; d; d = d.prev)\n        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;\n      if (compute) {\n        var old = cx.disabledComputing;\n        cx.disabledComputing = this.disabled;\n        result = compute(this.self, this.args, this.argNodes);\n        cx.disabledComputing = old;\n      }\n      if (fn.async && !fn.generator) {\n        var tp = result.getType();\n        if (!(tp && tp.constructor == Obj && tp.name == \"Promise\")) {\n          var defs = cx.definitions.ecmascript;\n          var rtnval = defs && new Obj(defs[\"Promise.prototype\"]);\n          if (rtnval) {\n            rtnval.getType().propagate(new DefProp(':t', result));\n            result = rtnval;            \n          }\n        }\n      }\n      maybeIterator(fn, result).propagate(this.retval, weight);\n    },\n    typeHint: function() {\n      var names = [];\n      for (var i = 0; i < this.args.length; ++i) names.push(\"?\");\n      return new Fn(null, this.self, this.args, names, ANull);\n    },\n    propagatesTo: function() {\n      return {target: this.retval, pathExt: \".!ret\"};\n    }\n  });\n\n  var HasMethodCall = constraint({\n    construct: function(propName, args, argNodes, retval) {\n      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(obj, weight) {\n      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);\n      callee.disabled = this.disabled;\n      obj.getProp(this.propName).propagate(callee, weight);\n    },\n    propHint: function() { return this.propName; }\n  });\n\n  var IsCtor = exports.IsCtor = constraint({\n    construct: function(target, noReuse) {\n      this.target = target; this.noReuse = noReuse;\n    },\n    addType: function(f, weight) {\n      if (!(f instanceof Fn)) return;\n      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;\n      f.getProp(\"prototype\").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);\n    }\n  });\n\n  var getInstance = exports.getInstance = function(obj, ctor) {\n    if (ctor === false) return new Obj(obj);\n\n    if (!ctor) ctor = obj.hasCtor;\n    if (!obj.instances) obj.instances = [];\n    for (var i = 0; i < obj.instances.length; ++i) {\n      var cur = obj.instances[i];\n      if (cur.ctor == ctor) return cur.instance;\n    }\n    var instance = new Obj(obj, ctor && ctor.name);\n    instance.origin = obj.origin;\n    obj.instances.push({ctor: ctor, instance: instance});\n    return instance;\n  };\n\n  var IsProto = exports.IsProto = constraint({\n    construct: function(ctor, target) {\n      this.ctor = ctor; this.target = target;\n    },\n    addType: function(o, _weight) {\n      if (!(o instanceof Obj)) return;\n      if ((this.count = (this.count || 0) + 1) > 8) return;\n      if (o == cx.protos.Array)\n        this.target.addType(new Arr);\n      else\n        this.target.addType(getInstance(o, this.ctor));\n    }\n  });\n\n  var FnPrototype = constraint({\n    construct: function(fn) { this.fn = fn; },\n    addType: function(o, _weight) {\n      if (o instanceof Obj && !o.hasCtor) {\n        o.hasCtor = this.fn;\n        var adder = new SpeculativeThis(o, this.fn);\n        adder.addType(this.fn);\n        o.forAllProps(function(_prop, val, local) {\n          if (local) val.propagate(adder);\n        });\n      }\n    }\n  });\n\n  var IsAdded = constraint({\n    construct: function(other, target) {\n      this.other = other; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type == cx.str)\n        this.target.addType(cx.str, weight);\n      else if (type == cx.num && this.other.hasType(cx.num))\n        this.target.addType(cx.num, weight);\n    },\n    typeHint: function() { return this.other; }\n  });\n\n  var IfObj = exports.IfObj = constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(t, weight) {\n      if (t instanceof Obj) this.target.addType(t, weight);\n    },\n    propagatesTo: function() { return this.target; }\n  });\n\n  var SpeculativeThis = constraint({\n    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },\n    addType: function(tp) {\n      if (tp instanceof Fn && tp.self)\n        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);\n    }\n  });\n\n  var HasProto = constraint({\n    construct: function(obj) { this.obj = obj },\n    addType: function(tp) {\n      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)\n        this.obj.replaceProto(tp);\n    }\n  });\n\n  var Muffle = constraint({\n    construct: function(inner, weight) {\n      this.inner = inner; this.weight = weight;\n    },\n    addType: function(tp, weight) {\n      this.inner.addType(tp, Math.min(weight, this.weight));\n    },\n    propagatesTo: function() { return this.inner.propagatesTo(); },\n    typeHint: function() { return this.inner.typeHint(); },\n    propHint: function() { return this.inner.propHint(); }\n  });\n\n  // TYPE OBJECTS\n\n  var Type = exports.Type = function() {};\n  Type.prototype = extend(ANull, {\n    constructor: Type,\n    propagate: function(c, w) { c.addType(this, w); },\n    hasType: function(other) { return other == this; },\n    isEmpty: function() { return false; },\n    typeHint: function() { return this; },\n    getType: function() { return this; }\n  });\n\n  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };\n  Prim.prototype = extend(Type.prototype, {\n    constructor: Prim,\n    toString: function() { return this.name; },\n    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},\n    gatherProperties: function(f, depth) {\n      if (this.proto) this.proto.gatherProperties(f, depth);\n    }\n  });\n\n  function isInteger(str) {\n    var c0 = str.charCodeAt(0);\n    if (c0 >= 48 && c0 <= 57) return !/\\D/.test(str);\n    else return false;\n  }\n\n  var Obj = exports.Obj = function(proto, name) {\n    if (!this.props) this.props = Object.create(null);\n    this.proto = proto === true ? cx.protos.Object : proto;\n    if (proto && proto != cx.protos.Object && !name && proto.name && !(this instanceof Fn)) {\n      var match = /^(.*)\\.prototype$/.exec(this.proto.name);\n      if (match) name = match[1];\n    }\n    this.name = name;\n    this.maybeProps = null;\n    this.origin = cx.curOrigin;\n  };\n  Obj.prototype = extend(Type.prototype, {\n    constructor: Obj,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= 0 && this.name) return this.name;\n      var props = [], etc = false;\n      for (var prop in this.props) if (prop != \"<i>\") {\n        if (props.length > 5) { etc = true; break; }\n        if (maxDepth)\n          props.push(prop + \": \" + toString(this.props[prop], maxDepth - 1, this));\n        else\n          props.push(prop);\n      }\n      props.sort();\n      if (etc) props.push(\"...\");\n      return \"{\" + props.join(\", \") + \"}\";\n    },\n    hasProp: function(prop, searchProto) {\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n      var found = this.props[prop];\n      if (searchProto !== false)\n        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];\n      return found;\n    },\n    defProp: function(prop, originNode) {\n      var found = this.hasProp(prop, false);\n      if (found) {\n        if (originNode && !found.originNode) found.originNode = originNode;\n        return found;\n      }\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n\n      var av = this.maybeProps && this.maybeProps[prop];\n      if (av) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n      } else {\n        av = new AVal;\n        av.propertyOf = this;\n        av.propertyName = prop;\n      }\n\n      this.props[prop] = av;\n      av.originNode = originNode;\n      av.origin = cx.curOrigin;\n      this.broadcastProp(prop, av, true);\n      return av;\n    },\n    getProp: function(prop) {\n      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);\n      if (found) return found;\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n      var av = this.ensureMaybeProps()[prop] = new AVal;\n      av.propertyOf = this;\n      av.propertyName = prop;\n      return av;\n    },\n    normalizeIntegerProp: function(_) { return \"<i>\" },\n    broadcastProp: function(prop, val, local) {\n      if (local) {\n        this.signal(\"addProp\", prop, val);\n        // If this is a scope, it shouldn't be registered\n        if (!(this instanceof Scope)) registerProp(prop, this);\n      }\n\n      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {\n        var h = this.onNewProp[i];\n        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);\n      }\n    },\n    onProtoProp: function(prop, val, _local) {\n      var maybe = this.maybeProps && this.maybeProps[prop];\n      if (maybe) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n        this.proto.getProp(prop).propagate(maybe);\n      }\n      this.broadcastProp(prop, val, false);\n    },\n    replaceProto: function(proto) {\n      for (var o = proto; o; o = o.proto)\n        if (o == this) return;\n      if (this.proto && this.maybeProps)\n        this.proto.unregPropHandler(this);\n      this.proto = proto;\n      if (this.maybeProps)\n        this.proto.forAllProps(this);\n    },\n    ensureMaybeProps: function() {\n      if (!this.maybeProps) {\n        if (this.proto) this.proto.forAllProps(this);\n        this.maybeProps = Object.create(null);\n      }\n      return this.maybeProps;\n    },\n    removeProp: function(prop) {\n      var av = this.props[prop];\n      delete this.props[prop];\n      this.ensureMaybeProps()[prop] = av;\n      av.types.length = 0;\n    },\n    forAllProps: function(c) {\n      if (!this.onNewProp) {\n        this.onNewProp = [];\n        if (this.proto) this.proto.forAllProps(this);\n      }\n      this.onNewProp.push(c);\n      for (var o = this; o; o = o.proto) for (var prop in o.props) {\n        if (c.onProtoProp)\n          c.onProtoProp(prop, o.props[prop], o == this);\n        else\n          c(prop, o.props[prop], o == this);\n      }\n    },\n    maybeUnregProtoPropHandler: function() {\n      if (this.maybeProps) {\n        for (var _n in this.maybeProps) return;\n        this.maybeProps = null;\n      }\n      if (!this.proto || this.onNewProp && this.onNewProp.length) return;\n      this.proto.unregPropHandler(this);\n    },\n    unregPropHandler: function(handler) {\n      for (var i = 0; i < this.onNewProp.length; ++i)\n        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }\n      this.maybeUnregProtoPropHandler();\n    },\n    gatherProperties: function(f, depth) {\n      for (var prop in this.props) if (prop != \"<i>\" && prop.charAt(0) != \":\")\n        f(prop, this, depth);\n      if (this.proto) this.proto.gatherProperties(f, depth + 1);\n    },\n    getObjType: function() { return this; }\n  });\n\n  var geckoIterators = typeof StopIteration != \"undefined\";\n  function ignoredProp(name) {\n    return name == \"__proto__\" || name == \"\" || geckoIterators && name == \"__iterator__\";\n  }\n\n  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator, async) {\n    Obj.call(this, cx.protos.Function, name);\n    this.self = self;\n    this.args = args;\n    this.argNames = argNames;\n    this.retval = retval;\n    this.generator = generator;\n    this.async = async;\n  };\n  Fn.prototype = extend(Obj.prototype, {\n    constructor: Fn,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      var str = this.generator ? \"fn*(\" : \"fn(\";\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i) str += \", \";\n        var name = this.argNames[i];\n        if (name && name != \"?\") str += name + \": \";\n        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : \"?\";\n      }\n      str += \")\";\n      if (!this.retval.isEmpty())\n        str += \" -> \" + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : \"?\");\n      return str;\n    },\n    getProp: function(prop) {\n      if (prop == \"prototype\") {\n        var known = this.hasProp(prop, false);\n        if (!known) {\n          known = this.defProp(prop);\n          var proto = new Obj(true, this.name && this.name + \".prototype\");\n          proto.origin = this.origin;\n          known.addType(proto, WG_MADEUP_PROTO);\n        }\n        return known;\n      }\n      return Obj.prototype.getProp.call(this, prop);\n    },\n    defProp: function(prop, originNode) {\n      if (prop == \"prototype\") {\n        var found = this.hasProp(prop, false);\n        if (found) return found;\n        found = Obj.prototype.defProp.call(this, prop, originNode);\n        found.origin = this.origin;\n        found.propagate(new FnPrototype(this));\n        return found;\n      }\n      return Obj.prototype.defProp.call(this, prop, originNode);\n    },\n    getFunctionType: function() { return this; },\n    isArrowFn: function() { return this.originNode && this.originNode.type == \"ArrowFunctionExpression\" }\n  });\n\n  var Arr = exports.Arr = function(contentType) {\n    Obj.call(this, cx.protos.Array);\n    var content = this.defProp(\"<i>\");\n    if (Array.isArray(contentType)) {\n      this.tuple = contentType.length;\n      for (var i = 0; i < contentType.length; i++) {\n        var prop = this.defProp(String(i));\n        contentType[i].propagate(prop);\n        prop.propagate(content);\n      }\n    } else if (contentType) {\n      this.tuple = 0;\n      contentType.propagate(content);\n    }\n  };\n  Arr.prototype = extend(Obj.prototype, {\n    constructor: Arr,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= -3) return \"[?]\";\n      var content = \"\";\n      if (this.tuple) {\n        var similar;\n        for (var i = 0; i in this.props; i++) {\n          var type = toString(this.getProp(String(i)), maxDepth - 1, this);\n          if (similar == null)\n            similar = type;\n          else if (similar != type)\n            similar = false;\n          else\n            similar = type;\n          content += (content ? \", \" : \"\") + type;\n        }\n        if (similar) content = similar;\n      } else {\n        content = toString(this.getProp(\"<i>\"), maxDepth - 1, this);\n      }\n      return \"[\" + content + \"]\";\n    },\n    normalizeIntegerProp: function(prop) {\n      if (+prop < this.tuple) return prop;\n      else return \"<i>\";\n    }\n  });\n\n  var Sym = exports.Sym = function(name, originNode) {\n    Prim.call(this, cx.protos.Symbol, \"Symbol\");\n    this.symName = name;\n    this.originNode = originNode;\n  };\n  Sym.prototype = extend(Prim.prototype, {\n    constructor: Sym,\n    asPropName: function() { return \":\" + this.symName },\n    getSymbolType: function() { return this }\n  });\n\n  exports.getSymbol = function(name, originNode) {\n    var cleanName = name.replace(/[^\\w$\\.]/g, \"_\");\n    var known = cx.symbols[cleanName];\n    if (known) {\n      if (originNode && !known.originNode) known.originNode = originNode;\n      return known;\n    }\n    return cx.symbols[cleanName] = new Sym(cleanName, originNode);\n  };\n\n  // THE PROPERTY REGISTRY\n\n  function registerProp(prop, obj) {\n    var data = cx.props[prop] || (cx.props[prop] = []);\n    data.push(obj);\n  }\n\n  function objsWithProp(prop) {\n    return cx.props[prop];\n  }\n\n  // INFERENCE CONTEXT\n\n  exports.Context = function(defs, parent) {\n    this.parent = parent;\n    this.props = Object.create(null);\n    this.protos = Object.create(null);\n    this.origins = [];\n    this.curOrigin = \"ecmascript\";\n    this.paths = Object.create(null);\n    this.definitions = Object.create(null);\n    this.purgeGen = 0;\n    this.workList = null;\n    this.disabledComputing = null;\n    this.curSuperCtor = this.curSuper = null;\n    this.symbols = Object.create(null);\n\n    exports.withContext(this, function() {\n      cx.protos.Object = new Obj(null, \"Object.prototype\");\n      cx.topScope = new Scope();\n      cx.topScope.name = \"<top>\";\n      cx.protos.Array = new Obj(true, \"Array.prototype\");\n      cx.protos.Function = new Fn(\"Function.prototype\", ANull, [], [], ANull);\n      cx.protos.Function.proto = cx.protos.Object;\n      cx.protos.RegExp = new Obj(true, \"RegExp.prototype\");\n      cx.protos.String = new Obj(true, \"String.prototype\");\n      cx.protos.Number = new Obj(true, \"Number.prototype\");\n      cx.protos.Boolean = new Obj(true, \"Boolean.prototype\");\n      cx.protos.Symbol = new Obj(true, \"Symbol.prototype\");\n      cx.str = new Prim(cx.protos.String, \"string\");\n      cx.bool = new Prim(cx.protos.Boolean, \"bool\");\n      cx.num = new Prim(cx.protos.Number, \"number\");\n      cx.curOrigin = null;\n\n      if (defs) for (var i = 0; i < defs.length; ++i)\n        def.load(defs[i]);\n    });\n  };\n\n  exports.Context.prototype.startAnalysis = function() {\n    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;\n  };\n\n  var cx = null;\n  exports.cx = function() { return cx; };\n\n  exports.withContext = function(context, f) {\n    var old = cx;\n    cx = context;\n    try { return f(); }\n    finally { cx = old; }\n  };\n\n  exports.TimedOut = function() {\n    this.message = \"Timed out\";\n    this.stack = (new Error()).stack;\n  };\n  exports.TimedOut.prototype = Object.create(Error.prototype);\n  exports.TimedOut.prototype.name = \"infer.TimedOut\";\n\n  var timeout;\n  exports.withTimeout = function(ms, f) {\n    var end = +new Date + ms;\n    var oldEnd = timeout;\n    if (oldEnd && oldEnd < end) return f();\n    timeout = end;\n    try { return f(); }\n    finally { timeout = oldEnd; }\n  };\n\n  exports.addOrigin = function(origin) {\n    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);\n  };\n\n  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;\n  function withWorklist(f) {\n    if (cx.workList) return f(cx.workList);\n\n    var list = [], depth = 0;\n    var add = cx.workList = function(type, target, weight) {\n      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)\n        list.push(type, target, weight, depth);\n    };\n    var ret = f(add);\n    for (var i = 0; i < list.length; i += 4) {\n      if (timeout && +new Date >= timeout)\n        throw new exports.TimedOut();\n      depth = list[i + 3] + 1;\n      list[i + 1].addType(list[i], list[i + 2]);\n    }\n    cx.workList = null;\n    return ret;\n  }\n\n  function withSuper(ctor, obj, f) {\n    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper;\n    cx.curSuperCtor = ctor; cx.curSuper = obj;\n    var result = f();\n    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj;\n    return result;\n  }\n\n  // SCOPES\n\n  var Scope = exports.Scope = function(prev, originNode, isBlock, isCatch) {\n    Obj.call(this, prev || true);\n    this.prev = prev;\n    this.originNode = originNode;\n    this.isBlock = !!isBlock;\n    this.isCatch = !!isCatch;\n  };\n  Scope.prototype = extend(Obj.prototype, {\n    constructor: Scope,\n    defVar: function(name, originNode) {\n      for (var s = this; ; s = s.proto) {\n        var found = s.props[name];\n        if (found) return found;\n        if (!s.prev) return s.defProp(name, originNode);\n      }\n    }\n  });\n\n  function functionScope(scope, arrow) {\n    while (scope.isBlock || scope.isCatch || (arrow === false && scope.fnType && scope.fnType.isArrowFn()))\n      scope = scope.prev;\n    return scope;\n  }\n\n\n  // RETVAL COMPUTATION HEURISTICS\n\n  function maybeInstantiate(scope, score) {\n    var fn = functionScope(scope).fnType;\n    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;\n  }\n\n  var NotSmaller = {};\n  function nodeSmallerThan(node, n) {\n    try {\n      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});\n      return true;\n    } catch(e) {\n      if (e == NotSmaller) return false;\n      throw e;\n    }\n  }\n\n  function maybeTagAsInstantiated(node, fn) {\n    var score = fn.instantiateScore;\n    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {\n      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);\n      setFunctionInstantiated(node, fn);\n      return true;\n    } else {\n      fn.instantiateScore = null;\n    }\n  }\n\n  function setFunctionInstantiated(node, fn) {\n    // Disconnect the arg avals, so that we can add info to them without side effects\n    var refScope = node.scope;\n    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;\n    fn.self = new AVal;\n    fn.computeRet = function(self, args) {\n      // Prevent recursion\n      return withDisabledComputing(fn, function() {\n        var oldOrigin = cx.curOrigin;\n        cx.curOrigin = fn.origin;\n        var scope = node.scope ? node.scope : refScope;\n        var scopeCopy = new Scope(scope.prev, scope.originNode);\n        for (var v in scope.props) {\n          var local = scopeCopy.defProp(v, scope.props[v].originNode);\n          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)\n            args[i].propagate(local);\n        }\n        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;\n        while (argNames.length < args.length) argNames.push(\"?\");\n        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator, fn.async);\n        scopeCopy.fnType.originNode = fn.originNode;\n        if (fn.arguments) {\n          var argset = scopeCopy.fnType.arguments = new AVal;\n          scopeCopy.defProp(\"arguments\").addType(new Arr(argset));\n          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);\n        }\n        node.scope = scopeCopy;\n        walk.recursive(node.body, scopeCopy, null, scopeGatherer);\n        walk.recursive(node.body, scopeCopy, null, inferWrapper);\n        cx.curOrigin = oldOrigin;\n        return scopeCopy.fnType.retval;\n      });\n    };\n  }\n\n  function maybeTagAsGeneric(fn) {\n    var target = fn.retval;\n    if (target == ANull || fn.isArrowFn()) return;\n    var targetInner, asArray;\n    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)\n      target = asArray = targetInner.getProp(\"<i>\");\n\n    function explore(aval, path, depth) {\n      if (depth > 3 || !aval.forward) return;\n      for (var i = 0; i < aval.forward.length; ++i) {\n        var prop = aval.forward[i].propagatesTo();\n        if (!prop) continue;\n        var newPath = path, dest;\n        if (prop instanceof AVal) {\n          dest = prop;\n        } else if (prop.target instanceof AVal) {\n          newPath += prop.pathExt;\n          dest = prop.target;\n        } else continue;\n        if (dest == target) return newPath;\n        var found = explore(dest, newPath, depth + 1);\n        if (found) return found;\n      }\n    }\n\n    var foundPath = explore(fn.self, \"!this\", 0);\n    for (var i = 0; !foundPath && i < fn.args.length; ++i)\n      foundPath = explore(fn.args[i], \"!\" + i, 0);\n\n    if (foundPath) {\n      if (asArray) foundPath = \"[\" + foundPath + \"]\";\n      var p = new def.TypeParser(foundPath);\n      var parsed = p.parseType(true);\n      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };\n      fn.computeRetSource = foundPath;\n      return true;\n    }\n  }\n\n  // SCOPE GATHERING PASS\n\n  function addVar(scope, nameNode) {\n    return scope.defProp(nameNode.name, nameNode);\n  }\n  function patternName(node) {\n    if (node.type == \"Identifier\") return node.name;\n    if (node.type == \"AssignmentPattern\") return patternName(node.left);\n    if (node.type == \"ObjectPattern\") return \"{\" + node.properties.map(function(e) { return patternName(e.type === 'RestElement' ? e : e.value) }).join(\", \") + \"}\";\n    if (node.type == \"ArrayPattern\") return \"[\" + node.elements.map(function(e) { return e ? patternName(e) : \"\" }).join(\", \") + \"]\";\n    if (node.type == \"RestElement\") return \"...\" + patternName(node.argument);\n    return \"_\";\n  }\n\n  function isBlockScopedDecl(node) {\n    return node.type == \"VariableDeclaration\" && node.kind != \"var\" ||\n      node.type == \"FunctionDeclaration\" ||\n      node.type == \"ClassDeclaration\";\n  }\n\n  function patternScopes(inner, outer) {\n    return {inner: inner, outer: outer || inner};\n  }\n\n  var scopeGatherer = exports.scopeGatherer = walk.make({\n    VariablePattern: function(node, scopes) {\n      if (scopes.inner) addVar(scopes.inner, node);\n    },\n    AssignmentPattern: function(node, scopes, c) {\n      c(node.left, scopes, \"Pattern\");\n      c(node.right, scopes.outer, \"Expression\");\n    },\n    AssignmentExpression: function(node, scope, c) {\n      if (node.left.type == \"MemberExpression\")\n        c(node.left, scope, \"Expression\");\n      else\n        c(node.left, patternScopes(false, scope), \"Pattern\");\n      c(node.right, scope, \"Expression\");\n    },\n    MemberPattern: function(node, scope, c) {\n      c(node, scope.outer);\n    },\n    Function: function(node, scope, c) {\n      var inner = node.scope = new Scope(scope, node);\n      var argVals = [], argNames = [];\n      for (var i = 0; i < node.params.length; ++i) {\n        var param = node.params[i];\n        argNames.push(patternName(param));\n        if (param.type == \"Identifier\") {\n          argVals.push(addVar(inner, param));\n        } else {\n          var arg = new AVal;\n          argVals.push(arg);\n          arg.originNode = param;\n          c(param, patternScopes(inner), \"Pattern\");\n        }\n      }\n      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator, node.async);\n      inner.fnType.originNode = node;\n      if (node.id) {\n        var decl = node.type == \"FunctionDeclaration\";\n        addVar(decl ? scope : inner, node.id);\n      }\n      c(node.body, inner, node.expression ? \"Expression\" : \"Statement\");\n    },\n    BlockStatement: function(node, scope, c) {\n      if (!node.scope && node.body.some(isBlockScopedDecl))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.BlockStatement(node, scope, c);\n    },\n    CatchClause: function(node, scope, c) {\n      if (!node.param) { return; }\n      scope = node.scope = new Scope(scope, node, false, true);\n      if (node.param.type == \"Identifier\") {\n        var v = addVar(scope, node.param);\n        c(node.body, scope, \"Statement\");\n        var ecma = cx.definitions.ecmascript;\n        if (ecma && v.isEmpty()) getInstance(ecma[\"Error.prototype\"]).propagate(v, WG_CATCH_ERROR);\n      } else {\n        c(node.param, patternScopes(scope), \"Pattern\");\n      }\n    },\n    VariableDeclaration: function(node, scope, c) {\n      var targetScope = node.kind == \"var\" ? functionScope(scope) : scope;\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        c(decl.id, patternScopes(targetScope, scope), \"Pattern\");\n        if (decl.init) c(decl.init, scope, \"Expression\");\n      }\n    },\n    ClassDeclaration: function(node, scope, c) {\n      if (node.id) addVar(scope, node.id);\n      if (node.superClass) c(node.superClass, scope, \"Expression\");\n      for (var i = 0; i < node.body.body.length; i++)\n        c(node.body.body[i], scope);\n    },\n    ForInStatement: function(node, scope, c) {\n      if (!node.scope && isBlockScopedDecl(node.left))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.ForInStatement(node, scope, c);\n    },\n    ForStatement: function(node, scope, c) {\n      if (!node.scope && node.init && isBlockScopedDecl(node.init))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.ForStatement(node, scope, c);\n    },\n    ImportDeclaration: function(node, scope) {\n      for (var i = 0; i < node.specifiers.length; i++)\n        addVar(scope, node.specifiers[i].local);\n    }\n  });\n  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement;\n\n  function rmScope(node) { if (node.scope) node.scope = null }\n  var scopeClearer = {BlockStatement: rmScope, Function: rmScope, CatchClause: rmScope,\n                      ForInStateMent: rmScope, ForStatement: rmScope};\n  exports.clearScopes = function(ast) {\n    walk.simple(ast, scopeClearer);\n  };\n\n  // CONSTRAINT GATHERING PASS\n\n  var propName = exports.propName = function(node, inferInScope) {\n    var key = node.property || node.key;\n    if (!node.computed && key.type == \"Identifier\") return key.name;\n    if (key.type == \"Literal\") {\n      if (typeof key.value == \"string\") return key.value;\n      if (typeof key.value == \"number\") return String(key.value);\n    }\n    if (inferInScope) {\n      var symName = symbolName(infer(key, inferInScope));\n      if (symName) return node.propName = symName;\n    } else if (node.propName) {\n      return node.propName;\n    }\n    return \"<i>\";\n  };\n  function symbolName(val) {\n    var sym = val.getSymbolType();\n    if (sym) return sym.asPropName();\n  }\n\n  function unopResultType(op) {\n    switch (op) {\n    case \"+\": case \"-\": case \"~\": return cx.num;\n    case \"!\": return cx.bool;\n    case \"typeof\": return cx.str;\n    case \"void\": case \"delete\": return ANull;\n    }\n  }\n  function binopIsBoolean(op) {\n    switch (op) {\n    case \"==\": case \"!=\": case \"===\": case \"!==\": case \"<\": case \">\": case \">=\": case \"<=\":\n    case \"in\": case \"instanceof\": return true;\n    }\n  }\n  function literalType(node) {\n    if (node.regex) return getInstance(cx.protos.RegExp);\n    switch (typeof node.value) {\n    case \"boolean\": return cx.bool;\n    case \"number\": return cx.num;\n    case \"string\": return cx.str;\n    case \"object\":\n    case \"function\":\n      if (!node.value) return ANull;\n      return getInstance(cx.protos.RegExp);\n    }\n  }\n\n  function join(a, b) {\n    if (a == b || b == ANull) return a;\n    if (a == ANull) return b;\n    var joined = new AVal;\n    a.propagate(joined);\n    b.propagate(joined);\n    return joined;\n  }\n\n  function connectParams(node, scope) {\n    for (var i = 0; i < node.params.length; i++) {\n      var param = node.params[i];\n      if (param.type == \"Identifier\") continue;\n      connectPattern(param, scope, node.scope.fnType.args[i]);\n    }\n  }\n\n  function ensureVar(node, scope) {\n    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node);\n  }\n\n  var inferPatternVisitor = exports.inferPatternVisitor = {\n    Identifier: function(node, scope, source) {\n      source.propagate(ensureVar(node, scope));\n    },\n    MemberExpression: function(node, scope, source) {\n      var obj = infer(node.object, scope);\n      var pName = propName(node, scope);\n      obj.propagate(new DefProp(pName, source, node.property));\n    },\n    RestElement: function(node, scope, source) {\n      connectPattern(node.argument, scope, new Arr(source));\n    },\n    ObjectPattern: function(node, scope, source) {\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.type == 'RestElement') { continue; }\n        connectPattern(prop.value, scope, source.getProp(propName(prop)));\n      }\n    },\n    ArrayPattern: function(node, scope, source) {\n      for (var i = 0; i < node.elements.length; i++)\n        if (node.elements[i])\n          connectPattern(node.elements[i], scope, source.getProp(String(i)));\n    },\n    AssignmentPattern: function(node, scope, source) {\n      connectPattern(node.left, scope, join(source, infer(node.right, scope)));\n    }\n  };\n\n  function connectPattern(node, scope, source) {\n    var connecter = inferPatternVisitor[node.type];\n    if (connecter) connecter(node, scope, source);\n  }\n\n  function getThis(scope) {\n    var fnScope = functionScope(scope);\n    return fnScope.fnType ? fnScope.fnType.self : fnScope;\n  }\n\n  function maybeAddPhantomObj(obj) {\n    if (!obj.isEmpty() || !obj.propertyOf) return;\n    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ);\n    maybeAddPhantomObj(obj.propertyOf);\n  }\n\n  function inferClass(node, scope, name) {\n    if (!name && node.id) name = node.id.name;\n\n    var sup = cx.protos.Object, supCtor, delayed;\n    if (node.superClass) {\n      if (node.superClass.type == \"Literal\" && node.superClass.value == null) {\n        sup = null;\n      } else {\n        var supVal = infer(node.superClass, scope), supProto;\n        supCtor = supVal.getFunctionType();\n        if (supCtor && (supProto = supCtor.getProp(\"prototype\").getObjType())) {\n          sup = supProto;\n        } else {\n          supCtor = supVal;\n          delayed = supVal.getProp(\"prototype\");\n        }\n      }\n    }\n    var proto = new Obj(sup, name && name + \".prototype\");\n    if (delayed) delayed.propagate(new HasProto(proto));\n\n    return withSuper(supCtor, delayed || sup, function() {\n      var ctor, body = node.body.body;\n      for (var i = 0; i < body.length; i++)\n        if (body[i].kind == \"constructor\") ctor = body[i].value;\n      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull);\n      fn.originNode = node.id || ctor || node;\n\n      var inst = getInstance(proto, fn);\n      fn.self.addType(inst);\n      fn.defProp(\"prototype\", node).addType(proto);\n      for (var i = 0; i < body.length; i++) {\n        var method = body[i], target;\n        if (method.kind == \"constructor\") continue;\n        var pName = propName(method, scope);\n        if (pName == \"<i>\" || method.kind == \"set\") {\n          target = ANull;\n        } else {\n          target = (method.static ? fn : proto).defProp(pName, method.key);\n          target.initializer = true;\n          if (method.kind == \"get\") target = new IsCallee(inst, [], null, target);\n        }\n        infer(method.value, scope, target);\n        var methodFn = target.getFunctionType();\n        if (methodFn) methodFn.self.addType(inst);\n      }\n      return fn;\n    });\n  }\n\n  function arrayLiteralType(elements, scope, inner) {\n    var tuple = elements.length > 1 && elements.length < 6;\n    if (tuple) {\n      var homogenous = true, litType;\n      for (var i = 0; i < elements.length; i++) {\n        var elt = elements[i];\n        if (!elt)\n          tuple = false;\n        else if (elt.type != \"Literal\" || (litType && litType != typeof elt.value))\n          homogenous = false;\n        else\n          litType = typeof elt.value;\n      }\n      if (homogenous) tuple = false;\n    }\n\n    if (tuple) {\n      var types = [];\n      for (var i = 0; i < elements.length; ++i)\n        types.push(inner(elements[i], scope));\n      return new Arr(types);\n    } else if (elements.length < 2) {\n      return new Arr(elements[0] && inner(elements[0], scope));\n    } else {\n      var eltVal = new AVal;\n      for (var i = 0; i < elements.length; i++)\n        if (elements[i]) inner(elements[i], scope).propagate(eltVal);\n      return new Arr(eltVal);\n    }\n  }\n\n  function ret(f) {\n    return function(node, scope, out, name) {\n      var r = f(node, scope, name);\n      if (out) r.propagate(out);\n      return r;\n    };\n  }\n  function fill(f) {\n    return function(node, scope, out, name) {\n      if (!out) out = new AVal;\n      f(node, scope, out, name);\n      return out;\n    };\n  }\n\n  var inferExprVisitor = exports.inferExprVisitor = {\n    ArrayExpression: ret(function(node, scope) {\n      return arrayLiteralType(node.elements, scope, infer);\n    }),\n    ObjectExpression: ret(function(node, scope, name) {\n      var proto = cx.protos.Object, waitForProto;\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.type == 'SpreadElement') { continue; }\n        if (prop.key.name == \"__proto__\") {\n          if (prop.value.type == \"Literal\" && prop.value.value == null) {\n            proto = null;\n          } else {\n            var protoVal = infer(prop.value, scope), known = protoVal.getObjType();\n            if (known) proto = known;\n            else waitForProto = protoVal;\n          }\n        }\n      }\n\n      var obj = node.objType = new Obj(proto, name);\n      if (waitForProto) waitForProto.propagate(new HasProto(obj));\n      obj.originNode = node;\n\n      withSuper(null, waitForProto || proto, function() {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var prop = node.properties[i], key = prop.key;\n          if (prop.type == 'SpreadElement' || ignoredProp(prop.key.name)) continue;\n\n          var name = propName(prop, scope), target;\n          if (name == \"<i>\" || prop.kind == \"set\") {\n            target = ANull;\n          } else {\n            target = obj.defProp(name, key);\n            var val = target;\n            val.initializer = true;\n            if (prop.kind == \"get\")\n              target = new IsCallee(obj, [], null, val);\n          }\n          infer(prop.value, scope, target, name);\n          if (prop.value.type == \"FunctionExpression\")\n            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);\n        }\n      });\n      return obj;\n    }),\n    FunctionExpression: ret(function(node, scope, name) {\n      var inner = node.scope, fn = inner.fnType;\n      if (name && !fn.name) fn.name = name;\n      connectParams(node, inner);\n      if (node.expression)\n        infer(node.body, inner, inner.fnType.retval = new AVal);\n      else\n        walk.recursive(node.body, inner, null, inferWrapper, \"Statement\");\n      if (node.type == \"ArrowFunctionExpression\")\n        getThis(scope).propagate(fn.self);\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) inner.getProp(node.id.name).addType(fn);\n      return fn;\n    }),\n    ClassExpression: ret(inferClass),\n    SequenceExpression: ret(function(node, scope) {\n      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return infer(node.expressions[l], scope);\n    }),\n    UnaryExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return unopResultType(node.operator);\n    }),\n    UpdateExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return cx.num;\n    }),\n    BinaryExpression: ret(function(node, scope) {\n      if (node.operator == \"+\") {\n        var lhs = infer(node.left, scope);\n        var rhs = infer(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;\n        var result = new AVal;\n        lhs.propagate(new IsAdded(rhs, result));\n        rhs.propagate(new IsAdded(lhs, result));\n        return result;\n      } else {\n        infer(node.left, scope, ANull);\n        infer(node.right, scope, ANull);\n        return binopIsBoolean(node.operator) ? cx.bool : cx.num;\n      }\n    }),\n    AssignmentExpression: ret(function(node, scope, name) {\n      var rhs, pName;\n      if (node.left.type == \"MemberExpression\") {\n        pName = propName(node.left, scope);\n        if (!name)\n          name = node.left.object.type == \"Identifier\" ? node.left.object.name + \".\" + pName : pName;\n      } else if (!name && node.left.type == \"Identifier\") {\n        name = node.left.name;\n      }\n\n      if (node.operator && node.operator != \"=\" && node.operator != \"+=\") {\n        infer(node.right, scope, ANull);\n        rhs = cx.num;\n      } else {\n        rhs = infer(node.right, scope, null, name);\n      }\n\n      if (node.left.type == \"MemberExpression\") {\n        var obj = infer(node.left.object, scope);\n        if (pName == \"prototype\") maybeInstantiate(scope, 20);\n        if (pName == \"<i>\") {\n          // This is a hack to recognize for/in loops that copy\n          // properties, and do the copying ourselves, insofar as we\n          // manage, because such loops tend to be relevant for type\n          // information.\n          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;\n          if (over) {\n            maybeInstantiate(scope, 20);\n            var fromRight = node.right.type == \"MemberExpression\" && node.right.computed && node.right.property.name == v;\n            over.forAllProps(function(prop, val, local) {\n              if (local && prop != \"prototype\" && prop != \"<i>\")\n                obj.propagate(new DefProp(prop, fromRight ? val : ANull));\n            });\n            return rhs;\n          }\n        }\n\n        obj.propagate(new DefProp(pName, rhs, node.left.property));\n        maybeAddPhantomObj(obj);\n        if (node.right.type == \"FunctionExpression\")\n          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);\n      } else {\n        connectPattern(node.left, scope, rhs);\n      }\n      return rhs;\n    }),\n    LogicalExpression: fill(function(node, scope, out) {\n      infer(node.left, scope, out);\n      infer(node.right, scope, out);\n    }),\n    ConditionalExpression: fill(function(node, scope, out) {\n      infer(node.test, scope, ANull);\n      infer(node.consequent, scope, out);\n      infer(node.alternate, scope, out);\n    }),\n    NewExpression: fill(function(node, scope, out, name) {\n      if (node.callee.type == \"Identifier\" && node.callee.name in scope.props)\n        maybeInstantiate(scope, 20);\n\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var callee = infer(node.callee, scope);\n      var self = new AVal;\n      callee.propagate(new IsCtor(self, name && /\\.prototype$/.test(name)));\n      self.propagate(out, WG_NEW_INSTANCE);\n      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));\n    }),\n    CallExpression: fill(function(node, scope, out) {\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var outerFn = functionScope(scope).fnType;\n      if (node.callee.type == \"MemberExpression\") {\n        var self = infer(node.callee.object, scope);\n        var pName = propName(node.callee, scope);\n        if (outerFn && (pName == \"call\" || pName == \"apply\") &&\n            outerFn.args.indexOf(self) > -1)\n          maybeInstantiate(scope, 30);\n        self.propagate(new HasMethodCall(pName, args, node.arguments, out));\n      } else if (node.callee.type == \"Super\" && cx.curSuperCtor) {\n        node.callee.superType = cx.curSuperCtor;\n        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out));\n        getThis(scope).propagate(out, WG_NEW_INSTANCE);\n      } else {\n        var callee = infer(node.callee, scope);\n        if (outerFn && outerFn.args.indexOf(callee) > -1)\n          maybeInstantiate(scope, 30);\n        var knownFn = callee.getFunctionType();\n        if (knownFn && knownFn.instantiateScore && outerFn)\n          maybeInstantiate(scope, knownFn.instantiateScore / 5);\n        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));\n      }\n    }),\n    AwaitExpression: fill(function(node, scope, out, name) {\n      var arg = infer(node.argument, scope, null, name);\n      var tp = arg.getType();\n      if (tp && tp.constructor == Obj && tp.name == \"Promise\") {\n        if (tp.hasProp(\":t\")) {\n          tp.getProp(\":t\").propagate(out);\n        }\n      } else {\n        arg.propagate(out);\n      }\n    }),\n    MemberExpression: fill(function(node, scope, out) {\n      var name = propName(node), wg;\n      if (name == \"<i>\") {\n        var propType = infer(node.property, scope);\n        var symName = symbolName(propType);\n        if (symName)\n          name = node.propName = symName;\n        else if (!propType.hasType(cx.num))\n          wg = WG_MULTI_MEMBER;\n      }\n      infer(node.object, scope).getProp(name).propagate(out, wg);\n    }),\n    Identifier: ret(function(node, scope) {\n      if (node.name == \"arguments\") {\n        var fnScope = functionScope(scope, false);\n        if (fnScope.fnType && !(node.name in fnScope.props))\n          fnScope.defProp(node.name, fnScope.fnType.originNode)\n            .addType(new Arr(fnScope.fnType.arguments = new AVal));\n      }\n      return scope.getProp(node.name);\n    }),\n    ThisExpression: ret(function(_node, scope) {\n      return getThis(scope);\n    }),\n    Super: ret(function(node) {\n      return node.superType = cx.curSuper || ANull;\n    }),\n    Literal: ret(function(node) {\n      return literalType(node);\n    }),\n    TemplateLiteral: ret(function(node, scope) {\n      for (var i = 0; i < node.expressions.length; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return cx.str;\n    }),\n    TaggedTemplateExpression: fill(function(node, scope, out) {\n      var args = [new Arr(cx.str)];\n      for (var i = 0; i < node.quasi.expressions.length; ++i)\n        args.push(infer(node.quasi.expressions[i], scope));\n      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out));\n    }),\n    YieldExpression: ret(function(node, scope) {\n      var output = ANull, fn = functionScope(scope).fnType;\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        if (!fn.yieldval) fn.yieldval = new AVal;\n        output = fn.retval;\n      }\n      if (node.argument) {\n        if (node.delegate) {\n          infer(node.argument, scope, new HasMethodCall(\"next\", [], null,\n                                                        new GetProp(\"value\", output)));\n        } else {\n          infer(node.argument, scope, output);\n        }\n      }\n      return fn ? fn.yieldval : ANull;\n    })\n  };\n  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression;\n\n  function infer(node, scope, out, name) {\n    var handler = inferExprVisitor[node.type];\n    return handler ? handler(node, scope, out, name) : ANull;\n  }\n\n  function loopPattern(init) {\n    return init.type == \"VariableDeclaration\" ? init.declarations[0].id : init;\n  }\n\n  var inferWrapper = exports.inferWrapper = walk.make({\n    Expression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    ObjectExpression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    FunctionDeclaration: function(node, scope, c) {\n      var inner = node.scope, fn = inner.fnType;\n      connectParams(node, inner);\n      c(node.body, inner, \"Statement\");\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) scope.getProp(node.id.name).addType(fn);\n    },\n\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope);\n    },\n\n    ExportDefaultDeclaration: function(node, scope, c) {\n      c(node.declaration, node.scope || scope);\n    },\n\n    VariableDeclaration: function(node, scope) {\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        if (decl.id.type == \"Identifier\") {\n          var prop = scope.getProp(decl.id.name);\n          if (decl.init)\n            infer(decl.init, scope, prop, decl.id.name);\n        } else if (decl.init) {\n          connectPattern(decl.id, scope, infer(decl.init, scope));\n        }\n      }\n    },\n\n    ClassDeclaration: function(node, scope) {\n      if (!node.id) inferClass(node, scope);\n      else scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name));\n    },\n\n    ReturnStatement: function(node, scope) {\n      if (!node.argument) return;\n      var output = ANull, fn = functionScope(scope).fnType;\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        output = fn.retval;\n      }\n      infer(node.argument, scope, output);\n    },\n\n    ForInStatement: function(node, scope, c) {\n      var source = infer(node.right, scope);\n      if ((node.right.type == \"Identifier\" && node.right.name in scope.props) ||\n          (node.right.type == \"MemberExpression\" && node.right.property.name == \"prototype\")) {\n        maybeInstantiate(scope, 5);\n        var pattern = loopPattern(node.left);\n        if (pattern.type == \"Identifier\") {\n          if (pattern.name in scope.props)\n            scope.getProp(pattern.name).iteratesOver = source;\n          source.getProp(\"<i>\").propagate(ensureVar(pattern, scope));\n        } else {\n          connectPattern(pattern, scope, source.getProp(\"<i>\"));\n        }\n      }\n      c(node.body, scope, \"Statement\");\n    },\n\n    ForOfStatement: function(node, scope, c) {\n      var pattern = loopPattern(node.left), target;\n      if (pattern.type == \"Identifier\")\n        target = ensureVar(pattern, scope);\n      else\n        connectPattern(pattern, scope, target = new AVal);\n\n      if (node.await) {\n        infer(node.right, scope, new HasMethodCall(\":Symbol.asyncIterator\", [], null,\n                                                   new HasMethodCall(\"next\", [], null,\n                                                                     new GetProp(\":t\",\n                                                                                 new GetProp(\"value\", target)))));\n      } else {\n        infer(node.right, scope, new HasMethodCall(\":Symbol.iterator\", [], null,\n                                                   new HasMethodCall(\"next\", [], null,\n                                                                     new GetProp(\"value\", target))));\n      }\n      c(node.body, scope, \"Statement\");\n    }\n  });\n\n  // PARSING\n\n  var parse = exports.parse = function(text, options, thirdArg) {\n    if (!options || Array.isArray(options)) options = thirdArg;\n    var ast;\n    try { ast = acorn.parse(text, options); }\n    catch(e) { ast = acorn_loose.parse(text, options); }\n    return ast;\n  };\n\n  // ANALYSIS INTERFACE\n\n  exports.analyze = function(ast, name, scope) {\n    if (typeof ast == \"string\") ast = parse(ast);\n\n    if (!name) name = \"file#\" + cx.origins.length;\n    exports.addOrigin(cx.curOrigin = name);\n\n    if (!scope) scope = cx.topScope;\n    cx.startAnalysis();\n\n    walk.recursive(ast, scope, null, scopeGatherer);\n    if (cx.parent) cx.parent.signal(\"preInfer\", ast, scope);\n    walk.recursive(ast, scope, null, inferWrapper);\n    if (cx.parent) cx.parent.signal(\"postInfer\", ast, scope);\n\n    cx.curOrigin = null;\n  };\n\n  // PURGING\n\n  exports.purge = function(origins, start, end) {\n    var test = makePredicate(origins, start, end);\n    ++cx.purgeGen;\n    cx.topScope.purge(test);\n    for (var prop in cx.props) {\n      var list = cx.props[prop];\n      for (var i = 0; i < list.length; ++i) {\n        var obj = list[i], av = obj.props[prop];\n        if (!av || test(av, av.originNode)) list.splice(i--, 1);\n      }\n      if (!list.length) delete cx.props[prop];\n    }\n  };\n\n  function makePredicate(origins, start, end) {\n    var arr = Array.isArray(origins);\n    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }\n    if (arr) {\n      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };\n    } else {\n      if (end == null) return function(n) { return n.origin == origins; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };\n    }\n  }\n\n  AVal.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return;\n    this.purgeGen = cx.purgeGen;\n    for (var i = 0; i < this.types.length; ++i) {\n      var type = this.types[i];\n      if (test(type, type.originNode))\n        this.types.splice(i--, 1);\n      else\n        type.purge(test);\n    }\n    if (!this.types.length) this.maxWeight = 0;\n\n    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n      var f = this.forward[i];\n      if (test(f)) {\n        this.forward.splice(i--, 1);\n        if (this.props) this.props = null;\n      } else if (f.purge) {\n        f.purge(test);\n      }\n    }\n  };\n  ANull.purge = function() {};\n  Obj.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return true;\n    this.purgeGen = cx.purgeGen;\n    for (var p in this.props) {\n      var av = this.props[p];\n      if (test(av, av.originNode))\n        this.removeProp(p);\n      av.purge(test);\n    }\n  };\n  Fn.prototype.purge = function(test) {\n    if (Obj.prototype.purge.call(this, test)) return;\n    this.self.purge(test);\n    this.retval.purge(test);\n    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);\n  };\n\n  // EXPRESSION TYPE DETERMINATION\n\n  function findByPropertyName(name) {\n    guessing = true;\n    var found = objsWithProp(name);\n    if (found) for (var i = 0; i < found.length; ++i) {\n      var val = found[i].getProp(name);\n      if (!val.isEmpty()) return val;\n    }\n    return ANull;\n  }\n\n  function generatorResult(input, output, async) {\n    var defs = cx.definitions.ecmascript;\n    var valObj = new Obj(true);\n    valObj.defProp(\"done\").addType(cx.bool);\n    output.propagate(valObj.defProp(\"value\"));\n    var retObj = valObj;\n    if (async && defs) {\n      retObj = new Obj(defs[\"Promise.prototype\"]);\n      retObj.getType().propagate(new DefProp(':t', valObj));\n    }\n    var method = new Fn(null, ANull, input ? [input] : [], input ? [\"?\"] : [], retObj);\n    var result = new Obj(defs ? async ? defs.async_generator_prototype : defs.generator_prototype : true);\n    result.defProp(\"next\").addType(method);\n    return result;\n  }\n\n  function maybeIterator(fn, output) {\n    if (!fn.generator) return output;\n    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types\n      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output, fn.async);\n      return fn.generator;\n    }\n    return generatorResult(fn.yieldval, output, fn.async);\n  }\n\n  function computeReturnType(funcNode, argNodes, scope) {\n    var fn = findType(funcNode, scope).getFunctionType();\n    if (!fn) return ANull;\n    var result = fn.retval;\n    if (fn.computeRet) {\n      for (var i = 0, args = []; i < argNodes.length; ++i)\n        args.push(findType(argNodes[i], scope));\n      var self = ANull;\n      if (funcNode.type == \"MemberExpression\")\n        self = findType(funcNode.object, scope);\n      result = fn.computeRet(self, args, argNodes);\n    }\n    return maybeIterator(fn, result);\n  }\n\n  var typeFinder = exports.typeFinder = {\n    ArrayExpression: function(node, scope) {\n      return arrayLiteralType(node.elements, scope, findType);\n    },\n    ObjectExpression: function(node) {\n      return node.objType;\n    },\n    ClassDeclaration: function(node) {\n      return node.objType;\n    },\n    ClassExpression: function(node) {\n      return node.objType;\n    },\n    FunctionDeclaration: function(node) {\n      return node.scope.fnType;\n    },\n    FunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    ArrowFunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    SequenceExpression: function(node, scope) {\n      return findType(node.expressions[node.expressions.length-1], scope);\n    },\n    UnaryExpression: function(node) {\n      return unopResultType(node.operator);\n    },\n    UpdateExpression: function() {\n      return cx.num;\n    },\n    BinaryExpression: function(node, scope) {\n      if (binopIsBoolean(node.operator)) return cx.bool;\n      if (node.operator == \"+\") {\n        var lhs = findType(node.left, scope);\n        var rhs = findType(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n      }\n      return cx.num;\n    },\n    AssignmentExpression: function(node, scope) {\n      return findType(node.right, scope);\n    },\n    LogicalExpression: function(node, scope) {\n      var lhs = findType(node.left, scope);\n      return lhs.isEmpty() ? findType(node.right, scope) : lhs;\n    },\n    ConditionalExpression: function(node, scope) {\n      var lhs = findType(node.consequent, scope);\n      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;\n    },\n    NewExpression: function(node, scope) {\n      var f = findType(node.callee, scope).getFunctionType();\n      var proto = f && f.getProp(\"prototype\").getObjType();\n      if (!proto) return ANull;\n      return getInstance(proto, f);\n    },\n    CallExpression: function(node, scope) {\n      return computeReturnType(node.callee, node.arguments, scope);\n    },\n    MemberExpression: function(node, scope) {\n      var propN = propName(node), obj = findType(node.object, scope).getType();\n      if (obj) return obj.getProp(propN);\n      if (propN == \"<i>\") return ANull;\n      return findByPropertyName(propN);\n    },\n    MethodDefinition: function(node) {\n      var propN = propName(node), obj = getThis(node.value.scope).getType();\n      if (obj) return obj.getProp(propN);\n      return ANull;\n    },\n    Identifier: function(node, scope) {\n      return scope.hasProp(node.name) || ANull;\n    },\n    ThisExpression: function(_node, scope) {\n      return getThis(scope);\n    },\n    Literal: function(node) {\n      return literalType(node);\n    },\n    Super: ret(function(node) {\n      return node.superType;\n    }),\n    TemplateLiteral: function() {\n      return cx.str;\n    },\n    TaggedTemplateExpression: function(node, scope) {\n      return computeReturnType(node.tag, node.quasi.expressions, scope);\n    },\n    YieldExpression: function(_node, scope) {\n      var fn = functionScope(scope).fnType;\n      return fn ? fn.yieldval : ANull;\n    }\n  };\n\n  function findType(node, scope) {\n    var finder = typeFinder[node.type];\n    return finder ? finder(node, scope) : ANull;\n  }\n\n  var searchVisitor = exports.searchVisitor = walk.make({\n    Function: function(node, _st, c) {\n      walk.base.Function(node, node.scope, c);\n    },\n    CatchClause: function(node, _st, c) {\n      walk.base.CatchClause(node, node.scope, c);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      if (node.key != node.value) c(node.value, st, \"Expression\");\n    },\n    Statement: function(node, st, c) {\n      c(node, node.scope || st);\n    },\n    ImportSpecifier: function(node, st, c) {\n      c(node.local, st);\n    },\n    ImportDefaultSpecifier: function(node, st, c) {\n      c(node.local, st);\n    },\n    ImportNamespaceSpecifier: function(node, st, c) {\n      c(node.local, st);\n    }\n  });\n  var searchExprVisitor = exports.searchExprVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      if (node.computed) { c(node.property, st, \"Expression\"); }\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n  exports.fullVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      c(node.property, st, node.computed ? \"Expression\" : null);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n\n  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (node.type == \"Identifier\" && node.name == \"\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAt(ast, start, end, test, searchExprVisitor, defaultScope || cx.topScope);\n  };\n  exports.findClosestExpression = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchExprVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.expressionType = function(found) {\n    return findType(found.node, found.state);\n  };\n\n  // Finding the expected type of something, from context\n\n  exports.parentNode = function(child, ast) {\n    var stack = [];\n    function c(node, st, override) {\n      if (node.start <= child.start && node.end >= child.end) {\n        var top = stack[stack.length - 1];\n        if (node == child) throw {found: top};\n        if (top != node) stack.push(node);\n        walk.base[override || node.type](node, st, c);\n        if (top != node) stack.pop();\n      }\n    }\n    try {\n      c(ast, null);\n    } catch (e) {\n      if (e.found) return e.found;\n      throw e;\n    }\n  };\n\n  var findTypeFromContext = exports.findTypeFromContext = {\n    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp(\"<i>\"); },\n    ObjectExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.value == node)\n          return get(parent, true).getProp(propName(prop));\n      }\n    },\n    UnaryExpression: function(parent) { return unopResultType(parent.operator); },\n    UpdateExpression: function() { return cx.num; },\n    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },\n    AssignmentExpression: function(parent, _, get) { return get(parent.left); },\n    LogicalExpression: function(parent, _, get) { return get(parent, true); },\n    ConditionalExpression: function(parent, node, get) {\n      if (parent.consequent == node || parent.alternate == node) return get(parent, true);\n    },\n    CallExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.arguments.length; i++) {\n        var arg = parent.arguments[i];\n        if (arg == node) {\n          var calleeType = get(parent.callee).getFunctionType();\n          if (calleeType instanceof Fn)\n            return calleeType.args[i];\n          break;\n        }\n      }\n    },\n    ReturnStatement: function(_parent, node, get) {\n      // tweaking search position to avoid endless recursion\n      // when looking for definition of key in fn ( return fn ( return object ) )\n      // see ternjs/tern#777\n      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start - 1, \"Function\");\n      if (fnNode) {\n        var fnType = fnNode.node.type != \"FunctionDeclaration\"\n          ? get(fnNode.node, true).getFunctionType()\n          : fnNode.node.scope.fnType;\n        if (fnType) return fnType.retval.getType();\n      }\n    },\n    VariableDeclarator: function(parent, node, get) {\n      if (parent.init == node) return get(parent.id);\n    }\n  };\n  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression;\n\n  exports.typeFromContext = function(ast, found) {\n    var parent = exports.parentNode(found.node, ast);\n    var type = null;\n    if (findTypeFromContext.hasOwnProperty(parent.type)) {\n      var finder = findTypeFromContext[parent.type];\n      type = finder && finder(parent, found.node, function(node, fromContext) {\n        var obj = {node: node, state: found.state};\n        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);\n        return tp || ANull;\n      });\n    }\n    return type || exports.expressionType(found);\n  };\n\n  // Flag used to indicate that some wild guessing was used to produce\n  // a type or set of completions.\n  var guessing = false;\n\n  exports.resetGuessing = function(val) { guessing = val; };\n  exports.didGuess = function() { return guessing; };\n\n  exports.forAllPropertiesOf = function(type, f) {\n    type.gatherProperties(f, 0);\n  };\n\n  exports.findRefs = function(ast, baseScope, name, refScope, f) {\n    function handleId(node, scope, ancestors) {\n      var parent = ancestors[ancestors.length - 2];\n      if (parent.type == \"MemberExpression\" && !parent.computed && !!node.object) return;\n      if (node.name != name ||\n          (node == ast.id && ast.type == \"FunctionDeclaration\")) return;\n      if (parent.property === node) return;\n      for (var s = scope; s; s = s.prev) {\n        if (s == refScope) f(node, scope, ancestors);\n        if (name in s.props) return;\n      }\n    }\n    walk.ancestor(ast, {Identifier: handleId, VariablePattern: handleId},\n                  exports.fullVisitor, baseScope);\n  };\n\n  var simpleWalker = walk.make({\n    Function: function(node, _scope, c) {\n      c(node.body, node.scope, node.expression ? \"Expression\" : \"Statement\");\n    },\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope);\n    }\n  });\n\n  exports.findPropRefs = function(ast, scope, objType, name, f) {\n    // Find the type which owns the property in hierarchy\n    while (objType && !objType.props[name] && !(objType.maybeProps && objType.maybeProps[name])) {\n      objType = objType.proto;\n    }\n    if (!objType) throw new Error(\"Couldn't locate property in the base object type.\");\n\n    function isObjTypeProto(type) {\n      // Check whether the found type has objType in its hierarchy\n      while (type && type != objType) {\n        // Ff property is overriden higher in the hierarchy, return false\n        if (type.props[name] || (type.maybeProps && type.maybeProps[name])) {\n          return false;\n        }\n        type = type.proto;\n      }\n      return type;\n    }\n\n    walk.simple(ast, {\n      MemberExpression: function(node, scope) {\n        if (node.computed || propName(node) != name) return;\n        if (isObjTypeProto(findType(node.object, scope).getType())) f(node.property, scope);\n      },\n      ObjectExpression: function(node, scope) {\n        if (findType(node, scope).getType() != objType) return;\n        for (var i = 0; i < node.properties.length; ++i)\n          if (propName(node.properties[i]) == name) f(node.properties[i].key, scope);\n      },\n      MethodDefinition: function(node) {\n        if (propName(node) != name) return;\n        if (node.value && isObjTypeProto(getThis(node.value.scope).getType())) f(node.key, node.value.scope);\n      }\n    }, simpleWalker, scope);\n  };\n\n  // LOCAL-VARIABLE QUERIES\n\n  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {\n    var found = walk.findNodeAround(ast, pos, function(_, node) {\n      return node.scope;\n    });\n    if (found) return found.node.scope;\n    else return defaultScope || cx.topScope;\n  };\n\n  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {\n    var scope = scopeAt(ast, pos, defaultScope);\n    scope.gatherProperties(f, 0);\n  };\n\n  // INIT DEF MODULE\n\n  // Delayed initialization because of cyclic dependencies.\n  def = exports.def = def.init({}, exports);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9saWIvaW5mZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVybi9saWIvaW5mZXIuanM/YjIxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYWluIHR5cGUgaW5mZXJlbmNlIGVuZ2luZVxuXG4vLyBXYWxrcyBhbiBBU1QsIGJ1aWxkaW5nIHVwIGEgZ3JhcGggb2YgYWJzdHJhY3QgdmFsdWVzIGFuZCBjb25zdHJhaW50c1xuLy8gdGhhdCBjYXVzZSB0eXBlcyB0byBmbG93IGZyb20gb25lIG5vZGUgdG8gYW5vdGhlci4gQWxzbyBkZWZpbmVzIGFcbi8vIG51bWJlciBvZiB1dGlsaXRpZXMgZm9yIGFjY2Vzc2luZyBBU1RzIGFuZCBzY29wZXMuXG5cbi8vIEFuYWx5c2lzIGlzIGRvbmUgaW4gYSBjb250ZXh0LCB3aGljaCBpcyB0cmFja2VkIGJ5IHRoZSBkeW5hbWljYWxseVxuLy8gYm91bmQgY3ggdmFyaWFibGUuIFVzZSB3aXRoQ29udGV4dCB0byBzZXQgdGhlIGN1cnJlbnQgY29udGV4dC5cblxuLy8gRm9yIG1lbW9yeS1zYXZpbmcgcmVhc29ucywgaW5kaXZpZHVhbCB0eXBlcyBleHBvcnQgYW4gaW50ZXJmYWNlXG4vLyBzaW1pbGFyIHRvIGFic3RyYWN0IHZhbHVlcyAod2hpY2ggY2FuIGhvbGQgbXVsdGlwbGUgdHlwZXMpLCBhbmQgY2FuXG4vLyB0aHVzIGJlIHVzZWQgaW4gcGxhY2UgYWJzdHJhY3QgdmFsdWVzIHRoYXQgb25seSBldmVyIGNvbnRhaW4gYVxuLy8gc2luZ2xlIHR5cGUuXG5cbihmdW5jdGlvbihyb290LCBtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIHJldHVybiBtb2QoZXhwb3J0cywgcmVxdWlyZShcImFjb3JuXCIpLCByZXF1aXJlKFwiYWNvcm4tbG9vc2VcIiksIHJlcXVpcmUoXCJhY29ybi13YWxrXCIpLFxuICAgICAgICAgICAgICAgcmVxdWlyZShcIi4vZGVmXCIpLCByZXF1aXJlKFwiLi9zaWduYWxcIikpO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgcmV0dXJuIGRlZmluZShbXCJleHBvcnRzXCIsIFwiYWNvcm4vZGlzdC9hY29yblwiLCBcImFjb3JuLWxvb3NlL2Rpc3QvYWNvcm4tbG9vc2VcIiwgXCJhY29ybi13YWxrL2Rpc3Qvd2Fsa1wiLCBcIi4vZGVmXCIsIFwiLi9zaWduYWxcIl0sIG1vZCk7XG4gIG1vZChyb290LnRlcm4gfHwgKHJvb3QudGVybiA9IHt9KSwgYWNvcm4sIGFjb3JuLmxvb3NlLCBhY29ybi53YWxrLCB0ZXJuLmRlZiwgdGVybi5zaWduYWwpOyAvLyBQbGFpbiBicm93c2VyIGVudlxufSkodGhpcywgZnVuY3Rpb24oZXhwb3J0cywgYWNvcm4sIGFjb3JuX2xvb3NlLCB3YWxrLCBkZWYsIHNpZ25hbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgdG9TdHJpbmcgPSBleHBvcnRzLnRvU3RyaW5nID0gZnVuY3Rpb24odHlwZSwgbWF4RGVwdGgsIHBhcmVudCkge1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09IHBhcmVudCB8fCBtYXhEZXB0aCAmJiBtYXhEZXB0aCA8IC0zKSByZXR1cm4gXCI/XCI7XG4gICAgcmV0dXJuIHR5cGUudG9TdHJpbmcobWF4RGVwdGgsIHBhcmVudCk7XG4gIH07XG5cbiAgLy8gQSB2YXJpYW50IG9mIEFWYWwgdXNlZCBmb3IgdW5rbm93biwgZGVhZC1lbmQgdmFsdWVzLiBBbHNvIHNlcnZlc1xuICAvLyBhcyBwcm90b3R5cGUgZm9yIEFWYWxzLCBUeXBlcywgYW5kIENvbnN0cmFpbnRzIGJlY2F1c2UgaXRcbiAgLy8gaW1wbGVtZW50cyAnZW1wdHknIHZlcnNpb25zIG9mIGFsbCB0aGUgbWV0aG9kcyB0aGF0IHRoZSBjb2RlXG4gIC8vIGV4cGVjdHMuXG4gIHZhciBBTnVsbCA9IGV4cG9ydHMuQU51bGwgPSBzaWduYWwubWl4aW4oe1xuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKCkge30sXG4gICAgcHJvcGFnYXRlOiBmdW5jdGlvbigpIHt9LFxuICAgIGdldFByb3A6IGZ1bmN0aW9uKCkgeyByZXR1cm4gQU51bGw7IH0sXG4gICAgZm9yQWxsUHJvcHM6IGZ1bmN0aW9uKCkge30sXG4gICAgaGFzVHlwZTogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgZ2V0RnVuY3Rpb25UeXBlOiBmdW5jdGlvbigpIHt9LFxuICAgIGdldE9ialR5cGU6IGZ1bmN0aW9uKCkge30sXG4gICAgZ2V0U3ltYm9sVHlwZTogZnVuY3Rpb24oKSB7fSxcbiAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHt9LFxuICAgIGdhdGhlclByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge30sXG4gICAgcHJvcGFnYXRlc1RvOiBmdW5jdGlvbigpIHt9LFxuICAgIHR5cGVIaW50OiBmdW5jdGlvbigpIHt9LFxuICAgIHByb3BIaW50OiBmdW5jdGlvbigpIHt9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiP1wiOyB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGV4dGVuZChwcm90bywgcHJvcHMpIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgaWYgKHByb3BzKSBmb3IgKHZhciBwcm9wIGluIHByb3BzKSBvYmpbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgLy8gQUJTVFJBQ1QgVkFMVUVTXG5cbiAgdmFyIFdHX0RFRkFVTFQgPSAxMDAsIFdHX05FV19JTlNUQU5DRSA9IDkwLCBXR19NQURFVVBfUFJPVE8gPSAxMCxcbiAgICAgIFdHX01VTFRJX01FTUJFUiA9IDYsIFdHX0NBVENIX0VSUk9SID0gNixcbiAgICAgIFdHX1BIQU5UT01fT0JKID0gMSxcbiAgICAgIFdHX0dMT0JBTF9USElTID0gOTAsIFdHX1NQRUNVTEFUSVZFX1RISVMgPSAyLCBXR19TUEVDVUxBVElWRV9QUk9UT19USElTID0gNDtcblxuICB2YXIgQVZhbCA9IGV4cG9ydHMuQVZhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHlwZXMgPSBbXTtcbiAgICB0aGlzLmZvcndhcmQgPSBudWxsO1xuICAgIHRoaXMubWF4V2VpZ2h0ID0gMDtcbiAgfTtcbiAgQVZhbC5wcm90b3R5cGUgPSBleHRlbmQoQU51bGwsIHtcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0eXBlLCB3ZWlnaHQpIHtcbiAgICAgIHdlaWdodCA9IHdlaWdodCB8fCBXR19ERUZBVUxUO1xuICAgICAgaWYgKHRoaXMubWF4V2VpZ2h0IDwgd2VpZ2h0KSB7XG4gICAgICAgIHRoaXMubWF4V2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgICBpZiAodGhpcy50eXBlcy5sZW5ndGggPT0gMSAmJiB0aGlzLnR5cGVzWzBdID09IHR5cGUpIHJldHVybjtcbiAgICAgICAgdGhpcy50eXBlcy5sZW5ndGggPSAwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1heFdlaWdodCA+IHdlaWdodCB8fCB0aGlzLnR5cGVzLmluZGV4T2YodHlwZSkgPiAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2lnbmFsKFwiYWRkVHlwZVwiLCB0eXBlKTtcbiAgICAgIHRoaXMudHlwZXMucHVzaCh0eXBlKTtcbiAgICAgIHZhciBmb3J3YXJkID0gdGhpcy5mb3J3YXJkO1xuICAgICAgaWYgKGZvcndhcmQpIHdpdGhXb3JrbGlzdChmdW5jdGlvbihhZGQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3J3YXJkLmxlbmd0aDsgKytpKSBhZGQodHlwZSwgZm9yd2FyZFtpXSwgd2VpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwcm9wYWdhdGU6IGZ1bmN0aW9uKHRhcmdldCwgd2VpZ2h0KSB7XG4gICAgICBpZiAodGFyZ2V0ID09IEFOdWxsIHx8ICh0YXJnZXQgaW5zdGFuY2VvZiBUeXBlICYmIHRoaXMuZm9yd2FyZCAmJiB0aGlzLmZvcndhcmQubGVuZ3RoID4gMikpIHJldHVybjtcbiAgICAgIGlmICh3ZWlnaHQgJiYgd2VpZ2h0ICE9IFdHX0RFRkFVTFQpIHRhcmdldCA9IG5ldyBNdWZmbGUodGFyZ2V0LCB3ZWlnaHQpO1xuICAgICAgKHRoaXMuZm9yd2FyZCB8fCAodGhpcy5mb3J3YXJkID0gW10pKS5wdXNoKHRhcmdldCk7XG4gICAgICB2YXIgdHlwZXMgPSB0aGlzLnR5cGVzO1xuICAgICAgaWYgKHR5cGVzLmxlbmd0aCkgd2l0aFdvcmtsaXN0KGZ1bmN0aW9uKGFkZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgKytpKSBhZGQodHlwZXNbaV0sIHRhcmdldCwgd2VpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRQcm9wOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICBpZiAoaWdub3JlZFByb3AocHJvcCkpIHJldHVybiBBTnVsbDtcbiAgICAgIHZhciBmb3VuZCA9ICh0aGlzLnByb3BzIHx8ICh0aGlzLnByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW3Byb3BdO1xuICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICBmb3VuZCA9IHRoaXMucHJvcHNbcHJvcF0gPSBuZXcgQVZhbDtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGUobmV3IEdldFByb3AocHJvcCwgZm91bmQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgZm9yQWxsUHJvcHM6IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHRoaXMucHJvcGFnYXRlKG5ldyBGb3JBbGxQcm9wcyhjKSk7XG4gICAgfSxcblxuICAgIGhhc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGVzLmluZGV4T2YodHlwZSkgPiAtMTtcbiAgICB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50eXBlcy5sZW5ndGggPT09IDA7IH0sXG4gICAgZ2V0RnVuY3Rpb25UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnR5cGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICBpZiAodGhpcy50eXBlc1tpXSBpbnN0YW5jZW9mIEZuKSByZXR1cm4gdGhpcy50eXBlc1tpXTtcbiAgICB9LFxuICAgIGdldE9ialR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlZW4gPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHlwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ldO1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgT2JqKSkgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlLm5hbWUpIHJldHVybiB0eXBlO1xuICAgICAgICBpZiAoIXNlZW4pIHNlZW4gPSB0eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlZW47XG4gICAgfSxcblxuICAgIGdldFN5bWJvbFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHlwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIGlmICh0aGlzLnR5cGVzW2ldIGluc3RhbmNlb2YgU3ltKSByZXR1cm4gdGhpcy50eXBlc1tpXTtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oZ3Vlc3MpIHtcbiAgICAgIGlmICh0aGlzLnR5cGVzLmxlbmd0aCA9PT0gMCAmJiBndWVzcyAhPT0gZmFsc2UpIHJldHVybiB0aGlzLm1ha2V1cFR5cGUoKTtcbiAgICAgIGlmICh0aGlzLnR5cGVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMudHlwZXNbMF07XG4gICAgICByZXR1cm4gY2Fub25pY2FsVHlwZSh0aGlzLnR5cGVzKTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKG1heERlcHRoLCBwYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLnR5cGVzLmxlbmd0aCA9PSAwKSByZXR1cm4gdG9TdHJpbmcodGhpcy5tYWtldXBUeXBlKCksIG1heERlcHRoLCBwYXJlbnQpO1xuICAgICAgaWYgKHRoaXMudHlwZXMubGVuZ3RoID09IDEpIHJldHVybiB0b1N0cmluZyh0aGlzLnR5cGVzWzBdLCBtYXhEZXB0aCwgcGFyZW50KTtcbiAgICAgIHZhciBzaW1wbGlmaWVkID0gc2ltcGxpZnlUeXBlcyh0aGlzLnR5cGVzKTtcbiAgICAgIGlmIChzaW1wbGlmaWVkLmxlbmd0aCA+IDIpIHJldHVybiBcIj9cIjtcbiAgICAgIHJldHVybiBzaW1wbGlmaWVkLm1hcChmdW5jdGlvbih0cCkgeyByZXR1cm4gdG9TdHJpbmcodHAsIG1heERlcHRoLCBwYXJlbnQpOyB9KS5qb2luKFwifFwiKTtcbiAgICB9LFxuXG4gICAgbWFrZXVwUHJvcFR5cGU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHByb3BOYW1lID0gdGhpcy5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgIHZhciBwcm90b1Byb3AgPSBvYmoucHJvdG8gJiYgb2JqLnByb3RvLmhhc1Byb3AocHJvcE5hbWUpO1xuICAgICAgaWYgKHByb3RvUHJvcCkge1xuICAgICAgICB2YXIgZnJvbVByb3RvID0gcHJvdG9Qcm9wLmdldFR5cGUoKTtcbiAgICAgICAgaWYgKGZyb21Qcm90bykgcmV0dXJuIGZyb21Qcm90bztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BOYW1lICE9IFwiPGk+XCIpIHtcbiAgICAgICAgdmFyIGNvbXB1dGVkUHJvcCA9IG9iai5oYXNQcm9wKFwiPGk+XCIpO1xuICAgICAgICBpZiAoY29tcHV0ZWRQcm9wKSByZXR1cm4gY29tcHV0ZWRQcm9wLmdldFR5cGUoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqLnByb3BzW1wiPGk+XCJdICE9IHRoaXMpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmoucHJvcHMpIHtcbiAgICAgICAgICB2YXIgdmFsID0gb2JqLnByb3BzW3Byb3BdO1xuICAgICAgICAgIGlmICghdmFsLmlzRW1wdHkoKSkgcmV0dXJuIHZhbC5nZXRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFrZXVwVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLnByb3BlcnR5T2YgJiYgdGhpcy5tYWtldXBQcm9wVHlwZSh0aGlzLnByb3BlcnR5T2YpO1xuICAgICAgaWYgKGNvbXB1dGVkKSByZXR1cm4gY29tcHV0ZWQ7XG5cbiAgICAgIGlmICghdGhpcy5mb3J3YXJkKSByZXR1cm4gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZvcndhcmQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGhpbnQgPSB0aGlzLmZvcndhcmRbaV0udHlwZUhpbnQoKTtcbiAgICAgICAgaWYgKGhpbnQgJiYgIWhpbnQuaXNFbXB0eSgpKSB7Z3Vlc3NpbmcgPSB0cnVlOyByZXR1cm4gaGludDt9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCksIGZvdW5kUHJvcCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9yd2FyZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMuZm9yd2FyZFtpXS5wcm9wSGludCgpO1xuICAgICAgICBpZiAocHJvcCAmJiBwcm9wICE9IFwibGVuZ3RoXCIgJiYgcHJvcCAhPSBcIjxpPlwiICYmIHByb3AgIT0gXCLinJZcIiAmJiBwcm9wICE9IGN4LmNvbXBsZXRpbmdQcm9wZXJ0eSkge1xuICAgICAgICAgIHByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgICAgICBmb3VuZFByb3AgPSBwcm9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kUHJvcCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHZhciBvYmpzID0gb2Jqc1dpdGhQcm9wKGZvdW5kUHJvcCk7XG4gICAgICBpZiAob2Jqcykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBzZWFyY2g6IGZvciAodmFyIGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIGlmICghb2JqLmhhc1Byb3AocHJvcCkpIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICBpZiAob2JqLmhhc0N0b3IpIG9iaiA9IGdldEluc3RhbmNlKG9iaik7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbm9uID0gY2Fub25pY2FsVHlwZShtYXRjaGVzKTtcbiAgICAgICAgaWYgKGNhbm9uKSB7Z3Vlc3NpbmcgPSB0cnVlOyByZXR1cm4gY2Fub247fVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0eXBlSGludDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnR5cGVzLmxlbmd0aCA/IHRoaXMuZ2V0VHlwZSgpIDogbnVsbDsgfSxcbiAgICBwcm9wYWdhdGVzVG86IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIGdhdGhlclByb3BlcnRpZXM6IGZ1bmN0aW9uKGYsIGRlcHRoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIHRoaXMudHlwZXNbaV0uZ2F0aGVyUHJvcGVydGllcyhmLCBkZXB0aCk7XG4gICAgfSxcblxuICAgIGd1ZXNzUHJvcGVydGllczogZnVuY3Rpb24oZikge1xuICAgICAgaWYgKHRoaXMuZm9yd2FyZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvcndhcmQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByb3AgPSB0aGlzLmZvcndhcmRbaV0ucHJvcEhpbnQoKTtcbiAgICAgICAgaWYgKHByb3ApIGYocHJvcCwgbnVsbCwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgZ3Vlc3NlZCA9IHRoaXMubWFrZXVwVHlwZSgpO1xuICAgICAgaWYgKGd1ZXNzZWQpIGd1ZXNzZWQuZ2F0aGVyUHJvcGVydGllcyhmKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNpbWlsYXJBVmFsKGEsIGIsIGRlcHRoKSB7XG4gICAgdmFyIHR5cGVBID0gYS5nZXRUeXBlKGZhbHNlKSwgdHlwZUIgPSBiLmdldFR5cGUoZmFsc2UpO1xuICAgIGlmICghdHlwZUEgfHwgIXR5cGVCKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2ltaWxhclR5cGUodHlwZUEsIHR5cGVCLCBkZXB0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaW1pbGFyVHlwZShhLCBiLCBkZXB0aCkge1xuICAgIGlmICghYSB8fCBkZXB0aCA+PSA1KSByZXR1cm4gYjtcbiAgICBpZiAoIWEgfHwgYSA9PSBiKSByZXR1cm4gYTtcbiAgICBpZiAoIWIpIHJldHVybiBhO1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PSBBcnIpIHtcbiAgICAgIHZhciBpbm5lckEgPSBhLmdldFByb3AoXCI8aT5cIikuZ2V0VHlwZShmYWxzZSk7XG4gICAgICBpZiAoIWlubmVyQSkgcmV0dXJuIGI7XG4gICAgICB2YXIgaW5uZXJCID0gYi5nZXRQcm9wKFwiPGk+XCIpLmdldFR5cGUoZmFsc2UpO1xuICAgICAgaWYgKCFpbm5lckIgfHwgc2ltaWxhclR5cGUoaW5uZXJBLCBpbm5lckIsIGRlcHRoICsgMSkpIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYS5jb25zdHJ1Y3RvciA9PSBPYmopIHtcbiAgICAgIHZhciBwcm9wc0EgPSAwLCBwcm9wc0IgPSAwLCBzYW1lID0gMDtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gYS5wcm9wcykge1xuICAgICAgICBwcm9wc0ErKztcbiAgICAgICAgaWYgKHByb3AgaW4gYi5wcm9wcyAmJiBzaW1pbGFyQVZhbChhLnByb3BzW3Byb3BdLCBiLnByb3BzW3Byb3BdLCBkZXB0aCArIDEpKVxuICAgICAgICAgIHNhbWUrKztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3AgaW4gYi5wcm9wcykgcHJvcHNCKys7XG4gICAgICBpZiAocHJvcHNBICYmIHByb3BzQiAmJiBzYW1lIDwgTWF0aC5tYXgocHJvcHNBLCBwcm9wc0IpIC8gMikgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHByb3BzQSA+IHByb3BzQiA/IGEgOiBiO1xuICAgIH0gZWxzZSBpZiAoYS5jb25zdHJ1Y3RvciA9PSBGbikge1xuICAgICAgaWYgKGEuYXJncy5sZW5ndGggIT0gYi5hcmdzLmxlbmd0aCB8fFxuICAgICAgICAgICFhLmFyZ3MuZXZlcnkoZnVuY3Rpb24odHAsIGkpIHsgcmV0dXJuIHNpbWlsYXJBVmFsKHRwLCBiLmFyZ3NbaV0sIGRlcHRoICsgMSk7IH0pIHx8XG4gICAgICAgICAgIXNpbWlsYXJBVmFsKGEucmV0dmFsLCBiLnJldHZhbCwgZGVwdGggKyAxKSB8fCAhc2ltaWxhckFWYWwoYS5zZWxmLCBiLnNlbGYsIGRlcHRoICsgMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpbXBsaWZ5VHlwZXMgPSBleHBvcnRzLnNpbXBsaWZ5VHlwZXMgPSBmdW5jdGlvbih0eXBlcykge1xuICAgIHZhciBmb3VuZCA9IFtdO1xuICAgIG91dGVyOiBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHAgPSB0eXBlc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHNpbWlsYXIgPSBzaW1pbGFyVHlwZSh0cCwgZm91bmRbal0sIDApO1xuICAgICAgICBpZiAoc2ltaWxhcikge1xuICAgICAgICAgIGZvdW5kW2pdID0gc2ltaWxhcjtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm91bmQucHVzaCh0cCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfTtcblxuICBmdW5jdGlvbiBjYW5vbmljYWxUeXBlKHR5cGVzKSB7XG4gICAgdmFyIGFycmF5cyA9IDAsIGZucyA9IDAsIG9ianMgPSAwLCBwcmltID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHAgPSB0eXBlc1tpXTtcbiAgICAgIGlmICh0cCBpbnN0YW5jZW9mIEFycikgKythcnJheXM7XG4gICAgICBlbHNlIGlmICh0cCBpbnN0YW5jZW9mIEZuKSArK2ZucztcbiAgICAgIGVsc2UgaWYgKHRwIGluc3RhbmNlb2YgT2JqKSArK29ianM7XG4gICAgICBlbHNlIGlmICh0cCBpbnN0YW5jZW9mIFByaW0pIHtcbiAgICAgICAgaWYgKHByaW0gJiYgdHAubmFtZSAhPSBwcmltLm5hbWUpIHJldHVybiBudWxsO1xuICAgICAgICBwcmltID0gdHA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBraW5kcyA9IChhcnJheXMgJiYgMSkgKyAoZm5zICYmIDEpICsgKG9ianMgJiYgMSkgKyAocHJpbSAmJiAxKTtcbiAgICBpZiAoa2luZHMgPiAxKSByZXR1cm4gbnVsbDtcbiAgICBpZiAocHJpbSkgcmV0dXJuIHByaW07XG5cbiAgICB2YXIgbWF4U2NvcmUgPSAwLCBtYXhUcCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHRwID0gdHlwZXNbaV0sIHNjb3JlID0gMDtcbiAgICAgIGlmIChhcnJheXMpIHtcbiAgICAgICAgc2NvcmUgPSB0cC5nZXRQcm9wKFwiPGk+XCIpLmlzRW1wdHkoKSA/IDEgOiAyO1xuICAgICAgfSBlbHNlIGlmIChmbnMpIHtcbiAgICAgICAgc2NvcmUgPSAxO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRwLmFyZ3MubGVuZ3RoOyArK2opIGlmICghdHAuYXJnc1tqXS5pc0VtcHR5KCkpICsrc2NvcmU7XG4gICAgICAgIGlmICghdHAucmV0dmFsLmlzRW1wdHkoKSkgKytzY29yZTtcbiAgICAgIH0gZWxzZSBpZiAob2Jqcykge1xuICAgICAgICBzY29yZSA9IHRwLm5hbWUgPyAxMDAgOiAyO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3JlID49IG1heFNjb3JlKSB7IG1heFNjb3JlID0gc2NvcmU7IG1heFRwID0gdHA7IH1cbiAgICB9XG4gICAgcmV0dXJuIG1heFRwO1xuICB9XG5cbiAgLy8gUFJPUEFHQVRJT04gU1RSQVRFR0lFU1xuXG4gIHZhciBjb25zdHJhaW50ID0gZXhwb3J0cy5jb25zdHJhaW50ID0gZnVuY3Rpb24obWV0aG9kcykge1xuICAgIHZhciBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9yaWdpbiA9IGN4LmN1ck9yaWdpbjtcbiAgICAgIHRoaXMuY29uc3RydWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQU51bGwpO1xuICAgIGZvciAodmFyIG0gaW4gbWV0aG9kcykgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobSkpIGN0b3IucHJvdG90eXBlW21dID0gbWV0aG9kc1ttXTtcbiAgICByZXR1cm4gY3RvcjtcbiAgfTtcblxuICB2YXIgR2V0UHJvcCA9IGNvbnN0cmFpbnQoe1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24ocHJvcCwgdGFyZ2V0KSB7XG4gICAgICB0aGlzLnByb3AgPSBwcm9wOyB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKHR5cGUsIHdlaWdodCkge1xuICAgICAgaWYgKHR5cGUuZ2V0UHJvcClcbiAgICAgICAgdHlwZS5nZXRQcm9wKHRoaXMucHJvcCkucHJvcGFnYXRlKHRoaXMudGFyZ2V0LCB3ZWlnaHQpO1xuICAgIH0sXG4gICAgcHJvcEhpbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wcm9wOyB9LFxuICAgIHByb3BhZ2F0ZXNUbzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wcm9wID09IFwiPGk+XCIgfHwgIS9bXlxcd19dLy50ZXN0KHRoaXMucHJvcCkpXG4gICAgICAgIHJldHVybiB7dGFyZ2V0OiB0aGlzLnRhcmdldCwgcGF0aEV4dDogXCIuXCIgKyB0aGlzLnByb3B9O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIERlZlByb3AgPSBleHBvcnRzLlByb3BIYXNTdWJzZXQgPSBleHBvcnRzLkRlZlByb3AgPSBjb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHByb3AsIHR5cGUsIG9yaWdpbk5vZGUpIHtcbiAgICAgIHRoaXMucHJvcCA9IHByb3A7IHRoaXMudHlwZSA9IHR5cGU7IHRoaXMub3JpZ2luTm9kZSA9IG9yaWdpbk5vZGU7XG4gICAgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0eXBlLCB3ZWlnaHQpIHtcbiAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBPYmopKSByZXR1cm47XG4gICAgICB2YXIgcHJvcCA9IHR5cGUuZGVmUHJvcCh0aGlzLnByb3AsIHRoaXMub3JpZ2luTm9kZSk7XG4gICAgICBpZiAoIXByb3Aub3JpZ2luKSBwcm9wLm9yaWdpbiA9IHRoaXMub3JpZ2luO1xuICAgICAgdGhpcy50eXBlLnByb3BhZ2F0ZShwcm9wLCB3ZWlnaHQpO1xuICAgIH0sXG4gICAgcHJvcEhpbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wcm9wOyB9XG4gIH0pO1xuXG4gIHZhciBGb3JBbGxQcm9wcyA9IGNvbnN0cmFpbnQoe1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24oYykgeyB0aGlzLmMgPSBjOyB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBPYmopKSByZXR1cm47XG4gICAgICB0eXBlLmZvckFsbFByb3BzKHRoaXMuYyk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB3aXRoRGlzYWJsZWRDb21wdXRpbmcoZm4sIGJvZHkpIHtcbiAgICBjeC5kaXNhYmxlZENvbXB1dGluZyA9IHtmbjogZm4sIHByZXY6IGN4LmRpc2FibGVkQ29tcHV0aW5nfTtcbiAgICB2YXIgcmVzdWx0ID0gYm9keSgpO1xuICAgIGN4LmRpc2FibGVkQ29tcHV0aW5nID0gY3guZGlzYWJsZWRDb21wdXRpbmcucHJldjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBJc0NhbGxlZSA9IGV4cG9ydHMuSXNDYWxsZWUgPSBjb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHNlbGYsIGFyZ3MsIGFyZ05vZGVzLCByZXR2YWwpIHtcbiAgICAgIHRoaXMuc2VsZiA9IHNlbGY7IHRoaXMuYXJncyA9IGFyZ3M7IHRoaXMuYXJnTm9kZXMgPSBhcmdOb2RlczsgdGhpcy5yZXR2YWwgPSByZXR2YWw7XG4gICAgICB0aGlzLmRpc2FibGVkID0gY3guZGlzYWJsZWRDb21wdXRpbmc7XG4gICAgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbihmbiwgd2VpZ2h0KSB7XG4gICAgICBpZiAoIShmbiBpbnN0YW5jZW9mIEZuKSkgcmV0dXJuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPCBmbi5hcmdzLmxlbmd0aCkgdGhpcy5hcmdzW2ldLnByb3BhZ2F0ZShmbi5hcmdzW2ldLCB3ZWlnaHQpO1xuICAgICAgICBpZiAoZm4uYXJndW1lbnRzKSB0aGlzLmFyZ3NbaV0ucHJvcGFnYXRlKGZuLmFyZ3VtZW50cywgd2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmICghZm4uaXNBcnJvd0ZuKCkpXG4gICAgICAgIHRoaXMuc2VsZi5wcm9wYWdhdGUoZm4uc2VsZiwgdGhpcy5zZWxmID09IGN4LnRvcFNjb3BlID8gV0dfR0xPQkFMX1RISVMgOiB3ZWlnaHQpO1xuICAgICAgdmFyIGNvbXB1dGUgPSBmbi5jb21wdXRlUmV0LCByZXN1bHQgPSBmbi5yZXR2YWw7XG4gICAgICBpZiAoY29tcHV0ZSkgZm9yICh2YXIgZCA9IHRoaXMuZGlzYWJsZWQ7IGQ7IGQgPSBkLnByZXYpXG4gICAgICAgIGlmIChkLmZuID09IGZuIHx8IGZuLm9yaWdpbk5vZGUgJiYgZC5mbi5vcmlnaW5Ob2RlID09IGZuLm9yaWdpbk5vZGUpIGNvbXB1dGUgPSBudWxsO1xuICAgICAgaWYgKGNvbXB1dGUpIHtcbiAgICAgICAgdmFyIG9sZCA9IGN4LmRpc2FibGVkQ29tcHV0aW5nO1xuICAgICAgICBjeC5kaXNhYmxlZENvbXB1dGluZyA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIHJlc3VsdCA9IGNvbXB1dGUodGhpcy5zZWxmLCB0aGlzLmFyZ3MsIHRoaXMuYXJnTm9kZXMpO1xuICAgICAgICBjeC5kaXNhYmxlZENvbXB1dGluZyA9IG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbi5hc3luYyAmJiAhZm4uZ2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciB0cCA9IHJlc3VsdC5nZXRUeXBlKCk7XG4gICAgICAgIGlmICghKHRwICYmIHRwLmNvbnN0cnVjdG9yID09IE9iaiAmJiB0cC5uYW1lID09IFwiUHJvbWlzZVwiKSkge1xuICAgICAgICAgIHZhciBkZWZzID0gY3guZGVmaW5pdGlvbnMuZWNtYXNjcmlwdDtcbiAgICAgICAgICB2YXIgcnRudmFsID0gZGVmcyAmJiBuZXcgT2JqKGRlZnNbXCJQcm9taXNlLnByb3RvdHlwZVwiXSk7XG4gICAgICAgICAgaWYgKHJ0bnZhbCkge1xuICAgICAgICAgICAgcnRudmFsLmdldFR5cGUoKS5wcm9wYWdhdGUobmV3IERlZlByb3AoJzp0JywgcmVzdWx0KSk7XG4gICAgICAgICAgICByZXN1bHQgPSBydG52YWw7ICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXliZUl0ZXJhdG9yKGZuLCByZXN1bHQpLnByb3BhZ2F0ZSh0aGlzLnJldHZhbCwgd2VpZ2h0KTtcbiAgICB9LFxuICAgIHR5cGVIaW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIG5hbWVzLnB1c2goXCI/XCIpO1xuICAgICAgcmV0dXJuIG5ldyBGbihudWxsLCB0aGlzLnNlbGYsIHRoaXMuYXJncywgbmFtZXMsIEFOdWxsKTtcbiAgICB9LFxuICAgIHByb3BhZ2F0ZXNUbzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3RhcmdldDogdGhpcy5yZXR2YWwsIHBhdGhFeHQ6IFwiLiFyZXRcIn07XG4gICAgfVxuICB9KTtcblxuICB2YXIgSGFzTWV0aG9kQ2FsbCA9IGNvbnN0cmFpbnQoe1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24ocHJvcE5hbWUsIGFyZ3MsIGFyZ05vZGVzLCByZXR2YWwpIHtcbiAgICAgIHRoaXMucHJvcE5hbWUgPSBwcm9wTmFtZTsgdGhpcy5hcmdzID0gYXJnczsgdGhpcy5hcmdOb2RlcyA9IGFyZ05vZGVzOyB0aGlzLnJldHZhbCA9IHJldHZhbDtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSBjeC5kaXNhYmxlZENvbXB1dGluZztcbiAgICB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKG9iaiwgd2VpZ2h0KSB7XG4gICAgICB2YXIgY2FsbGVlID0gbmV3IElzQ2FsbGVlKG9iaiwgdGhpcy5hcmdzLCB0aGlzLmFyZ05vZGVzLCB0aGlzLnJldHZhbCk7XG4gICAgICBjYWxsZWUuZGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkO1xuICAgICAgb2JqLmdldFByb3AodGhpcy5wcm9wTmFtZSkucHJvcGFnYXRlKGNhbGxlZSwgd2VpZ2h0KTtcbiAgICB9LFxuICAgIHByb3BIaW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHJvcE5hbWU7IH1cbiAgfSk7XG5cbiAgdmFyIElzQ3RvciA9IGV4cG9ydHMuSXNDdG9yID0gY29uc3RyYWludCh7XG4gICAgY29uc3RydWN0OiBmdW5jdGlvbih0YXJnZXQsIG5vUmV1c2UpIHtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0OyB0aGlzLm5vUmV1c2UgPSBub1JldXNlO1xuICAgIH0sXG4gICAgYWRkVHlwZTogZnVuY3Rpb24oZiwgd2VpZ2h0KSB7XG4gICAgICBpZiAoIShmIGluc3RhbmNlb2YgRm4pKSByZXR1cm47XG4gICAgICBpZiAoY3gucGFyZW50ICYmICFjeC5wYXJlbnQub3B0aW9ucy5yZXVzZUluc3RhbmNlcykgdGhpcy5ub1JldXNlID0gdHJ1ZTtcbiAgICAgIGYuZ2V0UHJvcChcInByb3RvdHlwZVwiKS5wcm9wYWdhdGUobmV3IElzUHJvdG8odGhpcy5ub1JldXNlID8gZmFsc2UgOiBmLCB0aGlzLnRhcmdldCksIHdlaWdodCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZ2V0SW5zdGFuY2UgPSBleHBvcnRzLmdldEluc3RhbmNlID0gZnVuY3Rpb24ob2JqLCBjdG9yKSB7XG4gICAgaWYgKGN0b3IgPT09IGZhbHNlKSByZXR1cm4gbmV3IE9iaihvYmopO1xuXG4gICAgaWYgKCFjdG9yKSBjdG9yID0gb2JqLmhhc0N0b3I7XG4gICAgaWYgKCFvYmouaW5zdGFuY2VzKSBvYmouaW5zdGFuY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouaW5zdGFuY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY3VyID0gb2JqLmluc3RhbmNlc1tpXTtcbiAgICAgIGlmIChjdXIuY3RvciA9PSBjdG9yKSByZXR1cm4gY3VyLmluc3RhbmNlO1xuICAgIH1cbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgT2JqKG9iaiwgY3RvciAmJiBjdG9yLm5hbWUpO1xuICAgIGluc3RhbmNlLm9yaWdpbiA9IG9iai5vcmlnaW47XG4gICAgb2JqLmluc3RhbmNlcy5wdXNoKHtjdG9yOiBjdG9yLCBpbnN0YW5jZTogaW5zdGFuY2V9KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgdmFyIElzUHJvdG8gPSBleHBvcnRzLklzUHJvdG8gPSBjb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGN0b3IsIHRhcmdldCkge1xuICAgICAgdGhpcy5jdG9yID0gY3RvcjsgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbihvLCBfd2VpZ2h0KSB7XG4gICAgICBpZiAoIShvIGluc3RhbmNlb2YgT2JqKSkgcmV0dXJuO1xuICAgICAgaWYgKCh0aGlzLmNvdW50ID0gKHRoaXMuY291bnQgfHwgMCkgKyAxKSA+IDgpIHJldHVybjtcbiAgICAgIGlmIChvID09IGN4LnByb3Rvcy5BcnJheSlcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkVHlwZShuZXcgQXJyKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkVHlwZShnZXRJbnN0YW5jZShvLCB0aGlzLmN0b3IpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBGblByb3RvdHlwZSA9IGNvbnN0cmFpbnQoe1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24oZm4pIHsgdGhpcy5mbiA9IGZuOyB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKG8sIF93ZWlnaHQpIHtcbiAgICAgIGlmIChvIGluc3RhbmNlb2YgT2JqICYmICFvLmhhc0N0b3IpIHtcbiAgICAgICAgby5oYXNDdG9yID0gdGhpcy5mbjtcbiAgICAgICAgdmFyIGFkZGVyID0gbmV3IFNwZWN1bGF0aXZlVGhpcyhvLCB0aGlzLmZuKTtcbiAgICAgICAgYWRkZXIuYWRkVHlwZSh0aGlzLmZuKTtcbiAgICAgICAgby5mb3JBbGxQcm9wcyhmdW5jdGlvbihfcHJvcCwgdmFsLCBsb2NhbCkge1xuICAgICAgICAgIGlmIChsb2NhbCkgdmFsLnByb3BhZ2F0ZShhZGRlcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIElzQWRkZWQgPSBjb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKG90aGVyLCB0YXJnZXQpIHtcbiAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjsgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0eXBlLCB3ZWlnaHQpIHtcbiAgICAgIGlmICh0eXBlID09IGN4LnN0cilcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkVHlwZShjeC5zdHIsIHdlaWdodCk7XG4gICAgICBlbHNlIGlmICh0eXBlID09IGN4Lm51bSAmJiB0aGlzLm90aGVyLmhhc1R5cGUoY3gubnVtKSlcbiAgICAgICAgdGhpcy50YXJnZXQuYWRkVHlwZShjeC5udW0sIHdlaWdodCk7XG4gICAgfSxcbiAgICB0eXBlSGludDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm90aGVyOyB9XG4gIH0pO1xuXG4gIHZhciBJZk9iaiA9IGV4cG9ydHMuSWZPYmogPSBjb25zdHJhaW50KHtcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHRhcmdldCkgeyB0aGlzLnRhcmdldCA9IHRhcmdldDsgfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0LCB3ZWlnaHQpIHtcbiAgICAgIGlmICh0IGluc3RhbmNlb2YgT2JqKSB0aGlzLnRhcmdldC5hZGRUeXBlKHQsIHdlaWdodCk7XG4gICAgfSxcbiAgICBwcm9wYWdhdGVzVG86IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50YXJnZXQ7IH1cbiAgfSk7XG5cbiAgdmFyIFNwZWN1bGF0aXZlVGhpcyA9IGNvbnN0cmFpbnQoe1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24ob2JqLCBjdG9yKSB7IHRoaXMub2JqID0gb2JqOyB0aGlzLmN0b3IgPSBjdG9yOyB9LFxuICAgIGFkZFR5cGU6IGZ1bmN0aW9uKHRwKSB7XG4gICAgICBpZiAodHAgaW5zdGFuY2VvZiBGbiAmJiB0cC5zZWxmKVxuICAgICAgICB0cC5zZWxmLmFkZFR5cGUoZ2V0SW5zdGFuY2UodGhpcy5vYmosIHRoaXMuY3RvciksIFdHX1NQRUNVTEFUSVZFX1BST1RPX1RISVMpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIEhhc1Byb3RvID0gY29uc3RyYWludCh7XG4gICAgY29uc3RydWN0OiBmdW5jdGlvbihvYmopIHsgdGhpcy5vYmogPSBvYmogfSxcbiAgICBhZGRUeXBlOiBmdW5jdGlvbih0cCkge1xuICAgICAgaWYgKHRwIGluc3RhbmNlb2YgT2JqICYmIHRoaXMub2JqLnByb3RvID09IGN4LnByb3Rvcy5PYmplY3QpXG4gICAgICAgIHRoaXMub2JqLnJlcGxhY2VQcm90byh0cCk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgTXVmZmxlID0gY29uc3RyYWludCh7XG4gICAgY29uc3RydWN0OiBmdW5jdGlvbihpbm5lciwgd2VpZ2h0KSB7XG4gICAgICB0aGlzLmlubmVyID0gaW5uZXI7IHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xuICAgIH0sXG4gICAgYWRkVHlwZTogZnVuY3Rpb24odHAsIHdlaWdodCkge1xuICAgICAgdGhpcy5pbm5lci5hZGRUeXBlKHRwLCBNYXRoLm1pbih3ZWlnaHQsIHRoaXMud2VpZ2h0KSk7XG4gICAgfSxcbiAgICBwcm9wYWdhdGVzVG86IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbm5lci5wcm9wYWdhdGVzVG8oKTsgfSxcbiAgICB0eXBlSGludDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlubmVyLnR5cGVIaW50KCk7IH0sXG4gICAgcHJvcEhpbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbm5lci5wcm9wSGludCgpOyB9XG4gIH0pO1xuXG4gIC8vIFRZUEUgT0JKRUNUU1xuXG4gIHZhciBUeXBlID0gZXhwb3J0cy5UeXBlID0gZnVuY3Rpb24oKSB7fTtcbiAgVHlwZS5wcm90b3R5cGUgPSBleHRlbmQoQU51bGwsIHtcbiAgICBjb25zdHJ1Y3RvcjogVHlwZSxcbiAgICBwcm9wYWdhdGU6IGZ1bmN0aW9uKGMsIHcpIHsgYy5hZGRUeXBlKHRoaXMsIHcpOyB9LFxuICAgIGhhc1R5cGU6IGZ1bmN0aW9uKG90aGVyKSB7IHJldHVybiBvdGhlciA9PSB0aGlzOyB9LFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgdHlwZUhpbnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG5cbiAgdmFyIFByaW0gPSBleHBvcnRzLlByaW0gPSBmdW5jdGlvbihwcm90bywgbmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB0aGlzLnByb3RvID0gcHJvdG87IH07XG4gIFByaW0ucHJvdG90eXBlID0gZXh0ZW5kKFR5cGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IFByaW0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uYW1lOyB9LFxuICAgIGdldFByb3A6IGZ1bmN0aW9uKHByb3ApIHtyZXR1cm4gdGhpcy5wcm90by5oYXNQcm9wKHByb3ApIHx8IEFOdWxsO30sXG4gICAgZ2F0aGVyUHJvcGVydGllczogZnVuY3Rpb24oZiwgZGVwdGgpIHtcbiAgICAgIGlmICh0aGlzLnByb3RvKSB0aGlzLnByb3RvLmdhdGhlclByb3BlcnRpZXMoZiwgZGVwdGgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIHZhciBjMCA9IHN0ci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjMCA+PSA0OCAmJiBjMCA8PSA1NykgcmV0dXJuICEvXFxELy50ZXN0KHN0cik7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT2JqID0gZXhwb3J0cy5PYmogPSBmdW5jdGlvbihwcm90bywgbmFtZSkge1xuICAgIGlmICghdGhpcy5wcm9wcykgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5wcm90byA9IHByb3RvID09PSB0cnVlID8gY3gucHJvdG9zLk9iamVjdCA6IHByb3RvO1xuICAgIGlmIChwcm90byAmJiBwcm90byAhPSBjeC5wcm90b3MuT2JqZWN0ICYmICFuYW1lICYmIHByb3RvLm5hbWUgJiYgISh0aGlzIGluc3RhbmNlb2YgRm4pKSB7XG4gICAgICB2YXIgbWF0Y2ggPSAvXiguKilcXC5wcm90b3R5cGUkLy5leGVjKHRoaXMucHJvdG8ubmFtZSk7XG4gICAgICBpZiAobWF0Y2gpIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1heWJlUHJvcHMgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luID0gY3guY3VyT3JpZ2luO1xuICB9O1xuICBPYmoucHJvdG90eXBlID0gZXh0ZW5kKFR5cGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IE9iaixcbiAgICB0b1N0cmluZzogZnVuY3Rpb24obWF4RGVwdGgpIHtcbiAgICAgIGlmIChtYXhEZXB0aCA9PSBudWxsKSBtYXhEZXB0aCA9IDA7XG4gICAgICBpZiAobWF4RGVwdGggPD0gMCAmJiB0aGlzLm5hbWUpIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB2YXIgcHJvcHMgPSBbXSwgZXRjID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMucHJvcHMpIGlmIChwcm9wICE9IFwiPGk+XCIpIHtcbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDUpIHsgZXRjID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICAgICAgaWYgKG1heERlcHRoKVxuICAgICAgICAgIHByb3BzLnB1c2gocHJvcCArIFwiOiBcIiArIHRvU3RyaW5nKHRoaXMucHJvcHNbcHJvcF0sIG1heERlcHRoIC0gMSwgdGhpcykpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnNvcnQoKTtcbiAgICAgIGlmIChldGMpIHByb3BzLnB1c2goXCIuLi5cIik7XG4gICAgICByZXR1cm4gXCJ7XCIgKyBwcm9wcy5qb2luKFwiLCBcIikgKyBcIn1cIjtcbiAgICB9LFxuICAgIGhhc1Byb3A6IGZ1bmN0aW9uKHByb3AsIHNlYXJjaFByb3RvKSB7XG4gICAgICBpZiAoaXNJbnRlZ2VyKHByb3ApKSBwcm9wID0gdGhpcy5ub3JtYWxpemVJbnRlZ2VyUHJvcChwcm9wKTtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMucHJvcHNbcHJvcF07XG4gICAgICBpZiAoc2VhcmNoUHJvdG8gIT09IGZhbHNlKVxuICAgICAgICBmb3IgKHZhciBwID0gdGhpcy5wcm90bzsgcCAmJiAhZm91bmQ7IHAgPSBwLnByb3RvKSBmb3VuZCA9IHAucHJvcHNbcHJvcF07XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcbiAgICBkZWZQcm9wOiBmdW5jdGlvbihwcm9wLCBvcmlnaW5Ob2RlKSB7XG4gICAgICB2YXIgZm91bmQgPSB0aGlzLmhhc1Byb3AocHJvcCwgZmFsc2UpO1xuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGlmIChvcmlnaW5Ob2RlICYmICFmb3VuZC5vcmlnaW5Ob2RlKSBmb3VuZC5vcmlnaW5Ob2RlID0gb3JpZ2luTm9kZTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGlnbm9yZWRQcm9wKHByb3ApKSByZXR1cm4gQU51bGw7XG4gICAgICBpZiAoaXNJbnRlZ2VyKHByb3ApKSBwcm9wID0gdGhpcy5ub3JtYWxpemVJbnRlZ2VyUHJvcChwcm9wKTtcblxuICAgICAgdmFyIGF2ID0gdGhpcy5tYXliZVByb3BzICYmIHRoaXMubWF5YmVQcm9wc1twcm9wXTtcbiAgICAgIGlmIChhdikge1xuICAgICAgICBkZWxldGUgdGhpcy5tYXliZVByb3BzW3Byb3BdO1xuICAgICAgICB0aGlzLm1heWJlVW5yZWdQcm90b1Byb3BIYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdiA9IG5ldyBBVmFsO1xuICAgICAgICBhdi5wcm9wZXJ0eU9mID0gdGhpcztcbiAgICAgICAgYXYucHJvcGVydHlOYW1lID0gcHJvcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wc1twcm9wXSA9IGF2O1xuICAgICAgYXYub3JpZ2luTm9kZSA9IG9yaWdpbk5vZGU7XG4gICAgICBhdi5vcmlnaW4gPSBjeC5jdXJPcmlnaW47XG4gICAgICB0aGlzLmJyb2FkY2FzdFByb3AocHJvcCwgYXYsIHRydWUpO1xuICAgICAgcmV0dXJuIGF2O1xuICAgIH0sXG4gICAgZ2V0UHJvcDogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5oYXNQcm9wKHByb3AsIHRydWUpIHx8ICh0aGlzLm1heWJlUHJvcHMgJiYgdGhpcy5tYXliZVByb3BzW3Byb3BdKTtcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgICAgaWYgKGlnbm9yZWRQcm9wKHByb3ApKSByZXR1cm4gQU51bGw7XG4gICAgICBpZiAoaXNJbnRlZ2VyKHByb3ApKSBwcm9wID0gdGhpcy5ub3JtYWxpemVJbnRlZ2VyUHJvcChwcm9wKTtcbiAgICAgIHZhciBhdiA9IHRoaXMuZW5zdXJlTWF5YmVQcm9wcygpW3Byb3BdID0gbmV3IEFWYWw7XG4gICAgICBhdi5wcm9wZXJ0eU9mID0gdGhpcztcbiAgICAgIGF2LnByb3BlcnR5TmFtZSA9IHByb3A7XG4gICAgICByZXR1cm4gYXY7XG4gICAgfSxcbiAgICBub3JtYWxpemVJbnRlZ2VyUHJvcDogZnVuY3Rpb24oXykgeyByZXR1cm4gXCI8aT5cIiB9LFxuICAgIGJyb2FkY2FzdFByb3A6IGZ1bmN0aW9uKHByb3AsIHZhbCwgbG9jYWwpIHtcbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICB0aGlzLnNpZ25hbChcImFkZFByb3BcIiwgcHJvcCwgdmFsKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHNjb3BlLCBpdCBzaG91bGRuJ3QgYmUgcmVnaXN0ZXJlZFxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NvcGUpKSByZWdpc3RlclByb3AocHJvcCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9uTmV3UHJvcCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9uTmV3UHJvcC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMub25OZXdQcm9wW2ldO1xuICAgICAgICBoLm9uUHJvdG9Qcm9wID8gaC5vblByb3RvUHJvcChwcm9wLCB2YWwsIGxvY2FsKSA6IGgocHJvcCwgdmFsLCBsb2NhbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblByb3RvUHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsLCBfbG9jYWwpIHtcbiAgICAgIHZhciBtYXliZSA9IHRoaXMubWF5YmVQcm9wcyAmJiB0aGlzLm1heWJlUHJvcHNbcHJvcF07XG4gICAgICBpZiAobWF5YmUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubWF5YmVQcm9wc1twcm9wXTtcbiAgICAgICAgdGhpcy5tYXliZVVucmVnUHJvdG9Qcm9wSGFuZGxlcigpO1xuICAgICAgICB0aGlzLnByb3RvLmdldFByb3AocHJvcCkucHJvcGFnYXRlKG1heWJlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnJvYWRjYXN0UHJvcChwcm9wLCB2YWwsIGZhbHNlKTtcbiAgICB9LFxuICAgIHJlcGxhY2VQcm90bzogZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgIGZvciAodmFyIG8gPSBwcm90bzsgbzsgbyA9IG8ucHJvdG8pXG4gICAgICAgIGlmIChvID09IHRoaXMpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnByb3RvICYmIHRoaXMubWF5YmVQcm9wcylcbiAgICAgICAgdGhpcy5wcm90by51bnJlZ1Byb3BIYW5kbGVyKHRoaXMpO1xuICAgICAgdGhpcy5wcm90byA9IHByb3RvO1xuICAgICAgaWYgKHRoaXMubWF5YmVQcm9wcylcbiAgICAgICAgdGhpcy5wcm90by5mb3JBbGxQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGVuc3VyZU1heWJlUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLm1heWJlUHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvdG8pIHRoaXMucHJvdG8uZm9yQWxsUHJvcHModGhpcyk7XG4gICAgICAgIHRoaXMubWF5YmVQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXliZVByb3BzO1xuICAgIH0sXG4gICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdmFyIGF2ID0gdGhpcy5wcm9wc1twcm9wXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnByb3BzW3Byb3BdO1xuICAgICAgdGhpcy5lbnN1cmVNYXliZVByb3BzKClbcHJvcF0gPSBhdjtcbiAgICAgIGF2LnR5cGVzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBmb3JBbGxQcm9wczogZnVuY3Rpb24oYykge1xuICAgICAgaWYgKCF0aGlzLm9uTmV3UHJvcCkge1xuICAgICAgICB0aGlzLm9uTmV3UHJvcCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm90bykgdGhpcy5wcm90by5mb3JBbGxQcm9wcyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25OZXdQcm9wLnB1c2goYyk7XG4gICAgICBmb3IgKHZhciBvID0gdGhpczsgbzsgbyA9IG8ucHJvdG8pIGZvciAodmFyIHByb3AgaW4gby5wcm9wcykge1xuICAgICAgICBpZiAoYy5vblByb3RvUHJvcClcbiAgICAgICAgICBjLm9uUHJvdG9Qcm9wKHByb3AsIG8ucHJvcHNbcHJvcF0sIG8gPT0gdGhpcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjKHByb3AsIG8ucHJvcHNbcHJvcF0sIG8gPT0gdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXliZVVucmVnUHJvdG9Qcm9wSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5tYXliZVByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIF9uIGluIHRoaXMubWF5YmVQcm9wcykgcmV0dXJuO1xuICAgICAgICB0aGlzLm1heWJlUHJvcHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByb3RvIHx8IHRoaXMub25OZXdQcm9wICYmIHRoaXMub25OZXdQcm9wLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdGhpcy5wcm90by51bnJlZ1Byb3BIYW5kbGVyKHRoaXMpO1xuICAgIH0sXG4gICAgdW5yZWdQcm9wSGFuZGxlcjogZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9uTmV3UHJvcC5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHRoaXMub25OZXdQcm9wW2ldID09IGhhbmRsZXIpIHsgdGhpcy5vbk5ld1Byb3Auc3BsaWNlKGksIDEpOyBicmVhazsgfVxuICAgICAgdGhpcy5tYXliZVVucmVnUHJvdG9Qcm9wSGFuZGxlcigpO1xuICAgIH0sXG4gICAgZ2F0aGVyUHJvcGVydGllczogZnVuY3Rpb24oZiwgZGVwdGgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5wcm9wcykgaWYgKHByb3AgIT0gXCI8aT5cIiAmJiBwcm9wLmNoYXJBdCgwKSAhPSBcIjpcIilcbiAgICAgICAgZihwcm9wLCB0aGlzLCBkZXB0aCk7XG4gICAgICBpZiAodGhpcy5wcm90bykgdGhpcy5wcm90by5nYXRoZXJQcm9wZXJ0aWVzKGYsIGRlcHRoICsgMSk7XG4gICAgfSxcbiAgICBnZXRPYmpUeXBlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG5cbiAgdmFyIGdlY2tvSXRlcmF0b3JzID0gdHlwZW9mIFN0b3BJdGVyYXRpb24gIT0gXCJ1bmRlZmluZWRcIjtcbiAgZnVuY3Rpb24gaWdub3JlZFByb3AobmFtZSkge1xuICAgIHJldHVybiBuYW1lID09IFwiX19wcm90b19fXCIgfHwgbmFtZSA9PSBcIuKcllwiIHx8IGdlY2tvSXRlcmF0b3JzICYmIG5hbWUgPT0gXCJfX2l0ZXJhdG9yX19cIjtcbiAgfVxuXG4gIHZhciBGbiA9IGV4cG9ydHMuRm4gPSBmdW5jdGlvbihuYW1lLCBzZWxmLCBhcmdzLCBhcmdOYW1lcywgcmV0dmFsLCBnZW5lcmF0b3IsIGFzeW5jKSB7XG4gICAgT2JqLmNhbGwodGhpcywgY3gucHJvdG9zLkZ1bmN0aW9uLCBuYW1lKTtcbiAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5hcmdOYW1lcyA9IGFyZ05hbWVzO1xuICAgIHRoaXMucmV0dmFsID0gcmV0dmFsO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHRoaXMuYXN5bmMgPSBhc3luYztcbiAgfTtcbiAgRm4ucHJvdG90eXBlID0gZXh0ZW5kKE9iai5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3RvcjogRm4sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKG1heERlcHRoKSB7XG4gICAgICBpZiAobWF4RGVwdGggPT0gbnVsbCkgbWF4RGVwdGggPSAwO1xuICAgICAgdmFyIHN0ciA9IHRoaXMuZ2VuZXJhdG9yID8gXCJmbiooXCIgOiBcImZuKFwiO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkpIHN0ciArPSBcIiwgXCI7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5hcmdOYW1lc1tpXTtcbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZSAhPSBcIj9cIikgc3RyICs9IG5hbWUgKyBcIjogXCI7XG4gICAgICAgIHN0ciArPSBtYXhEZXB0aCA+IC0zID8gdG9TdHJpbmcodGhpcy5hcmdzW2ldLCBtYXhEZXB0aCAtIDEsIHRoaXMpIDogXCI/XCI7XG4gICAgICB9XG4gICAgICBzdHIgKz0gXCIpXCI7XG4gICAgICBpZiAoIXRoaXMucmV0dmFsLmlzRW1wdHkoKSlcbiAgICAgICAgc3RyICs9IFwiIC0+IFwiICsgKG1heERlcHRoID4gLTMgPyB0b1N0cmluZyh0aGlzLnJldHZhbCwgbWF4RGVwdGggLSAxLCB0aGlzKSA6IFwiP1wiKTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcbiAgICBnZXRQcm9wOiBmdW5jdGlvbihwcm9wKSB7XG4gICAgICBpZiAocHJvcCA9PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgIHZhciBrbm93biA9IHRoaXMuaGFzUHJvcChwcm9wLCBmYWxzZSk7XG4gICAgICAgIGlmICgha25vd24pIHtcbiAgICAgICAgICBrbm93biA9IHRoaXMuZGVmUHJvcChwcm9wKTtcbiAgICAgICAgICB2YXIgcHJvdG8gPSBuZXcgT2JqKHRydWUsIHRoaXMubmFtZSAmJiB0aGlzLm5hbWUgKyBcIi5wcm90b3R5cGVcIik7XG4gICAgICAgICAgcHJvdG8ub3JpZ2luID0gdGhpcy5vcmlnaW47XG4gICAgICAgICAga25vd24uYWRkVHlwZShwcm90bywgV0dfTUFERVVQX1BST1RPKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga25vd247XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqLnByb3RvdHlwZS5nZXRQcm9wLmNhbGwodGhpcywgcHJvcCk7XG4gICAgfSxcbiAgICBkZWZQcm9wOiBmdW5jdGlvbihwcm9wLCBvcmlnaW5Ob2RlKSB7XG4gICAgICBpZiAocHJvcCA9PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHRoaXMuaGFzUHJvcChwcm9wLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgICAgICBmb3VuZCA9IE9iai5wcm90b3R5cGUuZGVmUHJvcC5jYWxsKHRoaXMsIHByb3AsIG9yaWdpbk5vZGUpO1xuICAgICAgICBmb3VuZC5vcmlnaW4gPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgZm91bmQucHJvcGFnYXRlKG5ldyBGblByb3RvdHlwZSh0aGlzKSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmoucHJvdG90eXBlLmRlZlByb3AuY2FsbCh0aGlzLCBwcm9wLCBvcmlnaW5Ob2RlKTtcbiAgICB9LFxuICAgIGdldEZ1bmN0aW9uVHlwZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIGlzQXJyb3dGbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm9yaWdpbk5vZGUgJiYgdGhpcy5vcmlnaW5Ob2RlLnR5cGUgPT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIH1cbiAgfSk7XG5cbiAgdmFyIEFyciA9IGV4cG9ydHMuQXJyID0gZnVuY3Rpb24oY29udGVudFR5cGUpIHtcbiAgICBPYmouY2FsbCh0aGlzLCBjeC5wcm90b3MuQXJyYXkpO1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5kZWZQcm9wKFwiPGk+XCIpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlKSkge1xuICAgICAgdGhpcy50dXBsZSA9IGNvbnRlbnRUeXBlLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudFR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSB0aGlzLmRlZlByb3AoU3RyaW5nKGkpKTtcbiAgICAgICAgY29udGVudFR5cGVbaV0ucHJvcGFnYXRlKHByb3ApO1xuICAgICAgICBwcm9wLnByb3BhZ2F0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICB0aGlzLnR1cGxlID0gMDtcbiAgICAgIGNvbnRlbnRUeXBlLnByb3BhZ2F0ZShjb250ZW50KTtcbiAgICB9XG4gIH07XG4gIEFyci5wcm90b3R5cGUgPSBleHRlbmQoT2JqLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBBcnIsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKG1heERlcHRoKSB7XG4gICAgICBpZiAobWF4RGVwdGggPT0gbnVsbCkgbWF4RGVwdGggPSAwO1xuICAgICAgaWYgKG1heERlcHRoIDw9IC0zKSByZXR1cm4gXCJbP11cIjtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIGlmICh0aGlzLnR1cGxlKSB7XG4gICAgICAgIHZhciBzaW1pbGFyO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSBpbiB0aGlzLnByb3BzOyBpKyspIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRvU3RyaW5nKHRoaXMuZ2V0UHJvcChTdHJpbmcoaSkpLCBtYXhEZXB0aCAtIDEsIHRoaXMpO1xuICAgICAgICAgIGlmIChzaW1pbGFyID09IG51bGwpXG4gICAgICAgICAgICBzaW1pbGFyID0gdHlwZTtcbiAgICAgICAgICBlbHNlIGlmIChzaW1pbGFyICE9IHR5cGUpXG4gICAgICAgICAgICBzaW1pbGFyID0gZmFsc2U7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2ltaWxhciA9IHR5cGU7XG4gICAgICAgICAgY29udGVudCArPSAoY29udGVudCA/IFwiLCBcIiA6IFwiXCIpICsgdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2ltaWxhcikgY29udGVudCA9IHNpbWlsYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gdG9TdHJpbmcodGhpcy5nZXRQcm9wKFwiPGk+XCIpLCBtYXhEZXB0aCAtIDEsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiW1wiICsgY29udGVudCArIFwiXVwiO1xuICAgIH0sXG4gICAgbm9ybWFsaXplSW50ZWdlclByb3A6IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmICgrcHJvcCA8IHRoaXMudHVwbGUpIHJldHVybiBwcm9wO1xuICAgICAgZWxzZSByZXR1cm4gXCI8aT5cIjtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBTeW0gPSBleHBvcnRzLlN5bSA9IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbk5vZGUpIHtcbiAgICBQcmltLmNhbGwodGhpcywgY3gucHJvdG9zLlN5bWJvbCwgXCJTeW1ib2xcIik7XG4gICAgdGhpcy5zeW1OYW1lID0gbmFtZTtcbiAgICB0aGlzLm9yaWdpbk5vZGUgPSBvcmlnaW5Ob2RlO1xuICB9O1xuICBTeW0ucHJvdG90eXBlID0gZXh0ZW5kKFByaW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IFN5bSxcbiAgICBhc1Byb3BOYW1lOiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiOlwiICsgdGhpcy5zeW1OYW1lIH0sXG4gICAgZ2V0U3ltYm9sVHlwZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH1cbiAgfSk7XG5cbiAgZXhwb3J0cy5nZXRTeW1ib2wgPSBmdW5jdGlvbihuYW1lLCBvcmlnaW5Ob2RlKSB7XG4gICAgdmFyIGNsZWFuTmFtZSA9IG5hbWUucmVwbGFjZSgvW15cXHckXFwuXS9nLCBcIl9cIik7XG4gICAgdmFyIGtub3duID0gY3guc3ltYm9sc1tjbGVhbk5hbWVdO1xuICAgIGlmIChrbm93bikge1xuICAgICAgaWYgKG9yaWdpbk5vZGUgJiYgIWtub3duLm9yaWdpbk5vZGUpIGtub3duLm9yaWdpbk5vZGUgPSBvcmlnaW5Ob2RlO1xuICAgICAgcmV0dXJuIGtub3duO1xuICAgIH1cbiAgICByZXR1cm4gY3guc3ltYm9sc1tjbGVhbk5hbWVdID0gbmV3IFN5bShjbGVhbk5hbWUsIG9yaWdpbk5vZGUpO1xuICB9O1xuXG4gIC8vIFRIRSBQUk9QRVJUWSBSRUdJU1RSWVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyUHJvcChwcm9wLCBvYmopIHtcbiAgICB2YXIgZGF0YSA9IGN4LnByb3BzW3Byb3BdIHx8IChjeC5wcm9wc1twcm9wXSA9IFtdKTtcbiAgICBkYXRhLnB1c2gob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ianNXaXRoUHJvcChwcm9wKSB7XG4gICAgcmV0dXJuIGN4LnByb3BzW3Byb3BdO1xuICB9XG5cbiAgLy8gSU5GRVJFTkNFIENPTlRFWFRcblxuICBleHBvcnRzLkNvbnRleHQgPSBmdW5jdGlvbihkZWZzLCBwYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnByb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnByb3RvcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5vcmlnaW5zID0gW107XG4gICAgdGhpcy5jdXJPcmlnaW4gPSBcImVjbWFzY3JpcHRcIjtcbiAgICB0aGlzLnBhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmRlZmluaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnB1cmdlR2VuID0gMDtcbiAgICB0aGlzLndvcmtMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmRpc2FibGVkQ29tcHV0aW5nID0gbnVsbDtcbiAgICB0aGlzLmN1clN1cGVyQ3RvciA9IHRoaXMuY3VyU3VwZXIgPSBudWxsO1xuICAgIHRoaXMuc3ltYm9scyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBleHBvcnRzLndpdGhDb250ZXh0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgY3gucHJvdG9zLk9iamVjdCA9IG5ldyBPYmoobnVsbCwgXCJPYmplY3QucHJvdG90eXBlXCIpO1xuICAgICAgY3gudG9wU2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICAgIGN4LnRvcFNjb3BlLm5hbWUgPSBcIjx0b3A+XCI7XG4gICAgICBjeC5wcm90b3MuQXJyYXkgPSBuZXcgT2JqKHRydWUsIFwiQXJyYXkucHJvdG90eXBlXCIpO1xuICAgICAgY3gucHJvdG9zLkZ1bmN0aW9uID0gbmV3IEZuKFwiRnVuY3Rpb24ucHJvdG90eXBlXCIsIEFOdWxsLCBbXSwgW10sIEFOdWxsKTtcbiAgICAgIGN4LnByb3Rvcy5GdW5jdGlvbi5wcm90byA9IGN4LnByb3Rvcy5PYmplY3Q7XG4gICAgICBjeC5wcm90b3MuUmVnRXhwID0gbmV3IE9iaih0cnVlLCBcIlJlZ0V4cC5wcm90b3R5cGVcIik7XG4gICAgICBjeC5wcm90b3MuU3RyaW5nID0gbmV3IE9iaih0cnVlLCBcIlN0cmluZy5wcm90b3R5cGVcIik7XG4gICAgICBjeC5wcm90b3MuTnVtYmVyID0gbmV3IE9iaih0cnVlLCBcIk51bWJlci5wcm90b3R5cGVcIik7XG4gICAgICBjeC5wcm90b3MuQm9vbGVhbiA9IG5ldyBPYmoodHJ1ZSwgXCJCb29sZWFuLnByb3RvdHlwZVwiKTtcbiAgICAgIGN4LnByb3Rvcy5TeW1ib2wgPSBuZXcgT2JqKHRydWUsIFwiU3ltYm9sLnByb3RvdHlwZVwiKTtcbiAgICAgIGN4LnN0ciA9IG5ldyBQcmltKGN4LnByb3Rvcy5TdHJpbmcsIFwic3RyaW5nXCIpO1xuICAgICAgY3guYm9vbCA9IG5ldyBQcmltKGN4LnByb3Rvcy5Cb29sZWFuLCBcImJvb2xcIik7XG4gICAgICBjeC5udW0gPSBuZXcgUHJpbShjeC5wcm90b3MuTnVtYmVyLCBcIm51bWJlclwiKTtcbiAgICAgIGN4LmN1ck9yaWdpbiA9IG51bGw7XG5cbiAgICAgIGlmIChkZWZzKSBmb3IgKHZhciBpID0gMDsgaSA8IGRlZnMubGVuZ3RoOyArK2kpXG4gICAgICAgIGRlZi5sb2FkKGRlZnNbaV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4cG9ydHMuQ29udGV4dC5wcm90b3R5cGUuc3RhcnRBbmFseXNpcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGlzYWJsZWRDb21wdXRpbmcgPSB0aGlzLndvcmtMaXN0ID0gdGhpcy5jdXJTdXBlckN0b3IgPSB0aGlzLmN1clN1cGVyID0gbnVsbDtcbiAgfTtcblxuICB2YXIgY3ggPSBudWxsO1xuICBleHBvcnRzLmN4ID0gZnVuY3Rpb24oKSB7IHJldHVybiBjeDsgfTtcblxuICBleHBvcnRzLndpdGhDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZikge1xuICAgIHZhciBvbGQgPSBjeDtcbiAgICBjeCA9IGNvbnRleHQ7XG4gICAgdHJ5IHsgcmV0dXJuIGYoKTsgfVxuICAgIGZpbmFsbHkgeyBjeCA9IG9sZDsgfVxuICB9O1xuXG4gIGV4cG9ydHMuVGltZWRPdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIlRpbWVkIG91dFwiO1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9O1xuICBleHBvcnRzLlRpbWVkT3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgZXhwb3J0cy5UaW1lZE91dC5wcm90b3R5cGUubmFtZSA9IFwiaW5mZXIuVGltZWRPdXRcIjtcblxuICB2YXIgdGltZW91dDtcbiAgZXhwb3J0cy53aXRoVGltZW91dCA9IGZ1bmN0aW9uKG1zLCBmKSB7XG4gICAgdmFyIGVuZCA9ICtuZXcgRGF0ZSArIG1zO1xuICAgIHZhciBvbGRFbmQgPSB0aW1lb3V0O1xuICAgIGlmIChvbGRFbmQgJiYgb2xkRW5kIDwgZW5kKSByZXR1cm4gZigpO1xuICAgIHRpbWVvdXQgPSBlbmQ7XG4gICAgdHJ5IHsgcmV0dXJuIGYoKTsgfVxuICAgIGZpbmFsbHkgeyB0aW1lb3V0ID0gb2xkRW5kOyB9XG4gIH07XG5cbiAgZXhwb3J0cy5hZGRPcmlnaW4gPSBmdW5jdGlvbihvcmlnaW4pIHtcbiAgICBpZiAoY3gub3JpZ2lucy5pbmRleE9mKG9yaWdpbikgPCAwKSBjeC5vcmlnaW5zLnB1c2gob3JpZ2luKTtcbiAgfTtcblxuICB2YXIgYmFzZU1heFdvcmtEZXB0aCA9IDIwLCByZWR1Y2VNYXhXb3JrRGVwdGggPSAwLjAwMDE7XG4gIGZ1bmN0aW9uIHdpdGhXb3JrbGlzdChmKSB7XG4gICAgaWYgKGN4LndvcmtMaXN0KSByZXR1cm4gZihjeC53b3JrTGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IFtdLCBkZXB0aCA9IDA7XG4gICAgdmFyIGFkZCA9IGN4LndvcmtMaXN0ID0gZnVuY3Rpb24odHlwZSwgdGFyZ2V0LCB3ZWlnaHQpIHtcbiAgICAgIGlmIChkZXB0aCA8IGJhc2VNYXhXb3JrRGVwdGggLSByZWR1Y2VNYXhXb3JrRGVwdGggKiBsaXN0Lmxlbmd0aClcbiAgICAgICAgbGlzdC5wdXNoKHR5cGUsIHRhcmdldCwgd2VpZ2h0LCBkZXB0aCk7XG4gICAgfTtcbiAgICB2YXIgcmV0ID0gZihhZGQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKHRpbWVvdXQgJiYgK25ldyBEYXRlID49IHRpbWVvdXQpXG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlRpbWVkT3V0KCk7XG4gICAgICBkZXB0aCA9IGxpc3RbaSArIDNdICsgMTtcbiAgICAgIGxpc3RbaSArIDFdLmFkZFR5cGUobGlzdFtpXSwgbGlzdFtpICsgMl0pO1xuICAgIH1cbiAgICBjeC53b3JrTGlzdCA9IG51bGw7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTdXBlcihjdG9yLCBvYmosIGYpIHtcbiAgICB2YXIgb2xkQ3RvciA9IGN4LmN1clN1cGVyQ3Rvciwgb2xkT2JqID0gY3guY3VyU3VwZXI7XG4gICAgY3guY3VyU3VwZXJDdG9yID0gY3RvcjsgY3guY3VyU3VwZXIgPSBvYmo7XG4gICAgdmFyIHJlc3VsdCA9IGYoKTtcbiAgICBjeC5jdXJTdXBlckN0b3IgPSBvbGRDdG9yOyBjeC5jdXJTdXBlciA9IG9sZE9iajtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gU0NPUEVTXG5cbiAgdmFyIFNjb3BlID0gZXhwb3J0cy5TY29wZSA9IGZ1bmN0aW9uKHByZXYsIG9yaWdpbk5vZGUsIGlzQmxvY2ssIGlzQ2F0Y2gpIHtcbiAgICBPYmouY2FsbCh0aGlzLCBwcmV2IHx8IHRydWUpO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgdGhpcy5vcmlnaW5Ob2RlID0gb3JpZ2luTm9kZTtcbiAgICB0aGlzLmlzQmxvY2sgPSAhIWlzQmxvY2s7XG4gICAgdGhpcy5pc0NhdGNoID0gISFpc0NhdGNoO1xuICB9O1xuICBTY29wZS5wcm90b3R5cGUgPSBleHRlbmQoT2JqLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBTY29wZSxcbiAgICBkZWZWYXI6IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbk5vZGUpIHtcbiAgICAgIGZvciAodmFyIHMgPSB0aGlzOyA7IHMgPSBzLnByb3RvKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHMucHJvcHNbbmFtZV07XG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgICAgICBpZiAoIXMucHJldikgcmV0dXJuIHMuZGVmUHJvcChuYW1lLCBvcmlnaW5Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uU2NvcGUoc2NvcGUsIGFycm93KSB7XG4gICAgd2hpbGUgKHNjb3BlLmlzQmxvY2sgfHwgc2NvcGUuaXNDYXRjaCB8fCAoYXJyb3cgPT09IGZhbHNlICYmIHNjb3BlLmZuVHlwZSAmJiBzY29wZS5mblR5cGUuaXNBcnJvd0ZuKCkpKVxuICAgICAgc2NvcGUgPSBzY29wZS5wcmV2O1xuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG5cbiAgLy8gUkVUVkFMIENPTVBVVEFUSU9OIEhFVVJJU1RJQ1NcblxuICBmdW5jdGlvbiBtYXliZUluc3RhbnRpYXRlKHNjb3BlLCBzY29yZSkge1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uU2NvcGUoc2NvcGUpLmZuVHlwZTtcbiAgICBpZiAoZm4pIGZuLmluc3RhbnRpYXRlU2NvcmUgPSAoZm4uaW5zdGFudGlhdGVTY29yZSB8fCAwKSArIHNjb3JlO1xuICB9XG5cbiAgdmFyIE5vdFNtYWxsZXIgPSB7fTtcbiAgZnVuY3Rpb24gbm9kZVNtYWxsZXJUaGFuKG5vZGUsIG4pIHtcbiAgICB0cnkge1xuICAgICAgd2Fsay5zaW1wbGUobm9kZSwge0V4cHJlc3Npb246IGZ1bmN0aW9uKCkgeyBpZiAoLS1uIDw9IDApIHRocm93IE5vdFNtYWxsZXI7IH19KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgaWYgKGUgPT0gTm90U21hbGxlcikgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZVRhZ0FzSW5zdGFudGlhdGVkKG5vZGUsIGZuKSB7XG4gICAgdmFyIHNjb3JlID0gZm4uaW5zdGFudGlhdGVTY29yZTtcbiAgICBpZiAoIWN4LmRpc2FibGVkQ29tcHV0aW5nICYmIHNjb3JlICYmIGZuLmFyZ3MubGVuZ3RoICYmIG5vZGVTbWFsbGVyVGhhbihub2RlLCBzY29yZSAqIDUpKSB7XG4gICAgICBtYXliZUluc3RhbnRpYXRlKGZ1bmN0aW9uU2NvcGUoZm4ub3JpZ2luTm9kZS5zY29wZS5wcmV2KSwgc2NvcmUgLyAyKTtcbiAgICAgIHNldEZ1bmN0aW9uSW5zdGFudGlhdGVkKG5vZGUsIGZuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5pbnN0YW50aWF0ZVNjb3JlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGdW5jdGlvbkluc3RhbnRpYXRlZChub2RlLCBmbikge1xuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFyZyBhdmFscywgc28gdGhhdCB3ZSBjYW4gYWRkIGluZm8gdG8gdGhlbSB3aXRob3V0IHNpZGUgZWZmZWN0c1xuICAgIHZhciByZWZTY29wZSA9IG5vZGUuc2NvcGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbi5hcmdzLmxlbmd0aDsgKytpKSBmbi5hcmdzW2ldID0gbmV3IEFWYWw7XG4gICAgZm4uc2VsZiA9IG5ldyBBVmFsO1xuICAgIGZuLmNvbXB1dGVSZXQgPSBmdW5jdGlvbihzZWxmLCBhcmdzKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgcmV0dXJuIHdpdGhEaXNhYmxlZENvbXB1dGluZyhmbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRPcmlnaW4gPSBjeC5jdXJPcmlnaW47XG4gICAgICAgIGN4LmN1ck9yaWdpbiA9IGZuLm9yaWdpbjtcbiAgICAgICAgdmFyIHNjb3BlID0gbm9kZS5zY29wZSA/IG5vZGUuc2NvcGUgOiByZWZTY29wZTtcbiAgICAgICAgdmFyIHNjb3BlQ29weSA9IG5ldyBTY29wZShzY29wZS5wcmV2LCBzY29wZS5vcmlnaW5Ob2RlKTtcbiAgICAgICAgZm9yICh2YXIgdiBpbiBzY29wZS5wcm9wcykge1xuICAgICAgICAgIHZhciBsb2NhbCA9IHNjb3BlQ29weS5kZWZQcm9wKHYsIHNjb3BlLnByb3BzW3ZdLm9yaWdpbk5vZGUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkgaWYgKGZuLmFyZ05hbWVzW2ldID09IHYgJiYgaSA8IGFyZ3MubGVuZ3RoKVxuICAgICAgICAgICAgYXJnc1tpXS5wcm9wYWdhdGUobG9jYWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdOYW1lcyA9IGZuLmFyZ05hbWVzLmxlbmd0aCAhPSBhcmdzLmxlbmd0aCA/IGZuLmFyZ05hbWVzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoKSA6IGZuLmFyZ05hbWVzO1xuICAgICAgICB3aGlsZSAoYXJnTmFtZXMubGVuZ3RoIDwgYXJncy5sZW5ndGgpIGFyZ05hbWVzLnB1c2goXCI/XCIpO1xuICAgICAgICBzY29wZUNvcHkuZm5UeXBlID0gbmV3IEZuKGZuLm5hbWUsIHNlbGYsIGFyZ3MsIGFyZ05hbWVzLCBBTnVsbCwgZm4uZ2VuZXJhdG9yLCBmbi5hc3luYyk7XG4gICAgICAgIHNjb3BlQ29weS5mblR5cGUub3JpZ2luTm9kZSA9IGZuLm9yaWdpbk5vZGU7XG4gICAgICAgIGlmIChmbi5hcmd1bWVudHMpIHtcbiAgICAgICAgICB2YXIgYXJnc2V0ID0gc2NvcGVDb3B5LmZuVHlwZS5hcmd1bWVudHMgPSBuZXcgQVZhbDtcbiAgICAgICAgICBzY29wZUNvcHkuZGVmUHJvcChcImFyZ3VtZW50c1wiKS5hZGRUeXBlKG5ldyBBcnIoYXJnc2V0KSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSBhcmdzW2ldLnByb3BhZ2F0ZShhcmdzZXQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2NvcGUgPSBzY29wZUNvcHk7XG4gICAgICAgIHdhbGsucmVjdXJzaXZlKG5vZGUuYm9keSwgc2NvcGVDb3B5LCBudWxsLCBzY29wZUdhdGhlcmVyKTtcbiAgICAgICAgd2Fsay5yZWN1cnNpdmUobm9kZS5ib2R5LCBzY29wZUNvcHksIG51bGwsIGluZmVyV3JhcHBlcik7XG4gICAgICAgIGN4LmN1ck9yaWdpbiA9IG9sZE9yaWdpbjtcbiAgICAgICAgcmV0dXJuIHNjb3BlQ29weS5mblR5cGUucmV0dmFsO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlVGFnQXNHZW5lcmljKGZuKSB7XG4gICAgdmFyIHRhcmdldCA9IGZuLnJldHZhbDtcbiAgICBpZiAodGFyZ2V0ID09IEFOdWxsIHx8IGZuLmlzQXJyb3dGbigpKSByZXR1cm47XG4gICAgdmFyIHRhcmdldElubmVyLCBhc0FycmF5O1xuICAgIGlmICghdGFyZ2V0LmlzRW1wdHkoKSAmJiAodGFyZ2V0SW5uZXIgPSB0YXJnZXQuZ2V0VHlwZSgpKSBpbnN0YW5jZW9mIEFycilcbiAgICAgIHRhcmdldCA9IGFzQXJyYXkgPSB0YXJnZXRJbm5lci5nZXRQcm9wKFwiPGk+XCIpO1xuXG4gICAgZnVuY3Rpb24gZXhwbG9yZShhdmFsLCBwYXRoLCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID4gMyB8fCAhYXZhbC5mb3J3YXJkKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF2YWwuZm9yd2FyZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJvcCA9IGF2YWwuZm9yd2FyZFtpXS5wcm9wYWdhdGVzVG8oKTtcbiAgICAgICAgaWYgKCFwcm9wKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG5ld1BhdGggPSBwYXRoLCBkZXN0O1xuICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEFWYWwpIHtcbiAgICAgICAgICBkZXN0ID0gcHJvcDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wLnRhcmdldCBpbnN0YW5jZW9mIEFWYWwpIHtcbiAgICAgICAgICBuZXdQYXRoICs9IHByb3AucGF0aEV4dDtcbiAgICAgICAgICBkZXN0ID0gcHJvcC50YXJnZXQ7XG4gICAgICAgIH0gZWxzZSBjb250aW51ZTtcbiAgICAgICAgaWYgKGRlc3QgPT0gdGFyZ2V0KSByZXR1cm4gbmV3UGF0aDtcbiAgICAgICAgdmFyIGZvdW5kID0gZXhwbG9yZShkZXN0LCBuZXdQYXRoLCBkZXB0aCArIDEpO1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZm91bmRQYXRoID0gZXhwbG9yZShmbi5zZWxmLCBcIiF0aGlzXCIsIDApO1xuICAgIGZvciAodmFyIGkgPSAwOyAhZm91bmRQYXRoICYmIGkgPCBmbi5hcmdzLmxlbmd0aDsgKytpKVxuICAgICAgZm91bmRQYXRoID0gZXhwbG9yZShmbi5hcmdzW2ldLCBcIiFcIiArIGksIDApO1xuXG4gICAgaWYgKGZvdW5kUGF0aCkge1xuICAgICAgaWYgKGFzQXJyYXkpIGZvdW5kUGF0aCA9IFwiW1wiICsgZm91bmRQYXRoICsgXCJdXCI7XG4gICAgICB2YXIgcCA9IG5ldyBkZWYuVHlwZVBhcnNlcihmb3VuZFBhdGgpO1xuICAgICAgdmFyIHBhcnNlZCA9IHAucGFyc2VUeXBlKHRydWUpO1xuICAgICAgZm4uY29tcHV0ZVJldCA9IHBhcnNlZC5hcHBseSA/IHBhcnNlZCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VkOyB9O1xuICAgICAgZm4uY29tcHV0ZVJldFNvdXJjZSA9IGZvdW5kUGF0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNDT1BFIEdBVEhFUklORyBQQVNTXG5cbiAgZnVuY3Rpb24gYWRkVmFyKHNjb3BlLCBuYW1lTm9kZSkge1xuICAgIHJldHVybiBzY29wZS5kZWZQcm9wKG5hbWVOb2RlLm5hbWUsIG5hbWVOb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBwYXR0ZXJuTmFtZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PSBcIklkZW50aWZpZXJcIikgcmV0dXJuIG5vZGUubmFtZTtcbiAgICBpZiAobm9kZS50eXBlID09IFwiQXNzaWdubWVudFBhdHRlcm5cIikgcmV0dXJuIHBhdHRlcm5OYW1lKG5vZGUubGVmdCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PSBcIk9iamVjdFBhdHRlcm5cIikgcmV0dXJuIFwie1wiICsgbm9kZS5wcm9wZXJ0aWVzLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBwYXR0ZXJuTmFtZShlLnR5cGUgPT09ICdSZXN0RWxlbWVudCcgPyBlIDogZS52YWx1ZSkgfSkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG4gICAgaWYgKG5vZGUudHlwZSA9PSBcIkFycmF5UGF0dGVyblwiKSByZXR1cm4gXCJbXCIgKyBub2RlLmVsZW1lbnRzLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlID8gcGF0dGVybk5hbWUoZSkgOiBcIlwiIH0pLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICAgIGlmIChub2RlLnR5cGUgPT0gXCJSZXN0RWxlbWVudFwiKSByZXR1cm4gXCIuLi5cIiArIHBhdHRlcm5OYW1lKG5vZGUuYXJndW1lbnQpO1xuICAgIHJldHVybiBcIl9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQmxvY2tTY29wZWREZWNsKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIG5vZGUua2luZCAhPSBcInZhclwiIHx8XG4gICAgICBub2RlLnR5cGUgPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHxcbiAgICAgIG5vZGUudHlwZSA9PSBcIkNsYXNzRGVjbGFyYXRpb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdHRlcm5TY29wZXMoaW5uZXIsIG91dGVyKSB7XG4gICAgcmV0dXJuIHtpbm5lcjogaW5uZXIsIG91dGVyOiBvdXRlciB8fCBpbm5lcn07XG4gIH1cblxuICB2YXIgc2NvcGVHYXRoZXJlciA9IGV4cG9ydHMuc2NvcGVHYXRoZXJlciA9IHdhbGsubWFrZSh7XG4gICAgVmFyaWFibGVQYXR0ZXJuOiBmdW5jdGlvbihub2RlLCBzY29wZXMpIHtcbiAgICAgIGlmIChzY29wZXMuaW5uZXIpIGFkZFZhcihzY29wZXMuaW5uZXIsIG5vZGUpO1xuICAgIH0sXG4gICAgQXNzaWdubWVudFBhdHRlcm46IGZ1bmN0aW9uKG5vZGUsIHNjb3BlcywgYykge1xuICAgICAgYyhub2RlLmxlZnQsIHNjb3BlcywgXCJQYXR0ZXJuXCIpO1xuICAgICAgYyhub2RlLnJpZ2h0LCBzY29wZXMub3V0ZXIsIFwiRXhwcmVzc2lvblwiKTtcbiAgICB9LFxuICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSwgYykge1xuICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgICAgICBjKG5vZGUubGVmdCwgc2NvcGUsIFwiRXhwcmVzc2lvblwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyhub2RlLmxlZnQsIHBhdHRlcm5TY29wZXMoZmFsc2UsIHNjb3BlKSwgXCJQYXR0ZXJuXCIpO1xuICAgICAgYyhub2RlLnJpZ2h0LCBzY29wZSwgXCJFeHByZXNzaW9uXCIpO1xuICAgIH0sXG4gICAgTWVtYmVyUGF0dGVybjogZnVuY3Rpb24obm9kZSwgc2NvcGUsIGMpIHtcbiAgICAgIGMobm9kZSwgc2NvcGUub3V0ZXIpO1xuICAgIH0sXG4gICAgRnVuY3Rpb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBjKSB7XG4gICAgICB2YXIgaW5uZXIgPSBub2RlLnNjb3BlID0gbmV3IFNjb3BlKHNjb3BlLCBub2RlKTtcbiAgICAgIHZhciBhcmdWYWxzID0gW10sIGFyZ05hbWVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IG5vZGUucGFyYW1zW2ldO1xuICAgICAgICBhcmdOYW1lcy5wdXNoKHBhdHRlcm5OYW1lKHBhcmFtKSk7XG4gICAgICAgIGlmIChwYXJhbS50eXBlID09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgYXJnVmFscy5wdXNoKGFkZFZhcihpbm5lciwgcGFyYW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJnID0gbmV3IEFWYWw7XG4gICAgICAgICAgYXJnVmFscy5wdXNoKGFyZyk7XG4gICAgICAgICAgYXJnLm9yaWdpbk5vZGUgPSBwYXJhbTtcbiAgICAgICAgICBjKHBhcmFtLCBwYXR0ZXJuU2NvcGVzKGlubmVyKSwgXCJQYXR0ZXJuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbm5lci5mblR5cGUgPSBuZXcgRm4obm9kZS5pZCAmJiBub2RlLmlkLm5hbWUsIG5ldyBBVmFsLCBhcmdWYWxzLCBhcmdOYW1lcywgQU51bGwsIG5vZGUuZ2VuZXJhdG9yLCBub2RlLmFzeW5jKTtcbiAgICAgIGlubmVyLmZuVHlwZS5vcmlnaW5Ob2RlID0gbm9kZTtcbiAgICAgIGlmIChub2RlLmlkKSB7XG4gICAgICAgIHZhciBkZWNsID0gbm9kZS50eXBlID09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiO1xuICAgICAgICBhZGRWYXIoZGVjbCA/IHNjb3BlIDogaW5uZXIsIG5vZGUuaWQpO1xuICAgICAgfVxuICAgICAgYyhub2RlLmJvZHksIGlubmVyLCBub2RlLmV4cHJlc3Npb24gPyBcIkV4cHJlc3Npb25cIiA6IFwiU3RhdGVtZW50XCIpO1xuICAgIH0sXG4gICAgQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBjKSB7XG4gICAgICBpZiAoIW5vZGUuc2NvcGUgJiYgbm9kZS5ib2R5LnNvbWUoaXNCbG9ja1Njb3BlZERlY2wpKVxuICAgICAgICBzY29wZSA9IG5vZGUuc2NvcGUgPSBuZXcgU2NvcGUoc2NvcGUsIG5vZGUsIHRydWUpO1xuICAgICAgd2Fsay5iYXNlLkJsb2NrU3RhdGVtZW50KG5vZGUsIHNjb3BlLCBjKTtcbiAgICB9LFxuICAgIENhdGNoQ2xhdXNlOiBmdW5jdGlvbihub2RlLCBzY29wZSwgYykge1xuICAgICAgaWYgKCFub2RlLnBhcmFtKSB7IHJldHVybjsgfVxuICAgICAgc2NvcGUgPSBub2RlLnNjb3BlID0gbmV3IFNjb3BlKHNjb3BlLCBub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBpZiAobm9kZS5wYXJhbS50eXBlID09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHZhciB2ID0gYWRkVmFyKHNjb3BlLCBub2RlLnBhcmFtKTtcbiAgICAgICAgYyhub2RlLmJvZHksIHNjb3BlLCBcIlN0YXRlbWVudFwiKTtcbiAgICAgICAgdmFyIGVjbWEgPSBjeC5kZWZpbml0aW9ucy5lY21hc2NyaXB0O1xuICAgICAgICBpZiAoZWNtYSAmJiB2LmlzRW1wdHkoKSkgZ2V0SW5zdGFuY2UoZWNtYVtcIkVycm9yLnByb3RvdHlwZVwiXSkucHJvcGFnYXRlKHYsIFdHX0NBVENIX0VSUk9SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMobm9kZS5wYXJhbSwgcGF0dGVyblNjb3BlcyhzY29wZSksIFwiUGF0dGVyblwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBjKSB7XG4gICAgICB2YXIgdGFyZ2V0U2NvcGUgPSBub2RlLmtpbmQgPT0gXCJ2YXJcIiA/IGZ1bmN0aW9uU2NvcGUoc2NvcGUpIDogc2NvcGU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbnNbaV07XG4gICAgICAgIGMoZGVjbC5pZCwgcGF0dGVyblNjb3Blcyh0YXJnZXRTY29wZSwgc2NvcGUpLCBcIlBhdHRlcm5cIik7XG4gICAgICAgIGlmIChkZWNsLmluaXQpIGMoZGVjbC5pbml0LCBzY29wZSwgXCJFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUsIGMpIHtcbiAgICAgIGlmIChub2RlLmlkKSBhZGRWYXIoc2NvcGUsIG5vZGUuaWQpO1xuICAgICAgaWYgKG5vZGUuc3VwZXJDbGFzcykgYyhub2RlLnN1cGVyQ2xhc3MsIHNjb3BlLCBcIkV4cHJlc3Npb25cIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuYm9keS5ib2R5Lmxlbmd0aDsgaSsrKVxuICAgICAgICBjKG5vZGUuYm9keS5ib2R5W2ldLCBzY29wZSk7XG4gICAgfSxcbiAgICBGb3JJblN0YXRlbWVudDogZnVuY3Rpb24obm9kZSwgc2NvcGUsIGMpIHtcbiAgICAgIGlmICghbm9kZS5zY29wZSAmJiBpc0Jsb2NrU2NvcGVkRGVjbChub2RlLmxlZnQpKVxuICAgICAgICBzY29wZSA9IG5vZGUuc2NvcGUgPSBuZXcgU2NvcGUoc2NvcGUsIG5vZGUsIHRydWUpO1xuICAgICAgd2Fsay5iYXNlLkZvckluU3RhdGVtZW50KG5vZGUsIHNjb3BlLCBjKTtcbiAgICB9LFxuICAgIEZvclN0YXRlbWVudDogZnVuY3Rpb24obm9kZSwgc2NvcGUsIGMpIHtcbiAgICAgIGlmICghbm9kZS5zY29wZSAmJiBub2RlLmluaXQgJiYgaXNCbG9ja1Njb3BlZERlY2wobm9kZS5pbml0KSlcbiAgICAgICAgc2NvcGUgPSBub2RlLnNjb3BlID0gbmV3IFNjb3BlKHNjb3BlLCBub2RlLCB0cnVlKTtcbiAgICAgIHdhbGsuYmFzZS5Gb3JTdGF0ZW1lbnQobm9kZSwgc2NvcGUsIGMpO1xuICAgIH0sXG4gICAgSW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuc3BlY2lmaWVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgYWRkVmFyKHNjb3BlLCBub2RlLnNwZWNpZmllcnNbaV0ubG9jYWwpO1xuICAgIH1cbiAgfSk7XG4gIHNjb3BlR2F0aGVyZXIuRm9yT2ZTdGF0ZW1lbnQgPSBzY29wZUdhdGhlcmVyLkZvckluU3RhdGVtZW50O1xuXG4gIGZ1bmN0aW9uIHJtU2NvcGUobm9kZSkgeyBpZiAobm9kZS5zY29wZSkgbm9kZS5zY29wZSA9IG51bGwgfVxuICB2YXIgc2NvcGVDbGVhcmVyID0ge0Jsb2NrU3RhdGVtZW50OiBybVNjb3BlLCBGdW5jdGlvbjogcm1TY29wZSwgQ2F0Y2hDbGF1c2U6IHJtU2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgRm9ySW5TdGF0ZU1lbnQ6IHJtU2NvcGUsIEZvclN0YXRlbWVudDogcm1TY29wZX07XG4gIGV4cG9ydHMuY2xlYXJTY29wZXMgPSBmdW5jdGlvbihhc3QpIHtcbiAgICB3YWxrLnNpbXBsZShhc3QsIHNjb3BlQ2xlYXJlcik7XG4gIH07XG5cbiAgLy8gQ09OU1RSQUlOVCBHQVRIRVJJTkcgUEFTU1xuXG4gIHZhciBwcm9wTmFtZSA9IGV4cG9ydHMucHJvcE5hbWUgPSBmdW5jdGlvbihub2RlLCBpbmZlckluU2NvcGUpIHtcbiAgICB2YXIga2V5ID0gbm9kZS5wcm9wZXJ0eSB8fCBub2RlLmtleTtcbiAgICBpZiAoIW5vZGUuY29tcHV0ZWQgJiYga2V5LnR5cGUgPT0gXCJJZGVudGlmaWVyXCIpIHJldHVybiBrZXkubmFtZTtcbiAgICBpZiAoa2V5LnR5cGUgPT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5LnZhbHVlID09IFwic3RyaW5nXCIpIHJldHVybiBrZXkudmFsdWU7XG4gICAgICBpZiAodHlwZW9mIGtleS52YWx1ZSA9PSBcIm51bWJlclwiKSByZXR1cm4gU3RyaW5nKGtleS52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpbmZlckluU2NvcGUpIHtcbiAgICAgIHZhciBzeW1OYW1lID0gc3ltYm9sTmFtZShpbmZlcihrZXksIGluZmVySW5TY29wZSkpO1xuICAgICAgaWYgKHN5bU5hbWUpIHJldHVybiBub2RlLnByb3BOYW1lID0gc3ltTmFtZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUucHJvcE5hbWUpIHtcbiAgICAgIHJldHVybiBub2RlLnByb3BOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gXCI8aT5cIjtcbiAgfTtcbiAgZnVuY3Rpb24gc3ltYm9sTmFtZSh2YWwpIHtcbiAgICB2YXIgc3ltID0gdmFsLmdldFN5bWJvbFR5cGUoKTtcbiAgICBpZiAoc3ltKSByZXR1cm4gc3ltLmFzUHJvcE5hbWUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVub3BSZXN1bHRUeXBlKG9wKSB7XG4gICAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgXCIrXCI6IGNhc2UgXCItXCI6IGNhc2UgXCJ+XCI6IHJldHVybiBjeC5udW07XG4gICAgY2FzZSBcIiFcIjogcmV0dXJuIGN4LmJvb2w7XG4gICAgY2FzZSBcInR5cGVvZlwiOiByZXR1cm4gY3guc3RyO1xuICAgIGNhc2UgXCJ2b2lkXCI6IGNhc2UgXCJkZWxldGVcIjogcmV0dXJuIEFOdWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5vcElzQm9vbGVhbihvcCkge1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlIFwiPT1cIjogY2FzZSBcIiE9XCI6IGNhc2UgXCI9PT1cIjogY2FzZSBcIiE9PVwiOiBjYXNlIFwiPFwiOiBjYXNlIFwiPlwiOiBjYXNlIFwiPj1cIjogY2FzZSBcIjw9XCI6XG4gICAgY2FzZSBcImluXCI6IGNhc2UgXCJpbnN0YW5jZW9mXCI6IHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaXRlcmFsVHlwZShub2RlKSB7XG4gICAgaWYgKG5vZGUucmVnZXgpIHJldHVybiBnZXRJbnN0YW5jZShjeC5wcm90b3MuUmVnRXhwKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBub2RlLnZhbHVlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIGN4LmJvb2w7XG4gICAgY2FzZSBcIm51bWJlclwiOiByZXR1cm4gY3gubnVtO1xuICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGN4LnN0cjtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICBpZiAoIW5vZGUudmFsdWUpIHJldHVybiBBTnVsbDtcbiAgICAgIHJldHVybiBnZXRJbnN0YW5jZShjeC5wcm90b3MuUmVnRXhwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiIHx8IGIgPT0gQU51bGwpIHJldHVybiBhO1xuICAgIGlmIChhID09IEFOdWxsKSByZXR1cm4gYjtcbiAgICB2YXIgam9pbmVkID0gbmV3IEFWYWw7XG4gICAgYS5wcm9wYWdhdGUoam9pbmVkKTtcbiAgICBiLnByb3BhZ2F0ZShqb2luZWQpO1xuICAgIHJldHVybiBqb2luZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25uZWN0UGFyYW1zKG5vZGUsIHNjb3BlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmFtID0gbm9kZS5wYXJhbXNbaV07XG4gICAgICBpZiAocGFyYW0udHlwZSA9PSBcIklkZW50aWZpZXJcIikgY29udGludWU7XG4gICAgICBjb25uZWN0UGF0dGVybihwYXJhbSwgc2NvcGUsIG5vZGUuc2NvcGUuZm5UeXBlLmFyZ3NbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVZhcihub2RlLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS5oYXNQcm9wKG5vZGUubmFtZSkgfHwgY3gudG9wU2NvcGUuZGVmUHJvcChub2RlLm5hbWUsIG5vZGUpO1xuICB9XG5cbiAgdmFyIGluZmVyUGF0dGVyblZpc2l0b3IgPSBleHBvcnRzLmluZmVyUGF0dGVyblZpc2l0b3IgPSB7XG4gICAgSWRlbnRpZmllcjogZnVuY3Rpb24obm9kZSwgc2NvcGUsIHNvdXJjZSkge1xuICAgICAgc291cmNlLnByb3BhZ2F0ZShlbnN1cmVWYXIobm9kZSwgc2NvcGUpKTtcbiAgICB9LFxuICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBzb3VyY2UpIHtcbiAgICAgIHZhciBvYmogPSBpbmZlcihub2RlLm9iamVjdCwgc2NvcGUpO1xuICAgICAgdmFyIHBOYW1lID0gcHJvcE5hbWUobm9kZSwgc2NvcGUpO1xuICAgICAgb2JqLnByb3BhZ2F0ZShuZXcgRGVmUHJvcChwTmFtZSwgc291cmNlLCBub2RlLnByb3BlcnR5KSk7XG4gICAgfSxcbiAgICBSZXN0RWxlbWVudDogZnVuY3Rpb24obm9kZSwgc2NvcGUsIHNvdXJjZSkge1xuICAgICAgY29ubmVjdFBhdHRlcm4obm9kZS5hcmd1bWVudCwgc2NvcGUsIG5ldyBBcnIoc291cmNlKSk7XG4gICAgfSxcbiAgICBPYmplY3RQYXR0ZXJuOiBmdW5jdGlvbihub2RlLCBzY29wZSwgc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PSAnUmVzdEVsZW1lbnQnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGNvbm5lY3RQYXR0ZXJuKHByb3AudmFsdWUsIHNjb3BlLCBzb3VyY2UuZ2V0UHJvcChwcm9wTmFtZShwcm9wKSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbihub2RlLCBzY29wZSwgc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWxlbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChub2RlLmVsZW1lbnRzW2ldKVxuICAgICAgICAgIGNvbm5lY3RQYXR0ZXJuKG5vZGUuZWxlbWVudHNbaV0sIHNjb3BlLCBzb3VyY2UuZ2V0UHJvcChTdHJpbmcoaSkpKTtcbiAgICB9LFxuICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbihub2RlLCBzY29wZSwgc291cmNlKSB7XG4gICAgICBjb25uZWN0UGF0dGVybihub2RlLmxlZnQsIHNjb3BlLCBqb2luKHNvdXJjZSwgaW5mZXIobm9kZS5yaWdodCwgc2NvcGUpKSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbm5lY3RQYXR0ZXJuKG5vZGUsIHNjb3BlLCBzb3VyY2UpIHtcbiAgICB2YXIgY29ubmVjdGVyID0gaW5mZXJQYXR0ZXJuVmlzaXRvcltub2RlLnR5cGVdO1xuICAgIGlmIChjb25uZWN0ZXIpIGNvbm5lY3Rlcihub2RlLCBzY29wZSwgc291cmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRoaXMoc2NvcGUpIHtcbiAgICB2YXIgZm5TY29wZSA9IGZ1bmN0aW9uU2NvcGUoc2NvcGUpO1xuICAgIHJldHVybiBmblNjb3BlLmZuVHlwZSA/IGZuU2NvcGUuZm5UeXBlLnNlbGYgOiBmblNjb3BlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVBZGRQaGFudG9tT2JqKG9iaikge1xuICAgIGlmICghb2JqLmlzRW1wdHkoKSB8fCAhb2JqLnByb3BlcnR5T2YpIHJldHVybjtcbiAgICBvYmoucHJvcGVydHlPZi5nZXRQcm9wKG9iai5wcm9wZXJ0eU5hbWUpLmFkZFR5cGUobmV3IE9iaiwgV0dfUEhBTlRPTV9PQkopO1xuICAgIG1heWJlQWRkUGhhbnRvbU9iaihvYmoucHJvcGVydHlPZik7XG4gIH1cblxuICBmdW5jdGlvbiBpbmZlckNsYXNzKG5vZGUsIHNjb3BlLCBuYW1lKSB7XG4gICAgaWYgKCFuYW1lICYmIG5vZGUuaWQpIG5hbWUgPSBub2RlLmlkLm5hbWU7XG5cbiAgICB2YXIgc3VwID0gY3gucHJvdG9zLk9iamVjdCwgc3VwQ3RvciwgZGVsYXllZDtcbiAgICBpZiAobm9kZS5zdXBlckNsYXNzKSB7XG4gICAgICBpZiAobm9kZS5zdXBlckNsYXNzLnR5cGUgPT0gXCJMaXRlcmFsXCIgJiYgbm9kZS5zdXBlckNsYXNzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgc3VwID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdXBWYWwgPSBpbmZlcihub2RlLnN1cGVyQ2xhc3MsIHNjb3BlKSwgc3VwUHJvdG87XG4gICAgICAgIHN1cEN0b3IgPSBzdXBWYWwuZ2V0RnVuY3Rpb25UeXBlKCk7XG4gICAgICAgIGlmIChzdXBDdG9yICYmIChzdXBQcm90byA9IHN1cEN0b3IuZ2V0UHJvcChcInByb3RvdHlwZVwiKS5nZXRPYmpUeXBlKCkpKSB7XG4gICAgICAgICAgc3VwID0gc3VwUHJvdG87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwQ3RvciA9IHN1cFZhbDtcbiAgICAgICAgICBkZWxheWVkID0gc3VwVmFsLmdldFByb3AoXCJwcm90b3R5cGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHByb3RvID0gbmV3IE9iaihzdXAsIG5hbWUgJiYgbmFtZSArIFwiLnByb3RvdHlwZVwiKTtcbiAgICBpZiAoZGVsYXllZCkgZGVsYXllZC5wcm9wYWdhdGUobmV3IEhhc1Byb3RvKHByb3RvKSk7XG5cbiAgICByZXR1cm4gd2l0aFN1cGVyKHN1cEN0b3IsIGRlbGF5ZWQgfHwgc3VwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdG9yLCBib2R5ID0gbm9kZS5ib2R5LmJvZHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChib2R5W2ldLmtpbmQgPT0gXCJjb25zdHJ1Y3RvclwiKSBjdG9yID0gYm9keVtpXS52YWx1ZTtcbiAgICAgIHZhciBmbiA9IG5vZGUub2JqVHlwZSA9IGN0b3IgPyBpbmZlcihjdG9yLCBzY29wZSkgOiBuZXcgRm4obmFtZSwgQU51bGwsIFtdLCBudWxsLCBBTnVsbCk7XG4gICAgICBmbi5vcmlnaW5Ob2RlID0gbm9kZS5pZCB8fCBjdG9yIHx8IG5vZGU7XG5cbiAgICAgIHZhciBpbnN0ID0gZ2V0SW5zdGFuY2UocHJvdG8sIGZuKTtcbiAgICAgIGZuLnNlbGYuYWRkVHlwZShpbnN0KTtcbiAgICAgIGZuLmRlZlByb3AoXCJwcm90b3R5cGVcIiwgbm9kZSkuYWRkVHlwZShwcm90byk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGJvZHlbaV0sIHRhcmdldDtcbiAgICAgICAgaWYgKG1ldGhvZC5raW5kID09IFwiY29uc3RydWN0b3JcIikgY29udGludWU7XG4gICAgICAgIHZhciBwTmFtZSA9IHByb3BOYW1lKG1ldGhvZCwgc2NvcGUpO1xuICAgICAgICBpZiAocE5hbWUgPT0gXCI8aT5cIiB8fCBtZXRob2Qua2luZCA9PSBcInNldFwiKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gQU51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gKG1ldGhvZC5zdGF0aWMgPyBmbiA6IHByb3RvKS5kZWZQcm9wKHBOYW1lLCBtZXRob2Qua2V5KTtcbiAgICAgICAgICB0YXJnZXQuaW5pdGlhbGl6ZXIgPSB0cnVlO1xuICAgICAgICAgIGlmIChtZXRob2Qua2luZCA9PSBcImdldFwiKSB0YXJnZXQgPSBuZXcgSXNDYWxsZWUoaW5zdCwgW10sIG51bGwsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mZXIobWV0aG9kLnZhbHVlLCBzY29wZSwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG1ldGhvZEZuID0gdGFyZ2V0LmdldEZ1bmN0aW9uVHlwZSgpO1xuICAgICAgICBpZiAobWV0aG9kRm4pIG1ldGhvZEZuLnNlbGYuYWRkVHlwZShpbnN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbjtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5TGl0ZXJhbFR5cGUoZWxlbWVudHMsIHNjb3BlLCBpbm5lcikge1xuICAgIHZhciB0dXBsZSA9IGVsZW1lbnRzLmxlbmd0aCA+IDEgJiYgZWxlbWVudHMubGVuZ3RoIDwgNjtcbiAgICBpZiAodHVwbGUpIHtcbiAgICAgIHZhciBob21vZ2Vub3VzID0gdHJ1ZSwgbGl0VHlwZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsdCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICB0dXBsZSA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChlbHQudHlwZSAhPSBcIkxpdGVyYWxcIiB8fCAobGl0VHlwZSAmJiBsaXRUeXBlICE9IHR5cGVvZiBlbHQudmFsdWUpKVxuICAgICAgICAgIGhvbW9nZW5vdXMgPSBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpdFR5cGUgPSB0eXBlb2YgZWx0LnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGhvbW9nZW5vdXMpIHR1cGxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR1cGxlKSB7XG4gICAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2goaW5uZXIoZWxlbWVudHNbaV0sIHNjb3BlKSk7XG4gICAgICByZXR1cm4gbmV3IEFycih0eXBlcyk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbmV3IEFycihlbGVtZW50c1swXSAmJiBpbm5lcihlbGVtZW50c1swXSwgc2NvcGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsdFZhbCA9IG5ldyBBVmFsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldKSBpbm5lcihlbGVtZW50c1tpXSwgc2NvcGUpLnByb3BhZ2F0ZShlbHRWYWwpO1xuICAgICAgcmV0dXJuIG5ldyBBcnIoZWx0VmFsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXQoZikge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBzY29wZSwgb3V0LCBuYW1lKSB7XG4gICAgICB2YXIgciA9IGYobm9kZSwgc2NvcGUsIG5hbWUpO1xuICAgICAgaWYgKG91dCkgci5wcm9wYWdhdGUob3V0KTtcbiAgICAgIHJldHVybiByO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmlsbChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBvdXQsIG5hbWUpIHtcbiAgICAgIGlmICghb3V0KSBvdXQgPSBuZXcgQVZhbDtcbiAgICAgIGYobm9kZSwgc2NvcGUsIG91dCwgbmFtZSk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5mZXJFeHByVmlzaXRvciA9IGV4cG9ydHMuaW5mZXJFeHByVmlzaXRvciA9IHtcbiAgICBBcnJheUV4cHJlc3Npb246IHJldChmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGFycmF5TGl0ZXJhbFR5cGUobm9kZS5lbGVtZW50cywgc2NvcGUsIGluZmVyKTtcbiAgICB9KSxcbiAgICBPYmplY3RFeHByZXNzaW9uOiByZXQoZnVuY3Rpb24obm9kZSwgc2NvcGUsIG5hbWUpIHtcbiAgICAgIHZhciBwcm90byA9IGN4LnByb3Rvcy5PYmplY3QsIHdhaXRGb3JQcm90bztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAocHJvcC50eXBlID09ICdTcHJlYWRFbGVtZW50JykgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAocHJvcC5rZXkubmFtZSA9PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgaWYgKHByb3AudmFsdWUudHlwZSA9PSBcIkxpdGVyYWxcIiAmJiBwcm9wLnZhbHVlLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3RvVmFsID0gaW5mZXIocHJvcC52YWx1ZSwgc2NvcGUpLCBrbm93biA9IHByb3RvVmFsLmdldE9ialR5cGUoKTtcbiAgICAgICAgICAgIGlmIChrbm93bikgcHJvdG8gPSBrbm93bjtcbiAgICAgICAgICAgIGVsc2Ugd2FpdEZvclByb3RvID0gcHJvdG9WYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmogPSBub2RlLm9ialR5cGUgPSBuZXcgT2JqKHByb3RvLCBuYW1lKTtcbiAgICAgIGlmICh3YWl0Rm9yUHJvdG8pIHdhaXRGb3JQcm90by5wcm9wYWdhdGUobmV3IEhhc1Byb3RvKG9iaikpO1xuICAgICAgb2JqLm9yaWdpbk5vZGUgPSBub2RlO1xuXG4gICAgICB3aXRoU3VwZXIobnVsbCwgd2FpdEZvclByb3RvIHx8IHByb3RvLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXSwga2V5ID0gcHJvcC5rZXk7XG4gICAgICAgICAgaWYgKHByb3AudHlwZSA9PSAnU3ByZWFkRWxlbWVudCcgfHwgaWdub3JlZFByb3AocHJvcC5rZXkubmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wTmFtZShwcm9wLCBzY29wZSksIHRhcmdldDtcbiAgICAgICAgICBpZiAobmFtZSA9PSBcIjxpPlwiIHx8IHByb3Aua2luZCA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBBTnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gb2JqLmRlZlByb3AobmFtZSwga2V5KTtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0YXJnZXQ7XG4gICAgICAgICAgICB2YWwuaW5pdGlhbGl6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb3Aua2luZCA9PSBcImdldFwiKVxuICAgICAgICAgICAgICB0YXJnZXQgPSBuZXcgSXNDYWxsZWUob2JqLCBbXSwgbnVsbCwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5mZXIocHJvcC52YWx1ZSwgc2NvcGUsIHRhcmdldCwgbmFtZSk7XG4gICAgICAgICAgaWYgKHByb3AudmFsdWUudHlwZSA9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICAgICAgICAgICAgcHJvcC52YWx1ZS5zY29wZS5mblR5cGUuc2VsZi5hZGRUeXBlKG9iaiwgV0dfU1BFQ1VMQVRJVkVfVEhJUyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KSxcbiAgICBGdW5jdGlvbkV4cHJlc3Npb246IHJldChmdW5jdGlvbihub2RlLCBzY29wZSwgbmFtZSkge1xuICAgICAgdmFyIGlubmVyID0gbm9kZS5zY29wZSwgZm4gPSBpbm5lci5mblR5cGU7XG4gICAgICBpZiAobmFtZSAmJiAhZm4ubmFtZSkgZm4ubmFtZSA9IG5hbWU7XG4gICAgICBjb25uZWN0UGFyYW1zKG5vZGUsIGlubmVyKTtcbiAgICAgIGlmIChub2RlLmV4cHJlc3Npb24pXG4gICAgICAgIGluZmVyKG5vZGUuYm9keSwgaW5uZXIsIGlubmVyLmZuVHlwZS5yZXR2YWwgPSBuZXcgQVZhbCk7XG4gICAgICBlbHNlXG4gICAgICAgIHdhbGsucmVjdXJzaXZlKG5vZGUuYm9keSwgaW5uZXIsIG51bGwsIGluZmVyV3JhcHBlciwgXCJTdGF0ZW1lbnRcIik7XG4gICAgICBpZiAobm9kZS50eXBlID09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgICAgICAgZ2V0VGhpcyhzY29wZSkucHJvcGFnYXRlKGZuLnNlbGYpO1xuICAgICAgbWF5YmVUYWdBc0luc3RhbnRpYXRlZChub2RlLCBmbikgfHwgbWF5YmVUYWdBc0dlbmVyaWMoZm4pO1xuICAgICAgaWYgKG5vZGUuaWQpIGlubmVyLmdldFByb3Aobm9kZS5pZC5uYW1lKS5hZGRUeXBlKGZuKTtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9KSxcbiAgICBDbGFzc0V4cHJlc3Npb246IHJldChpbmZlckNsYXNzKSxcbiAgICBTZXF1ZW5jZUV4cHJlc3Npb246IHJldChmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDE7IGkgPCBsOyArK2kpXG4gICAgICAgIGluZmVyKG5vZGUuZXhwcmVzc2lvbnNbaV0sIHNjb3BlLCBBTnVsbCk7XG4gICAgICByZXR1cm4gaW5mZXIobm9kZS5leHByZXNzaW9uc1tsXSwgc2NvcGUpO1xuICAgIH0pLFxuICAgIFVuYXJ5RXhwcmVzc2lvbjogcmV0KGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICBpbmZlcihub2RlLmFyZ3VtZW50LCBzY29wZSwgQU51bGwpO1xuICAgICAgcmV0dXJuIHVub3BSZXN1bHRUeXBlKG5vZGUub3BlcmF0b3IpO1xuICAgIH0pLFxuICAgIFVwZGF0ZUV4cHJlc3Npb246IHJldChmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgaW5mZXIobm9kZS5hcmd1bWVudCwgc2NvcGUsIEFOdWxsKTtcbiAgICAgIHJldHVybiBjeC5udW07XG4gICAgfSksXG4gICAgQmluYXJ5RXhwcmVzc2lvbjogcmV0KGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICBpZiAobm9kZS5vcGVyYXRvciA9PSBcIitcIikge1xuICAgICAgICB2YXIgbGhzID0gaW5mZXIobm9kZS5sZWZ0LCBzY29wZSk7XG4gICAgICAgIHZhciByaHMgPSBpbmZlcihub2RlLnJpZ2h0LCBzY29wZSk7XG4gICAgICAgIGlmIChsaHMuaGFzVHlwZShjeC5zdHIpIHx8IHJocy5oYXNUeXBlKGN4LnN0cikpIHJldHVybiBjeC5zdHI7XG4gICAgICAgIGlmIChsaHMuaGFzVHlwZShjeC5udW0pICYmIHJocy5oYXNUeXBlKGN4Lm51bSkpIHJldHVybiBjeC5udW07XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQVZhbDtcbiAgICAgICAgbGhzLnByb3BhZ2F0ZShuZXcgSXNBZGRlZChyaHMsIHJlc3VsdCkpO1xuICAgICAgICByaHMucHJvcGFnYXRlKG5ldyBJc0FkZGVkKGxocywgcmVzdWx0KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZlcihub2RlLmxlZnQsIHNjb3BlLCBBTnVsbCk7XG4gICAgICAgIGluZmVyKG5vZGUucmlnaHQsIHNjb3BlLCBBTnVsbCk7XG4gICAgICAgIHJldHVybiBiaW5vcElzQm9vbGVhbihub2RlLm9wZXJhdG9yKSA/IGN4LmJvb2wgOiBjeC5udW07XG4gICAgICB9XG4gICAgfSksXG4gICAgQXNzaWdubWVudEV4cHJlc3Npb246IHJldChmdW5jdGlvbihub2RlLCBzY29wZSwgbmFtZSkge1xuICAgICAgdmFyIHJocywgcE5hbWU7XG4gICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcE5hbWUgPSBwcm9wTmFtZShub2RlLmxlZnQsIHNjb3BlKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgIG5hbWUgPSBub2RlLmxlZnQub2JqZWN0LnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgPyBub2RlLmxlZnQub2JqZWN0Lm5hbWUgKyBcIi5cIiArIHBOYW1lIDogcE5hbWU7XG4gICAgICB9IGVsc2UgaWYgKCFuYW1lICYmIG5vZGUubGVmdC50eXBlID09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIG5hbWUgPSBub2RlLmxlZnQubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgJiYgbm9kZS5vcGVyYXRvciAhPSBcIj1cIiAmJiBub2RlLm9wZXJhdG9yICE9IFwiKz1cIikge1xuICAgICAgICBpbmZlcihub2RlLnJpZ2h0LCBzY29wZSwgQU51bGwpO1xuICAgICAgICByaHMgPSBjeC5udW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaHMgPSBpbmZlcihub2RlLnJpZ2h0LCBzY29wZSwgbnVsbCwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmxlZnQudHlwZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICB2YXIgb2JqID0gaW5mZXIobm9kZS5sZWZ0Lm9iamVjdCwgc2NvcGUpO1xuICAgICAgICBpZiAocE5hbWUgPT0gXCJwcm90b3R5cGVcIikgbWF5YmVJbnN0YW50aWF0ZShzY29wZSwgMjApO1xuICAgICAgICBpZiAocE5hbWUgPT0gXCI8aT5cIikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIHJlY29nbml6ZSBmb3IvaW4gbG9vcHMgdGhhdCBjb3B5XG4gICAgICAgICAgLy8gcHJvcGVydGllcywgYW5kIGRvIHRoZSBjb3B5aW5nIG91cnNlbHZlcywgaW5zb2ZhciBhcyB3ZVxuICAgICAgICAgIC8vIG1hbmFnZSwgYmVjYXVzZSBzdWNoIGxvb3BzIHRlbmQgdG8gYmUgcmVsZXZhbnQgZm9yIHR5cGVcbiAgICAgICAgICAvLyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICB2YXIgdiA9IG5vZGUubGVmdC5wcm9wZXJ0eS5uYW1lLCBsb2NhbCA9IHNjb3BlLnByb3BzW3ZdLCBvdmVyID0gbG9jYWwgJiYgbG9jYWwuaXRlcmF0ZXNPdmVyO1xuICAgICAgICAgIGlmIChvdmVyKSB7XG4gICAgICAgICAgICBtYXliZUluc3RhbnRpYXRlKHNjb3BlLCAyMCk7XG4gICAgICAgICAgICB2YXIgZnJvbVJpZ2h0ID0gbm9kZS5yaWdodC50eXBlID09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIG5vZGUucmlnaHQuY29tcHV0ZWQgJiYgbm9kZS5yaWdodC5wcm9wZXJ0eS5uYW1lID09IHY7XG4gICAgICAgICAgICBvdmVyLmZvckFsbFByb3BzKGZ1bmN0aW9uKHByb3AsIHZhbCwgbG9jYWwpIHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsICYmIHByb3AgIT0gXCJwcm90b3R5cGVcIiAmJiBwcm9wICE9IFwiPGk+XCIpXG4gICAgICAgICAgICAgICAgb2JqLnByb3BhZ2F0ZShuZXcgRGVmUHJvcChwcm9wLCBmcm9tUmlnaHQgPyB2YWwgOiBBTnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5wcm9wYWdhdGUobmV3IERlZlByb3AocE5hbWUsIHJocywgbm9kZS5sZWZ0LnByb3BlcnR5KSk7XG4gICAgICAgIG1heWJlQWRkUGhhbnRvbU9iaihvYmopO1xuICAgICAgICBpZiAobm9kZS5yaWdodC50eXBlID09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gICAgICAgICAgb2JqLnByb3BhZ2F0ZShub2RlLnJpZ2h0LnNjb3BlLmZuVHlwZS5zZWxmLCBXR19TUEVDVUxBVElWRV9USElTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3RQYXR0ZXJuKG5vZGUubGVmdCwgc2NvcGUsIHJocyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmhzO1xuICAgIH0pLFxuICAgIExvZ2ljYWxFeHByZXNzaW9uOiBmaWxsKGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBvdXQpIHtcbiAgICAgIGluZmVyKG5vZGUubGVmdCwgc2NvcGUsIG91dCk7XG4gICAgICBpbmZlcihub2RlLnJpZ2h0LCBzY29wZSwgb3V0KTtcbiAgICB9KSxcbiAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IGZpbGwoZnVuY3Rpb24obm9kZSwgc2NvcGUsIG91dCkge1xuICAgICAgaW5mZXIobm9kZS50ZXN0LCBzY29wZSwgQU51bGwpO1xuICAgICAgaW5mZXIobm9kZS5jb25zZXF1ZW50LCBzY29wZSwgb3V0KTtcbiAgICAgIGluZmVyKG5vZGUuYWx0ZXJuYXRlLCBzY29wZSwgb3V0KTtcbiAgICB9KSxcbiAgICBOZXdFeHByZXNzaW9uOiBmaWxsKGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBvdXQsIG5hbWUpIHtcbiAgICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09IFwiSWRlbnRpZmllclwiICYmIG5vZGUuY2FsbGVlLm5hbWUgaW4gc2NvcGUucHJvcHMpXG4gICAgICAgIG1heWJlSW5zdGFudGlhdGUoc2NvcGUsIDIwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGFyZ3MgPSBbXTsgaSA8IG5vZGUuYXJndW1lbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICBhcmdzLnB1c2goaW5mZXIobm9kZS5hcmd1bWVudHNbaV0sIHNjb3BlKSk7XG4gICAgICB2YXIgY2FsbGVlID0gaW5mZXIobm9kZS5jYWxsZWUsIHNjb3BlKTtcbiAgICAgIHZhciBzZWxmID0gbmV3IEFWYWw7XG4gICAgICBjYWxsZWUucHJvcGFnYXRlKG5ldyBJc0N0b3Ioc2VsZiwgbmFtZSAmJiAvXFwucHJvdG90eXBlJC8udGVzdChuYW1lKSkpO1xuICAgICAgc2VsZi5wcm9wYWdhdGUob3V0LCBXR19ORVdfSU5TVEFOQ0UpO1xuICAgICAgY2FsbGVlLnByb3BhZ2F0ZShuZXcgSXNDYWxsZWUoc2VsZiwgYXJncywgbm9kZS5hcmd1bWVudHMsIG5ldyBJZk9iaihvdXQpKSk7XG4gICAgfSksXG4gICAgQ2FsbEV4cHJlc3Npb246IGZpbGwoZnVuY3Rpb24obm9kZSwgc2NvcGUsIG91dCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFyZ3MgPSBbXTsgaSA8IG5vZGUuYXJndW1lbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICBhcmdzLnB1c2goaW5mZXIobm9kZS5hcmd1bWVudHNbaV0sIHNjb3BlKSk7XG4gICAgICB2YXIgb3V0ZXJGbiA9IGZ1bmN0aW9uU2NvcGUoc2NvcGUpLmZuVHlwZTtcbiAgICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHZhciBzZWxmID0gaW5mZXIobm9kZS5jYWxsZWUub2JqZWN0LCBzY29wZSk7XG4gICAgICAgIHZhciBwTmFtZSA9IHByb3BOYW1lKG5vZGUuY2FsbGVlLCBzY29wZSk7XG4gICAgICAgIGlmIChvdXRlckZuICYmIChwTmFtZSA9PSBcImNhbGxcIiB8fCBwTmFtZSA9PSBcImFwcGx5XCIpICYmXG4gICAgICAgICAgICBvdXRlckZuLmFyZ3MuaW5kZXhPZihzZWxmKSA+IC0xKVxuICAgICAgICAgIG1heWJlSW5zdGFudGlhdGUoc2NvcGUsIDMwKTtcbiAgICAgICAgc2VsZi5wcm9wYWdhdGUobmV3IEhhc01ldGhvZENhbGwocE5hbWUsIGFyZ3MsIG5vZGUuYXJndW1lbnRzLCBvdXQpKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jYWxsZWUudHlwZSA9PSBcIlN1cGVyXCIgJiYgY3guY3VyU3VwZXJDdG9yKSB7XG4gICAgICAgIG5vZGUuY2FsbGVlLnN1cGVyVHlwZSA9IGN4LmN1clN1cGVyQ3RvcjtcbiAgICAgICAgY3guY3VyU3VwZXJDdG9yLnByb3BhZ2F0ZShuZXcgSXNDYWxsZWUoZ2V0VGhpcyhzY29wZSksIGFyZ3MsIG5vZGUuYXJndW1lbnRzLCBvdXQpKTtcbiAgICAgICAgZ2V0VGhpcyhzY29wZSkucHJvcGFnYXRlKG91dCwgV0dfTkVXX0lOU1RBTkNFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjYWxsZWUgPSBpbmZlcihub2RlLmNhbGxlZSwgc2NvcGUpO1xuICAgICAgICBpZiAob3V0ZXJGbiAmJiBvdXRlckZuLmFyZ3MuaW5kZXhPZihjYWxsZWUpID4gLTEpXG4gICAgICAgICAgbWF5YmVJbnN0YW50aWF0ZShzY29wZSwgMzApO1xuICAgICAgICB2YXIga25vd25GbiA9IGNhbGxlZS5nZXRGdW5jdGlvblR5cGUoKTtcbiAgICAgICAgaWYgKGtub3duRm4gJiYga25vd25Gbi5pbnN0YW50aWF0ZVNjb3JlICYmIG91dGVyRm4pXG4gICAgICAgICAgbWF5YmVJbnN0YW50aWF0ZShzY29wZSwga25vd25Gbi5pbnN0YW50aWF0ZVNjb3JlIC8gNSk7XG4gICAgICAgIGNhbGxlZS5wcm9wYWdhdGUobmV3IElzQ2FsbGVlKGN4LnRvcFNjb3BlLCBhcmdzLCBub2RlLmFyZ3VtZW50cywgb3V0KSk7XG4gICAgICB9XG4gICAgfSksXG4gICAgQXdhaXRFeHByZXNzaW9uOiBmaWxsKGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBvdXQsIG5hbWUpIHtcbiAgICAgIHZhciBhcmcgPSBpbmZlcihub2RlLmFyZ3VtZW50LCBzY29wZSwgbnVsbCwgbmFtZSk7XG4gICAgICB2YXIgdHAgPSBhcmcuZ2V0VHlwZSgpO1xuICAgICAgaWYgKHRwICYmIHRwLmNvbnN0cnVjdG9yID09IE9iaiAmJiB0cC5uYW1lID09IFwiUHJvbWlzZVwiKSB7XG4gICAgICAgIGlmICh0cC5oYXNQcm9wKFwiOnRcIikpIHtcbiAgICAgICAgICB0cC5nZXRQcm9wKFwiOnRcIikucHJvcGFnYXRlKG91dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZy5wcm9wYWdhdGUob3V0KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBNZW1iZXJFeHByZXNzaW9uOiBmaWxsKGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBvdXQpIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcE5hbWUobm9kZSksIHdnO1xuICAgICAgaWYgKG5hbWUgPT0gXCI8aT5cIikge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBpbmZlcihub2RlLnByb3BlcnR5LCBzY29wZSk7XG4gICAgICAgIHZhciBzeW1OYW1lID0gc3ltYm9sTmFtZShwcm9wVHlwZSk7XG4gICAgICAgIGlmIChzeW1OYW1lKVxuICAgICAgICAgIG5hbWUgPSBub2RlLnByb3BOYW1lID0gc3ltTmFtZTtcbiAgICAgICAgZWxzZSBpZiAoIXByb3BUeXBlLmhhc1R5cGUoY3gubnVtKSlcbiAgICAgICAgICB3ZyA9IFdHX01VTFRJX01FTUJFUjtcbiAgICAgIH1cbiAgICAgIGluZmVyKG5vZGUub2JqZWN0LCBzY29wZSkuZ2V0UHJvcChuYW1lKS5wcm9wYWdhdGUob3V0LCB3Zyk7XG4gICAgfSksXG4gICAgSWRlbnRpZmllcjogcmV0KGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICBpZiAobm9kZS5uYW1lID09IFwiYXJndW1lbnRzXCIpIHtcbiAgICAgICAgdmFyIGZuU2NvcGUgPSBmdW5jdGlvblNjb3BlKHNjb3BlLCBmYWxzZSk7XG4gICAgICAgIGlmIChmblNjb3BlLmZuVHlwZSAmJiAhKG5vZGUubmFtZSBpbiBmblNjb3BlLnByb3BzKSlcbiAgICAgICAgICBmblNjb3BlLmRlZlByb3Aobm9kZS5uYW1lLCBmblNjb3BlLmZuVHlwZS5vcmlnaW5Ob2RlKVxuICAgICAgICAgICAgLmFkZFR5cGUobmV3IEFycihmblNjb3BlLmZuVHlwZS5hcmd1bWVudHMgPSBuZXcgQVZhbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjb3BlLmdldFByb3Aobm9kZS5uYW1lKTtcbiAgICB9KSxcbiAgICBUaGlzRXhwcmVzc2lvbjogcmV0KGZ1bmN0aW9uKF9ub2RlLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGdldFRoaXMoc2NvcGUpO1xuICAgIH0pLFxuICAgIFN1cGVyOiByZXQoZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3VwZXJUeXBlID0gY3guY3VyU3VwZXIgfHwgQU51bGw7XG4gICAgfSksXG4gICAgTGl0ZXJhbDogcmV0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBsaXRlcmFsVHlwZShub2RlKTtcbiAgICB9KSxcbiAgICBUZW1wbGF0ZUxpdGVyYWw6IHJldChmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKVxuICAgICAgICBpbmZlcihub2RlLmV4cHJlc3Npb25zW2ldLCBzY29wZSwgQU51bGwpO1xuICAgICAgcmV0dXJuIGN4LnN0cjtcbiAgICB9KSxcbiAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IGZpbGwoZnVuY3Rpb24obm9kZSwgc2NvcGUsIG91dCkge1xuICAgICAgdmFyIGFyZ3MgPSBbbmV3IEFycihjeC5zdHIpXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5xdWFzaS5leHByZXNzaW9ucy5sZW5ndGg7ICsraSlcbiAgICAgICAgYXJncy5wdXNoKGluZmVyKG5vZGUucXVhc2kuZXhwcmVzc2lvbnNbaV0sIHNjb3BlKSk7XG4gICAgICBpbmZlcihub2RlLnRhZywgc2NvcGUsIG5ldyBJc0NhbGxlZShjeC50b3BTY29wZSwgYXJncywgbm9kZS5xdWFzaS5leHByZXNzaW9ucywgb3V0KSk7XG4gICAgfSksXG4gICAgWWllbGRFeHByZXNzaW9uOiByZXQoZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIHZhciBvdXRwdXQgPSBBTnVsbCwgZm4gPSBmdW5jdGlvblNjb3BlKHNjb3BlKS5mblR5cGU7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgaWYgKGZuLnJldHZhbCA9PSBBTnVsbCkgZm4ucmV0dmFsID0gbmV3IEFWYWw7XG4gICAgICAgIGlmICghZm4ueWllbGR2YWwpIGZuLnlpZWxkdmFsID0gbmV3IEFWYWw7XG4gICAgICAgIG91dHB1dCA9IGZuLnJldHZhbDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICAgIGlmIChub2RlLmRlbGVnYXRlKSB7XG4gICAgICAgICAgaW5mZXIobm9kZS5hcmd1bWVudCwgc2NvcGUsIG5ldyBIYXNNZXRob2RDYWxsKFwibmV4dFwiLCBbXSwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEdldFByb3AoXCJ2YWx1ZVwiLCBvdXRwdXQpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5mZXIobm9kZS5hcmd1bWVudCwgc2NvcGUsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmbiA/IGZuLnlpZWxkdmFsIDogQU51bGw7XG4gICAgfSlcbiAgfTtcbiAgaW5mZXJFeHByVmlzaXRvci5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGluZmVyRXhwclZpc2l0b3IuRnVuY3Rpb25FeHByZXNzaW9uO1xuXG4gIGZ1bmN0aW9uIGluZmVyKG5vZGUsIHNjb3BlLCBvdXQsIG5hbWUpIHtcbiAgICB2YXIgaGFuZGxlciA9IGluZmVyRXhwclZpc2l0b3Jbbm9kZS50eXBlXTtcbiAgICByZXR1cm4gaGFuZGxlciA/IGhhbmRsZXIobm9kZSwgc2NvcGUsIG91dCwgbmFtZSkgOiBBTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb3BQYXR0ZXJuKGluaXQpIHtcbiAgICByZXR1cm4gaW5pdC50eXBlID09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiID8gaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQgOiBpbml0O1xuICB9XG5cbiAgdmFyIGluZmVyV3JhcHBlciA9IGV4cG9ydHMuaW5mZXJXcmFwcGVyID0gd2Fsay5tYWtlKHtcbiAgICBFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgaW5mZXIobm9kZSwgbm9kZS5zY29wZSB8fCBzY29wZSwgQU51bGwpO1xuICAgIH0sXG5cbiAgICBPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgaW5mZXIobm9kZSwgbm9kZS5zY29wZSB8fCBzY29wZSwgQU51bGwpO1xuICAgIH0sXG5cbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSwgYykge1xuICAgICAgdmFyIGlubmVyID0gbm9kZS5zY29wZSwgZm4gPSBpbm5lci5mblR5cGU7XG4gICAgICBjb25uZWN0UGFyYW1zKG5vZGUsIGlubmVyKTtcbiAgICAgIGMobm9kZS5ib2R5LCBpbm5lciwgXCJTdGF0ZW1lbnRcIik7XG4gICAgICBtYXliZVRhZ0FzSW5zdGFudGlhdGVkKG5vZGUsIGZuKSB8fCBtYXliZVRhZ0FzR2VuZXJpYyhmbik7XG4gICAgICBpZiAobm9kZS5pZCkgc2NvcGUuZ2V0UHJvcChub2RlLmlkLm5hbWUpLmFkZFR5cGUoZm4pO1xuICAgIH0sXG5cbiAgICBTdGF0ZW1lbnQ6IGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBjKSB7XG4gICAgICBjKG5vZGUsIG5vZGUuc2NvcGUgfHwgc2NvcGUpO1xuICAgIH0sXG5cbiAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlLCBjKSB7XG4gICAgICBjKG5vZGUuZGVjbGFyYXRpb24sIG5vZGUuc2NvcGUgfHwgc2NvcGUpO1xuICAgIH0sXG5cbiAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICBpZiAoZGVjbC5pZC50eXBlID09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBzY29wZS5nZXRQcm9wKGRlY2wuaWQubmFtZSk7XG4gICAgICAgICAgaWYgKGRlY2wuaW5pdClcbiAgICAgICAgICAgIGluZmVyKGRlY2wuaW5pdCwgc2NvcGUsIHByb3AsIGRlY2wuaWQubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVjbC5pbml0KSB7XG4gICAgICAgICAgY29ubmVjdFBhdHRlcm4oZGVjbC5pZCwgc2NvcGUsIGluZmVyKGRlY2wuaW5pdCwgc2NvcGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgaWYgKCFub2RlLmlkKSBpbmZlckNsYXNzKG5vZGUsIHNjb3BlKTtcbiAgICAgIGVsc2Ugc2NvcGUuZ2V0UHJvcChub2RlLmlkLm5hbWUpLmFkZFR5cGUoaW5mZXJDbGFzcyhub2RlLCBzY29wZSwgbm9kZS5pZC5uYW1lKSk7XG4gICAgfSxcblxuICAgIFJldHVyblN0YXRlbWVudDogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIGlmICghbm9kZS5hcmd1bWVudCkgcmV0dXJuO1xuICAgICAgdmFyIG91dHB1dCA9IEFOdWxsLCBmbiA9IGZ1bmN0aW9uU2NvcGUoc2NvcGUpLmZuVHlwZTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBpZiAoZm4ucmV0dmFsID09IEFOdWxsKSBmbi5yZXR2YWwgPSBuZXcgQVZhbDtcbiAgICAgICAgb3V0cHV0ID0gZm4ucmV0dmFsO1xuICAgICAgfVxuICAgICAgaW5mZXIobm9kZS5hcmd1bWVudCwgc2NvcGUsIG91dHB1dCk7XG4gICAgfSxcblxuICAgIEZvckluU3RhdGVtZW50OiBmdW5jdGlvbihub2RlLCBzY29wZSwgYykge1xuICAgICAgdmFyIHNvdXJjZSA9IGluZmVyKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICAgIGlmICgobm9kZS5yaWdodC50eXBlID09IFwiSWRlbnRpZmllclwiICYmIG5vZGUucmlnaHQubmFtZSBpbiBzY29wZS5wcm9wcykgfHxcbiAgICAgICAgICAobm9kZS5yaWdodC50eXBlID09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIG5vZGUucmlnaHQucHJvcGVydHkubmFtZSA9PSBcInByb3RvdHlwZVwiKSkge1xuICAgICAgICBtYXliZUluc3RhbnRpYXRlKHNjb3BlLCA1KTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBsb29wUGF0dGVybihub2RlLmxlZnQpO1xuICAgICAgICBpZiAocGF0dGVybi50eXBlID09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4ubmFtZSBpbiBzY29wZS5wcm9wcylcbiAgICAgICAgICAgIHNjb3BlLmdldFByb3AocGF0dGVybi5uYW1lKS5pdGVyYXRlc092ZXIgPSBzb3VyY2U7XG4gICAgICAgICAgc291cmNlLmdldFByb3AoXCI8aT5cIikucHJvcGFnYXRlKGVuc3VyZVZhcihwYXR0ZXJuLCBzY29wZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbm5lY3RQYXR0ZXJuKHBhdHRlcm4sIHNjb3BlLCBzb3VyY2UuZ2V0UHJvcChcIjxpPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGMobm9kZS5ib2R5LCBzY29wZSwgXCJTdGF0ZW1lbnRcIik7XG4gICAgfSxcblxuICAgIEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbihub2RlLCBzY29wZSwgYykge1xuICAgICAgdmFyIHBhdHRlcm4gPSBsb29wUGF0dGVybihub2RlLmxlZnQpLCB0YXJnZXQ7XG4gICAgICBpZiAocGF0dGVybi50eXBlID09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB0YXJnZXQgPSBlbnN1cmVWYXIocGF0dGVybiwgc2NvcGUpO1xuICAgICAgZWxzZVxuICAgICAgICBjb25uZWN0UGF0dGVybihwYXR0ZXJuLCBzY29wZSwgdGFyZ2V0ID0gbmV3IEFWYWwpO1xuXG4gICAgICBpZiAobm9kZS5hd2FpdCkge1xuICAgICAgICBpbmZlcihub2RlLnJpZ2h0LCBzY29wZSwgbmV3IEhhc01ldGhvZENhbGwoXCI6U3ltYm9sLmFzeW5jSXRlcmF0b3JcIiwgW10sIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgSGFzTWV0aG9kQ2FsbChcIm5leHRcIiwgW10sIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgR2V0UHJvcChcIjp0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgR2V0UHJvcChcInZhbHVlXCIsIHRhcmdldCkpKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mZXIobm9kZS5yaWdodCwgc2NvcGUsIG5ldyBIYXNNZXRob2RDYWxsKFwiOlN5bWJvbC5pdGVyYXRvclwiLCBbXSwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBIYXNNZXRob2RDYWxsKFwibmV4dFwiLCBbXSwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBHZXRQcm9wKFwidmFsdWVcIiwgdGFyZ2V0KSkpKTtcbiAgICAgIH1cbiAgICAgIGMobm9kZS5ib2R5LCBzY29wZSwgXCJTdGF0ZW1lbnRcIik7XG4gICAgfVxuICB9KTtcblxuICAvLyBQQVJTSU5HXG5cbiAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMsIHRoaXJkQXJnKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIG9wdGlvbnMgPSB0aGlyZEFyZztcbiAgICB2YXIgYXN0O1xuICAgIHRyeSB7IGFzdCA9IGFjb3JuLnBhcnNlKHRleHQsIG9wdGlvbnMpOyB9XG4gICAgY2F0Y2goZSkgeyBhc3QgPSBhY29ybl9sb29zZS5wYXJzZSh0ZXh0LCBvcHRpb25zKTsgfVxuICAgIHJldHVybiBhc3Q7XG4gIH07XG5cbiAgLy8gQU5BTFlTSVMgSU5URVJGQUNFXG5cbiAgZXhwb3J0cy5hbmFseXplID0gZnVuY3Rpb24oYXN0LCBuYW1lLCBzY29wZSkge1xuICAgIGlmICh0eXBlb2YgYXN0ID09IFwic3RyaW5nXCIpIGFzdCA9IHBhcnNlKGFzdCk7XG5cbiAgICBpZiAoIW5hbWUpIG5hbWUgPSBcImZpbGUjXCIgKyBjeC5vcmlnaW5zLmxlbmd0aDtcbiAgICBleHBvcnRzLmFkZE9yaWdpbihjeC5jdXJPcmlnaW4gPSBuYW1lKTtcblxuICAgIGlmICghc2NvcGUpIHNjb3BlID0gY3gudG9wU2NvcGU7XG4gICAgY3guc3RhcnRBbmFseXNpcygpO1xuXG4gICAgd2Fsay5yZWN1cnNpdmUoYXN0LCBzY29wZSwgbnVsbCwgc2NvcGVHYXRoZXJlcik7XG4gICAgaWYgKGN4LnBhcmVudCkgY3gucGFyZW50LnNpZ25hbChcInByZUluZmVyXCIsIGFzdCwgc2NvcGUpO1xuICAgIHdhbGsucmVjdXJzaXZlKGFzdCwgc2NvcGUsIG51bGwsIGluZmVyV3JhcHBlcik7XG4gICAgaWYgKGN4LnBhcmVudCkgY3gucGFyZW50LnNpZ25hbChcInBvc3RJbmZlclwiLCBhc3QsIHNjb3BlKTtcblxuICAgIGN4LmN1ck9yaWdpbiA9IG51bGw7XG4gIH07XG5cbiAgLy8gUFVSR0lOR1xuXG4gIGV4cG9ydHMucHVyZ2UgPSBmdW5jdGlvbihvcmlnaW5zLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRlc3QgPSBtYWtlUHJlZGljYXRlKG9yaWdpbnMsIHN0YXJ0LCBlbmQpO1xuICAgICsrY3gucHVyZ2VHZW47XG4gICAgY3gudG9wU2NvcGUucHVyZ2UodGVzdCk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBjeC5wcm9wcykge1xuICAgICAgdmFyIGxpc3QgPSBjeC5wcm9wc1twcm9wXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgb2JqID0gbGlzdFtpXSwgYXYgPSBvYmoucHJvcHNbcHJvcF07XG4gICAgICAgIGlmICghYXYgfHwgdGVzdChhdiwgYXYub3JpZ2luTm9kZSkpIGxpc3Quc3BsaWNlKGktLSwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoIWxpc3QubGVuZ3RoKSBkZWxldGUgY3gucHJvcHNbcHJvcF07XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUob3JpZ2lucywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBhcnIgPSBBcnJheS5pc0FycmF5KG9yaWdpbnMpO1xuICAgIGlmIChhcnIgJiYgb3JpZ2lucy5sZW5ndGggPT0gMSkgeyBvcmlnaW5zID0gb3JpZ2luc1swXTsgYXJyID0gZmFsc2U7IH1cbiAgICBpZiAoYXJyKSB7XG4gICAgICBpZiAoZW5kID09IG51bGwpIHJldHVybiBmdW5jdGlvbihuKSB7IHJldHVybiBvcmlnaW5zLmluZGV4T2Yobi5vcmlnaW4pID4gLTE7IH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obiwgcG9zKSB7IHJldHVybiBwb3MgJiYgcG9zLnN0YXJ0ID49IHN0YXJ0ICYmIHBvcy5lbmQgPD0gZW5kICYmIG9yaWdpbnMuaW5kZXhPZihuLm9yaWdpbikgPiAtMTsgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZCA9PSBudWxsKSByZXR1cm4gZnVuY3Rpb24obikgeyByZXR1cm4gbi5vcmlnaW4gPT0gb3JpZ2luczsgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihuLCBwb3MpIHsgcmV0dXJuIHBvcyAmJiBwb3Muc3RhcnQgPj0gc3RhcnQgJiYgcG9zLmVuZCA8PSBlbmQgJiYgbi5vcmlnaW4gPT0gb3JpZ2luczsgfTtcbiAgICB9XG4gIH1cblxuICBBVmFsLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICBpZiAodGhpcy5wdXJnZUdlbiA9PSBjeC5wdXJnZUdlbikgcmV0dXJuO1xuICAgIHRoaXMucHVyZ2VHZW4gPSBjeC5wdXJnZUdlbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tpXTtcbiAgICAgIGlmICh0ZXN0KHR5cGUsIHR5cGUub3JpZ2luTm9kZSkpXG4gICAgICAgIHRoaXMudHlwZXMuc3BsaWNlKGktLSwgMSk7XG4gICAgICBlbHNlXG4gICAgICAgIHR5cGUucHVyZ2UodGVzdCk7XG4gICAgfVxuICAgIGlmICghdGhpcy50eXBlcy5sZW5ndGgpIHRoaXMubWF4V2VpZ2h0ID0gMDtcblxuICAgIGlmICh0aGlzLmZvcndhcmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb3J3YXJkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZiA9IHRoaXMuZm9yd2FyZFtpXTtcbiAgICAgIGlmICh0ZXN0KGYpKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpIHRoaXMucHJvcHMgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChmLnB1cmdlKSB7XG4gICAgICAgIGYucHVyZ2UodGVzdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBBTnVsbC5wdXJnZSA9IGZ1bmN0aW9uKCkge307XG4gIE9iai5wcm90b3R5cGUucHVyZ2UgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgaWYgKHRoaXMucHVyZ2VHZW4gPT0gY3gucHVyZ2VHZW4pIHJldHVybiB0cnVlO1xuICAgIHRoaXMucHVyZ2VHZW4gPSBjeC5wdXJnZUdlbjtcbiAgICBmb3IgKHZhciBwIGluIHRoaXMucHJvcHMpIHtcbiAgICAgIHZhciBhdiA9IHRoaXMucHJvcHNbcF07XG4gICAgICBpZiAodGVzdChhdiwgYXYub3JpZ2luTm9kZSkpXG4gICAgICAgIHRoaXMucmVtb3ZlUHJvcChwKTtcbiAgICAgIGF2LnB1cmdlKHRlc3QpO1xuICAgIH1cbiAgfTtcbiAgRm4ucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24odGVzdCkge1xuICAgIGlmIChPYmoucHJvdG90eXBlLnB1cmdlLmNhbGwodGhpcywgdGVzdCkpIHJldHVybjtcbiAgICB0aGlzLnNlbGYucHVyZ2UodGVzdCk7XG4gICAgdGhpcy5yZXR2YWwucHVyZ2UodGVzdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHRoaXMuYXJnc1tpXS5wdXJnZSh0ZXN0KTtcbiAgfTtcblxuICAvLyBFWFBSRVNTSU9OIFRZUEUgREVURVJNSU5BVElPTlxuXG4gIGZ1bmN0aW9uIGZpbmRCeVByb3BlcnR5TmFtZShuYW1lKSB7XG4gICAgZ3Vlc3NpbmcgPSB0cnVlO1xuICAgIHZhciBmb3VuZCA9IG9ianNXaXRoUHJvcChuYW1lKTtcbiAgICBpZiAoZm91bmQpIGZvciAodmFyIGkgPSAwOyBpIDwgZm91bmQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB2YWwgPSBmb3VuZFtpXS5nZXRQcm9wKG5hbWUpO1xuICAgICAgaWYgKCF2YWwuaXNFbXB0eSgpKSByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gQU51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0b3JSZXN1bHQoaW5wdXQsIG91dHB1dCwgYXN5bmMpIHtcbiAgICB2YXIgZGVmcyA9IGN4LmRlZmluaXRpb25zLmVjbWFzY3JpcHQ7XG4gICAgdmFyIHZhbE9iaiA9IG5ldyBPYmoodHJ1ZSk7XG4gICAgdmFsT2JqLmRlZlByb3AoXCJkb25lXCIpLmFkZFR5cGUoY3guYm9vbCk7XG4gICAgb3V0cHV0LnByb3BhZ2F0ZSh2YWxPYmouZGVmUHJvcChcInZhbHVlXCIpKTtcbiAgICB2YXIgcmV0T2JqID0gdmFsT2JqO1xuICAgIGlmIChhc3luYyAmJiBkZWZzKSB7XG4gICAgICByZXRPYmogPSBuZXcgT2JqKGRlZnNbXCJQcm9taXNlLnByb3RvdHlwZVwiXSk7XG4gICAgICByZXRPYmouZ2V0VHlwZSgpLnByb3BhZ2F0ZShuZXcgRGVmUHJvcCgnOnQnLCB2YWxPYmopKTtcbiAgICB9XG4gICAgdmFyIG1ldGhvZCA9IG5ldyBGbihudWxsLCBBTnVsbCwgaW5wdXQgPyBbaW5wdXRdIDogW10sIGlucHV0ID8gW1wiP1wiXSA6IFtdLCByZXRPYmopO1xuICAgIHZhciByZXN1bHQgPSBuZXcgT2JqKGRlZnMgPyBhc3luYyA/IGRlZnMuYXN5bmNfZ2VuZXJhdG9yX3Byb3RvdHlwZSA6IGRlZnMuZ2VuZXJhdG9yX3Byb3RvdHlwZSA6IHRydWUpO1xuICAgIHJlc3VsdC5kZWZQcm9wKFwibmV4dFwiKS5hZGRUeXBlKG1ldGhvZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSXRlcmF0b3IoZm4sIG91dHB1dCkge1xuICAgIGlmICghZm4uZ2VuZXJhdG9yKSByZXR1cm4gb3V0cHV0O1xuICAgIGlmICghZm4uY29tcHV0ZVJldCkgeyAvLyBSZXVzZSBpdGVyYXRvciBvYmplY3RzIGZvciBub24tY29tcHV0ZWQgcmV0dXJuIHR5cGVzXG4gICAgICBpZiAoZm4uZ2VuZXJhdG9yID09PSB0cnVlKSBmbi5nZW5lcmF0b3IgPSBnZW5lcmF0b3JSZXN1bHQoZm4ueWllbGR2YWwsIG91dHB1dCwgZm4uYXN5bmMpO1xuICAgICAgcmV0dXJuIGZuLmdlbmVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRvclJlc3VsdChmbi55aWVsZHZhbCwgb3V0cHV0LCBmbi5hc3luYyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlUmV0dXJuVHlwZShmdW5jTm9kZSwgYXJnTm9kZXMsIHNjb3BlKSB7XG4gICAgdmFyIGZuID0gZmluZFR5cGUoZnVuY05vZGUsIHNjb3BlKS5nZXRGdW5jdGlvblR5cGUoKTtcbiAgICBpZiAoIWZuKSByZXR1cm4gQU51bGw7XG4gICAgdmFyIHJlc3VsdCA9IGZuLnJldHZhbDtcbiAgICBpZiAoZm4uY29tcHV0ZVJldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFyZ3MgPSBbXTsgaSA8IGFyZ05vZGVzLmxlbmd0aDsgKytpKVxuICAgICAgICBhcmdzLnB1c2goZmluZFR5cGUoYXJnTm9kZXNbaV0sIHNjb3BlKSk7XG4gICAgICB2YXIgc2VsZiA9IEFOdWxsO1xuICAgICAgaWYgKGZ1bmNOb2RlLnR5cGUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgICAgIHNlbGYgPSBmaW5kVHlwZShmdW5jTm9kZS5vYmplY3QsIHNjb3BlKTtcbiAgICAgIHJlc3VsdCA9IGZuLmNvbXB1dGVSZXQoc2VsZiwgYXJncywgYXJnTm9kZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcihmbiwgcmVzdWx0KTtcbiAgfVxuXG4gIHZhciB0eXBlRmluZGVyID0gZXhwb3J0cy50eXBlRmluZGVyID0ge1xuICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBhcnJheUxpdGVyYWxUeXBlKG5vZGUuZWxlbWVudHMsIHNjb3BlLCBmaW5kVHlwZSk7XG4gICAgfSxcbiAgICBPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5vYmpUeXBlO1xuICAgIH0sXG4gICAgQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUub2JqVHlwZTtcbiAgICB9LFxuICAgIENsYXNzRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUub2JqVHlwZTtcbiAgICB9LFxuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnNjb3BlLmZuVHlwZTtcbiAgICB9LFxuICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuc2NvcGUuZm5UeXBlO1xuICAgIH0sXG4gICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnNjb3BlLmZuVHlwZTtcbiAgICB9LFxuICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBmaW5kVHlwZShub2RlLmV4cHJlc3Npb25zW25vZGUuZXhwcmVzc2lvbnMubGVuZ3RoLTFdLCBzY29wZSk7XG4gICAgfSxcbiAgICBVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB1bm9wUmVzdWx0VHlwZShub2RlLm9wZXJhdG9yKTtcbiAgICB9LFxuICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN4Lm51bTtcbiAgICB9LFxuICAgIEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICBpZiAoYmlub3BJc0Jvb2xlYW4obm9kZS5vcGVyYXRvcikpIHJldHVybiBjeC5ib29sO1xuICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT0gXCIrXCIpIHtcbiAgICAgICAgdmFyIGxocyA9IGZpbmRUeXBlKG5vZGUubGVmdCwgc2NvcGUpO1xuICAgICAgICB2YXIgcmhzID0gZmluZFR5cGUobm9kZS5yaWdodCwgc2NvcGUpO1xuICAgICAgICBpZiAobGhzLmhhc1R5cGUoY3guc3RyKSB8fCByaHMuaGFzVHlwZShjeC5zdHIpKSByZXR1cm4gY3guc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN4Lm51bTtcbiAgICB9LFxuICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGZpbmRUeXBlKG5vZGUucmlnaHQsIHNjb3BlKTtcbiAgICB9LFxuICAgIExvZ2ljYWxFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgdmFyIGxocyA9IGZpbmRUeXBlKG5vZGUubGVmdCwgc2NvcGUpO1xuICAgICAgcmV0dXJuIGxocy5pc0VtcHR5KCkgPyBmaW5kVHlwZShub2RlLnJpZ2h0LCBzY29wZSkgOiBsaHM7XG4gICAgfSxcbiAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICB2YXIgbGhzID0gZmluZFR5cGUobm9kZS5jb25zZXF1ZW50LCBzY29wZSk7XG4gICAgICByZXR1cm4gbGhzLmlzRW1wdHkoKSA/IGZpbmRUeXBlKG5vZGUuYWx0ZXJuYXRlLCBzY29wZSkgOiBsaHM7XG4gICAgfSxcbiAgICBOZXdFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgdmFyIGYgPSBmaW5kVHlwZShub2RlLmNhbGxlZSwgc2NvcGUpLmdldEZ1bmN0aW9uVHlwZSgpO1xuICAgICAgdmFyIHByb3RvID0gZiAmJiBmLmdldFByb3AoXCJwcm90b3R5cGVcIikuZ2V0T2JqVHlwZSgpO1xuICAgICAgaWYgKCFwcm90bykgcmV0dXJuIEFOdWxsO1xuICAgICAgcmV0dXJuIGdldEluc3RhbmNlKHByb3RvLCBmKTtcbiAgICB9LFxuICAgIENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVSZXR1cm5UeXBlKG5vZGUuY2FsbGVlLCBub2RlLmFyZ3VtZW50cywgc2NvcGUpO1xuICAgIH0sXG4gICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIHZhciBwcm9wTiA9IHByb3BOYW1lKG5vZGUpLCBvYmogPSBmaW5kVHlwZShub2RlLm9iamVjdCwgc2NvcGUpLmdldFR5cGUoKTtcbiAgICAgIGlmIChvYmopIHJldHVybiBvYmouZ2V0UHJvcChwcm9wTik7XG4gICAgICBpZiAocHJvcE4gPT0gXCI8aT5cIikgcmV0dXJuIEFOdWxsO1xuICAgICAgcmV0dXJuIGZpbmRCeVByb3BlcnR5TmFtZShwcm9wTik7XG4gICAgfSxcbiAgICBNZXRob2REZWZpbml0aW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJvcE4gPSBwcm9wTmFtZShub2RlKSwgb2JqID0gZ2V0VGhpcyhub2RlLnZhbHVlLnNjb3BlKS5nZXRUeXBlKCk7XG4gICAgICBpZiAob2JqKSByZXR1cm4gb2JqLmdldFByb3AocHJvcE4pO1xuICAgICAgcmV0dXJuIEFOdWxsO1xuICAgIH0sXG4gICAgSWRlbnRpZmllcjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBzY29wZS5oYXNQcm9wKG5vZGUubmFtZSkgfHwgQU51bGw7XG4gICAgfSxcbiAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24oX25vZGUsIHNjb3BlKSB7XG4gICAgICByZXR1cm4gZ2V0VGhpcyhzY29wZSk7XG4gICAgfSxcbiAgICBMaXRlcmFsOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbGl0ZXJhbFR5cGUobm9kZSk7XG4gICAgfSxcbiAgICBTdXBlcjogcmV0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnN1cGVyVHlwZTtcbiAgICB9KSxcbiAgICBUZW1wbGF0ZUxpdGVyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGN4LnN0cjtcbiAgICB9LFxuICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgIHJldHVybiBjb21wdXRlUmV0dXJuVHlwZShub2RlLnRhZywgbm9kZS5xdWFzaS5leHByZXNzaW9ucywgc2NvcGUpO1xuICAgIH0sXG4gICAgWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbihfbm9kZSwgc2NvcGUpIHtcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uU2NvcGUoc2NvcGUpLmZuVHlwZTtcbiAgICAgIHJldHVybiBmbiA/IGZuLnlpZWxkdmFsIDogQU51bGw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRUeXBlKG5vZGUsIHNjb3BlKSB7XG4gICAgdmFyIGZpbmRlciA9IHR5cGVGaW5kZXJbbm9kZS50eXBlXTtcbiAgICByZXR1cm4gZmluZGVyID8gZmluZGVyKG5vZGUsIHNjb3BlKSA6IEFOdWxsO1xuICB9XG5cbiAgdmFyIHNlYXJjaFZpc2l0b3IgPSBleHBvcnRzLnNlYXJjaFZpc2l0b3IgPSB3YWxrLm1ha2Uoe1xuICAgIEZ1bmN0aW9uOiBmdW5jdGlvbihub2RlLCBfc3QsIGMpIHtcbiAgICAgIHdhbGsuYmFzZS5GdW5jdGlvbihub2RlLCBub2RlLnNjb3BlLCBjKTtcbiAgICB9LFxuICAgIENhdGNoQ2xhdXNlOiBmdW5jdGlvbihub2RlLCBfc3QsIGMpIHtcbiAgICAgIHdhbGsuYmFzZS5DYXRjaENsYXVzZShub2RlLCBub2RlLnNjb3BlLCBjKTtcbiAgICB9LFxuICAgIFByb3BlcnR5OiBmdW5jdGlvbihub2RlLCBzdCwgYykge1xuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIGMobm9kZS5rZXksIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgICBpZiAobm9kZS5rZXkgIT0gbm9kZS52YWx1ZSkgYyhub2RlLnZhbHVlLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgIH0sXG4gICAgU3RhdGVtZW50OiBmdW5jdGlvbihub2RlLCBzdCwgYykge1xuICAgICAgYyhub2RlLCBub2RlLnNjb3BlIHx8IHN0KTtcbiAgICB9LFxuICAgIEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24obm9kZSwgc3QsIGMpIHtcbiAgICAgIGMobm9kZS5sb2NhbCwgc3QpO1xuICAgIH0sXG4gICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogZnVuY3Rpb24obm9kZSwgc3QsIGMpIHtcbiAgICAgIGMobm9kZS5sb2NhbCwgc3QpO1xuICAgIH0sXG4gICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBmdW5jdGlvbihub2RlLCBzdCwgYykge1xuICAgICAgYyhub2RlLmxvY2FsLCBzdCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHNlYXJjaEV4cHJWaXNpdG9yID0gZXhwb3J0cy5zZWFyY2hFeHByVmlzaXRvciA9IHdhbGsubWFrZSh7XG4gICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc3QsIGMpIHtcbiAgICAgIGMobm9kZS5vYmplY3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgICBpZiAobm9kZS5jb21wdXRlZCkgeyBjKG5vZGUucHJvcGVydHksIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgICB9LFxuICAgIFByb3BlcnR5OiBmdW5jdGlvbihub2RlLCBzdCwgYykge1xuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIGMobm9kZS5rZXksIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgICBjKG5vZGUudmFsdWUsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9LCBzZWFyY2hWaXNpdG9yKTtcbiAgZXhwb3J0cy5mdWxsVmlzaXRvciA9IHdhbGsubWFrZSh7XG4gICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc3QsIGMpIHtcbiAgICAgIGMobm9kZS5vYmplY3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgICBjKG5vZGUucHJvcGVydHksIHN0LCBub2RlLmNvbXB1dGVkID8gXCJFeHByZXNzaW9uXCIgOiBudWxsKTtcbiAgICB9LFxuICAgIFByb3BlcnR5OiBmdW5jdGlvbihub2RlLCBzdCwgYykge1xuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIGMobm9kZS5rZXksIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgICBjKG5vZGUudmFsdWUsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9LCBzZWFyY2hWaXNpdG9yKTtcblxuICBleHBvcnRzLmZpbmRFeHByZXNzaW9uQXQgPSBmdW5jdGlvbihhc3QsIHN0YXJ0LCBlbmQsIGRlZmF1bHRTY29wZSwgZmlsdGVyKSB7XG4gICAgdmFyIHRlc3QgPSBmaWx0ZXIgfHwgZnVuY3Rpb24oX3QsIG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5uYW1lID09IFwi4pyWXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0eXBlRmluZGVyLmhhc093blByb3BlcnR5KG5vZGUudHlwZSk7XG4gICAgfTtcbiAgICByZXR1cm4gd2Fsay5maW5kTm9kZUF0KGFzdCwgc3RhcnQsIGVuZCwgdGVzdCwgc2VhcmNoRXhwclZpc2l0b3IsIGRlZmF1bHRTY29wZSB8fCBjeC50b3BTY29wZSk7XG4gIH07XG4gIGV4cG9ydHMuZmluZENsb3Nlc3RFeHByZXNzaW9uID0gZnVuY3Rpb24oYXN0LCBzdGFydCwgZW5kLCBkZWZhdWx0U2NvcGUsIGZpbHRlcikge1xuICAgIHZhciB0ZXN0ID0gZmlsdGVyIHx8IGZ1bmN0aW9uKF90LCBub2RlKSB7XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCAmJiBub2RlLnN0YXJ0ID4gc3RhcnQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChub2RlLnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5uYW1lID09IFwi4pyWXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0eXBlRmluZGVyLmhhc093blByb3BlcnR5KG5vZGUudHlwZSk7XG4gICAgfTtcbiAgICByZXR1cm4gd2Fsay5maW5kTm9kZUFyb3VuZChhc3QsIGVuZCwgdGVzdCwgc2VhcmNoRXhwclZpc2l0b3IsIGRlZmF1bHRTY29wZSB8fCBjeC50b3BTY29wZSk7XG4gIH07XG5cbiAgZXhwb3J0cy5maW5kRXhwcmVzc2lvbkFyb3VuZCA9IGZ1bmN0aW9uKGFzdCwgc3RhcnQsIGVuZCwgZGVmYXVsdFNjb3BlLCBmaWx0ZXIpIHtcbiAgICB2YXIgdGVzdCA9IGZpbHRlciB8fCBmdW5jdGlvbihfdCwgbm9kZSkge1xuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgbm9kZS5zdGFydCA+IHN0YXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAobm9kZS50eXBlID09IFwiSWRlbnRpZmllclwiICYmIG5vZGUubmFtZSA9PSBcIuKcllwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHlwZUZpbmRlci5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIHdhbGsuZmluZE5vZGVBcm91bmQoYXN0LCBlbmQsIHRlc3QsIHNlYXJjaFZpc2l0b3IsIGRlZmF1bHRTY29wZSB8fCBjeC50b3BTY29wZSk7XG4gIH07XG5cbiAgZXhwb3J0cy5leHByZXNzaW9uVHlwZSA9IGZ1bmN0aW9uKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZpbmRUeXBlKGZvdW5kLm5vZGUsIGZvdW5kLnN0YXRlKTtcbiAgfTtcblxuICAvLyBGaW5kaW5nIHRoZSBleHBlY3RlZCB0eXBlIG9mIHNvbWV0aGluZywgZnJvbSBjb250ZXh0XG5cbiAgZXhwb3J0cy5wYXJlbnROb2RlID0gZnVuY3Rpb24oY2hpbGQsIGFzdCkge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICBpZiAobm9kZS5zdGFydCA8PSBjaGlsZC5zdGFydCAmJiBub2RlLmVuZCA+PSBjaGlsZC5lbmQpIHtcbiAgICAgICAgdmFyIHRvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobm9kZSA9PSBjaGlsZCkgdGhyb3cge2ZvdW5kOiB0b3B9O1xuICAgICAgICBpZiAodG9wICE9IG5vZGUpIHN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgIHdhbGsuYmFzZVtvdmVycmlkZSB8fCBub2RlLnR5cGVdKG5vZGUsIHN0LCBjKTtcbiAgICAgICAgaWYgKHRvcCAhPSBub2RlKSBzdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGMoYXN0LCBudWxsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5mb3VuZCkgcmV0dXJuIGUuZm91bmQ7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZmluZFR5cGVGcm9tQ29udGV4dCA9IGV4cG9ydHMuZmluZFR5cGVGcm9tQ29udGV4dCA9IHtcbiAgICBBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uKHBhcmVudCwgXywgZ2V0KSB7IHJldHVybiBnZXQocGFyZW50LCB0cnVlKS5nZXRQcm9wKFwiPGk+XCIpOyB9LFxuICAgIE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uKHBhcmVudCwgbm9kZSwgZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudC5wcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICBpZiAocHJvcC52YWx1ZSA9PSBub2RlKVxuICAgICAgICAgIHJldHVybiBnZXQocGFyZW50LCB0cnVlKS5nZXRQcm9wKHByb3BOYW1lKHByb3ApKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24ocGFyZW50KSB7IHJldHVybiB1bm9wUmVzdWx0VHlwZShwYXJlbnQub3BlcmF0b3IpOyB9LFxuICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gY3gubnVtOyB9LFxuICAgIEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHBhcmVudCkgeyByZXR1cm4gYmlub3BJc0Jvb2xlYW4ocGFyZW50Lm9wZXJhdG9yKSA/IGN4LmJvb2wgOiBjeC5udW07IH0sXG4gICAgQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uKHBhcmVudCwgXywgZ2V0KSB7IHJldHVybiBnZXQocGFyZW50LmxlZnQpOyB9LFxuICAgIExvZ2ljYWxFeHByZXNzaW9uOiBmdW5jdGlvbihwYXJlbnQsIF8sIGdldCkgeyByZXR1cm4gZ2V0KHBhcmVudCwgdHJ1ZSk7IH0sXG4gICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbihwYXJlbnQsIG5vZGUsIGdldCkge1xuICAgICAgaWYgKHBhcmVudC5jb25zZXF1ZW50ID09IG5vZGUgfHwgcGFyZW50LmFsdGVybmF0ZSA9PSBub2RlKSByZXR1cm4gZ2V0KHBhcmVudCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24ocGFyZW50LCBub2RlLCBnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50LmFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gcGFyZW50LmFyZ3VtZW50c1tpXTtcbiAgICAgICAgaWYgKGFyZyA9PSBub2RlKSB7XG4gICAgICAgICAgdmFyIGNhbGxlZVR5cGUgPSBnZXQocGFyZW50LmNhbGxlZSkuZ2V0RnVuY3Rpb25UeXBlKCk7XG4gICAgICAgICAgaWYgKGNhbGxlZVR5cGUgaW5zdGFuY2VvZiBGbilcbiAgICAgICAgICAgIHJldHVybiBjYWxsZWVUeXBlLmFyZ3NbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFJldHVyblN0YXRlbWVudDogZnVuY3Rpb24oX3BhcmVudCwgbm9kZSwgZ2V0KSB7XG4gICAgICAvLyB0d2Vha2luZyBzZWFyY2ggcG9zaXRpb24gdG8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb25cbiAgICAgIC8vIHdoZW4gbG9va2luZyBmb3IgZGVmaW5pdGlvbiBvZiBrZXkgaW4gZm4gKCByZXR1cm4gZm4gKCByZXR1cm4gb2JqZWN0ICkgKVxuICAgICAgLy8gc2VlIHRlcm5qcy90ZXJuIzc3N1xuICAgICAgdmFyIGZuTm9kZSA9IHdhbGsuZmluZE5vZGVBcm91bmQobm9kZS5zb3VyY2VGaWxlLmFzdCwgbm9kZS5zdGFydCAtIDEsIFwiRnVuY3Rpb25cIik7XG4gICAgICBpZiAoZm5Ob2RlKSB7XG4gICAgICAgIHZhciBmblR5cGUgPSBmbk5vZGUubm9kZS50eXBlICE9IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiXG4gICAgICAgICAgPyBnZXQoZm5Ob2RlLm5vZGUsIHRydWUpLmdldEZ1bmN0aW9uVHlwZSgpXG4gICAgICAgICAgOiBmbk5vZGUubm9kZS5zY29wZS5mblR5cGU7XG4gICAgICAgIGlmIChmblR5cGUpIHJldHVybiBmblR5cGUucmV0dmFsLmdldFR5cGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24ocGFyZW50LCBub2RlLCBnZXQpIHtcbiAgICAgIGlmIChwYXJlbnQuaW5pdCA9PSBub2RlKSByZXR1cm4gZ2V0KHBhcmVudC5pZCk7XG4gICAgfVxuICB9O1xuICBmaW5kVHlwZUZyb21Db250ZXh0Lk5ld0V4cHJlc3Npb24gPSBmaW5kVHlwZUZyb21Db250ZXh0LkNhbGxFeHByZXNzaW9uO1xuXG4gIGV4cG9ydHMudHlwZUZyb21Db250ZXh0ID0gZnVuY3Rpb24oYXN0LCBmb3VuZCkge1xuICAgIHZhciBwYXJlbnQgPSBleHBvcnRzLnBhcmVudE5vZGUoZm91bmQubm9kZSwgYXN0KTtcbiAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgaWYgKGZpbmRUeXBlRnJvbUNvbnRleHQuaGFzT3duUHJvcGVydHkocGFyZW50LnR5cGUpKSB7XG4gICAgICB2YXIgZmluZGVyID0gZmluZFR5cGVGcm9tQ29udGV4dFtwYXJlbnQudHlwZV07XG4gICAgICB0eXBlID0gZmluZGVyICYmIGZpbmRlcihwYXJlbnQsIGZvdW5kLm5vZGUsIGZ1bmN0aW9uKG5vZGUsIGZyb21Db250ZXh0KSB7XG4gICAgICAgIHZhciBvYmogPSB7bm9kZTogbm9kZSwgc3RhdGU6IGZvdW5kLnN0YXRlfTtcbiAgICAgICAgdmFyIHRwID0gZnJvbUNvbnRleHQgPyBleHBvcnRzLnR5cGVGcm9tQ29udGV4dChhc3QsIG9iaikgOiBleHBvcnRzLmV4cHJlc3Npb25UeXBlKG9iaik7XG4gICAgICAgIHJldHVybiB0cCB8fCBBTnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSB8fCBleHBvcnRzLmV4cHJlc3Npb25UeXBlKGZvdW5kKTtcbiAgfTtcblxuICAvLyBGbGFnIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBzb21lIHdpbGQgZ3Vlc3Npbmcgd2FzIHVzZWQgdG8gcHJvZHVjZVxuICAvLyBhIHR5cGUgb3Igc2V0IG9mIGNvbXBsZXRpb25zLlxuICB2YXIgZ3Vlc3NpbmcgPSBmYWxzZTtcblxuICBleHBvcnRzLnJlc2V0R3Vlc3NpbmcgPSBmdW5jdGlvbih2YWwpIHsgZ3Vlc3NpbmcgPSB2YWw7IH07XG4gIGV4cG9ydHMuZGlkR3Vlc3MgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGd1ZXNzaW5nOyB9O1xuXG4gIGV4cG9ydHMuZm9yQWxsUHJvcGVydGllc09mID0gZnVuY3Rpb24odHlwZSwgZikge1xuICAgIHR5cGUuZ2F0aGVyUHJvcGVydGllcyhmLCAwKTtcbiAgfTtcblxuICBleHBvcnRzLmZpbmRSZWZzID0gZnVuY3Rpb24oYXN0LCBiYXNlU2NvcGUsIG5hbWUsIHJlZlNjb3BlLCBmKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlSWQobm9kZSwgc2NvcGUsIGFuY2VzdG9ycykge1xuICAgICAgdmFyIHBhcmVudCA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMl07XG4gICAgICBpZiAocGFyZW50LnR5cGUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIXBhcmVudC5jb21wdXRlZCAmJiAhIW5vZGUub2JqZWN0KSByZXR1cm47XG4gICAgICBpZiAobm9kZS5uYW1lICE9IG5hbWUgfHxcbiAgICAgICAgICAobm9kZSA9PSBhc3QuaWQgJiYgYXN0LnR5cGUgPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpKSByZXR1cm47XG4gICAgICBpZiAocGFyZW50LnByb3BlcnR5ID09PSBub2RlKSByZXR1cm47XG4gICAgICBmb3IgKHZhciBzID0gc2NvcGU7IHM7IHMgPSBzLnByZXYpIHtcbiAgICAgICAgaWYgKHMgPT0gcmVmU2NvcGUpIGYobm9kZSwgc2NvcGUsIGFuY2VzdG9ycyk7XG4gICAgICAgIGlmIChuYW1lIGluIHMucHJvcHMpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgd2Fsay5hbmNlc3Rvcihhc3QsIHtJZGVudGlmaWVyOiBoYW5kbGVJZCwgVmFyaWFibGVQYXR0ZXJuOiBoYW5kbGVJZH0sXG4gICAgICAgICAgICAgICAgICBleHBvcnRzLmZ1bGxWaXNpdG9yLCBiYXNlU2NvcGUpO1xuICB9O1xuXG4gIHZhciBzaW1wbGVXYWxrZXIgPSB3YWxrLm1ha2Uoe1xuICAgIEZ1bmN0aW9uOiBmdW5jdGlvbihub2RlLCBfc2NvcGUsIGMpIHtcbiAgICAgIGMobm9kZS5ib2R5LCBub2RlLnNjb3BlLCBub2RlLmV4cHJlc3Npb24gPyBcIkV4cHJlc3Npb25cIiA6IFwiU3RhdGVtZW50XCIpO1xuICAgIH0sXG4gICAgU3RhdGVtZW50OiBmdW5jdGlvbihub2RlLCBzY29wZSwgYykge1xuICAgICAgYyhub2RlLCBub2RlLnNjb3BlIHx8IHNjb3BlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV4cG9ydHMuZmluZFByb3BSZWZzID0gZnVuY3Rpb24oYXN0LCBzY29wZSwgb2JqVHlwZSwgbmFtZSwgZikge1xuICAgIC8vIEZpbmQgdGhlIHR5cGUgd2hpY2ggb3ducyB0aGUgcHJvcGVydHkgaW4gaGllcmFyY2h5XG4gICAgd2hpbGUgKG9ialR5cGUgJiYgIW9ialR5cGUucHJvcHNbbmFtZV0gJiYgIShvYmpUeXBlLm1heWJlUHJvcHMgJiYgb2JqVHlwZS5tYXliZVByb3BzW25hbWVdKSkge1xuICAgICAgb2JqVHlwZSA9IG9ialR5cGUucHJvdG87XG4gICAgfVxuICAgIGlmICghb2JqVHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9jYXRlIHByb3BlcnR5IGluIHRoZSBiYXNlIG9iamVjdCB0eXBlLlwiKTtcblxuICAgIGZ1bmN0aW9uIGlzT2JqVHlwZVByb3RvKHR5cGUpIHtcbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGZvdW5kIHR5cGUgaGFzIG9ialR5cGUgaW4gaXRzIGhpZXJhcmNoeVxuICAgICAgd2hpbGUgKHR5cGUgJiYgdHlwZSAhPSBvYmpUeXBlKSB7XG4gICAgICAgIC8vIEZmIHByb3BlcnR5IGlzIG92ZXJyaWRlbiBoaWdoZXIgaW4gdGhlIGhpZXJhcmNoeSwgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICh0eXBlLnByb3BzW25hbWVdIHx8ICh0eXBlLm1heWJlUHJvcHMgJiYgdHlwZS5tYXliZVByb3BzW25hbWVdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdHlwZS5wcm90bztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHdhbGsuc2ltcGxlKGFzdCwge1xuICAgICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQgfHwgcHJvcE5hbWUobm9kZSkgIT0gbmFtZSkgcmV0dXJuO1xuICAgICAgICBpZiAoaXNPYmpUeXBlUHJvdG8oZmluZFR5cGUobm9kZS5vYmplY3QsIHNjb3BlKS5nZXRUeXBlKCkpKSBmKG5vZGUucHJvcGVydHksIHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICBPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgICBpZiAoZmluZFR5cGUobm9kZSwgc2NvcGUpLmdldFR5cGUoKSAhPSBvYmpUeXBlKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChwcm9wTmFtZShub2RlLnByb3BlcnRpZXNbaV0pID09IG5hbWUpIGYobm9kZS5wcm9wZXJ0aWVzW2ldLmtleSwgc2NvcGUpO1xuICAgICAgfSxcbiAgICAgIE1ldGhvZERlZmluaXRpb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lKG5vZGUpICE9IG5hbWUpIHJldHVybjtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUgJiYgaXNPYmpUeXBlUHJvdG8oZ2V0VGhpcyhub2RlLnZhbHVlLnNjb3BlKS5nZXRUeXBlKCkpKSBmKG5vZGUua2V5LCBub2RlLnZhbHVlLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9LCBzaW1wbGVXYWxrZXIsIHNjb3BlKTtcbiAgfTtcblxuICAvLyBMT0NBTC1WQVJJQUJMRSBRVUVSSUVTXG5cbiAgdmFyIHNjb3BlQXQgPSBleHBvcnRzLnNjb3BlQXQgPSBmdW5jdGlvbihhc3QsIHBvcywgZGVmYXVsdFNjb3BlKSB7XG4gICAgdmFyIGZvdW5kID0gd2Fsay5maW5kTm9kZUFyb3VuZChhc3QsIHBvcywgZnVuY3Rpb24oXywgbm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuc2NvcGU7XG4gICAgfSk7XG4gICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQubm9kZS5zY29wZTtcbiAgICBlbHNlIHJldHVybiBkZWZhdWx0U2NvcGUgfHwgY3gudG9wU2NvcGU7XG4gIH07XG5cbiAgZXhwb3J0cy5mb3JBbGxMb2NhbHNBdCA9IGZ1bmN0aW9uKGFzdCwgcG9zLCBkZWZhdWx0U2NvcGUsIGYpIHtcbiAgICB2YXIgc2NvcGUgPSBzY29wZUF0KGFzdCwgcG9zLCBkZWZhdWx0U2NvcGUpO1xuICAgIHNjb3BlLmdhdGhlclByb3BlcnRpZXMoZiwgMCk7XG4gIH07XG5cbiAgLy8gSU5JVCBERUYgTU9EVUxFXG5cbiAgLy8gRGVsYXllZCBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIGN5Y2xpYyBkZXBlbmRlbmNpZXMuXG4gIGRlZiA9IGV4cG9ydHMuZGVmID0gZGVmLmluaXQoe30sIGV4cG9ydHMpO1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tern/lib/infer.js\n");

/***/ }),

/***/ "./node_modules/tern/lib/signal.js":
/*!*****************************************!*\
  !*** ./node_modules/tern/lib/signal.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, mod) {\n  if (true) // CommonJS\n    return mod(exports);\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env\n})(this, function(exports) {\n\n  function on(type, f) {\n    var handlers = this._handlers || (this._handlers = Object.create(null));\n    (handlers[type] || (handlers[type] = [])).push(f);\n  }\n\n  function off(type, f) {\n    var arr = this._handlers && this._handlers[type];\n    if (arr) for (var i = 0; i < arr.length; ++i)\n      if (arr[i] == f) { arr.splice(i, 1); break; }\n  }\n\n  var noHandlers = [];\n  function getHandlers(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length ? arr.slice() : noHandlers;\n  }\n\n  function signal(type, a1, a2, a3, a4) {\n    var arr = getHandlers(this, type);\n    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4);\n  }\n\n  function signalReturnFirst(type, a1, a2, a3, a4) {\n    var arr = getHandlers(this, type);\n    for (var i = 0; i < arr.length; ++i) {\n      var result = arr[i].call(this, a1, a2, a3, a4);\n      if (result) return result;\n    }\n  }\n\n  function hasHandler(type) {\n    var arr = this._handlers && this._handlers[type];\n    return arr && arr.length > 0 && arr;\n  }\n\n  exports.mixin = function(obj) {\n    obj.on = on; obj.off = off;\n    obj.signal = signal;\n    obj.signalReturnFirst = signalReturnFirst;\n    obj.hasHandler = hasHandler;\n    return obj;\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9saWIvc2lnbmFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rlcm4vbGliL3NpZ25hbC5qcz9hYTk5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihyb290LCBtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIHJldHVybiBtb2QoZXhwb3J0cyk7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICByZXR1cm4gZGVmaW5lKFtcImV4cG9ydHNcIl0sIG1vZCk7XG4gIG1vZCgocm9vdC50ZXJuIHx8IChyb290LnRlcm4gPSB7fSkpLnNpZ25hbCA9IHt9KTsgLy8gUGxhaW4gYnJvd3NlciBlbnZcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcblxuICBmdW5jdGlvbiBvbih0eXBlLCBmKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMgfHwgKHRoaXMuX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgKGhhbmRsZXJzW3R5cGVdIHx8IChoYW5kbGVyc1t0eXBlXSA9IFtdKSkucHVzaChmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZih0eXBlLCBmKSB7XG4gICAgdmFyIGFyciA9IHRoaXMuX2hhbmRsZXJzICYmIHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuICAgIGlmIChhcnIpIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKGFycltpXSA9PSBmKSB7IGFyci5zcGxpY2UoaSwgMSk7IGJyZWFrOyB9XG4gIH1cblxuICB2YXIgbm9IYW5kbGVycyA9IFtdO1xuICBmdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKSB7XG4gICAgdmFyIGFyciA9IGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdO1xuICAgIHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA/IGFyci5zbGljZSgpIDogbm9IYW5kbGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbCh0eXBlLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgIHZhciBhcnIgPSBnZXRIYW5kbGVycyh0aGlzLCB0eXBlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgYXJyW2ldLmNhbGwodGhpcywgYTEsIGEyLCBhMywgYTQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsUmV0dXJuRmlyc3QodHlwZSwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICB2YXIgYXJyID0gZ2V0SGFuZGxlcnModGhpcywgdHlwZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciByZXN1bHQgPSBhcnJbaV0uY2FsbCh0aGlzLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0hhbmRsZXIodHlwZSkge1xuICAgIHZhciBhcnIgPSB0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXTtcbiAgICByZXR1cm4gYXJyICYmIGFyci5sZW5ndGggPiAwICYmIGFycjtcbiAgfVxuXG4gIGV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBvYmoub24gPSBvbjsgb2JqLm9mZiA9IG9mZjtcbiAgICBvYmouc2lnbmFsID0gc2lnbmFsO1xuICAgIG9iai5zaWduYWxSZXR1cm5GaXJzdCA9IHNpZ25hbFJldHVybkZpcnN0O1xuICAgIG9iai5oYXNIYW5kbGVyID0gaGFzSGFuZGxlcjtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tern/lib/signal.js\n");

/***/ }),

/***/ "./node_modules/tern/lib/tern.js":
/*!***************************************!*\
  !*** ./node_modules/tern/lib/tern.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// The Tern server object\n\n// A server is a stateful object that manages the analysis for a\n// project, and defines an interface for querying the code in the\n// project.\n\n(function(root, mod) {\n  if (true) // CommonJS\n    return mod(exports, __webpack_require__(/*! ./infer */ \"./node_modules/tern/lib/infer.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\"),\n               __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.mjs\"), __webpack_require__(/*! acorn-walk */ \"./node_modules/tern/node_modules/acorn-walk/dist/walk.mjs\"));\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./infer */ \"./node_modules/tern/lib/infer.js\"), __webpack_require__(/*! ./signal */ \"./node_modules/tern/lib/signal.js\"), __webpack_require__(/*! acorn/dist/acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.js\"), __webpack_require__(/*! acorn-walk/dist/walk */ \"./node_modules/tern/node_modules/acorn-walk/dist/walk.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env\n})(this, function(exports, infer, signal, acorn, walk) {\n  \"use strict\";\n\n  var plugins = Object.create(null);\n  exports.registerPlugin = function(name, init) { plugins[name] = init; };\n\n  var defaultOptions = exports.defaultOptions = {\n    debug: false,\n    async: false,\n    getFile: function(_f, c) { if (this.async) c(null, null); },\n    normalizeFilename: function(name) { return name },\n    defs: [],\n    plugins: {},\n    fetchTimeout: 1000,\n    dependencyBudget: 20000,\n    reuseInstances: true,\n    stripCRs: false,\n    ecmaVersion: 9,\n    projectDir: \"/\",\n    parent: null\n  };\n\n  var queryTypes = {\n    completions: {\n      takesFile: true,\n      run: findCompletions\n    },\n    properties: {\n      run: findProperties\n    },\n    type: {\n      takesFile: true,\n      run: findTypeAt\n    },\n    documentation: {\n      takesFile: true,\n      run: findDocs\n    },\n    definition: {\n      takesFile: true,\n      run: findDef\n    },\n    refs: {\n      takesFile: true,\n      fullFile: true,\n      run: findRefs\n    },\n    rename: {\n      takesFile: true,\n      fullFile: true,\n      run: buildRename\n    },\n    files: {\n      run: listFiles\n    }\n  };\n\n  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };\n\n  function File(name, parent) {\n    this.name = name;\n    this.parent = parent;\n    this.scope = this.text = this.ast = this.lineOffsets = null;\n  }\n  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };\n\n  function parseFile(srv, file) {\n    var options = {\n      directSourceFile: file,\n      allowReturnOutsideFunction: true,\n      allowImportExportEverywhere: true,\n      ecmaVersion: srv.options.ecmaVersion,\n      allowHashBang: true\n    };\n    var text = srv.signalReturnFirst(\"preParse\", file.text, options) || file.text;\n    var ast = infer.parse(text, options);\n    srv.signal(\"postParse\", ast, text);\n    return ast;\n  }\n\n  var astral = /[\\uD800-\\uDBFF]/g;\n\n  function updateText(file, text, srv) {\n    file.text = srv.options.stripCRs ? text.replace(/\\r\\n/g, \"\\n\") : text;\n    file.hasAstral = astral.test(file.text);\n    infer.withContext(srv.cx, function() {\n      file.ast = parseFile(srv, file);\n    });\n    file.lineOffsets = null;\n  }\n\n  var Server = exports.Server = function(options) {\n    this.cx = null;\n    this.options = options || {};\n    for (var o in defaultOptions) if (!options.hasOwnProperty(o))\n      options[o] = defaultOptions[o];\n\n    this.projectDir = options.projectDir.replace(/\\\\/g, \"/\");\n    if (!/\\/$/.test(this.projectDir)) this.projectDir += \"/\";\n\n    this.parent = options.parent;\n    this.handlers = Object.create(null);\n    this.files = [];\n    this.fileMap = Object.create(null);\n    this.needsPurge = [];\n    this.budgets = Object.create(null);\n    this.uses = 0;\n    this.pending = 0;\n    this.asyncError = null;\n    this.mod = {};\n\n    this.defs = options.defs.slice(0);\n    this.plugins = Object.create(null);\n    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))\n      this.loadPlugin(plugin, options.plugins[plugin]);\n\n    this.reset();\n  };\n  Server.prototype = signal.mixin({\n    addFile: function(name, /*optional*/ text, parent) {\n      // Don't crash when sloppy plugins pass non-existent parent ids\n      if (parent && !(parent in this.fileMap)) parent = null;\n      if (!(name in this.fileMap))\n        name = this.normalizeFilename(name);\n      ensureFile(this, name, parent, text);\n    },\n    delFile: function(name) {\n      var file = this.findFile(name);\n      if (file) {\n        this.needsPurge.push(file.name);\n        for (var i = 0; i < this.files.length; i++) {\n          if (this.files[i] == file) this.files.splice(i--, 1);\n          else if (this.files[i].parent == name) this.files[i].parent = null;\n        }\n        delete this.fileMap[file.name];\n      }\n    },\n    reset: function() {\n      this.signal(\"reset\");\n      this.cx = new infer.Context(this.defs, this);\n      this.uses = 0;\n      this.budgets = Object.create(null);\n      for (var i = 0; i < this.files.length; ++i) {\n        var file = this.files[i];\n        if (file.scope) {\n          infer.clearScopes(file.ast);\n          file.scope = null;\n        }\n      }\n      this.signal(\"postReset\");\n    },\n\n    request: function(doc, c) {\n      var inv = invalidDoc(doc);\n      if (inv) return c(inv);\n\n      var self = this;\n      doRequest(this, doc, function(err, data) {\n        c(err, data);\n        if (self.uses > 40) {\n          self.reset();\n          analyzeAll(self, null, function(){});\n        }\n      });\n    },\n\n    findFile: function(name) {\n      return this.fileMap[this.normalizeFilename(name)];\n    },\n\n    flush: function(c) {\n      var cx = this.cx;\n      analyzeAll(this, null, function(err) {\n        if (err) return c(err);\n        infer.withContext(cx, c);\n      });\n    },\n\n    startAsyncAction: function() {\n      ++this.pending;\n    },\n    finishAsyncAction: function(err) {\n      if (err) this.asyncError = err;\n      if (--this.pending === 0) this.signal(\"everythingFetched\");\n    },\n\n    addDefs: function(defs, toFront) {\n      if (toFront) this.defs.unshift(defs);\n      else this.defs.push(defs);\n\n      if (this.cx) this.reset();\n    },\n\n    deleteDefs: function(name) {\n      for (var i = 0; i < this.defs.length; i++) if (this.defs[i][\"!name\"] == name) {\n        this.defs.splice(i, 1);\n        if (this.cx) this.reset();\n        return;\n      }\n    },\n\n    loadPlugin: function(name, options) {\n      if (arguments.length == 1) options = this.options.plugins[name] || true;\n      if (name in this.plugins || !(name in plugins) || !options) return;\n      this.plugins[name] = true;\n      var init = plugins[name](this, options);\n\n      // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly\n      if (!init) return;\n      if (init.defs) this.addDefs(init.defs, init.loadFirst);\n      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))\n        this.on(type, init.passes[type]);\n    },\n\n    normalizeFilename: function(name) {\n      var norm = this.options.normalizeFilename(name).replace(/\\\\/g, \"/\");\n      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length);\n      return norm;\n    }\n  });\n\n  function doRequest(srv, doc, c) {\n    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))\n      return c(\"No query type '\" + doc.query.type + \"' defined\");\n\n    var query = doc.query;\n    // Respond as soon as possible when this just uploads files\n    if (!query) c(null, {});\n\n    var files = doc.files || [];\n    if (files.length) ++srv.uses;\n    for (var i = 0; i < files.length; ++i) {\n      var file = files[i];\n      file.name = srv.normalizeFilename(file.name);\n      if (file.type == \"delete\")\n        srv.delFile(file.name);\n      else\n        ensureFile(srv, file.name, null, file.type == \"full\" ? file.text : null);\n    }\n\n    var timeBudget = typeof doc.timeout == \"number\" ? [doc.timeout] : null;\n    if (!query) {\n      analyzeAll(srv, timeBudget, function(){});\n      return;\n    }\n\n    var queryType = queryTypes[query.type];\n    if (queryType.takesFile) {\n      if (typeof query.file != \"string\") return c(\".query.file must be a string\");\n      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);\n    }\n\n    analyzeAll(srv, timeBudget, function(err) {\n      if (err) return c(err);\n      var file = queryType.takesFile && resolveFile(srv, files, query.file);\n      if (queryType.fullFile && file.type == \"part\")\n        return c(\"Can't run a \" + query.type + \" query on a file fragment\");\n\n      infer.resetGuessing();\n      infer.withContext(srv.cx, function() {\n        var result, run = function() { result = queryType.run(srv, query, file); };\n        try {\n          if (timeBudget) infer.withTimeout(timeBudget[0], run);\n          else run();\n        } catch (e) {\n          if (srv.options.debug && e.name != \"TernError\") console.error(e.stack);\n          return c(e);\n        }\n        c(null, result);\n      });\n    });\n  }\n\n  function analyzeFile(srv, file) {\n    infer.withContext(srv.cx, function() {\n      file.scope = srv.cx.topScope;\n      srv.signal(\"beforeLoad\", file);\n      infer.analyze(file.ast, file.name, file.scope);\n      srv.signal(\"afterLoad\", file);\n    });\n    return file;\n  }\n\n  function ensureFile(srv, name, parent, text) {\n    var known = srv.findFile(name);\n    if (known) {\n      if (text != null) {\n        if (known.scope) {\n          srv.needsPurge.push(name);\n          infer.clearScopes(known.ast);\n          known.scope = null;\n        }\n        updateText(known, text, srv);\n      }\n      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {\n        known.parent = parent;\n        if (known.excluded) known.excluded = null;\n      }\n      return;\n    }\n\n    var file = new File(name, parent);\n    srv.files.push(file);\n    srv.fileMap[name] = file;\n    if (text != null) {\n      updateText(file, text, srv);\n    } else if (srv.options.async) {\n      srv.startAsyncAction();\n      srv.options.getFile(name, function(err, text) {\n        updateText(file, text || \"\", srv);\n        srv.finishAsyncAction(err);\n      });\n    } else {\n      updateText(file, srv.options.getFile(name) || \"\", srv);\n    }\n  }\n\n  function fetchAll(srv, c) {\n    var done = true, returned = false;\n    srv.files.forEach(function(file) {\n      if (file.text != null) return;\n      if (srv.options.async) {\n        done = false;\n        srv.options.getFile(file.name, function(err, text) {\n          if (err && !returned) { returned = true; return c(err); }\n          updateText(file, text || \"\", srv);\n          fetchAll(srv, c);\n        });\n      } else {\n        try {\n          updateText(file, srv.options.getFile(file.name) || \"\", srv);\n        } catch (e) { return c(e); }\n      }\n    });\n    if (done) c();\n  }\n\n  function waitOnFetch(srv, timeBudget, c) {\n    var done = function() {\n      srv.off(\"everythingFetched\", done);\n      clearTimeout(timeout);\n      analyzeAll(srv, timeBudget, c);\n    };\n    srv.on(\"everythingFetched\", done);\n    var timeout = setTimeout(done, srv.options.fetchTimeout);\n  }\n\n  function analyzeAll(srv, timeBudget, c) {\n    if (srv.pending) return waitOnFetch(srv, timeBudget, c);\n\n    var e = srv.fetchError;\n    if (e) { srv.fetchError = null; return c(e); }\n\n    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {\n      infer.purge(srv.needsPurge);\n      srv.needsPurge.length = 0;\n    });\n\n    var done = true;\n    // The second inner loop might add new files. The outer loop keeps\n    // repeating both inner loops until all files have been looked at.\n    for (var i = 0; i < srv.files.length;) {\n      var toAnalyze = [];\n      for (; i < srv.files.length; ++i) {\n        var file = srv.files[i];\n        if (file.text == null) done = false;\n        else if (file.scope == null && !file.excluded) toAnalyze.push(file);\n      }\n      toAnalyze.sort(function(a, b) {\n        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);\n      });\n      for (var j = 0; j < toAnalyze.length; j++) {\n        var file = toAnalyze[j];\n        if (file.parent && !chargeOnBudget(srv, file)) {\n          file.excluded = true;\n        } else if (timeBudget) {\n          var startTime = +new Date;\n          try {\n            infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });\n          } catch(e) {\n            if (e instanceof infer.TimedOut) return c(e);\n            else throw e;\n          }\n          timeBudget[0] -= +new Date - startTime;\n        } else {\n          analyzeFile(srv, file);\n        }\n      }\n    }\n    if (done) c();\n    else waitOnFetch(srv, timeBudget, c);\n  }\n\n  function firstLine(str) {\n    var end = str.indexOf(\"\\n\");\n    if (end < 0) return str;\n    return str.slice(0, end);\n  }\n\n  function findMatchingPosition(line, file, near) {\n    var pos = Math.max(0, near - 500), closest = null;\n    if (!/^\\s*$/.test(line)) for (;;) {\n      var found = file.indexOf(line, pos);\n      if (found < 0 || found > near + 500) break;\n      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))\n        closest = found;\n      pos = found + line.length;\n    }\n    return closest;\n  }\n\n  function scopeDepth(s) {\n    for (var i = 0; s; ++i, s = s.prev) {}\n    return i;\n  }\n\n  function ternError(msg) {\n    var err = new Error(msg);\n    err.name = \"TernError\";\n    return err;\n  }\n\n  function resolveFile(srv, localFiles, name) {\n    var isRef = name.match(/^#(\\d+)$/);\n    if (!isRef) return srv.findFile(name);\n\n    var file = localFiles[isRef[1]];\n    if (!file || file.type == \"delete\") throw ternError(\"Reference to unknown file \" + name);\n    if (file.type == \"full\") return srv.fileMap[file.name];\n\n    // This is a partial file\n\n    var realFile = file.backing = srv.fileMap[file.name];\n    var offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);\n    var line = firstLine(file.text);\n    var foundPos = findMatchingPosition(line, realFile.text, offset);\n    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf(\"\\n\", offset)) : foundPos;\n    var inObject, atFunction;\n\n    infer.withContext(srv.cx, function() {\n      infer.purge(file.name, pos, pos + file.text.length);\n\n      var text = file.text, m;\n      if (m = text.match(/(?:\"([^\"]*)\"|([\\w$]+))\\s*:\\s*function\\b/)) {\n        var objNode = walk.findNodeAround(file.backing.ast, pos, \"ObjectExpression\");\n        if (objNode && objNode.node.objType)\n          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};\n      }\n      if (foundPos && (m = line.match(/^(.*?)\\bfunction\\b/))) {\n        var cut = m[1].length, white = \"\";\n        for (var i = 0; i < cut; ++i) white += \" \";\n        file.text = white + text.slice(cut);\n        atFunction = true;\n      }\n\n      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);\n      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);\n      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;\n      file.ast = parseFile(srv, file);\n      infer.analyze(file.ast, file.name, scope);\n\n      // This is a kludge to tie together the function types (if any)\n      // outside and inside of the fragment, so that arguments and\n      // return values have some information known about them.\n      tieTogether: {\n        if (inObject || atFunction) {\n          var newInner = infer.scopeAt(file.ast, line.length, scopeStart);\n          if (!newInner.fnType) break tieTogether;\n          if (inObject) {\n            var prop = inObject.type.getProp(inObject.prop);\n            prop.addType(newInner.fnType);\n          } else if (atFunction) {\n            var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);\n            if (inner == scopeStart || !inner.fnType) break tieTogether;\n            var fOld = inner.fnType, fNew = newInner.fnType;\n            if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;\n            for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)\n              fOld.args[i].propagate(fNew.args[i]);\n            fOld.self.propagate(fNew.self);\n            fNew.retval.propagate(fOld.retval);\n          }\n        }\n      }\n    });\n    return file;\n  }\n\n  // Budget management\n\n  function astSize(node) {\n    var size = 0;\n    walk.simple(node, {Expression: function() { ++size; }});\n    return size;\n  }\n\n  function parentDepth(srv, parent) {\n    var depth = 0;\n    while (parent) {\n      parent = srv.fileMap[parent].parent;\n      ++depth;\n    }\n    return depth;\n  }\n\n  function budgetName(srv, file) {\n    for (;;) {\n      var parent = srv.fileMap[file.parent];\n      if (!parent.parent) break;\n      file = parent;\n    }\n    return file.name;\n  }\n\n  function chargeOnBudget(srv, file) {\n    var bName = budgetName(srv, file);\n    var size = astSize(file.ast);\n    var known = srv.budgets[bName];\n    if (known == null)\n      known = srv.budgets[bName] = srv.options.dependencyBudget;\n    if (known < size) return false;\n    srv.budgets[bName] = known - size;\n    return true;\n  }\n\n  // Query helpers\n\n  function isPosition(val) {\n    return typeof val == \"number\" || typeof val == \"object\" &&\n      typeof val.line == \"number\" && typeof val.ch == \"number\";\n  }\n\n  // Baseline query document validation\n  function invalidDoc(doc) {\n    if (doc.query) {\n      if (typeof doc.query.type != \"string\") return \".query.type must be a string\";\n      if (doc.query.start && !isPosition(doc.query.start)) return \".query.start must be a position\";\n      if (doc.query.end && !isPosition(doc.query.end)) return \".query.end must be a position\";\n    }\n    if (doc.files) {\n      if (!Array.isArray(doc.files)) return \"Files property must be an array\";\n      for (var i = 0; i < doc.files.length; ++i) {\n        var file = doc.files[i];\n        if (typeof file != \"object\") return \".files[n] must be objects\";\n        else if (typeof file.name != \"string\") return \".files[n].name must be a string\";\n        else if (file.type == \"delete\") continue;\n        else if (typeof file.text != \"string\") return \".files[n].text must be a string\";\n        else if (file.type == \"part\") {\n          if (!isPosition(file.offset) && typeof file.offsetLines != \"number\")\n            return \".files[n].offset must be a position\";\n        } else if (file.type != \"full\") return \".files[n].type must be \\\"full\\\" or \\\"part\\\"\";\n      }\n    }\n  }\n\n  var offsetSkipLines = 25;\n\n  function forwardCharacters(file, start, chars) {\n    var pos = start + chars, m;\n    if (file.hasAstral) {\n      astral.lastIndex = start;\n      while ((m = astral.exec(file.text)) && m.index < pos) pos++;\n    }\n    return pos;\n  }\n\n  function findLineStart(file, line) {\n    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var pos = 0, curLine = 0;\n    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);\n    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;\n\n    while (curLine < line) {\n      ++curLine;\n      pos = text.indexOf(\"\\n\", pos) + 1;\n      if (pos === 0) return null;\n      if (curLine % offsetSkipLines === 0) offsets.push(pos);\n    }\n    return pos;\n  }\n\n  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {\n    if (typeof pos != \"number\") {\n      var lineStart = findLineStart(file, pos.line);\n      if (lineStart == null) {\n        if (tolerant) pos = file.text.length;\n        else throw ternError(\"File doesn't contain a line \" + pos.line);\n      } else {\n        pos = forwardCharacters(file, lineStart, pos.ch);\n      }\n    } else {\n      pos = forwardCharacters(file, 0, pos);\n    }\n    if (pos > file.text.length) {\n      if (tolerant) pos = file.text.length;\n      else throw ternError(\"Position \" + pos + \" is outside of file.\");\n    }\n    return pos;\n  };\n\n  function charDistanceBetween(file, start, end) {\n    var diff = end - start, m;\n    if (file.hasAstral) {\n      astral.lastIndex = start;\n      while ((m = astral.exec(file.text)) && m.index < end) diff--;\n    }\n    return diff;\n  }\n\n  function asLineChar(file, pos) {\n    if (!file) return {line: 0, ch: 0};\n    var offsets = file.lineOffsets || (file.lineOffsets = [0]);\n    var text = file.text, line, lineStart;\n    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {\n      line = i * offsetSkipLines;\n      lineStart = offsets[i];\n    }\n    for (;;) {\n      var eol = text.indexOf(\"\\n\", lineStart);\n      if (eol >= pos || eol < 0) break;\n      lineStart = eol + 1;\n      ++line;\n    }\n    return {line: line, ch: charDistanceBetween(file, lineStart, pos)};\n  }\n\n  var outputPos = exports.outputPos = function(query, file, pos) {\n    if (query.lineCharPositions) {\n      var out = asLineChar(file, pos);\n      if (file.type == \"part\")\n        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;\n      return out;\n    } else {\n      return charDistanceBetween(file, 0, pos) + (file.type == \"part\" ? file.offset : 0);\n    }\n  };\n\n  // Delete empty fields from result objects\n  function clean(obj) {\n    for (var prop in obj) if (obj[prop] == null) delete obj[prop];\n    return obj;\n  }\n  function maybeSet(obj, prop, val) {\n    if (val != null) obj[prop] = val;\n  }\n\n  // Built-in query types\n\n  function compareCompletions(a, b) {\n    if (typeof a != \"string\") { a = a.name; b = b.name; }\n    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);\n    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;\n    else return aUp ? 1 : -1;\n  }\n\n  function isStringAround(node, start, end) {\n    return node.type == \"Literal\" && typeof node.value == \"string\" &&\n      node.start == start - 1 && node.end <= end + 1;\n  }\n\n  function pointInProp(objNode, point) {\n    for (var i = 0; i < objNode.properties.length; i++) {\n      var curProp = objNode.properties[i];\n      if (curProp.key && curProp.key.start <= point && curProp.key.end >= point)\n        return curProp;\n    }\n  }\n\n  var jsKeywords = (\"break do instanceof typeof case else new var \" +\n    \"catch finally return void continue for switch while debugger \" +\n    \"function this with default if throw delete in try\").split(\" \");\n  var jsKeywordsES6 = jsKeywords.concat(\"export class extends const super yield import let static\".split(\" \"));\n\n  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {\n    var typeInfo = query.types || query.docs || query.urls || query.origins;\n    var wrapAsObjs = typeInfo || query.depths;\n\n    for (var i = 0; i < completions.length; ++i) {\n      var c = completions[i];\n      if ((wrapAsObjs ? c.name : c) == name) return;\n    }\n    var rec = wrapAsObjs ? {name: name} : name;\n    completions.push(rec);\n\n    if (aval && typeInfo) {\n      infer.resetGuessing();\n      var type = aval.getType();\n      rec.guess = infer.didGuess();\n      if (query.types)\n        rec.type = infer.toString(aval);\n      if (query.docs)\n        maybeSet(rec, \"doc\", parseDoc(query, aval.doc || type && type.doc));\n      if (query.urls)\n        maybeSet(rec, \"url\", aval.url || type && type.url);\n      if (query.origins)\n        maybeSet(rec, \"origin\", aval.origin || type && type.origin);\n    }\n    if (query.depths) rec.depth = depth || 0;\n    return rec;\n  };\n\n  function findCompletions(srv, query, file) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n    var fromPlugin = srv.signalReturnFirst(\"completion\", file, query);\n    if (fromPlugin) return fromPlugin;\n\n    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;\n    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;\n    if (query.expandWordForward !== false)\n      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;\n    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;\n    if (query.caseInsensitive) word = word.toLowerCase();\n\n    function gather(prop, obj, depth, addInfo) {\n      // 'hasOwnProperty' and such are usually just noise, leave them\n      // out when no prefix is provided.\n      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;\n      if (query.filter !== false && word &&\n          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;\n      if (ignoreObj && ignoreObj.props[prop]) return;\n      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);\n      if (addInfo && result && typeof result != \"string\") addInfo(result);\n    }\n\n    var hookname, prop, objType, isKey;\n\n    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);\n    var memberExpr, objLit;\n    // Decide whether this is an object property, either in a member\n    // expression or an object literal.\n    if (exprAt) {\n      var exprNode = exprAt.node;\n\n      if (query.inLiteral === false && exprNode.type === \"Literal\" &&\n          (typeof exprNode.value === 'string' || exprNode.regex))\n        return {\n          start: outputPos(query, file, wordStart),\n          end: outputPos(query, file, wordEnd),\n          completions: []\n        };\n\n      if (exprNode.type == \"MemberExpression\" && exprNode.object.end < wordStart) {\n        memberExpr = exprAt;\n      } else if (isStringAround(exprNode, wordStart, wordEnd)) {\n        var parent = infer.parentNode(exprNode, file.ast);\n        if (parent.type == \"MemberExpression\" && parent.property == exprNode)\n          memberExpr = {node: parent, state: exprAt.state};\n      } else if (exprNode.type == \"ObjectExpression\") {\n        var objProp = pointInProp(exprNode, wordEnd);\n        if (objProp) {\n          objLit = exprAt;\n          prop = isKey = objProp.key.name || objProp.key.value;\n        } else if (!word && !/:\\s*$/.test(file.text.slice(0, wordStart))) {\n          objLit = exprAt;\n          prop = isKey = true;\n        }\n      }\n    }\n\n    if (objLit) {\n      // Since we can't use the type of the literal itself to complete\n      // its properties (it doesn't contain the information we need),\n      // we have to try asking the surrounding expression for type info.\n      objType = infer.typeFromContext(file.ast, objLit);\n      ignoreObj = objLit.node.objType;\n    } else if (memberExpr) {\n      prop = memberExpr.node.property;\n      prop = prop.type == \"Literal\" ? prop.value.slice(1) : prop.name;\n      memberExpr.node = memberExpr.node.object;\n      objType = infer.expressionType(memberExpr);\n    } else if (text.charAt(wordStart - 1) == \".\") {\n      var pathStart = wordStart - 1;\n      while (pathStart && (text.charAt(pathStart - 1) == \".\" || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;\n      var path = text.slice(pathStart, wordStart - 1);\n      if (path) {\n        objType = infer.def.parsePath(path, file.scope).getObjType();\n        prop = word;\n      }\n    }\n\n    if (prop != null) {\n      srv.cx.completingProperty = prop;\n\n      if (objType) infer.forAllPropertiesOf(objType, gather);\n\n      if (!completions.length && query.guess !== false && objType && objType.guessProperties)\n        objType.guessProperties(function(p, o, d) {if (p != prop && p != \"\" && p != \"<i>\") gather(p, o, d);});\n      if (!completions.length && word.length >= 2 && query.guess !== false)\n        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);\n      hookname = \"memberCompletion\";\n    } else {\n      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);\n      if (query.includeKeywords) {\n        (srv.options.ecmaVersion >= 6 ? jsKeywordsES6 : jsKeywords).forEach(function(kw) {\n          gather(kw, null, 0, function(rec) { rec.isKeyword = true; });\n        });\n      }\n      hookname = \"variableCompletion\";\n    }\n    srv.signal(hookname, file, wordStart, wordEnd, gather);\n\n    if (query.sort !== false) completions.sort(compareCompletions);\n    srv.cx.completingProperty = null;\n\n    return {start: outputPos(query, file, wordStart),\n            end: outputPos(query, file, wordEnd),\n            isProperty: !!prop,\n            isObjectKey: !!isKey,\n            completions: completions};\n  }\n\n  function findProperties(srv, query) {\n    var prefix = query.prefix, found = [];\n    for (var prop in srv.cx.props)\n      if (prop != \"<i>\" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);\n    if (query.sort !== false) found.sort(compareCompletions);\n    return {completions: found};\n  }\n\n  function inBody(node, pos) {\n    var body = node.body, start, end;\n    if (!body) return false;\n    if (Array.isArray(body)) {\n      start = body[0].start;\n      end = body[body.length - 1].end;\n    } else {\n      start = body.start;\n      end = body.end;\n    }\n    return start <= pos && end >= pos;\n  }\n\n  var findExpr = exports.findQueryExpr = function(file, query, wide) {\n    if (query.end == null) throw ternError(\"missing .query.end field\");\n\n    if (query.variable) {\n      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);\n      return {node: {type: \"Identifier\", name: query.variable, start: query.end, end: query.end + 1},\n              state: scope};\n    } else {\n      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);\n      if (!expr) {\n        var span = infer.findClosestExpression(file.ast, start, end, file.scope);\n        if (span && !inBody(span.node, end) &&\n            (wide || (start == null ? end : start) - span.node.start < 20 || span.node.end - end < 20))\n          expr = span;\n      }\n      if (!expr) {\n        var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n        if (around && !inBody(around.node, end) &&\n            (around.node.type == \"ObjectExpression\" || wide ||\n             (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n          expr = around;\n      }\n      return expr;\n    }\n  };\n\n  function findExprAround(file, query, wide) {\n    var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);\n    var expr = null;\n    var around = infer.findExpressionAround(file.ast, start, end, file.scope);\n    if (around && !inBody(around.node, end) &&\n        (around.node.type == \"ObjectExpression\" || wide ||\n         (start == null ? end : start) - around.node.start < 20 || around.node.end - end < 20))\n      expr = around;\n    return expr;\n  }\n\n  function findExprOrThrow(file, query, wide) {\n    var expr = findExpr(file, query, wide);\n    if (expr) return expr;\n    throw ternError(\"No expression at the given position.\");\n  }\n\n  function ensureObj(tp) {\n    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;\n    return tp;\n  }\n\n  function findExprType(srv, query, file, expr) {\n    var type;\n    if (expr) {\n      infer.resetGuessing();\n      type = infer.expressionType(expr);\n    }\n    var typeHandlers = srv.hasHandler(\"typeAt\");\n    if (typeHandlers) {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < typeHandlers.length; i++)\n        type = typeHandlers[i](file, pos, expr, type);\n    }\n    if (!type) throw ternError(\"No type found at the given position.\");\n\n    var objProp;\n    if (expr.node.type == \"ObjectExpression\" && query.end != null &&\n        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {\n      var name = objProp.key.name;\n      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));\n      if (fromCx && fromCx.hasProp(name)) {\n        type = fromCx.hasProp(name);\n      } else {\n        var fromLocal = ensureObj(type);\n        if (fromLocal && fromLocal.hasProp(name))\n          type = fromLocal.hasProp(name);\n      }\n    }\n    return type;\n  }\n\n  function findTypeAtExpr(srv, query, file, expr) {\n    var exprName, exprType;\n    var type = findExprType(srv, query, file, expr), exprType = type;\n    if (query.preferFunction)\n      type = type.getFunctionType() || type.getType();\n    else\n      type = type.getType();\n\n    if (expr) {\n      if (expr.node.type == \"Identifier\")\n        exprName = expr.node.name;\n      else if (expr.node.type == \"MemberExpression\" && !expr.node.computed)\n        exprName = expr.node.property.name;\n      else if (expr.node.type == \"MethodDefinition\" && !expr.node.computed)\n        exprName = expr.node.key.name;\n    }\n\n    if (query.depth != null && typeof query.depth != \"number\")\n      throw ternError(\".query.depth must be a number\");\n\n    return [type, exprName, exprType];\n  }\n\n  function findTypeAt(srv, query, file) {\n    var type, exprName, exprType;\n    var expr = findExpr(file, query);\n    var typeResult = findTypeAtExpr(srv, query, file, expr);\n    type = typeResult[0];\n    if (!type) {\n      expr = findExprAround(file, query);\n      typeResult = findTypeAtExpr(srv, query, file, expr);\n      type = typeResult[0];\n    }\n    exprName = typeResult[1];\n    exprType = typeResult[2];\n\n    var result = {guess: infer.didGuess(),\n                  type: infer.toString(exprType, query.depth),\n                  name: type && type.name,\n                  exprName: exprName,\n                  doc: exprType.doc,\n                  url: exprType.url};\n    if (type) storeTypeDocs(query, type, result);\n\n    return clean(result);\n  }\n\n  function parseDoc(query, doc) {\n    if (!doc) return null;\n    if (query.docFormat == \"full\") return doc;\n    var parabreak = /.\\n[\\s@\\n]/.exec(doc);\n    if (parabreak) doc = doc.slice(0, parabreak.index + 1);\n    doc = doc.replace(/\\n\\s*/g, \" \");\n    if (doc.length < 100) return doc;\n    var sentenceEnd = /[\\.!?] [A-Z]/g;\n    sentenceEnd.lastIndex = 80;\n    var found = sentenceEnd.exec(doc);\n    if (found) doc = doc.slice(0, found.index + 1);\n    return doc;\n  }\n\n  function findDocs(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    var inner = type.getType();\n    if (!inner) {\n      expr = findExprAround(file, query);\n      type = findExprType(srv, query, file, expr);\n      inner = type.getType();\n    }\n    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};\n    if (inner) storeTypeDocs(query, inner, result);\n    return clean(result);\n  }\n\n  function storeTypeDocs(query, type, out) {\n    if (!out.url) out.url = type.url;\n    if (!out.doc) out.doc = parseDoc(query, type.doc);\n    if (!out.origin) out.origin = type.origin;\n    var ctor, boring = infer.cx().protos;\n    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&\n        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {\n      out.url = ctor.url;\n      out.doc = parseDoc(query, ctor.doc);\n    }\n  }\n\n  var getSpan = exports.getSpan = function(obj) {\n    if (!obj.origin) return;\n    if (obj.originNode) {\n      var node = obj.originNode;\n      if (/^Function/.test(node.type) && node.id) node = node.id;\n      return {origin: obj.origin, node: node};\n    }\n    if (obj.span) return {origin: obj.origin, span: obj.span};\n  };\n\n  var storeSpan = exports.storeSpan = function(srv, query, span, target) {\n    target.origin = span.origin;\n    if (span.span) {\n      var m = /^(\\d+)\\[(\\d+):(\\d+)\\]-(\\d+)\\[(\\d+):(\\d+)\\]$/.exec(span.span);\n      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);\n      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);\n    } else {\n      var file = srv.fileMap[span.origin];\n      target.start = outputPos(query, file, span.node.start);\n      target.end = outputPos(query, file, span.node.end);\n    }\n  };\n\n  function findDef(srv, query, file) {\n    var expr = findExpr(file, query);\n    var type = findExprType(srv, query, file, expr);\n    if (infer.didGuess()) return {};\n\n    var span = getSpan(type);\n    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};\n\n    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {\n      var tp = type.types[i];\n      storeTypeDocs(query, tp, result);\n      if (!span) span = getSpan(tp);\n    }\n\n    if (span && span.node) { // refers to a loaded file\n      var spanFile = span.node.sourceFile || srv.fileMap[span.origin];\n      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);\n      result.start = start; result.end = end;\n      result.file = span.origin;\n      var cxStart = Math.max(0, span.node.start - 50);\n      result.contextOffset = span.node.start - cxStart;\n      result.context = spanFile.text.slice(cxStart, cxStart + 50);\n    } else if (span) { // external\n      result.file = span.origin;\n      storeSpan(srv, query, span, result);\n    }\n    return clean(result);\n  }\n\n  function findRefsToVariable(srv, query, file, expr, isRename) {\n    var name = expr.node.name;\n\n    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}\n    if (!scope) throw ternError(\"Could not find a definition for \" + name);\n\n    var type, refs = [];\n    function storeRef(file) {\n      return function(node, scopeHere, ancestors) {\n        var value = {file: file.name,\n                     start: outputPos(query, file, node.start),\n                     end: outputPos(query, file, node.end)};\n        if (isRename) {\n          for (var s = scopeHere; s != scope; s = s.prev) {\n            var exists = s.hasProp(isRename);\n            if (exists)\n              throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would make a variable at line \" +\n                              (asLineChar(file, node.start).line + 1) + \" point to the definition at line \" +\n                              (asLineChar(file, exists.name.start).line + 1));\n          }\n          var parent = ancestors[ancestors.length - 2];\n          if (parent && parent.type == \"Property\" && parent.key == parent.value)\n            value.isShorthand = true;\n        }\n        refs.push(value);\n      };\n    }\n\n    if (scope.originNode) {\n      type = \"local\";\n      if (isRename) {\n        for (var prev = scope.prev; prev; prev = prev.prev)\n          if (isRename in prev.props) break;\n        if (prev) infer.findRefs(scope.originNode, scope, isRename, prev, function(node) {\n          throw ternError(\"Renaming `\" + name + \"` to `\" + isRename + \"` would shadow the definition used at line \" +\n                          (asLineChar(file, node.start).line + 1));\n        });\n      }\n      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));\n    } else {\n      type = \"global\";\n      if (query.onlySourceFile) {\n        infer.findRefs(file.ast, file.scope, name, scope, storeRef(file));\n      } else {\n        for (var i = 0; i < srv.files.length; ++i) {\n          var cur = srv.files[i];\n          infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));\n        }\n      }\n    }\n\n    return {refs: refs, type: type, name: name};\n  }\n\n  function findRefsToProperty(srv, query, sourceFile, expr, prop) {\n    var exprType = infer.expressionType(expr);\n    if (expr.node.type == \"MethodDefinition\") {\n      exprType = exprType.propertyOf;\n    }\n    var objType = exprType.getObjType();\n    if (!objType) throw ternError(\"Couldn't determine type of base object.\");\n\n    var refs = [];\n    function storeRef(file) {\n      return function(node) {\n        refs.push({file: file.name,\n                   start: outputPos(query, file, node.start),\n                   end: outputPos(query, file, node.end)});\n      };\n    }\n\n    if (query.onlySourceFile) {\n        infer.findPropRefs(sourceFile.ast, sourceFile.scope, objType, prop.name, storeRef(sourceFile));\n    } else {\n      for (var i = 0; i < srv.files.length; ++i) {\n        var cur = srv.files[i];\n        infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));\n      }\n    }\n\n    return {refs: refs, name: prop.name};\n  }\n\n  function findRefs(srv, query, file) {\n    var expr = findExprOrThrow(file, query, true);\n    if (expr && expr.node.type == \"Identifier\") {\n      return findRefsToVariable(srv, query, file, expr);\n    } else if (expr && expr.node.type == \"MemberExpression\" && !expr.node.computed) {\n      var p = expr.node.property;\n      expr.node = expr.node.object;\n      return findRefsToProperty(srv, query, file, expr, p);\n    } else if (expr && expr.node.type == \"ObjectExpression\") {\n      var pos = resolvePos(file, query.end);\n      for (var i = 0; i < expr.node.properties.length; ++i) {\n        var k = expr.node.properties[i].key;\n        if (k.start <= pos && k.end >= pos)\n          return findRefsToProperty(srv, query, file, expr, k);\n      }\n    } else if (expr && expr.node.type == \"MethodDefinition\") {\n      var p = expr.node.key;\n      return findRefsToProperty(srv, query, file, expr, p);\n    }\n    throw ternError(\"Not at a variable or property name.\");\n  }\n\n  function buildRename(srv, query, file) {\n    if (typeof query.newName != \"string\") throw ternError(\".query.newName should be a string\");\n    var expr = findExprOrThrow(file, query);\n    if (!expr || expr.node.type != \"Identifier\") throw ternError(\"Not at a variable.\");\n\n    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;\n    delete data.refs;\n    data.files = srv.files.map(function(f){return f.name;});\n\n    var changes = data.changes = [];\n    for (var i = 0; i < refs.length; ++i) {\n      var use = refs[i];\n      if (use.isShorthand) use.text = expr.node.name + \": \" + query.newName;\n      else use.text = query.newName;\n      changes.push(use);\n    }\n\n    return data;\n  }\n\n  function listFiles(srv) {\n    return {files: srv.files.map(function(f){return f.name;})};\n  }\n\n  exports.version = \"0.24.3\";\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9saWIvdGVybi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJuL2xpYi90ZXJuLmpzP2U4ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIFRlcm4gc2VydmVyIG9iamVjdFxuXG4vLyBBIHNlcnZlciBpcyBhIHN0YXRlZnVsIG9iamVjdCB0aGF0IG1hbmFnZXMgdGhlIGFuYWx5c2lzIGZvciBhXG4vLyBwcm9qZWN0LCBhbmQgZGVmaW5lcyBhbiBpbnRlcmZhY2UgZm9yIHF1ZXJ5aW5nIHRoZSBjb2RlIGluIHRoZVxuLy8gcHJvamVjdC5cblxuKGZ1bmN0aW9uKHJvb3QsIG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgcmV0dXJuIG1vZChleHBvcnRzLCByZXF1aXJlKFwiLi9pbmZlclwiKSwgcmVxdWlyZShcIi4vc2lnbmFsXCIpLFxuICAgICAgICAgICAgICAgcmVxdWlyZShcImFjb3JuXCIpLCByZXF1aXJlKFwiYWNvcm4td2Fsa1wiKSk7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICByZXR1cm4gZGVmaW5lKFtcImV4cG9ydHNcIiwgXCIuL2luZmVyXCIsIFwiLi9zaWduYWxcIiwgXCJhY29ybi9kaXN0L2Fjb3JuXCIsIFwiYWNvcm4td2Fsay9kaXN0L3dhbGtcIl0sIG1vZCk7XG4gIG1vZChyb290LnRlcm4gfHwgKHJvb3QudGVybiA9IHt9KSwgdGVybiwgdGVybi5zaWduYWwsIGFjb3JuLCBhY29ybi53YWxrKTsgLy8gUGxhaW4gYnJvd3NlciBlbnZcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMsIGluZmVyLCBzaWduYWwsIGFjb3JuLCB3YWxrKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBwbHVnaW5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXhwb3J0cy5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uKG5hbWUsIGluaXQpIHsgcGx1Z2luc1tuYW1lXSA9IGluaXQ7IH07XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldEZpbGU6IGZ1bmN0aW9uKF9mLCBjKSB7IGlmICh0aGlzLmFzeW5jKSBjKG51bGwsIG51bGwpOyB9LFxuICAgIG5vcm1hbGl6ZUZpbGVuYW1lOiBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBuYW1lIH0sXG4gICAgZGVmczogW10sXG4gICAgcGx1Z2luczoge30sXG4gICAgZmV0Y2hUaW1lb3V0OiAxMDAwLFxuICAgIGRlcGVuZGVuY3lCdWRnZXQ6IDIwMDAwLFxuICAgIHJldXNlSW5zdGFuY2VzOiB0cnVlLFxuICAgIHN0cmlwQ1JzOiBmYWxzZSxcbiAgICBlY21hVmVyc2lvbjogOSxcbiAgICBwcm9qZWN0RGlyOiBcIi9cIixcbiAgICBwYXJlbnQ6IG51bGxcbiAgfTtcblxuICB2YXIgcXVlcnlUeXBlcyA9IHtcbiAgICBjb21wbGV0aW9uczoge1xuICAgICAgdGFrZXNGaWxlOiB0cnVlLFxuICAgICAgcnVuOiBmaW5kQ29tcGxldGlvbnNcbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHJ1bjogZmluZFByb3BlcnRpZXNcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIHRha2VzRmlsZTogdHJ1ZSxcbiAgICAgIHJ1bjogZmluZFR5cGVBdFxuICAgIH0sXG4gICAgZG9jdW1lbnRhdGlvbjoge1xuICAgICAgdGFrZXNGaWxlOiB0cnVlLFxuICAgICAgcnVuOiBmaW5kRG9jc1xuICAgIH0sXG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgdGFrZXNGaWxlOiB0cnVlLFxuICAgICAgcnVuOiBmaW5kRGVmXG4gICAgfSxcbiAgICByZWZzOiB7XG4gICAgICB0YWtlc0ZpbGU6IHRydWUsXG4gICAgICBmdWxsRmlsZTogdHJ1ZSxcbiAgICAgIHJ1bjogZmluZFJlZnNcbiAgICB9LFxuICAgIHJlbmFtZToge1xuICAgICAgdGFrZXNGaWxlOiB0cnVlLFxuICAgICAgZnVsbEZpbGU6IHRydWUsXG4gICAgICBydW46IGJ1aWxkUmVuYW1lXG4gICAgfSxcbiAgICBmaWxlczoge1xuICAgICAgcnVuOiBsaXN0RmlsZXNcbiAgICB9XG4gIH07XG5cbiAgZXhwb3J0cy5kZWZpbmVRdWVyeVR5cGUgPSBmdW5jdGlvbihuYW1lLCBkZXNjKSB7IHF1ZXJ5VHlwZXNbbmFtZV0gPSBkZXNjOyB9O1xuXG4gIGZ1bmN0aW9uIEZpbGUobmFtZSwgcGFyZW50KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNjb3BlID0gdGhpcy50ZXh0ID0gdGhpcy5hc3QgPSB0aGlzLmxpbmVPZmZzZXRzID0gbnVsbDtcbiAgfVxuICBGaWxlLnByb3RvdHlwZS5hc0xpbmVDaGFyID0gZnVuY3Rpb24ocG9zKSB7IHJldHVybiBhc0xpbmVDaGFyKHRoaXMsIHBvcyk7IH07XG5cbiAgZnVuY3Rpb24gcGFyc2VGaWxlKHNydiwgZmlsZSkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgZGlyZWN0U291cmNlRmlsZTogZmlsZSxcbiAgICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICAgICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiB0cnVlLFxuICAgICAgZWNtYVZlcnNpb246IHNydi5vcHRpb25zLmVjbWFWZXJzaW9uLFxuICAgICAgYWxsb3dIYXNoQmFuZzogdHJ1ZVxuICAgIH07XG4gICAgdmFyIHRleHQgPSBzcnYuc2lnbmFsUmV0dXJuRmlyc3QoXCJwcmVQYXJzZVwiLCBmaWxlLnRleHQsIG9wdGlvbnMpIHx8IGZpbGUudGV4dDtcbiAgICB2YXIgYXN0ID0gaW5mZXIucGFyc2UodGV4dCwgb3B0aW9ucyk7XG4gICAgc3J2LnNpZ25hbChcInBvc3RQYXJzZVwiLCBhc3QsIHRleHQpO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICB2YXIgYXN0cmFsID0gL1tcXHVEODAwLVxcdURCRkZdL2c7XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dChmaWxlLCB0ZXh0LCBzcnYpIHtcbiAgICBmaWxlLnRleHQgPSBzcnYub3B0aW9ucy5zdHJpcENScyA/IHRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpIDogdGV4dDtcbiAgICBmaWxlLmhhc0FzdHJhbCA9IGFzdHJhbC50ZXN0KGZpbGUudGV4dCk7XG4gICAgaW5mZXIud2l0aENvbnRleHQoc3J2LmN4LCBmdW5jdGlvbigpIHtcbiAgICAgIGZpbGUuYXN0ID0gcGFyc2VGaWxlKHNydiwgZmlsZSk7XG4gICAgfSk7XG4gICAgZmlsZS5saW5lT2Zmc2V0cyA9IG51bGw7XG4gIH1cblxuICB2YXIgU2VydmVyID0gZXhwb3J0cy5TZXJ2ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jeCA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBmb3IgKHZhciBvIGluIGRlZmF1bHRPcHRpb25zKSBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkobykpXG4gICAgICBvcHRpb25zW29dID0gZGVmYXVsdE9wdGlvbnNbb107XG5cbiAgICB0aGlzLnByb2plY3REaXIgPSBvcHRpb25zLnByb2plY3REaXIucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gICAgaWYgKCEvXFwvJC8udGVzdCh0aGlzLnByb2plY3REaXIpKSB0aGlzLnByb2plY3REaXIgKz0gXCIvXCI7XG5cbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICB0aGlzLmZpbGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMubmVlZHNQdXJnZSA9IFtdO1xuICAgIHRoaXMuYnVkZ2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy51c2VzID0gMDtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICAgIHRoaXMuYXN5bmNFcnJvciA9IG51bGw7XG4gICAgdGhpcy5tb2QgPSB7fTtcblxuICAgIHRoaXMuZGVmcyA9IG9wdGlvbnMuZGVmcy5zbGljZSgwKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIHBsdWdpbiBpbiBvcHRpb25zLnBsdWdpbnMpIGlmIChvcHRpb25zLnBsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luKSlcbiAgICAgIHRoaXMubG9hZFBsdWdpbihwbHVnaW4sIG9wdGlvbnMucGx1Z2luc1twbHVnaW5dKTtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcbiAgU2VydmVyLnByb3RvdHlwZSA9IHNpZ25hbC5taXhpbih7XG4gICAgYWRkRmlsZTogZnVuY3Rpb24obmFtZSwgLypvcHRpb25hbCovIHRleHQsIHBhcmVudCkge1xuICAgICAgLy8gRG9uJ3QgY3Jhc2ggd2hlbiBzbG9wcHkgcGx1Z2lucyBwYXNzIG5vbi1leGlzdGVudCBwYXJlbnQgaWRzXG4gICAgICBpZiAocGFyZW50ICYmICEocGFyZW50IGluIHRoaXMuZmlsZU1hcCkpIHBhcmVudCA9IG51bGw7XG4gICAgICBpZiAoIShuYW1lIGluIHRoaXMuZmlsZU1hcCkpXG4gICAgICAgIG5hbWUgPSB0aGlzLm5vcm1hbGl6ZUZpbGVuYW1lKG5hbWUpO1xuICAgICAgZW5zdXJlRmlsZSh0aGlzLCBuYW1lLCBwYXJlbnQsIHRleHQpO1xuICAgIH0sXG4gICAgZGVsRmlsZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbmRGaWxlKG5hbWUpO1xuICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgdGhpcy5uZWVkc1B1cmdlLnB1c2goZmlsZS5uYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmlsZXNbaV0gPT0gZmlsZSkgdGhpcy5maWxlcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICBlbHNlIGlmICh0aGlzLmZpbGVzW2ldLnBhcmVudCA9PSBuYW1lKSB0aGlzLmZpbGVzW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsZU1hcFtmaWxlLm5hbWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zaWduYWwoXCJyZXNldFwiKTtcbiAgICAgIHRoaXMuY3ggPSBuZXcgaW5mZXIuQ29udGV4dCh0aGlzLmRlZnMsIHRoaXMpO1xuICAgICAgdGhpcy51c2VzID0gMDtcbiAgICAgIHRoaXMuYnVkZ2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICBpZiAoZmlsZS5zY29wZSkge1xuICAgICAgICAgIGluZmVyLmNsZWFyU2NvcGVzKGZpbGUuYXN0KTtcbiAgICAgICAgICBmaWxlLnNjb3BlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zaWduYWwoXCJwb3N0UmVzZXRcIik7XG4gICAgfSxcblxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKGRvYywgYykge1xuICAgICAgdmFyIGludiA9IGludmFsaWREb2MoZG9jKTtcbiAgICAgIGlmIChpbnYpIHJldHVybiBjKGludik7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGRvUmVxdWVzdCh0aGlzLCBkb2MsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICBjKGVyciwgZGF0YSk7XG4gICAgICAgIGlmIChzZWxmLnVzZXMgPiA0MCkge1xuICAgICAgICAgIHNlbGYucmVzZXQoKTtcbiAgICAgICAgICBhbmFseXplQWxsKHNlbGYsIG51bGwsIGZ1bmN0aW9uKCl7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5kRmlsZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZU1hcFt0aGlzLm5vcm1hbGl6ZUZpbGVuYW1lKG5hbWUpXTtcbiAgICB9LFxuXG4gICAgZmx1c2g6IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBjeCA9IHRoaXMuY3g7XG4gICAgICBhbmFseXplQWxsKHRoaXMsIG51bGwsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gYyhlcnIpO1xuICAgICAgICBpbmZlci53aXRoQ29udGV4dChjeCwgYyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgc3RhcnRBc3luY0FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICArK3RoaXMucGVuZGluZztcbiAgICB9LFxuICAgIGZpbmlzaEFzeW5jQWN0aW9uOiBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHRoaXMuYXN5bmNFcnJvciA9IGVycjtcbiAgICAgIGlmICgtLXRoaXMucGVuZGluZyA9PT0gMCkgdGhpcy5zaWduYWwoXCJldmVyeXRoaW5nRmV0Y2hlZFwiKTtcbiAgICB9LFxuXG4gICAgYWRkRGVmczogZnVuY3Rpb24oZGVmcywgdG9Gcm9udCkge1xuICAgICAgaWYgKHRvRnJvbnQpIHRoaXMuZGVmcy51bnNoaWZ0KGRlZnMpO1xuICAgICAgZWxzZSB0aGlzLmRlZnMucHVzaChkZWZzKTtcblxuICAgICAgaWYgKHRoaXMuY3gpIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgZGVsZXRlRGVmczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlZnMubGVuZ3RoOyBpKyspIGlmICh0aGlzLmRlZnNbaV1bXCIhbmFtZVwiXSA9PSBuYW1lKSB7XG4gICAgICAgIHRoaXMuZGVmcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlmICh0aGlzLmN4KSB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9hZFBsdWdpbjogZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5wbHVnaW5zW25hbWVdIHx8IHRydWU7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLnBsdWdpbnMgfHwgIShuYW1lIGluIHBsdWdpbnMpIHx8ICFvcHRpb25zKSByZXR1cm47XG4gICAgICB0aGlzLnBsdWdpbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgdmFyIGluaXQgPSBwbHVnaW5zW25hbWVdKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBUaGlzIGlzIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbHR5LiBEb24ndCByZWx5IG9uIGl0IC0tIHVzZSBhZGREZWYgYW5kIG9uIGRpcmVjdGx5XG4gICAgICBpZiAoIWluaXQpIHJldHVybjtcbiAgICAgIGlmIChpbml0LmRlZnMpIHRoaXMuYWRkRGVmcyhpbml0LmRlZnMsIGluaXQubG9hZEZpcnN0KTtcbiAgICAgIGlmIChpbml0LnBhc3NlcykgZm9yICh2YXIgdHlwZSBpbiBpbml0LnBhc3NlcykgaWYgKGluaXQucGFzc2VzLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aGlzLm9uKHR5cGUsIGluaXQucGFzc2VzW3R5cGVdKTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplRmlsZW5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBub3JtID0gdGhpcy5vcHRpb25zLm5vcm1hbGl6ZUZpbGVuYW1lKG5hbWUpLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuICAgICAgaWYgKG5vcm0uaW5kZXhPZih0aGlzLnByb2plY3REaXIpID09IDApIG5vcm0gPSBub3JtLnNsaWNlKHRoaXMucHJvamVjdERpci5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5vcm07XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBkb1JlcXVlc3Qoc3J2LCBkb2MsIGMpIHtcbiAgICBpZiAoZG9jLnF1ZXJ5ICYmICFxdWVyeVR5cGVzLmhhc093blByb3BlcnR5KGRvYy5xdWVyeS50eXBlKSlcbiAgICAgIHJldHVybiBjKFwiTm8gcXVlcnkgdHlwZSAnXCIgKyBkb2MucXVlcnkudHlwZSArIFwiJyBkZWZpbmVkXCIpO1xuXG4gICAgdmFyIHF1ZXJ5ID0gZG9jLnF1ZXJ5O1xuICAgIC8vIFJlc3BvbmQgYXMgc29vbiBhcyBwb3NzaWJsZSB3aGVuIHRoaXMganVzdCB1cGxvYWRzIGZpbGVzXG4gICAgaWYgKCFxdWVyeSkgYyhudWxsLCB7fSk7XG5cbiAgICB2YXIgZmlsZXMgPSBkb2MuZmlsZXMgfHwgW107XG4gICAgaWYgKGZpbGVzLmxlbmd0aCkgKytzcnYudXNlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgZmlsZS5uYW1lID0gc3J2Lm5vcm1hbGl6ZUZpbGVuYW1lKGZpbGUubmFtZSk7XG4gICAgICBpZiAoZmlsZS50eXBlID09IFwiZGVsZXRlXCIpXG4gICAgICAgIHNydi5kZWxGaWxlKGZpbGUubmFtZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGVuc3VyZUZpbGUoc3J2LCBmaWxlLm5hbWUsIG51bGwsIGZpbGUudHlwZSA9PSBcImZ1bGxcIiA/IGZpbGUudGV4dCA6IG51bGwpO1xuICAgIH1cblxuICAgIHZhciB0aW1lQnVkZ2V0ID0gdHlwZW9mIGRvYy50aW1lb3V0ID09IFwibnVtYmVyXCIgPyBbZG9jLnRpbWVvdXRdIDogbnVsbDtcbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICBhbmFseXplQWxsKHNydiwgdGltZUJ1ZGdldCwgZnVuY3Rpb24oKXt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlUeXBlID0gcXVlcnlUeXBlc1txdWVyeS50eXBlXTtcbiAgICBpZiAocXVlcnlUeXBlLnRha2VzRmlsZSkge1xuICAgICAgaWYgKHR5cGVvZiBxdWVyeS5maWxlICE9IFwic3RyaW5nXCIpIHJldHVybiBjKFwiLnF1ZXJ5LmZpbGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgIGlmICghL14jLy50ZXN0KHF1ZXJ5LmZpbGUpKSBlbnN1cmVGaWxlKHNydiwgcXVlcnkuZmlsZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgYW5hbHl6ZUFsbChzcnYsIHRpbWVCdWRnZXQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGMoZXJyKTtcbiAgICAgIHZhciBmaWxlID0gcXVlcnlUeXBlLnRha2VzRmlsZSAmJiByZXNvbHZlRmlsZShzcnYsIGZpbGVzLCBxdWVyeS5maWxlKTtcbiAgICAgIGlmIChxdWVyeVR5cGUuZnVsbEZpbGUgJiYgZmlsZS50eXBlID09IFwicGFydFwiKVxuICAgICAgICByZXR1cm4gYyhcIkNhbid0IHJ1biBhIFwiICsgcXVlcnkudHlwZSArIFwiIHF1ZXJ5IG9uIGEgZmlsZSBmcmFnbWVudFwiKTtcblxuICAgICAgaW5mZXIucmVzZXRHdWVzc2luZygpO1xuICAgICAgaW5mZXIud2l0aENvbnRleHQoc3J2LmN4LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgcnVuID0gZnVuY3Rpb24oKSB7IHJlc3VsdCA9IHF1ZXJ5VHlwZS5ydW4oc3J2LCBxdWVyeSwgZmlsZSk7IH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRpbWVCdWRnZXQpIGluZmVyLndpdGhUaW1lb3V0KHRpbWVCdWRnZXRbMF0sIHJ1bik7XG4gICAgICAgICAgZWxzZSBydW4oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChzcnYub3B0aW9ucy5kZWJ1ZyAmJiBlLm5hbWUgIT0gXCJUZXJuRXJyb3JcIikgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gYyhlKTtcbiAgICAgICAgfVxuICAgICAgICBjKG51bGwsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuYWx5emVGaWxlKHNydiwgZmlsZSkge1xuICAgIGluZmVyLndpdGhDb250ZXh0KHNydi5jeCwgZnVuY3Rpb24oKSB7XG4gICAgICBmaWxlLnNjb3BlID0gc3J2LmN4LnRvcFNjb3BlO1xuICAgICAgc3J2LnNpZ25hbChcImJlZm9yZUxvYWRcIiwgZmlsZSk7XG4gICAgICBpbmZlci5hbmFseXplKGZpbGUuYXN0LCBmaWxlLm5hbWUsIGZpbGUuc2NvcGUpO1xuICAgICAgc3J2LnNpZ25hbChcImFmdGVyTG9hZFwiLCBmaWxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUZpbGUoc3J2LCBuYW1lLCBwYXJlbnQsIHRleHQpIHtcbiAgICB2YXIga25vd24gPSBzcnYuZmluZEZpbGUobmFtZSk7XG4gICAgaWYgKGtub3duKSB7XG4gICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChrbm93bi5zY29wZSkge1xuICAgICAgICAgIHNydi5uZWVkc1B1cmdlLnB1c2gobmFtZSk7XG4gICAgICAgICAgaW5mZXIuY2xlYXJTY29wZXMoa25vd24uYXN0KTtcbiAgICAgICAgICBrbm93bi5zY29wZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlVGV4dChrbm93biwgdGV4dCwgc3J2KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnREZXB0aChzcnYsIGtub3duLnBhcmVudCkgPiBwYXJlbnREZXB0aChzcnYsIHBhcmVudCkpIHtcbiAgICAgICAga25vd24ucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAoa25vd24uZXhjbHVkZWQpIGtub3duLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZmlsZSA9IG5ldyBGaWxlKG5hbWUsIHBhcmVudCk7XG4gICAgc3J2LmZpbGVzLnB1c2goZmlsZSk7XG4gICAgc3J2LmZpbGVNYXBbbmFtZV0gPSBmaWxlO1xuICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZVRleHQoZmlsZSwgdGV4dCwgc3J2KTtcbiAgICB9IGVsc2UgaWYgKHNydi5vcHRpb25zLmFzeW5jKSB7XG4gICAgICBzcnYuc3RhcnRBc3luY0FjdGlvbigpO1xuICAgICAgc3J2Lm9wdGlvbnMuZ2V0RmlsZShuYW1lLCBmdW5jdGlvbihlcnIsIHRleHQpIHtcbiAgICAgICAgdXBkYXRlVGV4dChmaWxlLCB0ZXh0IHx8IFwiXCIsIHNydik7XG4gICAgICAgIHNydi5maW5pc2hBc3luY0FjdGlvbihlcnIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZVRleHQoZmlsZSwgc3J2Lm9wdGlvbnMuZ2V0RmlsZShuYW1lKSB8fCBcIlwiLCBzcnYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoQWxsKHNydiwgYykge1xuICAgIHZhciBkb25lID0gdHJ1ZSwgcmV0dXJuZWQgPSBmYWxzZTtcbiAgICBzcnYuZmlsZXMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgICBpZiAoZmlsZS50ZXh0ICE9IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChzcnYub3B0aW9ucy5hc3luYykge1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHNydi5vcHRpb25zLmdldEZpbGUoZmlsZS5uYW1lLCBmdW5jdGlvbihlcnIsIHRleHQpIHtcbiAgICAgICAgICBpZiAoZXJyICYmICFyZXR1cm5lZCkgeyByZXR1cm5lZCA9IHRydWU7IHJldHVybiBjKGVycik7IH1cbiAgICAgICAgICB1cGRhdGVUZXh0KGZpbGUsIHRleHQgfHwgXCJcIiwgc3J2KTtcbiAgICAgICAgICBmZXRjaEFsbChzcnYsIGMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXBkYXRlVGV4dChmaWxlLCBzcnYub3B0aW9ucy5nZXRGaWxlKGZpbGUubmFtZSkgfHwgXCJcIiwgc3J2KTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gYyhlKTsgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkb25lKSBjKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWl0T25GZXRjaChzcnYsIHRpbWVCdWRnZXQsIGMpIHtcbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgc3J2Lm9mZihcImV2ZXJ5dGhpbmdGZXRjaGVkXCIsIGRvbmUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgYW5hbHl6ZUFsbChzcnYsIHRpbWVCdWRnZXQsIGMpO1xuICAgIH07XG4gICAgc3J2Lm9uKFwiZXZlcnl0aGluZ0ZldGNoZWRcIiwgZG9uZSk7XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIHNydi5vcHRpb25zLmZldGNoVGltZW91dCk7XG4gIH1cblxuICBmdW5jdGlvbiBhbmFseXplQWxsKHNydiwgdGltZUJ1ZGdldCwgYykge1xuICAgIGlmIChzcnYucGVuZGluZykgcmV0dXJuIHdhaXRPbkZldGNoKHNydiwgdGltZUJ1ZGdldCwgYyk7XG5cbiAgICB2YXIgZSA9IHNydi5mZXRjaEVycm9yO1xuICAgIGlmIChlKSB7IHNydi5mZXRjaEVycm9yID0gbnVsbDsgcmV0dXJuIGMoZSk7IH1cblxuICAgIGlmIChzcnYubmVlZHNQdXJnZS5sZW5ndGggPiAwKSBpbmZlci53aXRoQ29udGV4dChzcnYuY3gsIGZ1bmN0aW9uKCkge1xuICAgICAgaW5mZXIucHVyZ2Uoc3J2Lm5lZWRzUHVyZ2UpO1xuICAgICAgc3J2Lm5lZWRzUHVyZ2UubGVuZ3RoID0gMDtcbiAgICB9KTtcblxuICAgIHZhciBkb25lID0gdHJ1ZTtcbiAgICAvLyBUaGUgc2Vjb25kIGlubmVyIGxvb3AgbWlnaHQgYWRkIG5ldyBmaWxlcy4gVGhlIG91dGVyIGxvb3Aga2VlcHNcbiAgICAvLyByZXBlYXRpbmcgYm90aCBpbm5lciBsb29wcyB1bnRpbCBhbGwgZmlsZXMgaGF2ZSBiZWVuIGxvb2tlZCBhdC5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNydi5maWxlcy5sZW5ndGg7KSB7XG4gICAgICB2YXIgdG9BbmFseXplID0gW107XG4gICAgICBmb3IgKDsgaSA8IHNydi5maWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmlsZSA9IHNydi5maWxlc1tpXTtcbiAgICAgICAgaWYgKGZpbGUudGV4dCA9PSBudWxsKSBkb25lID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKGZpbGUuc2NvcGUgPT0gbnVsbCAmJiAhZmlsZS5leGNsdWRlZCkgdG9BbmFseXplLnB1c2goZmlsZSk7XG4gICAgICB9XG4gICAgICB0b0FuYWx5emUuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnREZXB0aChzcnYsIGEucGFyZW50KSAtIHBhcmVudERlcHRoKHNydiwgYi5wYXJlbnQpO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRvQW5hbHl6ZS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZmlsZSA9IHRvQW5hbHl6ZVtqXTtcbiAgICAgICAgaWYgKGZpbGUucGFyZW50ICYmICFjaGFyZ2VPbkJ1ZGdldChzcnYsIGZpbGUpKSB7XG4gICAgICAgICAgZmlsZS5leGNsdWRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZUJ1ZGdldCkge1xuICAgICAgICAgIHZhciBzdGFydFRpbWUgPSArbmV3IERhdGU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluZmVyLndpdGhUaW1lb3V0KHRpbWVCdWRnZXRbMF0sIGZ1bmN0aW9uKCkgeyBhbmFseXplRmlsZShzcnYsIGZpbGUpOyB9KTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgaW5mZXIuVGltZWRPdXQpIHJldHVybiBjKGUpO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aW1lQnVkZ2V0WzBdIC09ICtuZXcgRGF0ZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmFseXplRmlsZShzcnYsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb25lKSBjKCk7XG4gICAgZWxzZSB3YWl0T25GZXRjaChzcnYsIHRpbWVCdWRnZXQsIGMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyc3RMaW5lKHN0cikge1xuICAgIHZhciBlbmQgPSBzdHIuaW5kZXhPZihcIlxcblwiKTtcbiAgICBpZiAoZW5kIDwgMCkgcmV0dXJuIHN0cjtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGVuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdQb3NpdGlvbihsaW5lLCBmaWxlLCBuZWFyKSB7XG4gICAgdmFyIHBvcyA9IE1hdGgubWF4KDAsIG5lYXIgLSA1MDApLCBjbG9zZXN0ID0gbnVsbDtcbiAgICBpZiAoIS9eXFxzKiQvLnRlc3QobGluZSkpIGZvciAoOzspIHtcbiAgICAgIHZhciBmb3VuZCA9IGZpbGUuaW5kZXhPZihsaW5lLCBwb3MpO1xuICAgICAgaWYgKGZvdW5kIDwgMCB8fCBmb3VuZCA+IG5lYXIgKyA1MDApIGJyZWFrO1xuICAgICAgaWYgKGNsb3Nlc3QgPT0gbnVsbCB8fCBNYXRoLmFicyhjbG9zZXN0IC0gbmVhcikgPiBNYXRoLmFicyhmb3VuZCAtIG5lYXIpKVxuICAgICAgICBjbG9zZXN0ID0gZm91bmQ7XG4gICAgICBwb3MgPSBmb3VuZCArIGxpbmUubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjb3BlRGVwdGgocykge1xuICAgIGZvciAodmFyIGkgPSAwOyBzOyArK2ksIHMgPSBzLnByZXYpIHt9XG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXJuRXJyb3IobXNnKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgIGVyci5uYW1lID0gXCJUZXJuRXJyb3JcIjtcbiAgICByZXR1cm4gZXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUZpbGUoc3J2LCBsb2NhbEZpbGVzLCBuYW1lKSB7XG4gICAgdmFyIGlzUmVmID0gbmFtZS5tYXRjaCgvXiMoXFxkKykkLyk7XG4gICAgaWYgKCFpc1JlZikgcmV0dXJuIHNydi5maW5kRmlsZShuYW1lKTtcblxuICAgIHZhciBmaWxlID0gbG9jYWxGaWxlc1tpc1JlZlsxXV07XG4gICAgaWYgKCFmaWxlIHx8IGZpbGUudHlwZSA9PSBcImRlbGV0ZVwiKSB0aHJvdyB0ZXJuRXJyb3IoXCJSZWZlcmVuY2UgdG8gdW5rbm93biBmaWxlIFwiICsgbmFtZSk7XG4gICAgaWYgKGZpbGUudHlwZSA9PSBcImZ1bGxcIikgcmV0dXJuIHNydi5maWxlTWFwW2ZpbGUubmFtZV07XG5cbiAgICAvLyBUaGlzIGlzIGEgcGFydGlhbCBmaWxlXG5cbiAgICB2YXIgcmVhbEZpbGUgPSBmaWxlLmJhY2tpbmcgPSBzcnYuZmlsZU1hcFtmaWxlLm5hbWVdO1xuICAgIHZhciBvZmZzZXQgPSByZXNvbHZlUG9zKHJlYWxGaWxlLCBmaWxlLm9mZnNldExpbmVzID09IG51bGwgPyBmaWxlLm9mZnNldCA6IHtsaW5lOiBmaWxlLm9mZnNldExpbmVzLCBjaDogMH0sIHRydWUpO1xuICAgIHZhciBsaW5lID0gZmlyc3RMaW5lKGZpbGUudGV4dCk7XG4gICAgdmFyIGZvdW5kUG9zID0gZmluZE1hdGNoaW5nUG9zaXRpb24obGluZSwgcmVhbEZpbGUudGV4dCwgb2Zmc2V0KTtcbiAgICB2YXIgcG9zID0gZm91bmRQb3MgPT0gbnVsbCA/IE1hdGgubWF4KDAsIHJlYWxGaWxlLnRleHQubGFzdEluZGV4T2YoXCJcXG5cIiwgb2Zmc2V0KSkgOiBmb3VuZFBvcztcbiAgICB2YXIgaW5PYmplY3QsIGF0RnVuY3Rpb247XG5cbiAgICBpbmZlci53aXRoQ29udGV4dChzcnYuY3gsIGZ1bmN0aW9uKCkge1xuICAgICAgaW5mZXIucHVyZ2UoZmlsZS5uYW1lLCBwb3MsIHBvcyArIGZpbGUudGV4dC5sZW5ndGgpO1xuXG4gICAgICB2YXIgdGV4dCA9IGZpbGUudGV4dCwgbTtcbiAgICAgIGlmIChtID0gdGV4dC5tYXRjaCgvKD86XCIoW15cIl0qKVwifChbXFx3JF0rKSlcXHMqOlxccypmdW5jdGlvblxcYi8pKSB7XG4gICAgICAgIHZhciBvYmpOb2RlID0gd2Fsay5maW5kTm9kZUFyb3VuZChmaWxlLmJhY2tpbmcuYXN0LCBwb3MsIFwiT2JqZWN0RXhwcmVzc2lvblwiKTtcbiAgICAgICAgaWYgKG9iak5vZGUgJiYgb2JqTm9kZS5ub2RlLm9ialR5cGUpXG4gICAgICAgICAgaW5PYmplY3QgPSB7dHlwZTogb2JqTm9kZS5ub2RlLm9ialR5cGUsIHByb3A6IG1bMl0gfHwgbVsxXX07XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRQb3MgJiYgKG0gPSBsaW5lLm1hdGNoKC9eKC4qPylcXGJmdW5jdGlvblxcYi8pKSkge1xuICAgICAgICB2YXIgY3V0ID0gbVsxXS5sZW5ndGgsIHdoaXRlID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXQ7ICsraSkgd2hpdGUgKz0gXCIgXCI7XG4gICAgICAgIGZpbGUudGV4dCA9IHdoaXRlICsgdGV4dC5zbGljZShjdXQpO1xuICAgICAgICBhdEZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjb3BlU3RhcnQgPSBpbmZlci5zY29wZUF0KHJlYWxGaWxlLmFzdCwgcG9zLCByZWFsRmlsZS5zY29wZSk7XG4gICAgICB2YXIgc2NvcGVFbmQgPSBpbmZlci5zY29wZUF0KHJlYWxGaWxlLmFzdCwgcG9zICsgdGV4dC5sZW5ndGgsIHJlYWxGaWxlLnNjb3BlKTtcbiAgICAgIHZhciBzY29wZSA9IGZpbGUuc2NvcGUgPSBzY29wZURlcHRoKHNjb3BlU3RhcnQpIDwgc2NvcGVEZXB0aChzY29wZUVuZCkgPyBzY29wZUVuZCA6IHNjb3BlU3RhcnQ7XG4gICAgICBmaWxlLmFzdCA9IHBhcnNlRmlsZShzcnYsIGZpbGUpO1xuICAgICAgaW5mZXIuYW5hbHl6ZShmaWxlLmFzdCwgZmlsZS5uYW1lLCBzY29wZSk7XG5cbiAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gdGllIHRvZ2V0aGVyIHRoZSBmdW5jdGlvbiB0eXBlcyAoaWYgYW55KVxuICAgICAgLy8gb3V0c2lkZSBhbmQgaW5zaWRlIG9mIHRoZSBmcmFnbWVudCwgc28gdGhhdCBhcmd1bWVudHMgYW5kXG4gICAgICAvLyByZXR1cm4gdmFsdWVzIGhhdmUgc29tZSBpbmZvcm1hdGlvbiBrbm93biBhYm91dCB0aGVtLlxuICAgICAgdGllVG9nZXRoZXI6IHtcbiAgICAgICAgaWYgKGluT2JqZWN0IHx8IGF0RnVuY3Rpb24pIHtcbiAgICAgICAgICB2YXIgbmV3SW5uZXIgPSBpbmZlci5zY29wZUF0KGZpbGUuYXN0LCBsaW5lLmxlbmd0aCwgc2NvcGVTdGFydCk7XG4gICAgICAgICAgaWYgKCFuZXdJbm5lci5mblR5cGUpIGJyZWFrIHRpZVRvZ2V0aGVyO1xuICAgICAgICAgIGlmIChpbk9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBpbk9iamVjdC50eXBlLmdldFByb3AoaW5PYmplY3QucHJvcCk7XG4gICAgICAgICAgICBwcm9wLmFkZFR5cGUobmV3SW5uZXIuZm5UeXBlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBpbm5lciA9IGluZmVyLnNjb3BlQXQocmVhbEZpbGUuYXN0LCBwb3MgKyBsaW5lLmxlbmd0aCwgcmVhbEZpbGUuc2NvcGUpO1xuICAgICAgICAgICAgaWYgKGlubmVyID09IHNjb3BlU3RhcnQgfHwgIWlubmVyLmZuVHlwZSkgYnJlYWsgdGllVG9nZXRoZXI7XG4gICAgICAgICAgICB2YXIgZk9sZCA9IGlubmVyLmZuVHlwZSwgZk5ldyA9IG5ld0lubmVyLmZuVHlwZTtcbiAgICAgICAgICAgIGlmICghZk5ldyB8fCAoZk5ldy5uYW1lICE9IGZPbGQubmFtZSAmJiBmT2xkLm5hbWUpKSBicmVhayB0aWVUb2dldGhlcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlID0gTWF0aC5taW4oZk9sZC5hcmdzLmxlbmd0aCwgZk5ldy5hcmdzLmxlbmd0aCk7IGkgPCBlOyArK2kpXG4gICAgICAgICAgICAgIGZPbGQuYXJnc1tpXS5wcm9wYWdhdGUoZk5ldy5hcmdzW2ldKTtcbiAgICAgICAgICAgIGZPbGQuc2VsZi5wcm9wYWdhdGUoZk5ldy5zZWxmKTtcbiAgICAgICAgICAgIGZOZXcucmV0dmFsLnByb3BhZ2F0ZShmT2xkLnJldHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICAvLyBCdWRnZXQgbWFuYWdlbWVudFxuXG4gIGZ1bmN0aW9uIGFzdFNpemUobm9kZSkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICB3YWxrLnNpbXBsZShub2RlLCB7RXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfX0pO1xuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW50RGVwdGgoc3J2LCBwYXJlbnQpIHtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHNydi5maWxlTWFwW3BhcmVudF0ucGFyZW50O1xuICAgICAgKytkZXB0aDtcbiAgICB9XG4gICAgcmV0dXJuIGRlcHRoO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVkZ2V0TmFtZShzcnYsIGZpbGUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgcGFyZW50ID0gc3J2LmZpbGVNYXBbZmlsZS5wYXJlbnRdO1xuICAgICAgaWYgKCFwYXJlbnQucGFyZW50KSBicmVhaztcbiAgICAgIGZpbGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmaWxlLm5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyZ2VPbkJ1ZGdldChzcnYsIGZpbGUpIHtcbiAgICB2YXIgYk5hbWUgPSBidWRnZXROYW1lKHNydiwgZmlsZSk7XG4gICAgdmFyIHNpemUgPSBhc3RTaXplKGZpbGUuYXN0KTtcbiAgICB2YXIga25vd24gPSBzcnYuYnVkZ2V0c1tiTmFtZV07XG4gICAgaWYgKGtub3duID09IG51bGwpXG4gICAgICBrbm93biA9IHNydi5idWRnZXRzW2JOYW1lXSA9IHNydi5vcHRpb25zLmRlcGVuZGVuY3lCdWRnZXQ7XG4gICAgaWYgKGtub3duIDwgc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgIHNydi5idWRnZXRzW2JOYW1lXSA9IGtub3duIC0gc2l6ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFF1ZXJ5IGhlbHBlcnNcblxuICBmdW5jdGlvbiBpc1Bvc2l0aW9uKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbCA9PSBcIm9iamVjdFwiICYmXG4gICAgICB0eXBlb2YgdmFsLmxpbmUgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsLmNoID09IFwibnVtYmVyXCI7XG4gIH1cblxuICAvLyBCYXNlbGluZSBxdWVyeSBkb2N1bWVudCB2YWxpZGF0aW9uXG4gIGZ1bmN0aW9uIGludmFsaWREb2MoZG9jKSB7XG4gICAgaWYgKGRvYy5xdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBkb2MucXVlcnkudHlwZSAhPSBcInN0cmluZ1wiKSByZXR1cm4gXCIucXVlcnkudHlwZSBtdXN0IGJlIGEgc3RyaW5nXCI7XG4gICAgICBpZiAoZG9jLnF1ZXJ5LnN0YXJ0ICYmICFpc1Bvc2l0aW9uKGRvYy5xdWVyeS5zdGFydCkpIHJldHVybiBcIi5xdWVyeS5zdGFydCBtdXN0IGJlIGEgcG9zaXRpb25cIjtcbiAgICAgIGlmIChkb2MucXVlcnkuZW5kICYmICFpc1Bvc2l0aW9uKGRvYy5xdWVyeS5lbmQpKSByZXR1cm4gXCIucXVlcnkuZW5kIG11c3QgYmUgYSBwb3NpdGlvblwiO1xuICAgIH1cbiAgICBpZiAoZG9jLmZpbGVzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jLmZpbGVzKSkgcmV0dXJuIFwiRmlsZXMgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheVwiO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MuZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBkb2MuZmlsZXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSAhPSBcIm9iamVjdFwiKSByZXR1cm4gXCIuZmlsZXNbbl0gbXVzdCBiZSBvYmplY3RzXCI7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWxlLm5hbWUgIT0gXCJzdHJpbmdcIikgcmV0dXJuIFwiLmZpbGVzW25dLm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiO1xuICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT0gXCJkZWxldGVcIikgY29udGludWU7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWxlLnRleHQgIT0gXCJzdHJpbmdcIikgcmV0dXJuIFwiLmZpbGVzW25dLnRleHQgbXVzdCBiZSBhIHN0cmluZ1wiO1xuICAgICAgICBlbHNlIGlmIChmaWxlLnR5cGUgPT0gXCJwYXJ0XCIpIHtcbiAgICAgICAgICBpZiAoIWlzUG9zaXRpb24oZmlsZS5vZmZzZXQpICYmIHR5cGVvZiBmaWxlLm9mZnNldExpbmVzICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gXCIuZmlsZXNbbl0ub2Zmc2V0IG11c3QgYmUgYSBwb3NpdGlvblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGUudHlwZSAhPSBcImZ1bGxcIikgcmV0dXJuIFwiLmZpbGVzW25dLnR5cGUgbXVzdCBiZSBcXFwiZnVsbFxcXCIgb3IgXFxcInBhcnRcXFwiXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9mZnNldFNraXBMaW5lcyA9IDI1O1xuXG4gIGZ1bmN0aW9uIGZvcndhcmRDaGFyYWN0ZXJzKGZpbGUsIHN0YXJ0LCBjaGFycykge1xuICAgIHZhciBwb3MgPSBzdGFydCArIGNoYXJzLCBtO1xuICAgIGlmIChmaWxlLmhhc0FzdHJhbCkge1xuICAgICAgYXN0cmFsLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgd2hpbGUgKChtID0gYXN0cmFsLmV4ZWMoZmlsZS50ZXh0KSkgJiYgbS5pbmRleCA8IHBvcykgcG9zKys7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTGluZVN0YXJ0KGZpbGUsIGxpbmUpIHtcbiAgICB2YXIgdGV4dCA9IGZpbGUudGV4dCwgb2Zmc2V0cyA9IGZpbGUubGluZU9mZnNldHMgfHwgKGZpbGUubGluZU9mZnNldHMgPSBbMF0pO1xuICAgIHZhciBwb3MgPSAwLCBjdXJMaW5lID0gMDtcbiAgICB2YXIgc3RvcmVQb3MgPSBNYXRoLm1pbihNYXRoLmZsb29yKGxpbmUgLyBvZmZzZXRTa2lwTGluZXMpLCBvZmZzZXRzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBwb3MgPSBvZmZzZXRzW3N0b3JlUG9zXSwgY3VyTGluZSA9IHN0b3JlUG9zICogb2Zmc2V0U2tpcExpbmVzO1xuXG4gICAgd2hpbGUgKGN1ckxpbmUgPCBsaW5lKSB7XG4gICAgICArK2N1ckxpbmU7XG4gICAgICBwb3MgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgcG9zKSArIDE7XG4gICAgICBpZiAocG9zID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChjdXJMaW5lICUgb2Zmc2V0U2tpcExpbmVzID09PSAwKSBvZmZzZXRzLnB1c2gocG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIHZhciByZXNvbHZlUG9zID0gZXhwb3J0cy5yZXNvbHZlUG9zID0gZnVuY3Rpb24oZmlsZSwgcG9zLCB0b2xlcmFudCkge1xuICAgIGlmICh0eXBlb2YgcG9zICE9IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciBsaW5lU3RhcnQgPSBmaW5kTGluZVN0YXJ0KGZpbGUsIHBvcy5saW5lKTtcbiAgICAgIGlmIChsaW5lU3RhcnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9sZXJhbnQpIHBvcyA9IGZpbGUudGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2UgdGhyb3cgdGVybkVycm9yKFwiRmlsZSBkb2Vzbid0IGNvbnRhaW4gYSBsaW5lIFwiICsgcG9zLmxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gZm9yd2FyZENoYXJhY3RlcnMoZmlsZSwgbGluZVN0YXJ0LCBwb3MuY2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBmb3J3YXJkQ2hhcmFjdGVycyhmaWxlLCAwLCBwb3MpO1xuICAgIH1cbiAgICBpZiAocG9zID4gZmlsZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKHRvbGVyYW50KSBwb3MgPSBmaWxlLnRleHQubGVuZ3RoO1xuICAgICAgZWxzZSB0aHJvdyB0ZXJuRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIGlzIG91dHNpZGUgb2YgZmlsZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hhckRpc3RhbmNlQmV0d2VlbihmaWxlLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGRpZmYgPSBlbmQgLSBzdGFydCwgbTtcbiAgICBpZiAoZmlsZS5oYXNBc3RyYWwpIHtcbiAgICAgIGFzdHJhbC5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHdoaWxlICgobSA9IGFzdHJhbC5leGVjKGZpbGUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQpIGRpZmYtLTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmY7XG4gIH1cblxuICBmdW5jdGlvbiBhc0xpbmVDaGFyKGZpbGUsIHBvcykge1xuICAgIGlmICghZmlsZSkgcmV0dXJuIHtsaW5lOiAwLCBjaDogMH07XG4gICAgdmFyIG9mZnNldHMgPSBmaWxlLmxpbmVPZmZzZXRzIHx8IChmaWxlLmxpbmVPZmZzZXRzID0gWzBdKTtcbiAgICB2YXIgdGV4dCA9IGZpbGUudGV4dCwgbGluZSwgbGluZVN0YXJ0O1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBpZiAob2Zmc2V0c1tpXSA8PSBwb3MpIHtcbiAgICAgIGxpbmUgPSBpICogb2Zmc2V0U2tpcExpbmVzO1xuICAgICAgbGluZVN0YXJ0ID0gb2Zmc2V0c1tpXTtcbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGVvbCA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBsaW5lU3RhcnQpO1xuICAgICAgaWYgKGVvbCA+PSBwb3MgfHwgZW9sIDwgMCkgYnJlYWs7XG4gICAgICBsaW5lU3RhcnQgPSBlb2wgKyAxO1xuICAgICAgKytsaW5lO1xuICAgIH1cbiAgICByZXR1cm4ge2xpbmU6IGxpbmUsIGNoOiBjaGFyRGlzdGFuY2VCZXR3ZWVuKGZpbGUsIGxpbmVTdGFydCwgcG9zKX07XG4gIH1cblxuICB2YXIgb3V0cHV0UG9zID0gZXhwb3J0cy5vdXRwdXRQb3MgPSBmdW5jdGlvbihxdWVyeSwgZmlsZSwgcG9zKSB7XG4gICAgaWYgKHF1ZXJ5LmxpbmVDaGFyUG9zaXRpb25zKSB7XG4gICAgICB2YXIgb3V0ID0gYXNMaW5lQ2hhcihmaWxlLCBwb3MpO1xuICAgICAgaWYgKGZpbGUudHlwZSA9PSBcInBhcnRcIilcbiAgICAgICAgb3V0LmxpbmUgKz0gZmlsZS5vZmZzZXRMaW5lcyAhPSBudWxsID8gZmlsZS5vZmZzZXRMaW5lcyA6IGFzTGluZUNoYXIoZmlsZS5iYWNraW5nLCBmaWxlLm9mZnNldCkubGluZTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFyRGlzdGFuY2VCZXR3ZWVuKGZpbGUsIDAsIHBvcykgKyAoZmlsZS50eXBlID09IFwicGFydFwiID8gZmlsZS5vZmZzZXQgOiAwKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVsZXRlIGVtcHR5IGZpZWxkcyBmcm9tIHJlc3VsdCBvYmplY3RzXG4gIGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSBpZiAob2JqW3Byb3BdID09IG51bGwpIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBtYXliZVNldChvYmosIHByb3AsIHZhbCkge1xuICAgIGlmICh2YWwgIT0gbnVsbCkgb2JqW3Byb3BdID0gdmFsO1xuICB9XG5cbiAgLy8gQnVpbHQtaW4gcXVlcnkgdHlwZXNcblxuICBmdW5jdGlvbiBjb21wYXJlQ29tcGxldGlvbnMoYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSAhPSBcInN0cmluZ1wiKSB7IGEgPSBhLm5hbWU7IGIgPSBiLm5hbWU7IH1cbiAgICB2YXIgYVVwID0gL15bQS1aXS8udGVzdChhKSwgYlVwID0gL15bQS1aXS8udGVzdChiKTtcbiAgICBpZiAoYVVwID09IGJVcCkgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09IGIgPyAwIDogMTtcbiAgICBlbHNlIHJldHVybiBhVXAgPyAxIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmluZ0Fyb3VuZChub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Ygbm9kZS52YWx1ZSA9PSBcInN0cmluZ1wiICYmXG4gICAgICBub2RlLnN0YXJ0ID09IHN0YXJ0IC0gMSAmJiBub2RlLmVuZCA8PSBlbmQgKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnRJblByb3Aob2JqTm9kZSwgcG9pbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iak5vZGUucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1clByb3AgPSBvYmpOb2RlLnByb3BlcnRpZXNbaV07XG4gICAgICBpZiAoY3VyUHJvcC5rZXkgJiYgY3VyUHJvcC5rZXkuc3RhcnQgPD0gcG9pbnQgJiYgY3VyUHJvcC5rZXkuZW5kID49IHBvaW50KVxuICAgICAgICByZXR1cm4gY3VyUHJvcDtcbiAgICB9XG4gIH1cblxuICB2YXIganNLZXl3b3JkcyA9IChcImJyZWFrIGRvIGluc3RhbmNlb2YgdHlwZW9mIGNhc2UgZWxzZSBuZXcgdmFyIFwiICtcbiAgICBcImNhdGNoIGZpbmFsbHkgcmV0dXJuIHZvaWQgY29udGludWUgZm9yIHN3aXRjaCB3aGlsZSBkZWJ1Z2dlciBcIiArXG4gICAgXCJmdW5jdGlvbiB0aGlzIHdpdGggZGVmYXVsdCBpZiB0aHJvdyBkZWxldGUgaW4gdHJ5XCIpLnNwbGl0KFwiIFwiKTtcbiAgdmFyIGpzS2V5d29yZHNFUzYgPSBqc0tleXdvcmRzLmNvbmNhdChcImV4cG9ydCBjbGFzcyBleHRlbmRzIGNvbnN0IHN1cGVyIHlpZWxkIGltcG9ydCBsZXQgc3RhdGljXCIuc3BsaXQoXCIgXCIpKTtcblxuICB2YXIgYWRkQ29tcGxldGlvbiA9IGV4cG9ydHMuYWRkQ29tcGxldGlvbiA9IGZ1bmN0aW9uKHF1ZXJ5LCBjb21wbGV0aW9ucywgbmFtZSwgYXZhbCwgZGVwdGgpIHtcbiAgICB2YXIgdHlwZUluZm8gPSBxdWVyeS50eXBlcyB8fCBxdWVyeS5kb2NzIHx8IHF1ZXJ5LnVybHMgfHwgcXVlcnkub3JpZ2lucztcbiAgICB2YXIgd3JhcEFzT2JqcyA9IHR5cGVJbmZvIHx8IHF1ZXJ5LmRlcHRocztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcGxldGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjID0gY29tcGxldGlvbnNbaV07XG4gICAgICBpZiAoKHdyYXBBc09ianMgPyBjLm5hbWUgOiBjKSA9PSBuYW1lKSByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWMgPSB3cmFwQXNPYmpzID8ge25hbWU6IG5hbWV9IDogbmFtZTtcbiAgICBjb21wbGV0aW9ucy5wdXNoKHJlYyk7XG5cbiAgICBpZiAoYXZhbCAmJiB0eXBlSW5mbykge1xuICAgICAgaW5mZXIucmVzZXRHdWVzc2luZygpO1xuICAgICAgdmFyIHR5cGUgPSBhdmFsLmdldFR5cGUoKTtcbiAgICAgIHJlYy5ndWVzcyA9IGluZmVyLmRpZEd1ZXNzKCk7XG4gICAgICBpZiAocXVlcnkudHlwZXMpXG4gICAgICAgIHJlYy50eXBlID0gaW5mZXIudG9TdHJpbmcoYXZhbCk7XG4gICAgICBpZiAocXVlcnkuZG9jcylcbiAgICAgICAgbWF5YmVTZXQocmVjLCBcImRvY1wiLCBwYXJzZURvYyhxdWVyeSwgYXZhbC5kb2MgfHwgdHlwZSAmJiB0eXBlLmRvYykpO1xuICAgICAgaWYgKHF1ZXJ5LnVybHMpXG4gICAgICAgIG1heWJlU2V0KHJlYywgXCJ1cmxcIiwgYXZhbC51cmwgfHwgdHlwZSAmJiB0eXBlLnVybCk7XG4gICAgICBpZiAocXVlcnkub3JpZ2lucylcbiAgICAgICAgbWF5YmVTZXQocmVjLCBcIm9yaWdpblwiLCBhdmFsLm9yaWdpbiB8fCB0eXBlICYmIHR5cGUub3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRlcHRocykgcmVjLmRlcHRoID0gZGVwdGggfHwgMDtcbiAgICByZXR1cm4gcmVjO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRDb21wbGV0aW9ucyhzcnYsIHF1ZXJ5LCBmaWxlKSB7XG4gICAgaWYgKHF1ZXJ5LmVuZCA9PSBudWxsKSB0aHJvdyB0ZXJuRXJyb3IoXCJtaXNzaW5nIC5xdWVyeS5lbmQgZmllbGRcIik7XG4gICAgdmFyIGZyb21QbHVnaW4gPSBzcnYuc2lnbmFsUmV0dXJuRmlyc3QoXCJjb21wbGV0aW9uXCIsIGZpbGUsIHF1ZXJ5KTtcbiAgICBpZiAoZnJvbVBsdWdpbikgcmV0dXJuIGZyb21QbHVnaW47XG5cbiAgICB2YXIgd29yZFN0YXJ0ID0gcmVzb2x2ZVBvcyhmaWxlLCBxdWVyeS5lbmQpLCB3b3JkRW5kID0gd29yZFN0YXJ0LCB0ZXh0ID0gZmlsZS50ZXh0O1xuICAgIHdoaWxlICh3b3JkU3RhcnQgJiYgYWNvcm4uaXNJZGVudGlmaWVyQ2hhcih0ZXh0LmNoYXJDb2RlQXQod29yZFN0YXJ0IC0gMSkpKSAtLXdvcmRTdGFydDtcbiAgICBpZiAocXVlcnkuZXhwYW5kV29yZEZvcndhcmQgIT09IGZhbHNlKVxuICAgICAgd2hpbGUgKHdvcmRFbmQgPCB0ZXh0Lmxlbmd0aCAmJiBhY29ybi5pc0lkZW50aWZpZXJDaGFyKHRleHQuY2hhckNvZGVBdCh3b3JkRW5kKSkpICsrd29yZEVuZDtcbiAgICB2YXIgd29yZCA9IHRleHQuc2xpY2Uod29yZFN0YXJ0LCB3b3JkRW5kKSwgY29tcGxldGlvbnMgPSBbXSwgaWdub3JlT2JqO1xuICAgIGlmIChxdWVyeS5jYXNlSW5zZW5zaXRpdmUpIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBmdW5jdGlvbiBnYXRoZXIocHJvcCwgb2JqLCBkZXB0aCwgYWRkSW5mbykge1xuICAgICAgLy8gJ2hhc093blByb3BlcnR5JyBhbmQgc3VjaCBhcmUgdXN1YWxseSBqdXN0IG5vaXNlLCBsZWF2ZSB0aGVtXG4gICAgICAvLyBvdXQgd2hlbiBubyBwcmVmaXggaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoKG9iakxpdCB8fCBxdWVyeS5vbWl0T2JqZWN0UHJvdG90eXBlICE9PSBmYWxzZSkgJiYgb2JqID09IHNydi5jeC5wcm90b3MuT2JqZWN0ICYmICF3b3JkKSByZXR1cm47XG4gICAgICBpZiAocXVlcnkuZmlsdGVyICE9PSBmYWxzZSAmJiB3b3JkICYmXG4gICAgICAgICAgKHF1ZXJ5LmNhc2VJbnNlbnNpdGl2ZSA/IHByb3AudG9Mb3dlckNhc2UoKSA6IHByb3ApLmluZGV4T2Yod29yZCkgIT09IDApIHJldHVybjtcbiAgICAgIGlmIChpZ25vcmVPYmogJiYgaWdub3JlT2JqLnByb3BzW3Byb3BdKSByZXR1cm47XG4gICAgICB2YXIgcmVzdWx0ID0gYWRkQ29tcGxldGlvbihxdWVyeSwgY29tcGxldGlvbnMsIHByb3AsIG9iaiAmJiBvYmoucHJvcHNbcHJvcF0sIGRlcHRoKTtcbiAgICAgIGlmIChhZGRJbmZvICYmIHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ICE9IFwic3RyaW5nXCIpIGFkZEluZm8ocmVzdWx0KTtcbiAgICB9XG5cbiAgICB2YXIgaG9va25hbWUsIHByb3AsIG9ialR5cGUsIGlzS2V5O1xuXG4gICAgdmFyIGV4cHJBdCA9IGluZmVyLmZpbmRFeHByZXNzaW9uQXJvdW5kKGZpbGUuYXN0LCBudWxsLCB3b3JkU3RhcnQsIGZpbGUuc2NvcGUpO1xuICAgIHZhciBtZW1iZXJFeHByLCBvYmpMaXQ7XG4gICAgLy8gRGVjaWRlIHdoZXRoZXIgdGhpcyBpcyBhbiBvYmplY3QgcHJvcGVydHksIGVpdGhlciBpbiBhIG1lbWJlclxuICAgIC8vIGV4cHJlc3Npb24gb3IgYW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgaWYgKGV4cHJBdCkge1xuICAgICAgdmFyIGV4cHJOb2RlID0gZXhwckF0Lm5vZGU7XG5cbiAgICAgIGlmIChxdWVyeS5pbkxpdGVyYWwgPT09IGZhbHNlICYmIGV4cHJOb2RlLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICAgICAgKHR5cGVvZiBleHByTm9kZS52YWx1ZSA9PT0gJ3N0cmluZycgfHwgZXhwck5vZGUucmVnZXgpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiBvdXRwdXRQb3MocXVlcnksIGZpbGUsIHdvcmRTdGFydCksXG4gICAgICAgICAgZW5kOiBvdXRwdXRQb3MocXVlcnksIGZpbGUsIHdvcmRFbmQpLFxuICAgICAgICAgIGNvbXBsZXRpb25zOiBbXVxuICAgICAgICB9O1xuXG4gICAgICBpZiAoZXhwck5vZGUudHlwZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBleHByTm9kZS5vYmplY3QuZW5kIDwgd29yZFN0YXJ0KSB7XG4gICAgICAgIG1lbWJlckV4cHIgPSBleHByQXQ7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nQXJvdW5kKGV4cHJOb2RlLCB3b3JkU3RhcnQsIHdvcmRFbmQpKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBpbmZlci5wYXJlbnROb2RlKGV4cHJOb2RlLCBmaWxlLmFzdCk7XG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBwYXJlbnQucHJvcGVydHkgPT0gZXhwck5vZGUpXG4gICAgICAgICAgbWVtYmVyRXhwciA9IHtub2RlOiBwYXJlbnQsIHN0YXRlOiBleHByQXQuc3RhdGV9O1xuICAgICAgfSBlbHNlIGlmIChleHByTm9kZS50eXBlID09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHZhciBvYmpQcm9wID0gcG9pbnRJblByb3AoZXhwck5vZGUsIHdvcmRFbmQpO1xuICAgICAgICBpZiAob2JqUHJvcCkge1xuICAgICAgICAgIG9iakxpdCA9IGV4cHJBdDtcbiAgICAgICAgICBwcm9wID0gaXNLZXkgPSBvYmpQcm9wLmtleS5uYW1lIHx8IG9ialByb3Aua2V5LnZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKCF3b3JkICYmICEvOlxccyokLy50ZXN0KGZpbGUudGV4dC5zbGljZSgwLCB3b3JkU3RhcnQpKSkge1xuICAgICAgICAgIG9iakxpdCA9IGV4cHJBdDtcbiAgICAgICAgICBwcm9wID0gaXNLZXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iakxpdCkge1xuICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgdXNlIHRoZSB0eXBlIG9mIHRoZSBsaXRlcmFsIGl0c2VsZiB0byBjb21wbGV0ZVxuICAgICAgLy8gaXRzIHByb3BlcnRpZXMgKGl0IGRvZXNuJ3QgY29udGFpbiB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZCksXG4gICAgICAvLyB3ZSBoYXZlIHRvIHRyeSBhc2tpbmcgdGhlIHN1cnJvdW5kaW5nIGV4cHJlc3Npb24gZm9yIHR5cGUgaW5mby5cbiAgICAgIG9ialR5cGUgPSBpbmZlci50eXBlRnJvbUNvbnRleHQoZmlsZS5hc3QsIG9iakxpdCk7XG4gICAgICBpZ25vcmVPYmogPSBvYmpMaXQubm9kZS5vYmpUeXBlO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyRXhwcikge1xuICAgICAgcHJvcCA9IG1lbWJlckV4cHIubm9kZS5wcm9wZXJ0eTtcbiAgICAgIHByb3AgPSBwcm9wLnR5cGUgPT0gXCJMaXRlcmFsXCIgPyBwcm9wLnZhbHVlLnNsaWNlKDEpIDogcHJvcC5uYW1lO1xuICAgICAgbWVtYmVyRXhwci5ub2RlID0gbWVtYmVyRXhwci5ub2RlLm9iamVjdDtcbiAgICAgIG9ialR5cGUgPSBpbmZlci5leHByZXNzaW9uVHlwZShtZW1iZXJFeHByKTtcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckF0KHdvcmRTdGFydCAtIDEpID09IFwiLlwiKSB7XG4gICAgICB2YXIgcGF0aFN0YXJ0ID0gd29yZFN0YXJ0IC0gMTtcbiAgICAgIHdoaWxlIChwYXRoU3RhcnQgJiYgKHRleHQuY2hhckF0KHBhdGhTdGFydCAtIDEpID09IFwiLlwiIHx8IGFjb3JuLmlzSWRlbnRpZmllckNoYXIodGV4dC5jaGFyQ29kZUF0KHBhdGhTdGFydCAtIDEpKSkpIHBhdGhTdGFydC0tO1xuICAgICAgdmFyIHBhdGggPSB0ZXh0LnNsaWNlKHBhdGhTdGFydCwgd29yZFN0YXJ0IC0gMSk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBvYmpUeXBlID0gaW5mZXIuZGVmLnBhcnNlUGF0aChwYXRoLCBmaWxlLnNjb3BlKS5nZXRPYmpUeXBlKCk7XG4gICAgICAgIHByb3AgPSB3b3JkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wICE9IG51bGwpIHtcbiAgICAgIHNydi5jeC5jb21wbGV0aW5nUHJvcGVydHkgPSBwcm9wO1xuXG4gICAgICBpZiAob2JqVHlwZSkgaW5mZXIuZm9yQWxsUHJvcGVydGllc09mKG9ialR5cGUsIGdhdGhlcik7XG5cbiAgICAgIGlmICghY29tcGxldGlvbnMubGVuZ3RoICYmIHF1ZXJ5Lmd1ZXNzICE9PSBmYWxzZSAmJiBvYmpUeXBlICYmIG9ialR5cGUuZ3Vlc3NQcm9wZXJ0aWVzKVxuICAgICAgICBvYmpUeXBlLmd1ZXNzUHJvcGVydGllcyhmdW5jdGlvbihwLCBvLCBkKSB7aWYgKHAgIT0gcHJvcCAmJiBwICE9IFwi4pyWXCIgJiYgcCAhPSBcIjxpPlwiKSBnYXRoZXIocCwgbywgZCk7fSk7XG4gICAgICBpZiAoIWNvbXBsZXRpb25zLmxlbmd0aCAmJiB3b3JkLmxlbmd0aCA+PSAyICYmIHF1ZXJ5Lmd1ZXNzICE9PSBmYWxzZSlcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzcnYuY3gucHJvcHMpIGdhdGhlcihwcm9wLCBzcnYuY3gucHJvcHNbcHJvcF1bMF0sIDApO1xuICAgICAgaG9va25hbWUgPSBcIm1lbWJlckNvbXBsZXRpb25cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mZXIuZm9yQWxsTG9jYWxzQXQoZmlsZS5hc3QsIHdvcmRTdGFydCwgZmlsZS5zY29wZSwgZ2F0aGVyKTtcbiAgICAgIGlmIChxdWVyeS5pbmNsdWRlS2V5d29yZHMpIHtcbiAgICAgICAgKHNydi5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBqc0tleXdvcmRzRVM2IDoganNLZXl3b3JkcykuZm9yRWFjaChmdW5jdGlvbihrdykge1xuICAgICAgICAgIGdhdGhlcihrdywgbnVsbCwgMCwgZnVuY3Rpb24ocmVjKSB7IHJlYy5pc0tleXdvcmQgPSB0cnVlOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBob29rbmFtZSA9IFwidmFyaWFibGVDb21wbGV0aW9uXCI7XG4gICAgfVxuICAgIHNydi5zaWduYWwoaG9va25hbWUsIGZpbGUsIHdvcmRTdGFydCwgd29yZEVuZCwgZ2F0aGVyKTtcblxuICAgIGlmIChxdWVyeS5zb3J0ICE9PSBmYWxzZSkgY29tcGxldGlvbnMuc29ydChjb21wYXJlQ29tcGxldGlvbnMpO1xuICAgIHNydi5jeC5jb21wbGV0aW5nUHJvcGVydHkgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtzdGFydDogb3V0cHV0UG9zKHF1ZXJ5LCBmaWxlLCB3b3JkU3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBvdXRwdXRQb3MocXVlcnksIGZpbGUsIHdvcmRFbmQpLFxuICAgICAgICAgICAgaXNQcm9wZXJ0eTogISFwcm9wLFxuICAgICAgICAgICAgaXNPYmplY3RLZXk6ICEhaXNLZXksXG4gICAgICAgICAgICBjb21wbGV0aW9uczogY29tcGxldGlvbnN9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFByb3BlcnRpZXMoc3J2LCBxdWVyeSkge1xuICAgIHZhciBwcmVmaXggPSBxdWVyeS5wcmVmaXgsIGZvdW5kID0gW107XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzcnYuY3gucHJvcHMpXG4gICAgICBpZiAocHJvcCAhPSBcIjxpPlwiICYmICghcHJlZml4IHx8IHByb3AuaW5kZXhPZihwcmVmaXgpID09PSAwKSkgZm91bmQucHVzaChwcm9wKTtcbiAgICBpZiAocXVlcnkuc29ydCAhPT0gZmFsc2UpIGZvdW5kLnNvcnQoY29tcGFyZUNvbXBsZXRpb25zKTtcbiAgICByZXR1cm4ge2NvbXBsZXRpb25zOiBmb3VuZH07XG4gIH1cblxuICBmdW5jdGlvbiBpbkJvZHkobm9kZSwgcG9zKSB7XG4gICAgdmFyIGJvZHkgPSBub2RlLmJvZHksIHN0YXJ0LCBlbmQ7XG4gICAgaWYgKCFib2R5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYm9keSkpIHtcbiAgICAgIHN0YXJ0ID0gYm9keVswXS5zdGFydDtcbiAgICAgIGVuZCA9IGJvZHlbYm9keS5sZW5ndGggLSAxXS5lbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gYm9keS5zdGFydDtcbiAgICAgIGVuZCA9IGJvZHkuZW5kO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnQgPD0gcG9zICYmIGVuZCA+PSBwb3M7XG4gIH1cblxuICB2YXIgZmluZEV4cHIgPSBleHBvcnRzLmZpbmRRdWVyeUV4cHIgPSBmdW5jdGlvbihmaWxlLCBxdWVyeSwgd2lkZSkge1xuICAgIGlmIChxdWVyeS5lbmQgPT0gbnVsbCkgdGhyb3cgdGVybkVycm9yKFwibWlzc2luZyAucXVlcnkuZW5kIGZpZWxkXCIpO1xuXG4gICAgaWYgKHF1ZXJ5LnZhcmlhYmxlKSB7XG4gICAgICB2YXIgc2NvcGUgPSBpbmZlci5zY29wZUF0KGZpbGUuYXN0LCByZXNvbHZlUG9zKGZpbGUsIHF1ZXJ5LmVuZCksIGZpbGUuc2NvcGUpO1xuICAgICAgcmV0dXJuIHtub2RlOiB7dHlwZTogXCJJZGVudGlmaWVyXCIsIG5hbWU6IHF1ZXJ5LnZhcmlhYmxlLCBzdGFydDogcXVlcnkuZW5kLCBlbmQ6IHF1ZXJ5LmVuZCArIDF9LFxuICAgICAgICAgICAgICBzdGF0ZTogc2NvcGV9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBxdWVyeS5zdGFydCAmJiByZXNvbHZlUG9zKGZpbGUsIHF1ZXJ5LnN0YXJ0KSwgZW5kID0gcmVzb2x2ZVBvcyhmaWxlLCBxdWVyeS5lbmQpO1xuICAgICAgdmFyIGV4cHIgPSBpbmZlci5maW5kRXhwcmVzc2lvbkF0KGZpbGUuYXN0LCBzdGFydCwgZW5kLCBmaWxlLnNjb3BlKTtcbiAgICAgIGlmICghZXhwcikge1xuICAgICAgICB2YXIgc3BhbiA9IGluZmVyLmZpbmRDbG9zZXN0RXhwcmVzc2lvbihmaWxlLmFzdCwgc3RhcnQsIGVuZCwgZmlsZS5zY29wZSk7XG4gICAgICAgIGlmIChzcGFuICYmICFpbkJvZHkoc3Bhbi5ub2RlLCBlbmQpICYmXG4gICAgICAgICAgICAod2lkZSB8fCAoc3RhcnQgPT0gbnVsbCA/IGVuZCA6IHN0YXJ0KSAtIHNwYW4ubm9kZS5zdGFydCA8IDIwIHx8IHNwYW4ubm9kZS5lbmQgLSBlbmQgPCAyMCkpXG4gICAgICAgICAgZXhwciA9IHNwYW47XG4gICAgICB9XG4gICAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgdmFyIGFyb3VuZCA9IGluZmVyLmZpbmRFeHByZXNzaW9uQXJvdW5kKGZpbGUuYXN0LCBzdGFydCwgZW5kLCBmaWxlLnNjb3BlKTtcbiAgICAgICAgaWYgKGFyb3VuZCAmJiAhaW5Cb2R5KGFyb3VuZC5ub2RlLCBlbmQpICYmXG4gICAgICAgICAgICAoYXJvdW5kLm5vZGUudHlwZSA9PSBcIk9iamVjdEV4cHJlc3Npb25cIiB8fCB3aWRlIHx8XG4gICAgICAgICAgICAgKHN0YXJ0ID09IG51bGwgPyBlbmQgOiBzdGFydCkgLSBhcm91bmQubm9kZS5zdGFydCA8IDIwIHx8IGFyb3VuZC5ub2RlLmVuZCAtIGVuZCA8IDIwKSlcbiAgICAgICAgICBleHByID0gYXJvdW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRFeHByQXJvdW5kKGZpbGUsIHF1ZXJ5LCB3aWRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gcXVlcnkuc3RhcnQgJiYgcmVzb2x2ZVBvcyhmaWxlLCBxdWVyeS5zdGFydCksIGVuZCA9IHJlc29sdmVQb3MoZmlsZSwgcXVlcnkuZW5kKTtcbiAgICB2YXIgZXhwciA9IG51bGw7XG4gICAgdmFyIGFyb3VuZCA9IGluZmVyLmZpbmRFeHByZXNzaW9uQXJvdW5kKGZpbGUuYXN0LCBzdGFydCwgZW5kLCBmaWxlLnNjb3BlKTtcbiAgICBpZiAoYXJvdW5kICYmICFpbkJvZHkoYXJvdW5kLm5vZGUsIGVuZCkgJiZcbiAgICAgICAgKGFyb3VuZC5ub2RlLnR5cGUgPT0gXCJPYmplY3RFeHByZXNzaW9uXCIgfHwgd2lkZSB8fFxuICAgICAgICAgKHN0YXJ0ID09IG51bGwgPyBlbmQgOiBzdGFydCkgLSBhcm91bmQubm9kZS5zdGFydCA8IDIwIHx8IGFyb3VuZC5ub2RlLmVuZCAtIGVuZCA8IDIwKSlcbiAgICAgIGV4cHIgPSBhcm91bmQ7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRXhwck9yVGhyb3coZmlsZSwgcXVlcnksIHdpZGUpIHtcbiAgICB2YXIgZXhwciA9IGZpbmRFeHByKGZpbGUsIHF1ZXJ5LCB3aWRlKTtcbiAgICBpZiAoZXhwcikgcmV0dXJuIGV4cHI7XG4gICAgdGhyb3cgdGVybkVycm9yKFwiTm8gZXhwcmVzc2lvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlT2JqKHRwKSB7XG4gICAgaWYgKCF0cCB8fCAhKHRwID0gdHAuZ2V0VHlwZSgpKSB8fCAhKHRwIGluc3RhbmNlb2YgaW5mZXIuT2JqKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRwO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEV4cHJUeXBlKHNydiwgcXVlcnksIGZpbGUsIGV4cHIpIHtcbiAgICB2YXIgdHlwZTtcbiAgICBpZiAoZXhwcikge1xuICAgICAgaW5mZXIucmVzZXRHdWVzc2luZygpO1xuICAgICAgdHlwZSA9IGluZmVyLmV4cHJlc3Npb25UeXBlKGV4cHIpO1xuICAgIH1cbiAgICB2YXIgdHlwZUhhbmRsZXJzID0gc3J2Lmhhc0hhbmRsZXIoXCJ0eXBlQXRcIik7XG4gICAgaWYgKHR5cGVIYW5kbGVycykge1xuICAgICAgdmFyIHBvcyA9IHJlc29sdmVQb3MoZmlsZSwgcXVlcnkuZW5kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZUhhbmRsZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICB0eXBlID0gdHlwZUhhbmRsZXJzW2ldKGZpbGUsIHBvcywgZXhwciwgdHlwZSk7XG4gICAgfVxuICAgIGlmICghdHlwZSkgdGhyb3cgdGVybkVycm9yKFwiTm8gdHlwZSBmb3VuZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXCIpO1xuXG4gICAgdmFyIG9ialByb3A7XG4gICAgaWYgKGV4cHIubm9kZS50eXBlID09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIHF1ZXJ5LmVuZCAhPSBudWxsICYmXG4gICAgICAgIChvYmpQcm9wID0gcG9pbnRJblByb3AoZXhwci5ub2RlLCByZXNvbHZlUG9zKGZpbGUsIHF1ZXJ5LmVuZCkpKSkge1xuICAgICAgdmFyIG5hbWUgPSBvYmpQcm9wLmtleS5uYW1lO1xuICAgICAgdmFyIGZyb21DeCA9IGVuc3VyZU9iaihpbmZlci50eXBlRnJvbUNvbnRleHQoZmlsZS5hc3QsIGV4cHIpKTtcbiAgICAgIGlmIChmcm9tQ3ggJiYgZnJvbUN4Lmhhc1Byb3AobmFtZSkpIHtcbiAgICAgICAgdHlwZSA9IGZyb21DeC5oYXNQcm9wKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZyb21Mb2NhbCA9IGVuc3VyZU9iaih0eXBlKTtcbiAgICAgICAgaWYgKGZyb21Mb2NhbCAmJiBmcm9tTG9jYWwuaGFzUHJvcChuYW1lKSlcbiAgICAgICAgICB0eXBlID0gZnJvbUxvY2FsLmhhc1Byb3AobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFR5cGVBdEV4cHIoc3J2LCBxdWVyeSwgZmlsZSwgZXhwcikge1xuICAgIHZhciBleHByTmFtZSwgZXhwclR5cGU7XG4gICAgdmFyIHR5cGUgPSBmaW5kRXhwclR5cGUoc3J2LCBxdWVyeSwgZmlsZSwgZXhwciksIGV4cHJUeXBlID0gdHlwZTtcbiAgICBpZiAocXVlcnkucHJlZmVyRnVuY3Rpb24pXG4gICAgICB0eXBlID0gdHlwZS5nZXRGdW5jdGlvblR5cGUoKSB8fCB0eXBlLmdldFR5cGUoKTtcbiAgICBlbHNlXG4gICAgICB0eXBlID0gdHlwZS5nZXRUeXBlKCk7XG5cbiAgICBpZiAoZXhwcikge1xuICAgICAgaWYgKGV4cHIubm9kZS50eXBlID09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICBleHByTmFtZSA9IGV4cHIubm9kZS5uYW1lO1xuICAgICAgZWxzZSBpZiAoZXhwci5ub2RlLnR5cGUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIWV4cHIubm9kZS5jb21wdXRlZClcbiAgICAgICAgZXhwck5hbWUgPSBleHByLm5vZGUucHJvcGVydHkubmFtZTtcbiAgICAgIGVsc2UgaWYgKGV4cHIubm9kZS50eXBlID09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmICFleHByLm5vZGUuY29tcHV0ZWQpXG4gICAgICAgIGV4cHJOYW1lID0gZXhwci5ub2RlLmtleS5uYW1lO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5kZXB0aCAhPSBudWxsICYmIHR5cGVvZiBxdWVyeS5kZXB0aCAhPSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgdGVybkVycm9yKFwiLnF1ZXJ5LmRlcHRoIG11c3QgYmUgYSBudW1iZXJcIik7XG5cbiAgICByZXR1cm4gW3R5cGUsIGV4cHJOYW1lLCBleHByVHlwZV07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kVHlwZUF0KHNydiwgcXVlcnksIGZpbGUpIHtcbiAgICB2YXIgdHlwZSwgZXhwck5hbWUsIGV4cHJUeXBlO1xuICAgIHZhciBleHByID0gZmluZEV4cHIoZmlsZSwgcXVlcnkpO1xuICAgIHZhciB0eXBlUmVzdWx0ID0gZmluZFR5cGVBdEV4cHIoc3J2LCBxdWVyeSwgZmlsZSwgZXhwcik7XG4gICAgdHlwZSA9IHR5cGVSZXN1bHRbMF07XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICBleHByID0gZmluZEV4cHJBcm91bmQoZmlsZSwgcXVlcnkpO1xuICAgICAgdHlwZVJlc3VsdCA9IGZpbmRUeXBlQXRFeHByKHNydiwgcXVlcnksIGZpbGUsIGV4cHIpO1xuICAgICAgdHlwZSA9IHR5cGVSZXN1bHRbMF07XG4gICAgfVxuICAgIGV4cHJOYW1lID0gdHlwZVJlc3VsdFsxXTtcbiAgICBleHByVHlwZSA9IHR5cGVSZXN1bHRbMl07XG5cbiAgICB2YXIgcmVzdWx0ID0ge2d1ZXNzOiBpbmZlci5kaWRHdWVzcygpLFxuICAgICAgICAgICAgICAgICAgdHlwZTogaW5mZXIudG9TdHJpbmcoZXhwclR5cGUsIHF1ZXJ5LmRlcHRoKSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUgJiYgdHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgZXhwck5hbWU6IGV4cHJOYW1lLFxuICAgICAgICAgICAgICAgICAgZG9jOiBleHByVHlwZS5kb2MsXG4gICAgICAgICAgICAgICAgICB1cmw6IGV4cHJUeXBlLnVybH07XG4gICAgaWYgKHR5cGUpIHN0b3JlVHlwZURvY3MocXVlcnksIHR5cGUsIHJlc3VsdCk7XG5cbiAgICByZXR1cm4gY2xlYW4ocmVzdWx0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRG9jKHF1ZXJ5LCBkb2MpIHtcbiAgICBpZiAoIWRvYykgcmV0dXJuIG51bGw7XG4gICAgaWYgKHF1ZXJ5LmRvY0Zvcm1hdCA9PSBcImZ1bGxcIikgcmV0dXJuIGRvYztcbiAgICB2YXIgcGFyYWJyZWFrID0gLy5cXG5bXFxzQFxcbl0vLmV4ZWMoZG9jKTtcbiAgICBpZiAocGFyYWJyZWFrKSBkb2MgPSBkb2Muc2xpY2UoMCwgcGFyYWJyZWFrLmluZGV4ICsgMSk7XG4gICAgZG9jID0gZG9jLnJlcGxhY2UoL1xcblxccyovZywgXCIgXCIpO1xuICAgIGlmIChkb2MubGVuZ3RoIDwgMTAwKSByZXR1cm4gZG9jO1xuICAgIHZhciBzZW50ZW5jZUVuZCA9IC9bXFwuIT9dIFtBLVpdL2c7XG4gICAgc2VudGVuY2VFbmQubGFzdEluZGV4ID0gODA7XG4gICAgdmFyIGZvdW5kID0gc2VudGVuY2VFbmQuZXhlYyhkb2MpO1xuICAgIGlmIChmb3VuZCkgZG9jID0gZG9jLnNsaWNlKDAsIGZvdW5kLmluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREb2NzKHNydiwgcXVlcnksIGZpbGUpIHtcbiAgICB2YXIgZXhwciA9IGZpbmRFeHByKGZpbGUsIHF1ZXJ5KTtcbiAgICB2YXIgdHlwZSA9IGZpbmRFeHByVHlwZShzcnYsIHF1ZXJ5LCBmaWxlLCBleHByKTtcbiAgICB2YXIgaW5uZXIgPSB0eXBlLmdldFR5cGUoKTtcbiAgICBpZiAoIWlubmVyKSB7XG4gICAgICBleHByID0gZmluZEV4cHJBcm91bmQoZmlsZSwgcXVlcnkpO1xuICAgICAgdHlwZSA9IGZpbmRFeHByVHlwZShzcnYsIHF1ZXJ5LCBmaWxlLCBleHByKTtcbiAgICAgIGlubmVyID0gdHlwZS5nZXRUeXBlKCk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7dXJsOiB0eXBlLnVybCwgZG9jOiBwYXJzZURvYyhxdWVyeSwgdHlwZS5kb2MpLCB0eXBlOiBpbmZlci50b1N0cmluZyh0eXBlKX07XG4gICAgaWYgKGlubmVyKSBzdG9yZVR5cGVEb2NzKHF1ZXJ5LCBpbm5lciwgcmVzdWx0KTtcbiAgICByZXR1cm4gY2xlYW4ocmVzdWx0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3JlVHlwZURvY3MocXVlcnksIHR5cGUsIG91dCkge1xuICAgIGlmICghb3V0LnVybCkgb3V0LnVybCA9IHR5cGUudXJsO1xuICAgIGlmICghb3V0LmRvYykgb3V0LmRvYyA9IHBhcnNlRG9jKHF1ZXJ5LCB0eXBlLmRvYyk7XG4gICAgaWYgKCFvdXQub3JpZ2luKSBvdXQub3JpZ2luID0gdHlwZS5vcmlnaW47XG4gICAgdmFyIGN0b3IsIGJvcmluZyA9IGluZmVyLmN4KCkucHJvdG9zO1xuICAgIGlmICghb3V0LnVybCAmJiAhb3V0LmRvYyAmJiB0eXBlLnByb3RvICYmIChjdG9yID0gdHlwZS5wcm90by5oYXNDdG9yKSAmJlxuICAgICAgICB0eXBlLnByb3RvICE9IGJvcmluZy5PYmplY3QgJiYgdHlwZS5wcm90byAhPSBib3JpbmcuRnVuY3Rpb24gJiYgdHlwZS5wcm90byAhPSBib3JpbmcuQXJyYXkpIHtcbiAgICAgIG91dC51cmwgPSBjdG9yLnVybDtcbiAgICAgIG91dC5kb2MgPSBwYXJzZURvYyhxdWVyeSwgY3Rvci5kb2MpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZXRTcGFuID0gZXhwb3J0cy5nZXRTcGFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmoub3JpZ2luKSByZXR1cm47XG4gICAgaWYgKG9iai5vcmlnaW5Ob2RlKSB7XG4gICAgICB2YXIgbm9kZSA9IG9iai5vcmlnaW5Ob2RlO1xuICAgICAgaWYgKC9eRnVuY3Rpb24vLnRlc3Qobm9kZS50eXBlKSAmJiBub2RlLmlkKSBub2RlID0gbm9kZS5pZDtcbiAgICAgIHJldHVybiB7b3JpZ2luOiBvYmoub3JpZ2luLCBub2RlOiBub2RlfTtcbiAgICB9XG4gICAgaWYgKG9iai5zcGFuKSByZXR1cm4ge29yaWdpbjogb2JqLm9yaWdpbiwgc3Bhbjogb2JqLnNwYW59O1xuICB9O1xuXG4gIHZhciBzdG9yZVNwYW4gPSBleHBvcnRzLnN0b3JlU3BhbiA9IGZ1bmN0aW9uKHNydiwgcXVlcnksIHNwYW4sIHRhcmdldCkge1xuICAgIHRhcmdldC5vcmlnaW4gPSBzcGFuLm9yaWdpbjtcbiAgICBpZiAoc3Bhbi5zcGFuKSB7XG4gICAgICB2YXIgbSA9IC9eKFxcZCspXFxbKFxcZCspOihcXGQrKVxcXS0oXFxkKylcXFsoXFxkKyk6KFxcZCspXFxdJC8uZXhlYyhzcGFuLnNwYW4pO1xuICAgICAgdGFyZ2V0LnN0YXJ0ID0gcXVlcnkubGluZUNoYXJQb3NpdGlvbnMgPyB7bGluZTogTnVtYmVyKG1bMl0pLCBjaDogTnVtYmVyKG1bM10pfSA6IE51bWJlcihtWzFdKTtcbiAgICAgIHRhcmdldC5lbmQgPSBxdWVyeS5saW5lQ2hhclBvc2l0aW9ucyA/IHtsaW5lOiBOdW1iZXIobVs1XSksIGNoOiBOdW1iZXIobVs2XSl9IDogTnVtYmVyKG1bNF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlsZSA9IHNydi5maWxlTWFwW3NwYW4ub3JpZ2luXTtcbiAgICAgIHRhcmdldC5zdGFydCA9IG91dHB1dFBvcyhxdWVyeSwgZmlsZSwgc3Bhbi5ub2RlLnN0YXJ0KTtcbiAgICAgIHRhcmdldC5lbmQgPSBvdXRwdXRQb3MocXVlcnksIGZpbGUsIHNwYW4ubm9kZS5lbmQpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kRGVmKHNydiwgcXVlcnksIGZpbGUpIHtcbiAgICB2YXIgZXhwciA9IGZpbmRFeHByKGZpbGUsIHF1ZXJ5KTtcbiAgICB2YXIgdHlwZSA9IGZpbmRFeHByVHlwZShzcnYsIHF1ZXJ5LCBmaWxlLCBleHByKTtcbiAgICBpZiAoaW5mZXIuZGlkR3Vlc3MoKSkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIHNwYW4gPSBnZXRTcGFuKHR5cGUpO1xuICAgIHZhciByZXN1bHQgPSB7dXJsOiB0eXBlLnVybCwgZG9jOiBwYXJzZURvYyhxdWVyeSwgdHlwZS5kb2MpLCBvcmlnaW46IHR5cGUub3JpZ2lufTtcblxuICAgIGlmICh0eXBlLnR5cGVzKSBmb3IgKHZhciBpID0gdHlwZS50eXBlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHRwID0gdHlwZS50eXBlc1tpXTtcbiAgICAgIHN0b3JlVHlwZURvY3MocXVlcnksIHRwLCByZXN1bHQpO1xuICAgICAgaWYgKCFzcGFuKSBzcGFuID0gZ2V0U3Bhbih0cCk7XG4gICAgfVxuXG4gICAgaWYgKHNwYW4gJiYgc3Bhbi5ub2RlKSB7IC8vIHJlZmVycyB0byBhIGxvYWRlZCBmaWxlXG4gICAgICB2YXIgc3BhbkZpbGUgPSBzcGFuLm5vZGUuc291cmNlRmlsZSB8fCBzcnYuZmlsZU1hcFtzcGFuLm9yaWdpbl07XG4gICAgICB2YXIgc3RhcnQgPSBvdXRwdXRQb3MocXVlcnksIHNwYW5GaWxlLCBzcGFuLm5vZGUuc3RhcnQpLCBlbmQgPSBvdXRwdXRQb3MocXVlcnksIHNwYW5GaWxlLCBzcGFuLm5vZGUuZW5kKTtcbiAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0OyByZXN1bHQuZW5kID0gZW5kO1xuICAgICAgcmVzdWx0LmZpbGUgPSBzcGFuLm9yaWdpbjtcbiAgICAgIHZhciBjeFN0YXJ0ID0gTWF0aC5tYXgoMCwgc3Bhbi5ub2RlLnN0YXJ0IC0gNTApO1xuICAgICAgcmVzdWx0LmNvbnRleHRPZmZzZXQgPSBzcGFuLm5vZGUuc3RhcnQgLSBjeFN0YXJ0O1xuICAgICAgcmVzdWx0LmNvbnRleHQgPSBzcGFuRmlsZS50ZXh0LnNsaWNlKGN4U3RhcnQsIGN4U3RhcnQgKyA1MCk7XG4gICAgfSBlbHNlIGlmIChzcGFuKSB7IC8vIGV4dGVybmFsXG4gICAgICByZXN1bHQuZmlsZSA9IHNwYW4ub3JpZ2luO1xuICAgICAgc3RvcmVTcGFuKHNydiwgcXVlcnksIHNwYW4sIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBjbGVhbihyZXN1bHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFJlZnNUb1ZhcmlhYmxlKHNydiwgcXVlcnksIGZpbGUsIGV4cHIsIGlzUmVuYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBleHByLm5vZGUubmFtZTtcblxuICAgIGZvciAodmFyIHNjb3BlID0gZXhwci5zdGF0ZTsgc2NvcGUgJiYgIShuYW1lIGluIHNjb3BlLnByb3BzKTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7fVxuICAgIGlmICghc2NvcGUpIHRocm93IHRlcm5FcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZGVmaW5pdGlvbiBmb3IgXCIgKyBuYW1lKTtcblxuICAgIHZhciB0eXBlLCByZWZzID0gW107XG4gICAgZnVuY3Rpb24gc3RvcmVSZWYoZmlsZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHNjb3BlSGVyZSwgYW5jZXN0b3JzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHtmaWxlOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICBzdGFydDogb3V0cHV0UG9zKHF1ZXJ5LCBmaWxlLCBub2RlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgIGVuZDogb3V0cHV0UG9zKHF1ZXJ5LCBmaWxlLCBub2RlLmVuZCl9O1xuICAgICAgICBpZiAoaXNSZW5hbWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBzID0gc2NvcGVIZXJlOyBzICE9IHNjb3BlOyBzID0gcy5wcmV2KSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RzID0gcy5oYXNQcm9wKGlzUmVuYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICAgIHRocm93IHRlcm5FcnJvcihcIlJlbmFtaW5nIGBcIiArIG5hbWUgKyBcImAgdG8gYFwiICsgaXNSZW5hbWUgKyBcImAgd291bGQgbWFrZSBhIHZhcmlhYmxlIGF0IGxpbmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzTGluZUNoYXIoZmlsZSwgbm9kZS5zdGFydCkubGluZSArIDEpICsgXCIgcG9pbnQgdG8gdGhlIGRlZmluaXRpb24gYXQgbGluZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXNMaW5lQ2hhcihmaWxlLCBleGlzdHMubmFtZS5zdGFydCkubGluZSArIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSBcIlByb3BlcnR5XCIgJiYgcGFyZW50LmtleSA9PSBwYXJlbnQudmFsdWUpXG4gICAgICAgICAgICB2YWx1ZS5pc1Nob3J0aGFuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLm9yaWdpbk5vZGUpIHtcbiAgICAgIHR5cGUgPSBcImxvY2FsXCI7XG4gICAgICBpZiAoaXNSZW5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgcHJldiA9IHNjb3BlLnByZXY7IHByZXY7IHByZXYgPSBwcmV2LnByZXYpXG4gICAgICAgICAgaWYgKGlzUmVuYW1lIGluIHByZXYucHJvcHMpIGJyZWFrO1xuICAgICAgICBpZiAocHJldikgaW5mZXIuZmluZFJlZnMoc2NvcGUub3JpZ2luTm9kZSwgc2NvcGUsIGlzUmVuYW1lLCBwcmV2LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdGhyb3cgdGVybkVycm9yKFwiUmVuYW1pbmcgYFwiICsgbmFtZSArIFwiYCB0byBgXCIgKyBpc1JlbmFtZSArIFwiYCB3b3VsZCBzaGFkb3cgdGhlIGRlZmluaXRpb24gdXNlZCBhdCBsaW5lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzTGluZUNoYXIoZmlsZSwgbm9kZS5zdGFydCkubGluZSArIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpbmZlci5maW5kUmVmcyhzY29wZS5vcmlnaW5Ob2RlLCBzY29wZSwgbmFtZSwgc2NvcGUsIHN0b3JlUmVmKGZpbGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IFwiZ2xvYmFsXCI7XG4gICAgICBpZiAocXVlcnkub25seVNvdXJjZUZpbGUpIHtcbiAgICAgICAgaW5mZXIuZmluZFJlZnMoZmlsZS5hc3QsIGZpbGUuc2NvcGUsIG5hbWUsIHNjb3BlLCBzdG9yZVJlZihmaWxlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNydi5maWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBjdXIgPSBzcnYuZmlsZXNbaV07XG4gICAgICAgICAgaW5mZXIuZmluZFJlZnMoY3VyLmFzdCwgY3VyLnNjb3BlLCBuYW1lLCBzY29wZSwgc3RvcmVSZWYoY3VyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3JlZnM6IHJlZnMsIHR5cGU6IHR5cGUsIG5hbWU6IG5hbWV9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFJlZnNUb1Byb3BlcnR5KHNydiwgcXVlcnksIHNvdXJjZUZpbGUsIGV4cHIsIHByb3ApIHtcbiAgICB2YXIgZXhwclR5cGUgPSBpbmZlci5leHByZXNzaW9uVHlwZShleHByKTtcbiAgICBpZiAoZXhwci5ub2RlLnR5cGUgPT0gXCJNZXRob2REZWZpbml0aW9uXCIpIHtcbiAgICAgIGV4cHJUeXBlID0gZXhwclR5cGUucHJvcGVydHlPZjtcbiAgICB9XG4gICAgdmFyIG9ialR5cGUgPSBleHByVHlwZS5nZXRPYmpUeXBlKCk7XG4gICAgaWYgKCFvYmpUeXBlKSB0aHJvdyB0ZXJuRXJyb3IoXCJDb3VsZG4ndCBkZXRlcm1pbmUgdHlwZSBvZiBiYXNlIG9iamVjdC5cIik7XG5cbiAgICB2YXIgcmVmcyA9IFtdO1xuICAgIGZ1bmN0aW9uIHN0b3JlUmVmKGZpbGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJlZnMucHVzaCh7ZmlsZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBvdXRwdXRQb3MocXVlcnksIGZpbGUsIG5vZGUuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgIGVuZDogb3V0cHV0UG9zKHF1ZXJ5LCBmaWxlLCBub2RlLmVuZCl9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHF1ZXJ5Lm9ubHlTb3VyY2VGaWxlKSB7XG4gICAgICAgIGluZmVyLmZpbmRQcm9wUmVmcyhzb3VyY2VGaWxlLmFzdCwgc291cmNlRmlsZS5zY29wZSwgb2JqVHlwZSwgcHJvcC5uYW1lLCBzdG9yZVJlZihzb3VyY2VGaWxlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3J2LmZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXIgPSBzcnYuZmlsZXNbaV07XG4gICAgICAgIGluZmVyLmZpbmRQcm9wUmVmcyhjdXIuYXN0LCBjdXIuc2NvcGUsIG9ialR5cGUsIHByb3AubmFtZSwgc3RvcmVSZWYoY3VyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtyZWZzOiByZWZzLCBuYW1lOiBwcm9wLm5hbWV9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFJlZnMoc3J2LCBxdWVyeSwgZmlsZSkge1xuICAgIHZhciBleHByID0gZmluZEV4cHJPclRocm93KGZpbGUsIHF1ZXJ5LCB0cnVlKTtcbiAgICBpZiAoZXhwciAmJiBleHByLm5vZGUudHlwZSA9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgcmV0dXJuIGZpbmRSZWZzVG9WYXJpYWJsZShzcnYsIHF1ZXJ5LCBmaWxlLCBleHByKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIgJiYgZXhwci5ub2RlLnR5cGUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIWV4cHIubm9kZS5jb21wdXRlZCkge1xuICAgICAgdmFyIHAgPSBleHByLm5vZGUucHJvcGVydHk7XG4gICAgICBleHByLm5vZGUgPSBleHByLm5vZGUub2JqZWN0O1xuICAgICAgcmV0dXJuIGZpbmRSZWZzVG9Qcm9wZXJ0eShzcnYsIHF1ZXJ5LCBmaWxlLCBleHByLCBwKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIgJiYgZXhwci5ub2RlLnR5cGUgPT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIHZhciBwb3MgPSByZXNvbHZlUG9zKGZpbGUsIHF1ZXJ5LmVuZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIubm9kZS5wcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrID0gZXhwci5ub2RlLnByb3BlcnRpZXNbaV0ua2V5O1xuICAgICAgICBpZiAoay5zdGFydCA8PSBwb3MgJiYgay5lbmQgPj0gcG9zKVxuICAgICAgICAgIHJldHVybiBmaW5kUmVmc1RvUHJvcGVydHkoc3J2LCBxdWVyeSwgZmlsZSwgZXhwciwgayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHByICYmIGV4cHIubm9kZS50eXBlID09IFwiTWV0aG9kRGVmaW5pdGlvblwiKSB7XG4gICAgICB2YXIgcCA9IGV4cHIubm9kZS5rZXk7XG4gICAgICByZXR1cm4gZmluZFJlZnNUb1Byb3BlcnR5KHNydiwgcXVlcnksIGZpbGUsIGV4cHIsIHApO1xuICAgIH1cbiAgICB0aHJvdyB0ZXJuRXJyb3IoXCJOb3QgYXQgYSB2YXJpYWJsZSBvciBwcm9wZXJ0eSBuYW1lLlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkUmVuYW1lKHNydiwgcXVlcnksIGZpbGUpIHtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5Lm5ld05hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgdGVybkVycm9yKFwiLnF1ZXJ5Lm5ld05hbWUgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO1xuICAgIHZhciBleHByID0gZmluZEV4cHJPclRocm93KGZpbGUsIHF1ZXJ5KTtcbiAgICBpZiAoIWV4cHIgfHwgZXhwci5ub2RlLnR5cGUgIT0gXCJJZGVudGlmaWVyXCIpIHRocm93IHRlcm5FcnJvcihcIk5vdCBhdCBhIHZhcmlhYmxlLlwiKTtcblxuICAgIHZhciBkYXRhID0gZmluZFJlZnNUb1ZhcmlhYmxlKHNydiwgcXVlcnksIGZpbGUsIGV4cHIsIHF1ZXJ5Lm5ld05hbWUpLCByZWZzID0gZGF0YS5yZWZzO1xuICAgIGRlbGV0ZSBkYXRhLnJlZnM7XG4gICAgZGF0YS5maWxlcyA9IHNydi5maWxlcy5tYXAoZnVuY3Rpb24oZil7cmV0dXJuIGYubmFtZTt9KTtcblxuICAgIHZhciBjaGFuZ2VzID0gZGF0YS5jaGFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdXNlID0gcmVmc1tpXTtcbiAgICAgIGlmICh1c2UuaXNTaG9ydGhhbmQpIHVzZS50ZXh0ID0gZXhwci5ub2RlLm5hbWUgKyBcIjogXCIgKyBxdWVyeS5uZXdOYW1lO1xuICAgICAgZWxzZSB1c2UudGV4dCA9IHF1ZXJ5Lm5ld05hbWU7XG4gICAgICBjaGFuZ2VzLnB1c2godXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RGaWxlcyhzcnYpIHtcbiAgICByZXR1cm4ge2ZpbGVzOiBzcnYuZmlsZXMubWFwKGZ1bmN0aW9uKGYpe3JldHVybiBmLm5hbWU7fSl9O1xuICB9XG5cbiAgZXhwb3J0cy52ZXJzaW9uID0gXCIwLjI0LjNcIjtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tern/lib/tern.js\n");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.js":
/*!************************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.mjs\")) :\n  undefined;\n}(this, function (exports, acorn) { 'use strict';\n\n  function noop() {}\n\n  var LooseParser = function LooseParser(input, options) {\n    if ( options === void 0 ) options = {};\n\n    this.toks = this.constructor.BaseParser.tokenizer(input, options);\n    this.options = this.toks.options;\n    this.input = this.toks.input;\n    this.tok = this.last = {type: acorn.tokTypes.eof, start: 0, end: 0};\n    this.tok.validateRegExpFlags = noop;\n    this.tok.validateRegExpPattern = noop;\n    if (this.options.locations) {\n      var here = this.toks.curPosition();\n      this.tok.loc = new acorn.SourceLocation(this.toks, here, here);\n    }\n    this.ahead = []; // Tokens ahead\n    this.context = []; // Indentation contexted\n    this.curIndent = 0;\n    this.curLineStart = 0;\n    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    this.inAsync = false;\n    this.inFunction = false;\n  };\n\n  LooseParser.prototype.startNode = function startNode () {\n    return new acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n  };\n\n  LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n  };\n\n  LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n    if (this.options.locations) {\n      return new acorn.Node(this.toks, pos[0], pos[1])\n    } else {\n      return new acorn.Node(this.toks, pos)\n    }\n  };\n\n  LooseParser.prototype.finishNode = function finishNode (node, type) {\n    node.type = type;\n    node.end = this.last.end;\n    if (this.options.locations)\n      { node.loc.end = this.last.loc.end; }\n    if (this.options.ranges)\n      { node.range[1] = this.last.end; }\n    return node\n  };\n\n  LooseParser.prototype.dummyNode = function dummyNode (type) {\n    var dummy = this.startNode();\n    dummy.type = type;\n    dummy.end = dummy.start;\n    if (this.options.locations)\n      { dummy.loc.end = dummy.loc.start; }\n    if (this.options.ranges)\n      { dummy.range[1] = dummy.start; }\n    this.last = {type: acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n    return dummy\n  };\n\n  LooseParser.prototype.dummyIdent = function dummyIdent () {\n    var dummy = this.dummyNode(\"Identifier\");\n    dummy.name = \"\";\n    return dummy\n  };\n\n  LooseParser.prototype.dummyString = function dummyString () {\n    var dummy = this.dummyNode(\"Literal\");\n    dummy.value = dummy.raw = \"\";\n    return dummy\n  };\n\n  LooseParser.prototype.eat = function eat (type) {\n    if (this.tok.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  LooseParser.prototype.isContextual = function isContextual (name) {\n    return this.tok.type === acorn.tokTypes.name && this.tok.value === name\n  };\n\n  LooseParser.prototype.eatContextual = function eatContextual (name) {\n    return this.tok.value === name && this.eat(acorn.tokTypes.name)\n  };\n\n  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n    return this.tok.type === acorn.tokTypes.eof || this.tok.type === acorn.tokTypes.braceR ||\n      acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n  };\n\n  LooseParser.prototype.semicolon = function semicolon () {\n    return this.eat(acorn.tokTypes.semi)\n  };\n\n  LooseParser.prototype.expect = function expect (type) {\n    if (this.eat(type)) { return true }\n    for (var i = 1; i <= 2; i++) {\n      if (this.lookAhead(i).type === type) {\n        for (var j = 0; j < i; j++) { this.next(); }\n        return true\n      }\n    }\n  };\n\n  LooseParser.prototype.pushCx = function pushCx () {\n    this.context.push(this.curIndent);\n  };\n\n  LooseParser.prototype.popCx = function popCx () {\n    this.curIndent = this.context.pop();\n  };\n\n  LooseParser.prototype.lineEnd = function lineEnd (pos) {\n    while (pos < this.input.length && !acorn.isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n    return pos\n  };\n\n  LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n    for (var count = 0;; ++pos) {\n      var ch = this.input.charCodeAt(pos);\n      if (ch === 32) { ++count; }\n      else if (ch === 9) { count += this.options.tabSize; }\n      else { return count }\n    }\n  };\n\n  LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n    if (this.tok.type === closeTok || this.tok.type === acorn.tokTypes.eof) { return true }\n    return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n      (!blockHeuristic || this.nextLineStart >= this.input.length ||\n       this.indentationAfter(this.nextLineStart) < indent)\n  };\n\n  LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n      var ch = this.input.charCodeAt(p);\n      if (ch !== 9 && ch !== 32) { return false }\n    }\n    return true\n  };\n\n  LooseParser.prototype.extend = function extend (name, f) {\n    this[name] = f(this[name]);\n  };\n\n  LooseParser.prototype.parse = function parse () {\n    this.next();\n    return this.parseTopLevel()\n  };\n\n  LooseParser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  LooseParser.parse = function parse (input, options) {\n    return new this(input, options).parse()\n  };\n\n  // Allows plugins to extend the base parser / tokenizer used\n  LooseParser.BaseParser = acorn.Parser;\n\n  var lp = LooseParser.prototype;\n\n  function isSpace(ch) {\n    return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || acorn.isNewLine(ch)\n  }\n\n  lp.next = function() {\n    this.last = this.tok;\n    if (this.ahead.length)\n      { this.tok = this.ahead.shift(); }\n    else\n      { this.tok = this.readToken(); }\n\n    if (this.tok.start >= this.nextLineStart) {\n      while (this.tok.start >= this.nextLineStart) {\n        this.curLineStart = this.nextLineStart;\n        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n      }\n      this.curIndent = this.indentationAfter(this.curLineStart);\n    }\n  };\n\n  lp.readToken = function() {\n    for (;;) {\n      try {\n        this.toks.next();\n        if (this.toks.type === acorn.tokTypes.dot &&\n            this.input.substr(this.toks.end, 1) === \".\" &&\n            this.options.ecmaVersion >= 6) {\n          this.toks.end++;\n          this.toks.type = acorn.tokTypes.ellipsis;\n        }\n        return new acorn.Token(this.toks)\n      } catch (e) {\n        if (!(e instanceof SyntaxError)) { throw e }\n\n        // Try to skip some text, based on the error message, and then continue\n        var msg = e.message, pos = e.raisedAt, replace = true;\n        if (/unterminated/i.test(msg)) {\n          pos = this.lineEnd(e.pos + 1);\n          if (/string/.test(msg)) {\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.string, value: this.input.slice(e.pos + 1, pos)};\n          } else if (/regular expr/i.test(msg)) {\n            var re = this.input.slice(e.pos, pos);\n            try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.regexp, value: re};\n          } else if (/template/.test(msg)) {\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.template,\n              value: this.input.slice(e.pos, pos)\n            };\n          } else {\n            replace = false;\n          }\n        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n          while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n        } else if (/character escape|expected hexadecimal/i.test(msg)) {\n          while (pos < this.input.length) {\n            var ch = this.input.charCodeAt(pos++);\n            if (ch === 34 || ch === 39 || acorn.isNewLine(ch)) { break }\n          }\n        } else if (/unexpected character/i.test(msg)) {\n          pos++;\n          replace = false;\n        } else if (/regular expression/i.test(msg)) {\n          replace = true;\n        } else {\n          throw e\n        }\n        this.resetTo(pos);\n        if (replace === true) { replace = {start: pos, end: pos, type: acorn.tokTypes.name, value: \"\"}; }\n        if (replace) {\n          if (this.options.locations)\n            { replace.loc = new acorn.SourceLocation(\n              this.toks,\n              acorn.getLineInfo(this.input, replace.start),\n              acorn.getLineInfo(this.input, replace.end)); }\n          return replace\n        }\n      }\n    }\n  };\n\n  lp.resetTo = function(pos) {\n    this.toks.pos = pos;\n    var ch = this.input.charAt(pos - 1);\n    this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n      /[enwfd]/.test(ch) &&\n      /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n    if (this.options.locations) {\n      this.toks.curLine = 1;\n      this.toks.lineStart = acorn.lineBreakG.lastIndex = 0;\n      var match;\n      while ((match = acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n        ++this.toks.curLine;\n        this.toks.lineStart = match.index + match[0].length;\n      }\n    }\n  };\n\n  lp.lookAhead = function(n) {\n    while (n > this.ahead.length)\n      { this.ahead.push(this.readToken()); }\n    return this.ahead[n - 1]\n  };\n\n  function isDummy(node) { return node.name === \"\" }\n\n  var lp$1 = LooseParser.prototype;\n\n  lp$1.parseTopLevel = function() {\n    var node = this.startNodeAt(this.options.locations ? [0, acorn.getLineInfo(this.input, 0)] : 0);\n    node.body = [];\n    while (this.tok.type !== acorn.tokTypes.eof) { node.body.push(this.parseStatement()); }\n    this.toks.adaptDirectivePrologue(node.body);\n    this.last = this.tok;\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType;\n    }\n    return this.finishNode(node, \"Program\")\n  };\n\n  lp$1.parseStatement = function() {\n    var starttype = this.tok.type, node = this.startNode(), kind;\n\n    if (this.toks.isLet()) {\n      starttype = acorn.tokTypes._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n    case acorn.tokTypes._break: case acorn.tokTypes._continue:\n      this.next();\n      var isBreak = starttype === acorn.tokTypes._break;\n      if (this.semicolon() || this.canInsertSemicolon()) {\n        node.label = null;\n      } else {\n        node.label = this.tok.type === acorn.tokTypes.name ? this.parseIdent() : null;\n        this.semicolon();\n      }\n      return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n    case acorn.tokTypes._debugger:\n      this.next();\n      this.semicolon();\n      return this.finishNode(node, \"DebuggerStatement\")\n\n    case acorn.tokTypes._do:\n      this.next();\n      node.body = this.parseStatement();\n      node.test = this.eat(acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n      this.semicolon();\n      return this.finishNode(node, \"DoWhileStatement\")\n\n    case acorn.tokTypes._for:\n      this.next(); // `for` keyword\n      var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n\n      this.pushCx();\n      this.expect(acorn.tokTypes.parenL);\n      if (this.tok.type === acorn.tokTypes.semi) { return this.parseFor(node, null) }\n      var isLet = this.toks.isLet();\n      if (isLet || this.tok.type === acorn.tokTypes._var || this.tok.type === acorn.tokTypes._const) {\n        var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n        if (init$1.declarations.length === 1 && (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\"))) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n            node.await = isAwait;\n          }\n          return this.parseForIn(node, init$1)\n        }\n        return this.parseFor(node, init$1)\n      }\n      var init = this.parseExpression(true);\n      if (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\")) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n          node.await = isAwait;\n        }\n        return this.parseForIn(node, this.toAssignable(init))\n      }\n      return this.parseFor(node, init)\n\n    case acorn.tokTypes._function:\n      this.next();\n      return this.parseFunction(node, true)\n\n    case acorn.tokTypes._if:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.consequent = this.parseStatement();\n      node.alternate = this.eat(acorn.tokTypes._else) ? this.parseStatement() : null;\n      return this.finishNode(node, \"IfStatement\")\n\n    case acorn.tokTypes._return:\n      this.next();\n      if (this.eat(acorn.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n      else { node.argument = this.parseExpression(); this.semicolon(); }\n      return this.finishNode(node, \"ReturnStatement\")\n\n    case acorn.tokTypes._switch:\n      var blockIndent = this.curIndent, line = this.curLineStart;\n      this.next();\n      node.discriminant = this.parseParenExpression();\n      node.cases = [];\n      this.pushCx();\n      this.expect(acorn.tokTypes.braceL);\n\n      var cur;\n      while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {\n        if (this.tok.type === acorn.tokTypes._case || this.tok.type === acorn.tokTypes._default) {\n          var isCase = this.tok.type === acorn.tokTypes._case;\n          if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          this.next();\n          if (isCase) { cur.test = this.parseExpression(); }\n          else { cur.test = null; }\n          this.expect(acorn.tokTypes.colon);\n        } else {\n          if (!cur) {\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            cur.test = null;\n          }\n          cur.consequent.push(this.parseStatement());\n        }\n      }\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      this.popCx();\n      this.eat(acorn.tokTypes.braceR);\n      return this.finishNode(node, \"SwitchStatement\")\n\n    case acorn.tokTypes._throw:\n      this.next();\n      node.argument = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ThrowStatement\")\n\n    case acorn.tokTypes._try:\n      this.next();\n      node.block = this.parseBlock();\n      node.handler = null;\n      if (this.tok.type === acorn.tokTypes._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(acorn.tokTypes.parenL)) {\n          clause.param = this.toAssignable(this.parseExprAtom(), true);\n          this.expect(acorn.tokTypes.parenR);\n        } else {\n          clause.param = null;\n        }\n        clause.body = this.parseBlock();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n      }\n      node.finalizer = this.eat(acorn.tokTypes._finally) ? this.parseBlock() : null;\n      if (!node.handler && !node.finalizer) { return node.block }\n      return this.finishNode(node, \"TryStatement\")\n\n    case acorn.tokTypes._var:\n    case acorn.tokTypes._const:\n      return this.parseVar(node, false, kind || this.tok.value)\n\n    case acorn.tokTypes._while:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WhileStatement\")\n\n    case acorn.tokTypes._with:\n      this.next();\n      node.object = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WithStatement\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseBlock()\n\n    case acorn.tokTypes.semi:\n      this.next();\n      return this.finishNode(node, \"EmptyStatement\")\n\n    case acorn.tokTypes._class:\n      return this.parseClass(true)\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === acorn.tokTypes.parenL) {\n        node.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n\n      return this.parseImport()\n\n    case acorn.tokTypes._export:\n      return this.parseExport()\n\n    default:\n      if (this.toks.isAsyncFunction()) {\n        this.next();\n        this.next();\n        return this.parseFunction(node, true, true)\n      }\n      var expr = this.parseExpression();\n      if (isDummy(expr)) {\n        this.next();\n        if (this.tok.type === acorn.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n        return this.parseStatement()\n      } else if (starttype === acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(acorn.tokTypes.colon)) {\n        node.body = this.parseStatement();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\")\n      } else {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n    }\n  };\n\n  lp$1.parseBlock = function() {\n    var node = this.startNode();\n    this.pushCx();\n    this.expect(acorn.tokTypes.braceL);\n    var blockIndent = this.curIndent, line = this.curLineStart;\n    node.body = [];\n    while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true))\n      { node.body.push(this.parseStatement()); }\n    this.popCx();\n    this.eat(acorn.tokTypes.braceR);\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  lp$1.parseFor = function(node, init) {\n    node.init = init;\n    node.test = node.update = null;\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.semi) { node.test = this.parseExpression(); }\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.parenR) { node.update = this.parseExpression(); }\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  lp$1.parseForIn = function(node, init) {\n    var type = this.tok.type === acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, type)\n  };\n\n  lp$1.parseVar = function(node, noIn, kind) {\n    node.kind = kind;\n    this.next();\n    node.declarations = [];\n    do {\n      var decl = this.startNode();\n      decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n      decl.init = this.eat(acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    } while (this.eat(acorn.tokTypes.comma))\n    if (!node.declarations.length) {\n      var decl$1 = this.startNode();\n      decl$1.id = this.dummyIdent();\n      node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n    }\n    if (!noIn) { this.semicolon(); }\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  lp$1.parseClass = function(isStatement) {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    else { node.id = null; }\n    node.superClass = this.eat(acorn.tokTypes._extends) ? this.parseExpression() : null;\n    node.body = this.startNode();\n    node.body.body = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      if (this.semicolon()) { continue }\n      var method = this.startNode(), isGenerator = (void 0), isAsync = (void 0);\n      if (this.options.ecmaVersion >= 6) {\n        method.static = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(method);\n      if (isDummy(method.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n          (this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL)) {\n        method.static = true;\n        isGenerator = this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        method.static = false;\n      }\n      if (!method.computed &&\n          method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== acorn.tokTypes.parenL &&\n          !this.canInsertSemicolon()) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        isAsync = false;\n      }\n      if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n          !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n          this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL) {\n        method.kind = method.key.name;\n        this.parsePropertyName(method);\n        method.value = this.parseMethod(false);\n      } else {\n        if (!method.computed && !method.static && !isGenerator && !isAsync && (\n          method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n            method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n        method.value = this.parseMethod(isGenerator, isAsync);\n      }\n      node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    this.semicolon();\n    this.finishNode(node.body, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  lp$1.parseFunction = function(node, isStatement, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = this.eat(acorn.tokTypes.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  lp$1.parseExport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.eat(acorn.tokTypes.star)) {\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(acorn.tokTypes._default)) {\n      // export default (function foo() {}) // This is FunctionExpression.\n      var isAsync;\n      if (this.tok.type === acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n      } else if (this.tok.type === acorn.tokTypes._class) {\n        node.declaration = this.parseClass(\"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n      node.declaration = this.parseStatement();\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifierList();\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  lp$1.parseImport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.string) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      var elt;\n      if (this.tok.type === acorn.tokTypes.name && this.tok.value !== \"from\") {\n        elt = this.startNode();\n        elt.local = this.parseIdent();\n        this.finishNode(elt, \"ImportDefaultSpecifier\");\n        this.eat(acorn.tokTypes.comma);\n      }\n      node.specifiers = this.parseImportSpecifiers();\n      node.source = this.eatContextual(\"from\") && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n      if (elt) { node.specifiers.unshift(elt); }\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  lp$1.parseImportSpecifiers = function() {\n    var elts = [];\n    if (this.tok.type === acorn.tokTypes.star) {\n      var elt = this.startNode();\n      this.next();\n      elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n      elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n    } else {\n      var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n      this.pushCx();\n      this.eat(acorn.tokTypes.braceL);\n      if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n      while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n        var elt$1 = this.startNode();\n        if (this.eat(acorn.tokTypes.star)) {\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n          this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n        } else {\n          if (this.isContextual(\"from\")) { break }\n          elt$1.imported = this.parseIdent();\n          if (isDummy(elt$1.imported)) { break }\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n          this.finishNode(elt$1, \"ImportSpecifier\");\n        }\n        elts.push(elt$1);\n        this.eat(acorn.tokTypes.comma);\n      }\n      this.eat(acorn.tokTypes.braceR);\n      this.popCx();\n    }\n    return elts\n  };\n\n  lp$1.parseExportSpecifierList = function() {\n    var elts = [];\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      if (this.isContextual(\"from\")) { break }\n      var elt = this.startNode();\n      elt.local = this.parseIdent();\n      if (isDummy(elt.local)) { break }\n      elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n      this.finishNode(elt, \"ExportSpecifier\");\n      elts.push(elt);\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.eat(acorn.tokTypes.braceR);\n    this.popCx();\n    return elts\n  };\n\n  var lp$2 = LooseParser.prototype;\n\n  lp$2.checkLVal = function(expr) {\n    if (!expr) { return expr }\n    switch (expr.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n      return expr\n\n    case \"ParenthesizedExpression\":\n      expr.expression = this.checkLVal(expr.expression);\n      return expr\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseExpression = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseMaybeAssign(noIn);\n    if (this.tok.type === acorn.tokTypes.comma) {\n      var node = this.startNodeAt(start);\n      node.expressions = [expr];\n      while (this.eat(acorn.tokTypes.comma)) { node.expressions.push(this.parseMaybeAssign(noIn)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseParenExpression = function() {\n    this.pushCx();\n    this.expect(acorn.tokTypes.parenL);\n    var val = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    return val\n  };\n\n  lp$2.parseMaybeAssign = function(noIn) {\n    if (this.toks.isContextual(\"yield\")) {\n      var node = this.startNode();\n      this.next();\n      if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n        node.delegate = false;\n        node.argument = null;\n      } else {\n        node.delegate = this.eat(acorn.tokTypes.star);\n        node.argument = this.parseMaybeAssign();\n      }\n      return this.finishNode(node, \"YieldExpression\")\n    }\n\n    var start = this.storeCurrentPos();\n    var left = this.parseMaybeConditional(noIn);\n    if (this.tok.type.isAssign) {\n      var node$1 = this.startNodeAt(start);\n      node$1.operator = this.tok.value;\n      node$1.left = this.tok.type === acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n      this.next();\n      node$1.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node$1, \"AssignmentExpression\")\n    }\n    return left\n  };\n\n  lp$2.parseMaybeConditional = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseExprOps(noIn);\n    if (this.eat(acorn.tokTypes.question)) {\n      var node = this.startNodeAt(start);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      node.alternate = this.expect(acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseExprOps = function(noIn) {\n    var start = this.storeCurrentPos();\n    var indent = this.curIndent, line = this.curLineStart;\n    return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n  };\n\n  lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n    if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n    var prec = this.tok.type.binop;\n    if (prec != null && (!noIn || this.tok.type !== acorn.tokTypes._in)) {\n      if (prec > minPrec) {\n        var node = this.startNodeAt(start);\n        node.left = left;\n        node.operator = this.tok.value;\n        this.next();\n        if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n          node.right = this.dummyIdent();\n        } else {\n          var rightStart = this.storeCurrentPos();\n          node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n        }\n        this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n      }\n    }\n    return left\n  };\n\n  lp$2.parseMaybeUnary = function(sawUnary) {\n    var start = this.storeCurrentPos(), expr;\n    if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n      (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n    ) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.tok.type.prefix) {\n      var node = this.startNode(), update = this.tok.type === acorn.tokTypes.incDec;\n      if (!update) { sawUnary = true; }\n      node.operator = this.tok.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(true);\n      if (update) { node.argument = this.checkLVal(node.argument); }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (this.tok.type === acorn.tokTypes.ellipsis) {\n      var node$1 = this.startNode();\n      this.next();\n      node$1.argument = this.parseMaybeUnary(sawUnary);\n      expr = this.finishNode(node$1, \"SpreadElement\");\n    } else {\n      expr = this.parseExprSubscripts();\n      while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n        var node$2 = this.startNodeAt(start);\n        node$2.operator = this.tok.value;\n        node$2.prefix = false;\n        node$2.argument = this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$2, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(acorn.tokTypes.starstar)) {\n      var node$3 = this.startNodeAt(start);\n      node$3.operator = \"**\";\n      node$3.left = expr;\n      node$3.right = this.parseMaybeUnary(false);\n      return this.finishNode(node$3, \"BinaryExpression\")\n    }\n\n    return expr\n  };\n\n  lp$2.parseExprSubscripts = function() {\n    var start = this.storeCurrentPos();\n    return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n  };\n\n  lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n    for (;;) {\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        if (this.tok.type === acorn.tokTypes.dot && this.curIndent === startIndent)\n          { --startIndent; }\n        else\n          { return base }\n      }\n\n      var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n      if (this.eat(acorn.tokTypes.dot)) {\n        var node = this.startNodeAt(start);\n        node.object = base;\n        if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine())\n          { node.property = this.dummyIdent(); }\n        else\n          { node.property = this.parsePropertyAccessor() || this.dummyIdent(); }\n        node.computed = false;\n        base = this.finishNode(node, \"MemberExpression\");\n      } else if (this.tok.type === acorn.tokTypes.bracketL) {\n        this.pushCx();\n        this.next();\n        var node$1 = this.startNodeAt(start);\n        node$1.object = base;\n        node$1.property = this.parseExpression();\n        node$1.computed = true;\n        this.popCx();\n        this.expect(acorn.tokTypes.bracketR);\n        base = this.finishNode(node$1, \"MemberExpression\");\n      } else if (!noCalls && this.tok.type === acorn.tokTypes.parenL) {\n        var exprList = this.parseExprList(acorn.tokTypes.parenR);\n        if (maybeAsyncArrow && this.eat(acorn.tokTypes.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(start), exprList, true) }\n        var node$2 = this.startNodeAt(start);\n        node$2.callee = base;\n        node$2.arguments = exprList;\n        base = this.finishNode(node$2, \"CallExpression\");\n      } else if (this.tok.type === acorn.tokTypes.backQuote) {\n        var node$3 = this.startNodeAt(start);\n        node$3.tag = base;\n        node$3.quasi = this.parseTemplate();\n        base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n      } else {\n        return base\n      }\n    }\n  };\n\n  lp$2.parseExprAtom = function() {\n    var node;\n    switch (this.tok.type) {\n    case acorn.tokTypes._this:\n    case acorn.tokTypes._super:\n      var type = this.tok.type === acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type)\n\n    case acorn.tokTypes.name:\n      var start = this.storeCurrentPos();\n      var id = this.parseIdent();\n      var isAsync = false;\n      if (id.name === \"async\" && !this.canInsertSemicolon()) {\n        if (this.eat(acorn.tokTypes._function))\n          { return this.parseFunction(this.startNodeAt(start), false, true) }\n        if (this.tok.type === acorn.tokTypes.name) {\n          id = this.parseIdent();\n          isAsync = true;\n        }\n      }\n      return this.eat(acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n    case acorn.tokTypes.regexp:\n      node = this.startNode();\n      var val = this.tok.value;\n      node.regex = {pattern: val.pattern, flags: val.flags};\n      node.value = val.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.num: case acorn.tokTypes.string:\n      node = this.startNode();\n      node.value = this.tok.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      if (this.tok.type === acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes._null: case acorn.tokTypes._true: case acorn.tokTypes._false:\n      node = this.startNode();\n      node.value = this.tok.type === acorn.tokTypes._null ? null : this.tok.type === acorn.tokTypes._true;\n      node.raw = this.tok.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.parenL:\n      var parenStart = this.storeCurrentPos();\n      this.next();\n      var inner = this.parseExpression();\n      this.expect(acorn.tokTypes.parenR);\n      if (this.eat(acorn.tokTypes.arrow)) {\n        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n        var params = inner.expressions || [inner];\n        if (params.length && isDummy(params[params.length - 1]))\n          { params.pop(); }\n        return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n      }\n      if (this.options.preserveParens) {\n        var par = this.startNodeAt(parenStart);\n        par.expression = inner;\n        inner = this.finishNode(par, \"ParenthesizedExpression\");\n      }\n      return inner\n\n    case acorn.tokTypes.bracketL:\n      node = this.startNode();\n      node.elements = this.parseExprList(acorn.tokTypes.bracketR, true);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseObj()\n\n    case acorn.tokTypes._class:\n      return this.parseClass(false)\n\n    case acorn.tokTypes._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false)\n\n    case acorn.tokTypes._new:\n      return this.parseNew()\n\n    case acorn.tokTypes.backQuote:\n      return this.parseTemplate()\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport()\n      } else {\n        return this.dummyIdent()\n      }\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseDynamicImport = function() {\n    var node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"Import\")\n  };\n\n  lp$2.parseNew = function() {\n    var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(acorn.tokTypes.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var start = this.storeCurrentPos();\n    node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n    if (this.tok.type === acorn.tokTypes.parenL) {\n      node.arguments = this.parseExprList(acorn.tokTypes.parenR);\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  lp$2.parseTemplateElement = function() {\n    var elem = this.startNode();\n\n    // The loose parser accepts invalid unicode escapes even in untagged templates.\n    if (this.tok.type === acorn.tokTypes.invalidTemplate) {\n      elem.value = {\n        raw: this.tok.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.tok.value\n      };\n    }\n    this.next();\n    elem.tail = this.tok.type === acorn.tokTypes.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  lp$2.parseTemplate = function() {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      this.next();\n      node.expressions.push(this.parseExpression());\n      if (this.expect(acorn.tokTypes.braceR)) {\n        curElt = this.parseTemplateElement();\n      } else {\n        curElt = this.startNode();\n        curElt.value = {cooked: \"\", raw: \"\"};\n        curElt.tail = true;\n        this.finishNode(curElt, \"TemplateElement\");\n      }\n      node.quasis.push(curElt);\n    }\n    this.expect(acorn.tokTypes.backQuote);\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  lp$2.parseObj = function() {\n    var node = this.startNode();\n    node.properties = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      var prop = this.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n      if (this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.ellipsis)) {\n        prop.argument = this.parseMaybeAssign();\n        node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n        this.eat(acorn.tokTypes.comma);\n        continue\n      }\n      if (this.options.ecmaVersion >= 6) {\n        start = this.storeCurrentPos();\n        prop.method = false;\n        prop.shorthand = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(prop);\n      if (this.toks.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(prop);\n      } else {\n        isAsync = false;\n      }\n      if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (this.eat(acorn.tokTypes.colon)) {\n        prop.kind = \"init\";\n        prop.value = this.parseMaybeAssign();\n      } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn.tokTypes.parenL || this.tok.type === acorn.tokTypes.braceL)) {\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n      } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n                 (this.tok.type !== acorn.tokTypes.comma && this.tok.type !== acorn.tokTypes.braceR && this.tok.type !== acorn.tokTypes.eq)) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n      } else {\n        prop.kind = \"init\";\n        if (this.options.ecmaVersion >= 6) {\n          if (this.eat(acorn.tokTypes.eq)) {\n            var assign = this.startNodeAt(start);\n            assign.operator = \"=\";\n            assign.left = prop.key;\n            assign.right = this.parseMaybeAssign();\n            prop.value = this.finishNode(assign, \"AssignmentExpression\");\n          } else {\n            prop.value = prop.key;\n          }\n        } else {\n          prop.value = this.dummyIdent();\n        }\n        prop.shorthand = true;\n      }\n      node.properties.push(this.finishNode(prop, \"Property\"));\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return this.finishNode(node, \"ObjectExpression\")\n  };\n\n  lp$2.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(acorn.tokTypes.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseExpression();\n        this.expect(acorn.tokTypes.bracketR);\n        return\n      } else {\n        prop.computed = false;\n      }\n    }\n    var key = (this.tok.type === acorn.tokTypes.num || this.tok.type === acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n    prop.key = key || this.dummyIdent();\n  };\n\n  lp$2.parsePropertyAccessor = function() {\n    if (this.tok.type === acorn.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n  };\n\n  lp$2.parseIdent = function() {\n    var name = this.tok.type === acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n    if (!name) { return this.dummyIdent() }\n    var node = this.startNode();\n    this.next();\n    node.name = name;\n    return this.finishNode(node, \"Identifier\")\n  };\n\n  lp$2.initFunction = function(node) {\n    node.id = null;\n    node.params = [];\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = false; }\n  };\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  lp$2.toAssignable = function(node, binding) {\n    if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) ; else if (node.type === \"ParenthesizedExpression\") {\n      this.toAssignable(node.expression, binding);\n    } else if (this.options.ecmaVersion < 6) {\n      return this.dummyIdent()\n    } else if (node.type === \"ObjectExpression\") {\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1)\n        {\n        var prop = list[i];\n\n        this.toAssignable(prop, binding);\n      }\n    } else if (node.type === \"ArrayExpression\") {\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, binding);\n    } else if (node.type === \"Property\") {\n      this.toAssignable(node.value, binding);\n    } else if (node.type === \"SpreadElement\") {\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, binding);\n    } else if (node.type === \"AssignmentExpression\") {\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n    } else {\n      return this.dummyIdent()\n    }\n    return node\n  };\n\n  lp$2.toAssignableList = function(exprList, binding) {\n    for (var i = 0, list = exprList; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      this.toAssignable(expr, binding);\n    }\n    return exprList\n  };\n\n  lp$2.parseFunctionParams = function(params) {\n    params = this.parseExprList(acorn.tokTypes.parenR);\n    return this.toAssignableList(params, true)\n  };\n\n  lp$2.parseMethod = function(isGenerator, isAsync) {\n    var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = !!isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  lp$2.parseArrowExpression = function(node, params, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    node.expression = this.tok.type !== acorn.tokTypes.braceL;\n    if (node.expression) {\n      node.body = this.parseMaybeAssign();\n    } else {\n      node.body = this.parseBlock();\n      this.toks.adaptDirectivePrologue(node.body.body);\n    }\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  lp$2.parseExprList = function(close, allowEmpty) {\n    this.pushCx();\n    var indent = this.curIndent, line = this.curLineStart, elts = [];\n    this.next(); // Opening bracket\n    while (!this.closes(close, indent + 1, line)) {\n      if (this.eat(acorn.tokTypes.comma)) {\n        elts.push(allowEmpty ? null : this.dummyIdent());\n        continue\n      }\n      var elt = this.parseMaybeAssign();\n      if (isDummy(elt)) {\n        if (this.closes(close, indent, line)) { break }\n        this.next();\n      } else {\n        elts.push(elt);\n      }\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(close)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return elts\n  };\n\n  lp$2.parseAwait = function() {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  // Acorn: Loose parser\n\n  acorn.defaultOptions.tabSize = 4;\n\n  function parse(input, options) {\n    return LooseParser.parse(input, options)\n  }\n\n  exports.LooseParser = LooseParser;\n  exports.parse = parse;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4tbG9vc2UvZGlzdC9hY29ybi1sb29zZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJuL25vZGVfbW9kdWxlcy9hY29ybi1sb29zZS9kaXN0L2Fjb3JuLWxvb3NlLmpzPzNlZmEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdhY29ybicpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnYWNvcm4nXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoKGdsb2JhbC5hY29ybiA9IGdsb2JhbC5hY29ybiB8fCB7fSwgZ2xvYmFsLmFjb3JuLmxvb3NlID0ge30pLCBnbG9iYWwuYWNvcm4pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGFjb3JuKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICB2YXIgTG9vc2VQYXJzZXIgPSBmdW5jdGlvbiBMb29zZVBhcnNlcihpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgdGhpcy50b2tzID0gdGhpcy5jb25zdHJ1Y3Rvci5CYXNlUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy50b2tzLm9wdGlvbnM7XG4gICAgdGhpcy5pbnB1dCA9IHRoaXMudG9rcy5pbnB1dDtcbiAgICB0aGlzLnRvayA9IHRoaXMubGFzdCA9IHt0eXBlOiBhY29ybi50b2tUeXBlcy5lb2YsIHN0YXJ0OiAwLCBlbmQ6IDB9O1xuICAgIHRoaXMudG9rLnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBub29wO1xuICAgIHRoaXMudG9rLnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IG5vb3A7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHZhciBoZXJlID0gdGhpcy50b2tzLmN1clBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnRvay5sb2MgPSBuZXcgYWNvcm4uU291cmNlTG9jYXRpb24odGhpcy50b2tzLCBoZXJlLCBoZXJlKTtcbiAgICB9XG4gICAgdGhpcy5haGVhZCA9IFtdOyAvLyBUb2tlbnMgYWhlYWRcbiAgICB0aGlzLmNvbnRleHQgPSBbXTsgLy8gSW5kZW50YXRpb24gY29udGV4dGVkXG4gICAgdGhpcy5jdXJJbmRlbnQgPSAwO1xuICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLm5leHRMaW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQodGhpcy5jdXJMaW5lU3RhcnQpICsgMTtcbiAgICB0aGlzLmluQXN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLmluRnVuY3Rpb24gPSBmYWxzZTtcbiAgfTtcblxuICBMb29zZVBhcnNlci5wcm90b3R5cGUuc3RhcnROb2RlID0gZnVuY3Rpb24gc3RhcnROb2RlICgpIHtcbiAgICByZXR1cm4gbmV3IGFjb3JuLk5vZGUodGhpcy50b2tzLCB0aGlzLnRvay5zdGFydCwgdGhpcy5vcHRpb25zLmxvY2F0aW9ucyA/IHRoaXMudG9rLmxvYy5zdGFydCA6IG51bGwpXG4gIH07XG5cbiAgTG9vc2VQYXJzZXIucHJvdG90eXBlLnN0b3JlQ3VycmVudFBvcyA9IGZ1bmN0aW9uIHN0b3JlQ3VycmVudFBvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sb2NhdGlvbnMgPyBbdGhpcy50b2suc3RhcnQsIHRoaXMudG9rLmxvYy5zdGFydF0gOiB0aGlzLnRvay5zdGFydFxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uIHN0YXJ0Tm9kZUF0IChwb3MpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBhY29ybi5Ob2RlKHRoaXMudG9rcywgcG9zWzBdLCBwb3NbMV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgYWNvcm4uTm9kZSh0aGlzLnRva3MsIHBvcylcbiAgICB9XG4gIH07XG5cbiAgTG9vc2VQYXJzZXIucHJvdG90eXBlLmZpbmlzaE5vZGUgPSBmdW5jdGlvbiBmaW5pc2hOb2RlIChub2RlLCB0eXBlKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IHRoaXMubGFzdC5lbmQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IG5vZGUubG9jLmVuZCA9IHRoaXMubGFzdC5sb2MuZW5kOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IG5vZGUucmFuZ2VbMV0gPSB0aGlzLmxhc3QuZW5kOyB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBMb29zZVBhcnNlci5wcm90b3R5cGUuZHVtbXlOb2RlID0gZnVuY3Rpb24gZHVtbXlOb2RlICh0eXBlKSB7XG4gICAgdmFyIGR1bW15ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBkdW1teS50eXBlID0gdHlwZTtcbiAgICBkdW1teS5lbmQgPSBkdW1teS5zdGFydDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgZHVtbXkubG9jLmVuZCA9IGR1bW15LmxvYy5zdGFydDsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBkdW1teS5yYW5nZVsxXSA9IGR1bW15LnN0YXJ0OyB9XG4gICAgdGhpcy5sYXN0ID0ge3R5cGU6IGFjb3JuLnRva1R5cGVzLm5hbWUsIHN0YXJ0OiBkdW1teS5zdGFydCwgZW5kOiBkdW1teS5zdGFydCwgbG9jOiBkdW1teS5sb2N9O1xuICAgIHJldHVybiBkdW1teVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5kdW1teUlkZW50ID0gZnVuY3Rpb24gZHVtbXlJZGVudCAoKSB7XG4gICAgdmFyIGR1bW15ID0gdGhpcy5kdW1teU5vZGUoXCJJZGVudGlmaWVyXCIpO1xuICAgIGR1bW15Lm5hbWUgPSBcIuKcllwiO1xuICAgIHJldHVybiBkdW1teVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5kdW1teVN0cmluZyA9IGZ1bmN0aW9uIGR1bW15U3RyaW5nICgpIHtcbiAgICB2YXIgZHVtbXkgPSB0aGlzLmR1bW15Tm9kZShcIkxpdGVyYWxcIik7XG4gICAgZHVtbXkudmFsdWUgPSBkdW1teS5yYXcgPSBcIuKcllwiO1xuICAgIHJldHVybiBkdW1teVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKHR5cGUpIHtcbiAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gdHlwZSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgTG9vc2VQYXJzZXIucHJvdG90eXBlLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uIGlzQ29udGV4dHVhbCAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5uYW1lICYmIHRoaXMudG9rLnZhbHVlID09PSBuYW1lXG4gIH07XG5cbiAgTG9vc2VQYXJzZXIucHJvdG90eXBlLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbiBlYXRDb250ZXh0dWFsIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rLnZhbHVlID09PSBuYW1lICYmIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLm5hbWUpXG4gIH07XG5cbiAgTG9vc2VQYXJzZXIucHJvdG90eXBlLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uIGNhbkluc2VydFNlbWljb2xvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLmVvZiB8fCB0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5icmFjZVIgfHxcbiAgICAgIGFjb3JuLmxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0LmVuZCwgdGhpcy50b2suc3RhcnQpKVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiBzZW1pY29sb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5zZW1pKVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbiBleHBlY3QgKHR5cGUpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDI7IGkrKykge1xuICAgICAgaWYgKHRoaXMubG9va0FoZWFkKGkpLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyBqKyspIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTG9vc2VQYXJzZXIucHJvdG90eXBlLnB1c2hDeCA9IGZ1bmN0aW9uIHB1c2hDeCAoKSB7XG4gICAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5jdXJJbmRlbnQpO1xuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5wb3BDeCA9IGZ1bmN0aW9uIHBvcEN4ICgpIHtcbiAgICB0aGlzLmN1ckluZGVudCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgfTtcblxuICBMb29zZVBhcnNlci5wcm90b3R5cGUubGluZUVuZCA9IGZ1bmN0aW9uIGxpbmVFbmQgKHBvcykge1xuICAgIHdoaWxlIChwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhYWNvcm4uaXNOZXdMaW5lKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpKSkgeyArK3BvczsgfVxuICAgIHJldHVybiBwb3NcbiAgfTtcblxuICBMb29zZVBhcnNlci5wcm90b3R5cGUuaW5kZW50YXRpb25BZnRlciA9IGZ1bmN0aW9uIGluZGVudGF0aW9uQWZ0ZXIgKHBvcykge1xuICAgIGZvciAodmFyIGNvdW50ID0gMDs7ICsrcG9zKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gMzIpIHsgKytjb3VudDsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IDkpIHsgY291bnQgKz0gdGhpcy5vcHRpb25zLnRhYlNpemU7IH1cbiAgICAgIGVsc2UgeyByZXR1cm4gY291bnQgfVxuICAgIH1cbiAgfTtcblxuICBMb29zZVBhcnNlci5wcm90b3R5cGUuY2xvc2VzID0gZnVuY3Rpb24gY2xvc2VzIChjbG9zZVRvaywgaW5kZW50LCBsaW5lLCBibG9ja0hldXJpc3RpYykge1xuICAgIGlmICh0aGlzLnRvay50eXBlID09PSBjbG9zZVRvayB8fCB0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5lb2YpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBsaW5lICE9PSB0aGlzLmN1ckxpbmVTdGFydCAmJiB0aGlzLmN1ckluZGVudCA8IGluZGVudCAmJiB0aGlzLnRva2VuU3RhcnRzTGluZSgpICYmXG4gICAgICAoIWJsb2NrSGV1cmlzdGljIHx8IHRoaXMubmV4dExpbmVTdGFydCA+PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICAgIHRoaXMuaW5kZW50YXRpb25BZnRlcih0aGlzLm5leHRMaW5lU3RhcnQpIDwgaW5kZW50KVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS50b2tlblN0YXJ0c0xpbmUgPSBmdW5jdGlvbiB0b2tlblN0YXJ0c0xpbmUgKCkge1xuICAgIGZvciAodmFyIHAgPSB0aGlzLnRvay5zdGFydCAtIDE7IHAgPj0gdGhpcy5jdXJMaW5lU3RhcnQ7IC0tcCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHApO1xuICAgICAgaWYgKGNoICE9PSA5ICYmIGNoICE9PSAzMikgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIExvb3NlUGFyc2VyLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKG5hbWUsIGYpIHtcbiAgICB0aGlzW25hbWVdID0gZih0aGlzW25hbWVdKTtcbiAgfTtcblxuICBMb29zZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbCgpXG4gIH07XG5cbiAgTG9vc2VQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIGNscyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICAgIHJldHVybiBjbHNcbiAgfTtcblxuICBMb29zZVBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhpbnB1dCwgb3B0aW9ucykucGFyc2UoKVxuICB9O1xuXG4gIC8vIEFsbG93cyBwbHVnaW5zIHRvIGV4dGVuZCB0aGUgYmFzZSBwYXJzZXIgLyB0b2tlbml6ZXIgdXNlZFxuICBMb29zZVBhcnNlci5CYXNlUGFyc2VyID0gYWNvcm4uUGFyc2VyO1xuXG4gIHZhciBscCA9IExvb3NlUGFyc2VyLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBpc1NwYWNlKGNoKSB7XG4gICAgcmV0dXJuIChjaCA8IDE0ICYmIGNoID4gOCkgfHwgY2ggPT09IDMyIHx8IGNoID09PSAxNjAgfHwgYWNvcm4uaXNOZXdMaW5lKGNoKVxuICB9XG5cbiAgbHAubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGFzdCA9IHRoaXMudG9rO1xuICAgIGlmICh0aGlzLmFoZWFkLmxlbmd0aClcbiAgICAgIHsgdGhpcy50b2sgPSB0aGlzLmFoZWFkLnNoaWZ0KCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMudG9rID0gdGhpcy5yZWFkVG9rZW4oKTsgfVxuXG4gICAgaWYgKHRoaXMudG9rLnN0YXJ0ID49IHRoaXMubmV4dExpbmVTdGFydCkge1xuICAgICAgd2hpbGUgKHRoaXMudG9rLnN0YXJ0ID49IHRoaXMubmV4dExpbmVTdGFydCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMubmV4dExpbmVTdGFydDtcbiAgICAgICAgdGhpcy5uZXh0TGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kKHRoaXMuY3VyTGluZVN0YXJ0KSArIDE7XG4gICAgICB9XG4gICAgICB0aGlzLmN1ckluZGVudCA9IHRoaXMuaW5kZW50YXRpb25BZnRlcih0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgfVxuICB9O1xuXG4gIGxwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudG9rcy5uZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLnRva3MudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuZG90ICYmXG4gICAgICAgICAgICB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnRva3MuZW5kLCAxKSA9PT0gXCIuXCIgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgICAgdGhpcy50b2tzLmVuZCsrO1xuICAgICAgICAgIHRoaXMudG9rcy50eXBlID0gYWNvcm4udG9rVHlwZXMuZWxsaXBzaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBhY29ybi5Ub2tlbih0aGlzLnRva3MpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikpIHsgdGhyb3cgZSB9XG5cbiAgICAgICAgLy8gVHJ5IHRvIHNraXAgc29tZSB0ZXh0LCBiYXNlZCBvbiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gY29udGludWVcbiAgICAgICAgdmFyIG1zZyA9IGUubWVzc2FnZSwgcG9zID0gZS5yYWlzZWRBdCwgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIGlmICgvdW50ZXJtaW5hdGVkL2kudGVzdChtc2cpKSB7XG4gICAgICAgICAgcG9zID0gdGhpcy5saW5lRW5kKGUucG9zICsgMSk7XG4gICAgICAgICAgaWYgKC9zdHJpbmcvLnRlc3QobXNnKSkge1xuICAgICAgICAgICAgcmVwbGFjZSA9IHtzdGFydDogZS5wb3MsIGVuZDogcG9zLCB0eXBlOiBhY29ybi50b2tUeXBlcy5zdHJpbmcsIHZhbHVlOiB0aGlzLmlucHV0LnNsaWNlKGUucG9zICsgMSwgcG9zKX07XG4gICAgICAgICAgfSBlbHNlIGlmICgvcmVndWxhciBleHByL2kudGVzdChtc2cpKSB7XG4gICAgICAgICAgICB2YXIgcmUgPSB0aGlzLmlucHV0LnNsaWNlKGUucG9zLCBwb3MpO1xuICAgICAgICAgICAgdHJ5IHsgcmUgPSBuZXcgUmVnRXhwKHJlKTsgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgY29tcGlsYXRpb24gZXJyb3IgZHVlIHRvIG5ldyBzeW50YXggKi8gfVxuICAgICAgICAgICAgcmVwbGFjZSA9IHtzdGFydDogZS5wb3MsIGVuZDogcG9zLCB0eXBlOiBhY29ybi50b2tUeXBlcy5yZWdleHAsIHZhbHVlOiByZX07XG4gICAgICAgICAgfSBlbHNlIGlmICgvdGVtcGxhdGUvLnRlc3QobXNnKSkge1xuICAgICAgICAgICAgcmVwbGFjZSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGUucG9zLFxuICAgICAgICAgICAgICBlbmQ6IHBvcyxcbiAgICAgICAgICAgICAgdHlwZTogYWNvcm4udG9rVHlwZXMudGVtcGxhdGUsXG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlucHV0LnNsaWNlKGUucG9zLCBwb3MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKC9pbnZhbGlkICh1bmljb2RlfHJlZ2V4cHxudW1iZXIpfGV4cGVjdGluZyB1bmljb2RlfG9jdGFsIGxpdGVyYWx8aXMgcmVzZXJ2ZWR8ZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyfGV4cGVjdGVkIG51bWJlciBpbiByYWRpeC9pLnRlc3QobXNnKSkge1xuICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNTcGFjZSh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSkpIHsgKytwb3M7IH1cbiAgICAgICAgfSBlbHNlIGlmICgvY2hhcmFjdGVyIGVzY2FwZXxleHBlY3RlZCBoZXhhZGVjaW1hbC9pLnRlc3QobXNnKSkge1xuICAgICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMzQgfHwgY2ggPT09IDM5IHx8IGFjb3JuLmlzTmV3TGluZShjaCkpIHsgYnJlYWsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgvdW5leHBlY3RlZCBjaGFyYWN0ZXIvaS50ZXN0KG1zZykpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICByZXBsYWNlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoL3JlZ3VsYXIgZXhwcmVzc2lvbi9pLnRlc3QobXNnKSkge1xuICAgICAgICAgIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0VG8ocG9zKTtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHRydWUpIHsgcmVwbGFjZSA9IHtzdGFydDogcG9zLCBlbmQ6IHBvcywgdHlwZTogYWNvcm4udG9rVHlwZXMubmFtZSwgdmFsdWU6IFwi4pyWXCJ9OyB9XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICAgICAgICB7IHJlcGxhY2UubG9jID0gbmV3IGFjb3JuLlNvdXJjZUxvY2F0aW9uKFxuICAgICAgICAgICAgICB0aGlzLnRva3MsXG4gICAgICAgICAgICAgIGFjb3JuLmdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHJlcGxhY2Uuc3RhcnQpLFxuICAgICAgICAgICAgICBhY29ybi5nZXRMaW5lSW5mbyh0aGlzLmlucHV0LCByZXBsYWNlLmVuZCkpOyB9XG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBscC5yZXNldFRvID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy50b2tzLnBvcyA9IHBvcztcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdChwb3MgLSAxKTtcbiAgICB0aGlzLnRva3MuZXhwckFsbG93ZWQgPSAhY2ggfHwgL1tbeygsOzo/Lyo9K1xcLX4hfCYlXjw+XS8udGVzdChjaCkgfHxcbiAgICAgIC9bZW53ZmRdLy50ZXN0KGNoKSAmJlxuICAgICAgL1xcYihjYXNlfGVsc2V8cmV0dXJufHRocm93fG5ld3xpbnwoaW5zdGFuY2V8dHlwZSk/b2Z8ZGVsZXRlfHZvaWQpJC8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHBvcyAtIDEwLCBwb3MpKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB0aGlzLnRva3MuY3VyTGluZSA9IDE7XG4gICAgICB0aGlzLnRva3MubGluZVN0YXJ0ID0gYWNvcm4ubGluZUJyZWFrRy5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IGFjb3JuLmxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCBwb3MpIHtcbiAgICAgICAgKyt0aGlzLnRva3MuY3VyTGluZTtcbiAgICAgICAgdGhpcy50b2tzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBscC5sb29rQWhlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgd2hpbGUgKG4gPiB0aGlzLmFoZWFkLmxlbmd0aClcbiAgICAgIHsgdGhpcy5haGVhZC5wdXNoKHRoaXMucmVhZFRva2VuKCkpOyB9XG4gICAgcmV0dXJuIHRoaXMuYWhlYWRbbiAtIDFdXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEdW1teShub2RlKSB7IHJldHVybiBub2RlLm5hbWUgPT09IFwi4pyWXCIgfVxuXG4gIHZhciBscCQxID0gTG9vc2VQYXJzZXIucHJvdG90eXBlO1xuXG4gIGxwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLm9wdGlvbnMubG9jYXRpb25zID8gWzAsIGFjb3JuLmdldExpbmVJbmZvKHRoaXMuaW5wdXQsIDApXSA6IDApO1xuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHdoaWxlICh0aGlzLnRvay50eXBlICE9PSBhY29ybi50b2tUeXBlcy5lb2YpIHsgbm9kZS5ib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudCgpKTsgfVxuICAgIHRoaXMudG9rcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gICAgdGhpcy5sYXN0ID0gdGhpcy50b2s7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbiAgfTtcblxuICBscCQxLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudG9rLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gICAgaWYgKHRoaXMudG9rcy5pc0xldCgpKSB7XG4gICAgICBzdGFydHR5cGUgPSBhY29ybi50b2tUeXBlcy5fdmFyO1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9icmVhazogY2FzZSBhY29ybi50b2tUeXBlcy5fY29udGludWU6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBpc0JyZWFrID0gc3RhcnR0eXBlID09PSBhY29ybi50b2tUeXBlcy5fYnJlYWs7XG4gICAgICBpZiAodGhpcy5zZW1pY29sb24oKSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIG5vZGUubGFiZWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5sYWJlbCA9IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLm5hbWUgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IG51bGw7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9kZWJ1Z2dlcjpcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5fZG86XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIG5vZGUudGVzdCA9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLl93aGlsZSkgPyB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCkgOiB0aGlzLmR1bW15SWRlbnQoKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5fZm9yOlxuICAgICAgdGhpcy5uZXh0KCk7IC8vIGBmb3JgIGtleXdvcmRcbiAgICAgIHZhciBpc0F3YWl0ID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5pbkFzeW5jICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpO1xuXG4gICAgICB0aGlzLnB1c2hDeCgpO1xuICAgICAgdGhpcy5leHBlY3QoYWNvcm4udG9rVHlwZXMucGFyZW5MKTtcbiAgICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5zZW1pKSB7IHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpIH1cbiAgICAgIHZhciBpc0xldCA9IHRoaXMudG9rcy5pc0xldCgpO1xuICAgICAgaWYgKGlzTGV0IHx8IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLl92YXIgfHwgdGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuX2NvbnN0KSB7XG4gICAgICAgIHZhciBpbml0JDEgPSB0aGlzLnBhcnNlVmFyKHRoaXMuc3RhcnROb2RlKCksIHRydWUsIGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudG9rLnZhbHVlKTtcbiAgICAgICAgaWYgKGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5faW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50b2sudHlwZSAhPT0gYWNvcm4udG9rVHlwZXMuX2luKSB7XG4gICAgICAgICAgICBub2RlLmF3YWl0ID0gaXNBd2FpdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICAgICAgfVxuICAgICAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlKTtcbiAgICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5faW4gfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50b2sudHlwZSAhPT0gYWNvcm4udG9rVHlwZXMuX2luKSB7XG4gICAgICAgICAgbm9kZS5hd2FpdCA9IGlzQXdhaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCB0aGlzLnRvQXNzaWduYWJsZShpbml0KSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9mdW5jdGlvbjpcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCB0cnVlKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5faWY6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudCgpIDogbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5fcmV0dXJuOlxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuc2VtaSkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICAgICAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9zd2l0Y2g6XG4gICAgICB2YXIgYmxvY2tJbmRlbnQgPSB0aGlzLmN1ckluZGVudCwgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgIG5vZGUuY2FzZXMgPSBbXTtcbiAgICAgIHRoaXMucHVzaEN4KCk7XG4gICAgICB0aGlzLmV4cGVjdChhY29ybi50b2tUeXBlcy5icmFjZUwpO1xuXG4gICAgICB2YXIgY3VyO1xuICAgICAgd2hpbGUgKCF0aGlzLmNsb3NlcyhhY29ybi50b2tUeXBlcy5icmFjZVIsIGJsb2NrSW5kZW50LCBsaW5lLCB0cnVlKSkge1xuICAgICAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuX2Nhc2UgfHwgdGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuX2RlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgaXNDYXNlID0gdGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuX2Nhc2U7XG4gICAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpZiAoaXNDYXNlKSB7IGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgfVxuICAgICAgICAgIGVsc2UgeyBjdXIudGVzdCA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLmV4cGVjdChhY29ybi50b2tUeXBlcy5jb2xvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgIHRoaXMucG9wQ3goKTtcbiAgICAgIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmJyYWNlUik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl90aHJvdzpcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl90cnk6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gICAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuX2NhdGNoKSB7XG4gICAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnBhcmVuTCkpIHtcbiAgICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnRvQXNzaWduYWJsZSh0aGlzLnBhcnNlRXhwckF0b20oKSwgdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoYWNvcm4udG9rVHlwZXMucGFyZW5SKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgICB9XG4gICAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikgeyByZXR1cm4gbm9kZS5ibG9jayB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl92YXI6XG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5fY29uc3Q6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCB8fCB0aGlzLnRvay52YWx1ZSlcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuX3doaWxlOlxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuX3dpdGg6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIilcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLnNlbWk6XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5fY2xhc3M6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRydWUpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgdGhpcy5sb29rQWhlYWQoMSkudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMucGFyZW5MKSB7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0KClcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuX2V4cG9ydDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwb3J0KClcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy50b2tzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCB0cnVlLCB0cnVlKVxuICAgICAgfVxuICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKGlzRHVtbXkoZXhwcikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5lb2YpIHsgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQoKVxuICAgICAgfSBlbHNlIGlmIChzdGFydHR5cGUgPT09IGFjb3JuLnRva1R5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5jb2xvbikpIHtcbiAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGxwJDEucGFyc2VCbG9jayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnB1c2hDeCgpO1xuICAgIHRoaXMuZXhwZWN0KGFjb3JuLnRva1R5cGVzLmJyYWNlTCk7XG4gICAgdmFyIGJsb2NrSW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICBub2RlLmJvZHkgPSBbXTtcbiAgICB3aGlsZSAoIXRoaXMuY2xvc2VzKGFjb3JuLnRva1R5cGVzLmJyYWNlUiwgYmxvY2tJbmRlbnQsIGxpbmUsIHRydWUpKVxuICAgICAgeyBub2RlLmJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KCkpOyB9XG4gICAgdGhpcy5wb3BDeCgpO1xuICAgIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmJyYWNlUik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgbHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIG5vZGUudGVzdCA9IG5vZGUudXBkYXRlID0gbnVsbDtcbiAgICBpZiAodGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuc2VtaSkgJiYgdGhpcy50b2sudHlwZSAhPT0gYWNvcm4udG9rVHlwZXMuc2VtaSkgeyBub2RlLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB9XG4gICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnNlbWkpICYmIHRoaXMudG9rLnR5cGUgIT09IGFjb3JuLnRva1R5cGVzLnBhcmVuUikgeyBub2RlLnVwZGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IH1cbiAgICB0aGlzLnBvcEN4KCk7XG4gICAgdGhpcy5leHBlY3QoYWNvcm4udG9rVHlwZXMucGFyZW5SKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxuICB9O1xuXG4gIGxwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLl9pbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMucG9wQ3goKTtcbiAgICB0aGlzLmV4cGVjdChhY29ybi50b2tUeXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpXG4gIH07XG5cbiAgbHAkMS5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIG5vSW4sIGtpbmQpIHtcbiAgICBub2RlLmtpbmQgPSBraW5kO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgZG8ge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgZGVjbC5pZCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gdGhpcy50b0Fzc2lnbmFibGUodGhpcy5wYXJzZUV4cHJBdG9tKCksIHRydWUpIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBkZWNsLmluaXQgPSB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5lcSkgPyB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbikgOiBudWxsO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmNvbW1hKSlcbiAgICBpZiAoIW5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aCkge1xuICAgICAgdmFyIGRlY2wkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBkZWNsJDEuaWQgPSB0aGlzLmR1bW15SWRlbnQoKTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wkMSwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgIH1cbiAgICBpZiAoIW5vSW4pIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gIH07XG5cbiAgbHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24oaXNTdGF0ZW1lbnQpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLm5hbWUpIHsgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudCgpOyB9XG4gICAgZWxzZSBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpIHsgbm9kZS5pZCA9IHRoaXMuZHVtbXlJZGVudCgpOyB9XG4gICAgZWxzZSB7IG5vZGUuaWQgPSBudWxsOyB9XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IG51bGw7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmJvZHkuYm9keSA9IFtdO1xuICAgIHRoaXMucHVzaEN4KCk7XG4gICAgdmFyIGluZGVudCA9IHRoaXMuY3VySW5kZW50ICsgMSwgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmJyYWNlTCk7XG4gICAgaWYgKHRoaXMuY3VySW5kZW50ICsgMSA8IGluZGVudCkgeyBpbmRlbnQgPSB0aGlzLmN1ckluZGVudDsgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0OyB9XG4gICAgd2hpbGUgKCF0aGlzLmNsb3NlcyhhY29ybi50b2tUeXBlcy5icmFjZVIsIGluZGVudCwgbGluZSkpIHtcbiAgICAgIGlmICh0aGlzLnNlbWljb2xvbigpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciA9ICh2b2lkIDApLCBpc0FzeW5jID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgbWV0aG9kLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnN0YXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgICAgaWYgKGlzRHVtbXkobWV0aG9kLmtleSkpIHsgaWYgKGlzRHVtbXkodGhpcy5wYXJzZU1heWJlQXNzaWduKCkpKSB7IHRoaXMubmV4dCgpOyB9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmNvbW1hKTsgY29udGludWUgfVxuICAgICAgaWYgKG1ldGhvZC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIW1ldGhvZC5jb21wdXRlZCAmJiBtZXRob2Qua2V5Lm5hbWUgPT09IFwic3RhdGljXCIgJiZcbiAgICAgICAgICAodGhpcy50b2sudHlwZSAhPT0gYWNvcm4udG9rVHlwZXMucGFyZW5MICYmIHRoaXMudG9rLnR5cGUgIT09IGFjb3JuLnRva1R5cGVzLmJyYWNlTCkpIHtcbiAgICAgICAgbWV0aG9kLnN0YXRpYyA9IHRydWU7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuc3Rhcik7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmXG4gICAgICAgICAgbWV0aG9kLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBtZXRob2Qua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnRvay50eXBlICE9PSBhY29ybi50b2tUeXBlcy5wYXJlbkwgJiZcbiAgICAgICAgICAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5zdGFyKTtcbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIG1ldGhvZC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAhbWV0aG9kLmNvbXB1dGVkICYmIChtZXRob2Qua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgbWV0aG9kLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgIHRoaXMudG9rLnR5cGUgIT09IGFjb3JuLnRva1R5cGVzLnBhcmVuTCAmJiB0aGlzLnRvay50eXBlICE9PSBhY29ybi50b2tUeXBlcy5icmFjZUwpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBtZXRob2Qua2V5Lm5hbWU7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgICAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiAhaXNHZW5lcmF0b3IgJiYgIWlzQXN5bmMgJiYgKFxuICAgICAgICAgIG1ldGhvZC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbWV0aG9kLmtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgICAgICAgIG1ldGhvZC5rZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgbWV0aG9kLmtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpKTtcbiAgICB9XG4gICAgdGhpcy5wb3BDeCgpO1xuICAgIGlmICghdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuYnJhY2VSKSkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gY2xvc2luZyBicmFjZSwgbWFrZSB0aGUgbm9kZSBzcGFuIHRvIHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIG5leHQgdG9rZW4gKHRoaXMgaXMgdXNlZnVsIGZvciBUZXJuKVxuICAgICAgdGhpcy5sYXN0LmVuZCA9IHRoaXMudG9rLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5sYXN0LmxvYy5lbmQgPSB0aGlzLnRvay5sb2Muc3RhcnQ7IH1cbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUobm9kZS5ib2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIGxwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50LCBpc0FzeW5jKSB7XG4gICAgdmFyIG9sZEluQXN5bmMgPSB0aGlzLmluQXN5bmMsIG9sZEluRnVuY3Rpb24gPSB0aGlzLmluRnVuY3Rpb247XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHtcbiAgICAgIG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7XG4gICAgfVxuICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5uYW1lKSB7IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTsgfVxuICAgIGVsc2UgaWYgKGlzU3RhdGVtZW50ID09PSB0cnVlKSB7IG5vZGUuaWQgPSB0aGlzLmR1bW15SWRlbnQoKTsgfVxuICAgIHRoaXMuaW5Bc3luYyA9IG5vZGUuYXN5bmM7XG4gICAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcygpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIHRoaXMudG9rcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICB0aGlzLmluQXN5bmMgPSBvbGRJbkFzeW5jO1xuICAgIHRoaXMuaW5GdW5jdGlvbiA9IG9sZEluRnVuY3Rpb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuICBscCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdChhY29ybi50b2tUeXBlcy5zdGFyKSkge1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLmR1bW15U3RyaW5nKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLl9kZWZhdWx0KSkge1xuICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGZvbygpIHt9KSAvLyBUaGlzIGlzIEZ1bmN0aW9uRXhwcmVzc2lvbi5cbiAgICAgIHZhciBpc0FzeW5jO1xuICAgICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMudG9rcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIFwibnVsbGFibGVJRFwiLCBpc0FzeW5jKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuX2NsYXNzKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoXCJudWxsYWJsZUlEXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy50b2sudHlwZS5rZXl3b3JkIHx8IHRoaXMudG9rcy5pc0xldCgpIHx8IHRoaXMudG9rcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJMaXN0KCk7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IG51bGw7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIGxwJDEucGFyc2VJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLnN0cmluZykge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWx0O1xuICAgICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLm5hbWUgJiYgdGhpcy50b2sudmFsdWUgIT09IFwiZnJvbVwiKSB7XG4gICAgICAgIGVsdCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIGVsdC5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgICB0aGlzLmZpbmlzaE5vZGUoZWx0LCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIik7XG4gICAgICAgIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmNvbW1hKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikgJiYgdGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLmR1bW15U3RyaW5nKCk7XG4gICAgICBpZiAoZWx0KSB7IG5vZGUuc3BlY2lmaWVycy51bnNoaWZ0KGVsdCk7IH1cbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBscCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbHRzID0gW107XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLnN0YXIpIHtcbiAgICAgIHZhciBlbHQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBlbHQubG9jYWwgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCgpIDogdGhpcy5kdW1teUlkZW50KCk7XG4gICAgICBlbHRzLnB1c2godGhpcy5maW5pc2hOb2RlKGVsdCwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydCwgY29udGludWVkTGluZSA9IHRoaXMubmV4dExpbmVTdGFydDtcbiAgICAgIHRoaXMucHVzaEN4KCk7XG4gICAgICB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5icmFjZUwpO1xuICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gY29udGludWVkTGluZSkgeyBjb250aW51ZWRMaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7IH1cbiAgICAgIHdoaWxlICghdGhpcy5jbG9zZXMoYWNvcm4udG9rVHlwZXMuYnJhY2VSLCBpbmRlbnQgKyAodGhpcy5jdXJMaW5lU3RhcnQgPD0gY29udGludWVkTGluZSA/IDEgOiAwKSwgbGluZSkpIHtcbiAgICAgICAgdmFyIGVsdCQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnN0YXIpKSB7XG4gICAgICAgICAgZWx0JDEubG9jYWwgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCgpIDogdGhpcy5kdW1teUlkZW50KCk7XG4gICAgICAgICAgdGhpcy5maW5pc2hOb2RlKGVsdCQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJmcm9tXCIpKSB7IGJyZWFrIH1cbiAgICAgICAgICBlbHQkMS5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgICAgIGlmIChpc0R1bW15KGVsdCQxLmltcG9ydGVkKSkgeyBicmVhayB9XG4gICAgICAgICAgZWx0JDEubG9jYWwgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCgpIDogZWx0JDEuaW1wb3J0ZWQ7XG4gICAgICAgICAgdGhpcy5maW5pc2hOb2RlKGVsdCQxLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHRzLnB1c2goZWx0JDEpO1xuICAgICAgICB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5jb21tYSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5icmFjZVIpO1xuICAgICAgdGhpcy5wb3BDeCgpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIGxwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsdHMgPSBbXTtcbiAgICB2YXIgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydCwgY29udGludWVkTGluZSA9IHRoaXMubmV4dExpbmVTdGFydDtcbiAgICB0aGlzLnB1c2hDeCgpO1xuICAgIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmJyYWNlTCk7XG4gICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gY29udGludWVkTGluZSkgeyBjb250aW51ZWRMaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7IH1cbiAgICB3aGlsZSAoIXRoaXMuY2xvc2VzKGFjb3JuLnRva1R5cGVzLmJyYWNlUiwgaW5kZW50ICsgKHRoaXMuY3VyTGluZVN0YXJ0IDw9IGNvbnRpbnVlZExpbmUgPyAxIDogMCksIGxpbmUpKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJmcm9tXCIpKSB7IGJyZWFrIH1cbiAgICAgIHZhciBlbHQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgZWx0LmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAoaXNEdW1teShlbHQubG9jYWwpKSB7IGJyZWFrIH1cbiAgICAgIGVsdC5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50KCkgOiBlbHQubG9jYWw7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoZWx0LCBcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgICAgdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuY29tbWEpO1xuICAgIH1cbiAgICB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5icmFjZVIpO1xuICAgIHRoaXMucG9wQ3goKTtcbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHZhciBscCQyID0gTG9vc2VQYXJzZXIucHJvdG90eXBlO1xuXG4gIGxwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwcikge1xuICAgIGlmICghZXhwcikgeyByZXR1cm4gZXhwciB9XG4gICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICBleHByLmV4cHJlc3Npb24gPSB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24pO1xuICAgICAgcmV0dXJuIGV4cHJcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5kdW1teUlkZW50KClcbiAgICB9XG4gIH07XG5cbiAgbHAkMi5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuY29tbWEpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIGxwJDIucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnB1c2hDeCgpO1xuICAgIHRoaXMuZXhwZWN0KGFjb3JuLnRva1R5cGVzLnBhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5wb3BDeCgpO1xuICAgIHRoaXMuZXhwZWN0KGFjb3JuLnRva1R5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHZhbFxuICB9O1xuXG4gIGxwJDIucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgICBpZiAodGhpcy50b2tzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLnNlbWljb2xvbigpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudG9rLnR5cGUgIT09IGFjb3JuLnRva1R5cGVzLnN0YXIgJiYgIXRoaXMudG9rLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICAgICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5zdGFyKTtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICAgIH1cblxuICAgIHZhciBzdGFydCA9IHRoaXMuc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luKTtcbiAgICBpZiAodGhpcy50b2sudHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy50b2sudmFsdWU7XG4gICAgICBub2RlJDEubGVmdCA9IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCkgOiB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZSQxLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICBscCQyLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJPcHMobm9Jbik7XG4gICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5leHBlY3QoYWNvcm4udG9rVHlwZXMuY29sb24pID8gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pIDogdGhpcy5kdW1teUlkZW50KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgbHAkMi5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShmYWxzZSksIHN0YXJ0LCAtMSwgbm9JbiwgaW5kZW50LCBsaW5lKVxuICB9O1xuXG4gIGxwJDIucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBzdGFydCwgbWluUHJlYywgbm9JbiwgaW5kZW50LCBsaW5lKSB7XG4gICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICE9PSBsaW5lICYmIHRoaXMuY3VySW5kZW50IDwgaW5kZW50ICYmIHRoaXMudG9rZW5TdGFydHNMaW5lKCkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBwcmVjID0gdGhpcy50b2sudHlwZS5iaW5vcDtcbiAgICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0aGlzLnRvay50eXBlICE9PSBhY29ybi50b2tUeXBlcy5faW4pKSB7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudG9rLnZhbHVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICE9PSBsaW5lICYmIHRoaXMuY3VySW5kZW50IDwgaW5kZW50ICYmIHRoaXMudG9rZW5TdGFydHNMaW5lKCkpIHtcbiAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5kdW1teUlkZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJpZ2h0U3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KGZhbHNlKSwgcmlnaHRTdGFydCwgcHJlYywgbm9JbiwgaW5kZW50LCBsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgLyYmfFxcfFxcfC8udGVzdChub2RlLm9wZXJhdG9yKSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgc3RhcnQsIG1pblByZWMsIG5vSW4sIGluZGVudCwgbGluZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICBscCQyLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHNhd1VuYXJ5KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKSwgZXhwcjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgdGhpcy50b2tzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmXG4gICAgICAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSlcbiAgICApIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoKTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rLnR5cGUucHJlZml4KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLmluY0RlYztcbiAgICAgIGlmICghdXBkYXRlKSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudG9rLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkodHJ1ZSk7XG4gICAgICBpZiAodXBkYXRlKSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLmNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTsgfVxuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlJDEuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShzYXdVbmFyeSk7XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJTcHJlYWRFbGVtZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG4gICAgICB3aGlsZSAodGhpcy50b2sudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgICAgbm9kZSQyLm9wZXJhdG9yID0gdGhpcy50b2sudmFsdWU7XG4gICAgICAgIG5vZGUkMi5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgbm9kZSQyLmFyZ3VtZW50ID0gdGhpcy5jaGVja0xWYWwoZXhwcik7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuc3RhcnN0YXIpKSB7XG4gICAgICB2YXIgbm9kZSQzID0gdGhpcy5zdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlJDMub3BlcmF0b3IgPSBcIioqXCI7XG4gICAgICBub2RlJDMubGVmdCA9IGV4cHI7XG4gICAgICBub2RlJDMucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUkMywgXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJcbiAgfTtcblxuICBscCQyLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnQsIGZhbHNlLCB0aGlzLmN1ckluZGVudCwgdGhpcy5jdXJMaW5lU3RhcnQpXG4gIH07XG5cbiAgbHAkMi5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbihiYXNlLCBzdGFydCwgbm9DYWxscywgc3RhcnRJbmRlbnQsIGxpbmUpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgIT09IGxpbmUgJiYgdGhpcy5jdXJJbmRlbnQgPD0gc3RhcnRJbmRlbnQgJiYgdGhpcy50b2tlblN0YXJ0c0xpbmUoKSkge1xuICAgICAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuZG90ICYmIHRoaXMuY3VySW5kZW50ID09PSBzdGFydEluZGVudClcbiAgICAgICAgICB7IC0tc3RhcnRJbmRlbnQ7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcmV0dXJuIGJhc2UgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF5YmVBc3luY0Fycm93ID0gYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcblxuICAgICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmRvdCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgIT09IGxpbmUgJiYgdGhpcy5jdXJJbmRlbnQgPD0gc3RhcnRJbmRlbnQgJiYgdGhpcy50b2tlblN0YXJ0c0xpbmUoKSlcbiAgICAgICAgICB7IG5vZGUucHJvcGVydHkgPSB0aGlzLmR1bW15SWRlbnQoKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByb3BlcnR5QWNjZXNzb3IoKSB8fCB0aGlzLmR1bW15SWRlbnQoKTsgfVxuICAgICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5icmFja2V0TCkge1xuICAgICAgICB0aGlzLnB1c2hDeCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgICBub2RlJDEub2JqZWN0ID0gYmFzZTtcbiAgICAgICAgbm9kZSQxLnByb3BlcnR5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgbm9kZSQxLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3BDeCgpO1xuICAgICAgICB0aGlzLmV4cGVjdChhY29ybi50b2tUeXBlcy5icmFja2V0Uik7XG4gICAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLnBhcmVuTCkge1xuICAgICAgICB2YXIgZXhwckxpc3QgPSB0aGlzLnBhcnNlRXhwckxpc3QoYWNvcm4udG9rVHlwZXMucGFyZW5SKTtcbiAgICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5hcnJvdykpXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KSwgZXhwckxpc3QsIHRydWUpIH1cbiAgICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgICBub2RlJDIuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgbm9kZSQyLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICAgIHZhciBub2RlJDMgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgICAgbm9kZSQzLnRhZyA9IGJhc2U7XG4gICAgICAgIG5vZGUkMy5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSgpO1xuICAgICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMywgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFzZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBscCQyLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBzd2l0Y2ggKHRoaXMudG9rLnR5cGUpIHtcbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl90aGlzOlxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuX3N1cGVyOlxuICAgICAgdmFyIHR5cGUgPSB0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5fdGhpcyA/IFwiVGhpc0V4cHJlc3Npb25cIiA6IFwiU3VwZXJcIjtcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLm5hbWU6XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICAgICAgaWYgKGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpZiAodGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuX2Z1bmN0aW9uKSlcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydCksIGZhbHNlLCB0cnVlKSB9XG4gICAgICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5uYW1lKSB7XG4gICAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmFycm93KSA/IHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydCksIFtpZF0sIGlzQXN5bmMpIDogaWRcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMucmVnZXhwOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB2YXIgdmFsID0gdGhpcy50b2sudmFsdWU7XG4gICAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbC5wYXR0ZXJuLCBmbGFnczogdmFsLmZsYWdzfTtcbiAgICAgIG5vZGUudmFsdWUgPSB2YWwudmFsdWU7XG4gICAgICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy50b2suc3RhcnQsIHRoaXMudG9rLmVuZCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLm51bTogY2FzZSBhY29ybi50b2tUeXBlcy5zdHJpbmc6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnRvay52YWx1ZTtcbiAgICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnRvay5zdGFydCwgdGhpcy50b2suZW5kKTtcbiAgICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5udW0gJiYgbm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpOyB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9udWxsOiBjYXNlIGFjb3JuLnRva1R5cGVzLl90cnVlOiBjYXNlIGFjb3JuLnRva1R5cGVzLl9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLl90cnVlO1xuICAgICAgbm9kZS5yYXcgPSB0aGlzLnRvay50eXBlLmtleXdvcmQ7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLnBhcmVuTDpcbiAgICAgIHZhciBwYXJlblN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdmFyIGlubmVyID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KGFjb3JuLnRva1R5cGVzLnBhcmVuUik7XG4gICAgICBpZiAodGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIC8vIChhLCk9PmEgLy8gU2VxdWVuY2VFeHByZXNzaW9uIG1ha2VzIGR1bW15IGluIHRoZSBsYXN0IGhvbGUuIERyb3AgdGhlIGR1bW15LlxuICAgICAgICB2YXIgcGFyYW1zID0gaW5uZXIuZXhwcmVzc2lvbnMgfHwgW2lubmVyXTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggJiYgaXNEdW1teShwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKSlcbiAgICAgICAgICB7IHBhcmFtcy5wb3AoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHBhcmVuU3RhcnQpLCBwYXJhbXMpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHBhcmVuU3RhcnQpO1xuICAgICAgICBwYXIuZXhwcmVzc2lvbiA9IGlubmVyO1xuICAgICAgICBpbm5lciA9IHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXJcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuYnJhY2tldEw6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QoYWNvcm4udG9rVHlwZXMuYnJhY2tldFIsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaigpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9jbGFzczpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoZmFsc2UpXG5cbiAgICBjYXNlIGFjb3JuLnRva1R5cGVzLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gICAgY2FzZSBhY29ybi50b2tUeXBlcy5iYWNrUXVvdGU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICAgIGNhc2UgYWNvcm4udG9rVHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHVtbXlJZGVudCgpXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRoaXMuZHVtbXlJZGVudCgpXG4gICAgfVxuICB9O1xuXG4gIGxwJDIucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIilcbiAgfTtcblxuICBscCQyLnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBzdGFydEluZGVudCA9IHRoaXMuY3VySW5kZW50LCBsaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmRvdCkpIHtcbiAgICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICAgIH1cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0LCB0cnVlLCBzdGFydEluZGVudCwgbGluZSk7XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLnBhcmVuTCkge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QoYWNvcm4udG9rVHlwZXMucGFyZW5SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbiAgfTtcblxuICBscCQyLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgLy8gVGhlIGxvb3NlIHBhcnNlciBhY2NlcHRzIGludmFsaWQgdW5pY29kZSBlc2NhcGVzIGV2ZW4gaW4gdW50YWdnZWQgdGVtcGxhdGVzLlxuICAgIGlmICh0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy50b2sudmFsdWUsXG4gICAgICAgIGNvb2tlZDogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMudG9rLnN0YXJ0LCB0aGlzLnRvay5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICAgIGNvb2tlZDogdGhpcy50b2sudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLmJhY2tRdW90ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpXG4gIH07XG5cbiAgbHAkMi5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCgpO1xuICAgIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICBpZiAodGhpcy5leHBlY3QoYWNvcm4udG9rVHlwZXMuYnJhY2VSKSkge1xuICAgICAgICBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJFbHQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBjdXJFbHQudmFsdWUgPSB7Y29va2VkOiBcIlwiLCByYXc6IFwiXCJ9O1xuICAgICAgICBjdXJFbHQudGFpbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZmluaXNoTm9kZShjdXJFbHQsIFwiVGVtcGxhdGVFbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdChhY29ybi50b2tUeXBlcy5iYWNrUXVvdGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgfTtcblxuICBscCQyLnBhcnNlT2JqID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMucHVzaEN4KCk7XG4gICAgdmFyIGluZGVudCA9IHRoaXMuY3VySW5kZW50ICsgMSwgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmJyYWNlTCk7XG4gICAgaWYgKHRoaXMuY3VySW5kZW50ICsgMSA8IGluZGVudCkgeyBpbmRlbnQgPSB0aGlzLmN1ckluZGVudDsgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0OyB9XG4gICAgd2hpbGUgKCF0aGlzLmNsb3NlcyhhY29ybi50b2tUeXBlcy5icmFjZVIsIGluZGVudCwgbGluZSkpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IgPSAodm9pZCAwKSwgaXNBc3luYyA9ICh2b2lkIDApLCBzdGFydCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIikpO1xuICAgICAgICB0aGlzLmVhdChhY29ybi50b2tUeXBlcy5jb21tYSk7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgICAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgICBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLnN0YXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIGlmICh0aGlzLnRva3MuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuc3Rhcik7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNEdW1teShwcm9wLmtleSkpIHsgaWYgKGlzRHVtbXkodGhpcy5wYXJzZU1heWJlQXNzaWduKCkpKSB7IHRoaXMubmV4dCgpOyB9IHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmNvbW1hKTsgY29udGludWUgfVxuICAgICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmNvbG9uKSkge1xuICAgICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMucGFyZW5MIHx8IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLmJyYWNlTCkpIHtcbiAgICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgICAgICAhcHJvcC5jb21wdXRlZCAmJiAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICAgICAodGhpcy50b2sudHlwZSAhPT0gYWNvcm4udG9rVHlwZXMuY29tbWEgJiYgdGhpcy50b2sudHlwZSAhPT0gYWNvcm4udG9rVHlwZXMuYnJhY2VSICYmIHRoaXMudG9rLnR5cGUgIT09IGFjb3JuLnRva1R5cGVzLmVxKSkge1xuICAgICAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWF0KGFjb3JuLnRva1R5cGVzLmVxKSkge1xuICAgICAgICAgICAgdmFyIGFzc2lnbiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgICAgICAgYXNzaWduLm9wZXJhdG9yID0gXCI9XCI7XG4gICAgICAgICAgICBhc3NpZ24ubGVmdCA9IHByb3Aua2V5O1xuICAgICAgICAgICAgYXNzaWduLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5maW5pc2hOb2RlKGFzc2lnbiwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcC52YWx1ZSA9IHByb3Aua2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5kdW1teUlkZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2godGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIikpO1xuICAgICAgdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuY29tbWEpO1xuICAgIH1cbiAgICB0aGlzLnBvcEN4KCk7XG4gICAgaWYgKCF0aGlzLmVhdChhY29ybi50b2tUeXBlcy5icmFjZVIpKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBjbG9zaW5nIGJyYWNlLCBtYWtlIHRoZSBub2RlIHNwYW4gdG8gdGhlIHN0YXJ0XG4gICAgICAvLyBvZiB0aGUgbmV4dCB0b2tlbiAodGhpcyBpcyB1c2VmdWwgZm9yIFRlcm4pXG4gICAgICB0aGlzLmxhc3QuZW5kID0gdGhpcy50b2suc3RhcnQ7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxhc3QubG9jLmVuZCA9IHRoaXMudG9rLmxvYy5zdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIGxwJDIucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KGFjb3JuLnRva1R5cGVzLmJyYWNrZXRSKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBrZXkgPSAodGhpcy50b2sudHlwZSA9PT0gYWNvcm4udG9rVHlwZXMubnVtIHx8IHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLnN0cmluZykgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHByb3Aua2V5ID0ga2V5IHx8IHRoaXMuZHVtbXlJZGVudCgpO1xuICB9O1xuXG4gIGxwJDIucGFyc2VQcm9wZXJ0eUFjY2Vzc29yID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IGFjb3JuLnRva1R5cGVzLm5hbWUgfHwgdGhpcy50b2sudHlwZS5rZXl3b3JkKSB7IHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKSB9XG4gIH07XG5cbiAgbHAkMi5wYXJzZUlkZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRvay50eXBlID09PSBhY29ybi50b2tUeXBlcy5uYW1lID8gdGhpcy50b2sudmFsdWUgOiB0aGlzLnRvay50eXBlLmtleXdvcmQ7XG4gICAgaWYgKCFuYW1lKSB7IHJldHVybiB0aGlzLmR1bW15SWRlbnQoKSB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIilcbiAgfTtcblxuICBscCQyLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgbm9kZS5nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxuICB9O1xuXG4gIC8vIENvbnZlcnQgZXhpc3RpbmcgZXhwcmVzc2lvbiBhdG9tIHRvIGFzc2lnbmFibGUgcGF0dGVyblxuICAvLyBpZiBwb3NzaWJsZS5cblxuICBscCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmcpIHtcbiAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCAobm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhYmluZGluZykpIDsgZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpIHtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgYmluZGluZyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kdW1teUlkZW50KClcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBiaW5kaW5nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBiaW5kaW5nKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiKSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBiaW5kaW5nKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGJpbmRpbmcpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kdW1teUlkZW50KClcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBscCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgYmluZGluZykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwckxpc3Q7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGV4cHIgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShleHByLCBiaW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJMaXN0XG4gIH07XG5cbiAgbHAkMi5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcGFyYW1zID0gdGhpcy5wYXJzZUV4cHJMaXN0KGFjb3JuLnRva1R5cGVzLnBhcmVuUik7XG4gICAgcmV0dXJuIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpXG4gIH07XG5cbiAgbHAkMi5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLCBvbGRJbkZ1bmN0aW9uID0gdGhpcy5pbkZ1bmN0aW9uO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgbm9kZS5nZW5lcmF0b3IgPSAhIWlzR2VuZXJhdG9yOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG4gICAgdGhpcy5pbkFzeW5jID0gbm9kZS5hc3luYztcbiAgICB0aGlzLmluRnVuY3Rpb24gPSB0cnVlO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgdGhpcy50b2tzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gICAgdGhpcy5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jdGlvbjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgbHAkMi5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICAgIHZhciBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLCBvbGRJbkZ1bmN0aW9uID0gdGhpcy5pbkZ1bmN0aW9uO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuICAgIHRoaXMuaW5Bc3luYyA9IG5vZGUuYXN5bmM7XG4gICAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudG9rLnR5cGUgIT09IGFjb3JuLnRva1R5cGVzLmJyYWNlTDtcbiAgICBpZiAobm9kZS5leHByZXNzaW9uKSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICB0aGlzLnRva3MuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgfVxuICAgIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gICAgdGhpcy5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jdGlvbjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuICBscCQyLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSkge1xuICAgIHRoaXMucHVzaEN4KCk7XG4gICAgdmFyIGluZGVudCA9IHRoaXMuY3VySW5kZW50LCBsaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQsIGVsdHMgPSBbXTtcbiAgICB0aGlzLm5leHQoKTsgLy8gT3BlbmluZyBicmFja2V0XG4gICAgd2hpbGUgKCF0aGlzLmNsb3NlcyhjbG9zZSwgaW5kZW50ICsgMSwgbGluZSkpIHtcbiAgICAgIGlmICh0aGlzLmVhdChhY29ybi50b2tUeXBlcy5jb21tYSkpIHtcbiAgICAgICAgZWx0cy5wdXNoKGFsbG93RW1wdHkgPyBudWxsIDogdGhpcy5kdW1teUlkZW50KCkpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgaWYgKGlzRHVtbXkoZWx0KSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZXMoY2xvc2UsIGluZGVudCwgbGluZSkpIHsgYnJlYWsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lYXQoYWNvcm4udG9rVHlwZXMuY29tbWEpO1xuICAgIH1cbiAgICB0aGlzLnBvcEN4KCk7XG4gICAgaWYgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNsb3NpbmcgYnJhY2UsIG1ha2UgdGhlIG5vZGUgc3BhbiB0byB0aGUgc3RhcnRcbiAgICAgIC8vIG9mIHRoZSBuZXh0IHRva2VuICh0aGlzIGlzIHVzZWZ1bCBmb3IgVGVybilcbiAgICAgIHRoaXMubGFzdC5lbmQgPSB0aGlzLnRvay5zdGFydDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGFzdC5sb2MuZW5kID0gdGhpcy50b2subG9jLnN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzXG4gIH07XG5cbiAgbHAkMi5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbiAgfTtcblxuICAvLyBBY29ybjogTG9vc2UgcGFyc2VyXG5cbiAgYWNvcm4uZGVmYXVsdE9wdGlvbnMudGFiU2l6ZSA9IDQ7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTG9vc2VQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICBleHBvcnRzLkxvb3NlUGFyc2VyID0gTG9vc2VQYXJzZXI7XG4gIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxXQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.js\n");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.mjs ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.LooseParser = void 0;\n\nvar _acorn = __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.js\");\n\nfunction noop() {}\n\nvar LooseParser = function LooseParser(input, options) {\n  if (options === void 0) options = {};\n  this.toks = this.constructor.BaseParser.tokenizer(input, options);\n  this.options = this.toks.options;\n  this.input = this.toks.input;\n  this.tok = this.last = {\n    type: _acorn.tokTypes.eof,\n    start: 0,\n    end: 0\n  };\n  this.tok.validateRegExpFlags = noop;\n  this.tok.validateRegExpPattern = noop;\n\n  if (this.options.locations) {\n    var here = this.toks.curPosition();\n    this.tok.loc = new _acorn.SourceLocation(this.toks, here, here);\n  }\n\n  this.ahead = []; // Tokens ahead\n\n  this.context = []; // Indentation contexted\n\n  this.curIndent = 0;\n  this.curLineStart = 0;\n  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n  this.inAsync = false;\n  this.inFunction = false;\n};\n\nexports.LooseParser = LooseParser;\n\nLooseParser.prototype.startNode = function startNode() {\n  return new _acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);\n};\n\nLooseParser.prototype.storeCurrentPos = function storeCurrentPos() {\n  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;\n};\n\nLooseParser.prototype.startNodeAt = function startNodeAt(pos) {\n  if (this.options.locations) {\n    return new _acorn.Node(this.toks, pos[0], pos[1]);\n  } else {\n    return new _acorn.Node(this.toks, pos);\n  }\n};\n\nLooseParser.prototype.finishNode = function finishNode(node, type) {\n  node.type = type;\n  node.end = this.last.end;\n\n  if (this.options.locations) {\n    node.loc.end = this.last.loc.end;\n  }\n\n  if (this.options.ranges) {\n    node.range[1] = this.last.end;\n  }\n\n  return node;\n};\n\nLooseParser.prototype.dummyNode = function dummyNode(type) {\n  var dummy = this.startNode();\n  dummy.type = type;\n  dummy.end = dummy.start;\n\n  if (this.options.locations) {\n    dummy.loc.end = dummy.loc.start;\n  }\n\n  if (this.options.ranges) {\n    dummy.range[1] = dummy.start;\n  }\n\n  this.last = {\n    type: _acorn.tokTypes.name,\n    start: dummy.start,\n    end: dummy.start,\n    loc: dummy.loc\n  };\n  return dummy;\n};\n\nLooseParser.prototype.dummyIdent = function dummyIdent() {\n  var dummy = this.dummyNode(\"Identifier\");\n  dummy.name = \"\";\n  return dummy;\n};\n\nLooseParser.prototype.dummyString = function dummyString() {\n  var dummy = this.dummyNode(\"Literal\");\n  dummy.value = dummy.raw = \"\";\n  return dummy;\n};\n\nLooseParser.prototype.eat = function eat(type) {\n  if (this.tok.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n};\n\nLooseParser.prototype.isContextual = function isContextual(name) {\n  return this.tok.type === _acorn.tokTypes.name && this.tok.value === name;\n};\n\nLooseParser.prototype.eatContextual = function eatContextual(name) {\n  return this.tok.value === name && this.eat(_acorn.tokTypes.name);\n};\n\nLooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {\n  return this.tok.type === _acorn.tokTypes.eof || this.tok.type === _acorn.tokTypes.braceR || _acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start));\n};\n\nLooseParser.prototype.semicolon = function semicolon() {\n  return this.eat(_acorn.tokTypes.semi);\n};\n\nLooseParser.prototype.expect = function expect(type) {\n  if (this.eat(type)) {\n    return true;\n  }\n\n  for (var i = 1; i <= 2; i++) {\n    if (this.lookAhead(i).type === type) {\n      for (var j = 0; j < i; j++) {\n        this.next();\n      }\n\n      return true;\n    }\n  }\n};\n\nLooseParser.prototype.pushCx = function pushCx() {\n  this.context.push(this.curIndent);\n};\n\nLooseParser.prototype.popCx = function popCx() {\n  this.curIndent = this.context.pop();\n};\n\nLooseParser.prototype.lineEnd = function lineEnd(pos) {\n  while (pos < this.input.length && !(0, _acorn.isNewLine)(this.input.charCodeAt(pos))) {\n    ++pos;\n  }\n\n  return pos;\n};\n\nLooseParser.prototype.indentationAfter = function indentationAfter(pos) {\n  for (var count = 0;; ++pos) {\n    var ch = this.input.charCodeAt(pos);\n\n    if (ch === 32) {\n      ++count;\n    } else if (ch === 9) {\n      count += this.options.tabSize;\n    } else {\n      return count;\n    }\n  }\n};\n\nLooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {\n  if (this.tok.type === closeTok || this.tok.type === _acorn.tokTypes.eof) {\n    return true;\n  }\n\n  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);\n};\n\nLooseParser.prototype.tokenStartsLine = function tokenStartsLine() {\n  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n    var ch = this.input.charCodeAt(p);\n\n    if (ch !== 9 && ch !== 32) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nLooseParser.prototype.extend = function extend(name, f) {\n  this[name] = f(this[name]);\n};\n\nLooseParser.prototype.parse = function parse() {\n  this.next();\n  return this.parseTopLevel();\n};\n\nLooseParser.extend = function extend() {\n  var plugins = [],\n      len = arguments.length;\n\n  while (len--) {\n    plugins[len] = arguments[len];\n  }\n\n  var cls = this;\n\n  for (var i = 0; i < plugins.length; i++) {\n    cls = plugins[i](cls);\n  }\n\n  return cls;\n};\n\nLooseParser.parse = function parse(input, options) {\n  return new this(input, options).parse();\n}; // Allows plugins to extend the base parser / tokenizer used\n\n\nLooseParser.BaseParser = _acorn.Parser;\nvar lp = LooseParser.prototype;\n\nfunction isSpace(ch) {\n  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || (0, _acorn.isNewLine)(ch);\n}\n\nlp.next = function () {\n  this.last = this.tok;\n\n  if (this.ahead.length) {\n    this.tok = this.ahead.shift();\n  } else {\n    this.tok = this.readToken();\n  }\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart;\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    }\n\n    this.curIndent = this.indentationAfter(this.curLineStart);\n  }\n};\n\nlp.readToken = function () {\n  for (;;) {\n    try {\n      this.toks.next();\n\n      if (this.toks.type === _acorn.tokTypes.dot && this.input.substr(this.toks.end, 1) === \".\" && this.options.ecmaVersion >= 6) {\n        this.toks.end++;\n        this.toks.type = _acorn.tokTypes.ellipsis;\n      }\n\n      return new _acorn.Token(this.toks);\n    } catch (e) {\n      if (!(e instanceof SyntaxError)) {\n        throw e;\n      } // Try to skip some text, based on the error message, and then continue\n\n\n      var msg = e.message,\n          pos = e.raisedAt,\n          replace = true;\n\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1);\n\n        if (/string/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: _acorn.tokTypes.string,\n            value: this.input.slice(e.pos + 1, pos)\n          };\n        } else if (/regular expr/i.test(msg)) {\n          var re = this.input.slice(e.pos, pos);\n\n          try {\n            re = new RegExp(re);\n          } catch (e) {\n            /* ignore compilation error due to new syntax */\n          }\n\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: _acorn.tokTypes.regexp,\n            value: re\n          };\n        } else if (/template/.test(msg)) {\n          replace = {\n            start: e.pos,\n            end: pos,\n            type: _acorn.tokTypes.template,\n            value: this.input.slice(e.pos, pos)\n          };\n        } else {\n          replace = false;\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) {\n          ++pos;\n        }\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          var ch = this.input.charCodeAt(pos++);\n\n          if (ch === 34 || ch === 39 || (0, _acorn.isNewLine)(ch)) {\n            break;\n          }\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++;\n        replace = false;\n      } else if (/regular expression/i.test(msg)) {\n        replace = true;\n      } else {\n        throw e;\n      }\n\n      this.resetTo(pos);\n\n      if (replace === true) {\n        replace = {\n          start: pos,\n          end: pos,\n          type: _acorn.tokTypes.name,\n          value: \"\"\n        };\n      }\n\n      if (replace) {\n        if (this.options.locations) {\n          replace.loc = new _acorn.SourceLocation(this.toks, (0, _acorn.getLineInfo)(this.input, replace.start), (0, _acorn.getLineInfo)(this.input, replace.end));\n        }\n\n        return replace;\n      }\n    }\n  }\n};\n\nlp.resetTo = function (pos) {\n  this.toks.pos = pos;\n  var ch = this.input.charAt(pos - 1);\n  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n  if (this.options.locations) {\n    this.toks.curLine = 1;\n    this.toks.lineStart = _acorn.lineBreakG.lastIndex = 0;\n    var match;\n\n    while ((match = _acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine;\n      this.toks.lineStart = match.index + match[0].length;\n    }\n  }\n};\n\nlp.lookAhead = function (n) {\n  while (n > this.ahead.length) {\n    this.ahead.push(this.readToken());\n  }\n\n  return this.ahead[n - 1];\n};\n\nfunction isDummy(node) {\n  return node.name === \"\";\n}\n\nvar lp$1 = LooseParser.prototype;\n\nlp$1.parseTopLevel = function () {\n  var node = this.startNodeAt(this.options.locations ? [0, (0, _acorn.getLineInfo)(this.input, 0)] : 0);\n  node.body = [];\n\n  while (this.tok.type !== _acorn.tokTypes.eof) {\n    node.body.push(this.parseStatement());\n  }\n\n  this.toks.adaptDirectivePrologue(node.body);\n  this.last = this.tok;\n\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n\n  return this.finishNode(node, \"Program\");\n};\n\nlp$1.parseStatement = function () {\n  var starttype = this.tok.type,\n      node = this.startNode(),\n      kind;\n\n  if (this.toks.isLet()) {\n    starttype = _acorn.tokTypes._var;\n    kind = \"let\";\n  }\n\n  switch (starttype) {\n    case _acorn.tokTypes._break:\n    case _acorn.tokTypes._continue:\n      this.next();\n      var isBreak = starttype === _acorn.tokTypes._break;\n\n      if (this.semicolon() || this.canInsertSemicolon()) {\n        node.label = null;\n      } else {\n        node.label = this.tok.type === _acorn.tokTypes.name ? this.parseIdent() : null;\n        this.semicolon();\n      }\n\n      return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n    case _acorn.tokTypes._debugger:\n      this.next();\n      this.semicolon();\n      return this.finishNode(node, \"DebuggerStatement\");\n\n    case _acorn.tokTypes._do:\n      this.next();\n      node.body = this.parseStatement();\n      node.test = this.eat(_acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n      this.semicolon();\n      return this.finishNode(node, \"DoWhileStatement\");\n\n    case _acorn.tokTypes._for:\n      this.next(); // `for` keyword\n\n      var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n      this.pushCx();\n      this.expect(_acorn.tokTypes.parenL);\n\n      if (this.tok.type === _acorn.tokTypes.semi) {\n        return this.parseFor(node, null);\n      }\n\n      var isLet = this.toks.isLet();\n\n      if (isLet || this.tok.type === _acorn.tokTypes._var || this.tok.type === _acorn.tokTypes._const) {\n        var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n\n        if (init$1.declarations.length === 1 && (this.tok.type === _acorn.tokTypes._in || this.isContextual(\"of\"))) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== _acorn.tokTypes._in) {\n            node.await = isAwait;\n          }\n\n          return this.parseForIn(node, init$1);\n        }\n\n        return this.parseFor(node, init$1);\n      }\n\n      var init = this.parseExpression(true);\n\n      if (this.tok.type === _acorn.tokTypes._in || this.isContextual(\"of\")) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== _acorn.tokTypes._in) {\n          node.await = isAwait;\n        }\n\n        return this.parseForIn(node, this.toAssignable(init));\n      }\n\n      return this.parseFor(node, init);\n\n    case _acorn.tokTypes._function:\n      this.next();\n      return this.parseFunction(node, true);\n\n    case _acorn.tokTypes._if:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.consequent = this.parseStatement();\n      node.alternate = this.eat(_acorn.tokTypes._else) ? this.parseStatement() : null;\n      return this.finishNode(node, \"IfStatement\");\n\n    case _acorn.tokTypes._return:\n      this.next();\n\n      if (this.eat(_acorn.tokTypes.semi) || this.canInsertSemicolon()) {\n        node.argument = null;\n      } else {\n        node.argument = this.parseExpression();\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ReturnStatement\");\n\n    case _acorn.tokTypes._switch:\n      var blockIndent = this.curIndent,\n          line = this.curLineStart;\n      this.next();\n      node.discriminant = this.parseParenExpression();\n      node.cases = [];\n      this.pushCx();\n      this.expect(_acorn.tokTypes.braceL);\n      var cur;\n\n      while (!this.closes(_acorn.tokTypes.braceR, blockIndent, line, true)) {\n        if (this.tok.type === _acorn.tokTypes._case || this.tok.type === _acorn.tokTypes._default) {\n          var isCase = this.tok.type === _acorn.tokTypes._case;\n\n          if (cur) {\n            this.finishNode(cur, \"SwitchCase\");\n          }\n\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          this.next();\n\n          if (isCase) {\n            cur.test = this.parseExpression();\n          } else {\n            cur.test = null;\n          }\n\n          this.expect(_acorn.tokTypes.colon);\n        } else {\n          if (!cur) {\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            cur.test = null;\n          }\n\n          cur.consequent.push(this.parseStatement());\n        }\n      }\n\n      if (cur) {\n        this.finishNode(cur, \"SwitchCase\");\n      }\n\n      this.popCx();\n      this.eat(_acorn.tokTypes.braceR);\n      return this.finishNode(node, \"SwitchStatement\");\n\n    case _acorn.tokTypes._throw:\n      this.next();\n      node.argument = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ThrowStatement\");\n\n    case _acorn.tokTypes._try:\n      this.next();\n      node.block = this.parseBlock();\n      node.handler = null;\n\n      if (this.tok.type === _acorn.tokTypes._catch) {\n        var clause = this.startNode();\n        this.next();\n\n        if (this.eat(_acorn.tokTypes.parenL)) {\n          clause.param = this.toAssignable(this.parseExprAtom(), true);\n          this.expect(_acorn.tokTypes.parenR);\n        } else {\n          clause.param = null;\n        }\n\n        clause.body = this.parseBlock();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n      }\n\n      node.finalizer = this.eat(_acorn.tokTypes._finally) ? this.parseBlock() : null;\n\n      if (!node.handler && !node.finalizer) {\n        return node.block;\n      }\n\n      return this.finishNode(node, \"TryStatement\");\n\n    case _acorn.tokTypes._var:\n    case _acorn.tokTypes._const:\n      return this.parseVar(node, false, kind || this.tok.value);\n\n    case _acorn.tokTypes._while:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WhileStatement\");\n\n    case _acorn.tokTypes._with:\n      this.next();\n      node.object = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WithStatement\");\n\n    case _acorn.tokTypes.braceL:\n      return this.parseBlock();\n\n    case _acorn.tokTypes.semi:\n      this.next();\n      return this.finishNode(node, \"EmptyStatement\");\n\n    case _acorn.tokTypes._class:\n      return this.parseClass(true);\n\n    case _acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === _acorn.tokTypes.parenL) {\n        node.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n      }\n\n      return this.parseImport();\n\n    case _acorn.tokTypes._export:\n      return this.parseExport();\n\n    default:\n      if (this.toks.isAsyncFunction()) {\n        this.next();\n        this.next();\n        return this.parseFunction(node, true, true);\n      }\n\n      var expr = this.parseExpression();\n\n      if (isDummy(expr)) {\n        this.next();\n\n        if (this.tok.type === _acorn.tokTypes.eof) {\n          return this.finishNode(node, \"EmptyStatement\");\n        }\n\n        return this.parseStatement();\n      } else if (starttype === _acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(_acorn.tokTypes.colon)) {\n        node.body = this.parseStatement();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\");\n      } else {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\");\n      }\n\n  }\n};\n\nlp$1.parseBlock = function () {\n  var node = this.startNode();\n  this.pushCx();\n  this.expect(_acorn.tokTypes.braceL);\n  var blockIndent = this.curIndent,\n      line = this.curLineStart;\n  node.body = [];\n\n  while (!this.closes(_acorn.tokTypes.braceR, blockIndent, line, true)) {\n    node.body.push(this.parseStatement());\n  }\n\n  this.popCx();\n  this.eat(_acorn.tokTypes.braceR);\n  return this.finishNode(node, \"BlockStatement\");\n};\n\nlp$1.parseFor = function (node, init) {\n  node.init = init;\n  node.test = node.update = null;\n\n  if (this.eat(_acorn.tokTypes.semi) && this.tok.type !== _acorn.tokTypes.semi) {\n    node.test = this.parseExpression();\n  }\n\n  if (this.eat(_acorn.tokTypes.semi) && this.tok.type !== _acorn.tokTypes.parenR) {\n    node.update = this.parseExpression();\n  }\n\n  this.popCx();\n  this.expect(_acorn.tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, \"ForStatement\");\n};\n\nlp$1.parseForIn = function (node, init) {\n  var type = this.tok.type === _acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  node.left = init;\n  node.right = this.parseExpression();\n  this.popCx();\n  this.expect(_acorn.tokTypes.parenR);\n  node.body = this.parseStatement();\n  return this.finishNode(node, type);\n};\n\nlp$1.parseVar = function (node, noIn, kind) {\n  node.kind = kind;\n  this.next();\n  node.declarations = [];\n\n  do {\n    var decl = this.startNode();\n    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n    decl.init = this.eat(_acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n  } while (this.eat(_acorn.tokTypes.comma));\n\n  if (!node.declarations.length) {\n    var decl$1 = this.startNode();\n    decl$1.id = this.dummyIdent();\n    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n  }\n\n  if (!noIn) {\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\nlp$1.parseClass = function (isStatement) {\n  var node = this.startNode();\n  this.next();\n\n  if (this.tok.type === _acorn.tokTypes.name) {\n    node.id = this.parseIdent();\n  } else if (isStatement === true) {\n    node.id = this.dummyIdent();\n  } else {\n    node.id = null;\n  }\n\n  node.superClass = this.eat(_acorn.tokTypes._extends) ? this.parseExpression() : null;\n  node.body = this.startNode();\n  node.body.body = [];\n  this.pushCx();\n  var indent = this.curIndent + 1,\n      line = this.curLineStart;\n  this.eat(_acorn.tokTypes.braceL);\n\n  if (this.curIndent + 1 < indent) {\n    indent = this.curIndent;\n    line = this.curLineStart;\n  }\n\n  while (!this.closes(_acorn.tokTypes.braceR, indent, line)) {\n    if (this.semicolon()) {\n      continue;\n    }\n\n    var method = this.startNode(),\n        isGenerator = void 0,\n        isAsync = void 0;\n\n    if (this.options.ecmaVersion >= 6) {\n      method.static = false;\n      isGenerator = this.eat(_acorn.tokTypes.star);\n    }\n\n    this.parsePropertyName(method);\n\n    if (isDummy(method.key)) {\n      if (isDummy(this.parseMaybeAssign())) {\n        this.next();\n      }\n\n      this.eat(_acorn.tokTypes.comma);\n      continue;\n    }\n\n    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" && this.tok.type !== _acorn.tokTypes.parenL && this.tok.type !== _acorn.tokTypes.braceL) {\n      method.static = true;\n      isGenerator = this.eat(_acorn.tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      method.static = false;\n    }\n\n    if (!method.computed && method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== _acorn.tokTypes.parenL && !this.canInsertSemicolon()) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(_acorn.tokTypes.star);\n      this.parsePropertyName(method);\n    } else {\n      isAsync = false;\n    }\n\n    if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" && !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") && this.tok.type !== _acorn.tokTypes.parenL && this.tok.type !== _acorn.tokTypes.braceL) {\n      method.kind = method.key.name;\n      this.parsePropertyName(method);\n      method.value = this.parseMethod(false);\n    } else {\n      if (!method.computed && !method.static && !isGenerator && !isAsync && (method.key.type === \"Identifier\" && method.key.name === \"constructor\" || method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n        method.kind = \"constructor\";\n      } else {\n        method.kind = \"method\";\n      }\n\n      method.value = this.parseMethod(isGenerator, isAsync);\n    }\n\n    node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n  }\n\n  this.popCx();\n\n  if (!this.eat(_acorn.tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n\n    if (this.options.locations) {\n      this.last.loc.end = this.tok.loc.start;\n    }\n  }\n\n  this.semicolon();\n  this.finishNode(node.body, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\nlp$1.parseFunction = function (node, isStatement, isAsync) {\n  var oldInAsync = this.inAsync,\n      oldInFunction = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = this.eat(_acorn.tokTypes.star);\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  if (this.tok.type === _acorn.tokTypes.name) {\n    node.id = this.parseIdent();\n  } else if (isStatement === true) {\n    node.id = this.dummyIdent();\n  }\n\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\nlp$1.parseExport = function () {\n  var node = this.startNode();\n  this.next();\n\n  if (this.eat(_acorn.tokTypes.star)) {\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n\n  if (this.eat(_acorn.tokTypes._default)) {\n    // export default (function foo() {}) // This is FunctionExpression.\n    var isAsync;\n\n    if (this.tok.type === _acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n    } else if (this.tok.type === _acorn.tokTypes._class) {\n      node.declaration = this.parseClass(\"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  }\n\n  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n    node.declaration = this.parseStatement();\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifierList();\n    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\nlp$1.parseImport = function () {\n  var node = this.startNode();\n  this.next();\n\n  if (this.tok.type === _acorn.tokTypes.string) {\n    node.specifiers = [];\n    node.source = this.parseExprAtom();\n  } else {\n    var elt;\n\n    if (this.tok.type === _acorn.tokTypes.name && this.tok.value !== \"from\") {\n      elt = this.startNode();\n      elt.local = this.parseIdent();\n      this.finishNode(elt, \"ImportDefaultSpecifier\");\n      this.eat(_acorn.tokTypes.comma);\n    }\n\n    node.specifiers = this.parseImportSpecifiers();\n    node.source = this.eatContextual(\"from\") && this.tok.type === _acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n\n    if (elt) {\n      node.specifiers.unshift(elt);\n    }\n  }\n\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\nlp$1.parseImportSpecifiers = function () {\n  var elts = [];\n\n  if (this.tok.type === _acorn.tokTypes.star) {\n    var elt = this.startNode();\n    this.next();\n    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n  } else {\n    var indent = this.curIndent,\n        line = this.curLineStart,\n        continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(_acorn.tokTypes.braceL);\n\n    if (this.curLineStart > continuedLine) {\n      continuedLine = this.curLineStart;\n    }\n\n    while (!this.closes(_acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      var elt$1 = this.startNode();\n\n      if (this.eat(_acorn.tokTypes.star)) {\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n        this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n      } else {\n        if (this.isContextual(\"from\")) {\n          break;\n        }\n\n        elt$1.imported = this.parseIdent();\n\n        if (isDummy(elt$1.imported)) {\n          break;\n        }\n\n        elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n        this.finishNode(elt$1, \"ImportSpecifier\");\n      }\n\n      elts.push(elt$1);\n      this.eat(_acorn.tokTypes.comma);\n    }\n\n    this.eat(_acorn.tokTypes.braceR);\n    this.popCx();\n  }\n\n  return elts;\n};\n\nlp$1.parseExportSpecifierList = function () {\n  var elts = [];\n  var indent = this.curIndent,\n      line = this.curLineStart,\n      continuedLine = this.nextLineStart;\n  this.pushCx();\n  this.eat(_acorn.tokTypes.braceL);\n\n  if (this.curLineStart > continuedLine) {\n    continuedLine = this.curLineStart;\n  }\n\n  while (!this.closes(_acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n    if (this.isContextual(\"from\")) {\n      break;\n    }\n\n    var elt = this.startNode();\n    elt.local = this.parseIdent();\n\n    if (isDummy(elt.local)) {\n      break;\n    }\n\n    elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n    this.finishNode(elt, \"ExportSpecifier\");\n    elts.push(elt);\n    this.eat(_acorn.tokTypes.comma);\n  }\n\n  this.eat(_acorn.tokTypes.braceR);\n  this.popCx();\n  return elts;\n};\n\nvar lp$2 = LooseParser.prototype;\n\nlp$2.checkLVal = function (expr) {\n  if (!expr) {\n    return expr;\n  }\n\n  switch (expr.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n      return expr;\n\n    case \"ParenthesizedExpression\":\n      expr.expression = this.checkLVal(expr.expression);\n      return expr;\n\n    default:\n      return this.dummyIdent();\n  }\n};\n\nlp$2.parseExpression = function (noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseMaybeAssign(noIn);\n\n  if (this.tok.type === _acorn.tokTypes.comma) {\n    var node = this.startNodeAt(start);\n    node.expressions = [expr];\n\n    while (this.eat(_acorn.tokTypes.comma)) {\n      node.expressions.push(this.parseMaybeAssign(noIn));\n    }\n\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n\n  return expr;\n};\n\nlp$2.parseParenExpression = function () {\n  this.pushCx();\n  this.expect(_acorn.tokTypes.parenL);\n  var val = this.parseExpression();\n  this.popCx();\n  this.expect(_acorn.tokTypes.parenR);\n  return val;\n};\n\nlp$2.parseMaybeAssign = function (noIn) {\n  if (this.toks.isContextual(\"yield\")) {\n    var node = this.startNode();\n    this.next();\n\n    if (this.semicolon() || this.canInsertSemicolon() || this.tok.type !== _acorn.tokTypes.star && !this.tok.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(_acorn.tokTypes.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  var start = this.storeCurrentPos();\n  var left = this.parseMaybeConditional(noIn);\n\n  if (this.tok.type.isAssign) {\n    var node$1 = this.startNodeAt(start);\n    node$1.operator = this.tok.value;\n    node$1.left = this.tok.type === _acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n    this.next();\n    node$1.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node$1, \"AssignmentExpression\");\n  }\n\n  return left;\n};\n\nlp$2.parseMaybeConditional = function (noIn) {\n  var start = this.storeCurrentPos();\n  var expr = this.parseExprOps(noIn);\n\n  if (this.eat(_acorn.tokTypes.question)) {\n    var node = this.startNodeAt(start);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    node.alternate = this.expect(_acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  return expr;\n};\n\nlp$2.parseExprOps = function (noIn) {\n  var start = this.storeCurrentPos();\n  var indent = this.curIndent,\n      line = this.curLineStart;\n  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);\n};\n\nlp$2.parseExprOp = function (left, start, minPrec, noIn, indent, line) {\n  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n    return left;\n  }\n\n  var prec = this.tok.type.binop;\n\n  if (prec != null && (!noIn || this.tok.type !== _acorn.tokTypes._in)) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(start);\n      node.left = left;\n      node.operator = this.tok.value;\n      this.next();\n\n      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n        node.right = this.dummyIdent();\n      } else {\n        var rightStart = this.storeCurrentPos();\n        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n      }\n\n      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, start, minPrec, noIn, indent, line);\n    }\n  }\n\n  return left;\n};\n\nlp$2.parseMaybeUnary = function (sawUnary) {\n  var start = this.storeCurrentPos(),\n      expr;\n\n  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.tok.type.prefix) {\n    var node = this.startNode(),\n        update = this.tok.type === _acorn.tokTypes.incDec;\n\n    if (!update) {\n      sawUnary = true;\n    }\n\n    node.operator = this.tok.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(true);\n\n    if (update) {\n      node.argument = this.checkLVal(node.argument);\n    }\n\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (this.tok.type === _acorn.tokTypes.ellipsis) {\n    var node$1 = this.startNode();\n    this.next();\n    node$1.argument = this.parseMaybeUnary(sawUnary);\n    expr = this.finishNode(node$1, \"SpreadElement\");\n  } else {\n    expr = this.parseExprSubscripts();\n\n    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n      var node$2 = this.startNodeAt(start);\n      node$2.operator = this.tok.value;\n      node$2.prefix = false;\n      node$2.argument = this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$2, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(_acorn.tokTypes.starstar)) {\n    var node$3 = this.startNodeAt(start);\n    node$3.operator = \"**\";\n    node$3.left = expr;\n    node$3.right = this.parseMaybeUnary(false);\n    return this.finishNode(node$3, \"BinaryExpression\");\n  }\n\n  return expr;\n};\n\nlp$2.parseExprSubscripts = function () {\n  var start = this.storeCurrentPos();\n  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);\n};\n\nlp$2.parseSubscripts = function (base, start, noCalls, startIndent, line) {\n  for (;;) {\n    if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n      if (this.tok.type === _acorn.tokTypes.dot && this.curIndent === startIndent) {\n        --startIndent;\n      } else {\n        return base;\n      }\n    }\n\n    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n    if (this.eat(_acorn.tokTypes.dot)) {\n      var node = this.startNodeAt(start);\n      node.object = base;\n\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        node.property = this.dummyIdent();\n      } else {\n        node.property = this.parsePropertyAccessor() || this.dummyIdent();\n      }\n\n      node.computed = false;\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (this.tok.type === _acorn.tokTypes.bracketL) {\n      this.pushCx();\n      this.next();\n      var node$1 = this.startNodeAt(start);\n      node$1.object = base;\n      node$1.property = this.parseExpression();\n      node$1.computed = true;\n      this.popCx();\n      this.expect(_acorn.tokTypes.bracketR);\n      base = this.finishNode(node$1, \"MemberExpression\");\n    } else if (!noCalls && this.tok.type === _acorn.tokTypes.parenL) {\n      var exprList = this.parseExprList(_acorn.tokTypes.parenR);\n\n      if (maybeAsyncArrow && this.eat(_acorn.tokTypes.arrow)) {\n        return this.parseArrowExpression(this.startNodeAt(start), exprList, true);\n      }\n\n      var node$2 = this.startNodeAt(start);\n      node$2.callee = base;\n      node$2.arguments = exprList;\n      base = this.finishNode(node$2, \"CallExpression\");\n    } else if (this.tok.type === _acorn.tokTypes.backQuote) {\n      var node$3 = this.startNodeAt(start);\n      node$3.tag = base;\n      node$3.quasi = this.parseTemplate();\n      base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\nlp$2.parseExprAtom = function () {\n  var node;\n\n  switch (this.tok.type) {\n    case _acorn.tokTypes._this:\n    case _acorn.tokTypes._super:\n      var type = this.tok.type === _acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type);\n\n    case _acorn.tokTypes.name:\n      var start = this.storeCurrentPos();\n      var id = this.parseIdent();\n      var isAsync = false;\n\n      if (id.name === \"async\" && !this.canInsertSemicolon()) {\n        if (this.eat(_acorn.tokTypes._function)) {\n          return this.parseFunction(this.startNodeAt(start), false, true);\n        }\n\n        if (this.tok.type === _acorn.tokTypes.name) {\n          id = this.parseIdent();\n          isAsync = true;\n        }\n      }\n\n      return this.eat(_acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id;\n\n    case _acorn.tokTypes.regexp:\n      node = this.startNode();\n      var val = this.tok.value;\n      node.regex = {\n        pattern: val.pattern,\n        flags: val.flags\n      };\n      node.value = val.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case _acorn.tokTypes.num:\n    case _acorn.tokTypes.string:\n      node = this.startNode();\n      node.value = this.tok.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n\n      if (this.tok.type === _acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) {\n        node.bigint = node.raw.slice(0, -1);\n      }\n\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case _acorn.tokTypes._null:\n    case _acorn.tokTypes._true:\n    case _acorn.tokTypes._false:\n      node = this.startNode();\n      node.value = this.tok.type === _acorn.tokTypes._null ? null : this.tok.type === _acorn.tokTypes._true;\n      node.raw = this.tok.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case _acorn.tokTypes.parenL:\n      var parenStart = this.storeCurrentPos();\n      this.next();\n      var inner = this.parseExpression();\n      this.expect(_acorn.tokTypes.parenR);\n\n      if (this.eat(_acorn.tokTypes.arrow)) {\n        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n        var params = inner.expressions || [inner];\n\n        if (params.length && isDummy(params[params.length - 1])) {\n          params.pop();\n        }\n\n        return this.parseArrowExpression(this.startNodeAt(parenStart), params);\n      }\n\n      if (this.options.preserveParens) {\n        var par = this.startNodeAt(parenStart);\n        par.expression = inner;\n        inner = this.finishNode(par, \"ParenthesizedExpression\");\n      }\n\n      return inner;\n\n    case _acorn.tokTypes.bracketL:\n      node = this.startNode();\n      node.elements = this.parseExprList(_acorn.tokTypes.bracketR, true);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case _acorn.tokTypes.braceL:\n      return this.parseObj();\n\n    case _acorn.tokTypes._class:\n      return this.parseClass(false);\n\n    case _acorn.tokTypes._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false);\n\n    case _acorn.tokTypes._new:\n      return this.parseNew();\n\n    case _acorn.tokTypes.backQuote:\n      return this.parseTemplate();\n\n    case _acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport();\n      } else {\n        return this.dummyIdent();\n      }\n\n    default:\n      return this.dummyIdent();\n  }\n};\n\nlp$2.parseDynamicImport = function () {\n  var node = this.startNode();\n  this.next();\n  return this.finishNode(node, \"Import\");\n};\n\nlp$2.parseNew = function () {\n  var node = this.startNode(),\n      startIndent = this.curIndent,\n      line = this.curLineStart;\n  var meta = this.parseIdent(true);\n\n  if (this.options.ecmaVersion >= 6 && this.eat(_acorn.tokTypes.dot)) {\n    node.meta = meta;\n    node.property = this.parseIdent(true);\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  var start = this.storeCurrentPos();\n  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n\n  if (this.tok.type === _acorn.tokTypes.parenL) {\n    node.arguments = this.parseExprList(_acorn.tokTypes.parenR);\n  } else {\n    node.arguments = [];\n  }\n\n  return this.finishNode(node, \"NewExpression\");\n};\n\nlp$2.parseTemplateElement = function () {\n  var elem = this.startNode(); // The loose parser accepts invalid unicode escapes even in untagged templates.\n\n  if (this.tok.type === _acorn.tokTypes.invalidTemplate) {\n    elem.value = {\n      raw: this.tok.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.tok.value\n    };\n  }\n\n  this.next();\n  elem.tail = this.tok.type === _acorn.tokTypes.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\nlp$2.parseTemplate = function () {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement();\n  node.quasis = [curElt];\n\n  while (!curElt.tail) {\n    this.next();\n    node.expressions.push(this.parseExpression());\n\n    if (this.expect(_acorn.tokTypes.braceR)) {\n      curElt = this.parseTemplateElement();\n    } else {\n      curElt = this.startNode();\n      curElt.value = {\n        cooked: \"\",\n        raw: \"\"\n      };\n      curElt.tail = true;\n      this.finishNode(curElt, \"TemplateElement\");\n    }\n\n    node.quasis.push(curElt);\n  }\n\n  this.expect(_acorn.tokTypes.backQuote);\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\nlp$2.parseObj = function () {\n  var node = this.startNode();\n  node.properties = [];\n  this.pushCx();\n  var indent = this.curIndent + 1,\n      line = this.curLineStart;\n  this.eat(_acorn.tokTypes.braceL);\n\n  if (this.curIndent + 1 < indent) {\n    indent = this.curIndent;\n    line = this.curLineStart;\n  }\n\n  while (!this.closes(_acorn.tokTypes.braceR, indent, line)) {\n    var prop = this.startNode(),\n        isGenerator = void 0,\n        isAsync = void 0,\n        start = void 0;\n\n    if (this.options.ecmaVersion >= 9 && this.eat(_acorn.tokTypes.ellipsis)) {\n      prop.argument = this.parseMaybeAssign();\n      node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n      this.eat(_acorn.tokTypes.comma);\n      continue;\n    }\n\n    if (this.options.ecmaVersion >= 6) {\n      start = this.storeCurrentPos();\n      prop.method = false;\n      prop.shorthand = false;\n      isGenerator = this.eat(_acorn.tokTypes.star);\n    }\n\n    this.parsePropertyName(prop);\n\n    if (this.toks.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(_acorn.tokTypes.star);\n      this.parsePropertyName(prop);\n    } else {\n      isAsync = false;\n    }\n\n    if (isDummy(prop.key)) {\n      if (isDummy(this.parseMaybeAssign())) {\n        this.next();\n      }\n\n      this.eat(_acorn.tokTypes.comma);\n      continue;\n    }\n\n    if (this.eat(_acorn.tokTypes.colon)) {\n      prop.kind = \"init\";\n      prop.value = this.parseMaybeAssign();\n    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _acorn.tokTypes.parenL || this.tok.type === _acorn.tokTypes.braceL)) {\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" && !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.tok.type !== _acorn.tokTypes.comma && this.tok.type !== _acorn.tokTypes.braceR && this.tok.type !== _acorn.tokTypes.eq) {\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n    } else {\n      prop.kind = \"init\";\n\n      if (this.options.ecmaVersion >= 6) {\n        if (this.eat(_acorn.tokTypes.eq)) {\n          var assign = this.startNodeAt(start);\n          assign.operator = \"=\";\n          assign.left = prop.key;\n          assign.right = this.parseMaybeAssign();\n          prop.value = this.finishNode(assign, \"AssignmentExpression\");\n        } else {\n          prop.value = prop.key;\n        }\n      } else {\n        prop.value = this.dummyIdent();\n      }\n\n      prop.shorthand = true;\n    }\n\n    node.properties.push(this.finishNode(prop, \"Property\"));\n    this.eat(_acorn.tokTypes.comma);\n  }\n\n  this.popCx();\n\n  if (!this.eat(_acorn.tokTypes.braceR)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n\n    if (this.options.locations) {\n      this.last.loc.end = this.tok.loc.start;\n    }\n  }\n\n  return this.finishNode(node, \"ObjectExpression\");\n};\n\nlp$2.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(_acorn.tokTypes.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseExpression();\n      this.expect(_acorn.tokTypes.bracketR);\n      return;\n    } else {\n      prop.computed = false;\n    }\n  }\n\n  var key = this.tok.type === _acorn.tokTypes.num || this.tok.type === _acorn.tokTypes.string ? this.parseExprAtom() : this.parseIdent();\n  prop.key = key || this.dummyIdent();\n};\n\nlp$2.parsePropertyAccessor = function () {\n  if (this.tok.type === _acorn.tokTypes.name || this.tok.type.keyword) {\n    return this.parseIdent();\n  }\n};\n\nlp$2.parseIdent = function () {\n  var name = this.tok.type === _acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n\n  if (!name) {\n    return this.dummyIdent();\n  }\n\n  var node = this.startNode();\n  this.next();\n  node.name = name;\n  return this.finishNode(node, \"Identifier\");\n};\n\nlp$2.initFunction = function (node) {\n  node.id = null;\n  node.params = [];\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = false;\n  }\n}; // Convert existing expression atom to assignable pattern\n// if possible.\n\n\nlp$2.toAssignable = function (node, binding) {\n  if (!node || node.type === \"Identifier\" || node.type === \"MemberExpression\" && !binding) ;else if (node.type === \"ParenthesizedExpression\") {\n    this.toAssignable(node.expression, binding);\n  } else if (this.options.ecmaVersion < 6) {\n    return this.dummyIdent();\n  } else if (node.type === \"ObjectExpression\") {\n    node.type = \"ObjectPattern\";\n\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      this.toAssignable(prop, binding);\n    }\n  } else if (node.type === \"ArrayExpression\") {\n    node.type = \"ArrayPattern\";\n    this.toAssignableList(node.elements, binding);\n  } else if (node.type === \"Property\") {\n    this.toAssignable(node.value, binding);\n  } else if (node.type === \"SpreadElement\") {\n    node.type = \"RestElement\";\n    this.toAssignable(node.argument, binding);\n  } else if (node.type === \"AssignmentExpression\") {\n    node.type = \"AssignmentPattern\";\n    delete node.operator;\n  } else {\n    return this.dummyIdent();\n  }\n  return node;\n};\n\nlp$2.toAssignableList = function (exprList, binding) {\n  for (var i = 0, list = exprList; i < list.length; i += 1) {\n    var expr = list[i];\n    this.toAssignable(expr, binding);\n  }\n\n  return exprList;\n};\n\nlp$2.parseFunctionParams = function (params) {\n  params = this.parseExprList(_acorn.tokTypes.parenR);\n  return this.toAssignableList(params, true);\n};\n\nlp$2.parseMethod = function (isGenerator, isAsync) {\n  var node = this.startNode(),\n      oldInAsync = this.inAsync,\n      oldInFunction = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = !!isGenerator;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.parseFunctionParams();\n  node.body = this.parseBlock();\n  this.toks.adaptDirectivePrologue(node.body.body);\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"FunctionExpression\");\n};\n\nlp$2.parseArrowExpression = function (node, params, isAsync) {\n  var oldInAsync = this.inAsync,\n      oldInFunction = this.inFunction;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.inAsync = node.async;\n  this.inFunction = true;\n  node.params = this.toAssignableList(params, true);\n  node.expression = this.tok.type !== _acorn.tokTypes.braceL;\n\n  if (node.expression) {\n    node.body = this.parseMaybeAssign();\n  } else {\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n  }\n\n  this.inAsync = oldInAsync;\n  this.inFunction = oldInFunction;\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\nlp$2.parseExprList = function (close, allowEmpty) {\n  this.pushCx();\n  var indent = this.curIndent,\n      line = this.curLineStart,\n      elts = [];\n  this.next(); // Opening bracket\n\n  while (!this.closes(close, indent + 1, line)) {\n    if (this.eat(_acorn.tokTypes.comma)) {\n      elts.push(allowEmpty ? null : this.dummyIdent());\n      continue;\n    }\n\n    var elt = this.parseMaybeAssign();\n\n    if (isDummy(elt)) {\n      if (this.closes(close, indent, line)) {\n        break;\n      }\n\n      this.next();\n    } else {\n      elts.push(elt);\n    }\n\n    this.eat(_acorn.tokTypes.comma);\n  }\n\n  this.popCx();\n\n  if (!this.eat(close)) {\n    // If there is no closing brace, make the node span to the start\n    // of the next token (this is useful for Tern)\n    this.last.end = this.tok.start;\n\n    if (this.options.locations) {\n      this.last.loc.end = this.tok.loc.start;\n    }\n  }\n\n  return elts;\n};\n\nlp$2.parseAwait = function () {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary();\n  return this.finishNode(node, \"AwaitExpression\");\n}; // Acorn: Loose parser\n\n\n_acorn.defaultOptions.tabSize = 4;\n\nfunction parse(input, options) {\n  return LooseParser.parse(input, options);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4tbG9vc2UvZGlzdC9hY29ybi1sb29zZS5tanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4tbG9vc2UvZGlzdC9hY29ybi1sb29zZS5tanM/MjhlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b2tUeXBlcywgU291cmNlTG9jYXRpb24sIE5vZGUsIGxpbmVCcmVhaywgaXNOZXdMaW5lLCBQYXJzZXIsIFRva2VuLCBnZXRMaW5lSW5mbywgbGluZUJyZWFrRywgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICdhY29ybic7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgTG9vc2VQYXJzZXIgPSBmdW5jdGlvbiBMb29zZVBhcnNlcihpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLnRva3MgPSB0aGlzLmNvbnN0cnVjdG9yLkJhc2VQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gdGhpcy50b2tzLm9wdGlvbnM7XG4gIHRoaXMuaW5wdXQgPSB0aGlzLnRva3MuaW5wdXQ7XG4gIHRoaXMudG9rID0gdGhpcy5sYXN0ID0ge3R5cGU6IHRva1R5cGVzLmVvZiwgc3RhcnQ6IDAsIGVuZDogMH07XG4gIHRoaXMudG9rLnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBub29wO1xuICB0aGlzLnRvay52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBub29wO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIHZhciBoZXJlID0gdGhpcy50b2tzLmN1clBvc2l0aW9uKCk7XG4gICAgdGhpcy50b2subG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMudG9rcywgaGVyZSwgaGVyZSk7XG4gIH1cbiAgdGhpcy5haGVhZCA9IFtdOyAvLyBUb2tlbnMgYWhlYWRcbiAgdGhpcy5jb250ZXh0ID0gW107IC8vIEluZGVudGF0aW9uIGNvbnRleHRlZFxuICB0aGlzLmN1ckluZGVudCA9IDA7XG4gIHRoaXMuY3VyTGluZVN0YXJ0ID0gMDtcbiAgdGhpcy5uZXh0TGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kKHRoaXMuY3VyTGluZVN0YXJ0KSArIDE7XG4gIHRoaXMuaW5Bc3luYyA9IGZhbHNlO1xuICB0aGlzLmluRnVuY3Rpb24gPSBmYWxzZTtcbn07XG5cbkxvb3NlUGFyc2VyLnByb3RvdHlwZS5zdGFydE5vZGUgPSBmdW5jdGlvbiBzdGFydE5vZGUgKCkge1xuICByZXR1cm4gbmV3IE5vZGUodGhpcy50b2tzLCB0aGlzLnRvay5zdGFydCwgdGhpcy5vcHRpb25zLmxvY2F0aW9ucyA/IHRoaXMudG9rLmxvYy5zdGFydCA6IG51bGwpXG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuc3RvcmVDdXJyZW50UG9zID0gZnVuY3Rpb24gc3RvcmVDdXJyZW50UG9zICgpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5sb2NhdGlvbnMgPyBbdGhpcy50b2suc3RhcnQsIHRoaXMudG9rLmxvYy5zdGFydF0gOiB0aGlzLnRvay5zdGFydFxufTtcblxuTG9vc2VQYXJzZXIucHJvdG90eXBlLnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24gc3RhcnROb2RlQXQgKHBvcykge1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLnRva3MsIHBvc1swXSwgcG9zWzFdKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLnRva3MsIHBvcylcbiAgfVxufTtcblxuTG9vc2VQYXJzZXIucHJvdG90eXBlLmZpbmlzaE5vZGUgPSBmdW5jdGlvbiBmaW5pc2hOb2RlIChub2RlLCB0eXBlKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gdGhpcy5sYXN0LmVuZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyBub2RlLmxvYy5lbmQgPSB0aGlzLmxhc3QubG9jLmVuZDsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSB0aGlzLmxhc3QuZW5kOyB9XG4gIHJldHVybiBub2RlXG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuZHVtbXlOb2RlID0gZnVuY3Rpb24gZHVtbXlOb2RlICh0eXBlKSB7XG4gIHZhciBkdW1teSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGR1bW15LnR5cGUgPSB0eXBlO1xuICBkdW1teS5lbmQgPSBkdW1teS5zdGFydDtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyBkdW1teS5sb2MuZW5kID0gZHVtbXkubG9jLnN0YXJ0OyB9XG4gIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgZHVtbXkucmFuZ2VbMV0gPSBkdW1teS5zdGFydDsgfVxuICB0aGlzLmxhc3QgPSB7dHlwZTogdG9rVHlwZXMubmFtZSwgc3RhcnQ6IGR1bW15LnN0YXJ0LCBlbmQ6IGR1bW15LnN0YXJ0LCBsb2M6IGR1bW15LmxvY307XG4gIHJldHVybiBkdW1teVxufTtcblxuTG9vc2VQYXJzZXIucHJvdG90eXBlLmR1bW15SWRlbnQgPSBmdW5jdGlvbiBkdW1teUlkZW50ICgpIHtcbiAgdmFyIGR1bW15ID0gdGhpcy5kdW1teU5vZGUoXCJJZGVudGlmaWVyXCIpO1xuICBkdW1teS5uYW1lID0gXCLinJZcIjtcbiAgcmV0dXJuIGR1bW15XG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuZHVtbXlTdHJpbmcgPSBmdW5jdGlvbiBkdW1teVN0cmluZyAoKSB7XG4gIHZhciBkdW1teSA9IHRoaXMuZHVtbXlOb2RlKFwiTGl0ZXJhbFwiKTtcbiAgZHVtbXkudmFsdWUgPSBkdW1teS5yYXcgPSBcIuKcllwiO1xuICByZXR1cm4gZHVtbXlcbn07XG5cbkxvb3NlUGFyc2VyLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKHR5cGUpIHtcbiAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHR5cGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24gaXNDb250ZXh0dWFsIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5uYW1lICYmIHRoaXMudG9rLnZhbHVlID09PSBuYW1lXG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uIGVhdENvbnRleHR1YWwgKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMudG9rLnZhbHVlID09PSBuYW1lICYmIHRoaXMuZWF0KHRva1R5cGVzLm5hbWUpXG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuY2FuSW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24gY2FuSW5zZXJ0U2VtaWNvbG9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLmVvZiB8fCB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5icmFjZVIgfHxcbiAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdC5lbmQsIHRoaXMudG9rLnN0YXJ0KSlcbn07XG5cbkxvb3NlUGFyc2VyLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiBzZW1pY29sb24gKCkge1xuICByZXR1cm4gdGhpcy5lYXQodG9rVHlwZXMuc2VtaSlcbn07XG5cbkxvb3NlUGFyc2VyLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbiBleHBlY3QgKHR5cGUpIHtcbiAgaWYgKHRoaXMuZWF0KHR5cGUpKSB7IHJldHVybiB0cnVlIH1cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMjsgaSsrKSB7XG4gICAgaWYgKHRoaXMubG9va0FoZWFkKGkpLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuTG9vc2VQYXJzZXIucHJvdG90eXBlLnB1c2hDeCA9IGZ1bmN0aW9uIHB1c2hDeCAoKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuY3VySW5kZW50KTtcbn07XG5cbkxvb3NlUGFyc2VyLnByb3RvdHlwZS5wb3BDeCA9IGZ1bmN0aW9uIHBvcEN4ICgpIHtcbiAgdGhpcy5jdXJJbmRlbnQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUubGluZUVuZCA9IGZ1bmN0aW9uIGxpbmVFbmQgKHBvcykge1xuICB3aGlsZSAocG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIWlzTmV3TGluZSh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSkpIHsgKytwb3M7IH1cbiAgcmV0dXJuIHBvc1xufTtcblxuTG9vc2VQYXJzZXIucHJvdG90eXBlLmluZGVudGF0aW9uQWZ0ZXIgPSBmdW5jdGlvbiBpbmRlbnRhdGlvbkFmdGVyIChwb3MpIHtcbiAgZm9yICh2YXIgY291bnQgPSAwOzsgKytwb3MpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDMyKSB7ICsrY291bnQ7IH1cbiAgICBlbHNlIGlmIChjaCA9PT0gOSkgeyBjb3VudCArPSB0aGlzLm9wdGlvbnMudGFiU2l6ZTsgfVxuICAgIGVsc2UgeyByZXR1cm4gY291bnQgfVxuICB9XG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuY2xvc2VzID0gZnVuY3Rpb24gY2xvc2VzIChjbG9zZVRvaywgaW5kZW50LCBsaW5lLCBibG9ja0hldXJpc3RpYykge1xuICBpZiAodGhpcy50b2sudHlwZSA9PT0gY2xvc2VUb2sgfHwgdGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuZW9mKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGxpbmUgIT09IHRoaXMuY3VyTGluZVN0YXJ0ICYmIHRoaXMuY3VySW5kZW50IDwgaW5kZW50ICYmIHRoaXMudG9rZW5TdGFydHNMaW5lKCkgJiZcbiAgICAoIWJsb2NrSGV1cmlzdGljIHx8IHRoaXMubmV4dExpbmVTdGFydCA+PSB0aGlzLmlucHV0Lmxlbmd0aCB8fFxuICAgICB0aGlzLmluZGVudGF0aW9uQWZ0ZXIodGhpcy5uZXh0TGluZVN0YXJ0KSA8IGluZGVudClcbn07XG5cbkxvb3NlUGFyc2VyLnByb3RvdHlwZS50b2tlblN0YXJ0c0xpbmUgPSBmdW5jdGlvbiB0b2tlblN0YXJ0c0xpbmUgKCkge1xuICBmb3IgKHZhciBwID0gdGhpcy50b2suc3RhcnQgLSAxOyBwID49IHRoaXMuY3VyTGluZVN0YXJ0OyAtLXApIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocCk7XG4gICAgaWYgKGNoICE9PSA5ICYmIGNoICE9PSAzMikgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG5Mb29zZVBhcnNlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCBmKSB7XG4gIHRoaXNbbmFtZV0gPSBmKHRoaXNbbmFtZV0pO1xufTtcblxuTG9vc2VQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbCgpXG59O1xuXG5Mb29zZVBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKCkge1xuICAgIHZhciBwbHVnaW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICB2YXIgY2xzID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7IGNscyA9IHBsdWdpbnNbaV0oY2xzKTsgfVxuICByZXR1cm4gY2xzXG59O1xuXG5Mb29zZVBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMoaW5wdXQsIG9wdGlvbnMpLnBhcnNlKClcbn07XG5cbi8vIEFsbG93cyBwbHVnaW5zIHRvIGV4dGVuZCB0aGUgYmFzZSBwYXJzZXIgLyB0b2tlbml6ZXIgdXNlZFxuTG9vc2VQYXJzZXIuQmFzZVBhcnNlciA9IFBhcnNlcjtcblxudmFyIGxwID0gTG9vc2VQYXJzZXIucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNoKSB7XG4gIHJldHVybiAoY2ggPCAxNCAmJiBjaCA+IDgpIHx8IGNoID09PSAzMiB8fCBjaCA9PT0gMTYwIHx8IGlzTmV3TGluZShjaClcbn1cblxubHAubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxhc3QgPSB0aGlzLnRvaztcbiAgaWYgKHRoaXMuYWhlYWQubGVuZ3RoKVxuICAgIHsgdGhpcy50b2sgPSB0aGlzLmFoZWFkLnNoaWZ0KCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy50b2sgPSB0aGlzLnJlYWRUb2tlbigpOyB9XG5cbiAgaWYgKHRoaXMudG9rLnN0YXJ0ID49IHRoaXMubmV4dExpbmVTdGFydCkge1xuICAgIHdoaWxlICh0aGlzLnRvay5zdGFydCA+PSB0aGlzLm5leHRMaW5lU3RhcnQpIHtcbiAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gdGhpcy5uZXh0TGluZVN0YXJ0O1xuICAgICAgdGhpcy5uZXh0TGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kKHRoaXMuY3VyTGluZVN0YXJ0KSArIDE7XG4gICAgfVxuICAgIHRoaXMuY3VySW5kZW50ID0gdGhpcy5pbmRlbnRhdGlvbkFmdGVyKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgfVxufTtcblxubHAucmVhZFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIGZvciAoOzspIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy50b2tzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLnRva3MudHlwZSA9PT0gdG9rVHlwZXMuZG90ICYmXG4gICAgICAgICAgdGhpcy5pbnB1dC5zdWJzdHIodGhpcy50b2tzLmVuZCwgMSkgPT09IFwiLlwiICYmXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgdGhpcy50b2tzLmVuZCsrO1xuICAgICAgICB0aGlzLnRva3MudHlwZSA9IHRva1R5cGVzLmVsbGlwc2lzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzLnRva3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSkgeyB0aHJvdyBlIH1cblxuICAgICAgLy8gVHJ5IHRvIHNraXAgc29tZSB0ZXh0LCBiYXNlZCBvbiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gY29udGludWVcbiAgICAgIHZhciBtc2cgPSBlLm1lc3NhZ2UsIHBvcyA9IGUucmFpc2VkQXQsIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgaWYgKC91bnRlcm1pbmF0ZWQvaS50ZXN0KG1zZykpIHtcbiAgICAgICAgcG9zID0gdGhpcy5saW5lRW5kKGUucG9zICsgMSk7XG4gICAgICAgIGlmICgvc3RyaW5nLy50ZXN0KG1zZykpIHtcbiAgICAgICAgICByZXBsYWNlID0ge3N0YXJ0OiBlLnBvcywgZW5kOiBwb3MsIHR5cGU6IHRva1R5cGVzLnN0cmluZywgdmFsdWU6IHRoaXMuaW5wdXQuc2xpY2UoZS5wb3MgKyAxLCBwb3MpfTtcbiAgICAgICAgfSBlbHNlIGlmICgvcmVndWxhciBleHByL2kudGVzdChtc2cpKSB7XG4gICAgICAgICAgdmFyIHJlID0gdGhpcy5pbnB1dC5zbGljZShlLnBvcywgcG9zKTtcbiAgICAgICAgICB0cnkgeyByZSA9IG5ldyBSZWdFeHAocmUpOyB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSBjb21waWxhdGlvbiBlcnJvciBkdWUgdG8gbmV3IHN5bnRheCAqLyB9XG4gICAgICAgICAgcmVwbGFjZSA9IHtzdGFydDogZS5wb3MsIGVuZDogcG9zLCB0eXBlOiB0b2tUeXBlcy5yZWdleHAsIHZhbHVlOiByZX07XG4gICAgICAgIH0gZWxzZSBpZiAoL3RlbXBsYXRlLy50ZXN0KG1zZykpIHtcbiAgICAgICAgICByZXBsYWNlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGUucG9zLFxuICAgICAgICAgICAgZW5kOiBwb3MsXG4gICAgICAgICAgICB0eXBlOiB0b2tUeXBlcy50ZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlucHV0LnNsaWNlKGUucG9zLCBwb3MpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoL2ludmFsaWQgKHVuaWNvZGV8cmVnZXhwfG51bWJlcil8ZXhwZWN0aW5nIHVuaWNvZGV8b2N0YWwgbGl0ZXJhbHxpcyByZXNlcnZlZHxkaXJlY3RseSBhZnRlciBudW1iZXJ8ZXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4L2kudGVzdChtc2cpKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNTcGFjZSh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSkpIHsgKytwb3M7IH1cbiAgICAgIH0gZWxzZSBpZiAoL2NoYXJhY3RlciBlc2NhcGV8ZXhwZWN0ZWQgaGV4YWRlY2ltYWwvaS50ZXN0KG1zZykpIHtcbiAgICAgICAgd2hpbGUgKHBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgICBpZiAoY2ggPT09IDM0IHx8IGNoID09PSAzOSB8fCBpc05ld0xpbmUoY2gpKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgvdW5leHBlY3RlZCBjaGFyYWN0ZXIvaS50ZXN0KG1zZykpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoL3JlZ3VsYXIgZXhwcmVzc2lvbi9pLnRlc3QobXNnKSkge1xuICAgICAgICByZXBsYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRUbyhwb3MpO1xuICAgICAgaWYgKHJlcGxhY2UgPT09IHRydWUpIHsgcmVwbGFjZSA9IHtzdGFydDogcG9zLCBlbmQ6IHBvcywgdHlwZTogdG9rVHlwZXMubmFtZSwgdmFsdWU6IFwi4pyWXCJ9OyB9XG4gICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgICAgICB7IHJlcGxhY2UubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKFxuICAgICAgICAgICAgdGhpcy50b2tzLFxuICAgICAgICAgICAgZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcmVwbGFjZS5zdGFydCksXG4gICAgICAgICAgICBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCByZXBsYWNlLmVuZCkpOyB9XG4gICAgICAgIHJldHVybiByZXBsYWNlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5scC5yZXNldFRvID0gZnVuY3Rpb24ocG9zKSB7XG4gIHRoaXMudG9rcy5wb3MgPSBwb3M7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHBvcyAtIDEpO1xuICB0aGlzLnRva3MuZXhwckFsbG93ZWQgPSAhY2ggfHwgL1tbeygsOzo/Lyo9K1xcLX4hfCYlXjw+XS8udGVzdChjaCkgfHxcbiAgICAvW2Vud2ZkXS8udGVzdChjaCkgJiZcbiAgICAvXFxiKGNhc2V8ZWxzZXxyZXR1cm58dGhyb3d8bmV3fGlufChpbnN0YW5jZXx0eXBlKT9vZnxkZWxldGV8dm9pZCkkLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2UocG9zIC0gMTAsIHBvcykpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgdGhpcy50b2tzLmN1ckxpbmUgPSAxO1xuICAgIHRoaXMudG9rcy5saW5lU3RhcnQgPSBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgcG9zKSB7XG4gICAgICArK3RoaXMudG9rcy5jdXJMaW5lO1xuICAgICAgdGhpcy50b2tzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfVxufTtcblxubHAubG9va0FoZWFkID0gZnVuY3Rpb24obikge1xuICB3aGlsZSAobiA+IHRoaXMuYWhlYWQubGVuZ3RoKVxuICAgIHsgdGhpcy5haGVhZC5wdXNoKHRoaXMucmVhZFRva2VuKCkpOyB9XG4gIHJldHVybiB0aGlzLmFoZWFkW24gLSAxXVxufTtcblxuZnVuY3Rpb24gaXNEdW1teShub2RlKSB7IHJldHVybiBub2RlLm5hbWUgPT09IFwi4pyWXCIgfVxuXG52YXIgbHAkMSA9IExvb3NlUGFyc2VyLnByb3RvdHlwZTtcblxubHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLm9wdGlvbnMubG9jYXRpb25zID8gWzAsIGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIDApXSA6IDApO1xuICBub2RlLmJvZHkgPSBbXTtcbiAgd2hpbGUgKHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLmVvZikgeyBub2RlLmJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KCkpOyB9XG4gIHRoaXMudG9rcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gIHRoaXMubGFzdCA9IHRoaXMudG9rO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxufTtcblxubHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnR0eXBlID0gdGhpcy50b2sudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgaWYgKHRoaXMudG9rcy5pc0xldCgpKSB7XG4gICAgc3RhcnR0eXBlID0gdG9rVHlwZXMuX3ZhcjtcbiAgICBraW5kID0gXCJsZXRcIjtcbiAgfVxuXG4gIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gIGNhc2UgdG9rVHlwZXMuX2JyZWFrOiBjYXNlIHRva1R5cGVzLl9jb250aW51ZTpcbiAgICB0aGlzLm5leHQoKTtcbiAgICB2YXIgaXNCcmVhayA9IHN0YXJ0dHlwZSA9PT0gdG9rVHlwZXMuX2JyZWFrO1xuICAgIGlmICh0aGlzLnNlbWljb2xvbigpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIG5vZGUubGFiZWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcblxuICBjYXNlIHRva1R5cGVzLl9kZWJ1Z2dlcjpcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxuXG4gIGNhc2UgdG9rVHlwZXMuX2RvOlxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLmVhdCh0b2tUeXBlcy5fd2hpbGUpID8gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpIDogdGhpcy5kdW1teUlkZW50KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxuXG4gIGNhc2UgdG9rVHlwZXMuX2ZvcjpcbiAgICB0aGlzLm5leHQoKTsgLy8gYGZvcmAga2V5d29yZFxuICAgIHZhciBpc0F3YWl0ID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5pbkFzeW5jICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpO1xuXG4gICAgdGhpcy5wdXNoQ3goKTtcbiAgICB0aGlzLmV4cGVjdCh0b2tUeXBlcy5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5zZW1pKSB7IHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpIH1cbiAgICB2YXIgaXNMZXQgPSB0aGlzLnRva3MuaXNMZXQoKTtcbiAgICBpZiAoaXNMZXQgfHwgdGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuX3ZhciB8fCB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5fY29uc3QpIHtcbiAgICAgIHZhciBpbml0JDEgPSB0aGlzLnBhcnNlVmFyKHRoaXMuc3RhcnROb2RlKCksIHRydWUsIGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudG9rLnZhbHVlKTtcbiAgICAgIGlmIChpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5faW4pIHtcbiAgICAgICAgICBub2RlLmF3YWl0ID0gaXNBd2FpdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlKTtcbiAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5faW4pIHtcbiAgICAgICAgbm9kZS5hd2FpdCA9IGlzQXdhaXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxuXG4gIGNhc2UgdG9rVHlwZXMuX2Z1bmN0aW9uOlxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSlcblxuICBjYXNlIHRva1R5cGVzLl9pZjpcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodG9rVHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudCgpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcblxuICBjYXNlIHRva1R5cGVzLl9yZXR1cm46XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLnNlbWkpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG5cbiAgY2FzZSB0b2tUeXBlcy5fc3dpdGNoOlxuICAgIHZhciBibG9ja0luZGVudCA9IHRoaXMuY3VySW5kZW50LCBsaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgbm9kZS5jYXNlcyA9IFtdO1xuICAgIHRoaXMucHVzaEN4KCk7XG4gICAgdGhpcy5leHBlY3QodG9rVHlwZXMuYnJhY2VMKTtcblxuICAgIHZhciBjdXI7XG4gICAgd2hpbGUgKCF0aGlzLmNsb3Nlcyh0b2tUeXBlcy5icmFjZVIsIGJsb2NrSW5kZW50LCBsaW5lLCB0cnVlKSkge1xuICAgICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLl9jYXNlIHx8IHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLl9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkgeyBjdXIudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IH1cbiAgICAgICAgZWxzZSB7IGN1ci50ZXN0ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmV4cGVjdCh0b2tUeXBlcy5jb2xvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWN1cikge1xuICAgICAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgdGhpcy5wb3BDeCgpO1xuICAgIHRoaXMuZWF0KHRva1R5cGVzLmJyYWNlUik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxuXG4gIGNhc2UgdG9rVHlwZXMuX3Rocm93OlxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG5cbiAgY2FzZSB0b2tUeXBlcy5fdHJ5OlxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5fY2F0Y2gpIHtcbiAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5lYXQodG9rVHlwZXMucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnRvQXNzaWduYWJsZSh0aGlzLnBhcnNlRXhwckF0b20oKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KHRva1R5cGVzLnBhcmVuUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgfVxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodG9rVHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikgeyByZXR1cm4gbm9kZS5ibG9jayB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxuXG4gIGNhc2UgdG9rVHlwZXMuX3ZhcjpcbiAgY2FzZSB0b2tUeXBlcy5fY29uc3Q6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQgfHwgdGhpcy50b2sudmFsdWUpXG5cbiAgY2FzZSB0b2tUeXBlcy5fd2hpbGU6XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcblxuICBjYXNlIHRva1R5cGVzLl93aXRoOlxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuXG4gIGNhc2UgdG9rVHlwZXMuYnJhY2VMOlxuICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKVxuXG4gIGNhc2UgdG9rVHlwZXMuc2VtaTpcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcblxuICBjYXNlIHRva1R5cGVzLl9jbGFzczpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRydWUpXG5cbiAgY2FzZSB0b2tUeXBlcy5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiB0aGlzLmxvb2tBaGVhZCgxKS50eXBlID09PSB0b2tUeXBlcy5wYXJlbkwpIHtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydCgpXG5cbiAgY2FzZSB0b2tUeXBlcy5fZXhwb3J0OlxuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwb3J0KClcblxuICBkZWZhdWx0OlxuICAgIGlmICh0aGlzLnRva3MuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUsIHRydWUpXG4gICAgfVxuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAoaXNEdW1teShleHByKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuZW9mKSB7IHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKSB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudCgpXG4gICAgfSBlbHNlIGlmIChzdGFydHR5cGUgPT09IHRva1R5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0b2tUeXBlcy5jb2xvbikpIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufTtcblxubHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5wdXNoQ3goKTtcbiAgdGhpcy5leHBlY3QodG9rVHlwZXMuYnJhY2VMKTtcbiAgdmFyIGJsb2NrSW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgbm9kZS5ib2R5ID0gW107XG4gIHdoaWxlICghdGhpcy5jbG9zZXModG9rVHlwZXMuYnJhY2VSLCBibG9ja0luZGVudCwgbGluZSwgdHJ1ZSkpXG4gICAgeyBub2RlLmJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KCkpOyB9XG4gIHRoaXMucG9wQ3goKTtcbiAgdGhpcy5lYXQodG9rVHlwZXMuYnJhY2VSKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG59O1xuXG5scCQxLnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICBub2RlLmluaXQgPSBpbml0O1xuICBub2RlLnRlc3QgPSBub2RlLnVwZGF0ZSA9IG51bGw7XG4gIGlmICh0aGlzLmVhdCh0b2tUeXBlcy5zZW1pKSAmJiB0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5zZW1pKSB7IG5vZGUudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IH1cbiAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLnNlbWkpICYmIHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLnBhcmVuUikgeyBub2RlLnVwZGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IH1cbiAgdGhpcy5wb3BDeCgpO1xuICB0aGlzLmV4cGVjdCh0b2tUeXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbn07XG5cbmxwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5faW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCI7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmxlZnQgPSBpbml0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5wb3BDeCgpO1xuICB0aGlzLmV4cGVjdCh0b2tUeXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSlcbn07XG5cbmxwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBub0luLCBraW5kKSB7XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICBkbyB7XG4gICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGRlY2wuaWQgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IHRoaXMudG9Bc3NpZ25hYmxlKHRoaXMucGFyc2VFeHByQXRvbSgpLCB0cnVlKSA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGRlY2wuaW5pdCA9IHRoaXMuZWF0KHRva1R5cGVzLmVxKSA/IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKSA6IG51bGw7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICB9IHdoaWxlICh0aGlzLmVhdCh0b2tUeXBlcy5jb21tYSkpXG4gIGlmICghbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgdmFyIGRlY2wkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgZGVjbCQxLmlkID0gdGhpcy5kdW1teUlkZW50KCk7XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gIH1cbiAgaWYgKCFub0luKSB7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbn07XG5cbmxwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKGlzU3RhdGVtZW50KSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5uYW1lKSB7IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTsgfVxuICBlbHNlIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSkgeyBub2RlLmlkID0gdGhpcy5kdW1teUlkZW50KCk7IH1cbiAgZWxzZSB7IG5vZGUuaWQgPSBudWxsOyB9XG4gIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHRva1R5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiBudWxsO1xuICBub2RlLmJvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLmJvZHkuYm9keSA9IFtdO1xuICB0aGlzLnB1c2hDeCgpO1xuICB2YXIgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQgKyAxLCBsaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gIHRoaXMuZWF0KHRva1R5cGVzLmJyYWNlTCk7XG4gIGlmICh0aGlzLmN1ckluZGVudCArIDEgPCBpbmRlbnQpIHsgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQ7IGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydDsgfVxuICB3aGlsZSAoIXRoaXMuY2xvc2VzKHRva1R5cGVzLmJyYWNlUiwgaW5kZW50LCBsaW5lKSkge1xuICAgIGlmICh0aGlzLnNlbWljb2xvbigpKSB7IGNvbnRpbnVlIH1cbiAgICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IgPSAodm9pZCAwKSwgaXNBc3luYyA9ICh2b2lkIDApO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgbWV0aG9kLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0b2tUeXBlcy5zdGFyKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgIGlmIChpc0R1bW15KG1ldGhvZC5rZXkpKSB7IGlmIChpc0R1bW15KHRoaXMucGFyc2VNYXliZUFzc2lnbigpKSkgeyB0aGlzLm5leHQoKTsgfSB0aGlzLmVhdCh0b2tUeXBlcy5jb21tYSk7IGNvbnRpbnVlIH1cbiAgICBpZiAobWV0aG9kLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhbWV0aG9kLmNvbXB1dGVkICYmIG1ldGhvZC5rZXkubmFtZSA9PT0gXCJzdGF0aWNcIiAmJlxuICAgICAgICAodGhpcy50b2sudHlwZSAhPT0gdG9rVHlwZXMucGFyZW5MICYmIHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLmJyYWNlTCkpIHtcbiAgICAgIG1ldGhvZC5zdGF0aWMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0b2tUeXBlcy5zdGFyKTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kLnN0YXRpYyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJlxuICAgICAgICBtZXRob2Qua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG1ldGhvZC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLnBhcmVuTCAmJlxuICAgICAgICAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHRva1R5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FzeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBtZXRob2Qua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICFtZXRob2QuY29tcHV0ZWQgJiYgKG1ldGhvZC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBtZXRob2Qua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgIHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLnBhcmVuTCAmJiB0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5icmFjZUwpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gbWV0aG9kLmtleS5uYW1lO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgICAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmICFpc0dlbmVyYXRvciAmJiAhaXNBc3luYyAmJiAoXG4gICAgICAgIG1ldGhvZC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbWV0aG9kLmtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgICAgICBtZXRob2Qua2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIG1ldGhvZC5rZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICB9XG4gICAgICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICB9XG4gICAgbm9kZS5ib2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIikpO1xuICB9XG4gIHRoaXMucG9wQ3goKTtcbiAgaWYgKCF0aGlzLmVhdCh0b2tUeXBlcy5icmFjZVIpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY2xvc2luZyBicmFjZSwgbWFrZSB0aGUgbm9kZSBzcGFuIHRvIHRoZSBzdGFydFxuICAgIC8vIG9mIHRoZSBuZXh0IHRva2VuICh0aGlzIGlzIHVzZWZ1bCBmb3IgVGVybilcbiAgICB0aGlzLmxhc3QuZW5kID0gdGhpcy50b2suc3RhcnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5sYXN0LmxvYy5lbmQgPSB0aGlzLnRvay5sb2Muc3RhcnQ7IH1cbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICB0aGlzLmZpbmlzaE5vZGUobm9kZS5ib2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbn07XG5cbmxwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50LCBpc0FzeW5jKSB7XG4gIHZhciBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLCBvbGRJbkZ1bmN0aW9uID0gdGhpcy5pbkZ1bmN0aW9uO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0b2tUeXBlcy5zdGFyKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHtcbiAgICBub2RlLmFzeW5jID0gISFpc0FzeW5jO1xuICB9XG4gIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5uYW1lKSB7IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTsgfVxuICBlbHNlIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSkgeyBub2RlLmlkID0gdGhpcy5kdW1teUlkZW50KCk7IH1cbiAgdGhpcy5pbkFzeW5jID0gbm9kZS5hc3luYztcbiAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMoKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIHRoaXMudG9rcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgdGhpcy5pbkFzeW5jID0gb2xkSW5Bc3luYztcbiAgdGhpcy5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jdGlvbjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbmxwJDEucGFyc2VFeHBvcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLnN0YXIpKSB7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLmR1bW15U3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLl9kZWZhdWx0KSkge1xuICAgIC8vIGV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiBmb28oKSB7fSkgLy8gVGhpcyBpcyBGdW5jdGlvbkV4cHJlc3Npb24uXG4gICAgdmFyIGlzQXN5bmM7XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMudG9rcy5pc0FzeW5jRnVuY3Rpb24oKSkpIHtcbiAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMubmV4dCgpOyB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBcIm51bGxhYmxlSURcIiwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5fY2xhc3MpIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoXCJudWxsYWJsZUlEXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgaWYgKHRoaXMudG9rLnR5cGUua2V5d29yZCB8fCB0aGlzLnRva3MuaXNMZXQoKSB8fCB0aGlzLnRva3MuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyTGlzdCgpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogbnVsbDtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG59O1xuXG5scCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbHQ7XG4gICAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLm5hbWUgJiYgdGhpcy50b2sudmFsdWUgIT09IFwiZnJvbVwiKSB7XG4gICAgICBlbHQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgZWx0LmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoZWx0LCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIik7XG4gICAgICB0aGlzLmVhdCh0b2tUeXBlcy5jb21tYSk7XG4gICAgfVxuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpICYmIHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5kdW1teVN0cmluZygpO1xuICAgIGlmIChlbHQpIHsgbm9kZS5zcGVjaWZpZXJzLnVuc2hpZnQoZWx0KTsgfVxuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKVxufTtcblxubHAkMS5wYXJzZUltcG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVsdHMgPSBbXTtcbiAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLnN0YXIpIHtcbiAgICB2YXIgZWx0ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBlbHQubG9jYWwgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCgpIDogdGhpcy5kdW1teUlkZW50KCk7XG4gICAgZWx0cy5wdXNoKHRoaXMuZmluaXNoTm9kZShlbHQsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydCwgY29udGludWVkTGluZSA9IHRoaXMubmV4dExpbmVTdGFydDtcbiAgICB0aGlzLnB1c2hDeCgpO1xuICAgIHRoaXMuZWF0KHRva1R5cGVzLmJyYWNlTCk7XG4gICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gY29udGludWVkTGluZSkgeyBjb250aW51ZWRMaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7IH1cbiAgICB3aGlsZSAoIXRoaXMuY2xvc2VzKHRva1R5cGVzLmJyYWNlUiwgaW5kZW50ICsgKHRoaXMuY3VyTGluZVN0YXJ0IDw9IGNvbnRpbnVlZExpbmUgPyAxIDogMCksIGxpbmUpKSB7XG4gICAgICB2YXIgZWx0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLnN0YXIpKSB7XG4gICAgICAgIGVsdCQxLmxvY2FsID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IHRoaXMuZHVtbXlJZGVudCgpO1xuICAgICAgICB0aGlzLmZpbmlzaE5vZGUoZWx0JDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiZnJvbVwiKSkgeyBicmVhayB9XG4gICAgICAgIGVsdCQxLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICAgIGlmIChpc0R1bW15KGVsdCQxLmltcG9ydGVkKSkgeyBicmVhayB9XG4gICAgICAgIGVsdCQxLmxvY2FsID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IGVsdCQxLmltcG9ydGVkO1xuICAgICAgICB0aGlzLmZpbmlzaE5vZGUoZWx0JDEsIFwiSW1wb3J0U3BlY2lmaWVyXCIpO1xuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKGVsdCQxKTtcbiAgICAgIHRoaXMuZWF0KHRva1R5cGVzLmNvbW1hKTtcbiAgICB9XG4gICAgdGhpcy5lYXQodG9rVHlwZXMuYnJhY2VSKTtcbiAgICB0aGlzLnBvcEN4KCk7XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbmxwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJMaXN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbHRzID0gW107XG4gIHZhciBpbmRlbnQgPSB0aGlzLmN1ckluZGVudCwgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0LCBjb250aW51ZWRMaW5lID0gdGhpcy5uZXh0TGluZVN0YXJ0O1xuICB0aGlzLnB1c2hDeCgpO1xuICB0aGlzLmVhdCh0b2tUeXBlcy5icmFjZUwpO1xuICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiBjb250aW51ZWRMaW5lKSB7IGNvbnRpbnVlZExpbmUgPSB0aGlzLmN1ckxpbmVTdGFydDsgfVxuICB3aGlsZSAoIXRoaXMuY2xvc2VzKHRva1R5cGVzLmJyYWNlUiwgaW5kZW50ICsgKHRoaXMuY3VyTGluZVN0YXJ0IDw9IGNvbnRpbnVlZExpbmUgPyAxIDogMCksIGxpbmUpKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiZnJvbVwiKSkgeyBicmVhayB9XG4gICAgdmFyIGVsdCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgZWx0LmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKGlzRHVtbXkoZWx0LmxvY2FsKSkgeyBicmVhayB9XG4gICAgZWx0LmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQoKSA6IGVsdC5sb2NhbDtcbiAgICB0aGlzLmZpbmlzaE5vZGUoZWx0LCBcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgICBlbHRzLnB1c2goZWx0KTtcbiAgICB0aGlzLmVhdCh0b2tUeXBlcy5jb21tYSk7XG4gIH1cbiAgdGhpcy5lYXQodG9rVHlwZXMuYnJhY2VSKTtcbiAgdGhpcy5wb3BDeCgpO1xuICByZXR1cm4gZWx0c1xufTtcblxudmFyIGxwJDIgPSBMb29zZVBhcnNlci5wcm90b3R5cGU7XG5cbmxwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoIWV4cHIpIHsgcmV0dXJuIGV4cHIgfVxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIHJldHVybiBleHByXG5cbiAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgZXhwci5leHByZXNzaW9uID0gdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gZXhwclxuXG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZHVtbXlJZGVudCgpXG4gIH1cbn07XG5cbmxwJDIucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9Jbikge1xuICB2YXIgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgIHdoaWxlICh0aGlzLmVhdCh0b2tUeXBlcy5jb21tYSkpIHsgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKSk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbmxwJDIucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wdXNoQ3goKTtcbiAgdGhpcy5leHBlY3QodG9rVHlwZXMucGFyZW5MKTtcbiAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMucG9wQ3goKTtcbiAgdGhpcy5leHBlY3QodG9rVHlwZXMucGFyZW5SKTtcbiAgcmV0dXJuIHZhbFxufTtcblxubHAkMi5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24obm9Jbikge1xuICBpZiAodGhpcy50b2tzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnNlbWljb2xvbigpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLnN0YXIgJiYgIXRoaXMudG9rLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodG9rVHlwZXMuc3Rhcik7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbiAgfVxuXG4gIHZhciBzdGFydCA9IHRoaXMuc3RvcmVDdXJyZW50UG9zKCk7XG4gIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbik7XG4gIGlmICh0aGlzLnRvay50eXBlLmlzQXNzaWduKSB7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMudG9rLnZhbHVlO1xuICAgIG5vZGUkMS5sZWZ0ID0gdGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0KSA6IHRoaXMuY2hlY2tMVmFsKGxlZnQpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUkMS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG5scCQyLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKTtcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luKTtcbiAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLnF1ZXN0aW9uKSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydCk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZXhwZWN0KHRva1R5cGVzLmNvbG9uKSA/IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKSA6IHRoaXMuZHVtbXlJZGVudCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxubHAkMi5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuc3RvcmVDdXJyZW50UG9zKCk7XG4gIHZhciBpbmRlbnQgPSB0aGlzLmN1ckluZGVudCwgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0O1xuICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShmYWxzZSksIHN0YXJ0LCAtMSwgbm9JbiwgaW5kZW50LCBsaW5lKVxufTtcblxubHAkMi5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIHN0YXJ0LCBtaW5QcmVjLCBub0luLCBpbmRlbnQsIGxpbmUpIHtcbiAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICE9PSBsaW5lICYmIHRoaXMuY3VySW5kZW50IDwgaW5kZW50ICYmIHRoaXMudG9rZW5TdGFydHNMaW5lKCkpIHsgcmV0dXJuIGxlZnQgfVxuICB2YXIgcHJlYyA9IHRoaXMudG9rLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudG9rLnR5cGUgIT09IHRva1R5cGVzLl9pbikpIHtcbiAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudG9rLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgIT09IGxpbmUgJiYgdGhpcy5jdXJJbmRlbnQgPCBpbmRlbnQgJiYgdGhpcy50b2tlblN0YXJ0c0xpbmUoKSkge1xuICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5kdW1teUlkZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmlnaHRTdGFydCA9IHRoaXMuc3RvcmVDdXJyZW50UG9zKCk7XG4gICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KGZhbHNlKSwgcmlnaHRTdGFydCwgcHJlYywgbm9JbiwgaW5kZW50LCBsaW5lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCAvJiZ8XFx8XFx8Ly50ZXN0KG5vZGUub3BlcmF0b3IpID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgc3RhcnQsIG1pblByZWMsIG5vSW4sIGluZGVudCwgbGluZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlZnRcbn07XG5cbmxwJDIucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24oc2F3VW5hcnkpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKSwgZXhwcjtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRoaXMudG9rcy5pc0NvbnRleHR1YWwoXCJhd2FpdFwiKSAmJlxuICAgICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKVxuICApIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KCk7XG4gICAgc2F3VW5hcnkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMudG9rLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5pbmNEZWM7XG4gICAgaWYgKCF1cGRhdGUpIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudG9rLnZhbHVlO1xuICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkodHJ1ZSk7XG4gICAgaWYgKHVwZGF0ZSkgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuZWxsaXBzaXMpIHtcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlJDEuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShzYXdVbmFyeSk7XG4gICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiU3ByZWFkRWxlbWVudFwiKTtcbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG4gICAgd2hpbGUgKHRoaXMudG9rLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnQpO1xuICAgICAgbm9kZSQyLm9wZXJhdG9yID0gdGhpcy50b2sudmFsdWU7XG4gICAgICBub2RlJDIucHJlZml4ID0gZmFsc2U7XG4gICAgICBub2RlJDIuYXJndW1lbnQgPSB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHRva1R5cGVzLnN0YXJzdGFyKSkge1xuICAgIHZhciBub2RlJDMgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICBub2RlJDMub3BlcmF0b3IgPSBcIioqXCI7XG4gICAgbm9kZSQzLmxlZnQgPSBleHByO1xuICAgIG5vZGUkMy5yaWdodCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUkMywgXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH1cblxuICByZXR1cm4gZXhwclxufTtcblxubHAkMi5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuc3RvcmVDdXJyZW50UG9zKCk7XG4gIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnQsIGZhbHNlLCB0aGlzLmN1ckluZGVudCwgdGhpcy5jdXJMaW5lU3RhcnQpXG59O1xuXG5scCQyLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0LCBub0NhbGxzLCBzdGFydEluZGVudCwgbGluZSkge1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICE9PSBsaW5lICYmIHRoaXMuY3VySW5kZW50IDw9IHN0YXJ0SW5kZW50ICYmIHRoaXMudG9rZW5TdGFydHNMaW5lKCkpIHtcbiAgICAgIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5kb3QgJiYgdGhpcy5jdXJJbmRlbnQgPT09IHN0YXJ0SW5kZW50KVxuICAgICAgICB7IC0tc3RhcnRJbmRlbnQ7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gYmFzZSB9XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG5cbiAgICBpZiAodGhpcy5lYXQodG9rVHlwZXMuZG90KSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCAhPT0gbGluZSAmJiB0aGlzLmN1ckluZGVudCA8PSBzdGFydEluZGVudCAmJiB0aGlzLnRva2VuU3RhcnRzTGluZSgpKVxuICAgICAgICB7IG5vZGUucHJvcGVydHkgPSB0aGlzLmR1bW15SWRlbnQoKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlUHJvcGVydHlBY2Nlc3NvcigpIHx8IHRoaXMuZHVtbXlJZGVudCgpOyB9XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLmJyYWNrZXRMKSB7XG4gICAgICB0aGlzLnB1c2hDeCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydCk7XG4gICAgICBub2RlJDEub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUkMS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBub2RlJDEuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5wb3BDeCgpO1xuICAgICAgdGhpcy5leHBlY3QodG9rVHlwZXMuYnJhY2tldFIpO1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLnBhcmVuTCkge1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHRva1R5cGVzLnBhcmVuUik7XG4gICAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmIHRoaXMuZWF0KHRva1R5cGVzLmFycm93KSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KSwgZXhwckxpc3QsIHRydWUpIH1cbiAgICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgIG5vZGUkMi5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQyLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5iYWNrUXVvdGUpIHtcbiAgICAgIHZhciBub2RlJDMgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgIG5vZGUkMy50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQzLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKCk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMywgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlXG4gICAgfVxuICB9XG59O1xuXG5scCQyLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGU7XG4gIHN3aXRjaCAodGhpcy50b2sudHlwZSkge1xuICBjYXNlIHRva1R5cGVzLl90aGlzOlxuICBjYXNlIHRva1R5cGVzLl9zdXBlcjpcbiAgICB2YXIgdHlwZSA9IHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLl90aGlzID8gXCJUaGlzRXhwcmVzc2lvblwiIDogXCJTdXBlclwiO1xuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSlcblxuICBjYXNlIHRva1R5cGVzLm5hbWU6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKTtcbiAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICAgIGlmIChpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0b2tUeXBlcy5fZnVuY3Rpb24pKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydCksIGZhbHNlLCB0cnVlKSB9XG4gICAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMubmFtZSkge1xuICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWF0KHRva1R5cGVzLmFycm93KSA/IHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydCksIFtpZF0sIGlzQXN5bmMpIDogaWRcblxuICBjYXNlIHRva1R5cGVzLnJlZ2V4cDpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgdmFsID0gdGhpcy50b2sudmFsdWU7XG4gICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWwucGF0dGVybiwgZmxhZ3M6IHZhbC5mbGFnc307XG4gICAgbm9kZS52YWx1ZSA9IHZhbC52YWx1ZTtcbiAgICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy50b2suc3RhcnQsIHRoaXMudG9rLmVuZCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICBjYXNlIHRva1R5cGVzLm51bTogY2FzZSB0b2tUeXBlcy5zdHJpbmc6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudG9rLnZhbHVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnRvay5zdGFydCwgdGhpcy50b2suZW5kKTtcbiAgICBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMubnVtICYmIG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgY2FzZSB0b2tUeXBlcy5fbnVsbDogY2FzZSB0b2tUeXBlcy5fdHJ1ZTogY2FzZSB0b2tUeXBlcy5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLl90cnVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy50b2sudHlwZS5rZXl3b3JkO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgY2FzZSB0b2tUeXBlcy5wYXJlbkw6XG4gICAgdmFyIHBhcmVuU3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciBpbm5lciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodG9rVHlwZXMucGFyZW5SKTtcbiAgICBpZiAodGhpcy5lYXQodG9rVHlwZXMuYXJyb3cpKSB7XG4gICAgICAvLyAoYSwpPT5hIC8vIFNlcXVlbmNlRXhwcmVzc2lvbiBtYWtlcyBkdW1teSBpbiB0aGUgbGFzdCBob2xlLiBEcm9wIHRoZSBkdW1teS5cbiAgICAgIHZhciBwYXJhbXMgPSBpbm5lci5leHByZXNzaW9ucyB8fCBbaW5uZXJdO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggJiYgaXNEdW1teShwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKSlcbiAgICAgICAgeyBwYXJhbXMucG9wKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQocGFyZW5TdGFydCksIHBhcmFtcylcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQocGFyZW5TdGFydCk7XG4gICAgICBwYXIuZXhwcmVzc2lvbiA9IGlubmVyO1xuICAgICAgaW5uZXIgPSB0aGlzLmZpbmlzaE5vZGUocGFyLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaW5uZXJcblxuICBjYXNlIHRva1R5cGVzLmJyYWNrZXRMOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodG9rVHlwZXMuYnJhY2tldFIsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICBjYXNlIHRva1R5cGVzLmJyYWNlTDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9iaigpXG5cbiAgY2FzZSB0b2tUeXBlcy5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhmYWxzZSlcblxuICBjYXNlIHRva1R5cGVzLl9mdW5jdGlvbjpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKVxuXG4gIGNhc2UgdG9rVHlwZXMuX25ldzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgY2FzZSB0b2tUeXBlcy5iYWNrUXVvdGU6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpXG5cbiAgY2FzZSB0b2tUeXBlcy5faW1wb3J0OlxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEeW5hbWljSW1wb3J0KClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZHVtbXlJZGVudCgpXG4gICAgfVxuXG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZHVtbXlJZGVudCgpXG4gIH1cbn07XG5cbmxwJDIucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIilcbn07XG5cbmxwJDIucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBzdGFydEluZGVudCA9IHRoaXMuY3VySW5kZW50LCBsaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodG9rVHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH1cbiAgdmFyIHN0YXJ0ID0gdGhpcy5zdG9yZUN1cnJlbnRQb3MoKTtcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnQsIHRydWUsIHN0YXJ0SW5kZW50LCBsaW5lKTtcbiAgaWYgKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLnBhcmVuTCkge1xuICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHRva1R5cGVzLnBhcmVuUik7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxubHAkMi5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgLy8gVGhlIGxvb3NlIHBhcnNlciBhY2NlcHRzIGludmFsaWQgdW5pY29kZSBlc2NhcGVzIGV2ZW4gaW4gdW50YWdnZWQgdGVtcGxhdGVzLlxuICBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgIHJhdzogdGhpcy50b2sudmFsdWUsXG4gICAgICBjb29rZWQ6IG51bGxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy50b2suc3RhcnQsIHRoaXMudG9rLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdGhpcy50b2sudmFsdWVcbiAgICB9O1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICBlbGVtLnRhaWwgPSB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbmxwJDIucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XG4gIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgaWYgKHRoaXMuZXhwZWN0KHRva1R5cGVzLmJyYWNlUikpIHtcbiAgICAgIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyRWx0ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGN1ckVsdC52YWx1ZSA9IHtjb29rZWQ6IFwiXCIsIHJhdzogXCJcIn07XG4gICAgICBjdXJFbHQudGFpbCA9IHRydWU7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoY3VyRWx0LCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICB9XG4gICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQpO1xuICB9XG4gIHRoaXMuZXhwZWN0KHRva1R5cGVzLmJhY2tRdW90ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbn07XG5cbmxwJDIucGFyc2VPYmogPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5wdXNoQ3goKTtcbiAgdmFyIGluZGVudCA9IHRoaXMuY3VySW5kZW50ICsgMSwgbGluZSA9IHRoaXMuY3VyTGluZVN0YXJ0O1xuICB0aGlzLmVhdCh0b2tUeXBlcy5icmFjZUwpO1xuICBpZiAodGhpcy5jdXJJbmRlbnQgKyAxIDwgaW5kZW50KSB7IGluZGVudCA9IHRoaXMuY3VySW5kZW50OyBsaW5lID0gdGhpcy5jdXJMaW5lU3RhcnQ7IH1cbiAgd2hpbGUgKCF0aGlzLmNsb3Nlcyh0b2tUeXBlcy5icmFjZVIsIGluZGVudCwgbGluZSkpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yID0gKHZvaWQgMCksIGlzQXN5bmMgPSAodm9pZCAwKSwgc3RhcnQgPSAodm9pZCAwKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodG9rVHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpKTtcbiAgICAgIHRoaXMuZWF0KHRva1R5cGVzLmNvbW1hKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgc3RhcnQgPSB0aGlzLnN0b3JlQ3VycmVudFBvcygpO1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHRva1R5cGVzLnN0YXIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIGlmICh0aGlzLnRva3MuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0b2tUeXBlcy5zdGFyKTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzRHVtbXkocHJvcC5rZXkpKSB7IGlmIChpc0R1bW15KHRoaXMucGFyc2VNYXliZUFzc2lnbigpKSkgeyB0aGlzLm5leHQoKTsgfSB0aGlzLmVhdCh0b2tUeXBlcy5jb21tYSk7IGNvbnRpbnVlIH1cbiAgICBpZiAodGhpcy5lYXQodG9rVHlwZXMuY29sb24pKSB7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICh0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5wYXJlbkwgfHwgdGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMuYnJhY2VMKSkge1xuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgICAgIXByb3AuY29tcHV0ZWQgJiYgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAgICh0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5jb21tYSAmJiB0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5icmFjZVIgJiYgdGhpcy50b2sudHlwZSAhPT0gdG9rVHlwZXMuZXEpKSB7XG4gICAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLmVxKSkge1xuICAgICAgICAgIHZhciBhc3NpZ24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0KTtcbiAgICAgICAgICBhc3NpZ24ub3BlcmF0b3IgPSBcIj1cIjtcbiAgICAgICAgICBhc3NpZ24ubGVmdCA9IHByb3Aua2V5O1xuICAgICAgICAgIGFzc2lnbi5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICAgIHByb3AudmFsdWUgPSB0aGlzLmZpbmlzaE5vZGUoYXNzaWduLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMuZHVtbXlJZGVudCgpO1xuICAgICAgfVxuICAgICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICAgIH1cbiAgICBub2RlLnByb3BlcnRpZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKSk7XG4gICAgdGhpcy5lYXQodG9rVHlwZXMuY29tbWEpO1xuICB9XG4gIHRoaXMucG9wQ3goKTtcbiAgaWYgKCF0aGlzLmVhdCh0b2tUeXBlcy5icmFjZVIpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY2xvc2luZyBicmFjZSwgbWFrZSB0aGUgbm9kZSBzcGFuIHRvIHRoZSBzdGFydFxuICAgIC8vIG9mIHRoZSBuZXh0IHRva2VuICh0aGlzIGlzIHVzZWZ1bCBmb3IgVGVybilcbiAgICB0aGlzLmxhc3QuZW5kID0gdGhpcy50b2suc3RhcnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5sYXN0LmxvYy5lbmQgPSB0aGlzLnRvay5sb2Muc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0RXhwcmVzc2lvblwiKVxufTtcblxubHAkMi5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0b2tUeXBlcy5icmFja2V0Uik7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICB2YXIga2V5ID0gKHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLm51bSB8fCB0aGlzLnRvay50eXBlID09PSB0b2tUeXBlcy5zdHJpbmcpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgcHJvcC5rZXkgPSBrZXkgfHwgdGhpcy5kdW1teUlkZW50KCk7XG59O1xuXG5scCQyLnBhcnNlUHJvcGVydHlBY2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy50b2sudHlwZSA9PT0gdG9rVHlwZXMubmFtZSB8fCB0aGlzLnRvay50eXBlLmtleXdvcmQpIHsgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpIH1cbn07XG5cbmxwJDIucGFyc2VJZGVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMudG9rLnR5cGUgPT09IHRva1R5cGVzLm5hbWUgPyB0aGlzLnRvay52YWx1ZSA6IHRoaXMudG9rLnR5cGUua2V5d29yZDtcbiAgaWYgKCFuYW1lKSB7IHJldHVybiB0aGlzLmR1bW15SWRlbnQoKSB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUubmFtZSA9IG5hbWU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpXG59O1xuXG5scCQyLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5pZCA9IG51bGw7XG4gIG5vZGUucGFyYW1zID0gW107XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG59O1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5scCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGJpbmRpbmcpIHtcbiAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgKG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIWJpbmRpbmcpKSA7IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKSB7XG4gICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBiaW5kaW5nKTtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7XG4gICAgcmV0dXJuIHRoaXMuZHVtbXlJZGVudCgpXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgYmluZGluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGJpbmRpbmcpO1xuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiKSB7XG4gICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgYmluZGluZyk7XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmFyZ3VtZW50LCBiaW5kaW5nKTtcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5kdW1teUlkZW50KClcbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxubHAkMi50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGJpbmRpbmcpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByTGlzdDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBleHByID0gbGlzdFtpXTtcblxuICAgIHRoaXMudG9Bc3NpZ25hYmxlKGV4cHIsIGJpbmRpbmcpO1xuICB9XG4gIHJldHVybiBleHByTGlzdFxufTtcblxubHAkMi5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHRoaXMucGFyc2VFeHByTGlzdCh0b2tUeXBlcy5wYXJlblIpO1xuICByZXR1cm4gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSlcbn07XG5cbmxwJDIucGFyc2VNZXRob2QgPSBmdW5jdGlvbihpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZEluQXN5bmMgPSB0aGlzLmluQXN5bmMsIG9sZEluRnVuY3Rpb24gPSB0aGlzLmluRnVuY3Rpb247XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9ICEhaXNHZW5lcmF0b3I7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLmluRnVuY3Rpb24gPSB0cnVlO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcygpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgdGhpcy50b2tzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICB0aGlzLmluQXN5bmMgPSBvbGRJbkFzeW5jO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmN0aW9uO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5scCQyLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHZhciBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLCBvbGRJbkZ1bmN0aW9uID0gdGhpcy5pbkZ1bmN0aW9uO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLmluRnVuY3Rpb24gPSB0cnVlO1xuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnRvay50eXBlICE9PSB0b2tUeXBlcy5icmFjZUw7XG4gIGlmIChub2RlLmV4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICB0aGlzLnRva3MuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gIH1cbiAgdGhpcy5pbkFzeW5jID0gb2xkSW5Bc3luYztcbiAgdGhpcy5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jdGlvbjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5scCQyLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSkge1xuICB0aGlzLnB1c2hDeCgpO1xuICB2YXIgaW5kZW50ID0gdGhpcy5jdXJJbmRlbnQsIGxpbmUgPSB0aGlzLmN1ckxpbmVTdGFydCwgZWx0cyA9IFtdO1xuICB0aGlzLm5leHQoKTsgLy8gT3BlbmluZyBicmFja2V0XG4gIHdoaWxlICghdGhpcy5jbG9zZXMoY2xvc2UsIGluZGVudCArIDEsIGxpbmUpKSB7XG4gICAgaWYgKHRoaXMuZWF0KHRva1R5cGVzLmNvbW1hKSkge1xuICAgICAgZWx0cy5wdXNoKGFsbG93RW1wdHkgPyBudWxsIDogdGhpcy5kdW1teUlkZW50KCkpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIGlmIChpc0R1bW15KGVsdCkpIHtcbiAgICAgIGlmICh0aGlzLmNsb3NlcyhjbG9zZSwgaW5kZW50LCBsaW5lKSkgeyBicmVhayB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWx0cy5wdXNoKGVsdCk7XG4gICAgfVxuICAgIHRoaXMuZWF0KHRva1R5cGVzLmNvbW1hKTtcbiAgfVxuICB0aGlzLnBvcEN4KCk7XG4gIGlmICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gY2xvc2luZyBicmFjZSwgbWFrZSB0aGUgbm9kZSBzcGFuIHRvIHRoZSBzdGFydFxuICAgIC8vIG9mIHRoZSBuZXh0IHRva2VuICh0aGlzIGlzIHVzZWZ1bCBmb3IgVGVybilcbiAgICB0aGlzLmxhc3QuZW5kID0gdGhpcy50b2suc3RhcnQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5sYXN0LmxvYy5lbmQgPSB0aGlzLnRvay5sb2Muc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxubHAkMi5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBBY29ybjogTG9vc2UgcGFyc2VyXG5cbmRlZmF1bHRPcHRpb25zLnRhYlNpemUgPSA0O1xuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gTG9vc2VQYXJzZXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpXG59XG5cbmV4cG9ydCB7IExvb3NlUGFyc2VyLCBwYXJzZSB9O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6TEE7QUEwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvRkE7QUFpR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tern/node_modules/acorn-loose/dist/acorn-loose.mjs\n");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn-walk/dist/walk.js":
/*!****************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn-walk/dist/walk.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, function (exports) { 'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st); }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state) {\n    var ancestors = [];\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st || ancestors, ancestors); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\")\n      { return function (type) { return type === test; } }\n    else if (!test)\n      { return function () { return true; } }\n    else\n      { return test }\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state; };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (!override) { callback(node, st, type); }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var ancestors = []\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (!override) { callback(node, st || ancestors, ancestors, type); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          { baseVisitor[type](node, st, c); }\n        if ((start == null || node.start === start) &&\n            (end == null || node.end === end) &&\n            test(type, node))\n          { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) { return }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) { return }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) { return }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        { max = new Found(node, st); }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max\n  }\n\n  // Fallback to an Object.create polyfill for older environments.\n  var create = Object.create || function(proto) {\n    function Ctor() {}\n    Ctor.prototype = proto;\n    return new Ctor\n  };\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = create(baseVisitor || base);\n    for (var type in funcs) { visitor[type] = funcs[type]; }\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st); }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n\n  base.Program = base.BlockStatement = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var stmt = list[i];\n\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n  };\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n\n      if (cs.test) { c(cs.test, st, \"Expression\"); }\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n        {\n        var cons = list[i];\n\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) { c(node.argument, st, \"Expression\"); }\n  };\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) { c(node.handler, st); }\n    if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) { c(node.param, st, \"Pattern\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) { c(node.init, st, \"ForInit\"); }\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    if (node.update) { c(node.update, st, \"Expression\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") { c(node, st); }\n    else { c(node, st, \"Expression\"); }\n  };\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) { c(node.init, st, \"Expression\"); }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\")\n      { c(node, st, \"VariablePattern\"); }\n    else if (node.type === \"MemberExpression\")\n      { c(node, st, \"MemberPattern\"); }\n    else\n      { c(node, st); }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Pattern\"); }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) { c(prop.key, st, \"Expression\"); }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Expression\"); }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1)\n      {\n      var quasi = list[i];\n\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n      {\n      var expr = list$1[i$1];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments)\n      { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n        {\n          var arg = list[i];\n\n          c(arg, st, \"Expression\");\n        } }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) { c(node.property, st, \"Expression\"); }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n    if (node.source) { c(node.source, st, \"Expression\"); }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n      {\n      var spec = list[i];\n\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n  base.Class = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var elt = list[i];\n\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.Property = function (node, st, c) {\n    if (node.computed) { c(node.key, st, \"Expression\"); }\n    c(node.value, st, \"Expression\");\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4td2Fsay9kaXN0L3dhbGsuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4td2Fsay9kaXN0L3dhbGsuanM/ZWZlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeSgoZ2xvYmFsLmFjb3JuID0gZ2xvYmFsLmFjb3JuIHx8IHt9LCBnbG9iYWwuYWNvcm4ud2FsayA9IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gQVNUIHdhbGtlciBtb2R1bGUgZm9yIE1vemlsbGEgUGFyc2VyIEFQSSBjb21wYXRpYmxlIHRyZWVzXG5cbiAgLy8gQSBzaW1wbGUgd2FsayBpcyBvbmUgd2hlcmUgeW91IHNpbXBseSBzcGVjaWZ5IGNhbGxiYWNrcyB0byBiZVxuICAvLyBjYWxsZWQgb24gc3BlY2lmaWMgbm9kZXMuIFRoZSBsYXN0IHR3byBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiBBXG4gIC8vIHNpbXBsZSB1c2Ugd291bGQgYmVcbiAgLy9cbiAgLy8gICAgIHdhbGsuc2ltcGxlKG15VHJlZSwge1xuICAvLyAgICAgICAgIEV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUpIHsgLi4uIH1cbiAgLy8gICAgIH0pO1xuICAvL1xuICAvLyB0byBkbyBzb21ldGhpbmcgd2l0aCBhbGwgZXhwcmVzc2lvbnMuIEFsbCBQYXJzZXIgQVBJIG5vZGUgdHlwZXNcbiAgLy8gY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgbm9kZSB0eXBlcywgYXMgd2VsbCBhcyBFeHByZXNzaW9uIGFuZFxuICAvLyBTdGF0ZW1lbnQsIHdoaWNoIGRlbm90ZSBjYXRlZ29yaWVzIG9mIG5vZGVzLlxuICAvL1xuICAvLyBUaGUgYmFzZSBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBwYXNzIGEgY3VzdG9tIChyZWN1cnNpdmUpXG4gIC8vIHdhbGtlciwgYW5kIHN0YXRlIGNhbiBiZSB1c2VkIHRvIGdpdmUgdGhpcyB3YWxrZWQgYW4gaW5pdGlhbFxuICAvLyBzdGF0ZS5cblxuICBmdW5jdGlvbiBzaW1wbGUobm9kZSwgdmlzaXRvcnMsIGJhc2VWaXNpdG9yLCBzdGF0ZSwgb3ZlcnJpZGUpIHtcbiAgICBpZiAoIWJhc2VWaXNpdG9yKSB7IGJhc2VWaXNpdG9yID0gYmFzZVxuICAgIDsgfShmdW5jdGlvbiBjKG5vZGUsIHN0LCBvdmVycmlkZSkge1xuICAgICAgdmFyIHR5cGUgPSBvdmVycmlkZSB8fCBub2RlLnR5cGUsIGZvdW5kID0gdmlzaXRvcnNbdHlwZV07XG4gICAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgICBpZiAoZm91bmQpIHsgZm91bmQobm9kZSwgc3QpOyB9XG4gICAgfSkobm9kZSwgc3RhdGUsIG92ZXJyaWRlKTtcbiAgfVxuXG4gIC8vIEFuIGFuY2VzdG9yIHdhbGsga2VlcHMgYW4gYXJyYXkgb2YgYW5jZXN0b3Igbm9kZXMgKGluY2x1ZGluZyB0aGVcbiAgLy8gY3VycmVudCBub2RlKSBhbmQgcGFzc2VzIHRoZW0gdG8gdGhlIGNhbGxiYWNrIGFzIHRoaXJkIHBhcmFtZXRlclxuICAvLyAoYW5kIGFsc28gYXMgc3RhdGUgcGFyYW1ldGVyIHdoZW4gbm8gb3RoZXIgc3RhdGUgaXMgcHJlc2VudCkuXG4gIGZ1bmN0aW9uIGFuY2VzdG9yKG5vZGUsIHZpc2l0b3JzLCBiYXNlVmlzaXRvciwgc3RhdGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2VcbiAgICA7IH0oZnVuY3Rpb24gYyhub2RlLCBzdCwgb3ZlcnJpZGUpIHtcbiAgICAgIHZhciB0eXBlID0gb3ZlcnJpZGUgfHwgbm9kZS50eXBlLCBmb3VuZCA9IHZpc2l0b3JzW3R5cGVdO1xuICAgICAgdmFyIGlzTmV3ID0gbm9kZSAhPT0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChpc05ldykgeyBhbmNlc3RvcnMucHVzaChub2RlKTsgfVxuICAgICAgYmFzZVZpc2l0b3JbdHlwZV0obm9kZSwgc3QsIGMpO1xuICAgICAgaWYgKGZvdW5kKSB7IGZvdW5kKG5vZGUsIHN0IHx8IGFuY2VzdG9ycywgYW5jZXN0b3JzKTsgfVxuICAgICAgaWYgKGlzTmV3KSB7IGFuY2VzdG9ycy5wb3AoKTsgfVxuICAgIH0pKG5vZGUsIHN0YXRlKTtcbiAgfVxuXG4gIC8vIEEgcmVjdXJzaXZlIHdhbGsgaXMgb25lIHdoZXJlIHlvdXIgZnVuY3Rpb25zIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gIC8vIHdhbGtlcnMuIFRoZXkgY2FuIG1vZGlmeSBhbmQgcmVwbGFjZSB0aGUgc3RhdGUgcGFyYW1ldGVyIHRoYXQnc1xuICAvLyB0aHJlYWRlZCB0aHJvdWdoIHRoZSB3YWxrLCBhbmQgY2FuIG9wdCBob3cgYW5kIHdoZXRoZXIgdG8gd2Fsa1xuICAvLyB0aGVpciBjaGlsZCBub2RlcyAoYnkgY2FsbGluZyB0aGVpciB0aGlyZCBhcmd1bWVudCBvbiB0aGVzZVxuICAvLyBub2RlcykuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZShub2RlLCBzdGF0ZSwgZnVuY3MsIGJhc2VWaXNpdG9yLCBvdmVycmlkZSkge1xuICAgIHZhciB2aXNpdG9yID0gZnVuY3MgPyBtYWtlKGZ1bmNzLCBiYXNlVmlzaXRvciB8fCB1bmRlZmluZWQpIDogYmFzZVZpc2l0b3JcbiAgICA7KGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICB2aXNpdG9yW292ZXJyaWRlIHx8IG5vZGUudHlwZV0obm9kZSwgc3QsIGMpO1xuICAgIH0pKG5vZGUsIHN0YXRlLCBvdmVycmlkZSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlVGVzdCh0ZXN0KSB7XG4gICAgaWYgKHR5cGVvZiB0ZXN0ID09PSBcInN0cmluZ1wiKVxuICAgICAgeyByZXR1cm4gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUgPT09IHRlc3Q7IH0gfVxuICAgIGVsc2UgaWYgKCF0ZXN0KVxuICAgICAgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gdGVzdCB9XG4gIH1cblxuICB2YXIgRm91bmQgPSBmdW5jdGlvbiBGb3VuZChub2RlLCBzdGF0ZSkgeyB0aGlzLm5vZGUgPSBub2RlOyB0aGlzLnN0YXRlID0gc3RhdGU7IH07XG5cbiAgLy8gQSBmdWxsIHdhbGsgdHJpZ2dlcnMgdGhlIGNhbGxiYWNrIG9uIGVhY2ggbm9kZVxuICBmdW5jdGlvbiBmdWxsKG5vZGUsIGNhbGxiYWNrLCBiYXNlVmlzaXRvciwgc3RhdGUsIG92ZXJyaWRlKSB7XG4gICAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2VcbiAgICA7IH0oZnVuY3Rpb24gYyhub2RlLCBzdCwgb3ZlcnJpZGUpIHtcbiAgICAgIHZhciB0eXBlID0gb3ZlcnJpZGUgfHwgbm9kZS50eXBlO1xuICAgICAgYmFzZVZpc2l0b3JbdHlwZV0obm9kZSwgc3QsIGMpO1xuICAgICAgaWYgKCFvdmVycmlkZSkgeyBjYWxsYmFjayhub2RlLCBzdCwgdHlwZSk7IH1cbiAgICB9KShub2RlLCBzdGF0ZSwgb3ZlcnJpZGUpO1xuICB9XG5cbiAgLy8gQW4gZnVsbEFuY2VzdG9yIHdhbGsgaXMgbGlrZSBhbiBhbmNlc3RvciB3YWxrLCBidXQgdHJpZ2dlcnNcbiAgLy8gdGhlIGNhbGxiYWNrIG9uIGVhY2ggbm9kZVxuICBmdW5jdGlvbiBmdWxsQW5jZXN0b3Iobm9kZSwgY2FsbGJhY2ssIGJhc2VWaXNpdG9yLCBzdGF0ZSkge1xuICAgIGlmICghYmFzZVZpc2l0b3IpIHsgYmFzZVZpc2l0b3IgPSBiYXNlOyB9XG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdXG4gICAgOyhmdW5jdGlvbiBjKG5vZGUsIHN0LCBvdmVycmlkZSkge1xuICAgICAgdmFyIHR5cGUgPSBvdmVycmlkZSB8fCBub2RlLnR5cGU7XG4gICAgICB2YXIgaXNOZXcgPSBub2RlICE9PSBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGlzTmV3KSB7IGFuY2VzdG9ycy5wdXNoKG5vZGUpOyB9XG4gICAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgICBpZiAoIW92ZXJyaWRlKSB7IGNhbGxiYWNrKG5vZGUsIHN0IHx8IGFuY2VzdG9ycywgYW5jZXN0b3JzLCB0eXBlKTsgfVxuICAgICAgaWYgKGlzTmV3KSB7IGFuY2VzdG9ycy5wb3AoKTsgfVxuICAgIH0pKG5vZGUsIHN0YXRlKTtcbiAgfVxuXG4gIC8vIEZpbmQgYSBub2RlIHdpdGggYSBnaXZlbiBzdGFydCwgZW5kLCBhbmQgdHlwZSAoYWxsIGFyZSBvcHRpb25hbCxcbiAgLy8gbnVsbCBjYW4gYmUgdXNlZCBhcyB3aWxkY2FyZCkuIFJldHVybnMgYSB7bm9kZSwgc3RhdGV9IG9iamVjdCwgb3JcbiAgLy8gdW5kZWZpbmVkIHdoZW4gaXQgZG9lc24ndCBmaW5kIGEgbWF0Y2hpbmcgbm9kZS5cbiAgZnVuY3Rpb24gZmluZE5vZGVBdChub2RlLCBzdGFydCwgZW5kLCB0ZXN0LCBiYXNlVmlzaXRvciwgc3RhdGUpIHtcbiAgICBpZiAoIWJhc2VWaXNpdG9yKSB7IGJhc2VWaXNpdG9yID0gYmFzZTsgfVxuICAgIHRlc3QgPSBtYWtlVGVzdCh0ZXN0KTtcbiAgICB0cnkge1xuICAgICAgKGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciB0eXBlID0gb3ZlcnJpZGUgfHwgbm9kZS50eXBlO1xuICAgICAgICBpZiAoKHN0YXJ0ID09IG51bGwgfHwgbm9kZS5zdGFydCA8PSBzdGFydCkgJiZcbiAgICAgICAgICAgIChlbmQgPT0gbnVsbCB8fCBub2RlLmVuZCA+PSBlbmQpKVxuICAgICAgICAgIHsgYmFzZVZpc2l0b3JbdHlwZV0obm9kZSwgc3QsIGMpOyB9XG4gICAgICAgIGlmICgoc3RhcnQgPT0gbnVsbCB8fCBub2RlLnN0YXJ0ID09PSBzdGFydCkgJiZcbiAgICAgICAgICAgIChlbmQgPT0gbnVsbCB8fCBub2RlLmVuZCA9PT0gZW5kKSAmJlxuICAgICAgICAgICAgdGVzdCh0eXBlLCBub2RlKSlcbiAgICAgICAgICB7IHRocm93IG5ldyBGb3VuZChub2RlLCBzdCkgfVxuICAgICAgfSkobm9kZSwgc3RhdGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRm91bmQpIHsgcmV0dXJuIGUgfVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGlubmVybW9zdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlblxuICAvLyBwb3NpdGlvbi4gSW50ZXJmYWNlIHNpbWlsYXIgdG8gZmluZE5vZGVBdC5cbiAgZnVuY3Rpb24gZmluZE5vZGVBcm91bmQobm9kZSwgcG9zLCB0ZXN0LCBiYXNlVmlzaXRvciwgc3RhdGUpIHtcbiAgICB0ZXN0ID0gbWFrZVRlc3QodGVzdCk7XG4gICAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2U7IH1cbiAgICB0cnkge1xuICAgICAgKGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciB0eXBlID0gb3ZlcnJpZGUgfHwgbm9kZS50eXBlO1xuICAgICAgICBpZiAobm9kZS5zdGFydCA+IHBvcyB8fCBub2RlLmVuZCA8IHBvcykgeyByZXR1cm4gfVxuICAgICAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgICAgIGlmICh0ZXN0KHR5cGUsIG5vZGUpKSB7IHRocm93IG5ldyBGb3VuZChub2RlLCBzdCkgfVxuICAgICAgfSkobm9kZSwgc3RhdGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRm91bmQpIHsgcmV0dXJuIGUgfVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIG91dGVybW9zdCBtYXRjaGluZyBub2RlIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24uXG4gIGZ1bmN0aW9uIGZpbmROb2RlQWZ0ZXIobm9kZSwgcG9zLCB0ZXN0LCBiYXNlVmlzaXRvciwgc3RhdGUpIHtcbiAgICB0ZXN0ID0gbWFrZVRlc3QodGVzdCk7XG4gICAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2U7IH1cbiAgICB0cnkge1xuICAgICAgKGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICAgIGlmIChub2RlLmVuZCA8IHBvcykgeyByZXR1cm4gfVxuICAgICAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZTtcbiAgICAgICAgaWYgKG5vZGUuc3RhcnQgPj0gcG9zICYmIHRlc3QodHlwZSwgbm9kZSkpIHsgdGhyb3cgbmV3IEZvdW5kKG5vZGUsIHN0KSB9XG4gICAgICAgIGJhc2VWaXNpdG9yW3R5cGVdKG5vZGUsIHN0LCBjKTtcbiAgICAgIH0pKG5vZGUsIHN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEZvdW5kKSB7IHJldHVybiBlIH1cbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBvdXRlcm1vc3QgbWF0Y2hpbmcgbm9kZSBiZWZvcmUgYSBnaXZlbiBwb3NpdGlvbi5cbiAgZnVuY3Rpb24gZmluZE5vZGVCZWZvcmUobm9kZSwgcG9zLCB0ZXN0LCBiYXNlVmlzaXRvciwgc3RhdGUpIHtcbiAgICB0ZXN0ID0gbWFrZVRlc3QodGVzdCk7XG4gICAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2U7IH1cbiAgICB2YXIgbWF4XG4gICAgOyhmdW5jdGlvbiBjKG5vZGUsIHN0LCBvdmVycmlkZSkge1xuICAgICAgaWYgKG5vZGUuc3RhcnQgPiBwb3MpIHsgcmV0dXJuIH1cbiAgICAgIHZhciB0eXBlID0gb3ZlcnJpZGUgfHwgbm9kZS50eXBlO1xuICAgICAgaWYgKG5vZGUuZW5kIDw9IHBvcyAmJiAoIW1heCB8fCBtYXgubm9kZS5lbmQgPCBub2RlLmVuZCkgJiYgdGVzdCh0eXBlLCBub2RlKSlcbiAgICAgICAgeyBtYXggPSBuZXcgRm91bmQobm9kZSwgc3QpOyB9XG4gICAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgfSkobm9kZSwgc3RhdGUpO1xuICAgIHJldHVybiBtYXhcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGFuIE9iamVjdC5jcmVhdGUgcG9seWZpbGwgZm9yIG9sZGVyIGVudmlyb25tZW50cy5cbiAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBmdW5jdGlvbiBDdG9yKCkge31cbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHJldHVybiBuZXcgQ3RvclxuICB9O1xuXG4gIC8vIFVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIHdhbGtlci4gV2lsbCBmaWxsIGluIGFsbCBtaXNzaW5nIG5vZGVcbiAgLy8gdHlwZSBwcm9wZXJ0aWVzIHdpdGggdGhlIGRlZmF1bHRzLlxuICBmdW5jdGlvbiBtYWtlKGZ1bmNzLCBiYXNlVmlzaXRvcikge1xuICAgIHZhciB2aXNpdG9yID0gY3JlYXRlKGJhc2VWaXNpdG9yIHx8IGJhc2UpO1xuICAgIGZvciAodmFyIHR5cGUgaW4gZnVuY3MpIHsgdmlzaXRvclt0eXBlXSA9IGZ1bmNzW3R5cGVdOyB9XG4gICAgcmV0dXJuIHZpc2l0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBUaHJvdWdoKG5vZGUsIHN0LCBjKSB7IGMobm9kZSwgc3QpOyB9XG4gIGZ1bmN0aW9uIGlnbm9yZShfbm9kZSwgX3N0LCBfYykge31cblxuICAvLyBOb2RlIHdhbGtlcnMuXG5cbiAgdmFyIGJhc2UgPSB7fTtcblxuICBiYXNlLlByb2dyYW0gPSBiYXNlLkJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmJvZHk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHN0bXQgPSBsaXN0W2ldO1xuXG4gICAgICBjKHN0bXQsIHN0LCBcIlN0YXRlbWVudFwiKTtcbiAgICB9XG4gIH07XG4gIGJhc2UuU3RhdGVtZW50ID0gc2tpcFRocm91Z2g7XG4gIGJhc2UuRW1wdHlTdGF0ZW1lbnQgPSBpZ25vcmU7XG4gIGJhc2UuRXhwcmVzc2lvblN0YXRlbWVudCA9IGJhc2UuUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPVxuICAgIGZ1bmN0aW9uIChub2RlLCBzdCwgYykgeyByZXR1cm4gYyhub2RlLmV4cHJlc3Npb24sIHN0LCBcIkV4cHJlc3Npb25cIik7IH07XG4gIGJhc2UuSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICBjKG5vZGUuY29uc2VxdWVudCwgc3QsIFwiU3RhdGVtZW50XCIpO1xuICAgIGlmIChub2RlLmFsdGVybmF0ZSkgeyBjKG5vZGUuYWx0ZXJuYXRlLCBzdCwgXCJTdGF0ZW1lbnRcIik7IH1cbiAgfTtcbiAgYmFzZS5MYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUuYm9keSwgc3QsIFwiU3RhdGVtZW50XCIpOyB9O1xuICBiYXNlLkJyZWFrU3RhdGVtZW50ID0gYmFzZS5Db250aW51ZVN0YXRlbWVudCA9IGlnbm9yZTtcbiAgYmFzZS5XaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgYyhub2RlLm9iamVjdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICBjKG5vZGUuYm9keSwgc3QsIFwiU3RhdGVtZW50XCIpO1xuICB9O1xuICBiYXNlLlN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGMobm9kZS5kaXNjcmltaW5hbnQsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gbm9kZS5jYXNlczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBjcyA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoY3MudGVzdCkgeyBjKGNzLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gY3MuY29uc2VxdWVudDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgdmFyIGNvbnMgPSBsaXN0W2ldO1xuXG4gICAgICAgIGMoY29ucywgc3QsIFwiU3RhdGVtZW50XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgYmFzZS5Td2l0Y2hDYXNlID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgaWYgKG5vZGUudGVzdCkgeyBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5jb25zZXF1ZW50OyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBjb25zID0gbGlzdFtpXTtcblxuICAgICAgYyhjb25zLCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gICAgfVxuICB9O1xuICBiYXNlLlJldHVyblN0YXRlbWVudCA9IGJhc2UuWWllbGRFeHByZXNzaW9uID0gYmFzZS5Bd2FpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBpZiAobm9kZS5hcmd1bWVudCkgeyBjKG5vZGUuYXJndW1lbnQsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgfTtcbiAgYmFzZS5UaHJvd1N0YXRlbWVudCA9IGJhc2UuU3ByZWFkRWxlbWVudCA9XG4gICAgZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUuYXJndW1lbnQsIHN0LCBcIkV4cHJlc3Npb25cIik7IH07XG4gIGJhc2UuVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgYyhub2RlLmJsb2NrLCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gICAgaWYgKG5vZGUuaGFuZGxlcikgeyBjKG5vZGUuaGFuZGxlciwgc3QpOyB9XG4gICAgaWYgKG5vZGUuZmluYWxpemVyKSB7IGMobm9kZS5maW5hbGl6ZXIsIHN0LCBcIlN0YXRlbWVudFwiKTsgfVxuICB9O1xuICBiYXNlLkNhdGNoQ2xhdXNlID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgaWYgKG5vZGUucGFyYW0pIHsgYyhub2RlLnBhcmFtLCBzdCwgXCJQYXR0ZXJuXCIpOyB9XG4gICAgYyhub2RlLmJvZHksIHN0LCBcIlN0YXRlbWVudFwiKTtcbiAgfTtcbiAgYmFzZS5XaGlsZVN0YXRlbWVudCA9IGJhc2UuRG9XaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGMobm9kZS50ZXN0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgIGMobm9kZS5ib2R5LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gIH07XG4gIGJhc2UuRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgaWYgKG5vZGUuaW5pdCkgeyBjKG5vZGUuaW5pdCwgc3QsIFwiRm9ySW5pdFwiKTsgfVxuICAgIGlmIChub2RlLnRlc3QpIHsgYyhub2RlLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgICBpZiAobm9kZS51cGRhdGUpIHsgYyhub2RlLnVwZGF0ZSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICAgIGMobm9kZS5ib2R5LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gIH07XG4gIGJhc2UuRm9ySW5TdGF0ZW1lbnQgPSBiYXNlLkZvck9mU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgYyhub2RlLmxlZnQsIHN0LCBcIkZvckluaXRcIik7XG4gICAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgIGMobm9kZS5ib2R5LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gIH07XG4gIGJhc2UuRm9ySW5pdCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7IGMobm9kZSwgc3QpOyB9XG4gICAgZWxzZSB7IGMobm9kZSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICB9O1xuICBiYXNlLkRlYnVnZ2VyU3RhdGVtZW50ID0gaWdub3JlO1xuXG4gIGJhc2UuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykgeyByZXR1cm4gYyhub2RlLCBzdCwgXCJGdW5jdGlvblwiKTsgfTtcbiAgYmFzZS5WYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmRlY2xhcmF0aW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICAgIGMoZGVjbCwgc3QpO1xuICAgIH1cbiAgfTtcbiAgYmFzZS5WYXJpYWJsZURlY2xhcmF0b3IgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBjKG5vZGUuaWQsIHN0LCBcIlBhdHRlcm5cIik7XG4gICAgaWYgKG5vZGUuaW5pdCkgeyBjKG5vZGUuaW5pdCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICB9O1xuXG4gIGJhc2UuRnVuY3Rpb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBpZiAobm9kZS5pZCkgeyBjKG5vZGUuaWQsIHN0LCBcIlBhdHRlcm5cIik7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGMocGFyYW0sIHN0LCBcIlBhdHRlcm5cIik7XG4gICAgfVxuICAgIGMobm9kZS5ib2R5LCBzdCwgbm9kZS5leHByZXNzaW9uID8gXCJFeHByZXNzaW9uXCIgOiBcIlN0YXRlbWVudFwiKTtcbiAgfTtcblxuICBiYXNlLlBhdHRlcm4gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgYyhub2RlLCBzdCwgXCJWYXJpYWJsZVBhdHRlcm5cIik7IH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgICAgeyBjKG5vZGUsIHN0LCBcIk1lbWJlclBhdHRlcm5cIik7IH1cbiAgICBlbHNlXG4gICAgICB7IGMobm9kZSwgc3QpOyB9XG4gIH07XG4gIGJhc2UuVmFyaWFibGVQYXR0ZXJuID0gaWdub3JlO1xuICBiYXNlLk1lbWJlclBhdHRlcm4gPSBza2lwVGhyb3VnaDtcbiAgYmFzZS5SZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykgeyByZXR1cm4gYyhub2RlLmFyZ3VtZW50LCBzdCwgXCJQYXR0ZXJuXCIpOyB9O1xuICBiYXNlLkFycmF5UGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5lbGVtZW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoZWx0KSB7IGMoZWx0LCBzdCwgXCJQYXR0ZXJuXCIpOyB9XG4gICAgfVxuICB9O1xuICBiYXNlLk9iamVjdFBhdHRlcm4gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgaWYgKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiKSB7XG4gICAgICAgIGlmIChwcm9wLmNvbXB1dGVkKSB7IGMocHJvcC5rZXksIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgICAgICAgYyhwcm9wLnZhbHVlLCBzdCwgXCJQYXR0ZXJuXCIpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICBjKHByb3AuYXJndW1lbnQsIHN0LCBcIlBhdHRlcm5cIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGJhc2UuRXhwcmVzc2lvbiA9IHNraXBUaHJvdWdoO1xuICBiYXNlLlRoaXNFeHByZXNzaW9uID0gYmFzZS5TdXBlciA9IGJhc2UuTWV0YVByb3BlcnR5ID0gaWdub3JlO1xuICBiYXNlLkFycmF5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5lbGVtZW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoZWx0KSB7IGMoZWx0LCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gICAgfVxuICB9O1xuICBiYXNlLk9iamVjdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIGMocHJvcCwgc3QpO1xuICAgIH1cbiAgfTtcbiAgYmFzZS5GdW5jdGlvbkV4cHJlc3Npb24gPSBiYXNlLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gYmFzZS5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuICBiYXNlLlNlcXVlbmNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5leHByZXNzaW9uczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgZXhwciA9IGxpc3RbaV07XG5cbiAgICAgIGMoZXhwciwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH07XG4gIGJhc2UuVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnF1YXNpczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcXVhc2kgPSBsaXN0W2ldO1xuXG4gICAgICBjKHF1YXNpLCBzdCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gbm9kZS5leHByZXNzaW9uczsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgZXhwciA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBjKGV4cHIsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9O1xuICBiYXNlLlRlbXBsYXRlRWxlbWVudCA9IGlnbm9yZTtcbiAgYmFzZS5VbmFyeUV4cHJlc3Npb24gPSBiYXNlLlVwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBjKG5vZGUuYXJndW1lbnQsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIH07XG4gIGJhc2UuQmluYXJ5RXhwcmVzc2lvbiA9IGJhc2UuTG9naWNhbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBjKG5vZGUubGVmdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICBjKG5vZGUucmlnaHQsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIH07XG4gIGJhc2UuQXNzaWdubWVudEV4cHJlc3Npb24gPSBiYXNlLkFzc2lnbm1lbnRQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgYyhub2RlLmxlZnQsIHN0LCBcIlBhdHRlcm5cIik7XG4gICAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICB9O1xuICBiYXNlLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICAgIGMobm9kZS50ZXN0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgIGMobm9kZS5jb25zZXF1ZW50LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgIGMobm9kZS5hbHRlcm5hdGUsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIH07XG4gIGJhc2UuTmV3RXhwcmVzc2lvbiA9IGJhc2UuQ2FsbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBjKG5vZGUuY2FsbGVlLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgIGlmIChub2RlLmFyZ3VtZW50cylcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmFyZ3VtZW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcblxuICAgICAgICAgIGMoYXJnLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICB9IH1cbiAgfTtcbiAgYmFzZS5NZW1iZXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgYyhub2RlLm9iamVjdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICBpZiAobm9kZS5jb21wdXRlZCkgeyBjKG5vZGUucHJvcGVydHksIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgfTtcbiAgYmFzZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gYmFzZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbilcbiAgICAgIHsgYyhub2RlLmRlY2xhcmF0aW9uLCBzdCwgbm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiB8fCBub2RlLmRlY2xhcmF0aW9uLmlkID8gXCJTdGF0ZW1lbnRcIiA6IFwiRXhwcmVzc2lvblwiKTsgfVxuICAgIGlmIChub2RlLnNvdXJjZSkgeyBjKG5vZGUuc291cmNlLCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gIH07XG4gIGJhc2UuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgICBjKG5vZGUuc291cmNlLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICB9O1xuICBiYXNlLkltcG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICBjKHNwZWMsIHN0KTtcbiAgICB9XG4gICAgYyhub2RlLnNvdXJjZSwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgfTtcbiAgYmFzZS5JbXBvcnRTcGVjaWZpZXIgPSBiYXNlLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBiYXNlLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGJhc2UuSWRlbnRpZmllciA9IGJhc2UuTGl0ZXJhbCA9IGJhc2UuSW1wb3J0ID0gaWdub3JlO1xuXG4gIGJhc2UuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgYyhub2RlLnRhZywgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICBjKG5vZGUucXVhc2ksIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIH07XG4gIGJhc2UuQ2xhc3NEZWNsYXJhdGlvbiA9IGJhc2UuQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUsIHN0LCBcIkNsYXNzXCIpOyB9O1xuICBiYXNlLkNsYXNzID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgaWYgKG5vZGUuaWQpIHsgYyhub2RlLmlkLCBzdCwgXCJQYXR0ZXJuXCIpOyB9XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcykgeyBjKG5vZGUuc3VwZXJDbGFzcywgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICAgIGMobm9kZS5ib2R5LCBzdCk7XG4gIH07XG4gIGJhc2UuQ2xhc3NCb2R5ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmJvZHk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGVsdCA9IGxpc3RbaV07XG5cbiAgICAgIGMoZWx0LCBzdCk7XG4gICAgfVxuICB9O1xuICBiYXNlLk1ldGhvZERlZmluaXRpb24gPSBiYXNlLlByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHsgYyhub2RlLmtleSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICAgIGMobm9kZS52YWx1ZSwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgfTtcblxuICBleHBvcnRzLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gIGV4cG9ydHMuYmFzZSA9IGJhc2U7XG4gIGV4cG9ydHMuZmluZE5vZGVBZnRlciA9IGZpbmROb2RlQWZ0ZXI7XG4gIGV4cG9ydHMuZmluZE5vZGVBcm91bmQgPSBmaW5kTm9kZUFyb3VuZDtcbiAgZXhwb3J0cy5maW5kTm9kZUF0ID0gZmluZE5vZGVBdDtcbiAgZXhwb3J0cy5maW5kTm9kZUJlZm9yZSA9IGZpbmROb2RlQmVmb3JlO1xuICBleHBvcnRzLmZ1bGwgPSBmdWxsO1xuICBleHBvcnRzLmZ1bGxBbmNlc3RvciA9IGZ1bGxBbmNlc3RvcjtcbiAgZXhwb3J0cy5tYWtlID0gbWFrZTtcbiAgZXhwb3J0cy5yZWN1cnNpdmUgPSByZWN1cnNpdmU7XG4gIGV4cG9ydHMuc2ltcGxlID0gc2ltcGxlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tern/node_modules/acorn-walk/dist/walk.js\n");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn-walk/dist/walk.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn-walk/dist/walk.mjs ***!
  \*****************************************************************/
/*! exports provided: ancestor, base, findNodeAfter, findNodeAround, findNodeAt, findNodeBefore, full, fullAncestor, make, recursive, simple */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ancestor\", function() { return ancestor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"base\", function() { return base; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNodeAfter\", function() { return findNodeAfter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNodeAround\", function() { return findNodeAround; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNodeAt\", function() { return findNodeAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNodeBefore\", function() { return findNodeBefore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"full\", function() { return full; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fullAncestor\", function() { return fullAncestor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"make\", function() { return make; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"recursive\", function() { return recursive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"simple\", function() { return simple; });\n// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n    {\n    var quasi = list[i];\n\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n    {\n    var expr = list$1[i$1];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4td2Fsay9kaXN0L3dhbGsubWpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rlcm4vbm9kZV9tb2R1bGVzL2Fjb3JuLXdhbGsvZGlzdC93YWxrLm1qcz9jNzY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFTVCB3YWxrZXIgbW9kdWxlIGZvciBNb3ppbGxhIFBhcnNlciBBUEkgY29tcGF0aWJsZSB0cmVlc1xuXG4vLyBBIHNpbXBsZSB3YWxrIGlzIG9uZSB3aGVyZSB5b3Ugc2ltcGx5IHNwZWNpZnkgY2FsbGJhY2tzIHRvIGJlXG4vLyBjYWxsZWQgb24gc3BlY2lmaWMgbm9kZXMuIFRoZSBsYXN0IHR3byBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiBBXG4vLyBzaW1wbGUgdXNlIHdvdWxkIGJlXG4vL1xuLy8gICAgIHdhbGsuc2ltcGxlKG15VHJlZSwge1xuLy8gICAgICAgICBFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlKSB7IC4uLiB9XG4vLyAgICAgfSk7XG4vL1xuLy8gdG8gZG8gc29tZXRoaW5nIHdpdGggYWxsIGV4cHJlc3Npb25zLiBBbGwgUGFyc2VyIEFQSSBub2RlIHR5cGVzXG4vLyBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBub2RlIHR5cGVzLCBhcyB3ZWxsIGFzIEV4cHJlc3Npb24gYW5kXG4vLyBTdGF0ZW1lbnQsIHdoaWNoIGRlbm90ZSBjYXRlZ29yaWVzIG9mIG5vZGVzLlxuLy9cbi8vIFRoZSBiYXNlIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIHBhc3MgYSBjdXN0b20gKHJlY3Vyc2l2ZSlcbi8vIHdhbGtlciwgYW5kIHN0YXRlIGNhbiBiZSB1c2VkIHRvIGdpdmUgdGhpcyB3YWxrZWQgYW4gaW5pdGlhbFxuLy8gc3RhdGUuXG5cbmZ1bmN0aW9uIHNpbXBsZShub2RlLCB2aXNpdG9ycywgYmFzZVZpc2l0b3IsIHN0YXRlLCBvdmVycmlkZSkge1xuICBpZiAoIWJhc2VWaXNpdG9yKSB7IGJhc2VWaXNpdG9yID0gYmFzZVxuICA7IH0oZnVuY3Rpb24gYyhub2RlLCBzdCwgb3ZlcnJpZGUpIHtcbiAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZSwgZm91bmQgPSB2aXNpdG9yc1t0eXBlXTtcbiAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgaWYgKGZvdW5kKSB7IGZvdW5kKG5vZGUsIHN0KTsgfVxuICB9KShub2RlLCBzdGF0ZSwgb3ZlcnJpZGUpO1xufVxuXG4vLyBBbiBhbmNlc3RvciB3YWxrIGtlZXBzIGFuIGFycmF5IG9mIGFuY2VzdG9yIG5vZGVzIChpbmNsdWRpbmcgdGhlXG4vLyBjdXJyZW50IG5vZGUpIGFuZCBwYXNzZXMgdGhlbSB0byB0aGUgY2FsbGJhY2sgYXMgdGhpcmQgcGFyYW1ldGVyXG4vLyAoYW5kIGFsc28gYXMgc3RhdGUgcGFyYW1ldGVyIHdoZW4gbm8gb3RoZXIgc3RhdGUgaXMgcHJlc2VudCkuXG5mdW5jdGlvbiBhbmNlc3Rvcihub2RlLCB2aXNpdG9ycywgYmFzZVZpc2l0b3IsIHN0YXRlKSB7XG4gIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2VcbiAgOyB9KGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgdmFyIHR5cGUgPSBvdmVycmlkZSB8fCBub2RlLnR5cGUsIGZvdW5kID0gdmlzaXRvcnNbdHlwZV07XG4gICAgdmFyIGlzTmV3ID0gbm9kZSAhPT0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNOZXcpIHsgYW5jZXN0b3JzLnB1c2gobm9kZSk7IH1cbiAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgaWYgKGZvdW5kKSB7IGZvdW5kKG5vZGUsIHN0IHx8IGFuY2VzdG9ycywgYW5jZXN0b3JzKTsgfVxuICAgIGlmIChpc05ldykgeyBhbmNlc3RvcnMucG9wKCk7IH1cbiAgfSkobm9kZSwgc3RhdGUpO1xufVxuXG4vLyBBIHJlY3Vyc2l2ZSB3YWxrIGlzIG9uZSB3aGVyZSB5b3VyIGZ1bmN0aW9ucyBvdmVycmlkZSB0aGUgZGVmYXVsdFxuLy8gd2Fsa2Vycy4gVGhleSBjYW4gbW9kaWZ5IGFuZCByZXBsYWNlIHRoZSBzdGF0ZSBwYXJhbWV0ZXIgdGhhdCdzXG4vLyB0aHJlYWRlZCB0aHJvdWdoIHRoZSB3YWxrLCBhbmQgY2FuIG9wdCBob3cgYW5kIHdoZXRoZXIgdG8gd2Fsa1xuLy8gdGhlaXIgY2hpbGQgbm9kZXMgKGJ5IGNhbGxpbmcgdGhlaXIgdGhpcmQgYXJndW1lbnQgb24gdGhlc2Vcbi8vIG5vZGVzKS5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZShub2RlLCBzdGF0ZSwgZnVuY3MsIGJhc2VWaXNpdG9yLCBvdmVycmlkZSkge1xuICB2YXIgdmlzaXRvciA9IGZ1bmNzID8gbWFrZShmdW5jcywgYmFzZVZpc2l0b3IgfHwgdW5kZWZpbmVkKSA6IGJhc2VWaXNpdG9yXG4gIDsoZnVuY3Rpb24gYyhub2RlLCBzdCwgb3ZlcnJpZGUpIHtcbiAgICB2aXNpdG9yW292ZXJyaWRlIHx8IG5vZGUudHlwZV0obm9kZSwgc3QsIGMpO1xuICB9KShub2RlLCBzdGF0ZSwgb3ZlcnJpZGUpO1xufVxuXG5mdW5jdGlvbiBtYWtlVGVzdCh0ZXN0KSB7XG4gIGlmICh0eXBlb2YgdGVzdCA9PT0gXCJzdHJpbmdcIilcbiAgICB7IHJldHVybiBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSA9PT0gdGVzdDsgfSB9XG4gIGVsc2UgaWYgKCF0ZXN0KVxuICAgIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0gfVxuICBlbHNlXG4gICAgeyByZXR1cm4gdGVzdCB9XG59XG5cbnZhciBGb3VuZCA9IGZ1bmN0aW9uIEZvdW5kKG5vZGUsIHN0YXRlKSB7IHRoaXMubm9kZSA9IG5vZGU7IHRoaXMuc3RhdGUgPSBzdGF0ZTsgfTtcblxuLy8gQSBmdWxsIHdhbGsgdHJpZ2dlcnMgdGhlIGNhbGxiYWNrIG9uIGVhY2ggbm9kZVxuZnVuY3Rpb24gZnVsbChub2RlLCBjYWxsYmFjaywgYmFzZVZpc2l0b3IsIHN0YXRlLCBvdmVycmlkZSkge1xuICBpZiAoIWJhc2VWaXNpdG9yKSB7IGJhc2VWaXNpdG9yID0gYmFzZVxuICA7IH0oZnVuY3Rpb24gYyhub2RlLCBzdCwgb3ZlcnJpZGUpIHtcbiAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZTtcbiAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgaWYgKCFvdmVycmlkZSkgeyBjYWxsYmFjayhub2RlLCBzdCwgdHlwZSk7IH1cbiAgfSkobm9kZSwgc3RhdGUsIG92ZXJyaWRlKTtcbn1cblxuLy8gQW4gZnVsbEFuY2VzdG9yIHdhbGsgaXMgbGlrZSBhbiBhbmNlc3RvciB3YWxrLCBidXQgdHJpZ2dlcnNcbi8vIHRoZSBjYWxsYmFjayBvbiBlYWNoIG5vZGVcbmZ1bmN0aW9uIGZ1bGxBbmNlc3Rvcihub2RlLCBjYWxsYmFjaywgYmFzZVZpc2l0b3IsIHN0YXRlKSB7XG4gIGlmICghYmFzZVZpc2l0b3IpIHsgYmFzZVZpc2l0b3IgPSBiYXNlOyB9XG4gIHZhciBhbmNlc3RvcnMgPSBbXVxuICA7KGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgdmFyIHR5cGUgPSBvdmVycmlkZSB8fCBub2RlLnR5cGU7XG4gICAgdmFyIGlzTmV3ID0gbm9kZSAhPT0gYW5jZXN0b3JzW2FuY2VzdG9ycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNOZXcpIHsgYW5jZXN0b3JzLnB1c2gobm9kZSk7IH1cbiAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgaWYgKCFvdmVycmlkZSkgeyBjYWxsYmFjayhub2RlLCBzdCB8fCBhbmNlc3RvcnMsIGFuY2VzdG9ycywgdHlwZSk7IH1cbiAgICBpZiAoaXNOZXcpIHsgYW5jZXN0b3JzLnBvcCgpOyB9XG4gIH0pKG5vZGUsIHN0YXRlKTtcbn1cblxuLy8gRmluZCBhIG5vZGUgd2l0aCBhIGdpdmVuIHN0YXJ0LCBlbmQsIGFuZCB0eXBlIChhbGwgYXJlIG9wdGlvbmFsLFxuLy8gbnVsbCBjYW4gYmUgdXNlZCBhcyB3aWxkY2FyZCkuIFJldHVybnMgYSB7bm9kZSwgc3RhdGV9IG9iamVjdCwgb3Jcbi8vIHVuZGVmaW5lZCB3aGVuIGl0IGRvZXNuJ3QgZmluZCBhIG1hdGNoaW5nIG5vZGUuXG5mdW5jdGlvbiBmaW5kTm9kZUF0KG5vZGUsIHN0YXJ0LCBlbmQsIHRlc3QsIGJhc2VWaXNpdG9yLCBzdGF0ZSkge1xuICBpZiAoIWJhc2VWaXNpdG9yKSB7IGJhc2VWaXNpdG9yID0gYmFzZTsgfVxuICB0ZXN0ID0gbWFrZVRlc3QodGVzdCk7XG4gIHRyeSB7XG4gICAgKGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZTtcbiAgICAgIGlmICgoc3RhcnQgPT0gbnVsbCB8fCBub2RlLnN0YXJ0IDw9IHN0YXJ0KSAmJlxuICAgICAgICAgIChlbmQgPT0gbnVsbCB8fCBub2RlLmVuZCA+PSBlbmQpKVxuICAgICAgICB7IGJhc2VWaXNpdG9yW3R5cGVdKG5vZGUsIHN0LCBjKTsgfVxuICAgICAgaWYgKChzdGFydCA9PSBudWxsIHx8IG5vZGUuc3RhcnQgPT09IHN0YXJ0KSAmJlxuICAgICAgICAgIChlbmQgPT0gbnVsbCB8fCBub2RlLmVuZCA9PT0gZW5kKSAmJlxuICAgICAgICAgIHRlc3QodHlwZSwgbm9kZSkpXG4gICAgICAgIHsgdGhyb3cgbmV3IEZvdW5kKG5vZGUsIHN0KSB9XG4gICAgfSkobm9kZSwgc3RhdGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBGb3VuZCkgeyByZXR1cm4gZSB9XG4gICAgdGhyb3cgZVxuICB9XG59XG5cbi8vIEZpbmQgdGhlIGlubmVybW9zdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSB0aGF0IGNvbnRhaW5zIHRoZSBnaXZlblxuLy8gcG9zaXRpb24uIEludGVyZmFjZSBzaW1pbGFyIHRvIGZpbmROb2RlQXQuXG5mdW5jdGlvbiBmaW5kTm9kZUFyb3VuZChub2RlLCBwb3MsIHRlc3QsIGJhc2VWaXNpdG9yLCBzdGF0ZSkge1xuICB0ZXN0ID0gbWFrZVRlc3QodGVzdCk7XG4gIGlmICghYmFzZVZpc2l0b3IpIHsgYmFzZVZpc2l0b3IgPSBiYXNlOyB9XG4gIHRyeSB7XG4gICAgKGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZTtcbiAgICAgIGlmIChub2RlLnN0YXJ0ID4gcG9zIHx8IG5vZGUuZW5kIDwgcG9zKSB7IHJldHVybiB9XG4gICAgICBiYXNlVmlzaXRvclt0eXBlXShub2RlLCBzdCwgYyk7XG4gICAgICBpZiAodGVzdCh0eXBlLCBub2RlKSkgeyB0aHJvdyBuZXcgRm91bmQobm9kZSwgc3QpIH1cbiAgICB9KShub2RlLCBzdGF0ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIEZvdW5kKSB7IHJldHVybiBlIH1cbiAgICB0aHJvdyBlXG4gIH1cbn1cblxuLy8gRmluZCB0aGUgb3V0ZXJtb3N0IG1hdGNoaW5nIG5vZGUgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbi5cbmZ1bmN0aW9uIGZpbmROb2RlQWZ0ZXIobm9kZSwgcG9zLCB0ZXN0LCBiYXNlVmlzaXRvciwgc3RhdGUpIHtcbiAgdGVzdCA9IG1ha2VUZXN0KHRlc3QpO1xuICBpZiAoIWJhc2VWaXNpdG9yKSB7IGJhc2VWaXNpdG9yID0gYmFzZTsgfVxuICB0cnkge1xuICAgIChmdW5jdGlvbiBjKG5vZGUsIHN0LCBvdmVycmlkZSkge1xuICAgICAgaWYgKG5vZGUuZW5kIDwgcG9zKSB7IHJldHVybiB9XG4gICAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZTtcbiAgICAgIGlmIChub2RlLnN0YXJ0ID49IHBvcyAmJiB0ZXN0KHR5cGUsIG5vZGUpKSB7IHRocm93IG5ldyBGb3VuZChub2RlLCBzdCkgfVxuICAgICAgYmFzZVZpc2l0b3JbdHlwZV0obm9kZSwgc3QsIGMpO1xuICAgIH0pKG5vZGUsIHN0YXRlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgRm91bmQpIHsgcmV0dXJuIGUgfVxuICAgIHRocm93IGVcbiAgfVxufVxuXG4vLyBGaW5kIHRoZSBvdXRlcm1vc3QgbWF0Y2hpbmcgbm9kZSBiZWZvcmUgYSBnaXZlbiBwb3NpdGlvbi5cbmZ1bmN0aW9uIGZpbmROb2RlQmVmb3JlKG5vZGUsIHBvcywgdGVzdCwgYmFzZVZpc2l0b3IsIHN0YXRlKSB7XG4gIHRlc3QgPSBtYWtlVGVzdCh0ZXN0KTtcbiAgaWYgKCFiYXNlVmlzaXRvcikgeyBiYXNlVmlzaXRvciA9IGJhc2U7IH1cbiAgdmFyIG1heFxuICA7KGZ1bmN0aW9uIGMobm9kZSwgc3QsIG92ZXJyaWRlKSB7XG4gICAgaWYgKG5vZGUuc3RhcnQgPiBwb3MpIHsgcmV0dXJuIH1cbiAgICB2YXIgdHlwZSA9IG92ZXJyaWRlIHx8IG5vZGUudHlwZTtcbiAgICBpZiAobm9kZS5lbmQgPD0gcG9zICYmICghbWF4IHx8IG1heC5ub2RlLmVuZCA8IG5vZGUuZW5kKSAmJiB0ZXN0KHR5cGUsIG5vZGUpKVxuICAgICAgeyBtYXggPSBuZXcgRm91bmQobm9kZSwgc3QpOyB9XG4gICAgYmFzZVZpc2l0b3JbdHlwZV0obm9kZSwgc3QsIGMpO1xuICB9KShub2RlLCBzdGF0ZSk7XG4gIHJldHVybiBtYXhcbn1cblxuLy8gRmFsbGJhY2sgdG8gYW4gT2JqZWN0LmNyZWF0ZSBwb2x5ZmlsbCBmb3Igb2xkZXIgZW52aXJvbm1lbnRzLlxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24ocHJvdG8pIHtcbiAgZnVuY3Rpb24gQ3RvcigpIHt9XG4gIEN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgQ3RvclxufTtcblxuLy8gVXNlZCB0byBjcmVhdGUgYSBjdXN0b20gd2Fsa2VyLiBXaWxsIGZpbGwgaW4gYWxsIG1pc3Npbmcgbm9kZVxuLy8gdHlwZSBwcm9wZXJ0aWVzIHdpdGggdGhlIGRlZmF1bHRzLlxuZnVuY3Rpb24gbWFrZShmdW5jcywgYmFzZVZpc2l0b3IpIHtcbiAgdmFyIHZpc2l0b3IgPSBjcmVhdGUoYmFzZVZpc2l0b3IgfHwgYmFzZSk7XG4gIGZvciAodmFyIHR5cGUgaW4gZnVuY3MpIHsgdmlzaXRvclt0eXBlXSA9IGZ1bmNzW3R5cGVdOyB9XG4gIHJldHVybiB2aXNpdG9yXG59XG5cbmZ1bmN0aW9uIHNraXBUaHJvdWdoKG5vZGUsIHN0LCBjKSB7IGMobm9kZSwgc3QpOyB9XG5mdW5jdGlvbiBpZ25vcmUoX25vZGUsIF9zdCwgX2MpIHt9XG5cbi8vIE5vZGUgd2Fsa2Vycy5cblxudmFyIGJhc2UgPSB7fTtcblxuYmFzZS5Qcm9ncmFtID0gYmFzZS5CbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuYm9keTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBzdG10ID0gbGlzdFtpXTtcblxuICAgIGMoc3RtdCwgc3QsIFwiU3RhdGVtZW50XCIpO1xuICB9XG59O1xuYmFzZS5TdGF0ZW1lbnQgPSBza2lwVGhyb3VnaDtcbmJhc2UuRW1wdHlTdGF0ZW1lbnQgPSBpZ25vcmU7XG5iYXNlLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBiYXNlLlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID1cbiAgZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUuZXhwcmVzc2lvbiwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfTtcbmJhc2UuSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgYyhub2RlLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGMobm9kZS5jb25zZXF1ZW50LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG4gIGlmIChub2RlLmFsdGVybmF0ZSkgeyBjKG5vZGUuYWx0ZXJuYXRlLCBzdCwgXCJTdGF0ZW1lbnRcIik7IH1cbn07XG5iYXNlLkxhYmVsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHsgcmV0dXJuIGMobm9kZS5ib2R5LCBzdCwgXCJTdGF0ZW1lbnRcIik7IH07XG5iYXNlLkJyZWFrU3RhdGVtZW50ID0gYmFzZS5Db250aW51ZVN0YXRlbWVudCA9IGlnbm9yZTtcbmJhc2UuV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUub2JqZWN0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUuYm9keSwgc3QsIFwiU3RhdGVtZW50XCIpO1xufTtcbmJhc2UuU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5kaXNjcmltaW5hbnQsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IG5vZGUuY2FzZXM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgdmFyIGNzID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoY3MudGVzdCkgeyBjKGNzLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNzLmNvbnNlcXVlbnQ7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGNvbnMgPSBsaXN0W2ldO1xuXG4gICAgICBjKGNvbnMsIHN0LCBcIlN0YXRlbWVudFwiKTtcbiAgICB9XG4gIH1cbn07XG5iYXNlLlN3aXRjaENhc2UgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgaWYgKG5vZGUudGVzdCkgeyBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuY29uc2VxdWVudDsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBjb25zID0gbGlzdFtpXTtcblxuICAgIGMoY29ucywgc3QsIFwiU3RhdGVtZW50XCIpO1xuICB9XG59O1xuYmFzZS5SZXR1cm5TdGF0ZW1lbnQgPSBiYXNlLllpZWxkRXhwcmVzc2lvbiA9IGJhc2UuQXdhaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLmFyZ3VtZW50KSB7IGMobm9kZS5hcmd1bWVudCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxufTtcbmJhc2UuVGhyb3dTdGF0ZW1lbnQgPSBiYXNlLlNwcmVhZEVsZW1lbnQgPVxuICBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHsgcmV0dXJuIGMobm9kZS5hcmd1bWVudCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfTtcbmJhc2UuVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5ibG9jaywgc3QsIFwiU3RhdGVtZW50XCIpO1xuICBpZiAobm9kZS5oYW5kbGVyKSB7IGMobm9kZS5oYW5kbGVyLCBzdCk7IH1cbiAgaWYgKG5vZGUuZmluYWxpemVyKSB7IGMobm9kZS5maW5hbGl6ZXIsIHN0LCBcIlN0YXRlbWVudFwiKTsgfVxufTtcbmJhc2UuQ2F0Y2hDbGF1c2UgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgaWYgKG5vZGUucGFyYW0pIHsgYyhub2RlLnBhcmFtLCBzdCwgXCJQYXR0ZXJuXCIpOyB9XG4gIGMobm9kZS5ib2R5LCBzdCwgXCJTdGF0ZW1lbnRcIik7XG59O1xuYmFzZS5XaGlsZVN0YXRlbWVudCA9IGJhc2UuRG9XaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUudGVzdCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgYyhub2RlLmJvZHksIHN0LCBcIlN0YXRlbWVudFwiKTtcbn07XG5iYXNlLkZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5pbml0KSB7IGMobm9kZS5pbml0LCBzdCwgXCJGb3JJbml0XCIpOyB9XG4gIGlmIChub2RlLnRlc3QpIHsgYyhub2RlLnRlc3QsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgaWYgKG5vZGUudXBkYXRlKSB7IGMobm9kZS51cGRhdGUsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgYyhub2RlLmJvZHksIHN0LCBcIlN0YXRlbWVudFwiKTtcbn07XG5iYXNlLkZvckluU3RhdGVtZW50ID0gYmFzZS5Gb3JPZlN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUubGVmdCwgc3QsIFwiRm9ySW5pdFwiKTtcbiAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUuYm9keSwgc3QsIFwiU3RhdGVtZW50XCIpO1xufTtcbmJhc2UuRm9ySW5pdCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikgeyBjKG5vZGUsIHN0KTsgfVxuICBlbHNlIHsgYyhub2RlLCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG59O1xuYmFzZS5EZWJ1Z2dlclN0YXRlbWVudCA9IGlnbm9yZTtcblxuYmFzZS5GdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7IHJldHVybiBjKG5vZGUsIHN0LCBcIkZ1bmN0aW9uXCIpOyB9O1xuYmFzZS5WYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5kZWNsYXJhdGlvbnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICBjKGRlY2wsIHN0KTtcbiAgfVxufTtcbmJhc2UuVmFyaWFibGVEZWNsYXJhdG9yID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5pZCwgc3QsIFwiUGF0dGVyblwiKTtcbiAgaWYgKG5vZGUuaW5pdCkgeyBjKG5vZGUuaW5pdCwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxufTtcblxuYmFzZS5GdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5pZCkgeyBjKG5vZGUuaWQsIHN0LCBcIlBhdHRlcm5cIik7IH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBjKHBhcmFtLCBzdCwgXCJQYXR0ZXJuXCIpO1xuICB9XG4gIGMobm9kZS5ib2R5LCBzdCwgbm9kZS5leHByZXNzaW9uID8gXCJFeHByZXNzaW9uXCIgOiBcIlN0YXRlbWVudFwiKTtcbn07XG5cbmJhc2UuUGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICB7IGMobm9kZSwgc3QsIFwiVmFyaWFibGVQYXR0ZXJuXCIpOyB9XG4gIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgeyBjKG5vZGUsIHN0LCBcIk1lbWJlclBhdHRlcm5cIik7IH1cbiAgZWxzZVxuICAgIHsgYyhub2RlLCBzdCk7IH1cbn07XG5iYXNlLlZhcmlhYmxlUGF0dGVybiA9IGlnbm9yZTtcbmJhc2UuTWVtYmVyUGF0dGVybiA9IHNraXBUaHJvdWdoO1xuYmFzZS5SZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykgeyByZXR1cm4gYyhub2RlLmFyZ3VtZW50LCBzdCwgXCJQYXR0ZXJuXCIpOyB9O1xuYmFzZS5BcnJheVBhdHRlcm4gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmVsZW1lbnRzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBlbHQgPSBsaXN0W2ldO1xuXG4gICAgaWYgKGVsdCkgeyBjKGVsdCwgc3QsIFwiUGF0dGVyblwiKTsgfVxuICB9XG59O1xuYmFzZS5PYmplY3RQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIGlmIChwcm9wLnR5cGUgPT09IFwiUHJvcGVydHlcIikge1xuICAgICAgaWYgKHByb3AuY29tcHV0ZWQpIHsgYyhwcm9wLmtleSwgc3QsIFwiRXhwcmVzc2lvblwiKTsgfVxuICAgICAgYyhwcm9wLnZhbHVlLCBzdCwgXCJQYXR0ZXJuXCIpO1xuICAgIH0gZWxzZSBpZiAocHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIGMocHJvcC5hcmd1bWVudCwgc3QsIFwiUGF0dGVyblwiKTtcbiAgICB9XG4gIH1cbn07XG5cbmJhc2UuRXhwcmVzc2lvbiA9IHNraXBUaHJvdWdoO1xuYmFzZS5UaGlzRXhwcmVzc2lvbiA9IGJhc2UuU3VwZXIgPSBiYXNlLk1ldGFQcm9wZXJ0eSA9IGlnbm9yZTtcbmJhc2UuQXJyYXlFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5lbGVtZW50czsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgZWx0ID0gbGlzdFtpXTtcblxuICAgIGlmIChlbHQpIHsgYyhlbHQsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgfVxufTtcbmJhc2UuT2JqZWN0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIGMocHJvcCwgc3QpO1xuICB9XG59O1xuYmFzZS5GdW5jdGlvbkV4cHJlc3Npb24gPSBiYXNlLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gYmFzZS5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuYmFzZS5TZXF1ZW5jZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmV4cHJlc3Npb25zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIGV4cHIgPSBsaXN0W2ldO1xuXG4gICAgYyhleHByLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICB9XG59O1xuYmFzZS5UZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnF1YXNpczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBxdWFzaSA9IGxpc3RbaV07XG5cbiAgICBjKHF1YXNpLCBzdCk7XG4gIH1cblxuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBub2RlLmV4cHJlc3Npb25zOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGV4cHIgPSBsaXN0JDFbaSQxXTtcblxuICAgIGMoZXhwciwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgfVxufTtcbmJhc2UuVGVtcGxhdGVFbGVtZW50ID0gaWdub3JlO1xuYmFzZS5VbmFyeUV4cHJlc3Npb24gPSBiYXNlLlVwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgYyhub2RlLmFyZ3VtZW50LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcbmJhc2UuQmluYXJ5RXhwcmVzc2lvbiA9IGJhc2UuTG9naWNhbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgYyhub2RlLmxlZnQsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGMobm9kZS5yaWdodCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbn07XG5iYXNlLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gYmFzZS5Bc3NpZ25tZW50UGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUubGVmdCwgc3QsIFwiUGF0dGVyblwiKTtcbiAgYyhub2RlLnJpZ2h0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcbmJhc2UuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS50ZXN0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUuY29uc2VxdWVudCwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgYyhub2RlLmFsdGVybmF0ZSwgc3QsIFwiRXhwcmVzc2lvblwiKTtcbn07XG5iYXNlLk5ld0V4cHJlc3Npb24gPSBiYXNlLkNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5jYWxsZWUsIHN0LCBcIkV4cHJlc3Npb25cIik7XG4gIGlmIChub2RlLmFyZ3VtZW50cylcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5hcmd1bWVudHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgICB2YXIgYXJnID0gbGlzdFtpXTtcblxuICAgICAgICBjKGFyZywgc3QsIFwiRXhwcmVzc2lvblwiKTtcbiAgICAgIH0gfVxufTtcbmJhc2UuTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUub2JqZWN0LCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBpZiAobm9kZS5jb21wdXRlZCkgeyBjKG5vZGUucHJvcGVydHksIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbn07XG5iYXNlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBiYXNlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBpZiAobm9kZS5kZWNsYXJhdGlvbilcbiAgICB7IGMobm9kZS5kZWNsYXJhdGlvbiwgc3QsIG5vZGUudHlwZSA9PT0gXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgfHwgbm9kZS5kZWNsYXJhdGlvbi5pZCA/IFwiU3RhdGVtZW50XCIgOiBcIkV4cHJlc3Npb25cIik7IH1cbiAgaWYgKG5vZGUuc291cmNlKSB7IGMobm9kZS5zb3VyY2UsIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbn07XG5iYXNlLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGMobm9kZS5zb3VyY2UsIHN0LCBcIkV4cHJlc3Npb25cIik7XG59O1xuYmFzZS5JbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgIGMoc3BlYywgc3QpO1xuICB9XG4gIGMobm9kZS5zb3VyY2UsIHN0LCBcIkV4cHJlc3Npb25cIik7XG59O1xuYmFzZS5JbXBvcnRTcGVjaWZpZXIgPSBiYXNlLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBiYXNlLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGJhc2UuSWRlbnRpZmllciA9IGJhc2UuTGl0ZXJhbCA9IGJhc2UuSW1wb3J0ID0gaWdub3JlO1xuXG5iYXNlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBzdCwgYykge1xuICBjKG5vZGUudGFnLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xuICBjKG5vZGUucXVhc2ksIHN0LCBcIkV4cHJlc3Npb25cIik7XG59O1xuYmFzZS5DbGFzc0RlY2xhcmF0aW9uID0gYmFzZS5DbGFzc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHsgcmV0dXJuIGMobm9kZSwgc3QsIFwiQ2xhc3NcIik7IH07XG5iYXNlLkNsYXNzID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLmlkKSB7IGMobm9kZS5pZCwgc3QsIFwiUGF0dGVyblwiKTsgfVxuICBpZiAobm9kZS5zdXBlckNsYXNzKSB7IGMobm9kZS5zdXBlckNsYXNzLCBzdCwgXCJFeHByZXNzaW9uXCIpOyB9XG4gIGMobm9kZS5ib2R5LCBzdCk7XG59O1xuYmFzZS5DbGFzc0JvZHkgPSBmdW5jdGlvbiAobm9kZSwgc3QsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLmJvZHk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZWx0ID0gbGlzdFtpXTtcblxuICAgIGMoZWx0LCBzdCk7XG4gIH1cbn07XG5iYXNlLk1ldGhvZERlZmluaXRpb24gPSBiYXNlLlByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHN0LCBjKSB7XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7IGMobm9kZS5rZXksIHN0LCBcIkV4cHJlc3Npb25cIik7IH1cbiAgYyhub2RlLnZhbHVlLCBzdCwgXCJFeHByZXNzaW9uXCIpO1xufTtcblxuZXhwb3J0IHsgYW5jZXN0b3IsIGJhc2UsIGZpbmROb2RlQWZ0ZXIsIGZpbmROb2RlQXJvdW5kLCBmaW5kTm9kZUF0LCBmaW5kTm9kZUJlZm9yZSwgZnVsbCwgZnVsbEFuY2VzdG9yLCBtYWtlLCByZWN1cnNpdmUsIHNpbXBsZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tern/node_modules/acorn-walk/dist/walk.mjs\n");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn/dist/acorn.js":
/*!************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn/dist/acorn.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.acorn = {}));\n}(this, function (exports) { 'use strict';\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords$1 = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n\n  var types = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code, ecma2019String) {\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return hasOwnProperty.call(obj, propName)\n  }\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur)\n      }\n    }\n  }\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n    // (2019). This influences support for strict mode, the set of\n    // reserved words, and support for new syntax features. The default\n    // is 9.\n    ecmaVersion: 9,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callbackthat will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callbackthat will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion >= 2015)\n      { options.ecmaVersion -= 2009; }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      for (var v = options.ecmaVersion;; v--)\n        { if (reserved = reservedWords[v]) { break } }\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = {};\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  // Switch to a getter for 7.0.0.\n  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n  pp.strictDirective = function(start) {\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") { return true }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp.isContextual = function(name) {\n    return this.type === types.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp.canInsertSemicolon = function() {\n    return this.type === types.eof ||\n      this.type === types.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp.semicolon = function() {\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  }\n\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n  };\n\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$1 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function(node) {\n    var exports = {};\n    if (!node.body) { node.body = []; }\n    while (this.type !== types.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$1.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91) { return true } // '['\n    if (context) { return false }\n\n    if (nextCh === 123) { return true } // '{'\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$1.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$1.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types._debugger: return this.parseDebuggerStatement(node)\n    case types._do: return this.parseDoStatement(node)\n    case types._for: return this.parseForStatement(node)\n    case types._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types._if: return this.parseIfStatement(node)\n    case types._return: return this.parseReturnStatement(node)\n    case types._switch: return this.parseSwitchStatement(node)\n    case types._throw: return this.parseThrowStatement(node)\n    case types._try: return this.parseTryStatement(node)\n    case types._const: case types._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types._while: return this.parseWhileStatement(node)\n    case types._with: return this.parseWithStatement(node)\n    case types.braceL: return this.parseBlock(true, node)\n    case types.semi: return this.parseEmptyStatement(node)\n    case types._export:\n    case types._import:\n      if (this.options.ecmaVersion > 10 && starttype === types._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40) // '('\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$1.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$1.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$1.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types.parenL);\n    if (this.type === types.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types._var || this.type === types._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types._in) {\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\n          } else { node.await = awaitAt > -1; }\n        }\n        return this.parseForIn(node, init$1)\n      }\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, init$1)\n    }\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLVal(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$1.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$1.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$1.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types.braceR;) {\n      if (this.type === types._case || this.type === types._default) {\n        var isCase = this.type === types._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$1.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types.parenL)) {\n        clause.param = this.parseBindingAtom();\n        var simple = clause.param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$1.parseVarStatement = function(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$1.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$1.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$1.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$1.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$1.parseBlock = function(createNewLexicalScope, node) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (!this.eat(types.braceR)) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$1.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.type === types.semi ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.type === types.parenR ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$1.parseForIn = function(node, init) {\n    var isForIn = this.type === types._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$1.parseVar = function(node, isFor, kind) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) { break }\n    }\n    return node\n  };\n\n  pp$1.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$1.parseFunctionParams = function(node) {\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        }\n      }\n    }\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$1.parseClassElement = function(constructorAllowsSuper) {\n    var this$1 = this;\n\n    if (this.eat(types.semi)) { return null }\n\n    var method = this.startNode();\n    var tryContextual = function (k, noLineBreak) {\n      if ( noLineBreak === void 0 ) noLineBreak = false;\n\n      var start = this$1.start, startLoc = this$1.startLoc;\n      if (!this$1.eatContextual(k)) { return false }\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n      if (method.key) { this$1.unexpected(); }\n      method.computed = false;\n      method.key = this$1.startNodeAt(start, startLoc);\n      method.key.name = k;\n      this$1.finishNode(method.key, \"Identifier\");\n      return false\n    };\n\n    method.kind = \"method\";\n    method.static = tryContextual(\"static\");\n    var isGenerator = this.eat(types.star);\n    var isAsync = false;\n    if (!isGenerator) {\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      } else if (tryContextual(\"get\")) {\n        method.kind = \"get\";\n      } else if (tryContextual(\"set\")) {\n        method.kind = \"set\";\n      }\n    }\n    if (!method.key) { this.parsePropertyName(method); }\n    var key = method.key;\n    var allowsDirectSuper = false;\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n        key.type === \"Literal\" && key.value === \"constructor\")) {\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n      method.kind = \"constructor\";\n      allowsDirectSuper = constructorAllowsSuper;\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n    if (method.kind === \"get\" && method.value.params.length !== 0)\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && method.value.params.length !== 1)\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n    return method\n  };\n\n  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$1.parseClassId = function(node, isStatement) {\n    if (this.type === types.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLVal(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$1.parseClassSuper = function(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  };\n\n  // Parses module export declaration.\n\n  pp$1.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types.star)) {\n      this.expectContextual(\"from\");\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(types._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n      } else if (this.type === types._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(null);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n        }\n\n        node.source = null;\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$1.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (has(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat.name, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n    else if (type === \"ParenthesizedExpression\")\n      { this.checkPatternExport(exports, pat.expression); }\n  };\n\n  pp$1.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$1.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$1.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node = this.startNode();\n      node.local = this.parseIdent(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n      this.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$1.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$1.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(types.comma)) { return nodes }\n    }\n    if (this.type === types.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes\n    }\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node$2 = this.startNode();\n      node$2.imported = this.parseIdent(true);\n      if (this.eatContextual(\"as\")) {\n        node$2.local = this.parseIdent();\n      } else {\n        this.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n      this.checkLVal(node$2.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$1.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$1.isDirectiveCandidate = function(statement) {\n    return (\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$2 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$2.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$2.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$2.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$2.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types.comma); }\n      if (allowEmpty && this.type === types.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n    return elts\n  };\n\n  pp$2.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // Verify that a node is an lval  something that can be assigned\n  // to.\n  // bindingType can be either:\n  // 'var' indicating that the lval creates a 'var' binding\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (checkClashes) {\n        if (has(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      break\n\n    case \"MemberExpression\":\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\n        {\n      var prop = list[i];\n\n      this.checkLVal(prop, bindingType, checkClashes);\n    }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n      }\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  // A recursive descent parser operates by defining functions for all\n\n  var pp$3 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash \n  // either with each other or with an init property  and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n    if (this.type === types.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(noIn) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types.parenL || this.type === types.name)\n      { this.potentialArrowAt = this.start; }\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n    if (prec != null && (!noIn || this.type !== types._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n      }\n    }\n    return left\n  };\n\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLVal(node.argument); }\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(types.starstar))\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n    else\n      { return expr }\n  };\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    }\n    return result\n  };\n\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n      if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n      base = element;\n    }\n  };\n\n  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n    var computed = this.eat(types.bracketL);\n    if (computed || this.eat(types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n      node.computed = !!computed;\n      if (computed) { this.expect(types.bracketR); }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== \"Import\", false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      if (node$1.callee.type === \"Import\") {\n        if (node$1.arguments.length !== 1) {\n          this.raise(node$1.start, \"import() requires exactly one argument\");\n        }\n\n        var importArg = node$1.arguments[0];\n        if (importArg && importArg.type === \"SpreadElement\") {\n          this.raise(importArg.start, \"... is not allowed in import()\");\n        }\n      }\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types.backQuote) {\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super Arguments\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n        }\n      }\n      return id\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types.num: case types.string:\n      return this.parseLiteral(this.value)\n\n    case types._null: case types._true: case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types._new:\n      return this.parseNew()\n\n    case types.backQuote:\n      return this.parseTemplate()\n\n    case types._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport()\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseDynamicImport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.type !== types.parenL) {\n      this.unexpected();\n    }\n    return this.finishNode(node, \"Import\")\n  };\n\n  pp$3.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$3.parseParenExpression = function() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types.parenR) {\n        first ? first = false : this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\n      this.expect(types.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$3.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call  at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function() {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\" || containsEsc)\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n      if (!this.inNonArrowFunction())\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (this.options.ecmaVersion > 10 && node.callee.type === \"Import\") {\n      this.raise(node.callee.start, \"Cannot use new with import(...)\");\n    }\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== \"Import\", false); }\n    else { node.arguments = empty$1; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$3.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$3.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$3.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // To disallow parenthesized identifier via `this.toAssignable()`.\n      if (this.type === types.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types.comma && this.type !== types.braceR)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\")\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      prop.kind = \"init\";\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === types.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$3.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$3.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n    var isExpression = isArrowFunction && this.type !== types.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      node.body = this.parseBlock(false);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    this.strict = oldStrict;\n  };\n\n  pp$3.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$3.checkParams = function(node, allowDuplicates) {\n    var nameHash = {};\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types.comma)\n        { elt = null; }\n      else if (this.type === types.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$3.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$3.parseIdent = function(liberal, isBinding) {\n    var node = this.startNode();\n    if (this.type === types.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$3.parseYield = function(noIn) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$3.parseAwait = function() {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$5 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$5.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$5.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$5.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$5.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$5.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$5.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$5.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$5.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$6.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$6.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types$1 = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$7 = Parser.prototype;\n\n  pp$7.initialContext = function() {\n    return [types$1.b_stat]\n  };\n\n  pp$7.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\n      { return true }\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n      { return true }\n    if (prevType === types.braceL)\n      { return parent === types$1.b_stat }\n    if (prevType === types._var || prevType === types._const || prevType === types.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$7.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$7.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Token-specific context update code\n\n  types.parenR.updateContext = types.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types.dollarBraceL.updateContext = function() {\n    this.context.push(types$1.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types._function.updateContext = types._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n      { this.context.push(types$1.f_expr); }\n    else\n      { this.context.push(types$1.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types.backQuote.updateContext = function() {\n    if (this.curContext() === types$1.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types$1.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types.star.updateContext = function(prevType) {\n    if (prevType === types._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types$1.f_expr)\n        { this.context[index] = types$1.f_expr_gen; }\n      else\n        { this.context[index] = types$1.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // This file contains Unicode properties extracted from the ECMAScript\n  // specification. The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n  buildUnicodeData(9);\n  buildUnicodeData(10);\n  buildUnicodeData(11);\n\n  var pp$8 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i), next;\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current () {\n    return this.at(this.pos)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead () {\n    return this.at(this.nextIndex(this.pos))\n  };\n\n  RegExpValidationState.prototype.advance = function advance () {\n    this.pos = this.nextIndex(this.pos);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch) {\n    if (this.current() === ch) {\n      this.advance();\n      return true\n    }\n    return false\n  };\n\n  function codePointToString(ch) {\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n    ch -= 0x10000;\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n  }\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$8.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$8.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      this.regexp_alternative(state);\n    }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$8.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\n      { }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$8.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$8.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$8.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$8.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$8.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$8.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$8.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$8.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$8.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier[U] ::\n  //   [empty]\n  //   `?` GroupName[?U]\n  pp$8.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n        state.groupNames.push(state.lastStringValue);\n        return\n      }\n      state.raise(\"Invalid group\");\n    }\n  };\n\n  // GroupName[U] ::\n  //   `<` RegExpIdentifierName[?U] `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName[U] ::\n  //   RegExpIdentifierStart[?U]\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart[U] ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  pp$8.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart[U] ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$8.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$8.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$8.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$8.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$8.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$8.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$8.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        state.switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$8.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$8.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$8.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true\n    }\n\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      if (\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\n        state.eat(0x7D /* } */)\n      ) {\n        return true\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return false\n  };\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true\n    }\n    return false\n  };\n  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!has(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (!state.unicodeProperties.binary.test(nameOrValue))\n      { state.raise(\"Invalid property name\"); }\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$8.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$8.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      state.eat(0x5E /* ^ */);\n      this.regexp_classRanges(state);\n      if (state.eat(0x5D /* [ */)) {\n        return true\n      }\n      // Unreachable since it threw \"unterminated regular expression\" error before.\n      state.raise(\"Unterminated character class\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$8.regexp_classRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$8.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* [ */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$8.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$8.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$8.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$8.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$8.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp$9 = Parser.prototype;\n\n  // Move to the next token\n\n  pp$9.next = function() {\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$9.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp$9[Symbol.iterator] = function() {\n      var this$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1.getToken();\n          return {\n            done: token.type === types.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$9.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp$9.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp$9.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp$9.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00\n  };\n\n  pp$9.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this.curLine;\n        this.lineStart = match.index + match[0].length;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp$9.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp$9.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp$9.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp$9.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types.dot)\n    }\n  };\n\n  pp$9.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.slash, 1)\n  };\n\n  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types.star : types.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp$9.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n  };\n\n  pp$9.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.bitwiseXOR, 1)\n  };\n\n  pp$9.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.plusMin, 1)\n  };\n\n  pp$9.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n      return this.finishOp(types.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types.relational, size)\n  };\n\n  pp$9.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types.arrow)\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n  };\n\n  pp$9.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types.parenL)\n    case 41: ++this.pos; return this.finishToken(types.parenR)\n    case 59: ++this.pos; return this.finishToken(types.semi)\n    case 44: ++this.pos; return this.finishToken(types.comma)\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\n    case 123: ++this.pos; return this.finishToken(types.braceL)\n    case 125: ++this.pos; return this.finishToken(types.braceR)\n    case 58: ++this.pos; return this.finishToken(types.colon)\n    case 63: ++this.pos; return this.finishToken(types.question)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 126: // '~'\n      return this.finishOp(types.prefix, 1)\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n  };\n\n  pp$9.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp$9.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp$9.readInt = function(radix, len) {\n    var start = this.pos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      ++this.pos;\n      total = total * radix + val;\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  pp$9.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp$9.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var str$1 = this.input.slice(start, this.pos);\n      var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types.num, val$1)\n    }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var str = this.input.slice(start, this.pos);\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\n    return this.finishToken(types.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp$9.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  function codePointToString$1(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  pp$9.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else {\n        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp$9.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp$9.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp$9.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp$9.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break\n        }\n      // falls through\n\n      case \"`\":\n        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      // no default\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp$9.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp$9.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp$9.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString$1(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp$9.readWord = function() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n      type = keywords$1[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n  var version = \"6.4.0\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types,\n    keywordTypes: keywords$1,\n    TokContext: TokContext,\n    tokContexts: types$1,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords$1;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types$1;\n  exports.tokTypes = types;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXJuL25vZGVfbW9kdWxlcy9hY29ybi9kaXN0L2Fjb3JuLmpzP2U4ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmFjb3JuID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH07XG5cbiAgLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG4gIHZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbiAgdmFyIGtleXdvcmRzID0ge1xuICAgIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICAgIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG4gIH07XG5cbiAgdmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gIC8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuICAvLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuICAvLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4gIC8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuICAvLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGJkXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzg4XFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmVmXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YmZcXHVhN2MyLVxcdWE3YzZcXHVhN2Y3LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY3XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xuXG4gIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5cbiAgLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gIC8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbiAgLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuICAvLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuICAvLyBnZW5lcmF0ZWQgYnkgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xuICB2YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjgsNDMsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDE0LDM1LDQ3NywyOCwxMSwwLDksMjEsMTU1LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMTIsMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMCwzMyw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiwwLDE2MSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDM1LDU2LDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMjcwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSw3NTQsOTQ4NiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxMCw0Miw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MV07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbW1hLXNwYWNpbmdcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksNTI1LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsNCw5LDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksMjMyLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxOTMwNiw5LDEzNSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsMTk3MjMsMSw1MzE5LDQsNCw1LDksNywzLDYsMzEsMywxNDksMiwxNDE4LDQ5LDUxMyw1NCw1LDQ5LDksMCwxNSwwLDIzLDQsMiwxNCwxMzYxLDYsMiwxNiwzLDYsMiwxLDIsNCwyNjIsNiwxMCw5LDQxOSwxMywxNDk1LDYsMTEwLDYsNiw5LDc5MjQ4NywyMzldO1xuXG4gIC8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbiAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuICAvLyByYXJlLlxuICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICAgIHZhciBwb3MgPSAweDEwMDAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBwb3MgKz0gc2V0W2ldO1xuICAgICAgaWYgKHBvcyA+IGNvZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHBhcnQgb2YgYW4gaWRlbnRpZmllci5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG4gIH1cblxuICAvLyAjIyBUb2tlbiB0eXBlc1xuXG4gIC8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4gIC8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuICAvLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuICAvLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbiAgLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbiAgLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbiAgLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuICAvLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuICAvL1xuICAvLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuICAvLyBgeWllbGRgIGV4cHJlc3Npb24uIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBlaXRoZXIgY2FuXG4gIC8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4gIC8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuICAvL1xuICAvLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbiAgLy8gY29udGludWUganVtcHMgdG8gdGhhdCBsYWJlbC5cblxuICB2YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gICAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICAgIHJldHVybiBuZXcgVG9rZW5UeXBlKG5hbWUsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogcHJlY30pXG4gIH1cbiAgdmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbiAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgdmFyIGtleXdvcmRzJDEgPSB7fTtcblxuICAvLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG4gIGZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gICAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICB2YXIgdHlwZXMgPSB7XG4gICAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gICAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gICAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gICAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gICAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICAgIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICAgIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICAgIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gICAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gICAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICAgIGludmFsaWRUZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcImludmFsaWRUZW1wbGF0ZVwiKSxcbiAgICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICAgIGRvbGxhckJyYWNlTDogbmV3IFRva2VuVHlwZShcIiR7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG5cbiAgICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAgIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgICAvL1xuICAgIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAgIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgICAvL1xuICAgIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAgIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAgIC8vXG4gICAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICAgIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gICAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gICAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICAgIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gICAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gICAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICAgIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBtb2R1bG86IGJpbm9wKFwiJVwiLCAxMCksXG4gICAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgICBzdGFyc3RhcjogbmV3IFRva2VuVHlwZShcIioqXCIsIHtiZWZvcmVFeHByOiB0cnVlfSksXG5cbiAgICAvLyBLZXl3b3JkIHRva2VuIHR5cGVzLlxuICAgIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gICAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICAgIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gICAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gICAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgICBfaWY6IGt3KFwiaWZcIiksXG4gICAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gICAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gICAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICAgIF90cnk6IGt3KFwidHJ5XCIpLFxuICAgIF92YXI6IGt3KFwidmFyXCIpLFxuICAgIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF93aXRoOiBrdyhcIndpdGhcIiksXG4gICAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gICAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gICAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbiAgfTtcblxuICAvLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4gIC8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbiAgdmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBpc05ld0xpbmUoY29kZSwgZWNtYTIwMTlTdHJpbmcpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgKCFlY21hMjAxOVN0cmluZyAmJiAoY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOSkpXG4gIH1cblxuICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG4gIHZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG4gIHZhciByZWYgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG4gIHZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuICAvLyBDaGVja3MgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuXG4gIGZ1bmN0aW9uIGhhcyhvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbiAgfVxuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICAgIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4gICk7IH0pO1xuXG4gIGZ1bmN0aW9uIHdvcmRzUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbiAgfVxuXG4gIC8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuICAvLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG4gIHZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2w7XG4gIH07XG5cbiAgUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG4gIH07XG5cbiAgdmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG4gIH07XG5cbiAgLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuICAvLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuICAvLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAvLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4gIC8vIGludG8uXG5cbiAgZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gY3VyO1xuICAgICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA8IG9mZnNldCkge1xuICAgICAgICArK2xpbmU7XG4gICAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4gIC8vIHRoZSBwYXJzZXIgcHJvY2Vzcy4gVGhlc2Ugb3B0aW9ucyBhcmUgcmVjb2duaXplZDpcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAgIC8vIGVpdGhlciAzLCA1LCA2ICgyMDE1KSwgNyAoMjAxNiksIDggKDIwMTcpLCA5ICgyMDE4KSwgb3IgMTBcbiAgICAvLyAoMjAxOSkuIFRoaXMgaW5mbHVlbmNlcyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZlxuICAgIC8vIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3IgbmV3IHN5bnRheCBmZWF0dXJlcy4gVGhlIGRlZmF1bHRcbiAgICAvLyBpcyA5LlxuICAgIGVjbWFWZXJzaW9uOiA5LFxuICAgIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgICAvLyBDYW4gYmUgZWl0aGVyIGBcInNjcmlwdFwiYCBvciBgXCJtb2R1bGVcImAuIFRoaXMgaW5mbHVlbmNlcyBnbG9iYWxcbiAgICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgLy8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gIGNhbiBiZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWRcbiAgICAvLyB3aGVuIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkXG4gICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBjb21tYSBhcyBhbiBvZmZzZXQsIGFuZCBpZiBgbG9jYXRpb25zYCBpc1xuICAgIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gICAgLy8gYXMgc2Vjb25kIGFyZ3VtZW50LlxuICAgIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gICAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgICAvLyB0cmFpbGluZyBjb21tYXMuXG4gICAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAgIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gICAgLy8gU2V0IGBhbGxvd1Jlc2VydmVkYCB0byBhIGJvb2xlYW4gdmFsdWUgdG8gZXhwbGljaXRseSB0dXJuIHRoaXMgb25cbiAgICAvLyBhbiBvZmYuIFdoZW4gdGhpcyBvcHRpb24gaGFzIHRoZSB2YWx1ZSBcIm5ldmVyXCIsIHJlc2VydmVkIHdvcmRzXG4gICAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICAgIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gICAgLy8gZXJyb3IuXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUsXG4gICAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gICAgLy8gaXMgYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC5cbiAgICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gICAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgICAvLyBsaW5lIGJlaW5nIDEtYmFzZWQgYW5kIGNvbHVtbiAwLWJhc2VkKSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZVxuICAgIC8vIG5vZGVzLlxuICAgIGxvY2F0aW9uczogZmFsc2UsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvblRva2VuYCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gICAgLy8gdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlIHBhcnNlciBmcm9tIHRoZVxuICAgIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICAgIG9uVG9rZW46IG51bGwsXG4gICAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvbkNvbW1lbnRgIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAgIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAgIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBibG9jayAoYC8qICovYCkgY29tbWVudCxcbiAgICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgICAvLyBXaGVuIHRoZSBgbG9jYXRpb25zYCBvcHRpb24gaXMgb24sIHR3byBtb3JlIHBhcmFtZXRlcnMgYXJlXG4gICAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gICAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgICAvLyBwYXJzZXIgZnJvbSB0aGUgY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgb25Db21tZW50OiBudWxsLFxuICAgIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIChkaXJlY3RseSBvbiB0aGUgbm9kZSwgcmF0aGVyIHRoYW5cbiAgICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gICAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gICAgLy8gYHRydWVgLlxuICAgIC8vXG4gICAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAgIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAgIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gICAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAgIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAgIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAgIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgICAvLyAobm9uLXN0YW5kYXJkKSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBub2Rlc1xuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxuICB9O1xuXG4gIC8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgICBpZiAob3B0aW9ucy5lY21hVmVyc2lvbiA+PSAyMDE1KVxuICAgICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICAgIHsgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID0gb3B0aW9ucy5lY21hVmVyc2lvbiA8IDU7IH1cblxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgICBvcHRpb25zLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2Vucy5wdXNoKHRva2VuKTsgfTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgICAgeyBvcHRpb25zLm9uQ29tbWVudCA9IHB1c2hDb21tZW50KG9wdGlvbnMsIG9wdGlvbnMub25Db21tZW50KTsgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hDb21tZW50KG9wdGlvbnMsIGFycmF5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgICAgdHlwZTogYmxvY2sgPyBcIkJsb2NrXCIgOiBcIkxpbmVcIixcbiAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmRcbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICAgIHsgY29tbWVudC5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24odGhpcywgc3RhcnRMb2MsIGVuZExvYyk7IH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgICBhcnJheS5wdXNoKGNvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVhY2ggc2NvcGUgZ2V0cyBhIGJpdHNldCB0aGF0IG1heSBjb250YWluIHRoZXNlIGZsYWdzXG4gIHZhclxuICAgICAgU0NPUEVfVE9QID0gMSxcbiAgICAgIFNDT1BFX0ZVTkNUSU9OID0gMixcbiAgICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OLFxuICAgICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgICAgU0NPUEVfR0VORVJBVE9SID0gOCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICAgIFNDT1BFX1NVUEVSID0gNjQsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjg7XG5cbiAgZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIFNDT1BFX0ZVTkNUSU9OIHwgKGFzeW5jID8gU0NPUEVfQVNZTkMgOiAwKSB8IChnZW5lcmF0b3IgPyBTQ09QRV9HRU5FUkFUT1IgOiAwKVxuICB9XG5cbiAgLy8gVXNlZCBpbiBjaGVja0xWYWwgYW5kIGRlY2xhcmVOYW1lIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhIGJpbmRpbmdcbiAgdmFyXG4gICAgICBCSU5EX05PTkUgPSAwLCAvLyBOb3QgYSBiaW5kaW5nXG4gICAgICBCSU5EX1ZBUiA9IDEsIC8vIFZhci1zdHlsZSBiaW5kaW5nXG4gICAgICBCSU5EX0xFWElDQUwgPSAyLCAvLyBMZXQtIG9yIGNvbnN0LXN0eWxlIGJpbmRpbmdcbiAgICAgIEJJTkRfRlVOQ1RJT04gPSAzLCAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCAvLyBTaW1wbGUgKGlkZW50aWZpZXIgcGF0dGVybikgY2F0Y2ggYmluZGluZ1xuICAgICAgQklORF9PVVRTSURFID0gNTsgLy8gU3BlY2lhbCBjYXNlIGZvciBmdW5jdGlvbiBuYW1lcyBhcyBib3VuZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG5cbiAgdmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGU7XG4gICAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgICB9XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0O1xuICAgIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gICAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgdG9rZW5pemVyIGluIHRoZSBpbnB1dC5cbiAgICBpZiAoc3RhcnRQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICAgIH1cblxuICAgIC8vIFByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdG9rZW46XG4gICAgLy8gSXRzIHR5cGVcbiAgICB0aGlzLnR5cGUgPSB0eXBlcy5lb2Y7XG4gICAgLy8gRm9yIHRva2VucyB0aGF0IGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZWlyIHR5cGUsIHRoZSB2YWx1ZVxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gICAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpO1xuXG4gICAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAgIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAgIC8vIGdpdmVuIHBvc2l0aW9uLlxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgaXQncyBhIG1vZHVsZSBjb2RlLlxuICAgIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAgIC8vIFVzZWQgdG8gc2lnbmlmeSB0aGUgc3RhcnQgb2YgYSBwb3RlbnRpYWwgYXJyb3cgZnVuY3Rpb25cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAgIC8vIFBvc2l0aW9ucyB0byBkZWxheWVkLWNoZWNrIHRoYXQgeWllbGQvYXdhaXQgZG9lcyBub3QgZXhpc3QgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAvLyBUaHVzLWZhciB1bmRlZmluZWQgZXhwb3J0cy5cbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSB7fTtcblxuICAgIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICAgIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gICAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICAgIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gICAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gICAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuICAvLyBTd2l0Y2ggdG8gYSBnZXR0ZXIgZm9yIDcuMC4wLlxuICBQYXJzZXIucHJvdG90eXBlLmluTm9uQXJyb3dGdW5jdGlvbiA9IGZ1bmN0aW9uIGluTm9uQXJyb3dGdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciBjbHMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgICByZXR1cm4gY2xzXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gICAgcGFyc2VyLm5leHRUb2tlbigpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbiAgfTtcblxuICBQYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbiAgdmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXSkqPyknfFwiKCg/OlxcXFwufFteXCJdKSo/KVwiKS87XG4gIHBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgLy8gVHJ5IHRvIGZpbmQgc3RyaW5nIGxpdGVyYWwuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICgobWF0Y2hbMV0gfHwgbWF0Y2hbMl0pID09PSBcInVzZSBzdHJpY3RcIikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgICAgeyBzdGFydCsrOyB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFByZWRpY2F0ZSB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgb2YgdGhlIGdpdmVuXG4gIC8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbiAgcHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIHBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2NcbiAgfTtcblxuICAvLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbiAgcHAuZWF0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxuICBwcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgc2VtaWNvbG9uIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICBwcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2VSIHx8XG4gICAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgcHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuICAvLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxuICBwcC5zZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cbiAgcHAuYWZ0ZXJUcmFpbGluZ0NvbW1hID0gZnVuY3Rpb24odG9rVHlwZSwgbm90TmV4dCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgICB7IHRoaXMub3B0aW9ucy5vblRyYWlsaW5nQ29tbWEodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva1N0YXJ0TG9jKTsgfVxuICAgICAgaWYgKCFub3ROZXh0KVxuICAgICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuICAvLyBFeHBlY3QgYSB0b2tlbiBvZiBhIGdpdmVuIHR5cGUuIElmIGZvdW5kLCBjb25zdW1lIGl0LCBvdGhlcndpc2UsXG4gIC8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZCgpO1xuICB9O1xuXG4gIC8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gICAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgICB0aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICAgIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgICAgLTE7XG4gIH1cblxuICBwcC5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICAgIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxuICB9O1xuXG4gIHBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICAgIHZhciBkb3VibGVQcm90byA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG87XG4gICAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gICAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlKHNob3J0aGFuZEFzc2lnbiwgXCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuc1wiKTsgfVxuICAgIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICB9O1xuXG4gIHBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy55aWVsZFBvcywgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICB9O1xuXG4gIHBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICAgIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgcmV0dXJuIHRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwci5leHByZXNzaW9uKSB9XG4gICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxuICB9O1xuXG4gIHZhciBwcCQxID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgcHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5lb2YpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbk1vZHVsZSlcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgfSB9XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbiAgfTtcblxuICB2YXIgbG9vcExhYmVsID0ge2tpbmQ6IFwibG9vcFwifSwgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbiAgcHAkMS5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgLy8gRm9yIGFtYmlndW91cyBjYXNlcywgZGV0ZXJtaW5lIGlmIGEgTGV4aWNhbERlY2xhcmF0aW9uIChvciBvbmx5IGFcbiAgICAvLyBTdGF0ZW1lbnQpIGlzIGFsbG93ZWQgaGVyZS4gSWYgY29udGV4dCBpcyBub3QgZW1wdHkgdGhlbiBvbmx5IGEgU3RhdGVtZW50XG4gICAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gICAgLy8gRXhwcmVzc2lvblN0YXRlbWVudCwgc28gc3BlY2lhbC1jYXNlIGl0IGZpcnN0LlxuICAgIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snXG4gICAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChuZXh0Q2ggPT09IDEyMykgeyByZXR1cm4gdHJ1ZSB9IC8vICd7J1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4gIC8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuICAvLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxuICBwcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxuICB9O1xuXG4gIC8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbiAgLy9cbiAgLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbiAgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2VcbiAgLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuICAvLyBkb2VzIG5vdCBoZWxwLlxuXG4gIHBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICAgIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gICAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAgICBraW5kID0gXCJsZXRcIjtcbiAgICB9XG5cbiAgICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAgIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAgIC8vIGNvbXBsZXhpdHkuXG5cbiAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICAgIGNhc2UgdHlwZXMuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgICAvLyB3b3JrcywgYnV0IG5vdCB3aGVuIGl0IGlzIHBhcnQgb2YgYSBsYWJlbGVkIHN0YXRlbWVudCB0aGF0IGlzIHRoZSBzb2xlXG4gICAgICAvLyBib2R5IG9mIGFuIGlmIHN0YXRlbWVudC5cbiAgICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0eXBlcy5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2NvbnN0OiBjYXNlIHR5cGVzLl92YXI6XG4gICAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlO1xuICAgICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZClcbiAgICBjYXNlIHR5cGVzLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOiByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKHRydWUsIG5vZGUpXG4gICAgY2FzZSB0eXBlcy5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQpIHtcbiAgICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gICAgICAgIGlmIChuZXh0Q2ggPT09IDQwKSAvLyAnKCdcbiAgICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbFwiKTsgfVxuICAgICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgICAgLy8gYnJhY2UsIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudCBvciBMYWJlbGVkU3RhdGVtZW50LiBXZVxuICAgICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAgIC8vIElkZW50aWZpZXIgbm9kZSwgd2Ugc3dpdGNoIHRvIGludGVycHJldGluZyBpdCBhcyBhIGxhYmVsLlxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICBpZiAoY29udGV4dCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICAgIH1cblxuICAgICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gICAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gICAgLy8gY29udGludWUgdG8uXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsYWIgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuICAvLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbiAgLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbiAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4gIC8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4gIC8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG4gIHBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKVxuICAgIH1cbiAgICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBpc0xldCkge1xuICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAvLyBhbGxvdyBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgaW4gYnJhbmNoZXMsIGJ1dCBvbmx5IGluIG5vbi1zdHJpY3QgbW9kZVxuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cbiAgICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgICAvLyBub2Rlcy4gYGN1cmAgaXMgdXNlZCB0byBrZWVwIHRoZSBub2RlIHRoYXQgd2UgYXJlIGN1cnJlbnRseVxuICAgIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gICAgdmFyIGN1cjtcbiAgICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgaWYgKGN1cikgeyB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgcHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgICAgdmFyIHNpbXBsZSA9IGNsYXVzZS5wYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIjtcbiAgICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgICB9XG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgICB7IHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICB9IH1cbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBpbmZvcm1hdGlvbiBhYm91dCBwcmV2aW91cyBsYWJlbHMgb24gdGhpcyBub2RlXG4gICAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChjb250ZXh0ID8gY29udGV4dC5pbmRleE9mKFwibGFiZWxcIikgPT09IC0xID8gY29udGV4dCArIFwibGFiZWxcIiA6IGNvbnRleHQgOiBcImxhYmVsXCIpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIG5vZGUubGFiZWwgPSBleHByO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgcHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlKSB7XG4gICAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gICAgaWYgKCBub2RlID09PSB2b2lkIDAgKSBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmVudGVyU2NvcGUoMCk7IH1cbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgfTtcblxuICAvLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbiAgLy8gYHBhcnNlU3RhdGVtZW50YCB3aWxsIGFscmVhZHkgaGF2ZSBwYXJzZWQgdGhlIGluaXQgc3RhdGVtZW50IG9yXG4gIC8vIGV4cHJlc3Npb24uXG5cbiAgcHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICAgIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3RcbiAgLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG4gIHBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKFxuICAgICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmXG4gICAgICAoXG4gICAgICAgICFpc0ZvckluIHx8XG4gICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHxcbiAgICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aGlzLnJhaXNlKFxuICAgICAgICBpbml0LnN0YXJ0LFxuICAgICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcFwiKTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxuICBwcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkMS5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbiAgLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4gIC8vIGBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVGApLlxuXG4gIC8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG4gIHBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgaWYgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSB7XG4gICAgICBub2RlLmlkID0gKHN0YXRlbWVudCAmIEZVTkNfTlVMTEFCTEVfSUQpICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgICAvLyBzdWJqZWN0IHRvIEFubmV4IEIgc2VtYW50aWNzIChCSU5EX0ZVTkNUSU9OKS4gT3RoZXJ3aXNlLCB0aGUgYmluZGluZ1xuICAgICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG4gIC8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0O1xuICAgIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgICBjbGFzc0JvZHkuYm9keSA9IFtdO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnQobm9kZS5zdXBlckNsYXNzICE9PSBudWxsKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIGVsZW1lbnQua2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2UoZWxlbWVudC5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpKSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB0cnlDb250ZXh0dWFsID0gZnVuY3Rpb24gKGssIG5vTGluZUJyZWFrKSB7XG4gICAgICBpZiAoIG5vTGluZUJyZWFrID09PSB2b2lkIDAgKSBub0xpbmVCcmVhayA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgICAgaWYgKCF0aGlzJDEuZWF0Q29udGV4dHVhbChrKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKHRoaXMkMS50eXBlICE9PSB0eXBlcy5wYXJlbkwgJiYgKCFub0xpbmVCcmVhayB8fCAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIG1ldGhvZC5rZXkgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnQsIHN0YXJ0TG9jKTtcbiAgICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgICB0aGlzJDEuZmluaXNoTm9kZShtZXRob2Qua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9O1xuXG4gICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgIG1ldGhvZC5zdGF0aWMgPSB0cnlDb250ZXh0dWFsKFwic3RhdGljXCIpO1xuICAgIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gICAgaWYgKCFpc0dlbmVyYXRvcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwiZ2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJzZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gICAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gICAgdmFyIGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgIGlmIChtZXRob2Qua2luZCAhPT0gXCJtZXRob2RcIikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXJcIik7IH1cbiAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgICBtZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgIGFsbG93c0RpcmVjdFN1cGVyID0gY29uc3RydWN0b3JBbGxvd3NTdXBlcjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAwKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIHJldHVybiBtZXRob2RcbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudClcbiAgICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQgPT09IHRydWUpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBwcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gIH07XG5cbiAgLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbiAgcHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnN0YXIpKSB7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgICAgdmFyIGlzQXN5bmM7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICAgIHZhciBjTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIilcbiAgICB9XG4gICAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgZXhwb3J0IGlzIGRlZmluZWRcbiAgICAgICAgICB0aGlzLmNoZWNrTG9jYWxFeHBvcnQoc3BlYy5sb2NhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDEuY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBpZiAoaGFzKGV4cG9ydHMsIG5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICAgIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHBwJDEuY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gICAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXQucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwcm9wKTtcbiAgICAgICAgfSB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICAgIHsgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gcGF0LmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgICBpZiAoZWx0KSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGVsdCk7IH1cbiAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUHJvcGVydHlcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LnZhbHVlKTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuZXhwcmVzc2lvbik7IH1cbiAgfTtcblxuICBwcCQxLmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICAgIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIGRlY2wgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMS5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgdGhpcy5pc0xldCgpIHx8XG4gICAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbiAgcHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWw7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgbm9kZS5leHBvcnRlZC5zdGFydCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG4gIC8vIFBhcnNlcyBpbXBvcnQgZGVjbGFyYXRpb24uXG5cbiAgcHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICAvLyBpbXBvcnQgJy4uLidcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICBwcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUkMi5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgICBub2RlJDIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICAgIG5vZGUkMi5sb2NhbCA9IG5vZGUkMi5pbXBvcnRlZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfTtcblxuICAvLyBTZXQgYEV4cHJlc3Npb25TdGF0ZW1lbnQjZGlyZWN0aXZlYCBwcm9wZXJ0eSBmb3IgZGlyZWN0aXZlIHByb2xvZ3Vlcy5cbiAgcHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGggJiYgdGhpcy5pc0RpcmVjdGl2ZUNhbmRpZGF0ZShzdGF0ZW1lbnRzW2ldKTsgKytpKSB7XG4gICAgICBzdGF0ZW1lbnRzW2ldLmRpcmVjdGl2ZSA9IHN0YXRlbWVudHNbaV0uZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgfTtcbiAgcHAkMS5pc0RpcmVjdGl2ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudCkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0YXRlbWVudC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmXG4gICAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4gIC8vIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDIudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgICAvLyBFYXJseSBlcnJvcjpcbiAgICAgICAgICAvLyAgIEFzc2lnbm1lbnRSZXN0UHJvcGVydHlbWWllbGQsIEF3YWl0XSA6XG4gICAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgSXQgaXMgYSBTeW50YXggRXJyb3IgaWYgfERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0fCBpcyBhbiB8QXJyYXlMaXRlcmFsfCBvciBhbiB8T2JqZWN0TGl0ZXJhbHwuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAgIChwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgcHJvcC5hcmd1bWVudC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIkFycmF5UGF0dGVyblwiO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmFyZ3VtZW50LCBpc0JpbmRpbmcpO1xuICAgICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgICAvLyBmYWxscyB0aHJvdWdoIHRvIEFzc2lnbm1lbnRQYXR0ZXJuXG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG4gIHBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKGxhc3QuYXJndW1lbnQuc3RhcnQpOyB9XG4gICAgfVxuICAgIHJldHVybiBleHByTGlzdFxuICB9O1xuXG4gIC8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxuICBwcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9O1xuXG4gIC8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxuICB9O1xuXG4gIHBwJDIucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgICBlbHNlIHsgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpOyB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7XG4gICAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICAgIGVsdHMucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfTtcblxuICBwcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW1cbiAgfTtcblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDIucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgfTtcblxuICAvLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4gIC8vIHRvLlxuICAvLyBiaW5kaW5nVHlwZSBjYW4gYmUgZWl0aGVyOlxuICAvLyAndmFyJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhICd2YXInIGJpbmRpbmdcbiAgLy8gJ2xldCcgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSBsZXhpY2FsICgnbGV0JyBvciAnY29uc3QnKSBiaW5kaW5nXG4gIC8vICdub25lJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGJpbmRpbmcgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIGlsbGVnYWwgaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGR1cGxpY2F0ZSByZWZlcmVuY2VzXG5cbiAgcHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCAmJiBleHByLm5hbWUgPT09IFwibGV0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkUgJiYgYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChiaW5kaW5nVHlwZSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwci5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQSByZWN1cnNpdmUgZGVzY2VudCBwYXJzZXIgb3BlcmF0ZXMgYnkgZGVmaW5pbmcgZnVuY3Rpb25zIGZvciBhbGxcblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbiAgLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuICAvLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4gIC8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbiAgcHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgICB7IHJldHVybiB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSlcbiAgICAgIHsgcmV0dXJuIH1cbiAgICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gICAgdmFyIG5hbWU7XG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuICAgIHZhciBraW5kID0gcHJvcC5raW5kO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB7XG4gICAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA8IDApIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDsgfVxuICAgICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXQga2x1ZGdlLiBDYW4gYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMFxuICAgICAgICAgIGVsc2UgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgICAgfVxuICAgICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgICB2YXIgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXTtcbiAgICBpZiAob3RoZXIpIHtcbiAgICAgIHZhciByZWRlZmluaXRpb247XG4gICAgICBpZiAoa2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkZWZpbml0aW9uID0gb3RoZXIuaW5pdCB8fCBvdGhlcltraW5kXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgICAgaW5pdDogZmFsc2UsXG4gICAgICAgIGdldDogZmFsc2UsXG4gICAgICAgIHNldDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIG90aGVyW2tpbmRdID0gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbiAgLy8gVGhlc2UgbmVzdCwgZnJvbSB0aGUgbW9zdCBnZW5lcmFsIGV4cHJlc3Npb24gdHlwZSBhdCB0aGUgdG9wIHRvXG4gIC8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4gIC8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuICAvLyBhbmQsICppZiogdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhleSBoYW5kbGUgaXMgcHJlc2VudCwgd3JhcFxuICAvLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbiAgLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbiAgLy8gZm9yYmlkIHRoZSBgaW5gIG9wZXJhdG9yIChpbiBmb3IgbG9vcHMgaW5pdGFsaXphdGlvbiBleHByZXNzaW9ucylcbiAgLy8gYW5kIHByb3ZpZGUgcmVmZXJlbmNlIGZvciBzdG9yaW5nICc9JyBvcGVyYXRvciBpbnNpZGUgc2hvcnRoYW5kXG4gIC8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuICAvLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4gIC8vIGRlbGF5ZWQgc3ludGF4IGVycm9yIGF0IGNvcnJlY3QgcG9zaXRpb24pLlxuXG4gIHBwJDMucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG4gIC8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2ZcbiAgLy8gb3BlcmF0b3JzIGxpa2UgYCs9YC5cblxuICBwcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7XG4gICAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAgIC8vIFRoZSB0b2tlbml6ZXIgd2lsbCBhc3N1bWUgYW4gZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGFmdGVyXG4gICAgICAvLyBgeWllbGRgLCBidXQgdGhpcyBpc24ndCB0aGF0IGtpbmQgb2YgeWllbGRcbiAgICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgICB9XG5cbiAgICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTEsIG9sZFNob3J0aGFuZEFzc2lnbiA9IC0xO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBvbGRQYXJlbkFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbjtcbiAgICAgIG9sZFRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWE7XG4gICAgICBvbGRTaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgICAgeyB0aGlzLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXJ0OyB9XG4gICAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICAgIGlmICh0aGlzLnR5cGUuaXNBc3NpZ24pIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmVxID8gdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIDogbGVmdDtcbiAgICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyBEZXN0cnVjdHVyaW5nRXJyb3JzLmNhbGwocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgIH1cbiAgICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICAgIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICAgIGlmIChvbGRTaG9ydGhhbmRBc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IG9sZFNob3J0aGFuZEFzc2lnbjsgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxuICBwcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH07XG5cbiAgLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG4gIHBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG4gIH07XG5cbiAgLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbiAgLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbiAgLy8gYG1pblByZWNgIHByb3ZpZGVzIGNvbnRleHQgdGhhdCBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIHN0b3AgYW5kXG4gIC8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbiAgLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG4gIHBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICAgIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICAgIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuICBwcCQzLmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxuICBwcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgICAgc2F3VW5hcnkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzYXdVbmFyeSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyc3RhcikpXG4gICAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gZXhwciB9XG4gIH07XG5cbiAgLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbiAgcHAkMy5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB2YXIgc2tpcEFycm93U3Vic2NyaXB0cyA9IGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva0VuZCkgIT09IFwiKVwiO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5pbnB1dC5zbGljZShiYXNlLnN0YXJ0LCBiYXNlLmVuZCkgPT09IFwiYXN5bmNcIjtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KTtcbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7IHJldHVybiBlbGVtZW50IH1cbiAgICAgIGJhc2UgPSBlbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3cpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG4gICAgaWYgKGNvbXB1dGVkIHx8IHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IGNvbXB1dGVkID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7IHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTsgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgYmFzZS50eXBlICE9PSBcIkltcG9ydFwiLCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIGlmICh0aGlzLmF3YWl0SWRlbnRQb3MgPiAwKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuICAgICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgICBpZiAobm9kZSQxLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICAgIGlmIChub2RlJDEuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZSQxLnN0YXJ0LCBcImltcG9ydCgpIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltcG9ydEFyZyA9IG5vZGUkMS5hcmd1bWVudHNbMF07XG4gICAgICAgIGlmIChpbXBvcnRBcmcgJiYgaW1wb3J0QXJnLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShpbXBvcnRBcmcuc3RhcnQsIFwiLi4uIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlKSB7XG4gICAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgICBub2RlJDIucXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGUoe2lzVGFnZ2VkOiB0cnVlfSk7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBiYXNlXG4gIH07XG5cbiAgLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4gIC8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4gIC8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuICAvLyBvciBge31gLlxuXG4gIHBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gICAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gICAgdmFyIG5vZGUsIGNhbkJlQXJyb3cgPSB0aGlzLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhcnQ7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInc3VwZXInIGtleXdvcmQgb3V0c2lkZSBhIG1ldGhvZFwiKTsgfVxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgICAgLy8gICAgIHN1cGVyIFsgRXhwcmVzc2lvbiBdXG4gICAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgICAgLy8gU3VwZXJDYWxsOlxuICAgICAgLy8gICAgIHN1cGVyIEFyZ3VtZW50c1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2tldEwgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpXG4gICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKVxuXG4gICAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMubmFtZTpcbiAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIDAsIGZhbHNlLCB0cnVlKSB9XG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICBpZiAodGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCBmYWxzZSkgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiAhY29udGFpbnNFc2MpIHtcbiAgICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpZFxuXG4gICAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICAgIHJldHVybiBub2RlXG5cbiAgICBjYXNlIHR5cGVzLm51bTogY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICAgIGNhc2UgdHlwZXMuX251bGw6IGNhc2UgdHlwZXMuX3RydWU6IGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcy5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl90cnVlO1xuICAgICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuXG4gICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU5ldygpXG5cbiAgICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgdmFsLCBhbGxvd1RyYWlsaW5nQ29tbWEgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gODtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICB2YXIgaW5uZXJTdGFydFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICAvLyBEbyBub3Qgc2F2ZSBhd2FpdElkZW50UG9zIHRvIGFsbG93IGNoZWNraW5nIGF3YWl0cyBuZXN0ZWQgaW4gcGFyYW1ldGVyc1xuICAgICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgICAgbGFzdElzQ29tbWEgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgICBpZiAoc3ByZWFkU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0KTsgfVxuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcyB8fCB0aGlzLmF3YWl0UG9zO1xuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgICB2YWwuZXhwcmVzc2lvbnMgPSBleHByTGlzdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1cbiAgfTtcblxuICBwcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbiAgfTtcblxuICAvLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbiAgLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuICAvLyBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGUgbm9DYWxsc1xuICAvLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbiAgLy8gYXJndW1lbnQgbGlzdC5cblxuICB2YXIgZW1wdHkkMSA9IFtdO1xuXG4gIHBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIgfHwgY29udGFpbnNFc2MpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIG5ldy50YXJnZXRcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk5vbkFycm93RnVuY3Rpb24oKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuY2FsbGVlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLilcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgbm9kZS5jYWxsZWUudHlwZSAhPT0gXCJJbXBvcnRcIiwgZmFsc2UpOyB9XG4gICAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxuICBwcCQzLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gICAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkge1xuICAgICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgICB9XG4gICAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICAgIGNvb2tlZDogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuYmFja1F1b3RlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gICAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gICAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lb2YpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbFwiKTsgfVxuICAgICAgdGhpcy5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlUik7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICB9O1xuXG4gIHBwJDMuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfTtcblxuICAvLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbiAgcHAkMy5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgICB9XG4gICAgICAvLyBUbyBkaXNhbGxvdyBwYXJlbnRoZXNpemVkIGlkZW50aWZpZXIgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUGFyc2UgYXJndW1lbnQuXG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIC8vIEZpbmlzaFxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgICB9XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29sb24pXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBzdGFydFBvczsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICAgIHJldHVybiBwcm9wLmtleVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG4gIHBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyBub2RlLmdlbmVyYXRvciA9IG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxuICB9O1xuXG4gIC8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbiAgcHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCB0cnVlKTtcblxuICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbiAgcHAkMy5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICAgIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKSB8IFNDT1BFX0FSUk9XKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICAgIG5vZGUucGFyYW1zID0gdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJ1ZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxuICBwcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCkge1xuICAgIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZUw7XG4gICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgICB9XG4gICAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgICAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdmFyRGVjbGFyZWROYW1lcyB0byBlbnN1cmUgdGhhdCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgaXNuJ3QgYSBmb3JiaWRkZW4gaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZSwgZS5nLiAnZXZhbCdcbiAgICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gICAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gIH07XG5cbiAgcHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgICB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8vIENoZWNrcyBmdW5jdGlvbiBwYXJhbXMgZm9yIHZhcmlvdXMgZGlzYWxsb3dlZCBwYXR0ZXJucyBzdWNoIGFzIHVzaW5nIFwiZXZhbFwiXG4gIC8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG4gIHBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgbmFtZUhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbiAgLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbiAgLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuICAvLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbiAgLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxuICBwcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKVxuICAgICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChlbHQpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDMuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgICB7IHRoaXMucmFpc2Uoc3RhcnQsIChcIlVuZXhwZWN0ZWQga2V5d29yZCAnXCIgKyBuYW1lICsgXCInXCIpKTsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICAgIHZhciByZSA9IHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzO1xuICAgIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2Uga2V5d29yZCAnYXdhaXQnIG91dHNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4gIC8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuICAvLyBpZGVudGlmaWVycy5cblxuICBwcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZDtcblxuICAgICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlcy81NzVcbiAgICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAgIC8vIEJ1dCB0aGVyZSBpcyBubyBjaGFuY2UgdG8gcG9wIHRoZSBjb250ZXh0IGlmIHRoZSBrZXl3b3JkIGlzIGNvbnN1bWVkIGFzIGFuIGlkZW50aWZpZXIgc3VjaCBhcyBhIHByb3BlcnR5IG5hbWUuXG4gICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgYSBkb3QsIHRoaXMgZG9lcyBub3QgYXBwbHkgYmVjYXVzZSB0aGUgY29udGV4dC1tYW5hZ2luZyBjb2RlIGFscmVhZHkgaWdub3JlZCB0aGUga2V5d29yZFxuICAgICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAodGhpcy5sYXN0VG9rRW5kICE9PSB0aGlzLmxhc3RUb2tTdGFydCArIDEgfHwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSAhPT0gNDYpKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKCFsaWJlcmFsKSB7XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTtcbiAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICAvLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG4gIHBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5hd2FpdFBvcykgeyB0aGlzLmF3YWl0UG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgdmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbiAgLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbiAgLy8gdGhlIGxvY2F0aW9uIG9mIHRoZSBlcnJvciwgYXR0YWNoZXMgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbmRcbiAgLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4gIC8vIG1lc3NhZ2UuXG5cbiAgcHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICAgIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICAgIHRocm93IGVyclxuICB9O1xuXG4gIHBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbiAgcHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIC8vIEEgbGlzdCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAgIHRoaXMudmFyID0gW107XG4gICAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gICAgdGhpcy5sZXhpY2FsID0gW107XG4gICAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICB9O1xuXG4gIC8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxuICBwcCQ1LmVudGVyU2NvcGUgPSBmdW5jdGlvbihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xuICB9O1xuXG4gIHBwJDUuZXhpdFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbiAgLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxuICBwcCQ1LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlID0gZnVuY3Rpb24oc2NvcGUpIHtcbiAgICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbiAgfTtcblxuICBwcCQ1LmRlY2xhcmVOYW1lID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ1R5cGUsIHBvcykge1xuICAgIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICAgIHZhciBzY29wZSQxID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICAgIHZhciBzY29wZSQyID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIGlmIChzY29wZSQzLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xICYmICEoKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9TSU1QTEVfQ0FUQ0gpICYmIHNjb3BlJDMubGV4aWNhbFswXSA9PT0gbmFtZSkgfHxcbiAgICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxuICB9O1xuXG4gIHBwJDUuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgICBpZiAodGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihpZC5uYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gICAgfVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV1cbiAgfTtcblxuICBwcCQ1LmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxuICBwcCQ1LmN1cnJlbnRUaGlzU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUiAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfQVJST1cpKSB7IHJldHVybiBzY29wZSB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcbiAgICB0aGlzLnN0YXJ0ID0gcG9zO1xuICAgIHRoaXMuZW5kID0gMDtcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICAgIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxuICB9O1xuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgdmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG4gIH07XG5cbiAgcHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIG5vZGUuZW5kID0gcG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBub2RlLmxvYy5lbmQgPSBsb2M7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9O1xuXG4gIC8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbiAgcHAkNi5maW5pc2hOb2RlQXQgPSBmdW5jdGlvbihub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbiAgfTtcblxuICAvLyBUaGUgYWxnb3JpdGhtIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSByZWdleHAgY2FuIGFwcGVhciBhdCBhXG5cbiAgdmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG4gIH07XG5cbiAgdmFyIHR5cGVzJDEgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNy5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG4gIH07XG5cbiAgcHAkNy5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmZfZXhwciB8fCBwYXJlbnQgPT09IHR5cGVzJDEuZl9zdGF0KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAgIC8vIGB0dC5uYW1lYC5cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcy5hcnJvdylcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG4gIH07XG5cbiAgcHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFtpXTtcbiAgICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICAgIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gICAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbiAgfTtcblxuICAvLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbiAgdHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIGlmIChvdXQgPT09IHR5cGVzJDEuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcyQxLmJfc3RhdCA6IHR5cGVzJDEuYl9leHByKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gICAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wX3N0YXQgOiB0eXBlcyQxLnBfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfTtcblxuICB0eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYl9zdGF0KSlcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfc3RhdCk7IH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH07XG5cbiAgdHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgICAgeyB0aGlzLmNvbnRleHQucG9wKCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2V4cHJfZ2VuOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgYWxsb3dlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJvZlwiICYmICF0aGlzLmV4cHJBbGxvd2VkIHx8XG4gICAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICAgIHsgYWxsb3dlZCA9IHRydWU7IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG4gIH07XG5cbiAgLy8gVGhpcyBmaWxlIGNvbnRhaW5zIFVuaWNvZGUgcHJvcGVydGllcyBleHRyYWN0ZWQgZnJvbSB0aGUgRUNNQVNjcmlwdFxuICAvLyBzcGVjaWZpY2F0aW9uLiBUaGUgbGlzdHMgYXJlIGV4dHJhY3RlZCBsaWtlIHNvOlxuICAvLyAkJCgnI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXMgPiBmaWd1cmUgPiB0YWJsZSA+IHRib2R5ID4gdHIgPiB0ZDpudGgtY2hpbGQoMSkgY29kZScpLm1hcChlbCA9PiBlbC5pbm5lclRleHQpXG5cbiAgLy8gI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXNcbiAgdmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG4gIHZhciBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTlCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRXh0ZW5kZWRfUGljdG9ncmFwaGljXCI7XG4gIHZhciBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTEwQmluYXJ5UHJvcGVydGllcztcbiAgdmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICAgIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgICAxMDogZWNtYTEwQmluYXJ5UHJvcGVydGllcyxcbiAgICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllc1xuICB9O1xuXG4gIC8vICN0YWJsZS11bmljb2RlLWdlbmVyYWwtY2F0ZWdvcnktdmFsdWVzXG4gIHZhciB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzID0gXCJDYXNlZF9MZXR0ZXIgTEMgQ2xvc2VfUHVuY3R1YXRpb24gUGUgQ29ubmVjdG9yX1B1bmN0dWF0aW9uIFBjIENvbnRyb2wgQ2MgY250cmwgQ3VycmVuY3lfU3ltYm9sIFNjIERhc2hfUHVuY3R1YXRpb24gUGQgRGVjaW1hbF9OdW1iZXIgTmQgZGlnaXQgRW5jbG9zaW5nX01hcmsgTWUgRmluYWxfUHVuY3R1YXRpb24gUGYgRm9ybWF0IENmIEluaXRpYWxfUHVuY3R1YXRpb24gUGkgTGV0dGVyIEwgTGV0dGVyX051bWJlciBObCBMaW5lX1NlcGFyYXRvciBabCBMb3dlcmNhc2VfTGV0dGVyIExsIE1hcmsgTSBDb21iaW5pbmdfTWFyayBNYXRoX1N5bWJvbCBTbSBNb2RpZmllcl9MZXR0ZXIgTG0gTW9kaWZpZXJfU3ltYm9sIFNrIE5vbnNwYWNpbmdfTWFyayBNbiBOdW1iZXIgTiBPcGVuX1B1bmN0dWF0aW9uIFBzIE90aGVyIEMgT3RoZXJfTGV0dGVyIExvIE90aGVyX051bWJlciBObyBPdGhlcl9QdW5jdHVhdGlvbiBQbyBPdGhlcl9TeW1ib2wgU28gUGFyYWdyYXBoX1NlcGFyYXRvciBacCBQcml2YXRlX1VzZSBDbyBQdW5jdHVhdGlvbiBQIHB1bmN0IFNlcGFyYXRvciBaIFNwYWNlX1NlcGFyYXRvciBacyBTcGFjaW5nX01hcmsgTWMgU3Vycm9nYXRlIENzIFN5bWJvbCBTIFRpdGxlY2FzZV9MZXR0ZXIgTHQgVW5hc3NpZ25lZCBDbiBVcHBlcmNhc2VfTGV0dGVyIEx1XCI7XG5cbiAgLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xuICB2YXIgZWNtYTlTY3JpcHRWYWx1ZXMgPSBcIkFkbGFtIEFkbG0gQWhvbSBBaG9tIEFuYXRvbGlhbl9IaWVyb2dseXBocyBIbHV3IEFyYWJpYyBBcmFiIEFybWVuaWFuIEFybW4gQXZlc3RhbiBBdnN0IEJhbGluZXNlIEJhbGkgQmFtdW0gQmFtdSBCYXNzYV9WYWggQmFzcyBCYXRhayBCYXRrIEJlbmdhbGkgQmVuZyBCaGFpa3N1a2kgQmhrcyBCb3BvbW9mbyBCb3BvIEJyYWhtaSBCcmFoIEJyYWlsbGUgQnJhaSBCdWdpbmVzZSBCdWdpIEJ1aGlkIEJ1aGQgQ2FuYWRpYW5fQWJvcmlnaW5hbCBDYW5zIENhcmlhbiBDYXJpIENhdWNhc2lhbl9BbGJhbmlhbiBBZ2hiIENoYWttYSBDYWttIENoYW0gQ2hhbSBDaGVyb2tlZSBDaGVyIENvbW1vbiBaeXl5IENvcHRpYyBDb3B0IFFhYWMgQ3VuZWlmb3JtIFhzdXggQ3lwcmlvdCBDcHJ0IEN5cmlsbGljIEN5cmwgRGVzZXJldCBEc3J0IERldmFuYWdhcmkgRGV2YSBEdXBsb3lhbiBEdXBsIEVneXB0aWFuX0hpZXJvZ2x5cGhzIEVneXAgRWxiYXNhbiBFbGJhIEV0aGlvcGljIEV0aGkgR2VvcmdpYW4gR2VvciBHbGFnb2xpdGljIEdsYWcgR290aGljIEdvdGggR3JhbnRoYSBHcmFuIEdyZWVrIEdyZWsgR3VqYXJhdGkgR3VqciBHdXJtdWtoaSBHdXJ1IEhhbiBIYW5pIEhhbmd1bCBIYW5nIEhhbnVub28gSGFubyBIYXRyYW4gSGF0ciBIZWJyZXcgSGViciBIaXJhZ2FuYSBIaXJhIEltcGVyaWFsX0FyYW1haWMgQXJtaSBJbmhlcml0ZWQgWmluaCBRYWFpIEluc2NyaXB0aW9uYWxfUGFobGF2aSBQaGxpIEluc2NyaXB0aW9uYWxfUGFydGhpYW4gUHJ0aSBKYXZhbmVzZSBKYXZhIEthaXRoaSBLdGhpIEthbm5hZGEgS25kYSBLYXRha2FuYSBLYW5hIEtheWFoX0xpIEthbGkgS2hhcm9zaHRoaSBLaGFyIEtobWVyIEtobXIgS2hvamtpIEtob2ogS2h1ZGF3YWRpIFNpbmQgTGFvIExhb28gTGF0aW4gTGF0biBMZXBjaGEgTGVwYyBMaW1idSBMaW1iIExpbmVhcl9BIExpbmEgTGluZWFyX0IgTGluYiBMaXN1IExpc3UgTHljaWFuIEx5Y2kgTHlkaWFuIEx5ZGkgTWFoYWphbmkgTWFoaiBNYWxheWFsYW0gTWx5bSBNYW5kYWljIE1hbmQgTWFuaWNoYWVhbiBNYW5pIE1hcmNoZW4gTWFyYyBNYXNhcmFtX0dvbmRpIEdvbm0gTWVldGVpX01heWVrIE10ZWkgTWVuZGVfS2lrYWt1aSBNZW5kIE1lcm9pdGljX0N1cnNpdmUgTWVyYyBNZXJvaXRpY19IaWVyb2dseXBocyBNZXJvIE1pYW8gUGxyZCBNb2RpIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG4gIHZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG4gIHZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbiAgdmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gICAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gICAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgICAxMTogZWNtYTExU2NyaXB0VmFsdWVzXG4gIH07XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICAgIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBub25CaW5hcnk6IHtcbiAgICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgICB9XG4gICAgfTtcbiAgICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICAgIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbiAgfVxuICBidWlsZFVuaWNvZGVEYXRhKDkpO1xuICBidWlsZFVuaWNvZGVEYXRhKDEwKTtcbiAgYnVpbGRVbmljb2RlRGF0YSgxMSk7XG5cbiAgdmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gICAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgPyAxMSA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgICB0aGlzLmJhY2tSZWZlcmVuY2VOYW1lcyA9IFtdO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbiAgfTtcblxuICAvLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuICAvLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIGF0IChpKSB7XG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gICAgcmV0dXJuIG5leHQgPj0gMHhEQzAwICYmIG5leHQgPD0gMHhERkZGID8gKGMgPDwgMTApICsgbmV4dCAtIDB4MzVGREMwMCA6IGNcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSkge1xuICAgIHZhciBzID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICBpZiAoaSA+PSBsKSB7XG4gICAgICByZXR1cm4gbFxuICAgIH1cbiAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsIHx8XG4gICAgICAgIChuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweERDMDAgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIGkgKyAxXG4gICAgfVxuICAgIHJldHVybiBpICsgMlxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmF0KHRoaXMucG9zKVxuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcykpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoKSB7XG4gICAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcyk7XG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCgpID09PSBjaCkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjaCkge1xuICAgIGlmIChjaCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpIH1cbiAgICBjaCAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwcCQ4LnZhbGlkYXRlUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHAkOC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gICAgLy8gVGhlIGdvYWwgc3ltYm9sIGZvciB0aGUgcGFyc2UgaXMgfFBhdHRlcm5bflUsIH5OXXwuIElmIHRoZSByZXN1bHQgb2ZcbiAgICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAgIC8vIGV4Y2VwdGlvbiBpZiBfUF8gZGlkIG5vdCBjb25mb3JtIHRvIHRoZSBncmFtbWFyLCBpZiBhbnkgZWxlbWVudHMgb2YgX1BfXG4gICAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICAgIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbiAgcHAkOC5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUucG9zID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxuICBwcCQ4LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUFsdGVybmF0aXZlXG4gIHBwJDgucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICAgIHsgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG4gIHBwJDgucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAgIC8vIGBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGVgIGlzIHRydWUgaWYgdGhlIGxhc3QgZWF0ZW4gQXNzZXJ0aW9uXG4gICAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxuICBwcCQ4LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAgIC8vIF4sICRcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUUgLyogXiAqLykgfHwgc3RhdGUuZWF0KDB4MjQgLyogJCAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gXFxiIFxcQlxuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxuICBwcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG4gIHBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG4gIHBwJDgucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxuICBwcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG4gIHBwJDgucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxuICBwcCQ4LnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgICBjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovIHx8XG4gICAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RSAvKiBeICovIHx8XG4gICAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuICAvLyBCdXQgZWF0IGVhZ2VyLlxuICBwcCQ4LnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChcbiAgICAgIGNoICE9PSAtMSAmJlxuICAgICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgICAgY2ggIT09IDB4MkUgLyogLiAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgICAgY2ggIT09IDB4NUUgLyogXiAqLyAmJlxuICAgICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICAgICkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gR3JvdXBTcGVjaWZpZXJbVV0gOjpcbiAgLy8gICBbZW1wdHldXG4gIC8vICAgYD9gIEdyb3VwTmFtZVs/VV1cbiAgcHAkOC5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEdyb3VwTmFtZVtVXSA6OlxuICAvLyAgIGA8YCBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gYD5gXG4gIC8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxuICBwcCQ4LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNFIC8qID4gKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBSZWdFeHBJZGVudGlmaWVyTmFtZVtVXSA6OlxuICAvLyAgIFJlZ0V4cElkZW50aWZpZXJTdGFydFs/VV1cbiAgLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gUmVnRXhwSWRlbnRpZmllclBhcnRbP1VdXG4gIC8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gUmVnRXhwSWRlbnRpZmllclN0YXJ0W1VdIDo6XG4gIC8vICAgVW5pY29kZUlEU3RhcnRcbiAgLy8gICBgJGBcbiAgLy8gICBgX2BcbiAgLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV1cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG4gIH1cblxuICAvLyBSZWdFeHBJZGVudGlmaWVyUGFydFtVXSA6OlxuICAvLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4gIC8vICAgYCRgXG4gIC8vICAgYF9gXG4gIC8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbP1VdXG4gIC8vICAgPFpXTko+XG4gIC8vICAgPFpXSj5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gICAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgICAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NkIgLyogayAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2hhcmFjdGVyRXNjYXBlXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlKHN0YXRlKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBpZiAoc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwIC8qIDAgKi8gJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA9PT0gMHg3NCAvKiB0ICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2RSAvKiBuICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBBOyAvKiBcXG4gKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyAvKiBcXHYgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2NiAvKiBmICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg3MiAvKiByICovKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBEOyAvKiBcXHIgKi9cbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNvbnRyb2xMZXR0ZXJcbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc0NvbnRyb2xMZXR0ZXIoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg1QSAvKiBaICovKSB8fFxuICAgICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gICAgKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgIHZhciBsZWFkID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICAgIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykgJiYgc3RhdGUuZWF0KDB4NzUgLyogdSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAobGVhZCAtIDB4RDgwMCkgKiAweDQwMCArICh0cmFpbCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgICB0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoc3RhdGUpICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxuICBwcCQ4LnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxFc2NhcGVcbiAgcHAkOC5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwIC8qIDAgKi8pO1xuICAgICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc0VzY2FwZVxuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gICAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAgIChjaCA9PT0gMHg1MCAvKiBQICovIHx8IGNoID09PSAweDcwIC8qIHAgKi8pXG4gICAgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgICAgdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkge1xuICAgIHJldHVybiAoXG4gICAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgICBjaCA9PT0gMHg0NCAvKiBEICovIHx8XG4gICAgICBjaCA9PT0gMHg3MyAvKiBzICovIHx8XG4gICAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgICBjaCA9PT0gMHg3NyAvKiB3ICovIHx8XG4gICAgICBjaCA9PT0gMHg1NyAvKiBXICovXG4gICAgKVxuICB9XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgLy8gICBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIGA9YCBVbmljb2RlUHJvcGVydHlWYWx1ZVxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSkge1xuICAgICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG5cbiAgICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIG5hbWVPclZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIHBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFoYXMoc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeVtuYW1lXS50ZXN0KHZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG4gIH07XG4gIHBwJDgucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZU9yVmFsdWUpIHtcbiAgICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSlcbiAgICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgfTtcblxuICAvLyBVbmljb2RlUHJvcGVydHlOYW1lIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbiAgcHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gMDtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICAgIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG4gIGZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICAgIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbiAgfVxuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlIDo6XG4gIC8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG4gIGZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaClcbiAgfVxuXG4gIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA6OlxuICAvLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xuICBwcCQ4LnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc1xuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVCIC8qIFsgKi8pKSB7XG4gICAgICBzdGF0ZS5lYXQoMHg1RSAvKiBeICovKTtcbiAgICAgIHRoaXMucmVnZXhwX2NsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgLy8gVW5yZWFjaGFibGUgc2luY2UgaXQgdGhyZXcgXCJ1bnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIgZXJyb3IgYmVmb3JlLlxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Ob25lbXB0eUNsYXNzUmFuZ2VzXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbiAgcHAkOC5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbiAgcHAkOC5yZWdleHBfZWF0Q2xhc3NBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NFc2NhcGUoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoY2gkMSA9PT0gMHg2MyAvKiBjICovIHx8IGlzT2N0YWxEaWdpdChjaCQxKSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggIT09IDB4NUQgLyogWyAqLykge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DbGFzc0VzY2FwZVxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzQ29udHJvbExldHRlclxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG4gIHBwJDgucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxEaWdpdHNcbiAgcHAkOC5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleERpZ2l0c1xuICBwcCQ4LnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykgfHxcbiAgICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pXG4gICAgKVxuICB9XG4gIGZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gICAgaWYgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgICB9XG4gICAgaWYgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pIHtcbiAgICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgICB9XG4gICAgcmV0dXJuIGNoIC0gMHgzMCAvKiAwICovXG4gIH1cblxuICAvLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItTGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZVxuICAvLyBBbGxvd3Mgb25seSAwLTM3NyhvY3RhbCkgaS5lLiAwLTI1NShkZWNpbWFsKS5cbiAgcHAkOC5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgdmFyIG4yID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtT2N0YWxEaWdpdFxuICBwcCQ4LnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM3IC8qIDcgKi9cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleDREaWdpdHNcbiAgLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRcbiAgLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG4gIHBwJDgucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzID0gZnVuY3Rpb24oc3RhdGUsIGxlbmd0aCkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuICAvLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4gIC8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gICAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gICAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG4gIH07XG5cbiAgLy8gIyMgVG9rZW5pemVyXG5cbiAgdmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIC8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxuICBwcCQ5Lm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICAgIHRoaXMubGFzdFRva0VuZCA9IHRoaXMuZW5kO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfTtcblxuICBwcCQ5LmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxuICB9O1xuXG4gIC8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHsgcHAkOVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMS5nZXRUb2tlbigpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSB0eXBlcy5lb2YsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyB9XG5cbiAgLy8gVG9nZ2xlIHN0cmljdCBtb2RlLiBSZS1yZWFkcyB0aGUgbmV4dCBudW1iZXIgb3Igc3RyaW5nIHRvIHBsZWFzZVxuICAvLyBwZWRhbnRpYyB0ZXN0cyAoYFwidXNlIHN0cmljdFwiOyAwMTA7YCBzaG91bGQgZmFpbCkuXG5cbiAgcHAkOS5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoIC0gMV1cbiAgfTtcblxuICAvLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbiAgLy8gcHJvcGVydGllcy5cblxuICBwcCQ5Lm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHsgdGhpcy5za2lwU3BhY2UoKTsgfVxuXG4gICAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKSB9XG5cbiAgICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gICAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxuICB9O1xuXG4gIHBwJDkuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSB7IHJldHVybiBjb2RlIH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHJldHVybiAoY29kZSA8PCAxMCkgKyBuZXh0IC0gMHgzNWZkYzAwXG4gIH07XG5cbiAgcHAkOS5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gICAgdGhpcy5wb3MgPSBlbmQgKyAyO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0aGlzLnBvcykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICBwcCQ5LnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoICYmICFpc05ld0xpbmUoY2gpKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMucG9zKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxuICB9O1xuXG4gIC8vIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhcnNlIGFuZCBhZnRlciBldmVyeSB0b2tlbi4gU2tpcHNcbiAgLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxuICBwcCQ5LnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAzMjogY2FzZSAxNjA6IC8vICcgJ1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpKSB7XG4gICAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4gIC8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbiAgLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbiAgLy8gcmlnaHQgcG9zaXRpb24uXG5cbiAgcHAkOS5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgLy8gaW50byBpdC5cbiAgLy9cbiAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAvL1xuICBwcCQ5LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHsgcmV0dXJuIHRoaXMucmVhZE51bWJlcih0cnVlKSB9XG4gICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0NikgeyAvLyA0NiA9IGRvdCAnLidcbiAgICAgIHRoaXMucG9zICs9IDM7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lbGxpcHNpcylcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvdClcbiAgICB9XG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5zbGFzaCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gICAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiBjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0Mikge1xuICAgICAgKytzaXplO1xuICAgICAgdG9rZW50eXBlID0gdHlwZXMuc3RhcnN0YXI7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0b2tlbnR5cGUsIHNpemUpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyAvLyAnXidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAgIC8vIEEgYC0tPmAgbGluZSBjb21tZW50XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuaW5jRGVjLCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgc2l6ZSkgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMzMgJiYgY29kZSA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hcnJvdylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcy5lcSA6IHR5cGVzLnByZWZpeCwgMSlcbiAgfTtcblxuICBwcCQ5LmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAgIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgICBjYXNlIDQ2OiAvLyAnLidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gICAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICAgIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuTClcbiAgICBjYXNlIDQxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlblIpXG4gICAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSlcbiAgICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb21tYSlcbiAgICBjYXNlIDkxOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0TClcbiAgICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0UilcbiAgICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKVxuICAgIGNhc2UgMTI1OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpXG4gICAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pXG4gICAgY2FzZSA2MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pXG5cbiAgICBjYXNlIDk2OiAvLyAnYCdcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG5cbiAgICBjYXNlIDQ4OiAvLyAnMCdcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigxNikgfSAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIH0gLy8gJzBiJywgJzBCJyAtIGJpbmFyeSBudW1iZXJcbiAgICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAgIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gICAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMS05XG4gICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gICAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgICBjYXNlIDM0OiBjYXNlIDM5OiAvLyAnXCInLCBcIidcIlxuICAgICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG4gICAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gICAgLy8gb2Z0ZW4gcmVmZXJyZWQgdG8uIGBmaW5pc2hPcGAgc2ltcGx5IHNraXBzIHRoZSBhbW91bnQgb2ZcbiAgICAvLyBjaGFyYWN0ZXJzIGl0IGlzIGdpdmVuIGFzIHNlY29uZCBhcmd1bWVudCwgYW5kIHJldHVybnMgYSB0b2tlblxuICAgIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cblxuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICAgIGNhc2UgMzc6IGNhc2UgNDI6IC8vICclKidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICAgIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSlcblxuICAgIGNhc2UgOTQ6IC8vICdeJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gICAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gICAgY2FzZSAxMjY6IC8vICd+J1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKVxuICAgIH1cblxuICAgIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSArIFwiJ1wiKTtcbiAgfTtcblxuICBwcCQ5LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxuICB9O1xuXG4gIHBwJDkucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICB9XG4gICAgdmFyIHBhdHRlcm4gPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBmbGFncyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5yZWdleHBTdGF0ZSB8fCAodGhpcy5yZWdleHBTdGF0ZSA9IG5ldyBSZWdFeHBWYWxpZGF0aW9uU3RhdGUodGhpcykpO1xuICAgIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgICB0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihzdGF0ZSk7XG5cbiAgICAvLyBDcmVhdGUgTGl0ZXJhbCN2YWx1ZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEVTVHJlZSByZXF1aXJlcyBudWxsIGlmIGl0IGZhaWxlZCB0byBpbnN0YW50aWF0ZSBSZWdFeHAgb2JqZWN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9hMjcwMDNhZGY0ZmQ3YmZhZDQ0ZGU5Y2VmMzcyYTJlYWNkNTI3YjFjL2VzNS5tZCNyZWdleHBsaXRlcmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4gIC8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG4gIHBwJDkucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4pIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcbiAgICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICByZXR1cm4gdG90YWxcbiAgfTtcblxuICBwcCQ5LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgICAgdmFsID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpIDogbnVsbDtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbiAgfTtcblxuICAvLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxuICBwcCQ5LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIHZhciBvY3RhbCA9IHRoaXMucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKCFvY3RhbCAmJiAhc3RhcnRzV2l0aERvdCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgbmV4dCA9PT0gMTEwKSB7XG4gICAgICB2YXIgc3RyJDEgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICB2YXIgdmFsJDEgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHN0ciQxKSA6IG51bGw7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwkMSlcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhb2N0YWwpIHsgLy8gJ2VFJ1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IC8vICcrLSdcbiAgICAgIGlmICh0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICB2YXIgdmFsID0gb2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxuICB9O1xuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBwcCQ5LnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCBjb2RlO1xuXG4gICAgaWYgKGNoID09PSAxMjMpIHsgLy8gJ3snXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zO1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRikgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfTtcblxuICBmdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpIHtcbiAgICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG4gIH1cblxuICBwcCQ5LnJlYWRTdHJpbmcgPSBmdW5jdGlvbihxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpXG4gIH07XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICB2YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxuICBwcCQ5LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbiAgfTtcblxuICBwcCQ5LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICBwcCQ5LnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEyMykgeyAvLyAnYCcsICckeydcbiAgICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIG91dClcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xuICBwcCQ5LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOyB0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoOyB0aGlzLnBvcysrKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiJFwiOlxuICAgICAgICBpZiAodGhpcy5pbnB1dFt0aGlzLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgICAgY2FzZSBcImBcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxuICBwcCQ5LnJlYWRFc2NhcGVkQ2hhciA9IGZ1bmN0aW9uKGluVGVtcGxhdGUpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICAgIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgICBjYXNlIDEyMDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSkgLy8gJ3gnXG4gICAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyQxKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gICAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gICAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgICAgcmV0dXJuIFwiXCJcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgICA/IFwiT2N0YWwgbGl0ZXJhbCBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICAgIH1cbiAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIC8vIFVuaWNvZGUgbmV3IGxpbmUgY2hhcmFjdGVycyBhZnRlciBcXCBnZXQgcmVtb3ZlZCBmcm9tIG91dHB1dCBpbiBib3RoXG4gICAgICAgIC8vIHRlbXBsYXRlIGxpdGVyYWxzIGFuZCBzdHJpbmdzXG4gICAgICAgIHJldHVybiBcIlwiXG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxuICBwcCQ5LnJlYWRIZXhDaGFyID0gZnVuY3Rpb24obGVuKSB7XG4gICAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgICBpZiAobiA9PT0gbnVsbCkgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpOyB9XG4gICAgcmV0dXJuIG5cbiAgfTtcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuY29udGFpbnNFc2NgXG4gIC8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuICAvL1xuICAvLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4gIC8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG4gIHBwJDkucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuICAgIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgICB0aGlzLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgICB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCBhc3RyYWwpKVxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoZXNjKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcylcbiAgfTtcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbiAgLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbiAgcHAkOS5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICB2YXIgdHlwZSA9IHR5cGVzLm5hbWU7XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB3b3JkKTsgfVxuICAgICAgdHlwZSA9IGtleXdvcmRzJDFbd29yZF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG4gIH07XG5cbiAgLy8gQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cblxuICB2YXIgdmVyc2lvbiA9IFwiNi40LjBcIjtcblxuICBQYXJzZXIuYWNvcm4gPSB7XG4gICAgUGFyc2VyOiBQYXJzZXIsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgICBnZXRMaW5lSW5mbzogZ2V0TGluZUluZm8sXG4gICAgTm9kZTogTm9kZSxcbiAgICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgICB0b2tUeXBlczogdHlwZXMsXG4gICAga2V5d29yZFR5cGVzOiBrZXl3b3JkcyQxLFxuICAgIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gICAgdG9rQ29udGV4dHM6IHR5cGVzJDEsXG4gICAgaXNJZGVudGlmaWVyQ2hhcjogaXNJZGVudGlmaWVyQ2hhcixcbiAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgVG9rZW46IFRva2VuLFxuICAgIGlzTmV3TGluZTogaXNOZXdMaW5lLFxuICAgIGxpbmVCcmVhazogbGluZUJyZWFrLFxuICAgIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gICAgbm9uQVNDSUl3aGl0ZXNwYWNlOiBub25BU0NJSXdoaXRlc3BhY2VcbiAgfTtcblxuICAvLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuICAvLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuICAvLyByZXR1cm5zIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIGFzIHNwZWNpZmllZCBieSBbTW96aWxsYSBwYXJzZXJcbiAgLy8gQVBJXVthcGldLlxuICAvL1xuICAvLyBbYXBpXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVxuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4gIC8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbiAgLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpXG4gIH1cblxuICAvLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuICAvLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG4gIGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIudG9rZW5pemVyKGlucHV0LCBvcHRpb25zKVxuICB9XG5cbiAgZXhwb3J0cy5Ob2RlID0gTm9kZTtcbiAgZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG4gIGV4cG9ydHMuUG9zaXRpb24gPSBQb3NpdGlvbjtcbiAgZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xuICBleHBvcnRzLlRva0NvbnRleHQgPSBUb2tDb250ZXh0O1xuICBleHBvcnRzLlRva2VuID0gVG9rZW47XG4gIGV4cG9ydHMuVG9rZW5UeXBlID0gVG9rZW5UeXBlO1xuICBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIGV4cG9ydHMuZ2V0TGluZUluZm8gPSBnZXRMaW5lSW5mbztcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGlzSWRlbnRpZmllclN0YXJ0O1xuICBleHBvcnRzLmlzTmV3TGluZSA9IGlzTmV3TGluZTtcbiAgZXhwb3J0cy5rZXl3b3JkVHlwZXMgPSBrZXl3b3JkcyQxO1xuICBleHBvcnRzLmxpbmVCcmVhayA9IGxpbmVCcmVhaztcbiAgZXhwb3J0cy5saW5lQnJlYWtHID0gbGluZUJyZWFrRztcbiAgZXhwb3J0cy5ub25BU0NJSXdoaXRlc3BhY2UgPSBub25BU0NJSXdoaXRlc3BhY2U7XG4gIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiAgZXhwb3J0cy5wYXJzZUV4cHJlc3Npb25BdCA9IHBhcnNlRXhwcmVzc2lvbkF0O1xuICBleHBvcnRzLnRva0NvbnRleHRzID0gdHlwZXMkMTtcbiAgZXhwb3J0cy50b2tUeXBlcyA9IHR5cGVzO1xuICBleHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tern/node_modules/acorn/dist/acorn.js\n");

/***/ }),

/***/ "./node_modules/tern/node_modules/acorn/dist/acorn.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/tern/node_modules/acorn/dist/acorn.mjs ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLineInfo = getLineInfo;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.isNewLine = isNewLine;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.version = exports.tokTypes = exports.tokContexts = exports.nonASCIIwhitespace = exports.lineBreakG = exports.lineBreak = exports.keywordTypes = exports.defaultOptions = exports.TokenType = exports.Token = exports.TokContext = exports.SourceLocation = exports.Position = exports.Parser = exports.Node = void 0;\n// Reserved word lists for various dialects of the language\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}; // And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar keywordRelationalOperator = /^in(stanceof)?$/; // ## Character categories\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\nvar nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n// eslint-disable-next-line comma-spacing\n\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541]; // eslint-disable-next-line comma-spacing\n\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\n\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n\n    if (pos > code) {\n      return false;\n    }\n\n    pos += set[i + 1];\n\n    if (pos >= code) {\n      return true;\n    }\n  }\n} // Test whether a given character code starts an identifier.\n\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) {\n    return code === 36;\n  }\n\n  if (code < 91) {\n    return true;\n  }\n\n  if (code < 97) {\n    return code === 95;\n  }\n\n  if (code < 123) {\n    return true;\n  }\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  if (astral === false) {\n    return false;\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n} // Test whether a given character is part of an identifier.\n\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) {\n    return code === 36;\n  }\n\n  if (code < 58) {\n    return true;\n  }\n\n  if (code < 65) {\n    return false;\n  }\n\n  if (code < 91) {\n    return true;\n  }\n\n  if (code < 97) {\n    return code === 95;\n  }\n\n  if (code < 123) {\n    return true;\n  }\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  if (astral === false) {\n    return false;\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n} // ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\n\nvar TokenType = function TokenType(label, conf) {\n  if (conf === void 0) conf = {};\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nexports.TokenType = TokenType;\n\nfunction binop(name, prec) {\n  return new TokenType(name, {\n    beforeExpr: true,\n    binop: prec\n  });\n}\n\nvar beforeExpr = {\n  beforeExpr: true\n},\n    startsExpr = {\n  startsExpr: true\n}; // Map keyword names to token types.\n\nvar keywords$1 = {}; // Succinct definitions of keyword token types\n\nexports.keywordTypes = keywords$1;\n\nfunction kw(name, options) {\n  if (options === void 0) options = {};\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options);\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n  eq: new TokenType(\"=\", {\n    beforeExpr: true,\n    isAssign: true\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr: true,\n    isAssign: true\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix: true,\n    postfix: true,\n    startsExpr: true\n  }),\n  prefix: new TokenType(\"!/~\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr: true,\n    binop: 9,\n    prefix: true,\n    startsExpr: true\n  }),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {\n    beforeExpr: true\n  }),\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {\n    isLoop: true,\n    beforeExpr: true\n  }),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {\n    isLoop: true\n  }),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {\n    isLoop: true\n  }),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {\n    beforeExpr: true,\n    binop: 7\n  }),\n  _instanceof: kw(\"instanceof\", {\n    beforeExpr: true,\n    binop: 7\n  }),\n  _typeof: kw(\"typeof\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  _void: kw(\"void\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  _delete: kw(\"delete\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  })\n}; // Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nexports.tokTypes = types;\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nexports.lineBreak = lineBreak;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nexports.lineBreakG = lineBreakG;\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nexports.nonASCIIwhitespace = nonASCIIwhitespace;\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString; // Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName);\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return toString.call(obj) === \"[object Array]\";\n};\n\nfunction wordsRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\");\n} // These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nexports.Position = Position;\n\nPosition.prototype.offset = function offset(n) {\n  return new Position(this.line, this.column + n);\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n\n  if (p.sourceFile !== null) {\n    this.source = p.sourceFile;\n  }\n}; // The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\n\nexports.SourceLocation = SourceLocation;\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n} // A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n  // (2019). This influences support for strict mode, the set of\n  // reserved words, and support for new syntax features. The default\n  // is 9.\n  ecmaVersion: 9,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // the position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n}; // Interpret and default an options object\n\nexports.defaultOptions = defaultOptions;\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions) {\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];\n  }\n\n  if (options.ecmaVersion >= 2015) {\n    options.ecmaVersion -= 2009;\n  }\n\n  if (options.allowReserved == null) {\n    options.allowReserved = options.ecmaVersion < 5;\n  }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n\n    options.onToken = function (token) {\n      return tokens.push(token);\n    };\n  }\n\n  if (isArray(options.onComment)) {\n    options.onComment = pushComment(options, options.onComment);\n  }\n\n  return options;\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n\n    if (options.locations) {\n      comment.loc = new SourceLocation(this, startLoc, endLoc);\n    }\n\n    if (options.ranges) {\n      comment.range = [start, end];\n    }\n\n    array.push(comment);\n  };\n} // Each scope gets a bitset that may contain these flags\n\n\nvar SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);\n} // Used in checkLVal and declareName to determine the type of a binding\n\n\nvar BIND_NONE = 0,\n    // Not a binding\nBIND_VAR = 1,\n    // Var-style binding\nBIND_LEXICAL = 2,\n    // Let- or const-style binding\nBIND_FUNCTION = 3,\n    // Function declaration\nBIND_SIMPLE_CATCH = 4,\n    // Simple (identifier pattern) catch binding\nBIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n\n  if (options.allowReserved !== true) {\n    for (var v = options.ecmaVersion;; v--) {\n      if (reserved = reservedWords[v]) {\n        break;\n      }\n    }\n\n    if (options.sourceType === \"module\") {\n      reserved += \" await\";\n    }\n  }\n\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input); // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  this.containsEsc = false; // Set up token state\n  // The current position of the tokenizer in the input.\n\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  } // Properties of the current token:\n  // Its type\n\n\n  this.type = types.eof; // For tokens that include more information than their type, the value\n\n  this.value = null; // Its start and end offset\n\n  this.start = this.end = this.pos; // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n\n  this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token\n\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n\n  this.context = this.initialContext();\n  this.exprAllowed = true; // Figure out if it's a module code.\n\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function\n\n  this.potentialArrowAt = -1; // Positions to delayed-check that yield/await does not exist in default parameters.\n\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0; // Labels in scope.\n\n  this.labels = []; // Thus-far undefined exports.\n\n  this.undefinedExports = {}; // If enabled, skip leading hashbang line.\n\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n    this.skipLineComment(2);\n  } // Scope tracking for duplicate variable names (see scope.js)\n\n\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP); // For RegExp validation\n\n  this.regexpState = null;\n};\n\nexports.Parser = Parser;\nvar prototypeAccessors = {\n  inFunction: {\n    configurable: true\n  },\n  inGenerator: {\n    configurable: true\n  },\n  inAsync: {\n    configurable: true\n  },\n  allowSuper: {\n    configurable: true\n  },\n  allowDirectSuper: {\n    configurable: true\n  },\n  treatFunctionsAsVar: {\n    configurable: true\n  }\n};\n\nParser.prototype.parse = function parse() {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node);\n};\n\nprototypeAccessors.inFunction.get = function () {\n  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n};\n\nprototypeAccessors.inGenerator.get = function () {\n  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;\n};\n\nprototypeAccessors.inAsync.get = function () {\n  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;\n};\n\nprototypeAccessors.allowSuper.get = function () {\n  return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n};\n\nprototypeAccessors.allowDirectSuper.get = function () {\n  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n};\n\nprototypeAccessors.treatFunctionsAsVar.get = function () {\n  return this.treatFunctionsAsVarInScope(this.currentScope());\n}; // Switch to a getter for 7.0.0.\n\n\nParser.prototype.inNonArrowFunction = function inNonArrowFunction() {\n  return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n};\n\nParser.extend = function extend() {\n  var plugins = [],\n      len = arguments.length;\n\n  while (len--) {\n    plugins[len] = arguments[len];\n  }\n\n  var cls = this;\n\n  for (var i = 0; i < plugins.length; i++) {\n    cls = plugins[i](cls);\n  }\n\n  return cls;\n};\n\nParser.parse = function parse(input, options) {\n  return new this(options, input).parse();\n};\n\nParser.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression();\n};\n\nParser.tokenizer = function tokenizer(input, options) {\n  return new this(options, input);\n};\n\nObject.defineProperties(Parser.prototype, prototypeAccessors);\nvar pp = Parser.prototype; // ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n\npp.strictDirective = function (start) {\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n\n    if (!match) {\n      return false;\n    }\n\n    if ((match[1] || match[2]) === \"use strict\") {\n      return true;\n    }\n\n    start += match[0].length; // Skip semicolon, if any.\n\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n\n    if (this.input[start] === \";\") {\n      start++;\n    }\n  }\n}; // Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\n\npp.eat = function (type) {\n  if (this.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n}; // Tests whether parsed token is a contextual keyword.\n\n\npp.isContextual = function (name) {\n  return this.type === types.name && this.value === name && !this.containsEsc;\n}; // Consumes contextual keyword if possible.\n\n\npp.eatContextual = function (name) {\n  if (!this.isContextual(name)) {\n    return false;\n  }\n\n  this.next();\n  return true;\n}; // Asserts that following token is given contextual keyword.\n\n\npp.expectContextual = function (name) {\n  if (!this.eatContextual(name)) {\n    this.unexpected();\n  }\n}; // Test whether a semicolon can be inserted at the current position.\n\n\npp.canInsertSemicolon = function () {\n  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n\npp.insertSemicolon = function () {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon) {\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n    }\n\n    return true;\n  }\n}; // Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\n\npp.semicolon = function () {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) {\n    this.unexpected();\n  }\n};\n\npp.afterTrailingComma = function (tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma) {\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n    }\n\n    if (!notNext) {\n      this.next();\n    }\n\n    return true;\n  }\n}; // Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\n\npp.expect = function (type) {\n  this.eat(type) || this.unexpected();\n}; // Raise an unexpected token error.\n\n\npp.unexpected = function (pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n}\n\npp.checkPatternErrors = function (refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) {\n    return;\n  }\n\n  if (refDestructuringErrors.trailingComma > -1) {\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n  }\n\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n\n  if (parens > -1) {\n    this.raiseRecoverable(parens, \"Parenthesized pattern\");\n  }\n};\n\npp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) {\n    return false;\n  }\n\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n\n  if (!andThrow) {\n    return shorthandAssign >= 0 || doubleProto >= 0;\n  }\n\n  if (shorthandAssign >= 0) {\n    this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n  }\n\n  if (doubleProto >= 0) {\n    this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n  }\n};\n\npp.checkYieldAwaitInDefaultParams = function () {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n  }\n\n  if (this.awaitPos) {\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n  }\n};\n\npp.isSimpleAssignTarget = function (expr) {\n  if (expr.type === \"ParenthesizedExpression\") {\n    return this.isSimpleAssignTarget(expr.expression);\n  }\n\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\n\nvar pp$1 = Parser.prototype; // ### Statement parsing\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function (node) {\n  var exports = {};\n\n  if (!node.body) {\n    node.body = [];\n  }\n\n  while (this.type !== types.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n\n  if (this.inModule) {\n    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {\n      var name = list[i];\n      this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n    }\n  }\n\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\");\n};\n\nvar loopLabel = {\n  kind: \"loop\"\n},\n    switchLabel = {\n  kind: \"switch\"\n};\n\npp$1.isLet = function (context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n    return false;\n  }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length,\n      nextCh = this.input.charCodeAt(next); // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n\n  if (nextCh === 91) {\n    return true;\n  } // '['\n\n\n  if (context) {\n    return false;\n  }\n\n  if (nextCh === 123) {\n    return true;\n  } // '{'\n\n\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) {\n      ++pos;\n    }\n\n    var ident = this.input.slice(next, pos);\n\n    if (!keywordRelationalOperator.test(ident)) {\n      return true;\n    }\n  }\n\n  return false;\n}; // check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\n\n\npp$1.isAsyncFunction = function () {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n    return false;\n  }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));\n}; // Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\n\npp$1.parseStatement = function (context, topLevel, exports) {\n  var starttype = this.type,\n      node = this.startNode(),\n      kind;\n\n  if (this.isLet(context)) {\n    starttype = types._var;\n    kind = \"let\";\n  } // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n\n  switch (starttype) {\n    case types._break:\n    case types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n\n    case types._debugger:\n      return this.parseDebuggerStatement(node);\n\n    case types._do:\n      return this.parseDoStatement(node);\n\n    case types._for:\n      return this.parseForStatement(node);\n\n    case types._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) {\n        this.unexpected();\n      }\n\n      return this.parseFunctionStatement(node, false, !context);\n\n    case types._class:\n      if (context) {\n        this.unexpected();\n      }\n\n      return this.parseClass(node, true);\n\n    case types._if:\n      return this.parseIfStatement(node);\n\n    case types._return:\n      return this.parseReturnStatement(node);\n\n    case types._switch:\n      return this.parseSwitchStatement(node);\n\n    case types._throw:\n      return this.parseThrowStatement(node);\n\n    case types._try:\n      return this.parseTryStatement(node);\n\n    case types._const:\n    case types._var:\n      kind = kind || this.value;\n\n      if (context && kind !== \"var\") {\n        this.unexpected();\n      }\n\n      return this.parseVarStatement(node, kind);\n\n    case types._while:\n      return this.parseWhileStatement(node);\n\n    case types._with:\n      return this.parseWithStatement(node);\n\n    case types.braceL:\n      return this.parseBlock(true, node);\n\n    case types.semi:\n      return this.parseEmptyStatement(node);\n\n    case types._export:\n    case types._import:\n      if (this.options.ecmaVersion > 10 && starttype === types._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length,\n            nextCh = this.input.charCodeAt(next);\n\n        if (nextCh === 40) // '('\n          {\n            return this.parseExpressionStatement(node, this.parseExpression());\n          }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) {\n          this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n        }\n\n        if (!this.inModule) {\n          this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n        }\n      }\n\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) {\n          this.unexpected();\n        }\n\n        this.next();\n        return this.parseFunctionStatement(node, true, !context);\n      }\n\n      var maybeName = this.value,\n          expr = this.parseExpression();\n\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n        return this.parseLabeledStatement(node, maybeName, expr, context);\n      } else {\n        return this.parseExpressionStatement(node, expr);\n      }\n\n  }\n};\n\npp$1.parseBreakContinueStatement = function (node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n\n  if (this.eat(types.semi) || this.insertSemicolon()) {\n    node.label = null;\n  } else if (this.type !== types.name) {\n    this.unexpected();\n  } else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  } // Verify that there is an actual destination to break or\n  // continue to.\n\n\n  var i = 0;\n\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n        break;\n      }\n\n      if (node.label && isBreak) {\n        break;\n      }\n    }\n  }\n\n  if (i === this.labels.length) {\n    this.raise(node.start, \"Unsyntactic \" + keyword);\n  }\n\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n\npp$1.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\n\npp$1.parseDoStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n\n  if (this.options.ecmaVersion >= 6) {\n    this.eat(types.semi);\n  } else {\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"DoWhileStatement\");\n}; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\n\npp$1.parseForStatement = function (node) {\n  this.next();\n  var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types.parenL);\n\n  if (this.type === types.semi) {\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, null);\n  }\n\n  var isLet = this.isLet();\n\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(),\n        kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n\n    if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n          }\n        } else {\n          node.await = awaitAt > -1;\n        }\n      }\n\n      return this.parseForIn(node, init$1);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init$1);\n  }\n\n  var refDestructuringErrors = new DestructuringErrors();\n  var init = this.parseExpression(true, refDestructuringErrors);\n\n  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) {\n          this.unexpected(awaitAt);\n        }\n      } else {\n        node.await = awaitAt > -1;\n      }\n    }\n\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init);\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n\n  if (awaitAt > -1) {\n    this.unexpected(awaitAt);\n  }\n\n  return this.parseFor(node, init);\n};\n\npp$1.parseFunctionStatement = function (node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);\n};\n\npp$1.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode\n\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\");\n};\n\npp$1.parseReturnStatement = function (node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n    this.raise(this.start, \"'return' outside of function\");\n  }\n\n  this.next(); // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) {\n    node.argument = null;\n  } else {\n    node.argument = this.parseExpression();\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ReturnStatement\");\n};\n\npp$1.parseSwitchStatement = function (node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0); // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this.type === types._case || this.type === types._default) {\n      var isCase = this.type === types._case;\n\n      if (cur) {\n        this.finishNode(cur, \"SwitchCase\");\n      }\n\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) {\n          this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n        }\n\n        sawDefault = true;\n        cur.test = null;\n      }\n\n      this.expect(types.colon);\n    } else {\n      if (!cur) {\n        this.unexpected();\n      }\n\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n\n  this.exitScope();\n\n  if (cur) {\n    this.finishNode(cur, \"SwitchCase\");\n  }\n\n  this.next(); // Closing brace\n\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\n\npp$1.parseThrowStatement = function (node) {\n  this.next();\n\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n  }\n\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n}; // Reused empty array added for node fields that are always empty.\n\n\nvar empty = [];\n\npp$1.parseTryStatement = function (node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      var simple = clause.param.type === \"Identifier\";\n      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) {\n        this.unexpected();\n      }\n\n      clause.param = null;\n      this.enterScope(0);\n    }\n\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n  if (!node.handler && !node.finalizer) {\n    this.raise(node.start, \"Missing catch or finally clause\");\n  }\n\n  return this.finishNode(node, \"TryStatement\");\n};\n\npp$1.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\npp$1.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\n\npp$1.parseWithStatement = function (node) {\n  if (this.strict) {\n    this.raise(this.start, \"'with' in strict mode\");\n  }\n\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\");\n};\n\npp$1.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\n\npp$1.parseLabeledStatement = function (node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {\n    var label = list[i$1];\n\n    if (label.name === maybeName) {\n      this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n  }\n\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else {\n      break;\n    }\n  }\n\n  this.labels.push({\n    name: maybeName,\n    kind: kind,\n    statementStart: this.start\n  });\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\n\npp$1.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n}; // Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\n\npp$1.parseBlock = function (createNewLexicalScope, node) {\n  if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n  if (node === void 0) node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n\n  if (createNewLexicalScope) {\n    this.enterScope(0);\n  }\n\n  while (!this.eat(types.braceR)) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n\n  if (createNewLexicalScope) {\n    this.exitScope();\n  }\n\n  return this.finishNode(node, \"BlockStatement\");\n}; // Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\n\npp$1.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n}; // Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\n\npp$1.parseForIn = function (node, init) {\n  var isForIn = this.type === types._in;\n  this.next();\n\n  if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n    this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n  } else if (init.type === \"AssignmentPattern\") {\n    this.raise(init.start, \"Invalid left-hand side in for-loop\");\n  }\n\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n}; // Parse a list of variable declarations.\n\n\npp$1.parseVar = function (node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind;\n\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n\n    if (!this.eat(types.comma)) {\n      break;\n    }\n  }\n\n  return node;\n};\n\npp$1.parseVarId = function (decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1,\n    FUNC_HANGING_STATEMENT = 2,\n    FUNC_NULLABLE_ID = 4; // Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n\npp$1.parseFunction = function (node, statement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {\n      this.unexpected();\n    }\n\n    node.generator = this.eat(types.star);\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();\n\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      {\n        this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);\n      }\n  }\n\n  var oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT)) {\n    node.id = this.type === types.name ? this.parseIdent() : null;\n  }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false);\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, statement & FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\npp$1.parseFunctionParams = function (node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n}; // Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\n\npp$1.parseClass = function (node, isStatement) {\n  this.next(); // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n\n  var oldStrict = this.strict;\n  this.strict = true;\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    var element = this.parseClassElement(node.superClass !== null);\n\n    if (element) {\n      classBody.body.push(element);\n\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) {\n          this.raise(element.start, \"Duplicate constructor in the same class\");\n        }\n\n        hadConstructor = true;\n      }\n    }\n  }\n\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  this.strict = oldStrict;\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\npp$1.parseClassElement = function (constructorAllowsSuper) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) {\n    return null;\n  }\n\n  var method = this.startNode();\n\n  var tryContextual = function tryContextual(k, noLineBreak) {\n    if (noLineBreak === void 0) noLineBreak = false;\n    var start = this$1.start,\n        startLoc = this$1.startLoc;\n\n    if (!this$1.eatContextual(k)) {\n      return false;\n    }\n\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {\n      return true;\n    }\n\n    if (method.key) {\n      this$1.unexpected();\n    }\n\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false;\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n\n  if (!method.key) {\n    this.parsePropertyName(method);\n  }\n\n  var key = method.key;\n  var allowsDirectSuper = false;\n\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") {\n      this.raise(key.start, \"Constructor can't have get/set modifier\");\n    }\n\n    if (isGenerator) {\n      this.raise(key.start, \"Constructor can't be a generator\");\n    }\n\n    if (isAsync) {\n      this.raise(key.start, \"Constructor can't be an async method\");\n    }\n\n    method.kind = \"constructor\";\n    allowsDirectSuper = constructorAllowsSuper;\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n\n  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n\n  if (method.kind === \"get\" && method.value.params.length !== 0) {\n    this.raiseRecoverable(method.value.start, \"getter should have no params\");\n  }\n\n  if (method.kind === \"set\" && method.value.params.length !== 1) {\n    this.raiseRecoverable(method.value.start, \"setter should have exactly one param\");\n  }\n\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") {\n    this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\");\n  }\n\n  return method;\n};\n\npp$1.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {\n  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n  return this.finishNode(method, \"MethodDefinition\");\n};\n\npp$1.parseClassId = function (node, isStatement) {\n  if (this.type === types.name) {\n    node.id = this.parseIdent();\n\n    if (isStatement) {\n      this.checkLVal(node.id, BIND_LEXICAL, false);\n    }\n  } else {\n    if (isStatement === true) {\n      this.unexpected();\n    }\n\n    node.id = null;\n  }\n};\n\npp$1.parseClassSuper = function (node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n}; // Parses module export declaration.\n\n\npp$1.parseExport = function (node, exports) {\n  this.next(); // export * from '...'\n\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n\n    if (this.type !== types.string) {\n      this.unexpected();\n    }\n\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n\n  if (this.eat(types._default)) {\n    // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  } // export var|const|let|function|class ...\n\n\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(null);\n\n    if (node.declaration.type === \"VariableDeclaration\") {\n      this.checkVariableExport(exports, node.declaration.declarations);\n    } else {\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n    }\n\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) {\n        this.unexpected();\n      }\n\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n        this.checkUnreserved(spec.local); // check if export is defined\n\n        this.checkLocalExport(spec.local);\n      }\n\n      node.source = null;\n    }\n\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\npp$1.checkExport = function (exports, name, pos) {\n  if (!exports) {\n    return;\n  }\n\n  if (has(exports, name)) {\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n  }\n\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function (exports, pat) {\n  var type = pat.type;\n\n  if (type === \"Identifier\") {\n    this.checkExport(exports, pat.name, pat.start);\n  } else if (type === \"ObjectPattern\") {\n    for (var i = 0, list = pat.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      this.checkPatternExport(exports, prop);\n    }\n  } else if (type === \"ArrayPattern\") {\n    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n      if (elt) {\n        this.checkPatternExport(exports, elt);\n      }\n    }\n  } else if (type === \"Property\") {\n    this.checkPatternExport(exports, pat.value);\n  } else if (type === \"AssignmentPattern\") {\n    this.checkPatternExport(exports, pat.left);\n  } else if (type === \"RestElement\") {\n    this.checkPatternExport(exports, pat.argument);\n  } else if (type === \"ParenthesizedExpression\") {\n    this.checkPatternExport(exports, pat.expression);\n  }\n};\n\npp$1.checkVariableExport = function (exports, decls) {\n  if (!exports) {\n    return;\n  }\n\n  for (var i = 0, list = decls; i < list.length; i += 1) {\n    var decl = list[i];\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function () {\n  return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n}; // Parses a comma-separated list of module exports.\n\n\npp$1.parseExportSpecifiers = function (exports) {\n  var nodes = [],\n      first = true; // export { x, y as z } [from '...']\n\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n\n      if (this.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var node = this.startNode();\n    node.local = this.parseIdent(true);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n    this.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n\n  return nodes;\n}; // Parses import declaration.\n\n\npp$1.parseImport = function (node) {\n  this.next(); // import '...'\n\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n}; // Parses a comma-separated list of module imports.\n\n\npp$1.parseImportSpecifiers = function () {\n  var nodes = [],\n      first = true;\n\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n\n    if (!this.eat(types.comma)) {\n      return nodes;\n    }\n  }\n\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes;\n  }\n\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n\n      if (this.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var node$2 = this.startNode();\n    node$2.imported = this.parseIdent(true);\n\n    if (this.eatContextual(\"as\")) {\n      node$2.local = this.parseIdent();\n    } else {\n      this.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n\n    this.checkLVal(node$2.local, BIND_LEXICAL);\n    nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n  }\n\n  return nodes;\n}; // Set `ExpressionStatement#directive` property for directive prologues.\n\n\npp$1.adaptDirectivePrologue = function (statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\n\npp$1.isDirectiveCandidate = function (statement) {\n  return statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && ( // Reject parenthesized strings.\n  this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\");\n};\n\nvar pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\") {\n          this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        if (refDestructuringErrors) {\n          this.checkPatternErrors(refDestructuringErrors, true);\n        }\n\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n          this.toAssignable(prop, isBinding); // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n\n          if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n\n        break;\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") {\n          this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n        }\n\n        this.toAssignable(node.value, isBinding);\n        break;\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n\n        if (refDestructuringErrors) {\n          this.checkPatternErrors(refDestructuringErrors, true);\n        }\n\n        this.toAssignableList(node.elements, isBinding);\n        break;\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n\n        if (node.argument.type === \"AssignmentPattern\") {\n          this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n        }\n\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break;\n\n      case \"MemberExpression\":\n        if (!isBinding) {\n          break;\n        }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n  }\n\n  return node;\n}; // Convert list of expression atoms to binding list.\n\n\npp$2.toAssignableList = function (exprList, isBinding) {\n  var end = exprList.length;\n\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n\n    if (elt) {\n      this.toAssignable(elt, isBinding);\n    }\n  }\n\n  if (end) {\n    var last = exprList[end - 1];\n\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n      this.unexpected(last.argument.start);\n    }\n  }\n\n  return exprList;\n}; // Parses spread element.\n\n\npp$2.parseSpread = function (refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\");\n};\n\npp$2.parseRestBinding = function () {\n  var node = this.startNode();\n  this.next(); // RestElement inside of a function parameter must be an identifier\n\n  if (this.options.ecmaVersion === 6 && this.type !== types.name) {\n    this.unexpected();\n  }\n\n  node.argument = this.parseBindingAtom();\n  return this.finishNode(node, \"RestElement\");\n}; // Parses lvalue (assignable) atom.\n\n\npp$2.parseBindingAtom = function () {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\");\n\n      case types.braceL:\n        return this.parseObj(true);\n    }\n  }\n\n  return this.parseIdent();\n};\n\npp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {\n  var elts = [],\n      first = true;\n\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n    }\n\n    if (allowEmpty && this.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break;\n    } else if (this.type === types.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n\n      this.expect(close);\n      break;\n    } else {\n      var elem = this.parseMaybeDefault(this.start, this.startLoc);\n      this.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n\n  return elts;\n};\n\npp$2.parseBindingListItem = function (param) {\n  return param;\n}; // Parses assignment pattern around given atom if possible.\n\n\npp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {\n    return left;\n  }\n\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n}; // Verify that a node is an lval  something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n\npp$2.checkLVal = function (expr, bindingType, checkClashes) {\n  if (bindingType === void 0) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n    case \"Identifier\":\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\") {\n        this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n      }\n\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n        this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n      }\n\n      if (checkClashes) {\n        if (has(checkClashes, expr.name)) {\n          this.raiseRecoverable(expr.start, \"Argument name clash\");\n        }\n\n        checkClashes[expr.name] = true;\n      }\n\n      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) {\n        this.declareName(expr.name, bindingType, expr.start);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (bindingType) {\n        this.raiseRecoverable(expr.start, \"Binding member expression\");\n      }\n\n      break;\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        this.checkLVal(prop, bindingType, checkClashes);\n      }\n\n      break;\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break;\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n        if (elem) {\n          this.checkLVal(elem, bindingType, checkClashes);\n        }\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break;\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break;\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break;\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n}; // A recursive descent parser operates by defining functions for all\n\n\nvar pp$3 = Parser.prototype; // Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n    return;\n  }\n\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n    return;\n  }\n\n  var key = prop.key;\n  var name;\n\n  switch (key.type) {\n    case \"Identifier\":\n      name = key.name;\n      break;\n\n    case \"Literal\":\n      name = String(key.value);\n      break;\n\n    default:\n      return;\n  }\n\n  var kind = prop.kind;\n\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {\n          refDestructuringErrors.doubleProto = key.start;\n        } // Backwards-compat kludge. Can be removed in version 6.0\n        else {\n            this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n          }\n      }\n\n      propHash.proto = true;\n    }\n\n    return;\n  }\n\n  name = \"$\" + name;\n  var other = propHash[name];\n\n  if (other) {\n    var redefinition;\n\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n\n    if (redefinition) {\n      this.raiseRecoverable(key.start, \"Redefinition of property\");\n    }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n\n  other[kind] = true;\n}; // ### Expression parsing\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\n\npp$3.parseExpression = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n\n    while (this.eat(types.comma)) {\n      node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));\n    }\n\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n\n  return expr;\n}; // Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\n\npp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) {\n      return this.parseYield(noIn);\n    } // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else {\n        this.exprAllowed = false;\n      }\n  }\n\n  var ownDestructuringErrors = false,\n      oldParenAssign = -1,\n      oldTrailingComma = -1,\n      oldShorthandAssign = -1;\n\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors();\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start,\n      startLoc = this.startLoc;\n\n  if (this.type === types.parenL || this.type === types.name) {\n    this.potentialArrowAt = this.start;\n  }\n\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n\n  if (afterLeftParse) {\n    left = afterLeftParse.call(this, left, startPos, startLoc);\n  }\n\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n\n    if (!ownDestructuringErrors) {\n      DestructuringErrors.call(refDestructuringErrors);\n    }\n\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else {\n    if (ownDestructuringErrors) {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n  }\n\n  if (oldParenAssign > -1) {\n    refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n  }\n\n  if (oldTrailingComma > -1) {\n    refDestructuringErrors.trailingComma = oldTrailingComma;\n  }\n\n  if (oldShorthandAssign > -1) {\n    refDestructuringErrors.shorthandAssign = oldShorthandAssign;\n  }\n\n  return left;\n}; // Parse a ternary conditional (`?:`) operator.\n\n\npp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n\n  if (this.checkExpressionErrors(refDestructuringErrors)) {\n    return expr;\n  }\n\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  return expr;\n}; // Start the precedence parser.\n\n\npp$3.parseExprOps = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n\n  if (this.checkExpressionErrors(refDestructuringErrors)) {\n    return expr;\n  }\n\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n}; // Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\n\npp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start,\n          startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n\n  return left;\n};\n\npp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n}; // Parse unary operators, both prefix and postfix.\n\n\npp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {\n  var startPos = this.start,\n      startLoc = this.startLoc,\n      expr;\n\n  if (this.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(),\n        update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n\n    if (update) {\n      this.checkLVal(node.argument);\n    } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n    } else {\n      sawUnary = true;\n    }\n\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n      return expr;\n    }\n\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLVal(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar)) {\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false);\n  } else {\n    return expr;\n  }\n}; // Parse call, dot, and `[]`-subscript expressions.\n\n\npp$3.parseExprSubscripts = function (refDestructuringErrors) {\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {\n    return expr;\n  }\n\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n      refDestructuringErrors.parenthesizedAssign = -1;\n    }\n\n    if (refDestructuringErrors.parenthesizedBind >= result.start) {\n      refDestructuringErrors.parenthesizedBind = -1;\n    }\n  }\n\n  return result;\n};\n\npp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      return element;\n    }\n\n    base = element;\n  }\n};\n\npp$3.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n  var computed = this.eat(types.bracketL);\n\n  if (computed || this.eat(types.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n    node.computed = !!computed;\n\n    if (computed) {\n      this.expect(types.bracketR);\n    }\n\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors(),\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== \"Import\", false, refDestructuringErrors);\n\n    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n\n      if (this.awaitIdentPos > 0) {\n        this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n      }\n\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);\n    }\n\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n\n    if (node$1.callee.type === \"Import\") {\n      if (node$1.arguments.length !== 1) {\n        this.raise(node$1.start, \"import() requires exactly one argument\");\n      }\n\n      var importArg = node$1.arguments[0];\n\n      if (importArg && importArg.type === \"SpreadElement\") {\n        this.raise(importArg.start, \"... is not allowed in import()\");\n      }\n    }\n\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types.backQuote) {\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({\n      isTagged: true\n    });\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n\n  return base;\n}; // Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\n\npp$3.parseExprAtom = function (refDestructuringErrors) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types.slash) {\n    this.readRegexp();\n  }\n\n  var node,\n      canBeArrow = this.potentialArrowAt === this.start;\n\n  switch (this.type) {\n    case types._super:\n      if (!this.allowSuper) {\n        this.raise(this.start, \"'super' keyword outside a method\");\n      }\n\n      node = this.startNode();\n      this.next();\n\n      if (this.type === types.parenL && !this.allowDirectSuper) {\n        this.raise(node.start, \"super() call outside constructor of a subclass\");\n      } // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super Arguments\n\n\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {\n        this.unexpected();\n      }\n\n      return this.finishNode(node, \"Super\");\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\");\n\n    case types.name:\n      var startPos = this.start,\n          startLoc = this.startLoc,\n          containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function)) {\n        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);\n      }\n\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow)) {\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);\n        }\n\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent(false);\n\n          if (this.canInsertSemicolon() || !this.eat(types.arrow)) {\n            this.unexpected();\n          }\n\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);\n        }\n      }\n\n      return id;\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {\n        pattern: value.pattern,\n        flags: value.flags\n      };\n      return node;\n\n    case types.num:\n    case types.string:\n      return this.parseLiteral(this.value);\n\n    case types._null:\n    case types._true:\n    case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n\n    case types.parenL:\n      var start = this.start,\n          expr = this.parseParenAndDistinguishExpression(canBeArrow);\n\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n          refDestructuringErrors.parenthesizedAssign = start;\n        }\n\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = start;\n        }\n      }\n\n      return expr;\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors);\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0);\n\n    case types._class:\n      return this.parseClass(this.startNode(), false);\n\n    case types._new:\n      return this.parseNew();\n\n    case types.backQuote:\n      return this.parseTemplate();\n\n    case types._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport();\n      } else {\n        return this.unexpected();\n      }\n\n    default:\n      this.unexpected();\n  }\n};\n\npp$3.parseDynamicImport = function () {\n  var node = this.startNode();\n  this.next();\n\n  if (this.type !== types.parenL) {\n    this.unexpected();\n  }\n\n  return this.finishNode(node, \"Import\");\n};\n\npp$3.parseLiteral = function (value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {\n    node.bigint = node.raw.slice(0, -1);\n  }\n\n  this.next();\n  return this.finishNode(node, \"Literal\");\n};\n\npp$3.parseParenExpression = function () {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val;\n};\n\npp$3.parseParenAndDistinguishExpression = function (canBeArrow) {\n  var startPos = this.start,\n      startLoc = this.startLoc,\n      val,\n      allowTrailingComma = this.options.ecmaVersion >= 8;\n\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n    var innerStartPos = this.start,\n        innerStartLoc = this.startLoc;\n    var exprList = [],\n        first = true,\n        lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors(),\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0; // Do not save awaitIdentPos to allow checking awaits nested in parameters\n\n    while (this.type !== types.parenR) {\n      first ? first = false : this.expect(types.comma);\n\n      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break;\n      } else if (this.type === types.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n\n    var innerEndPos = this.start,\n        innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList);\n    }\n\n    if (!exprList.length || lastIsComma) {\n      this.unexpected(this.lastTokStart);\n    }\n\n    if (spreadStart) {\n      this.unexpected(spreadStart);\n    }\n\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\");\n  } else {\n    return val;\n  }\n};\n\npp$3.parseParenItem = function (item) {\n  return item;\n};\n\npp$3.parseParenArrowList = function (startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n}; // New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\n\nvar empty$1 = [];\n\npp$3.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n\n    if (node.property.name !== \"target\" || containsEsc) {\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\");\n    }\n\n    if (!this.inNonArrowFunction()) {\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\");\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  var startPos = this.start,\n      startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n\n  if (this.options.ecmaVersion > 10 && node.callee.type === \"Import\") {\n    this.raise(node.callee.start, \"Cannot use new with import(...)\");\n  }\n\n  if (this.eat(types.parenL)) {\n    node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== \"Import\", false);\n  } else {\n    node.arguments = empty$1;\n  }\n\n  return this.finishNode(node, \"NewExpression\");\n}; // Parse template expression.\n\n\npp$3.parseTemplateElement = function (ref) {\n  var isTagged = ref.isTagged;\n  var elem = this.startNode();\n\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\npp$3.parseTemplate = function (ref) {\n  if (ref === void 0) ref = {};\n  var isTagged = ref.isTagged;\n  if (isTagged === void 0) isTagged = false;\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({\n    isTagged: isTagged\n  });\n  node.quasis = [curElt];\n\n  while (!curElt.tail) {\n    if (this.type === types.eof) {\n      this.raise(this.pos, \"Unterminated template literal\");\n    }\n\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({\n      isTagged: isTagged\n    }));\n  }\n\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\npp$3.isAsyncProp = function (prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n}; // Parse an object literal or binding pattern.\n\n\npp$3.parseObj = function (isPattern, refDestructuringErrors) {\n  var node = this.startNode(),\n      first = true,\n      propHash = {};\n  node.properties = [];\n  this.next();\n\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this.expect(types.comma);\n\n      if (this.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n\n    if (!isPattern) {\n      this.checkPropClash(prop, propHash, refDestructuringErrors);\n    }\n\n    node.properties.push(prop);\n  }\n\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n\npp$3.parseProperty = function (isPattern, refDestructuringErrors) {\n  var prop = this.startNode(),\n      isGenerator,\n      isAsync,\n      startPos,\n      startLoc;\n\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n\n      return this.finishNode(prop, \"RestElement\");\n    } // To disallow parenthesized identifier via `this.toAssignable()`.\n\n\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    } // Parse argument.\n\n\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors); // To disallow trailing comma via `this.toAssignable()`.\n\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    } // Finish\n\n\n    return this.finishNode(prop, \"SpreadElement\");\n  }\n\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n  }\n\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\");\n};\n\npp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon) {\n    this.unexpected();\n  }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) {\n      this.unexpected();\n    }\n\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types.comma && this.type !== types.braceR) {\n    if (isGenerator || isAsync) {\n      this.unexpected();\n    }\n\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n\n      if (prop.kind === \"get\") {\n        this.raiseRecoverable(start, \"getter should have no params\");\n      } else {\n        this.raiseRecoverable(start, \"setter should have exactly one param\");\n      }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n      }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) {\n      this.unexpected();\n    }\n\n    this.checkUnreserved(prop.key);\n\n    if (prop.key.name === \"await\" && !this.awaitIdentPos) {\n      this.awaitIdentPos = startPos;\n    }\n\n    prop.kind = \"init\";\n\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0) {\n        refDestructuringErrors.shorthandAssign = this.start;\n      }\n\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n\n    prop.shorthand = true;\n  } else {\n    this.unexpected();\n  }\n};\n\npp$3.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key;\n    } else {\n      prop.computed = false;\n    }\n  }\n\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n}; // Initialize empty function node.\n\n\npp$3.initFunction = function (node) {\n  node.id = null;\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = node.expression = false;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = false;\n  }\n}; // Parse object or class method.\n\n\npp$3.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(),\n      oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      oldAwaitIdentPos = this.awaitIdentPos;\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator;\n  }\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true);\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\");\n}; // Parse arrow function expression with given parameters.\n\n\npp$3.parseArrowExpression = function (node, params, isAsync) {\n  var oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      oldAwaitIdentPos = this.awaitIdentPos;\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false);\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n}; // Parse function body and check parameters.\n\n\npp$3.parseFunctionBody = function (node, isArrowFunction, isMethod) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict,\n      useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n\n      if (useStrict && nonSimple) {\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      }\n    } // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n\n\n    var oldLabels = this.labels;\n    this.labels = [];\n\n    if (useStrict) {\n      this.strict = true;\n    } // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n\n\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n\n  this.exitScope(); // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n\n  if (this.strict && node.id) {\n    this.checkLVal(node.id, BIND_OUTSIDE);\n  }\n\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function (params) {\n  for (var i = 0, list = params; i < list.length; i += 1) {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") {\n      return false;\n    }\n  }\n\n  return true;\n}; // Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\n\npp$3.checkParams = function (node, allowDuplicates) {\n  var nameHash = {};\n\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n}; // Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\n\npp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [],\n      first = true;\n\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types.comma);\n\n      if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n\n    var elt = void 0;\n\n    if (allowEmpty && this.type === types.comma) {\n      elt = null;\n    } else if (this.type === types.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n\n      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n\n    elts.push(elt);\n  }\n\n  return elts;\n};\n\npp$3.checkUnreserved = function (ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\") {\n    this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n  }\n\n  if (this.inAsync && name === \"await\") {\n    this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n  }\n\n  if (this.keywords.test(name)) {\n    this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n  }\n\n  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n    return;\n  }\n\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\") {\n      this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n    }\n\n    this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n  }\n}; // Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\n\npp$3.parseIdent = function (liberal, isBinding) {\n  var node = this.startNode();\n\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword; // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n\n    if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n\n  this.next();\n  this.finishNode(node, \"Identifier\");\n\n  if (!liberal) {\n    this.checkUnreserved(node);\n\n    if (node.name === \"await\" && !this.awaitIdentPos) {\n      this.awaitIdentPos = node.start;\n    }\n  }\n\n  return node;\n}; // Parses yield expression inside generator.\n\n\npp$3.parseYield = function (noIn) {\n  if (!this.yieldPos) {\n    this.yieldPos = this.start;\n  }\n\n  var node = this.startNode();\n  this.next();\n\n  if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign(noIn);\n  }\n\n  return this.finishNode(node, \"YieldExpression\");\n};\n\npp$3.parseAwait = function () {\n  if (!this.awaitPos) {\n    this.awaitPos = this.start;\n  }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\");\n};\n\nvar pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function (pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;\n  err.loc = loc;\n  err.raisedAt = this.pos;\n  throw err;\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function () {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags; // A list of var-declared names in the current lexical scope\n\n  this.var = []; // A list of lexically-declared names in the current lexical scope\n\n  this.lexical = []; // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n\n  this.functions = [];\n}; // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n\npp$5.enterScope = function (flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$5.exitScope = function () {\n  this.scopeStack.pop();\n}; // The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\n\n\npp$5.treatFunctionsAsVarInScope = function (scope) {\n  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;\n};\n\npp$5.declareName = function (name, bindingType, pos) {\n  var redeclared = false;\n\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n\n    if (this.inModule && scope.flags & SCOPE_TOP) {\n      delete this.undefinedExports[name];\n    }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n\n    if (this.treatFunctionsAsVar) {\n      redeclared = scope$2.lexical.indexOf(name) > -1;\n    } else {\n      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n    }\n\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n\n      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break;\n      }\n\n      scope$3.var.push(name);\n\n      if (this.inModule && scope$3.flags & SCOPE_TOP) {\n        delete this.undefinedExports[name];\n      }\n\n      if (scope$3.flags & SCOPE_VAR) {\n        break;\n      }\n    }\n  }\n\n  if (redeclared) {\n    this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n  }\n};\n\npp$5.checkLocalExport = function (id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$5.currentScope = function () {\n  return this.scopeStack[this.scopeStack.length - 1];\n};\n\npp$5.currentVarScope = function () {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n\n    if (scope.flags & SCOPE_VAR) {\n      return scope;\n    }\n  }\n}; // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n\n\npp$5.currentThisScope = function () {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {\n      return scope;\n    }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n\n  if (parser.options.locations) {\n    this.loc = new SourceLocation(parser, loc);\n  }\n\n  if (parser.options.directSourceFile) {\n    this.sourceFile = parser.options.directSourceFile;\n  }\n\n  if (parser.options.ranges) {\n    this.range = [pos, 0];\n  }\n}; // Start an AST node, attaching a start offset.\n\n\nexports.Node = Node;\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function () {\n  return new Node(this, this.start, this.startLoc);\n};\n\npp$6.startNodeAt = function (pos, loc) {\n  return new Node(this, pos, loc);\n}; // Finish an AST node, adding `type` and `end` properties.\n\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n\n  if (this.options.locations) {\n    node.loc.end = loc;\n  }\n\n  if (this.options.ranges) {\n    node.range[1] = pos;\n  }\n\n  return node;\n}\n\npp$6.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n}; // Finish node at given position\n\n\npp$6.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n}; // The algorithm used to determine whether a regexp can appear at a\n\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nexports.TokContext = TokContext;\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) {\n    return p.tryReadTemplateToken();\n  }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\nexports.tokContexts = types$1;\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function () {\n  return [types$1.b_stat];\n};\n\npp$7.braceIsBlock = function (prevType) {\n  var parent = this.curContext();\n\n  if (parent === types$1.f_expr || parent === types$1.f_stat) {\n    return true;\n  }\n\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {\n    return !parent.isExpr;\n  } // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n\n\n  if (prevType === types._return || prevType === types.name && this.exprAllowed) {\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  }\n\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n    return true;\n  }\n\n  if (prevType === types.braceL) {\n    return parent === types$1.b_stat;\n  }\n\n  if (prevType === types._var || prevType === types._const || prevType === types.name) {\n    return false;\n  }\n\n  return !this.exprAllowed;\n};\n\npp$7.inGeneratorContext = function () {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n\n    if (context.token === \"function\") {\n      return context.generator;\n    }\n  }\n\n  return false;\n};\n\npp$7.updateContext = function (prevType) {\n  var update,\n      type = this.type;\n\n  if (type.keyword && prevType === types.dot) {\n    this.exprAllowed = false;\n  } else if (update = type.updateContext) {\n    update.call(this, prevType);\n  } else {\n    this.exprAllowed = type.beforeExpr;\n  }\n}; // Token-specific context update code\n\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return;\n  }\n\n  var out = this.context.pop();\n\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {// tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.context.push(types$1.f_expr);\n  } else {\n    this.context.push(types$1.f_stat);\n  }\n\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.q_tmpl) {\n    this.context.pop();\n  } else {\n    this.context.push(types$1.q_tmpl);\n  }\n\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function (prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n\n    if (this.context[index] === types$1.f_expr) {\n      this.context[index] = types$1.f_expr_gen;\n    } else {\n      this.context[index] = types$1.f_gen;\n    }\n  }\n\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function (prevType) {\n  var allowed = false;\n\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n      allowed = true;\n    }\n  }\n\n  this.exprAllowed = allowed;\n}; // This file contains Unicode properties extracted from the ECMAScript\n// specification. The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n// #table-binary-unicode-properties\n\n\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties\n}; // #table-unicode-general-category-values\n\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\"; // #table-unicode-script-values\n\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues\n};\nvar data = {};\n\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\n\nbuildUnicodeData(9);\nbuildUnicodeData(10);\nbuildUnicodeData(11);\nvar pp$8 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise(message) {\n  this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n}; // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n\n\nRegExpValidationState.prototype.at = function at(i) {\n  var s = this.source;\n  var l = s.length;\n\n  if (i >= l) {\n    return -1;\n  }\n\n  var c = s.charCodeAt(i);\n\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c;\n  }\n\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex(i) {\n  var s = this.source;\n  var l = s.length;\n\n  if (i >= l) {\n    return l;\n  }\n\n  var c = s.charCodeAt(i),\n      next;\n\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1;\n  }\n\n  return i + 2;\n};\n\nRegExpValidationState.prototype.current = function current() {\n  return this.at(this.pos);\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead() {\n  return this.at(this.nextIndex(this.pos));\n};\n\nRegExpValidationState.prototype.advance = function advance() {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat(ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true;\n  }\n\n  return false;\n};\n\nfunction codePointToString(ch) {\n  if (ch <= 0xFFFF) {\n    return String.fromCharCode(ch);\n  }\n\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);\n}\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\n\n\npp$8.validateRegExpFlags = function (state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\n\n\npp$8.validateRegExpPattern = function (state) {\n  this.regexp_pattern(state); // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n\n\npp$8.regexp_pattern = function (state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29\n    /* ) */\n    )) {\n      state.raise(\"Unmatched ')'\");\n    }\n\n    if (state.eat(0x5D\n    /* [ */\n    ) || state.eat(0x7D\n    /* } */\n    )) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n\n\npp$8.regexp_disjunction = function (state) {\n  this.regexp_alternative(state);\n\n  while (state.eat(0x7C\n  /* | */\n  )) {\n    this.regexp_alternative(state);\n  } // Make the same message as V8.\n\n\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n\n  if (state.eat(0x7B\n  /* { */\n  )) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n\n\npp$8.regexp_alternative = function (state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n\n\npp$8.regexp_eatTerm = function (state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n\n    return true;\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n\n\npp$8.regexp_eatAssertion = function (state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false; // ^, $\n\n  if (state.eat(0x5E\n  /* ^ */\n  ) || state.eat(0x24\n  /* $ */\n  )) {\n    return true;\n  } // \\b \\B\n\n\n  if (state.eat(0x5C\n  /* \\ */\n  )) {\n    if (state.eat(0x42\n    /* B */\n    ) || state.eat(0x62\n    /* b */\n    )) {\n      return true;\n    }\n\n    state.pos = start;\n  } // Lookahead / Lookbehind\n\n\n  if (state.eat(0x28\n  /* ( */\n  ) && state.eat(0x3F\n  /* ? */\n  )) {\n    var lookbehind = false;\n\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C\n      /* < */\n      );\n    }\n\n    if (state.eat(0x3D\n    /* = */\n    ) || state.eat(0x21\n    /* ! */\n    )) {\n      this.regexp_disjunction(state);\n\n      if (!state.eat(0x29\n      /* ) */\n      )) {\n        state.raise(\"Unterminated group\");\n      }\n\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true;\n    }\n  }\n\n  state.pos = start;\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n\n\npp$8.regexp_eatQuantifier = function (state, noError) {\n  if (noError === void 0) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F\n    /* ? */\n    );\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n\n\npp$8.regexp_eatQuantifierPrefix = function (state, noError) {\n  return state.eat(0x2A\n  /* * */\n  ) || state.eat(0x2B\n  /* + */\n  ) || state.eat(0x3F\n  /* ? */\n  ) || this.regexp_eatBracedQuantifier(state, noError);\n};\n\npp$8.regexp_eatBracedQuantifier = function (state, noError) {\n  var start = state.pos;\n\n  if (state.eat(0x7B\n  /* { */\n  )) {\n    var min = 0,\n        max = -1;\n\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n\n      if (state.eat(0x2C\n      /* , */\n      ) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n\n      if (state.eat(0x7D\n      /* } */\n      )) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n\n        return true;\n      }\n    }\n\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n\n\npp$8.regexp_eatAtom = function (state) {\n  return this.regexp_eatPatternCharacters(state) || state.eat(0x2E\n  /* . */\n  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\n\npp$8.regexp_eatReverseSolidusAtomEscape = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C\n  /* \\ */\n  )) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$8.regexp_eatUncapturingGroup = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x28\n  /* ( */\n  )) {\n    if (state.eat(0x3F\n    /* ? */\n    ) && state.eat(0x3A\n    /* : */\n    )) {\n      this.regexp_disjunction(state);\n\n      if (state.eat(0x29\n      /* ) */\n      )) {\n        return true;\n      }\n\n      state.raise(\"Unterminated group\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$8.regexp_eatCapturingGroup = function (state) {\n  if (state.eat(0x28\n  /* ( */\n  )) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F\n    /* ? */\n    ) {\n        state.raise(\"Invalid group\");\n      }\n\n    this.regexp_disjunction(state);\n\n    if (state.eat(0x29\n    /* ) */\n    )) {\n      state.numCapturingParens += 1;\n      return true;\n    }\n\n    state.raise(\"Unterminated group\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n\n\npp$8.regexp_eatExtendedAtom = function (state) {\n  return state.eat(0x2E\n  /* . */\n  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n\n\npp$8.regexp_eatInvalidBracedQuantifier = function (state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n\n\npp$8.regexp_eatSyntaxCharacter = function (state) {\n  var ch = state.current();\n\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n\n  return false;\n};\n\nfunction isSyntaxCharacter(ch) {\n  return ch === 0x24\n  /* $ */\n  || ch >= 0x28\n  /* ( */\n  && ch <= 0x2B\n  /* + */\n  || ch === 0x2E\n  /* . */\n  || ch === 0x3F\n  /* ? */\n  || ch >= 0x5B\n  /* [ */\n  && ch <= 0x5E\n  /* ^ */\n  || ch >= 0x7B\n  /* { */\n  && ch <= 0x7D\n  /* } */\n  ;\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\n\n\npp$8.regexp_eatPatternCharacters = function (state) {\n  var start = state.pos;\n  var ch = 0;\n\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n\n  return state.pos !== start;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n\n\npp$8.regexp_eatExtendedPatternCharacter = function (state) {\n  var ch = state.current();\n\n  if (ch !== -1 && ch !== 0x24\n  /* $ */\n  && !(ch >= 0x28\n  /* ( */\n  && ch <= 0x2B\n  /* + */\n  ) && ch !== 0x2E\n  /* . */\n  && ch !== 0x3F\n  /* ? */\n  && ch !== 0x5B\n  /* [ */\n  && ch !== 0x5E\n  /* ^ */\n  && ch !== 0x7C\n  /* | */\n  ) {\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\n\n\npp$8.regexp_groupSpecifier = function (state) {\n  if (state.eat(0x3F\n  /* ? */\n  )) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n\n      state.groupNames.push(state.lastStringValue);\n      return;\n    }\n\n    state.raise(\"Invalid group\");\n  }\n}; // GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\n\n\npp$8.regexp_eatGroupName = function (state) {\n  state.lastStringValue = \"\";\n\n  if (state.eat(0x3C\n  /* < */\n  )) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E\n    /* > */\n    )) {\n      return true;\n    }\n\n    state.raise(\"Invalid capture group name\");\n  }\n\n  return false;\n}; // RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\n\n\npp$8.regexp_eatRegExpIdentifierName = function (state) {\n  state.lastStringValue = \"\";\n\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n\n    return true;\n  }\n\n  return false;\n}; // RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n\n\npp$8.regexp_eatRegExpIdentifierStart = function (state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C\n  /* \\ */\n  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true;\n  }\n\n  state.pos = start;\n  return false;\n};\n\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24\n  /* $ */\n  || ch === 0x5F;\n  /* _ */\n} // RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\n\n\npp$8.regexp_eatRegExpIdentifierPart = function (state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C\n  /* \\ */\n  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true;\n  }\n\n  state.pos = start;\n  return false;\n};\n\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24\n  /* $ */\n  || ch === 0x5F\n  /* _ */\n  || ch === 0x200C\n  /* <ZWNJ> */\n  || ch === 0x200D;\n  /* <ZWJ> */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n\n\npp$8.regexp_eatAtomEscape = function (state) {\n  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n    return true;\n  }\n\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63\n    /* c */\n    ) {\n        state.raise(\"Invalid unicode escape\");\n      }\n\n    state.raise(\"Invalid escape\");\n  }\n\n  return false;\n};\n\npp$8.regexp_eatBackReference = function (state) {\n  var start = state.pos;\n\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n\n      return true;\n    }\n\n    if (n <= state.numCapturingParens) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$8.regexp_eatKGroupName = function (state) {\n  if (state.eat(0x6B\n  /* k */\n  )) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true;\n    }\n\n    state.raise(\"Invalid named reference\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n\n\npp$8.regexp_eatCharacterEscape = function (state) {\n  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\n\npp$8.regexp_eatCControlLetter = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x63\n  /* c */\n  )) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\npp$8.regexp_eatZero = function (state) {\n  if (state.current() === 0x30\n  /* 0 */\n  && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n\n\npp$8.regexp_eatControlEscape = function (state) {\n  var ch = state.current();\n\n  if (ch === 0x74\n  /* t */\n  ) {\n      state.lastIntValue = 0x09;\n      /* \\t */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x6E\n  /* n */\n  ) {\n      state.lastIntValue = 0x0A;\n      /* \\n */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x76\n  /* v */\n  ) {\n      state.lastIntValue = 0x0B;\n      /* \\v */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x66\n  /* f */\n  ) {\n      state.lastIntValue = 0x0C;\n      /* \\f */\n\n      state.advance();\n      return true;\n    }\n\n  if (ch === 0x72\n  /* r */\n  ) {\n      state.lastIntValue = 0x0D;\n      /* \\r */\n\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n\n\npp$8.regexp_eatControlLetter = function (state) {\n  var ch = state.current();\n\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true;\n  }\n\n  return false;\n};\n\nfunction isControlLetter(ch) {\n  return ch >= 0x41\n  /* A */\n  && ch <= 0x5A\n  /* Z */\n  || ch >= 0x61\n  /* a */\n  && ch <= 0x7A\n  /* z */\n  ;\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n\n\npp$8.regexp_eatRegExpUnicodeEscapeSequence = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x75\n  /* u */\n  )) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n\n        if (state.eat(0x5C\n        /* \\ */\n        ) && state.eat(0x75\n        /* u */\n        ) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true;\n          }\n        }\n\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n\n      return true;\n    }\n\n    if (state.switchU && state.eat(0x7B\n    /* { */\n    ) && this.regexp_eatHexDigits(state) && state.eat(0x7D\n    /* } */\n    ) && isValidUnicode(state.lastIntValue)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n};\n\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF;\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n\n\npp$8.regexp_eatIdentityEscape = function (state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true;\n    }\n\n    if (state.eat(0x2F\n    /* / */\n    )) {\n      state.lastIntValue = 0x2F;\n      /* / */\n\n      return true;\n    }\n\n    return false;\n  }\n\n  var ch = state.current();\n\n  if (ch !== 0x63\n  /* c */\n  && (!state.switchN || ch !== 0x6B\n  /* k */\n  )) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n\n\npp$8.regexp_eatDecimalEscape = function (state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n\n  if (ch >= 0x31\n  /* 1 */\n  && ch <= 0x39\n  /* 9 */\n  ) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30\n        /* 0 */\n        );\n        state.advance();\n      } while ((ch = state.current()) >= 0x30\n      /* 0 */\n      && ch <= 0x39\n      /* 9 */\n      );\n\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n\n\npp$8.regexp_eatCharacterClassEscape = function (state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true;\n  }\n\n  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50\n  /* P */\n  || ch === 0x70\n  /* p */\n  )) {\n    state.lastIntValue = -1;\n    state.advance();\n\n    if (state.eat(0x7B\n    /* { */\n    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D\n    /* } */\n    )) {\n      return true;\n    }\n\n    state.raise(\"Invalid property name\");\n  }\n\n  return false;\n};\n\nfunction isCharacterClassEscape(ch) {\n  return ch === 0x64\n  /* d */\n  || ch === 0x44\n  /* D */\n  || ch === 0x73\n  /* s */\n  || ch === 0x53\n  /* S */\n  || ch === 0x77\n  /* w */\n  || ch === 0x57\n  /* W */\n  ;\n} // UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\n\n\npp$8.regexp_eatUnicodePropertyValueExpression = function (state) {\n  var start = state.pos; // UnicodePropertyName `=` UnicodePropertyValue\n\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D\n  /* = */\n  )) {\n    var name = state.lastStringValue;\n\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true;\n    }\n  }\n\n  state.pos = start; // LoneUnicodePropertyNameOrValue\n\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true;\n  }\n\n  return false;\n};\n\npp$8.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {\n  if (!has(state.unicodeProperties.nonBinary, name)) {\n    state.raise(\"Invalid property name\");\n  }\n\n  if (!state.unicodeProperties.nonBinary[name].test(value)) {\n    state.raise(\"Invalid property value\");\n  }\n};\n\npp$8.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {\n  if (!state.unicodeProperties.binary.test(nameOrValue)) {\n    state.raise(\"Invalid property name\");\n  }\n}; // UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\n\n\npp$8.regexp_eatUnicodePropertyName = function (state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n\n  return state.lastStringValue !== \"\";\n};\n\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F;\n  /* _ */\n} // UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\n\n\npp$8.regexp_eatUnicodePropertyValue = function (state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n\n  return state.lastStringValue !== \"\";\n};\n\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n} // LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\n\n\npp$8.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {\n  return this.regexp_eatUnicodePropertyValue(state);\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n\n\npp$8.regexp_eatCharacterClass = function (state) {\n  if (state.eat(0x5B\n  /* [ */\n  )) {\n    state.eat(0x5E\n    /* ^ */\n    );\n    this.regexp_classRanges(state);\n\n    if (state.eat(0x5D\n    /* [ */\n    )) {\n      return true;\n    } // Unreachable since it threw \"unterminated regular expression\" error before.\n\n\n    state.raise(\"Unterminated character class\");\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n\n\npp$8.regexp_classRanges = function (state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n\n    if (state.eat(0x2D\n    /* - */\n    ) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n\n\npp$8.regexp_eatClassAtom = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C\n  /* \\ */\n  )) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n\n      if (ch$1 === 0x63\n      /* c */\n      || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n\n      state.raise(\"Invalid escape\");\n    }\n\n    state.pos = start;\n  }\n\n  var ch = state.current();\n\n  if (ch !== 0x5D\n  /* [ */\n  ) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n\n\npp$8.regexp_eatClassEscape = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x62\n  /* b */\n  )) {\n    state.lastIntValue = 0x08;\n    /* <BS> */\n\n    return true;\n  }\n\n  if (state.switchU && state.eat(0x2D\n  /* - */\n  )) {\n    state.lastIntValue = 0x2D;\n    /* - */\n\n    return true;\n  }\n\n  if (!state.switchU && state.eat(0x63\n  /* c */\n  )) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true;\n    }\n\n    state.pos = start;\n  }\n\n  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n\n\npp$8.regexp_eatClassControlLetter = function (state) {\n  var ch = state.current();\n\n  if (isDecimalDigit(ch) || ch === 0x5F\n  /* _ */\n  ) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true;\n    }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\n\npp$8.regexp_eatHexEscapeSequence = function (state) {\n  var start = state.pos;\n\n  if (state.eat(0x78\n  /* x */\n  )) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true;\n    }\n\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n\n    state.pos = start;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n\n\npp$8.regexp_eatDecimalDigits = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30\n    /* 0 */\n    );\n    state.advance();\n  }\n\n  return state.pos !== start;\n};\n\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30\n  /* 0 */\n  && ch <= 0x39;\n  /* 9 */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n\n\npp$8.regexp_eatHexDigits = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n\n  return state.pos !== start;\n};\n\nfunction isHexDigit(ch) {\n  return ch >= 0x30\n  /* 0 */\n  && ch <= 0x39\n  /* 9 */\n  || ch >= 0x41\n  /* A */\n  && ch <= 0x46\n  /* F */\n  || ch >= 0x61\n  /* a */\n  && ch <= 0x66\n  /* f */\n  ;\n}\n\nfunction hexToInt(ch) {\n  if (ch >= 0x41\n  /* A */\n  && ch <= 0x46\n  /* F */\n  ) {\n      return 10 + (ch - 0x41\n      /* A */\n      );\n    }\n\n  if (ch >= 0x61\n  /* a */\n  && ch <= 0x66\n  /* f */\n  ) {\n      return 10 + (ch - 0x61\n      /* a */\n      );\n    }\n\n  return ch - 0x30;\n  /* 0 */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\n\n\npp$8.regexp_eatLegacyOctalEscapeSequence = function (state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n\n    return true;\n  }\n\n  return false;\n}; // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n\n\npp$8.regexp_eatOctalDigit = function (state) {\n  var ch = state.current();\n\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30;\n    /* 0 */\n\n    state.advance();\n    return true;\n  }\n\n  state.lastIntValue = 0;\n  return false;\n};\n\nfunction isOctalDigit(ch) {\n  return ch >= 0x30\n  /* 0 */\n  && ch <= 0x37;\n  /* 7 */\n} // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n\n\npp$8.regexp_eatFixedHexDigits = function (state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false;\n    }\n\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n\n  return true;\n}; // Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n\n  if (p.options.locations) {\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n  }\n\n  if (p.options.ranges) {\n    this.range = [p.start, p.end];\n  }\n}; // ## Tokenizer\n\n\nexports.Token = Token;\nvar pp$9 = Parser.prototype; // Move to the next token\n\npp$9.next = function () {\n  if (this.options.onToken) {\n    this.options.onToken(new Token(this));\n  }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$9.getToken = function () {\n  this.next();\n  return new Token(this);\n}; // If we're in an ES6 environment, make parsers iterable\n\n\nif (typeof Symbol !== \"undefined\") {\n  pp$9[Symbol.iterator] = function () {\n    var this$1 = this;\n    return {\n      next: function next() {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        };\n      }\n    };\n  };\n} // Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\n\npp$9.curContext = function () {\n  return this.context[this.context.length - 1];\n}; // Read a single token, updating the parser object's token-related\n// properties.\n\n\npp$9.nextToken = function () {\n  var curContext = this.curContext();\n\n  if (!curContext || !curContext.preserveSpace) {\n    this.skipSpace();\n  }\n\n  this.start = this.pos;\n\n  if (this.options.locations) {\n    this.startLoc = this.curPosition();\n  }\n\n  if (this.pos >= this.input.length) {\n    return this.finishToken(types.eof);\n  }\n\n  if (curContext.override) {\n    return curContext.override(this);\n  } else {\n    this.readToken(this.fullCharCodeAtPos());\n  }\n};\n\npp$9.readToken = function (code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92\n  /* '\\' */\n  ) {\n      return this.readWord();\n    }\n\n  return this.getTokenFromCode(code);\n};\n\npp$9.fullCharCodeAtPos = function () {\n  var code = this.input.charCodeAt(this.pos);\n\n  if (code <= 0xd7ff || code >= 0xe000) {\n    return code;\n  }\n\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00;\n};\n\npp$9.skipBlockComment = function () {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos,\n      end = this.input.indexOf(\"*/\", this.pos += 2);\n\n  if (end === -1) {\n    this.raise(this.pos - 2, \"Unterminated comment\");\n  }\n\n  this.pos = end + 2;\n\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this.curLine;\n      this.lineStart = match.index + match[0].length;\n    }\n  }\n\n  if (this.options.onComment) {\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n  }\n};\n\npp$9.skipLineComment = function (startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n\n  if (this.options.onComment) {\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n  }\n}; // Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\n\npp$9.skipSpace = function () {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n\n    switch (ch) {\n      case 32:\n      case 160:\n        // ' '\n        ++this.pos;\n        break;\n\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n\n      case 10:\n      case 8232:\n      case 8233:\n        ++this.pos;\n\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n\n        break;\n\n      case 47:\n        // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n          case 42:\n            // '*'\n            this.skipBlockComment();\n            break;\n\n          case 47:\n            this.skipLineComment(2);\n            break;\n\n          default:\n            break loop;\n        }\n\n        break;\n\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop;\n        }\n\n    }\n  }\n}; // Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\n\npp$9.finishToken = function (type, val) {\n  this.end = this.pos;\n\n  if (this.options.locations) {\n    this.endLoc = this.curPosition();\n  }\n\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n  this.updateContext(prevType);\n}; // ### Token reading\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\n\n\npp$9.readToken_dot = function () {\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next >= 48 && next <= 57) {\n    return this.readNumber(true);\n  }\n\n  var next2 = this.input.charCodeAt(this.pos + 2);\n\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n    // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis);\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot);\n  }\n};\n\npp$9.readToken_slash = function () {\n  // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (this.exprAllowed) {\n    ++this.pos;\n    return this.readRegexp();\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(types.slash, 1);\n};\n\npp$9.readToken_mult_modulo_exp = function (code) {\n  // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo; // exponentiation operator ** and **=\n\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, size + 1);\n  }\n\n  return this.finishOp(tokentype, size);\n};\n\npp$9.readToken_pipe_amp = function (code) {\n  // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === code) {\n    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n};\n\npp$9.readToken_caret = function () {\n  // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(types.bitwiseXOR, 1);\n};\n\npp$9.readToken_plus_min = function (code) {\n  // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    return this.finishOp(types.incDec, 2);\n  }\n\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n\n  return this.finishOp(types.plusMin, 1);\n};\n\npp$9.readToken_lt_gt = function (code) {\n  // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n\n    if (this.input.charCodeAt(this.pos + size) === 61) {\n      return this.finishOp(types.assign, size + 1);\n    }\n\n    return this.finishOp(types.bitShift, size);\n  }\n\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken();\n  }\n\n  if (next === 61) {\n    size = 2;\n  }\n\n  return this.finishOp(types.relational, size);\n};\n\npp$9.readToken_eq_excl = function (code) {\n  // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n\n  if (next === 61) {\n    return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n  }\n\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n    // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow);\n  }\n\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);\n};\n\npp$9.getTokenFromCode = function (code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46:\n      // '.'\n      return this.readToken_dot();\n    // Punctuation tokens.\n\n    case 40:\n      ++this.pos;\n      return this.finishToken(types.parenL);\n\n    case 41:\n      ++this.pos;\n      return this.finishToken(types.parenR);\n\n    case 59:\n      ++this.pos;\n      return this.finishToken(types.semi);\n\n    case 44:\n      ++this.pos;\n      return this.finishToken(types.comma);\n\n    case 91:\n      ++this.pos;\n      return this.finishToken(types.bracketL);\n\n    case 93:\n      ++this.pos;\n      return this.finishToken(types.bracketR);\n\n    case 123:\n      ++this.pos;\n      return this.finishToken(types.braceL);\n\n    case 125:\n      ++this.pos;\n      return this.finishToken(types.braceR);\n\n    case 58:\n      ++this.pos;\n      return this.finishToken(types.colon);\n\n    case 63:\n      ++this.pos;\n      return this.finishToken(types.question);\n\n    case 96:\n      // '`'\n      if (this.options.ecmaVersion < 6) {\n        break;\n      }\n\n      ++this.pos;\n      return this.finishToken(types.backQuote);\n\n    case 48:\n      // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n\n      if (next === 120 || next === 88) {\n        return this.readRadixNumber(16);\n      } // '0x', '0X' - hex number\n\n\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) {\n          return this.readRadixNumber(8);\n        } // '0o', '0O' - octal number\n\n\n        if (next === 98 || next === 66) {\n          return this.readRadixNumber(2);\n        } // '0b', '0B' - binary number\n\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      // 1-9\n      return this.readNumber(false);\n    // Quotes produce strings.\n\n    case 34:\n    case 39:\n      // '\"', \"'\"\n      return this.readString(code);\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47:\n      // '/'\n      return this.readToken_slash();\n\n    case 37:\n    case 42:\n      // '%*'\n      return this.readToken_mult_modulo_exp(code);\n\n    case 124:\n    case 38:\n      // '|&'\n      return this.readToken_pipe_amp(code);\n\n    case 94:\n      // '^'\n      return this.readToken_caret();\n\n    case 43:\n    case 45:\n      // '+-'\n      return this.readToken_plus_min(code);\n\n    case 60:\n    case 62:\n      // '<>'\n      return this.readToken_lt_gt(code);\n\n    case 61:\n    case 33:\n      // '=!'\n      return this.readToken_eq_excl(code);\n\n    case 126:\n      // '~'\n      return this.finishOp(types.prefix, 1);\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n};\n\npp$9.finishOp = function (type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str);\n};\n\npp$9.readRegexp = function () {\n  var escaped,\n      inClass,\n      start = this.pos;\n\n  for (;;) {\n    if (this.pos >= this.input.length) {\n      this.raise(start, \"Unterminated regular expression\");\n    }\n\n    var ch = this.input.charAt(this.pos);\n\n    if (lineBreak.test(ch)) {\n      this.raise(start, \"Unterminated regular expression\");\n    }\n\n    if (!escaped) {\n      if (ch === \"[\") {\n        inClass = true;\n      } else if (ch === \"]\" && inClass) {\n        inClass = false;\n      } else if (ch === \"/\" && !inClass) {\n        break;\n      }\n\n      escaped = ch === \"\\\\\";\n    } else {\n      escaped = false;\n    }\n\n    ++this.pos;\n  }\n\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n\n  if (this.containsEsc) {\n    this.unexpected(flagsStart);\n  } // Validate pattern\n\n\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state); // Create Literal#value property value.\n\n  var value = null;\n\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {// ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {\n    pattern: pattern,\n    flags: flags,\n    value: value\n  });\n}; // Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\n\npp$9.readInt = function (radix, len) {\n  var start = this.pos,\n      total = 0;\n\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this.input.charCodeAt(this.pos),\n        val = void 0;\n\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } // a\n    else if (code >= 65) {\n        val = code - 65 + 10;\n      } // A\n      else if (code >= 48 && code <= 57) {\n          val = code - 48;\n        } // 0-9\n        else {\n            val = Infinity;\n          }\n\n    if (val >= radix) {\n      break;\n    }\n\n    ++this.pos;\n    total = total * radix + val;\n  }\n\n  if (this.pos === start || len != null && this.pos - start !== len) {\n    return null;\n  }\n\n  return total;\n};\n\npp$9.readRadixNumber = function (radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n\n  var val = this.readInt(radix);\n\n  if (val == null) {\n    this.raise(this.start + 2, \"Expected number in radix \" + radix);\n  }\n\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {\n    this.raise(this.pos, \"Identifier directly after number\");\n  }\n\n  return this.finishToken(types.num, val);\n}; // Read an integer, octal integer, or floating-point number.\n\n\npp$9.readNumber = function (startsWithDot) {\n  var start = this.pos;\n\n  if (!startsWithDot && this.readInt(10) === null) {\n    this.raise(start, \"Invalid number\");\n  }\n\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n  if (octal && this.strict) {\n    this.raise(start, \"Invalid number\");\n  }\n\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n    octal = false;\n  }\n\n  var next = this.input.charCodeAt(this.pos);\n\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var str$1 = this.input.slice(start, this.pos);\n    var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n    ++this.pos;\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.pos, \"Identifier directly after number\");\n    }\n\n    return this.finishToken(types.num, val$1);\n  }\n\n  if (next === 46 && !octal) {\n    // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n\n  if ((next === 69 || next === 101) && !octal) {\n    // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n\n    if (next === 43 || next === 45) {\n      ++this.pos;\n    } // '+-'\n\n\n    if (this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n  }\n\n  if (isIdentifierStart(this.fullCharCodeAtPos())) {\n    this.raise(this.pos, \"Identifier directly after number\");\n  }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val);\n}; // Read a string value, interpreting backslash-escapes.\n\n\npp$9.readCodePoint = function () {\n  var ch = this.input.charCodeAt(this.pos),\n      code;\n\n  if (ch === 123) {\n    // '{'\n    if (this.options.ecmaVersion < 6) {\n      this.unexpected();\n    }\n\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n\n    if (code > 0x10FFFF) {\n      this.invalidStringToken(codePos, \"Code point out of bounds\");\n    }\n  } else {\n    code = this.readHexChar(4);\n  }\n\n  return code;\n};\n\nfunction codePointToString$1(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  }\n\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\n\npp$9.readString = function (quote) {\n  var out = \"\",\n      chunkStart = ++this.pos;\n\n  for (;;) {\n    if (this.pos >= this.input.length) {\n      this.raise(this.start, \"Unterminated string constant\");\n    }\n\n    var ch = this.input.charCodeAt(this.pos);\n\n    if (ch === quote) {\n      break;\n    }\n\n    if (ch === 92) {\n      // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else {\n      if (isNewLine(ch, this.options.ecmaVersion >= 10)) {\n        this.raise(this.start, \"Unterminated string constant\");\n      }\n\n      ++this.pos;\n    }\n  }\n\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out);\n}; // Reads template string tokens.\n\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$9.tryReadTemplateToken = function () {\n  this.inTemplateElement = true;\n\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err;\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$9.invalidStringToken = function (position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR;\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$9.readTmplToken = function () {\n  var out = \"\",\n      chunkStart = this.pos;\n\n  for (;;) {\n    if (this.pos >= this.input.length) {\n      this.raise(this.start, \"Unterminated template\");\n    }\n\n    var ch = this.input.charCodeAt(this.pos);\n\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n      // '`', '${'\n      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types.dollarBraceL);\n        } else {\n          ++this.pos;\n          return this.finishToken(types.backQuote);\n        }\n      }\n\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types.template, out);\n    }\n\n    if (ch === 92) {\n      // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n\n      switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) {\n            ++this.pos;\n          }\n\n        case 10:\n          out += \"\\n\";\n          break;\n\n        default:\n          out += String.fromCharCode(ch);\n          break;\n      }\n\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n}; // Reads a template token to search for the end, without validating any escape sequences\n\n\npp$9.readInvalidTemplateToken = function () {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break;\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break;\n        }\n\n      // falls through\n\n      case \"`\":\n        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));\n      // no default\n    }\n  }\n\n  this.raise(this.start, \"Unterminated template\");\n}; // Used to read escaped characters\n\n\npp$9.readEscapedChar = function (inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n\n  switch (ch) {\n    case 110:\n      return \"\\n\";\n    // 'n' -> '\\n'\n\n    case 114:\n      return \"\\r\";\n    // 'r' -> '\\r'\n\n    case 120:\n      return String.fromCharCode(this.readHexChar(2));\n    // 'x'\n\n    case 117:\n      return codePointToString$1(this.readCodePoint());\n    // 'u'\n\n    case 116:\n      return \"\\t\";\n    // 't' -> '\\t'\n\n    case 98:\n      return \"\\b\";\n    // 'b' -> '\\b'\n\n    case 118:\n      return \"\\x0B\";\n    // 'v' -> '\\u000b'\n\n    case 102:\n      return \"\\f\";\n    // 'f' -> '\\f'\n\n    case 13:\n      if (this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n      }\n\n    // '\\r\\n'\n\n    case 10:\n      // ' \\n'\n      if (this.options.locations) {\n        this.lineStart = this.pos;\n        ++this.curLine;\n      }\n\n      return \"\";\n\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n        }\n\n        return String.fromCharCode(octal);\n      }\n\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\";\n      }\n\n      return String.fromCharCode(ch);\n  }\n}; // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\npp$9.readHexChar = function (len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n\n  if (n === null) {\n    this.invalidStringToken(codePos, \"Bad character escape sequence\");\n  }\n\n  return n;\n}; // Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\n\npp$9.readWord1 = function () {\n  this.containsEsc = false;\n  var word = \"\",\n      first = true,\n      chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) {\n      // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        {\n          this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n\n      ++this.pos;\n      var esc = this.readCodePoint();\n\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n        this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n      }\n\n      word += codePointToString$1(esc);\n      chunkStart = this.pos;\n    } else {\n      break;\n    }\n\n    first = false;\n  }\n\n  return word + this.input.slice(chunkStart, this.pos);\n}; // Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\n\npp$9.readWord = function () {\n  var word = this.readWord1();\n  var type = types.name;\n\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) {\n      this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word);\n    }\n\n    type = keywords$1[word];\n  }\n\n  return this.finishToken(type, word);\n}; // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n\nvar version = \"6.4.0\";\nexports.version = version;\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types,\n  keywordTypes: keywords$1,\n  TokContext: TokContext,\n  tokContexts: types$1,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n}; // The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return Parser.parse(input, options);\n} // This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options);\n} // Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVybi9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5tanM/MmViMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZXNlcnZlZCB3b3JkIGxpc3RzIGZvciB2YXJpb3VzIGRpYWxlY3RzIG9mIHRoZSBsYW5ndWFnZVxuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gIDU6IFwiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnRcIixcbiAgNjogXCJlbnVtXCIsXG4gIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gIHN0cmljdEJpbmQ6IFwiZXZhbCBhcmd1bWVudHNcIlxufTtcblxuLy8gQW5kIHRoZSBrZXl3b3Jkc1xuXG52YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG52YXIga2V5d29yZHMgPSB7XG4gIDU6IGVjbWE1QW5kTGVzc0tleXdvcmRzLFxuICBcIjVtb2R1bGVcIjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBleHBvcnQgaW1wb3J0XCIsXG4gIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbn07XG5cbnZhciBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yID0gL15pbihzdGFuY2VvZik/JC87XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuLy8gR2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YmRcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmZWZcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiZlxcdWE3YzItXFx1YTdjNlxcdWE3ZjctXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjdcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5cbi8vIFRoZXNlIGFyZSBhIHJ1bi1sZW5ndGggYW5kIG9mZnNldCBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuLy8gPjB4ZmZmZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBhIHZhbGlkIHBhcnQgb2YgaWRlbnRpZmllcnMuIFRoZVxuLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuLy8gb2Zmc2V0IHRvIHRoZSBuZXh0IHJhbmdlLCBhbmQgdGhlbiBhIHNpemUgb2YgdGhlIHJhbmdlLiBUaGV5IHdlcmVcbi8vIGdlbmVyYXRlZCBieSBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE0LDI5LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxNTcsMzEwLDEwLDIxLDExLDcsMTUzLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI4LDQzLDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCwxNCwzNSw0NzcsMjgsMTEsMCw5LDIxLDE1NSwyMiwxMyw1Miw3Niw0NCwzMywyNCwyNywzNSwzMCwwLDEyLDM0LDQsMCwxMyw0NywxNSwzLDIyLDAsMiwwLDM2LDE3LDIsMjQsODUsNiwyLDAsMiwzLDIsMTQsMiw5LDgsNDYsMzksNywzLDEsMywyMSwyLDYsMiwxLDIsNCw0LDAsMTksMCwxMyw0LDE1OSw1MiwxOSwzLDIxLDAsMzMsNDcsMjEsMSwyLDAsMTg1LDQ2LDQyLDMsMzcsNDcsMjEsMCw2MCw0MiwxNCwwLDcyLDI2LDIzMCw0MywxMTcsNjMsMzIsMCwxNjEsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDI3MCw5MjEsMTAzLDExMCwxOCwxOTUsMjc0OSwxMDcwLDQwNTAsNTgyLDg2MzQsNTY4LDgsMzAsMTE0LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw2ODksNjMsMTI5LDc0LDYsMCw2NywxMiw2NSwxLDIsMCwyOSw2MTM1LDksNzU0LDk0ODYsMjg2LDUwLDIsMTgsMyw5LDM5NSwyMzA5LDEwNiw2LDEyLDQsOCw4LDksNTk5MSw4NCwyLDcwLDIsMSwzLDAsMywxLDMsMywyLDExLDIsMCwyLDYsMiw2NCwyLDMsMyw3LDIsNiwyLDI3LDIsMywyLDQsMiwwLDQsNiwyLDMzOSwzLDI0LDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsNywyMzU3LDQ0LDExLDYsMTcsMCwzNzAsNDMsMTMwMSwxOTYsNjAsNjcsOCwwLDEyMDUsMywyLDI2LDIsMSwyLDAsMywwLDIsOSwyLDMsMiwwLDIsMCw3LDAsNSwwLDIsMCwyLDAsMiwyLDIsMSwyLDAsMywwLDIsMCwyLDAsMiwwLDIsMCwyLDEsMiwwLDMsMywyLDYsMiwzLDIsMywyLDAsMiw5LDIsMTYsNiwyLDIsNCwyLDE2LDQ0MjEsNDI3MTAsNDIsNDE0OCwxMiwyMjEsMyw1NzYxLDE1LDc0NzIsMzEwNCw1NDFdO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksNTI1LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsNCw5LDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksMjMyLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxOTMwNiw5LDEzNSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsMTk3MjMsMSw1MzE5LDQsNCw1LDksNywzLDYsMzEsMywxNDksMiwxNDE4LDQ5LDUxMyw1NCw1LDQ5LDksMCwxNSwwLDIzLDQsMiwxNCwxMzYxLDYsMiwxNiwzLDYsMiwxLDIsNCwyNjIsNiwxMCw5LDQxOSwxMywxNDk1LDYsMTEwLDYsNiw5LDc5MjQ4NywyMzldO1xuXG4vLyBUaGlzIGhhcyBhIGNvbXBsZXhpdHkgbGluZWFyIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29kZS4gVGhlXG4vLyBhc3N1bXB0aW9uIGlzIHRoYXQgbG9va2luZyB1cCBhc3RyYWwgaWRlbnRpZmllciBjaGFyYWN0ZXJzIGlzXG4vLyByYXJlLlxuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgdmFyIHBvcyA9IDB4MTAwMDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIGFzdHJhbCkge1xuICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICBpZiAoY29kZSA8IDQ4KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gIGlmIChjb2RlIDwgNTgpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChjb2RlIDwgOTEpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8IDk3KSB7IHJldHVybiBjb2RlID09PSA5NSB9XG4gIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7IHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSkgfVxuICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG59XG5cbi8vICMjIFRva2VuIHR5cGVzXG5cbi8vIFRoZSBhc3NpZ25tZW50IG9mIGZpbmUtZ3JhaW5lZCwgaW5mb3JtYXRpb24tY2FycnlpbmcgdHlwZSBvYmplY3RzXG4vLyBhbGxvd3MgdGhlIHRva2VuaXplciB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gaXQgaGFzIGFib3V0IGFcbi8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4vLyBBbGwgdG9rZW4gdHlwZSB2YXJpYWJsZXMgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlLCB0byBtYWtlIHRoZW1cbi8vIGVhc3kgdG8gcmVjb2duaXplLlxuXG4vLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuLy8gYmUgZm9sbG93ZWQgYnkgYW4gZXhwcmVzc2lvbiAodGh1cywgYSBzbGFzaCBhZnRlciB0aGVtIHdvdWxkIGJlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4vL1xuLy8gVGhlIGBzdGFydHNFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGNoZWNrIGlmIHRoZSB0b2tlbiBlbmRzIGFcbi8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbi8vIGRpcmVjdGx5IHN0YXJ0IGFuIGV4cHJlc3Npb24gKGxpa2UgYSBxdW90YXRpb24gbWFyaykgb3IgY2FuXG4vLyBjb250aW51ZSBhbiBleHByZXNzaW9uIChsaWtlIHRoZSBib2R5IG9mIGEgc3RyaW5nKS5cbi8vXG4vLyBgaXNMb29wYCBtYXJrcyBhIGtleXdvcmQgYXMgc3RhcnRpbmcgYSBsb29wLCB3aGljaCBpcyBpbXBvcnRhbnRcbi8vIHRvIGtub3cgd2hlbiBwYXJzaW5nIGEgbGFiZWwsIGluIG9yZGVyIHRvIGFsbG93IG9yIGRpc2FsbG93XG4vLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG52YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsLCBjb25mKSB7XG4gIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgfHwgbnVsbDtcbiAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGJpbm9wKG5hbWUsIHByZWMpIHtcbiAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiBwcmVjfSlcbn1cbnZhciBiZWZvcmVFeHByID0ge2JlZm9yZUV4cHI6IHRydWV9LCBzdGFydHNFeHByID0ge3N0YXJ0c0V4cHI6IHRydWV9O1xuXG4vLyBNYXAga2V5d29yZCBuYW1lcyB0byB0b2tlbiB0eXBlcy5cblxudmFyIGtleXdvcmRzJDEgPSB7fTtcblxuLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuICByZXR1cm4ga2V5d29yZHMkMVtuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbn1cblxudmFyIHR5cGVzID0ge1xuICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gIHJlZ2V4cDogbmV3IFRva2VuVHlwZShcInJlZ2V4cFwiLCBzdGFydHNFeHByKSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHN0YXJ0c0V4cHIpLFxuICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgZW9mOiBuZXcgVG9rZW5UeXBlKFwiZW9mXCIpLFxuXG4gIC8vIFB1bmN0dWF0aW9uIHRva2VuIHR5cGVzLlxuICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2tldFI6IG5ldyBUb2tlblR5cGUoXCJdXCIpLFxuICBicmFjZUw6IG5ldyBUb2tlblR5cGUoXCJ7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcGFyZW5SOiBuZXcgVG9rZW5UeXBlKFwiKVwiKSxcbiAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCBiZWZvcmVFeHByKSxcbiAgY29sb246IG5ldyBUb2tlblR5cGUoXCI6XCIsIGJlZm9yZUV4cHIpLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgYmVmb3JlRXhwciksXG4gIGFycm93OiBuZXcgVG9rZW5UeXBlKFwiPT5cIiwgYmVmb3JlRXhwciksXG4gIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gIGludmFsaWRUZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcImludmFsaWRUZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gIGRvbGxhckJyYWNlTDogbmV3IFRva2VuVHlwZShcIiR7XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG5cbiAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgLy9cbiAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAvL1xuICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBsb2dpY2FsT1I6IGJpbm9wKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICBiaXR3aXNlWE9SOiBiaW5vcChcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgcmVsYXRpb25hbDogYmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gIGJpdFNoaWZ0OiBiaW5vcChcIjw8Lz4+Lz4+PlwiLCA4KSxcbiAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBtb2R1bG86IGJpbm9wKFwiJVwiLCAxMCksXG4gIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICBzdGFyc3RhcjogbmV3IFRva2VuVHlwZShcIioqXCIsIHtiZWZvcmVFeHByOiB0cnVlfSksXG5cbiAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgX2JyZWFrOiBrdyhcImJyZWFrXCIpLFxuICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gIF9jb250aW51ZToga3coXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICBfZG86IGt3KFwiZG9cIiwge2lzTG9vcDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0pLFxuICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICBfZm9yOiBrdyhcImZvclwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgX2lmOiBrdyhcImlmXCIpLFxuICBfcmV0dXJuOiBrdyhcInJldHVyblwiLCBiZWZvcmVFeHByKSxcbiAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgX3RyeToga3coXCJ0cnlcIiksXG4gIF92YXI6IGt3KFwidmFyXCIpLFxuICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gIF93aGlsZToga3coXCJ3aGlsZVwiLCB7aXNMb29wOiB0cnVlfSksXG4gIF93aXRoOiBrdyhcIndpdGhcIiksXG4gIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF90aGlzOiBrdyhcInRoaXNcIiwgc3RhcnRzRXhwciksXG4gIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgX2NsYXNzOiBrdyhcImNsYXNzXCIsIHN0YXJ0c0V4cHIpLFxuICBfZXh0ZW5kczoga3coXCJleHRlbmRzXCIsIGJlZm9yZUV4cHIpLFxuICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiwgc3RhcnRzRXhwciksXG4gIF9udWxsOiBrdyhcIm51bGxcIiwgc3RhcnRzRXhwciksXG4gIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgX2luOiBrdyhcImluXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF92b2lkOiBrdyhcInZvaWRcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbn07XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbj98XFxufFxcdTIwMjh8XFx1MjAyOS87XG52YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuXG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSwgZWNtYTIwMTlTdHJpbmcpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8ICghZWNtYTIwMTlTdHJpbmcgJiYgKGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjkpKVxufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG52YXIgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcblxudmFyIHJlZiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSByZWYudG9TdHJpbmc7XG5cbi8vIENoZWNrcyBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG5cbmZ1bmN0aW9uIGhhcyhvYmosIHByb3BOYW1lKSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcE5hbWUpXG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuKTsgfSk7XG5cbmZ1bmN0aW9uIHdvcmRzUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG59XG5cbi8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuLy8gYHN0YXJ0TG9jYCBhbmQgYGVuZExvY2AgcHJvcGVydGllcy5cblxudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxuUG9zaXRpb24ucHJvdG90eXBlLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCAobikge1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24ocCwgc3RhcnQsIGVuZCkge1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xuICBpZiAocC5zb3VyY2VGaWxlICE9PSBudWxsKSB7IHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlOyB9XG59O1xuXG4vLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4vLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuLy8gd2FudCB0byBmaW5kIHRoZSBsaW5lL2NvbHVtbiBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbi8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbi8vIGludG8uXG5cbmZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgbGluZSA9IDEsIGN1ciA9IDA7Oykge1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gY3VyO1xuICAgIHZhciBtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG4gICAgICArK2xpbmU7XG4gICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBvZmZzZXQgLSBjdXIpXG4gICAgfVxuICB9XG59XG5cbi8vIEEgc2Vjb25kIG9wdGlvbmFsIGFyZ3VtZW50IGNhbiBiZSBnaXZlbiB0byBmdXJ0aGVyIGNvbmZpZ3VyZVxuLy8gdGhlIHBhcnNlciBwcm9jZXNzLiBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkOlxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIGBlY21hVmVyc2lvbmAgaW5kaWNhdGVzIHRoZSBFQ01BU2NyaXB0IHZlcnNpb24gdG8gcGFyc2UuIE11c3QgYmVcbiAgLy8gZWl0aGVyIDMsIDUsIDYgKDIwMTUpLCA3ICgyMDE2KSwgOCAoMjAxNyksIDkgKDIwMTgpLCBvciAxMFxuICAvLyAoMjAxOSkuIFRoaXMgaW5mbHVlbmNlcyBzdXBwb3J0IGZvciBzdHJpY3QgbW9kZSwgdGhlIHNldCBvZlxuICAvLyByZXNlcnZlZCB3b3JkcywgYW5kIHN1cHBvcnQgZm9yIG5ldyBzeW50YXggZmVhdHVyZXMuIFRoZSBkZWZhdWx0XG4gIC8vIGlzIDkuXG4gIGVjbWFWZXJzaW9uOiA5LFxuICAvLyBgc291cmNlVHlwZWAgaW5kaWNhdGVzIHRoZSBtb2RlIHRoZSBjb2RlIHNob3VsZCBiZSBwYXJzZWQgaW4uXG4gIC8vIENhbiBiZSBlaXRoZXIgYFwic2NyaXB0XCJgIG9yIGBcIm1vZHVsZVwiYC4gVGhpcyBpbmZsdWVuY2VzIGdsb2JhbFxuICAvLyBzdHJpY3QgbW9kZSBhbmQgcGFyc2luZyBvZiBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgZGVjbGFyYXRpb25zLlxuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZFxuICAvLyB3aGVuIGEgc2VtaWNvbG9uIGlzIGF1dG9tYXRpY2FsbHkgaW5zZXJ0ZWQuIEl0IHdpbGwgYmUgcGFzc2VkXG4gIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgLy8gZW5hYmxlZCwgaXQgaXMgZ2l2ZW4gdGhlIGxvY2F0aW9uIGFzIGEgYHtsaW5lLCBjb2x1bW59YCBvYmplY3RcbiAgLy8gYXMgc2Vjb25kIGFyZ3VtZW50LlxuICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAvLyBgb25UcmFpbGluZ0NvbW1hYCBpcyBzaW1pbGFyIHRvIGBvbkluc2VydGVkU2VtaWNvbG9uYCwgYnV0IGZvclxuICAvLyB0cmFpbGluZyBjb21tYXMuXG4gIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgLy8gQnkgZGVmYXVsdCwgcmVzZXJ2ZWQgd29yZHMgYXJlIG9ubHkgZW5mb3JjZWQgaWYgZWNtYVZlcnNpb24gPj0gNS5cbiAgLy8gU2V0IGBhbGxvd1Jlc2VydmVkYCB0byBhIGJvb2xlYW4gdmFsdWUgdG8gZXhwbGljaXRseSB0dXJuIHRoaXMgb25cbiAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAvLyBhbmQga2V5d29yZHMgY2FuIGFsc28gbm90IGJlIHVzZWQgYXMgcHJvcGVydHkgbmFtZXMuXG4gIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAvLyBlcnJvci5cbiAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gIC8vIGFwcGVhcmluZyBhdCB0aGUgdG9wIG9mIHRoZSBwcm9ncmFtLlxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGF3YWl0IGlkZW50aWZpZXJzIGFyZSBhbGxvd2VkIHRvIGFwcGVhciBhdCB0aGUgdG9wLWxldmVsIHNjb3BlLFxuICAvLyBidXQgdGhleSBhcmUgc3RpbGwgbm90IGFsbG93ZWQgaW4gbm9uLWFzeW5jIGZ1bmN0aW9ucy5cbiAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaGFzaGJhbmcgZGlyZWN0aXZlIGluIHRoZSBiZWdpbm5pbmcgb2YgZmlsZVxuICAvLyBpcyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LlxuICBhbGxvd0hhc2hCYW5nOiBmYWxzZSxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgYGxvY2AgcHJvcGVydGllcyBob2xkaW5nIG9iamVjdHMgd2l0aFxuICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIGluIGB7bGluZSwgY29sdW1ufWAgZm9ybSAod2l0aFxuICAvLyBsaW5lIGJlaW5nIDEtYmFzZWQgYW5kIGNvbHVtbiAwLWJhc2VkKSB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZVxuICAvLyBub2Rlcy5cbiAgbG9jYXRpb25zOiBmYWxzZSxcbiAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvblRva2VuYCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggb2JqZWN0IGluIHRoZSBzYW1lXG4gIC8vIGZvcm1hdCBhcyB0b2tlbnMgcmV0dXJuZWQgZnJvbSBgdG9rZW5pemVyKCkuZ2V0VG9rZW4oKWAuIE5vdGVcbiAgLy8gdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlIHBhcnNlciBmcm9tIHRoZVxuICAvLyBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Ub2tlbjogbnVsbCxcbiAgLy8gQSBmdW5jdGlvbiBjYW4gYmUgcGFzc2VkIGFzIGBvbkNvbW1lbnRgIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBgKGJsb2NrLCB0ZXh0LCBzdGFydCxcbiAgLy8gZW5kKWAgcGFyYW1ldGVycyB3aGVuZXZlciBhIGNvbW1lbnQgaXMgc2tpcHBlZC4gYGJsb2NrYCBpcyBhXG4gIC8vIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBibG9jayAoYC8qICovYCkgY29tbWVudCxcbiAgLy8gYHRleHRgIGlzIHRoZSBjb250ZW50IG9mIHRoZSBjb21tZW50LCBhbmQgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlXG4gIC8vIGNoYXJhY3RlciBvZmZzZXRzIHRoYXQgZGVub3RlIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBjb21tZW50LlxuICAvLyBXaGVuIHRoZSBgbG9jYXRpb25zYCBvcHRpb24gaXMgb24sIHR3byBtb3JlIHBhcmFtZXRlcnMgYXJlXG4gIC8vIHBhc3NlZCwgdGhlIGZ1bGwgYHtsaW5lLCBjb2x1bW59YCBsb2NhdGlvbnMgb2YgdGhlIHN0YXJ0IGFuZFxuICAvLyBlbmQgb2YgdGhlIGNvbW1lbnRzLiBOb3RlIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZVxuICAvLyBwYXJzZXIgZnJvbSB0aGUgY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gIG9uQ29tbWVudDogbnVsbCxcbiAgLy8gTm9kZXMgaGF2ZSB0aGVpciBzdGFydCBhbmQgZW5kIGNoYXJhY3RlcnMgb2Zmc2V0cyByZWNvcmRlZCBpblxuICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIChkaXJlY3RseSBvbiB0aGUgbm9kZSwgcmF0aGVyIHRoYW5cbiAgLy8gdGhlIGBsb2NgIG9iamVjdCwgd2hpY2ggaG9sZHMgbGluZS9jb2x1bW4gZGF0YS4gVG8gYWxzbyBhZGQgYVxuICAvLyBbc2VtaS1zdGFuZGFyZGl6ZWRdW3JhbmdlXSBgcmFuZ2VgIHByb3BlcnR5IGhvbGRpbmcgYSBgW3N0YXJ0LFxuICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gIC8vIGB0cnVlYC5cbiAgLy9cbiAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gIHJhbmdlczogZmFsc2UsXG4gIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBhcnNlIG11bHRpcGxlIGZpbGVzIGludG8gYSBzaW5nbGUgQVNUIGJ5XG4gIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAvLyBgcHJvZ3JhbWAgb3B0aW9uIGluIHN1YnNlcXVlbnQgcGFyc2VzLiBUaGlzIHdpbGwgYWRkIHRoZVxuICAvLyB0b3BsZXZlbCBmb3JtcyBvZiB0aGUgcGFyc2VkIGZpbGUgdG8gdGhlIGBQcm9ncmFtYCAodG9wKSBub2RlXG4gIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gIHByb2dyYW06IG51bGwsXG4gIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIHlvdSBjYW4gcGFzcyB0aGlzIHRvIHJlY29yZCB0aGUgc291cmNlXG4gIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgc291cmNlRmlsZTogbnVsbCxcbiAgLy8gVGhpcyB2YWx1ZSwgaWYgZ2l2ZW4sIGlzIHN0b3JlZCBpbiBldmVyeSBub2RlLCB3aGV0aGVyXG4gIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgZGlyZWN0U291cmNlRmlsZTogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25zIGFyZSByZXByZXNlbnRlZCBieVxuICAvLyAobm9uLXN0YW5kYXJkKSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiBub2Rlc1xuICBwcmVzZXJ2ZVBhcmVuczogZmFsc2Vcbn07XG5cbi8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpXG4gICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICB9XG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgdmFsdWU6IHRleHQsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gIH1cbn1cblxuLy8gRWFjaCBzY29wZSBnZXRzIGEgYml0c2V0IHRoYXQgbWF5IGNvbnRhaW4gdGhlc2UgZmxhZ3NcbnZhclxuICAgIFNDT1BFX1RPUCA9IDEsXG4gICAgU0NPUEVfRlVOQ1RJT04gPSAyLFxuICAgIFNDT1BFX1ZBUiA9IFNDT1BFX1RPUCB8IFNDT1BFX0ZVTkNUSU9OLFxuICAgIFNDT1BFX0FTWU5DID0gNCxcbiAgICBTQ09QRV9HRU5FUkFUT1IgPSA4LFxuICAgIFNDT1BFX0FSUk9XID0gMTYsXG4gICAgU0NPUEVfU0lNUExFX0NBVENIID0gMzIsXG4gICAgU0NPUEVfU1VQRVIgPSA2NCxcbiAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAxMjg7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoYXN5bmMsIGdlbmVyYXRvcikge1xuICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG59XG5cbi8vIFVzZWQgaW4gY2hlY2tMVmFsIGFuZCBkZWNsYXJlTmFtZSB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYSBiaW5kaW5nXG52YXJcbiAgICBCSU5EX05PTkUgPSAwLCAvLyBOb3QgYSBiaW5kaW5nXG4gICAgQklORF9WQVIgPSAxLCAvLyBWYXItc3R5bGUgYmluZGluZ1xuICAgIEJJTkRfTEVYSUNBTCA9IDIsIC8vIExldC0gb3IgY29uc3Qtc3R5bGUgYmluZGluZ1xuICAgIEJJTkRfRlVOQ1RJT04gPSAzLCAvLyBGdW5jdGlvbiBkZWNsYXJhdGlvblxuICAgIEJJTkRfU0lNUExFX0NBVENIID0gNCwgLy8gU2ltcGxlIChpZGVudGlmaWVyIHBhdHRlcm4pIGNhdGNoIGJpbmRpbmdcbiAgICBCSU5EX09VVFNJREUgPSA1OyAvLyBTcGVjaWFsIGNhc2UgZm9yIGZ1bmN0aW9uIG5hbWVzIGFzIGJvdW5kIGluc2lkZSB0aGUgZnVuY3Rpb25cblxudmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgdGhpcy5rZXl3b3JkcyA9IHdvcmRzUmVnZXhwKGtleXdvcmRzW29wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiA/IDYgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIgPyBcIjVtb2R1bGVcIiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gdHJ1ZSkge1xuICAgIGZvciAodmFyIHYgPSBvcHRpb25zLmVjbWFWZXJzaW9uOzsgdi0tKVxuICAgICAgeyBpZiAocmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW3ZdKSB7IGJyZWFrIH0gfVxuICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICB9XG4gIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0KTtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICBpZiAoc3RhcnRQb3MpIHtcbiAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICB9XG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcbiAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG4gIC8vIFRodXMtZmFyIHVuZGVmaW5lZCBleHBvcnRzLlxuICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSB7fTtcblxuICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgaWYgKHRoaXMucG9zID09PSAwICYmIG9wdGlvbnMuYWxsb3dIYXNoQmFuZyAmJiB0aGlzLmlucHV0LnNsaWNlKDAsIDIpID09PSBcIiMhXCIpXG4gICAgeyB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTsgfVxuXG4gIC8vIFNjb3BlIHRyYWNraW5nIGZvciBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMgKHNlZSBzY29wZS5qcylcbiAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gIC8vIEZvciBSZWdFeHAgdmFsaWRhdGlvblxuICB0aGlzLnJlZ2V4cFN0YXRlID0gbnVsbDtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGluRnVuY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5HZW5lcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5Bc3luYzogeyBjb25maWd1cmFibGU6IHRydWUgfSxhbGxvd1N1cGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93RGlyZWN0U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdHJlYXRGdW5jdGlvbnNBc1ZhcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKCkge1xuICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dFRva2VuKCk7XG4gIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwobm9kZSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5pbkZ1bmN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmluR2VuZXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfR0VORVJBVE9SKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfU1VQRVIpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmFsbG93RGlyZWN0U3VwZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDAgfTtcbnByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuLy8gU3dpdGNoIHRvIGEgZ2V0dGVyIGZvciA3LjAuMC5cblBhcnNlci5wcm90b3R5cGUuaW5Ob25BcnJvd0Z1bmN0aW9uID0gZnVuY3Rpb24gaW5Ob25BcnJvd0Z1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA+IDAgfTtcblxuUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgcGx1Z2luc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHZhciBjbHMgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHsgY2xzID0gcGx1Z2luc1tpXShjbHMpOyB9XG4gIHJldHVybiBjbHNcbn07XG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbn07XG5cblBhcnNlci5wYXJzZUV4cHJlc3Npb25BdCA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0IChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCwgcG9zKTtcbiAgcGFyc2VyLm5leHRUb2tlbigpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbigpXG59O1xuXG5QYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBwcCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIFBhcnNlciB1dGlsaXRpZXNcblxudmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXSkqPyknfFwiKCg/OlxcXFwufFteXCJdKSo/KVwiKS87XG5wcC5zdHJpY3REaXJlY3RpdmUgPSBmdW5jdGlvbihzdGFydCkge1xuICBmb3IgKDs7KSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgc3RyaW5nIGxpdGVyYWwuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7IHJldHVybiB0cnVlIH1cbiAgICBzdGFydCArPSBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAvLyBTa2lwIHNlbWljb2xvbiwgaWYgYW55LlxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICB7IHN0YXJ0Kys7IH1cbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG5wcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG5wcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwLnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcC5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgaWYgKCFub3ROZXh0KVxuICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwLmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG4vLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG59O1xuXG5mdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAtMTtcbn1cblxucHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxufTtcblxucHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbn07XG5cbnBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbn07XG5cbnBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxufTtcblxudmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4vLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG5wcCQxLnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBleHBvcnRzID0ge307XG4gIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmVvZikge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsLCB0cnVlLCBleHBvcnRzKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAodGhpcy5pbk1vZHVsZSlcbiAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdLnN0YXJ0LCAoXCJFeHBvcnQgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgZGVmaW5lZFwiKSk7XG4gICAgICB9IH1cbiAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbn07XG5cbnZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxucHAkMS5pc0xldCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAvLyBGb3IgYW1iaWd1b3VzIGNhc2VzLCBkZXRlcm1pbmUgaWYgYSBMZXhpY2FsRGVjbGFyYXRpb24gKG9yIG9ubHkgYVxuICAvLyBTdGF0ZW1lbnQpIGlzIGFsbG93ZWQgaGVyZS4gSWYgY29udGV4dCBpcyBub3QgZW1wdHkgdGhlbiBvbmx5IGEgU3RhdGVtZW50XG4gIC8vIGlzIGFsbG93ZWQuIEhvd2V2ZXIsIGBsZXQgW2AgaXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgbG9va2FoZWFkIGZvclxuICAvLyBFeHByZXNzaW9uU3RhdGVtZW50LCBzbyBzcGVjaWFsLWNhc2UgaXQgZmlyc3QuXG4gIGlmIChuZXh0Q2ggPT09IDkxKSB7IHJldHVybiB0cnVlIH0gLy8gJ1snXG4gIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKG5leHRDaCA9PT0gMTIzKSB7IHJldHVybiB0cnVlIH0gLy8gJ3snXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICBpZiAoIWtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdChpZGVudCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gY2hlY2sgJ2FzeW5jIFtubyBMaW5lVGVybWluYXRvciBoZXJlXSBmdW5jdGlvbidcbi8vIC0gJ2FzeW5jIC8qZm9vKi8gZnVuY3Rpb24nIGlzIE9LLlxuLy8gLSAnYXN5bmMgLypcXG4qLyBmdW5jdGlvbicgaXMgaW52YWxpZC5cbnBwJDEuaXNBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGg7XG4gIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIChuZXh0ICsgOCA9PT0gdGhpcy5pbnB1dC5sZW5ndGggfHwgIWlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQXQobmV4dCArIDgpKSlcbn07XG5cbi8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbi8vXG4vLyBJZiBleHBlY3RpbmcgYSBzdGF0ZW1lbnQgYW5kIGZpbmRpbmcgYSBzbGFzaCBvcGVyYXRvciwgcGFyc2UgYVxuLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2Vcbi8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbi8vIGRvZXMgbm90IGhlbHAuXG5cbnBwJDEucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb250ZXh0LCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgIHN0YXJ0dHlwZSA9IHR5cGVzLl92YXI7XG4gICAga2luZCA9IFwibGV0XCI7XG4gIH1cblxuICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgLy8gY29tcGxleGl0eS5cblxuICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuICBjYXNlIHR5cGVzLl9icmVhazogY2FzZSB0eXBlcy5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgY2FzZSB0eXBlcy5fZGVidWdnZXI6IHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZG86IHJldHVybiB0aGlzLnBhcnNlRG9TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAvLyBGdW5jdGlvbiBhcyBzb2xlIGJvZHkgb2YgZWl0aGVyIGFuIGlmIHN0YXRlbWVudCBvciBhIGxhYmVsZWQgc3RhdGVtZW50XG4gICAgLy8gd29ya3MsIGJ1dCBub3Qgd2hlbiBpdCBpcyBwYXJ0IG9mIGEgbGFiZWxlZCBzdGF0ZW1lbnQgdGhhdCBpcyB0aGUgc29sZVxuICAgIC8vIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlxuICAgIGlmICgoY29udGV4dCAmJiAodGhpcy5zdHJpY3QgfHwgY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikpICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWNvbnRleHQpXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKVxuICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3N3aXRjaDogcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9jb25zdDogY2FzZSB0eXBlcy5fdmFyOlxuICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgaWYgKGNvbnRleHQgJiYga2luZCAhPT0gXCJ2YXJcIikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gIGNhc2UgdHlwZXMuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3dpdGg6IHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jayh0cnVlLCBub2RlKVxuICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCkge1xuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQwKSAvLyAnKCdcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgaWYgKCF0b3BMZXZlbClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Nb2R1bGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogbW9kdWxlJ1wiKTsgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZXhwb3J0cylcblxuICAgIC8vIElmIHRoZSBzdGF0ZW1lbnQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHN0YXRlbWVudCBrZXl3b3JkIG9yIGFcbiAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAgIC8vIG5leHQgdG9rZW4gaXMgYSBjb2xvbiBhbmQgdGhlIGV4cHJlc3Npb24gd2FzIGEgc2ltcGxlXG4gICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gIGRlZmF1bHQ6XG4gICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgdHJ1ZSwgIWNvbnRleHQpXG4gICAgfVxuXG4gICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmIChzdGFydHR5cGUgPT09IHR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgZWxzZSBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIGVsc2Uge1xuICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gIC8vIGNvbnRpbnVlIHRvLlxuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGFiID0gdGhpcy5sYWJlbHNbaV07XG4gICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gXCJsb29wXCIpKSB7IGJyZWFrIH1cbiAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAoaSA9PT0gdGhpcy5sYWJlbHMubGVuZ3RoKSB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZG9cIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IHRoaXMuZWF0KHR5cGVzLnNlbWkpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbi8vIERpc2FtYmlndWF0aW5nIGJldHdlZW4gYSBgZm9yYCBhbmQgYSBgZm9yYC9gaW5gIG9yIGBmb3JgL2BvZmBcbi8vIGxvb3AgaXMgbm9uLXRyaXZpYWwuIEJhc2ljYWxseSwgd2UgaGF2ZSB0byBwYXJzZSB0aGUgaW5pdCBgdmFyYFxuLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbi8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGBwYXJzZUV4cHJlc3Npb25gKSwgYW5kIHRoZW4gY2hlY2tcbi8vIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYGluYCBvciBgb2ZgLiBXaGVuIHRoZXJlIGlzIG5vIGluaXRcbi8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4vLyBpcyBhIHJlZ3VsYXIgYGZvcmAgbG9vcC5cblxucHAkMS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHZhciBhd2FpdEF0ID0gKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSAmJiB0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSkgPyB0aGlzLmxhc3RUb2tTdGFydCA6IC0xO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSkge1xuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgfVxuICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl92YXIgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fY29uc3QgfHwgaXNMZXQpIHtcbiAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihpbml0JDEsIHRydWUsIGtpbmQpO1xuICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gIH1cbiAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICB9IGVsc2UgeyBub2RlLmF3YWl0ID0gYXdhaXRBdCA+IC0xOyB9XG4gICAgfVxuICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB0aGlzLmNoZWNrTFZhbChpbml0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gIH1cbiAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbn07XG5cbnBwJDEucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG59O1xuXG5wcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICghdGhpcy5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICB0aGlzLm5leHQoKTtcblxuICAvLyBJbiBgcmV0dXJuYCAoYW5kIGBicmVha2AvYGNvbnRpbnVlYCksIHRoZSBrZXl3b3JkcyB3aXRoXG4gIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNhc2VzID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXI7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVI7KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcy50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2U7XG4gICAgICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICBjdXIudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzXCIpOyB9XG4gICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICBjdXIudGVzdCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCkpO1xuICAgIH1cbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xuICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxufTtcblxuLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgY2xhdXNlLnBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgICB2YXIgc2ltcGxlID0gY2xhdXNlLnBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgICAgdGhpcy5lbnRlclNjb3BlKHNpbXBsZSA/IFNDT1BFX1NJTVBMRV9DQVRDSCA6IDApO1xuICAgICAgdGhpcy5jaGVja0xWYWwoY2xhdXNlLnBhcmFtLCBzaW1wbGUgPyBCSU5EX1NJTVBMRV9DQVRDSCA6IEJJTkRfTEVYSUNBTCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG4gICAgfVxuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gIH1cbiAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2hpbGVcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkge1xuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcy5sYWJlbHM7IGkkMSA8IGxpc3QubGVuZ3RoOyBpJDEgKz0gMSlcbiAgICB7XG4gICAgdmFyIGxhYmVsID0gbGlzdFtpJDFdO1xuXG4gICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSlcbiAgICAgIHsgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICB9IH1cbiAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhYmVsJDEgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICBpZiAobGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgbGFiZWwkMS5raW5kID0ga2luZDtcbiAgICB9IGVsc2UgeyBicmVhayB9XG4gIH1cbiAgdGhpcy5sYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydH0pO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICBub2RlLmxhYmVsID0gZXhwcjtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgZXhwcikge1xuICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4vLyBzdHJpY3RcImAgZGVjbGFyYXRpb25zIHdoZW4gYGFsbG93U3RyaWN0YCBpcyB0cnVlICh1c2VkIGZvclxuLy8gZnVuY3Rpb24gYm9kaWVzKS5cblxucHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBub2RlKSB7XG4gIGlmICggY3JlYXRlTmV3TGV4aWNhbFNjb3BlID09PSB2b2lkIDAgKSBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlO1xuICBpZiAoIG5vZGUgPT09IHZvaWQgMCApIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIG5vZGUuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZW50ZXJTY29wZSgwKTsgfVxuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4vLyBzYW1lIGZyb20gcGFyc2VyJ3MgcGVyc3BlY3RpdmUuXG5cbnBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgdmFyIGlzRm9ySW4gPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9pbjtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgaWYgKFxuICAgIGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiZcbiAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAoXG4gICAgICAhaXNGb3JJbiB8fFxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fFxuICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgIGluaXQua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCJcbiAgICApXG4gICkge1xuICAgIHRoaXMucmFpc2UoXG4gICAgICBpbml0LnN0YXJ0LFxuICAgICAgKChpc0ZvckluID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCIpICsgXCIgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXJcIilcbiAgICApO1xuICB9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3BcIik7XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IGlzRm9ySW4gPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG5wcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgbm9kZS5raW5kID0ga2luZDtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgZGVjbC5pbml0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJucyByZXF1aXJlIGFuIGluaXRpYWxpemF0aW9uIHZhbHVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNsLmluaXQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgYnJlYWsgfVxuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG5wcCQxLnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsLCBraW5kKSB7XG4gIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCA9PT0gXCJ2YXJcIiA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMLCBmYWxzZSk7XG59O1xuXG52YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cbi8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UYCkuXG5cbi8vIFJlbW92ZSBgYWxsb3dFeHByZXNzaW9uQm9keWAgZm9yIDcuMC4wLCBhcyBpdCBpcyBvbmx5IGNhbGxlZCB3aXRoIGZhbHNlXG5wcCQxLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMpIHtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhaXNBc3luYykge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIgJiYgKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgIG5vZGUuaWQgPSAoc3RhdGVtZW50ICYgRlVOQ19OVUxMQUJMRV9JRCkgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lID8gbnVsbCA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChub2RlLmlkICYmICEoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICAvLyBJZiBpdCBpcyBhIHJlZ3VsYXIgZnVuY3Rpb24gZGVjbGFyYXRpb24gaW4gc2xvcHB5IG1vZGUsIHRoZW4gaXQgaXNcbiAgICAgIC8vIHN1YmplY3QgdG8gQW5uZXggQiBzZW1hbnRpY3MgKEJJTkRfRlVOQ1RJT04pLiBPdGhlcndpc2UsIHRoZSBiaW5kaW5nXG4gICAgICAvLyBtb2RlIGRlcGVuZHMgb24gcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBzY29wZSAoc2VlXG4gICAgICAvLyB0cmVhdEZ1bmN0aW9uc0FzVmFyKS5cbiAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgKHRoaXMuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMpID8gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwgOiBCSU5EX0ZVTkNUSU9OKTsgfVxuICB9XG5cbiAgdmFyIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKG5vZGUuYXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG5cbiAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDsgfVxuXG4gIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xufTtcblxuLy8gUGFyc2UgYSBjbGFzcyBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDEucGFyc2VDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIGVjbWEtMjYyIDE0LjYgQ2xhc3MgRGVmaW5pdGlvbnNcbiAgLy8gQSBjbGFzcyBkZWZpbml0aW9uIGlzIGFsd2F5cyBzdHJpY3QgbW9kZSBjb2RlLlxuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3Q7XG4gIHRoaXMuc3RyaWN0ID0gdHJ1ZTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRWxlbWVudChub2RlLnN1cGVyQ2xhc3MgIT09IG51bGwpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZWxlbWVudC5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7IHRoaXMucmFpc2UoZWxlbWVudC5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24oY29uc3RydWN0b3JBbGxvd3NTdXBlcikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgdHJ5Q29udGV4dHVhbCA9IGZ1bmN0aW9uIChrLCBub0xpbmVCcmVhaykge1xuICAgIGlmICggbm9MaW5lQnJlYWsgPT09IHZvaWQgMCApIG5vTGluZUJyZWFrID0gZmFsc2U7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgIGlmICghdGhpcyQxLmVhdENvbnRleHR1YWwoaykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcyQxLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiAoIW5vTGluZUJyZWFrIHx8ICF0aGlzJDEuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgbWV0aG9kLmtleSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydCwgc3RhcnRMb2MpO1xuICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgdGhpcyQxLmZpbmlzaE5vZGUobWV0aG9kLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgbWV0aG9kLnN0YXRpYyA9IHRyeUNvbnRleHR1YWwoXCJzdGF0aWNcIik7XG4gIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICBpZiAoIWlzR2VuZXJhdG9yKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcImdldFwiO1xuICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcInNldFwiKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgIH1cbiAgfVxuICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICB2YXIgYWxsb3dzRGlyZWN0U3VwZXIgPSBmYWxzZTtcbiAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgaWYgKG1ldGhvZC5raW5kICE9PSBcIm1ldGhvZFwiKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGhhdmUgZ2V0L3NldCBtb2RpZmllclwiKTsgfVxuICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvclwiKTsgfVxuICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIGFsbG93c0RpcmVjdFN1cGVyID0gY29uc3RydWN0b3JBbGxvd3NTdXBlcjtcbiAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgIHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiKTtcbiAgfVxuICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgcmV0dXJuIG1ldGhvZFxufTtcblxucHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKGlzU3RhdGVtZW50KVxuICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX0xFWElDQUwsIGZhbHNlKTsgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc1N0YXRlbWVudCA9PT0gdHJ1ZSlcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBub2RlLmlkID0gbnVsbDtcbiAgfVxufTtcblxucHAkMS5wYXJzZUNsYXNzU3VwZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbn07XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24obm9kZSwgZXhwb3J0cykge1xuICB0aGlzLm5leHQoKTtcbiAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIilcbiAgfVxuICBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHRoaXMubGFzdFRva1N0YXJ0KTtcbiAgICB2YXIgaXNBc3luYztcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24gfHwgKGlzQXN5bmMgPSB0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSkge1xuICAgICAgdmFyIGZOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5uZXh0KCk7IH1cbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb24oZk5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgRlVOQ19OVUxMQUJMRV9JRCwgZmFsc2UsIGlzQXN5bmMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2xhc3MpIHtcbiAgICAgIHZhciBjTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzKGNOb2RlLCBcIm51bGxhYmxlSURcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIilcbiAgfVxuICAvLyBleHBvcnQgdmFyfGNvbnN0fGxldHxmdW5jdGlvbnxjbGFzcyAuLi5cbiAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSkge1xuICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpO1xuICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgeyB0aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQubmFtZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5zdGFydCk7IH1cbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gIH0gZWxzZSB7IC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGV4cG9ydHMpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5zcGVjaWZpZXJzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICB2YXIgc3BlYyA9IGxpc3RbaV07XG5cbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGV4cG9ydCBpcyBkZWZpbmVkXG4gICAgICAgIHRoaXMuY2hlY2tMb2NhbEV4cG9ydChzcGVjLmxvY2FsKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpXG59O1xuXG5wcCQxLmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gIGlmICghZXhwb3J0cykgeyByZXR1cm4gfVxuICBpZiAoaGFzKGV4cG9ydHMsIG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgZXhwb3J0c1tuYW1lXSA9IHRydWU7XG59O1xuXG5wcCQxLmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICB2YXIgdHlwZSA9IHBhdC50eXBlO1xuICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdC5uYW1lLCBwYXQuc3RhcnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXQucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwcm9wKTtcbiAgICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09PSBcIkFycmF5UGF0dGVyblwiKVxuICAgIHsgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gcGF0LmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgIGlmIChlbHQpIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxufTtcblxucHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBkZWNsLmlkKTtcbiAgfVxufTtcblxucHAkMS5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICB0aGlzLmlzTGV0KCkgfHxcbiAgICB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxucHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50KHRydWUpIDogbm9kZS5sb2NhbDtcbiAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgbm9kZS5leHBvcnRlZC5zdGFydCk7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gIH1cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUkMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICBub2RlJDIubG9jYWwgPSBub2RlJDIuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgQklORF9MRVhJQ0FMKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHByb3AuYXJndW1lbnQuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICAgIGlmIChub2RlLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMucmFpc2Uobm9kZS5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQsIGlzQmluZGluZyk7XG4gICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLmFyZ3VtZW50LnN0YXJ0LCBcIlJlc3QgZWxlbWVudHMgY2Fubm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICBpZiAobm9kZS5vcGVyYXRvciAhPT0gXCI9XCIpIHsgdGhpcy5yYWlzZShub2RlLmxlZnQuZW5kLCBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIpOyB9XG4gICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNCaW5kaW5nKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2ggdG8gQXNzaWdubWVudFBhdHRlcm5cblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxucHAkMi50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGlzQmluZGluZykge1xuICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgIGlmIChlbHQpIHsgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0JpbmRpbmcpOyB9XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiBpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgfVxuICByZXR1cm4gZXhwckxpc3Rcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTcHJlYWRFbGVtZW50XCIpXG59O1xuXG5wcCQyLnBhcnNlUmVzdEJpbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcblxuICAvLyBSZXN0RWxlbWVudCBpbnNpZGUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpZGVudGlmaWVyXG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZXMgbHZhbHVlIChhc3NpZ25hYmxlKSBhdG9tLlxuXG5wcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIilcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmoodHJ1ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dFbXB0eSwgYWxsb3dUcmFpbGluZ0NvbW1hKSB7XG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBmYWxzZTsgfVxuICAgIGVsc2UgeyB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7IH1cbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgdmFyIHJlc3QgPSB0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdCk7XG4gICAgICBlbHRzLnB1c2gocmVzdCk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYyk7XG4gICAgICB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pO1xuICAgICAgZWx0cy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gIHJldHVybiBwYXJhbVxufTtcblxuLy8gUGFyc2VzIGFzc2lnbm1lbnQgcGF0dGVybiBhcm91bmQgZ2l2ZW4gYXRvbSBpZiBwb3NzaWJsZS5cblxucHAkMi5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuZWF0KHR5cGVzLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxufTtcblxuLy8gVmVyaWZ5IHRoYXQgYSBub2RlIGlzIGFuIGx2YWwg4oCUIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZFxuLy8gdG8uXG4vLyBiaW5kaW5nVHlwZSBjYW4gYmUgZWl0aGVyOlxuLy8gJ3ZhcicgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSAndmFyJyBiaW5kaW5nXG4vLyAnbGV0JyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhIGxleGljYWwgKCdsZXQnIG9yICdjb25zdCcpIGJpbmRpbmdcbi8vICdub25lJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGJpbmRpbmcgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIGlsbGVnYWwgaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGR1cGxpY2F0ZSByZWZlcmVuY2VzXG5cbnBwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICBpZiAoIGJpbmRpbmdUeXBlID09PSB2b2lkIDAgKSBiaW5kaW5nVHlwZSA9IEJJTkRfTk9ORTtcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMICYmIGV4cHIubmFtZSA9PT0gXCJsZXRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZyBcIiA6IFwiQXNzaWduaW5nIHRvIFwiKSArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgaWYgKGhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgIT09IEJJTkRfTk9ORSAmJiBiaW5kaW5nVHlwZSAhPT0gQklORF9PVVRTSURFKSB7IHRoaXMuZGVjbGFyZU5hbWUoZXhwci5uYW1lLCBiaW5kaW5nVHlwZSwgZXhwci5zdGFydCk7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tMVmFsKHByb3AsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIudmFsdWUsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IGV4cHIuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgaWYgKGVsZW0pIHsgdGhpcy5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIik7XG4gIH1cbn07XG5cbi8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG5cbnZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbi8vIE9iamVjdC9jbGFzcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFyZSBub3QgYWxsb3dlZCB0byBjbGFzaCDigJRcbi8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbi8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbnBwJDMuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB7IHJldHVybiB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0ga2V5LnN0YXJ0OyB9XG4gICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXQga2x1ZGdlLiBDYW4gYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMFxuICAgICAgICBlbHNlIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gICAgICB9XG4gICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICBpZiAob3RoZXIpIHtcbiAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgIH1cbiAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwJDMucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuLy8gb3BlcmF0b3JzIGxpa2UgYCs9YC5cblxucHAkMy5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHtcbiAgICBpZiAodGhpcy5pbkdlbmVyYXRvcikgeyByZXR1cm4gdGhpcy5wYXJzZVlpZWxkKG5vSW4pIH1cbiAgICAvLyBUaGUgdG9rZW5pemVyIHdpbGwgYXNzdW1lIGFuIGV4cHJlc3Npb24gaXMgYWxsb3dlZCBhZnRlclxuICAgIC8vIGB5aWVsZGAsIGJ1dCB0aGlzIGlzbid0IHRoYXQga2luZCBvZiB5aWVsZFxuICAgIGVsc2UgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgfVxuXG4gIHZhciBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gZmFsc2UsIG9sZFBhcmVuQXNzaWduID0gLTEsIG9sZFRyYWlsaW5nQ29tbWEgPSAtMSwgb2xkU2hvcnRoYW5kQXNzaWduID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICBvbGRTaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xO1xuICB9IGVsc2Uge1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycztcbiAgICBvd25EZXN0cnVjdHVyaW5nRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICB7IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7IH1cbiAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7IGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7IH1cbiAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgOiBsZWZ0O1xuICAgIGlmICghb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyBEZXN0cnVjdHVyaW5nRXJyb3JzLmNhbGwocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IC0xOyAvLyByZXNldCBiZWNhdXNlIHNob3J0aGFuZCBkZWZhdWx0IHdhcyB1c2VkIGNvcnJlY3RseVxuICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG93bkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgfVxuICBpZiAob2xkUGFyZW5Bc3NpZ24gPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBvbGRQYXJlbkFzc2lnbjsgfVxuICBpZiAob2xkVHJhaWxpbmdDb21tYSA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IG9sZFRyYWlsaW5nQ29tbWE7IH1cbiAgaWYgKG9sZFNob3J0aGFuZEFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gb2xkU2hvcnRoYW5kQXNzaWduOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbnBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICByZXR1cm4gZXhwci5zdGFydCA9PT0gc3RhcnRQb3MgJiYgZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPyBleHByIDogdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKVxufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKSB7XG4gIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wO1xuICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0aGlzLnR5cGUgIT09IHR5cGVzLl9pbikpIHtcbiAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgIHZhciBsb2dpY2FsID0gdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsT1IgfHwgdGhpcy50eXBlID09PSB0eXBlcy5sb2dpY2FsQU5EO1xuICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9Jbik7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuYnVpbGRCaW5hcnkobGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9JbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlZnRcbn07XG5cbnBwJDMuYnVpbGRCaW5hcnkgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQsIHJpZ2h0LCBvcCwgbG9naWNhbCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5vcGVyYXRvciA9IG9wO1xuICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLCBib3RoIHByZWZpeCBhbmQgcG9zdGZpeC5cblxucHAkMy5wYXJzZU1heWJlVW5hcnkgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBzYXdVbmFyeSkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGV4cHI7XG4gIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpICYmICh0aGlzLmluQXN5bmMgfHwgKCF0aGlzLmluRnVuY3Rpb24gJiYgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24pKSkge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoKTtcbiAgICBzYXdVbmFyeSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlLnByZWZpeCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5pbmNEZWM7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgZWxzZSBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIiAmJlxuICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgZWxzZSB7IHNhd1VuYXJ5ID0gdHJ1ZTsgfVxuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXJzdGFyKSlcbiAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gIGVsc2VcbiAgICB7IHJldHVybiBleHByIH1cbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHZhciBza2lwQXJyb3dTdWJzY3JpcHRzID0gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCI7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuaW5wdXQuc2xpY2UoYmFzZS5zdGFydCwgYmFzZS5lbmQpID09PSBcImFzeW5jXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KTtcbiAgICBpZiAoZWxlbWVudCA9PT0gYmFzZSB8fCBlbGVtZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikgeyByZXR1cm4gZWxlbWVudCB9XG4gICAgYmFzZSA9IGVsZW1lbnQ7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VTdWJzY3JpcHQgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIG1heWJlQXN5bmNBcnJvdykge1xuICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG4gIGlmIChjb21wdXRlZCB8fCB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgIG5vZGUucHJvcGVydHkgPSBjb21wdXRlZCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIik7XG4gICAgbm9kZS5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkKSB7IHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTsgfVxuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHZhciBleHByTGlzdCA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSAhPT0gXCJJbXBvcnRcIiwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgaWYgKHRoaXMuYXdhaXRJZGVudFBvcyA+IDApXG4gICAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0SWRlbnRQb3MsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdCwgdHJ1ZSlcbiAgICB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcyB8fCB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgaWYgKG5vZGUkMS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUkMS5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZSQxLnN0YXJ0LCBcImltcG9ydCgpIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1wb3J0QXJnID0gbm9kZSQxLmFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChpbXBvcnRBcmcgJiYgaW1wb3J0QXJnLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoaW1wb3J0QXJnLnN0YXJ0LCBcIi4uLiBpcyBub3QgYWxsb3dlZCBpbiBpbXBvcnQoKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlJDEsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGUpIHtcbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGJhc2Vcbn07XG5cbi8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3Jcbi8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuLy8gb3IgYHt9YC5cblxucHAkMy5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAvLyBJZiBhIGRpdmlzaW9uIG9wZXJhdG9yIGFwcGVhcnMgaW4gYW4gZXhwcmVzc2lvbiBwb3NpdGlvbiwgdGhlXG4gIC8vIHRva2VuaXplciBnb3QgY29uZnVzZWQsIGFuZCB3ZSBmb3JjZSBpdCB0byByZWFkIGEgcmVnZXhwIGluc3RlYWQuXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNsYXNoKSB7IHRoaXMucmVhZFJlZ2V4cCgpOyB9XG5cbiAgdmFyIG5vZGUsIGNhbkJlQXJyb3cgPSB0aGlzLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhcnQ7XG4gIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3N1cGVyJyBrZXl3b3JkIG91dHNpZGUgYSBtZXRob2RcIik7IH1cbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgIXRoaXMuYWxsb3dEaXJlY3RTdXBlcilcbiAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcInN1cGVyKCkgY2FsbCBvdXRzaWRlIGNvbnN0cnVjdG9yIG9mIGEgc3ViY2xhc3NcIik7IH1cbiAgICAvLyBUaGUgYHN1cGVyYCBrZXl3b3JkIGNhbiBhcHBlYXIgYXQgYmVsb3c6XG4gICAgLy8gU3VwZXJQcm9wZXJ0eTpcbiAgICAvLyAgICAgc3VwZXIgWyBFeHByZXNzaW9uIF1cbiAgICAvLyAgICAgc3VwZXIgLiBJZGVudGlmaWVyTmFtZVxuICAgIC8vIFN1cGVyQ2FsbDpcbiAgICAvLyAgICAgc3VwZXIgQXJndW1lbnRzXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuZG90ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2tldEwgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgY2FzZSB0eXBlcy5fdGhpczpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIilcblxuICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgMCwgZmFsc2UsIHRydWUpIH1cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIGZhbHNlKSB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiAhY29udGFpbnNFc2MpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRcblxuICBjYXNlIHR5cGVzLnJlZ2V4cDpcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSk7XG4gICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgIHJldHVybiBub2RlXG5cbiAgY2FzZSB0eXBlcy5udW06IGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKVxuXG4gIGNhc2UgdHlwZXMuX251bGw6IGNhc2UgdHlwZXMuX3RydWU6IGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3RydWU7XG4gICAgbm9kZS5yYXcgPSB0aGlzLnR5cGUua2V5d29yZDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsIGV4cHIgPSB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwICYmICF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIpKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHN0YXJ0OyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHN0YXJ0OyB9XG4gICAgfVxuICAgIHJldHVybiBleHByXG5cbiAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlFeHByZXNzaW9uXCIpXG5cbiAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCAwKVxuXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgY2FzZSB0eXBlcy5fbmV3OlxuICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkMy5wYXJzZUR5bmFtaWNJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5MKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKVxufTtcblxucHAkMy5wYXJzZUxpdGVyYWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbn07XG5cbnBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHJldHVybiB2YWxcbn07XG5cbnBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgLy8gRG8gbm90IHNhdmUgYXdhaXRJZGVudFBvcyB0byBhbGxvdyBjaGVja2luZyBhd2FpdHMgbmVzdGVkIGluIHBhcmFtZXRlcnNcbiAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5wYXJlblIpIHtcbiAgICAgIGZpcnN0ID8gZmlyc3QgPSBmYWxzZSA6IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgc3ByZWFkU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlubmVyRW5kUG9zID0gdGhpcy5zdGFydCwgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG5cbiAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpXG4gICAgfVxuXG4gICAgaWYgKCFleHByTGlzdC5sZW5ndGggfHwgbGFzdElzQ29tbWEpIHsgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KTsgfVxuICAgIGlmIChzcHJlYWRTdGFydCkgeyB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpOyB9XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMueWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG5cbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0UG9zLCBpbm5lclN0YXJ0TG9jKTtcbiAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgdGhpcy5maW5pc2hOb2RlQXQodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBpbm5lckVuZFBvcywgaW5uZXJFbmRMb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgcGFyLmV4cHJlc3Npb24gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXIsIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIHJldHVybiBpdGVtXG59O1xuXG5wcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QpXG59O1xuXG4vLyBOZXcncyBwcmVjZWRlbmNlIGlzIHNsaWdodGx5IHRyaWNreS4gSXQgbXVzdCBhbGxvdyBpdHMgYXJndW1lbnQgdG9cbi8vIGJlIGEgYFtdYCBvciBkb3Qgc3Vic2NyaXB0IGV4cHJlc3Npb24sIGJ1dCBub3QgYSBjYWxsIOKAlCBhdCBsZWFzdCxcbi8vIG5vdCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHBhcmVudGhlc2VzLiBUaHVzLCBpdCB1c2VzIHRoZSBub0NhbGxzXG4vLyBhcmd1bWVudCB0byBwYXJzZVN1YnNjcmlwdHMgdG8gcHJldmVudCBpdCBmcm9tIGNvbnN1bWluZyB0aGVcbi8vIGFyZ3VtZW50IGxpc3QuXG5cbnZhciBlbXB0eSQxID0gW107XG5cbnBwJDMucGFyc2VOZXcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiIHx8IGNvbnRhaW5zRXNjKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgbmV3LnRhcmdldFwiKTsgfVxuICAgIGlmICghdGhpcy5pbk5vbkFycm93RnVuY3Rpb24oKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwibmV3LnRhcmdldCBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9uc1wiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIilcbiAgfVxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPiAxMCAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLmNhbGxlZS5zdGFydCwgXCJDYW5ub3QgdXNlIG5ldyB3aXRoIGltcG9ydCguLi4pXCIpO1xuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgbm9kZS5jYWxsZWUudHlwZSAhPT0gXCJJbXBvcnRcIiwgZmFsc2UpOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbnBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgIH1cbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgY29va2VkOiBudWxsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbnBwJDMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVvZikgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRlbXBsYXRlTGl0ZXJhbFwiKVxufTtcblxucHAkMy5pc0FzeW5jUHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHByb3Aua2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJlxuICAgICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcy5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSkgJiZcbiAgICAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKVxufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBwcm9wSGFzaCA9IHt9O1xuICBub2RlLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5uZXh0KCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICghaXNQYXR0ZXJuKSB7IHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpOyB9XG4gICAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1BhdHRlcm4gPyBcIk9iamVjdFBhdHRlcm5cIiA6IFwiT2JqZWN0RXhwcmVzc2lvblwiKVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBwcm9wID0gdGhpcy5zdGFydE5vZGUoKSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYztcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKVxuICAgIH1cbiAgICAvLyBUbyBkaXNhbGxvdyBwYXJlbnRoZXNpemVkIGlkZW50aWZpZXIgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFyc2UgYXJndW1lbnQuXG4gICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgLy8gVG8gZGlzYWxsb3cgdHJhaWxpbmcgY29tbWEgdmlhIGB0aGlzLnRvQXNzaWduYWJsZSgpYC5cbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApIHtcbiAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIC8vIEZpbmlzaFxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm4gfHwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIH1cbiAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgIHsgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTsgfVxuICB9XG4gIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgfSBlbHNlIHtcbiAgICBpc0FzeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gIGlmICgoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb2xvbilcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCkge1xuICAgIGlmIChpc1BhdHRlcm4pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9IGVsc2UgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmXG4gICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICh0aGlzLnR5cGUgIT09IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gcHJvcC5rZXkubmFtZTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICB2YXIgcGFyYW1Db3VudCA9IHByb3Aua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGlmIChwcm9wLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IHN0YXJ0UG9zOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVxICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0OyB9XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC52YWx1ZSA9IHByb3Aua2V5O1xuICAgIH1cbiAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gIH0gZWxzZSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcC5rZXkgPSB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSBcIm5ldmVyXCIpXG59O1xuXG4vLyBJbml0aWFsaXplIGVtcHR5IGZ1bmN0aW9uIG5vZGUuXG5cbnBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLmlkID0gbnVsbDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IG5vZGUuZ2VuZXJhdG9yID0gbm9kZS5leHByZXNzaW9uID0gZmFsc2U7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxufTtcblxuLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxucHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd0RpcmVjdFN1cGVyKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpIHwgU0NPUEVfU1VQRVIgfCAoYWxsb3dEaXJlY3RTdXBlciA/IFNDT1BFX0RJUkVDVF9TVVBFUiA6IDApKTtcblxuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIHRydWUpO1xuXG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxucHAkMy5wYXJzZUFycm93RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYykge1xuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpIHwgU0NPUEVfQVJST1cpO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBmYWxzZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxucHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QpIHtcbiAgdmFyIGlzRXhwcmVzc2lvbiA9IGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlTDtcbiAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0LCB1c2VTdHJpY3QgPSBmYWxzZTtcblxuICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9uU2ltcGxlID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpO1xuICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgdXNlU3RyaWN0ID0gdGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5lbmQpO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgICAgLy8gYXJlIG5vdCByZXBlYXRlZCwgYW5kIGl0IGRvZXMgbm90IHRyeSB0byBiaW5kIHRoZSB3b3JkcyBgZXZhbGBcbiAgICAgIC8vIG9yIGBhcmd1bWVudHNgLlxuICAgICAgaWYgKHVzZVN0cmljdCAmJiBub25TaW1wbGUpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgIH1cbiAgICAvLyBTdGFydCBhIG5ldyBzY29wZSB3aXRoIHJlZ2FyZCB0byBsYWJlbHMgYW5kIHRoZSBgaW5GdW5jdGlvbmBcbiAgICAvLyBmbGFnIChyZXN0b3JlIHRoZW0gdG8gdGhlaXIgb2xkIHZhbHVlIGFmdGVyd2FyZHMpLlxuICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAvLyBBZGQgdGhlIHBhcmFtcyB0byB2YXJEZWNsYXJlZE5hbWVzIHRvIGVuc3VyZSB0aGF0IGFuIGVycm9yIGlzIHRocm93blxuICAgIC8vIGlmIGEgbGV0L2NvbnN0IGRlY2xhcmF0aW9uIGluIHRoZSBmdW5jdGlvbiBjbGFzaGVzIHdpdGggb25lIG9mIHRoZSBwYXJhbXMuXG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCAhb2xkU3RyaWN0ICYmICF1c2VTdHJpY3QgJiYgIWlzQXJyb3dGdW5jdGlvbiAmJiAhaXNNZXRob2QgJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgfVxuICB0aGlzLmV4aXRTY29wZSgpO1xuXG4gIC8vIEVuc3VyZSB0aGUgZnVuY3Rpb24gbmFtZSBpc24ndCBhIGZvcmJpZGRlbiBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLCBlLmcuICdldmFsJ1xuICBpZiAodGhpcy5zdHJpY3QgJiYgbm9kZS5pZCkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBCSU5EX09VVFNJREUpOyB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xufTtcblxucHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbi8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG5wcCQzLmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBuYW1lSGFzaCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBCSU5EX1ZBUiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbi8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4vLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4vLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbi8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbnBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgZWx0ID0gKHZvaWQgMCk7XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSlcbiAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VTcHJlYWQocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIH1cbiAgICBlbHRzLnB1c2goZWx0KTtcbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkMy5jaGVja1VucmVzZXJ2ZWQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIHN0YXJ0ID0gcmVmLnN0YXJ0O1xuICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgdmFyIG5hbWUgPSByZWYubmFtZTtcblxuICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiBuYW1lID09PSBcInlpZWxkXCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgdmFyIHJlID0gdGhpcy5zdHJpY3QgPyB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgOiB0aGlzLnJlc2VydmVkV29yZHM7XG4gIGlmIChyZS50ZXN0KG5hbWUpKSB7XG4gICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlcy81NzVcbiAgICAvLyBgY2xhc3NgIGFuZCBgZnVuY3Rpb25gIGtleXdvcmRzIHB1c2ggbmV3IGNvbnRleHQgaW50byB0aGlzLmNvbnRleHQuXG4gICAgLy8gQnV0IHRoZXJlIGlzIG5vIGNoYW5jZSB0byBwb3AgdGhlIGNvbnRleHQgaWYgdGhlIGtleXdvcmQgaXMgY29uc3VtZWQgYXMgYW4gaWRlbnRpZmllciBzdWNoIGFzIGEgcHJvcGVydHkgbmFtZS5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgYSBkb3QsIHRoaXMgZG9lcyBub3QgYXBwbHkgYmVjYXVzZSB0aGUgY29udGV4dC1tYW5hZ2luZyBjb2RlIGFscmVhZHkgaWdub3JlZCB0aGUga2V5d29yZFxuICAgIGlmICgobm9kZS5uYW1lID09PSBcImNsYXNzXCIgfHwgbm9kZS5uYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIGlmICghbGliZXJhbCkge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiAhdGhpcy5hd2FpdElkZW50UG9zKVxuICAgICAgeyB0aGlzLmF3YWl0SWRlbnRQb3MgPSBub2RlLnN0YXJ0OyB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIFBhcnNlcyB5aWVsZCBleHByZXNzaW9uIGluc2lkZSBnZW5lcmF0b3IuXG5cbnBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKG5vSW4pIHtcbiAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0YXIgJiYgIXRoaXMudHlwZS5zdGFydHNFeHByKSkge1xuICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG52YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICB0aHJvdyBlcnJcbn07XG5cbnBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbnBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgfVxufTtcblxudmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgU2NvcGUgPSBmdW5jdGlvbiBTY29wZShmbGFncykge1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIC8vIEEgbGlzdCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLnZhciA9IFtdO1xuICAvLyBBIGxpc3Qgb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy5sZXhpY2FsID0gW107XG4gIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMuZnVuY3Rpb25zID0gW107XG59O1xuXG4vLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbnBwJDUuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBTY29wZShmbGFncykpO1xufTtcblxucHAkNS5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xufTtcblxuLy8gVGhlIHNwZWMgc2F5czpcbi8vID4gQXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZ1bmN0aW9uLCBvciBzY3JpcHQsIGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmVcbi8vID4gdHJlYXRlZCBsaWtlIHZhciBkZWNsYXJhdGlvbnMgcmF0aGVyIHRoYW4gbGlrZSBsZXhpY2FsIGRlY2xhcmF0aW9ucy5cbnBwJDUudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUgPSBmdW5jdGlvbihzY29wZSkge1xuICByZXR1cm4gKHNjb3BlLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pIHx8ICF0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUClcbn07XG5cbnBwJDUuZGVjbGFyZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5nVHlwZSwgcG9zKSB7XG4gIHZhciByZWRlY2xhcmVkID0gZmFsc2U7XG4gIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICByZWRlY2xhcmVkID0gc2NvcGUubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS52YXIuaW5kZXhPZihuYW1lKSA+IC0xO1xuICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApKVxuICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgdmFyIHNjb3BlJDEgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHNjb3BlJDEubGV4aWNhbC5wdXNoKG5hbWUpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgdmFyIHNjb3BlJDIgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmICh0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIpXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWRlY2xhcmVkID0gc2NvcGUkMi5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZSQyLnZhci5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKHNjb3BlJDMubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgJiYgISgoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1NJTVBMRV9DQVRDSCkgJiYgc2NvcGUkMy5sZXhpY2FsWzBdID09PSBuYW1lKSB8fFxuICAgICAgICAgICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlJDMpICYmIHNjb3BlJDMuZnVuY3Rpb25zLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbn07XG5cbnBwJDUuY2hlY2tMb2NhbEV4cG9ydCA9IGZ1bmN0aW9uKGlkKSB7XG4gIC8vIHNjb3BlLmZ1bmN0aW9ucyBtdXN0IGJlIGVtcHR5IGFzIE1vZHVsZSBjb2RlIGlzIGFsd2F5cyBzdHJpY3QuXG4gIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgdGhpcy5zY29wZVN0YWNrWzBdLnZhci5pbmRleE9mKGlkLm5hbWUpID09PSAtMSkge1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tpZC5uYW1lXSA9IGlkO1xuICB9XG59O1xuXG5wcCQ1LmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxufTtcblxucHAkNS5jdXJyZW50VmFyU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgIGlmIChzY29wZS5mbGFncyAmIFNDT1BFX1ZBUikgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG4vLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGB0aGlzYCwgYG5ldy50YXJnZXRgLCBgc3VwZXIoKWAsIGBzdXBlci5wcm9wZXJ0eWAsIGFuZCBgc3VwZXJbcHJvcGVydHldYC5cbnBwJDUuY3VycmVudFRoaXNTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSICYmICEoc2NvcGUuZmxhZ3MgJiBTQ09QRV9BUlJPVykpIHsgcmV0dXJuIHNjb3BlIH1cbiAgfVxufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgdGhpcy50eXBlID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IHBvcztcbiAgdGhpcy5lbmQgPSAwO1xuICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG59O1xuXG4vLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG52YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQ2LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbi8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB0aGlzLmlzRXhwciA9ICEhaXNFeHByO1xuICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbiAgdGhpcy5nZW5lcmF0b3IgPSAhIWdlbmVyYXRvcjtcbn07XG5cbnZhciB0eXBlcyQxID0ge1xuICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICBiX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiJHtcIiwgZmFsc2UpLFxuICBwX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCBmYWxzZSksXG4gIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50cnlSZWFkVGVtcGxhdGVUb2tlbigpOyB9KSxcbiAgZl9zdGF0OiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlKSxcbiAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICBmX2V4cHJfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUsIGZhbHNlLCBudWxsLCB0cnVlKSxcbiAgZl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UsIGZhbHNlLCBudWxsLCB0cnVlKVxufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ3LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG59O1xuXG5wcCQ3LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLmV4cHJBbGxvd2VkKVxuICAgIHsgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9lbHNlIHx8IHByZXZUeXBlID09PSB0eXBlcy5zZW1pIHx8IHByZXZUeXBlID09PSB0eXBlcy5lb2YgfHwgcHJldlR5cGUgPT09IHR5cGVzLnBhcmVuUiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYXJyb3cpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKVxuICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl92YXIgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiAhdGhpcy5leHByQWxsb3dlZFxufTtcblxucHAkNy5pbkdlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxOyBpID49IDE7IGktLSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgIGlmIChjb250ZXh0LnRva2VuID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICB7IHJldHVybiBjb250ZXh0LmdlbmVyYXRvciB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5wcCQ3LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgdXBkYXRlLCB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09PSB0eXBlcy5kb3QpXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbn07XG5cbi8vIFRva2VuLXNwZWNpZmljIGNvbnRleHQgdXBkYXRlIGNvZGVcblxudHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzJDEuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBvdXQgPSB0aGlzLmNvbnRleHQucG9wKCk7XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xufTtcblxudHlwZXMuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcyQxLmJfc3RhdCA6IHR5cGVzJDEuYl9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmJfdG1wbCk7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR5cGVzLl9pZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3dpdGggfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aGlsZTtcbiAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wX3N0YXQgOiB0eXBlcyQxLnBfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgLy8gdG9rRXhwckFsbG93ZWQgc3RheXMgdW5jaGFuZ2VkXG59O1xuXG50eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlLmJlZm9yZUV4cHIgJiYgcHJldlR5cGUgIT09IHR5cGVzLnNlbWkgJiYgcHJldlR5cGUgIT09IHR5cGVzLl9lbHNlICYmXG4gICAgICAhKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuICYmIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpICYmXG4gICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYl9zdGF0KSlcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9leHByKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfc3RhdCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLnFfdG1wbClcbiAgICB7IHRoaXMuY29udGV4dC5wb3AoKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLnFfdG1wbCk7IH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxudHlwZXMuc3Rhci51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZnVuY3Rpb24pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICBpZiAodGhpcy5jb250ZXh0W2luZGV4XSA9PT0gdHlwZXMkMS5mX2V4cHIpXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZXhwcl9nZW47IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dFtpbmRleF0gPSB0eXBlcyQxLmZfZ2VuOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5uYW1lLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgYWxsb3dlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgcHJldlR5cGUgIT09IHR5cGVzLmRvdCkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBcIm9mXCIgJiYgIXRoaXMuZXhwckFsbG93ZWQgfHxcbiAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgVW5pY29kZSBwcm9wZXJ0aWVzIGV4dHJhY3RlZCBmcm9tIHRoZSBFQ01BU2NyaXB0XG4vLyBzcGVjaWZpY2F0aW9uLiBUaGUgbGlzdHMgYXJlIGV4dHJhY3RlZCBsaWtlIHNvOlxuLy8gJCQoJyN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzID4gZmlndXJlID4gdGFibGUgPiB0Ym9keSA+IHRyID4gdGQ6bnRoLWNoaWxkKDEpIGNvZGUnKS5tYXAoZWwgPT4gZWwuaW5uZXJUZXh0KVxuXG4vLyAjdGFibGUtYmluYXJ5LXVuaWNvZGUtcHJvcGVydGllc1xudmFyIGVjbWE5QmluYXJ5UHJvcGVydGllcyA9IFwiQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTXCI7XG52YXIgZWNtYTEwQmluYXJ5UHJvcGVydGllcyA9IGVjbWE5QmluYXJ5UHJvcGVydGllcyArIFwiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpY1wiO1xudmFyIGVjbWExMUJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzO1xudmFyIHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzID0ge1xuICA5OiBlY21hOUJpbmFyeVByb3BlcnRpZXMsXG4gIDEwOiBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzLFxuICAxMTogZWNtYTExQmluYXJ5UHJvcGVydGllc1xufTtcblxuLy8gI3RhYmxlLXVuaWNvZGUtZ2VuZXJhbC1jYXRlZ29yeS12YWx1ZXNcbnZhciB1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzID0gXCJDYXNlZF9MZXR0ZXIgTEMgQ2xvc2VfUHVuY3R1YXRpb24gUGUgQ29ubmVjdG9yX1B1bmN0dWF0aW9uIFBjIENvbnRyb2wgQ2MgY250cmwgQ3VycmVuY3lfU3ltYm9sIFNjIERhc2hfUHVuY3R1YXRpb24gUGQgRGVjaW1hbF9OdW1iZXIgTmQgZGlnaXQgRW5jbG9zaW5nX01hcmsgTWUgRmluYWxfUHVuY3R1YXRpb24gUGYgRm9ybWF0IENmIEluaXRpYWxfUHVuY3R1YXRpb24gUGkgTGV0dGVyIEwgTGV0dGVyX051bWJlciBObCBMaW5lX1NlcGFyYXRvciBabCBMb3dlcmNhc2VfTGV0dGVyIExsIE1hcmsgTSBDb21iaW5pbmdfTWFyayBNYXRoX1N5bWJvbCBTbSBNb2RpZmllcl9MZXR0ZXIgTG0gTW9kaWZpZXJfU3ltYm9sIFNrIE5vbnNwYWNpbmdfTWFyayBNbiBOdW1iZXIgTiBPcGVuX1B1bmN0dWF0aW9uIFBzIE90aGVyIEMgT3RoZXJfTGV0dGVyIExvIE90aGVyX051bWJlciBObyBPdGhlcl9QdW5jdHVhdGlvbiBQbyBPdGhlcl9TeW1ib2wgU28gUGFyYWdyYXBoX1NlcGFyYXRvciBacCBQcml2YXRlX1VzZSBDbyBQdW5jdHVhdGlvbiBQIHB1bmN0IFNlcGFyYXRvciBaIFNwYWNlX1NlcGFyYXRvciBacyBTcGFjaW5nX01hcmsgTWMgU3Vycm9nYXRlIENzIFN5bWJvbCBTIFRpdGxlY2FzZV9MZXR0ZXIgTHQgVW5hc3NpZ25lZCBDbiBVcHBlcmNhc2VfTGV0dGVyIEx1XCI7XG5cbi8vICN0YWJsZS11bmljb2RlLXNjcmlwdC12YWx1ZXNcbnZhciBlY21hOVNjcmlwdFZhbHVlcyA9IFwiQWRsYW0gQWRsbSBBaG9tIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9kaSBNb25nb2xpYW4gTW9uZyBNcm8gTXJvbyBNdWx0YW5pIE11bHQgTXlhbm1hciBNeW1yIE5hYmF0YWVhbiBOYmF0IE5ld19UYWlfTHVlIFRhbHUgTmV3YSBOZXdhIE5rbyBOa29vIE51c2h1IE5zaHUgT2doYW0gT2dhbSBPbF9DaGlraSBPbGNrIE9sZF9IdW5nYXJpYW4gSHVuZyBPbGRfSXRhbGljIEl0YWwgT2xkX05vcnRoX0FyYWJpYW4gTmFyYiBPbGRfUGVybWljIFBlcm0gT2xkX1BlcnNpYW4gWHBlbyBPbGRfU291dGhfQXJhYmlhbiBTYXJiIE9sZF9UdXJraWMgT3JraCBPcml5YSBPcnlhIE9zYWdlIE9zZ2UgT3NtYW55YSBPc21hIFBhaGF3aF9IbW9uZyBIbW5nIFBhbG15cmVuZSBQYWxtIFBhdV9DaW5fSGF1IFBhdWMgUGhhZ3NfUGEgUGhhZyBQaG9lbmljaWFuIFBobnggUHNhbHRlcl9QYWhsYXZpIFBobHAgUmVqYW5nIFJqbmcgUnVuaWMgUnVuciBTYW1hcml0YW4gU2FtciBTYXVyYXNodHJhIFNhdXIgU2hhcmFkYSBTaHJkIFNoYXZpYW4gU2hhdyBTaWRkaGFtIFNpZGQgU2lnbldyaXRpbmcgU2dudyBTaW5oYWxhIFNpbmggU29yYV9Tb21wZW5nIFNvcmEgU295b21ibyBTb3lvIFN1bmRhbmVzZSBTdW5kIFN5bG90aV9OYWdyaSBTeWxvIFN5cmlhYyBTeXJjIFRhZ2Fsb2cgVGdsZyBUYWdiYW53YSBUYWdiIFRhaV9MZSBUYWxlIFRhaV9UaGFtIExhbmEgVGFpX1ZpZXQgVGF2dCBUYWtyaSBUYWtyIFRhbWlsIFRhbWwgVGFuZ3V0IFRhbmcgVGVsdWd1IFRlbHUgVGhhYW5hIFRoYWEgVGhhaSBUaGFpIFRpYmV0YW4gVGlidCBUaWZpbmFnaCBUZm5nIFRpcmh1dGEgVGlyaCBVZ2FyaXRpYyBVZ2FyIFZhaSBWYWlpIFdhcmFuZ19DaXRpIFdhcmEgWWkgWWlpaSBaYW5hYmF6YXJfU3F1YXJlIFphbmJcIjtcbnZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG52YXIgZWNtYTExU2NyaXB0VmFsdWVzID0gZWNtYTEwU2NyaXB0VmFsdWVzICsgXCIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvXCI7XG52YXIgdW5pY29kZVNjcmlwdFZhbHVlcyA9IHtcbiAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gIDEwOiBlY21hMTBTY3JpcHRWYWx1ZXMsXG4gIDExOiBlY21hMTFTY3JpcHRWYWx1ZXNcbn07XG5cbnZhciBkYXRhID0ge307XG5mdW5jdGlvbiBidWlsZFVuaWNvZGVEYXRhKGVjbWFWZXJzaW9uKSB7XG4gIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgYmluYXJ5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlQmluYXJ5UHJvcGVydGllc1tlY21hVmVyc2lvbl0gKyBcIiBcIiArIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMpLFxuICAgIG5vbkJpbmFyeToge1xuICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBTY3JpcHQ6IHdvcmRzUmVnZXhwKHVuaWNvZGVTY3JpcHRWYWx1ZXNbZWNtYVZlcnNpb25dKVxuICAgIH1cbiAgfTtcbiAgZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnMgPSBkLm5vbkJpbmFyeS5TY3JpcHQ7XG5cbiAgZC5ub25CaW5hcnkuZ2MgPSBkLm5vbkJpbmFyeS5HZW5lcmFsX0NhdGVnb3J5O1xuICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgZC5ub25CaW5hcnkuc2N4ID0gZC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnM7XG59XG5idWlsZFVuaWNvZGVEYXRhKDkpO1xuYnVpbGRVbmljb2RlRGF0YSgxMCk7XG5idWlsZFVuaWNvZGVEYXRhKDExKTtcblxudmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gIHRoaXMudW5pY29kZVByb3BlcnRpZXMgPSBkYXRhW3BhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExID8gMTEgOiBwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbl07XG4gIHRoaXMuc291cmNlID0gXCJcIjtcbiAgdGhpcy5mbGFncyA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG59O1xuXG4vLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgcmV0dXJuIGNcbiAgfVxuICB2YXIgbmV4dCA9IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIHJldHVybiBuZXh0ID49IDB4REMwMCAmJiBuZXh0IDw9IDB4REZGRiA/IChjIDw8IDEwKSArIG5leHQgLSAweDM1RkRDMDAgOiBjXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSkge1xuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKSwgbmV4dDtcbiAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCB8fFxuICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgcmV0dXJuIGkgKyAxXG4gIH1cbiAgcmV0dXJuIGkgKyAyXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmxvb2thaGVhZCA9IGZ1bmN0aW9uIGxvb2thaGVhZCAoKSB7XG4gIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zKSlcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2UgKCkge1xuICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zKTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gZWF0IChjaCkge1xuICBpZiAodGhpcy5jdXJyZW50KCkgPT09IGNoKSB7XG4gICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNoKSB7XG4gIGlmIChjaCA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpIH1cbiAgY2ggLT0gMHgxMDAwMDtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNoID4+IDEwKSArIDB4RDgwMCwgKGNoICYgMHgwM0ZGKSArIDB4REMwMClcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgZmxhZ3MgcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkOC52YWxpZGF0ZVJlZ0V4cEZsYWdzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICB2YXIgZmxhZ3MgPSBzdGF0ZS5mbGFncztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgaWYgKHZhbGlkRmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhdGUuc3RhcnQsIFwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgcGF0dGVybiBwYXJ0IG9mIGEgZ2l2ZW4gUmVnRXhwTGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cFZhbGlkYXRpb25TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIHZhbGlkYXRlIFJlZ0V4cC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5wcCQ4LnZhbGlkYXRlUmVnRXhwUGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIFRoZSBnb2FsIHN5bWJvbCBmb3IgdGhlIHBhcnNlIGlzIHxQYXR0ZXJuW35VLCB+Tl18LiBJZiB0aGUgcmVzdWx0IG9mXG4gIC8vIHBhcnNpbmcgY29udGFpbnMgYSB8R3JvdXBOYW1lfCwgcmVwYXJzZSB3aXRoIHRoZSBnb2FsIHN5bWJvbFxuICAvLyB8UGF0dGVyblt+VSwgK05dfCBhbmQgdXNlIHRoaXMgcmVzdWx0IGluc3RlYWQuIFRocm93IGEgKlN5bnRheEVycm9yKlxuICAvLyBleGNlcHRpb24gaWYgX1BfIGRpZCBub3QgY29uZm9ybSB0byB0aGUgZ3JhbW1hciwgaWYgYW55IGVsZW1lbnRzIG9mIF9QX1xuICAvLyB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoZSBwYXJzZSwgb3IgaWYgYW55IEVhcmx5IEVycm9yIGNvbmRpdGlvbnMgZXhpc3QuXG4gIGlmICghc3RhdGUuc3dpdGNoTiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICBzdGF0ZS5zd2l0Y2hOID0gdHJ1ZTtcbiAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVyblxucHAkOC5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLnBvcyA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPSAwO1xuICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoID0gMDtcblxuICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgaWYgKHN0YXRlLnBvcyAhPT0gc3RhdGUuc291cmNlLmxlbmd0aCkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZXMgYXMgVjguXG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg1RCAvKiBbICovKSB8fCBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHNcIik7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID4gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURpc2p1bmN0aW9uXG5wcCQ4LnJlZ2V4cF9kaXNqdW5jdGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgd2hpbGUgKHN0YXRlLmVhdCgweDdDIC8qIHwgKi8pKSB7XG4gICAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICB9XG5cbiAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICB9XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BbHRlcm5hdGl2ZVxucHAkOC5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAoc3RhdGUucG9zIDwgc3RhdGUuc291cmNlLmxlbmd0aCAmJiB0aGlzLnJlZ2V4cF9lYXRUZXJtKHN0YXRlKSlcbiAgICB7IH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1UZXJtXG5wcCQ4LnJlZ2V4cF9lYXRUZXJtID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAvLyBIYW5kbGUgYFF1YW50aWZpYWJsZUFzc2VydGlvbiBRdWFudGlmaWVyYCBhbHRlcm5hdGl2ZS5cbiAgICAvLyBgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlYCBpcyB0cnVlIGlmIHRoZSBsYXN0IGVhdGVuIEFzc2VydGlvblxuICAgIC8vIGlzIGEgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uLlxuICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBxdWFudGlmaWVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgPyB0aGlzLnJlZ2V4cF9lYXRBdG9tKHN0YXRlKSA6IHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShzdGF0ZSkpIHtcbiAgICB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXNzZXJ0aW9uXG5wcCQ4LnJlZ2V4cF9lYXRBc3NlcnRpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gIC8vIF4sICRcbiAgaWYgKHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pIHx8IHN0YXRlLmVhdCgweDI0IC8qICQgKi8pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFxcYiBcXEJcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHg0MiAvKiBCICovKSB8fCBzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICAvLyBMb29rYWhlYWQgLyBMb29rYmVoaW5kXG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSAmJiBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIHZhciBsb29rYmVoaW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgLyogPCAqLyk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSB8fCBzdGF0ZS5lYXQoMHgyMSAvKiAhICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9ICFsb29rYmVoaW5kO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyXG5wcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgaWYgKCBub0Vycm9yID09PSB2b2lkIDAgKSBub0Vycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoc3RhdGUsIG5vRXJyb3IpKSB7XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLyk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJQcmVmaXhcbnBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJBIC8qICogKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4MkIgLyogKyAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIG5vRXJyb3IpXG4gIClcbn07XG5wcCQ4LnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICBtaW4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgLyogLCAqLykgJiYgdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWF4ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICAgIC8vIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtdGVybVxuICAgICAgICBpZiAobWF4ICE9PSAtMSAmJiBtYXggPCBtaW4gJiYgIW5vRXJyb3IpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgIW5vRXJyb3IpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW5jb21wbGV0ZSBxdWFudGlmaWVyXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUF0b21cbnBwJDgucmVnZXhwX2VhdEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzKHN0YXRlKSB8fFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpXG4gIClcbn07XG5wcCQ4LnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSAmJiBzdGF0ZS5lYXQoMHgzQSAvKiA6ICovKSkge1xuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2dyb3VwU3BlY2lmaWVyKHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiAvKiA/ICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyArPSAxO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRBdG9tXG5wcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gKFxuICAgIHN0YXRlLmVhdCgweDJFIC8qIC4gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItSW52YWxpZEJyYWNlZFF1YW50aWZpZXJcbnBwJDgucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVN5bnRheENoYXJhY3RlclxucHAkOC5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHgyNCAvKiAkICovIHx8XG4gICAgY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLyB8fFxuICAgIGNoID09PSAweDJFIC8qIC4gKi8gfHxcbiAgICBjaCA9PT0gMHgzRiAvKiA/ICovIHx8XG4gICAgY2ggPj0gMHg1QiAvKiBbICovICYmIGNoIDw9IDB4NUUgLyogXiAqLyB8fFxuICAgIGNoID49IDB4N0IgLyogeyAqLyAmJiBjaCA8PSAweDdEIC8qIH0gKi9cbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuQ2hhcmFjdGVyXG4vLyBCdXQgZWF0IGVhZ2VyLlxucHAkOC5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpICE9PSAtMSAmJiAhaXNTeW50YXhDaGFyYWN0ZXIoY2gpKSB7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItRXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyXG5wcCQ4LnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChcbiAgICBjaCAhPT0gLTEgJiZcbiAgICBjaCAhPT0gMHgyNCAvKiAkICovICYmXG4gICAgIShjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovKSAmJlxuICAgIGNoICE9PSAweDJFIC8qIC4gKi8gJiZcbiAgICBjaCAhPT0gMHgzRiAvKiA/ICovICYmXG4gICAgY2ggIT09IDB4NUIgLyogWyAqLyAmJlxuICAgIGNoICE9PSAweDVFIC8qIF4gKi8gJiZcbiAgICBjaCAhPT0gMHg3QyAvKiB8ICovXG4gICkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gR3JvdXBTcGVjaWZpZXJbVV0gOjpcbi8vICAgW2VtcHR5XVxuLy8gICBgP2AgR3JvdXBOYW1lWz9VXVxucHAkOC5yZWdleHBfZ3JvdXBTcGVjaWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gIH1cbn07XG5cbi8vIEdyb3VwTmFtZVtVXSA6OlxuLy8gICBgPGAgUmVnRXhwSWRlbnRpZmllck5hbWVbP1VdIGA+YFxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQ4LnJlZ2V4cF9lYXRHcm91cE5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAoc3RhdGUuZWF0KDB4M0MgLyogPCAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNFIC8qID4gKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gUmVnRXhwSWRlbnRpZmllck5hbWVbVV0gOjpcbi8vICAgUmVnRXhwSWRlbnRpZmllclN0YXJ0Wz9VXVxuLy8gICBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gUmVnRXhwSWRlbnRpZmllclBhcnRbP1VdXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChzdGF0ZSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJTdGFydFtVXSA6OlxuLy8gICBVbmljb2RlSURTdGFydFxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWz9VXVxucHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIHN0YXRlLmFkdmFuY2UoKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0W1VdIDo6XG4vLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbP1VdXG4vLyAgIDxaV05KPlxuLy8gICA8WldKPlxucHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXRvbUVzY2FwZVxucHAkOC5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzIC8qIGMgKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gRm9yIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtYXRvbWVzY2FwZVxuICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxucHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgKVxufTtcbnBwJDgucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwIC8qIDAgKi8gJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IC8qIFxcdCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2RSAvKiBuICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDc2IC8qIHYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyAvKiBcXHYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IC8qIFxcZiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3MiAvKiByICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG5wcCQ4LnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4N0EgLyogeiAqLylcbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1SZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbnBwJDgucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pICYmIHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RGlnaXRzKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgIGRvIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChcbiAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAoY2ggPT09IDB4NTAgLyogUCAqLyB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICApIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgaWYgKFxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgY2ggPT09IDB4NDQgLyogRCAqLyB8fFxuICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgY2ggPT09IDB4NzcgLyogdyAqLyB8fFxuICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgKVxufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbi8vICAgTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG5wcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlKSkge1xuICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWhhcyhzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnksIG5hbWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbiAgaWYgKCFzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbbmFtZV0udGVzdCh2YWx1ZSkpXG4gICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgdmFsdWVcIik7IH1cbn07XG5wcCQ4LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWVPclZhbHVlKSB7XG4gIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QobmFtZU9yVmFsdWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7IH1cbn07XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbnBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzQ29udHJvbExldHRlcihjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2gpIHtcbiAgcmV0dXJuIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpXG59XG5cbi8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA6OlxuLy8gICBVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcnNcbnBwJDgucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSlcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzXG5wcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg1QiAvKiBbICovKSkge1xuICAgIHN0YXRlLmVhdCgweDVFIC8qIF4gKi8pO1xuICAgIHRoaXMucmVnZXhwX2NsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogWyAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIFVucmVhY2hhYmxlIHNpbmNlIGl0IHRocmV3IFwidW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiIGVycm9yIGJlZm9yZS5cbiAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtTm9uZW1wdHlDbGFzc1Jhbmdlc05vRGFzaFxucHAkOC5yZWdleHBfY2xhc3NSYW5nZXMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgIHZhciBsZWZ0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyRCAvKiAtICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbnBwJDgucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKGNoJDEgPT09IDB4NjMgLyogYyAqLyB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NUQgLyogWyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NFc2NhcGVcbnBwJDgucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG5wcCQ4LnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQ4LnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xucHAkOC5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbnBwJDgucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICApXG59XG5mdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgfVxuICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgfVxuICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Vcbi8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxucHAkOC5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG5wcCQ4LnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQ4LnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgdGhpcy50eXBlID0gcC50eXBlO1xuICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gIHRoaXMuZW5kID0gcC5lbmQ7XG4gIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbn07XG5cbi8vICMjIFRva2VuaXplclxuXG52YXIgcHAkOSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxucHAkOS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAkOS5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxufTtcblxuLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICB7IHBwJDlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxucHAkOS5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG4vLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbi8vIHByb3BlcnRpZXMuXG5cbnBwJDkubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVvZikgfVxuXG4gIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbn07XG5cbnBwJDkucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLylcbiAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbn07XG5cbnBwJDkuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAkOS5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gIHRoaXMucG9zID0gZW5kICsgMjtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgIHRoaXMubGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudCh0cnVlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbnBwJDkuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICs9IHN0YXJ0U2tpcCk7XG4gIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoICYmICFpc05ld0xpbmUoY2gpKSB7XG4gICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgeyB0aGlzLm9wdGlvbnMub25Db21tZW50KGZhbHNlLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCB0aGlzLnBvcyksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4vLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG5wcCQ5LnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkge1xuICBsb29wOiB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMzI6IGNhc2UgMTYwOiAvLyAnICdcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgY2FzZSAxMDogY2FzZSA4MjMyOiBjYXNlIDgyMzM6XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSkge1xuICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgIHRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4vLyBtYWludGFpbnMgYGNvbnRleHRgIGFuZCBgZXhwckFsbG93ZWRgLCBhbmQgc2tpcHMgdGhlIHNwYWNlIGFmdGVyXG4vLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuLy8gcmlnaHQgcG9zaXRpb24uXG5cbnBwJDkuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsO1xuXG4gIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG59O1xuXG4vLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4vLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbi8vIGlzIHNvbWV3aGF0IG9ic2N1cmUsIGJlY2F1c2UgaXQgd29ya3MgaW4gY2hhcmFjdGVyIGNvZGVzIHJhdGhlclxuLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbi8vIGludG8gaXQuXG4vL1xuLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuLy9cbnBwJDkucmVhZFRva2VuX2RvdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7IHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSkgfVxuICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0NikgeyAvLyA0NiA9IGRvdCAnLidcbiAgICB0aGlzLnBvcyArPSAzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVsbGlwc2lzKVxuICB9IGVsc2Uge1xuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KVxuICB9XG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9zbGFzaCA9IGZ1bmN0aW9uKCkgeyAvLyAnLydcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKHRoaXMuZXhwckFsbG93ZWQpIHsgKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMucmVhZFJlZ2V4cCgpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5zbGFzaCwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzLnN0YXIgOiB0eXBlcy5tb2R1bG87XG5cbiAgLy8gZXhwb25lbnRpYXRpb24gb3BlcmF0b3IgKiogYW5kICoqPVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICArK3NpemU7XG4gICAgdG9rZW50eXBlID0gdHlwZXMuc3RhcnN0YXI7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxufTtcblxucHAkOS5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMubG9naWNhbE9SIDogdHlwZXMubG9naWNhbEFORCwgMikgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmJpdHdpc2VPUiA6IHR5cGVzLmJpdHdpc2VBTkQsIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyAvLyAnXidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxufTtcblxucHAkOS5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgPT09IDAgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpKSB7XG4gICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuaW5jRGVjLCAyKVxuICB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPD4nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIHZhciBzaXplID0gMTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBzaXplID0gY29kZSA9PT0gNjIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyID8gMyA6IDI7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0U2hpZnQsIHNpemUpXG4gIH1cbiAgaWYgKG5leHQgPT09IDMzICYmIGNvZGUgPT09IDYwICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA0NSAmJlxuICAgICAgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMykgPT09IDQ1KSB7XG4gICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbn07XG5cbnBwJDkucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcy5lcSA6IHR5cGVzLnByZWZpeCwgMSlcbn07XG5cbnBwJDkuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gIC8vIFRoZSBpbnRlcnByZXRhdGlvbiBvZiBhIGRvdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgZm9sbG93ZWRcbiAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICBjYXNlIDQ2OiAvLyAnLidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KClcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuTClcbiAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKVxuICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zZW1pKVxuICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb21tYSlcbiAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpXG4gIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRSKVxuICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKVxuICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VSKVxuICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb2xvbilcbiAgY2FzZSA2MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pXG5cbiAgY2FzZSA5NjogLy8gJ2AnXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuXG4gIGNhc2UgNDg6IC8vICcwJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgfVxuXG4gIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOiBjYXNlIDU0OiBjYXNlIDU1OiBjYXNlIDU2OiBjYXNlIDU3OiAvLyAxLTlcbiAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gIC8vIFF1b3RlcyBwcm9kdWNlIHN0cmluZ3MuXG4gIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG4gIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAvLyBjaGFyYWN0ZXJzIGl0IGlzIGdpdmVuIGFzIHNlY29uZCBhcmd1bWVudCwgYW5kIHJldHVybnMgYSB0b2tlblxuICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgY2FzZSA0NzogLy8gJy8nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICBjYXNlIDM3OiBjYXNlIDQyOiAvLyAnJSonXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgY2FzZSA5NDogLy8gJ14nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICBjYXNlIDQzOiBjYXNlIDQ1OiAvLyAnKy0nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gIGNhc2UgMTI2OiAvLyAnfidcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wcmVmaXgsIDEpXG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkgKyBcIidcIik7XG59O1xuXG5wcCQ5LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBzaXplKTtcbiAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKVxufTtcblxucHAkOS5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMucG9zO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICArK3RoaXMucG9zO1xuICB2YXIgZmxhZ3NTdGFydCA9IHRoaXMucG9zO1xuICB2YXIgZmxhZ3MgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAvLyBWYWxpZGF0ZSBwYXR0ZXJuXG4gIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgc3RhdGUucmVzZXQoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cEZsYWdzKHN0YXRlKTtcbiAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gIC8vIENyZWF0ZSBMaXRlcmFsI3ZhbHVlIHByb3BlcnR5IHZhbHVlLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICB0cnkge1xuICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFU1RyZWUgcmVxdWlyZXMgbnVsbCBpZiBpdCBmYWlsZWQgdG8gaW5zdGFudGlhdGUgUmVnRXhwIG9iamVjdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL2EyNzAwM2FkZjRmZDdiZmFkNDRkZTljZWYzNzJhMmVhY2Q1MjdiMWMvZXM1Lm1kI3JlZ2V4cGxpdGVyYWxcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnJlZ2V4cCwge3BhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncywgdmFsdWU6IHZhbHVlfSlcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4vLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbnBwJDkucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIHRvdGFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCB2YWwgPSAodm9pZCAwKTtcbiAgICBpZiAoY29kZSA+PSA5NykgeyB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgfSAvLyBhXG4gICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgeyB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgfSAvLyBBXG4gICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSAvLyAwLTlcbiAgICBlbHNlIHsgdmFsID0gSW5maW5pdHk7IH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgfVxuICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgcmV0dXJuIHRvdGFsXG59O1xuXG5wcCQ5LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTEwKSB7XG4gICAgdmFsID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpIDogbnVsbDtcbiAgICArK3RoaXMucG9zO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG5wcCQ5LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIHZhciBvY3RhbCA9IHRoaXMucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgaWYgKG9jdGFsICYmIHRoaXMuc3RyaWN0KSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgaWYgKG9jdGFsICYmIC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKSkpIHsgb2N0YWwgPSBmYWxzZTsgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIGlmICghb2N0YWwgJiYgIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIG5leHQgPT09IDExMCkge1xuICAgIHZhciBzdHIkMSA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICB2YXIgdmFsJDEgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiID8gQmlnSW50KHN0ciQxKSA6IG51bGw7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwkMSlcbiAgfVxuICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICsrdGhpcy5wb3M7XG4gICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgfVxuICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IC8vICdlRSdcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IC8vICcrLSdcbiAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIH1cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gIHZhciB2YWwgPSBvY3RhbCA/IHBhcnNlSW50KHN0ciwgOCkgOiBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhIHN0cmluZyB2YWx1ZSwgaW50ZXJwcmV0aW5nIGJhY2tzbGFzaC1lc2NhcGVzLlxuXG5wcCQ5LnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgfVxuICByZXR1cm4gY29kZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjb2RlKSB7XG4gIC8vIFVURi0xNiBEZWNvZGluZ1xuICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICBjb2RlIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbn1cblxucHAkOS5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMCkpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG4gIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dClcbn07XG5cbi8vIFJlYWRzIHRlbXBsYXRlIHN0cmluZyB0b2tlbnMuXG5cbnZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG5wcCQ5LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICB0cnkge1xuICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xufTtcblxucHAkOS5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gIH1cbn07XG5cbnBwJDkucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMjMpIHsgLy8gJ2AnLCAnJHsnXG4gICAgICBpZiAodGhpcy5wb3MgPT09IHRoaXMuc3RhcnQgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMudGVtcGxhdGUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvbGxhckJyYWNlTClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIG91dClcbiAgICB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIodHJ1ZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH1cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG5wcCQ5LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgIHN3aXRjaCAodGhpcy5pbnB1dFt0aGlzLnBvc10pIHtcbiAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiJFwiOlxuICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAvLyBmYWxscyB0aHJvdWdoXG5cbiAgICBjYXNlIFwiYFwiOlxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKSlcblxuICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH1cbiAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxucHAkOS5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgc3dpdGNoIChjaCkge1xuICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nJDEodGhpcy5yZWFkQ29kZVBvaW50KCkpIC8vICd1J1xuICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gIGNhc2UgOTg6IHJldHVybiBcIlxcYlwiIC8vICdiJyAtPiAnXFxiJ1xuICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIC8vICd2JyAtPiAnXFx1MDAwYidcbiAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICBjYXNlIDEzOiBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfSAvLyAnXFxyXFxuJ1xuICBjYXNlIDEwOiAvLyAnIFxcbidcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zOyArK3RoaXMuY3VyTGluZTsgfVxuICAgIHJldHVybiBcIlwiXG4gIGRlZmF1bHQ6XG4gICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmICgob2N0YWxTdHIgIT09IFwiMFwiIHx8IGNoID09PSA1NiB8fCBjaCA9PT0gNTcpICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICB0aGlzLnBvcyAtIDEgLSBvY3RhbFN0ci5sZW5ndGgsXG4gICAgICAgICAgaW5UZW1wbGF0ZVxuICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgIDogXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKVxuICAgIH1cbiAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgLy8gVW5pY29kZSBuZXcgbGluZSBjaGFyYWN0ZXJzIGFmdGVyIFxcIGdldCByZW1vdmVkIGZyb20gb3V0cHV0IGluIGJvdGhcbiAgICAgIC8vIHRlbXBsYXRlIGxpdGVyYWxzIGFuZCBzdHJpbmdzXG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgfVxufTtcblxuLy8gVXNlZCB0byByZWFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VzICgnXFx4JywgJ1xcdScsICdcXFUnKS5cblxucHAkOS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICB2YXIgY29kZVBvcyA9IHRoaXMucG9zO1xuICB2YXIgbiA9IHRoaXMucmVhZEludCgxNiwgbGVuKTtcbiAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICByZXR1cm4gblxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyLCBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLiBTZXRzIGB0aGlzLmNvbnRhaW5zRXNjYFxuLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4vL1xuLy8gSW5jcmVtZW50YWxseSBhZGRzIG9ubHkgZXNjYXBlZCBjaGFycywgYWRkaW5nIG90aGVyIGNodW5rcyBhcy1pc1xuLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbnBwJDkucmVhZFdvcmQxID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgdmFyIHdvcmQgPSBcIlwiLCBmaXJzdCA9IHRydWUsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIGFzdHJhbCA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgIHZhciBjaCA9IHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gOTIpIHsgLy8gXCJcXFwiXG4gICAgICB0aGlzLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICB2YXIgZXNjU3RhcnQgPSB0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykgIT09IDExNykgLy8gXCJ1XCJcbiAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdmFyIGVzYyA9IHRoaXMucmVhZENvZGVQb2ludCgpO1xuICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoZXNjKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbi8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG5wcCQ5LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgdmFyIHR5cGUgPSB0eXBlcy5uYW1lO1xuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB3b3JkKTsgfVxuICAgIHR5cGUgPSBrZXl3b3JkcyQxW3dvcmRdO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG59O1xuXG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuXG52YXIgdmVyc2lvbiA9IFwiNi40LjBcIjtcblxuUGFyc2VyLmFjb3JuID0ge1xuICBQYXJzZXI6IFBhcnNlcixcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgZGVmYXVsdE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICBQb3NpdGlvbjogUG9zaXRpb24sXG4gIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgZ2V0TGluZUluZm86IGdldExpbmVJbmZvLFxuICBOb2RlOiBOb2RlLFxuICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgdG9rVHlwZXM6IHR5cGVzLFxuICBrZXl3b3JkVHlwZXM6IGtleXdvcmRzJDEsXG4gIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gIHRva0NvbnRleHRzOiB0eXBlcyQxLFxuICBpc0lkZW50aWZpZXJDaGFyOiBpc0lkZW50aWZpZXJDaGFyLFxuICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gIFRva2VuOiBUb2tlbixcbiAgaXNOZXdMaW5lOiBpc05ld0xpbmUsXG4gIGxpbmVCcmVhazogbGluZUJyZWFrLFxuICBsaW5lQnJlYWtHOiBsaW5lQnJlYWtHLFxuICBub25BU0NJSXdoaXRlc3BhY2U6IG5vbkFTQ0lJd2hpdGVzcGFjZVxufTtcblxuLy8gVGhlIG1haW4gZXhwb3J0ZWQgaW50ZXJmYWNlICh1bmRlciBgc2VsZi5hY29ybmAgd2hlbiBpbiB0aGVcbi8vIGJyb3dzZXIpIGlzIGEgYHBhcnNlYCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgY29kZSBzdHJpbmcgYW5kXG4vLyByZXR1cm5zIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIGFzIHNwZWNpZmllZCBieSBbTW96aWxsYSBwYXJzZXJcbi8vIEFQSV1bYXBpXS5cbi8vXG4vLyBbYXBpXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVxuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnBhcnNlKGlucHV0LCBvcHRpb25zKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGEgc2luZ2xlIGV4cHJlc3Npb24gYXQgYSBnaXZlblxuLy8gb2Zmc2V0IGluIGEgc3RyaW5nLiBVc2VmdWwgZm9yIHBhcnNpbmcgbWl4ZWQtbGFuZ3VhZ2UgZm9ybWF0c1xuLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25BdChpbnB1dCwgcG9zLCBvcHRpb25zKSB7XG4gIHJldHVybiBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucylcbn1cblxuLy8gQWNvcm4gaXMgb3JnYW5pemVkIGFzIGEgdG9rZW5pemVyIGFuZCBhIHJlY3Vyc2l2ZS1kZXNjZW50IHBhcnNlci5cbi8vIFRoZSBgdG9rZW5pemVyYCBleHBvcnQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIHRoZSB0b2tlbml6ZXIuXG5cbmZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnRva2VuaXplcihpbnB1dCwgb3B0aW9ucylcbn1cblxuZXhwb3J0IHsgTm9kZSwgUGFyc2VyLCBQb3NpdGlvbiwgU291cmNlTG9jYXRpb24sIFRva0NvbnRleHQsIFRva2VuLCBUb2tlblR5cGUsIGRlZmF1bHRPcHRpb25zLCBnZXRMaW5lSW5mbywgaXNJZGVudGlmaWVyQ2hhciwgaXNJZGVudGlmaWVyU3RhcnQsIGlzTmV3TGluZSwga2V5d29yZHMkMSBhcyBrZXl3b3JkVHlwZXMsIGxpbmVCcmVhaywgbGluZUJyZWFrRywgbm9uQVNDSUl3aGl0ZXNwYWNlLCBwYXJzZSwgcGFyc2VFeHByZXNzaW9uQXQsIHR5cGVzJDEgYXMgdG9rQ29udGV4dHMsIHR5cGVzIGFzIHRva1R5cGVzLCB0b2tlbml6ZXIsIHZlcnNpb24gfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBN0ZBO0FBaUdBO0FBQ0E7O0FBQ0E7O0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxGQTtBQUNBOzs7QUFzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFGQTtBQUdBO0FBSEE7QUFJQTtBQUpBO0FBS0E7QUFMQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBN0RBO0FBOERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXJFQTtBQXVFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckRBO0FBdURBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUZBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpHQTtBQW1HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBOztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUVBO0FBRkE7QUFHQTtBQUhBO0FBSUE7QUFBQTtBQUFBO0FBSkE7QUFLQTtBQUFBO0FBQUE7QUFOQTtBQVFBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBSUE7QUFKQTtBQUtBO0FBTEE7QUFNQTtBQU5BO0FBT0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSEE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUZBO0FBR0E7QUFIQTtBQUlBO0FBSkE7QUFLQTtBQU5BO0FBUUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFIQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBUEE7QUFTQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBQ0E7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFrQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFuRUE7QUFDQTtBQXFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFkQTtBQWdCQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBdENBO0FBd0NBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tern/node_modules/acorn/dist/acorn.mjs\n");

/***/ }),

/***/ "./node_modules/tern/plugin/doc_comment.js":
/*!*************************************************!*\
  !*** ./node_modules/tern/plugin/doc_comment.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Parses comments above variable declarations, function declarations,\n// and object properties as docstrings and JSDoc-style type\n// annotations.\n\n(function(mod) {\n  if (true) // CommonJS\n    return mod(__webpack_require__(/*! ../lib/infer */ \"./node_modules/tern/lib/infer.js\"), __webpack_require__(/*! ../lib/tern */ \"./node_modules/tern/lib/tern.js\"), __webpack_require__(/*! ../lib/comment */ \"./node_modules/tern/lib/comment.js\"),\n               __webpack_require__(/*! acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.mjs\"), __webpack_require__(/*! acorn-walk */ \"./node_modules/tern/node_modules/acorn-walk/dist/walk.mjs\"));\n  if (true) // AMD\n    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../lib/infer */ \"./node_modules/tern/lib/infer.js\"), __webpack_require__(/*! ../lib/tern */ \"./node_modules/tern/lib/tern.js\"), __webpack_require__(/*! ../lib/comment */ \"./node_modules/tern/lib/comment.js\"), __webpack_require__(/*! acorn/dist/acorn */ \"./node_modules/tern/node_modules/acorn/dist/acorn.js\"), __webpack_require__(/*! acorn-walk/dist/walk */ \"./node_modules/tern/node_modules/acorn-walk/dist/walk.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  mod(tern, tern, tern.comment, acorn, acorn.walk);\n})(function(infer, tern, comment, acorn, walk) {\n  \"use strict\";\n\n  var WG_MADEUP = 1, WG_STRONG = 101;\n\n  tern.registerPlugin(\"doc_comment\", function(server, options) {\n    server.mod.jsdocTypedefs = Object.create(null);\n    server.on(\"reset\", function() {\n      server.mod.jsdocTypedefs = Object.create(null);\n    });\n    server.mod.docComment = {\n      weight: options && options.strong ? WG_STRONG : undefined,\n      fullDocs: options && options.fullDocs\n    };\n\n    server.on(\"postParse\", postParse);\n    server.on(\"postInfer\", postInfer);\n    server.on(\"postLoadDef\", postLoadDef);\n  });\n\n  function postParse(ast, text) {\n    function attachComments(node) { comment.ensureCommentsBefore(text, node); }\n\n    walk.simple(ast, {\n      VariableDeclaration: attachComments,\n      FunctionDeclaration: attachComments,\n      MethodDefinition: attachComments,\n      Property: attachComments,\n      AssignmentExpression: function(node) {\n        if (node.operator == \"=\") attachComments(node);\n      },\n      CallExpression: function(node) {\n        if (isDefinePropertyCall(node)) attachComments(node);\n      },\n      ExportNamedDeclaration: attachComments,\n      ExportDefaultDeclaration: attachComments,\n      ClassDeclaration: attachComments\n    });\n  }\n\n  function isDefinePropertyCall(node) {\n    return node.callee.type == \"MemberExpression\" &&\n      node.callee.object.name == \"Object\" &&\n      node.callee.property.name == \"defineProperty\" &&\n      node.arguments.length >= 3 &&\n      typeof node.arguments[1].value == \"string\";\n  }\n\n  function postInfer(ast, scope) {\n    jsdocParseTypedefs(ast.sourceFile.text, scope);\n\n    walk.simple(ast, {\n      VariableDeclaration: function(node, scope) {\n        var decl = node.declarations[0].id;\n        if (node.commentsBefore && decl.type == \"Identifier\")\n          interpretComments(node, node.commentsBefore, scope,\n                            scope.getProp(node.declarations[0].id.name));\n      },\n      FunctionDeclaration: function(node, scope) {\n        if (node.commentsBefore)\n          interpretComments(node, node.commentsBefore, scope,\n                            scope.getProp(node.id.name),\n                            node.scope.fnType);\n      },\n      ClassDeclaration: function(node, scope) {\n        if (node.commentsBefore)\n          interpretComments(node, node.commentsBefore, scope,\n                            scope.getProp(node.id.name),\n                            node.objType);\n      },\n      AssignmentExpression: function(node, scope) {\n        if (node.commentsBefore)\n          interpretComments(node, node.commentsBefore, scope,\n                            infer.expressionType({node: node.left, state: scope}));\n      },\n      ObjectExpression: function(node, scope) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var prop = node.properties[i];\n          if (prop.type == 'SpreadElement') { continue; }\n          var name = infer.propName(prop);\n          if (name != \"<i>\" && prop.commentsBefore)\n            interpretComments(prop, prop.commentsBefore, scope, node.objType.getProp(name));\n        }\n      },\n      Class: function(node, scope) {\n        if (!node.objType) return;\n        var proto = node.objType.getProp(\"prototype\").getObjType();\n        if (!proto) return;\n        for (var i = 0; i < node.body.body.length; i++) {\n          var method = node.body.body[i], name;\n          if (!method.commentsBefore) continue;\n          if (method.kind == \"constructor\")\n            interpretComments(method, method.commentsBefore, scope, node.objType);\n          else if ((name = infer.propName(method)) != \"<i>\")\n            interpretComments(method, method.commentsBefore, scope, proto.getProp(name));\n        }\n      },\n      CallExpression: function(node, scope) {\n        if (node.commentsBefore && isDefinePropertyCall(node)) {\n          var type = infer.expressionType({node: node.arguments[0], state: scope}).getObjType();\n          if (type && type instanceof infer.Obj) {\n            var prop = type.props[node.arguments[1].value];\n            if (prop) interpretComments(node, node.commentsBefore, scope, prop);\n          }\n        }\n      },\n      ExportNamedDeclaration: function(node, scope) {\n        if (node.commentsBefore && node.declaration && node.declaration.type === 'FunctionDeclaration') {\n          interpretComments(node.declaration, node.commentsBefore, scope,\n                            scope.getProp(node.declaration.id.name),\n                            node.declaration.scope.fnType);\n        }\n      },\n      ExportDefaultDeclaration: function(node, scope) {\n        if (node.commentsBefore && node.declaration && node.declaration.type === 'FunctionDeclaration') {\n          interpretComments(node.declaration, node.commentsBefore, scope,\n                            scope.getProp(node.declaration.id.name),\n                            node.declaration.scope.fnType);\n        }\n      }\n    }, infer.searchVisitor, scope);\n  }\n\n  function postLoadDef(data) {\n    var defs = data[\"!typedef\"];\n    var cx = infer.cx(), orig = data[\"!name\"];\n    if (defs) for (var name in defs)\n      cx.parent.mod.jsdocTypedefs[name] =\n        maybeInstance(infer.def.parse(defs[name], orig, name), name);\n  }\n\n  // COMMENT INTERPRETATION\n\n  function stripLeadingChars(lines) {\n    for (var head, i = 1; i < lines.length; i++) {\n      var line = lines[i], lineHead = line.match(/^[\\s\\*]*/)[0];\n      if (lineHead != line) {\n        if (head == null) {\n          head = lineHead;\n        } else {\n          var same = 0;\n          while (same < head.length && head.charCodeAt(same) == lineHead.charCodeAt(same)) ++same;\n          if (same < head.length) head = head.slice(0, same);\n        }\n      }\n    }\n    lines = lines.map(function(line, i) {\n      line = line.replace(/\\s+$/, \"\");\n      if (i == 0 && head != null) {\n        for (var j = 0; j < head.length; j++) {\n          var found = line.indexOf(head.slice(j));\n          if (found == 0) return line.slice(head.length - j);\n        }\n      }\n      if (head == null || i == 0) return line.replace(/^[\\s\\*]*/, \"\");\n      if (line.length < head.length) return \"\";\n      return line.slice(head.length);\n    });\n    while (lines.length && !lines[lines.length - 1]) lines.pop();\n    while (lines.length && !lines[0]) lines.shift();\n    return lines;\n  }\n\n  function interpretComments(node, comments, scope, aval, type) {\n    jsdocInterpretComments(node, scope, aval, comments);\n    var cx = infer.cx();\n\n    if (!type && aval instanceof infer.AVal && aval.types.length) {\n      type = aval.types[aval.types.length - 1];\n      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)\n        type = null;\n    }\n\n    for (var i = comments.length - 1; i >= 0; i--) {\n      var text = stripLeadingChars(comments[i].split(/\\r\\n?|\\n/)).join(\"\\n\");\n      if (text) {\n        if (aval instanceof infer.AVal) aval.doc = text;\n        if (type) type.doc = text;\n        break;\n      }\n    }\n  }\n\n  // Parses a subset of JSDoc-style comments in order to include the\n  // explicitly defined types in the analysis.\n\n  function skipSpace(str, pos) {\n    while (/\\s/.test(str.charAt(pos))) ++pos;\n    return pos;\n  }\n\n  function isIdentifier(string) {\n    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;\n    for (var i = 1; i < string.length; i++)\n      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;\n    return true;\n  }\n\n  function parseLabelList(scope, str, pos, close) {\n    var labels = [], types = [], madeUp = false;\n    for (var first = true; ; first = false) {\n      pos = skipSpace(str, pos);\n      if (first && str.charAt(pos) == close) break;\n      var colon = str.indexOf(\":\", pos);\n      if (colon < 0) return null;\n      var label = str.slice(pos, colon);\n      if (!isIdentifier(label)) return null;\n      labels.push(label);\n      pos = colon + 1;\n      var type = parseType(scope, str, pos);\n      if (!type) return null;\n      pos = type.end;\n      madeUp = madeUp || type.madeUp;\n      types.push(type.type);\n      pos = skipSpace(str, pos);\n      var next = str.charAt(pos);\n      ++pos;\n      if (next == close) break;\n      if (next != \",\") return null;\n    }\n    return {labels: labels, types: types, end: pos, madeUp: madeUp};\n  }\n\n  function parseTypeAtom(scope, str, pos) {\n    var result = parseTypeInner(scope, str, pos);\n    if (!result) return null;\n    if (str.slice(result.end, result.end + 2) == \"[]\")\n      return {madeUp: result.madeUp, end: result.end + 2, type: new infer.Arr(result.type)};\n    else return result;\n  }\n\n  function parseType(scope, str, pos) {\n    var type, union = false, madeUp = false;\n    for (;;) {\n      var inner = parseTypeAtom(scope, str, pos);\n      if (!inner) return null;\n      madeUp = madeUp || inner.madeUp;\n      if (union) inner.type.propagate(union);\n      else type = inner.type;\n      pos = skipSpace(str, inner.end);\n      if (str.charAt(pos) != \"|\") break;\n      pos++;\n      if (!union) {\n        union = new infer.AVal;\n        type.propagate(union);\n        type = union;\n      }\n    }\n    var isOptional = false;\n    if (str.charAt(pos) == \"=\") {\n      ++pos;\n      isOptional = true;\n    }\n    return {type: type, end: pos, isOptional: isOptional, madeUp: madeUp};\n  }\n\n  function parseTypeInner(scope, str, pos) {\n    pos = skipSpace(str, pos);\n    if (/[?!]/.test(str.charAt(pos))) pos++;\n    var type, madeUp = false;\n\n    if (str.indexOf(\"function(\", pos) == pos) {\n      var args = parseLabelList(scope, str, pos + 9, \")\"), ret = infer.ANull;\n      if (!args) return null;\n      pos = skipSpace(str, args.end);\n      if (str.charAt(pos) == \":\") {\n        ++pos;\n        var retType = parseType(scope, str, pos + 1);\n        if (!retType) return null;\n        pos = retType.end;\n        ret = retType.type;\n        madeUp = retType.madeUp;\n      }\n      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);\n    } else if (str.charAt(pos) == \"[\") {\n      var inner = parseType(scope, str, pos + 1);\n      if (!inner) return null;\n      pos = skipSpace(str, inner.end);\n      madeUp = inner.madeUp;\n      if (str.charAt(pos) != \"]\") return null;\n      ++pos;\n      type = new infer.Arr(inner.type);\n    } else if (str.charAt(pos) == \"{\") {\n      var fields = parseLabelList(scope, str, pos + 1, \"}\");\n      if (!fields) return null;\n      type = new infer.Obj(true);\n      for (var i = 0; i < fields.types.length; ++i) {\n        var field = type.defProp(fields.labels[i]);\n        field.initializer = true;\n        fields.types[i].propagate(field);\n      }\n      pos = fields.end;\n      madeUp = fields.madeUp;\n    } else if (str.charAt(pos) == \"(\") {\n      var inner = parseType(scope, str, pos + 1);\n      if (!inner) return null;\n      pos = skipSpace(str, inner.end);\n      if (str.charAt(pos) != \")\") return null;\n      ++pos;\n      type = inner.type;\n    } else {\n      var start = pos;\n      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;\n      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;\n      if (start == pos) return null;\n      var word = str.slice(start, pos);\n      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;\n      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;\n      else if (/^string$/i.test(word)) type = infer.cx().str;\n      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;\n      else if (/^array$/i.test(word)) {\n        var inner = null;\n        if (str.charAt(pos) == \".\" && str.charAt(pos + 1) == \"<\") {\n          var inAngles = parseType(scope, str, pos + 2);\n          if (!inAngles) return null;\n          pos = skipSpace(str, inAngles.end);\n          madeUp = inAngles.madeUp;\n          if (str.charAt(pos++) != \">\") return null;\n          inner = inAngles.type;\n        }\n        type = new infer.Arr(inner);\n      } else if (/^object$/i.test(word)) {\n        type = new infer.Obj(true);\n        if (str.charAt(pos) == \".\" && str.charAt(pos + 1) == \"<\") {\n          var key = parseType(scope, str, pos + 2);\n          if (!key) return null;\n          pos = skipSpace(str, key.end);\n          if (str.charAt(pos++) != \",\") return null;\n          var val = parseType(scope, str, pos);\n          if (!val) return null;\n          pos = skipSpace(str, val.end);\n          madeUp = key.madeUp || val.madeUp;\n          if (str.charAt(pos++) != \">\") return null;\n          val.type.propagate(type.defProp(\"<i>\"));\n        }\n      } else {\n        while (str.charCodeAt(pos) == 46 ||\n               acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;\n        var path = str.slice(start, pos);\n        var cx = infer.cx(), defs = cx.parent && cx.parent.mod.jsdocTypedefs, found;\n        if (defs && (path in defs)) {\n          type = defs[path];\n        } else if (found = infer.def.parsePath(path, scope).getObjType()) {\n          type = maybeInstance(found, path);\n        } else {\n          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);\n          if (!(path in cx.jsdocPlaceholders))\n            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);\n          else\n            type = cx.jsdocPlaceholders[path];\n          madeUp = true;\n        }\n      }\n    }\n\n    return {type: type, end: pos, madeUp: madeUp};\n  }\n\n  function maybeInstance(type, path) {\n    if (type instanceof infer.Fn && /(?:^|\\.)[A-Z][^\\.]*$/.test(path)) {\n      var proto = type.getProp(\"prototype\").getObjType();\n      if (proto instanceof infer.Obj) return infer.getInstance(proto);\n    }\n    return type;\n  }\n\n  function parseTypeOuter(scope, str, pos) {\n    pos = skipSpace(str, pos || 0);\n    if (str.charAt(pos) != \"{\") return null;\n    var result = parseType(scope, str, pos + 1);\n    if (!result) return null;\n    var end = skipSpace(str, result.end);\n    if (str.charAt(end) != \"}\") return null;\n    result.end = end + 1;\n    return result;\n  }\n\n  function jsdocInterpretComments(node, scope, aval, comments) {\n    var type, args, ret, foundOne, self, parsed;\n\n    for (var i = 0; i < comments.length; ++i) {\n      var comment = comments[i];\n      var decl = /(?:\\n|\\*)\\s*@(type|param|arg(?:ument)?|returns?|this|class|constructor)(?:\\s*?\\n|\\s+(.*))/g, m;\n      while (m = decl.exec(comment)) {\n        if (m[1] == \"class\" || m[1] == \"constructor\") {\n          self = foundOne = true;\n          continue;\n        }\n\n        if (m[2] === undefined) continue; // to avoid tags that require a type argument.\n\n        if (m[1] == \"this\" && (parsed = parseType(scope, m[2], 0))) {\n          self = parsed;\n          foundOne = true;\n          continue;\n        }\n\n        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;\n        foundOne = true;\n\n        switch(m[1]) {\n        case \"returns\": case \"return\":\n          ret = parsed; break;\n        case \"type\":\n          type = parsed; break;\n        case \"param\": case \"arg\": case \"argument\":\n            // Possible jsdoc param name situations:\n            // employee\n            // [employee]\n            // [employee=John Doe]\n            // employee.name\n            // employees[].name\n            var name = m[2].slice(parsed.end).match(/^\\s*(\\[?)\\s*([^\\[\\]\\s=]+(\\[\\][^\\[\\]\\s=]+)?)\\s*(?:=[^\\]]+\\s*)?(\\]?).*/);\n            if (!name) continue;\n            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[4] === ']') ? \"?\" : \"\");\n\n            // Check to see if the jsdoc is indicating a property of a previously documented parameter\n            var isObjProp = false;\n            var parts = argname.split('.');\n            if (args && parts.length == 2) {\n              var objname = parts[0];\n              argname = parts[1];\n\n              // Go through each of the previously found parameter to find the\n              // object or array for which this new parameter should be a part\n              // of\n              var key, value;\n              for (key in args) {\n                value = args[key];\n\n                if (key === objname && value.type instanceof infer.Obj) {\n                  isObjProp = true;\n                  parsed.type.propagate(value.type.defProp(argname));\n                }\n                else if (key + '[]' === objname && value.type instanceof infer.Arr) {\n                  isObjProp = true;\n                  parsed.type.propagate(value.type.getProp(\"<i>\").getType().defProp(argname));\n                }\n              }\n            }\n            if (!isObjProp) {\n              (args || (args = Object.create(null)))[argname] = parsed;\n            }\n          break;\n        }\n      }\n    }\n\n    if (foundOne) applyType(type, self, args, ret, node, aval);\n  }\n\n  function jsdocParseTypedefs(text, scope) {\n    var cx = infer.cx();\n\n    var re = /\\s@typedef\\s+(.*)/g, m;\n    while (m = re.exec(text)) {\n      var parsed = parseTypeOuter(scope, m[1]);\n      var name = parsed && m[1].slice(parsed.end).match(/^\\s*(\\S+)/);\n      if (name && parsed.type instanceof infer.Obj) {\n        var rest = text.slice(m.index + m[0].length);\n        while (m = /\\s+@prop(?:erty)?\\s+(.*)/.exec(rest)) {\n          var propType = parseTypeOuter(scope, m[1]), propName;\n          if (propType && (propName = m[1].slice(propType.end).match(/^\\s*(\\S+)/)))\n            propType.type.propagate(parsed.type.defProp(propName[1]));\n          rest = rest.slice(m[0].length);\n        }\n        cx.parent.mod.jsdocTypedefs[name[1]] = parsed.type;\n      }\n    }\n  }\n\n  function propagateWithWeight(type, target) {\n    var weight = infer.cx().parent.mod.docComment.weight;\n    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));\n  }\n\n  function isFunExpr(node) { return node.type == \"FunctionExpression\" || node.type == \"ArrowFunctionExpression\" }\n\n  function applyType(type, self, args, ret, node, aval) {\n    var fn;\n    if (node.type == \"VariableDeclaration\") {\n      var decl = node.declarations[0];\n      if (decl.init && isFunExpr(decl.init)) fn = decl.init.scope.fnType;\n    } else if (node.type == \"FunctionDeclaration\") {\n      fn = node.scope.fnType;\n    } else if (node.type == \"AssignmentExpression\") {\n      if (isFunExpr(node.right))\n        fn = node.right.scope.fnType;\n    } else if (node.type == \"CallExpression\" || node.type === \"ClassDeclaration\") {\n    } else { // An object property\n      if (isFunExpr(node.value)) fn = node.value.scope.fnType;\n    }\n\n    if (fn && (args || ret || self)) {\n      if (args) for (var i = 0; i < fn.argNames.length; ++i) {\n        var name = fn.argNames[i], known = args[name];\n        if (!known && (known = args[name + \"?\"]))\n          fn.argNames[i] += \"?\";\n        if (known) propagateWithWeight(known, fn.args[i]);\n      }\n      if (ret) {\n        if (fn.retval == infer.ANull) fn.retval = new infer.AVal;\n        propagateWithWeight(ret, fn.retval);\n      }\n      if (self === true) {\n        var proto = fn.getProp(\"prototype\").getObjType();\n        self = proto && {type: infer.getInstance(proto, fn)};\n      }\n      if (self) propagateWithWeight(self, fn.self);\n    } else if (type) {\n      propagateWithWeight(type, aval);\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVybi9wbHVnaW4vZG9jX2NvbW1lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVybi9wbHVnaW4vZG9jX2NvbW1lbnQuanM/ZmQzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQYXJzZXMgY29tbWVudHMgYWJvdmUgdmFyaWFibGUgZGVjbGFyYXRpb25zLCBmdW5jdGlvbiBkZWNsYXJhdGlvbnMsXG4vLyBhbmQgb2JqZWN0IHByb3BlcnRpZXMgYXMgZG9jc3RyaW5ncyBhbmQgSlNEb2Mtc3R5bGUgdHlwZVxuLy8gYW5ub3RhdGlvbnMuXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIHJldHVybiBtb2QocmVxdWlyZShcIi4uL2xpYi9pbmZlclwiKSwgcmVxdWlyZShcIi4uL2xpYi90ZXJuXCIpLCByZXF1aXJlKFwiLi4vbGliL2NvbW1lbnRcIiksXG4gICAgICAgICAgICAgICByZXF1aXJlKFwiYWNvcm5cIiksIHJlcXVpcmUoXCJhY29ybi13YWxrXCIpKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIHJldHVybiBkZWZpbmUoW1wiLi4vbGliL2luZmVyXCIsIFwiLi4vbGliL3Rlcm5cIiwgXCIuLi9saWIvY29tbWVudFwiLCBcImFjb3JuL2Rpc3QvYWNvcm5cIiwgXCJhY29ybi13YWxrL2Rpc3Qvd2Fsa1wiXSwgbW9kKTtcbiAgbW9kKHRlcm4sIHRlcm4sIHRlcm4uY29tbWVudCwgYWNvcm4sIGFjb3JuLndhbGspO1xufSkoZnVuY3Rpb24oaW5mZXIsIHRlcm4sIGNvbW1lbnQsIGFjb3JuLCB3YWxrKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBXR19NQURFVVAgPSAxLCBXR19TVFJPTkcgPSAxMDE7XG5cbiAgdGVybi5yZWdpc3RlclBsdWdpbihcImRvY19jb21tZW50XCIsIGZ1bmN0aW9uKHNlcnZlciwgb3B0aW9ucykge1xuICAgIHNlcnZlci5tb2QuanNkb2NUeXBlZGVmcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2VydmVyLm9uKFwicmVzZXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBzZXJ2ZXIubW9kLmpzZG9jVHlwZWRlZnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH0pO1xuICAgIHNlcnZlci5tb2QuZG9jQ29tbWVudCA9IHtcbiAgICAgIHdlaWdodDogb3B0aW9ucyAmJiBvcHRpb25zLnN0cm9uZyA/IFdHX1NUUk9ORyA6IHVuZGVmaW5lZCxcbiAgICAgIGZ1bGxEb2NzOiBvcHRpb25zICYmIG9wdGlvbnMuZnVsbERvY3NcbiAgICB9O1xuXG4gICAgc2VydmVyLm9uKFwicG9zdFBhcnNlXCIsIHBvc3RQYXJzZSk7XG4gICAgc2VydmVyLm9uKFwicG9zdEluZmVyXCIsIHBvc3RJbmZlcik7XG4gICAgc2VydmVyLm9uKFwicG9zdExvYWREZWZcIiwgcG9zdExvYWREZWYpO1xuICB9KTtcblxuICBmdW5jdGlvbiBwb3N0UGFyc2UoYXN0LCB0ZXh0KSB7XG4gICAgZnVuY3Rpb24gYXR0YWNoQ29tbWVudHMobm9kZSkgeyBjb21tZW50LmVuc3VyZUNvbW1lbnRzQmVmb3JlKHRleHQsIG5vZGUpOyB9XG5cbiAgICB3YWxrLnNpbXBsZShhc3QsIHtcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IGF0dGFjaENvbW1lbnRzLFxuICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogYXR0YWNoQ29tbWVudHMsXG4gICAgICBNZXRob2REZWZpbml0aW9uOiBhdHRhY2hDb21tZW50cyxcbiAgICAgIFByb3BlcnR5OiBhdHRhY2hDb21tZW50cyxcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09IFwiPVwiKSBhdHRhY2hDb21tZW50cyhub2RlKTtcbiAgICAgIH0sXG4gICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoaXNEZWZpbmVQcm9wZXJ0eUNhbGwobm9kZSkpIGF0dGFjaENvbW1lbnRzKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IGF0dGFjaENvbW1lbnRzLFxuICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBhdHRhY2hDb21tZW50cyxcbiAgICAgIENsYXNzRGVjbGFyYXRpb246IGF0dGFjaENvbW1lbnRzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RlZmluZVByb3BlcnR5Q2FsbChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY2FsbGVlLnR5cGUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiZcbiAgICAgIG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09IFwiT2JqZWN0XCIgJiZcbiAgICAgIG5vZGUuY2FsbGVlLnByb3BlcnR5Lm5hbWUgPT0gXCJkZWZpbmVQcm9wZXJ0eVwiICYmXG4gICAgICBub2RlLmFyZ3VtZW50cy5sZW5ndGggPj0gMyAmJlxuICAgICAgdHlwZW9mIG5vZGUuYXJndW1lbnRzWzFdLnZhbHVlID09IFwic3RyaW5nXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0SW5mZXIoYXN0LCBzY29wZSkge1xuICAgIGpzZG9jUGFyc2VUeXBlZGVmcyhhc3Quc291cmNlRmlsZS50ZXh0LCBzY29wZSk7XG5cbiAgICB3YWxrLnNpbXBsZShhc3QsIHtcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICAgIHZhciBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbnNbMF0uaWQ7XG4gICAgICAgIGlmIChub2RlLmNvbW1lbnRzQmVmb3JlICYmIGRlY2wudHlwZSA9PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgICBpbnRlcnByZXRDb21tZW50cyhub2RlLCBub2RlLmNvbW1lbnRzQmVmb3JlLCBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5nZXRQcm9wKG5vZGUuZGVjbGFyYXRpb25zWzBdLmlkLm5hbWUpKTtcbiAgICAgIH0sXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgICBpZiAobm9kZS5jb21tZW50c0JlZm9yZSlcbiAgICAgICAgICBpbnRlcnByZXRDb21tZW50cyhub2RlLCBub2RlLmNvbW1lbnRzQmVmb3JlLCBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5nZXRQcm9wKG5vZGUuaWQubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zY29wZS5mblR5cGUpO1xuICAgICAgfSxcbiAgICAgIENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbW1lbnRzQmVmb3JlKVxuICAgICAgICAgIGludGVycHJldENvbW1lbnRzKG5vZGUsIG5vZGUuY29tbWVudHNCZWZvcmUsIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmdldFByb3Aobm9kZS5pZC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9ialR5cGUpO1xuICAgICAgfSxcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgICBpZiAobm9kZS5jb21tZW50c0JlZm9yZSlcbiAgICAgICAgICBpbnRlcnByZXRDb21tZW50cyhub2RlLCBub2RlLmNvbW1lbnRzQmVmb3JlLCBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZlci5leHByZXNzaW9uVHlwZSh7bm9kZTogbm9kZS5sZWZ0LCBzdGF0ZTogc2NvcGV9KSk7XG4gICAgICB9LFxuICAgICAgT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgICBpZiAocHJvcC50eXBlID09ICdTcHJlYWRFbGVtZW50JykgeyBjb250aW51ZTsgfVxuICAgICAgICAgIHZhciBuYW1lID0gaW5mZXIucHJvcE5hbWUocHJvcCk7XG4gICAgICAgICAgaWYgKG5hbWUgIT0gXCI8aT5cIiAmJiBwcm9wLmNvbW1lbnRzQmVmb3JlKVxuICAgICAgICAgICAgaW50ZXJwcmV0Q29tbWVudHMocHJvcCwgcHJvcC5jb21tZW50c0JlZm9yZSwgc2NvcGUsIG5vZGUub2JqVHlwZS5nZXRQcm9wKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENsYXNzOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgICBpZiAoIW5vZGUub2JqVHlwZSkgcmV0dXJuO1xuICAgICAgICB2YXIgcHJvdG8gPSBub2RlLm9ialR5cGUuZ2V0UHJvcChcInByb3RvdHlwZVwiKS5nZXRPYmpUeXBlKCk7XG4gICAgICAgIGlmICghcHJvdG8pIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmJvZHkuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRob2QgPSBub2RlLmJvZHkuYm9keVtpXSwgbmFtZTtcbiAgICAgICAgICBpZiAoIW1ldGhvZC5jb21tZW50c0JlZm9yZSkgY29udGludWU7XG4gICAgICAgICAgaWYgKG1ldGhvZC5raW5kID09IFwiY29uc3RydWN0b3JcIilcbiAgICAgICAgICAgIGludGVycHJldENvbW1lbnRzKG1ldGhvZCwgbWV0aG9kLmNvbW1lbnRzQmVmb3JlLCBzY29wZSwgbm9kZS5vYmpUeXBlKTtcbiAgICAgICAgICBlbHNlIGlmICgobmFtZSA9IGluZmVyLnByb3BOYW1lKG1ldGhvZCkpICE9IFwiPGk+XCIpXG4gICAgICAgICAgICBpbnRlcnByZXRDb21tZW50cyhtZXRob2QsIG1ldGhvZC5jb21tZW50c0JlZm9yZSwgc2NvcGUsIHByb3RvLmdldFByb3AobmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUsIHNjb3BlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbW1lbnRzQmVmb3JlICYmIGlzRGVmaW5lUHJvcGVydHlDYWxsKG5vZGUpKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBpbmZlci5leHByZXNzaW9uVHlwZSh7bm9kZTogbm9kZS5hcmd1bWVudHNbMF0sIHN0YXRlOiBzY29wZX0pLmdldE9ialR5cGUoKTtcbiAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlIGluc3RhbmNlb2YgaW5mZXIuT2JqKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHR5cGUucHJvcHNbbm9kZS5hcmd1bWVudHNbMV0udmFsdWVdO1xuICAgICAgICAgICAgaWYgKHByb3ApIGludGVycHJldENvbW1lbnRzKG5vZGUsIG5vZGUuY29tbWVudHNCZWZvcmUsIHNjb3BlLCBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBmdW5jdGlvbihub2RlLCBzY29wZSkge1xuICAgICAgICBpZiAobm9kZS5jb21tZW50c0JlZm9yZSAmJiBub2RlLmRlY2xhcmF0aW9uICYmIG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgaW50ZXJwcmV0Q29tbWVudHMobm9kZS5kZWNsYXJhdGlvbiwgbm9kZS5jb21tZW50c0JlZm9yZSwgc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZ2V0UHJvcChub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb24uc2NvcGUuZm5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogZnVuY3Rpb24obm9kZSwgc2NvcGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29tbWVudHNCZWZvcmUgJiYgbm9kZS5kZWNsYXJhdGlvbiAmJiBub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJykge1xuICAgICAgICAgIGludGVycHJldENvbW1lbnRzKG5vZGUuZGVjbGFyYXRpb24sIG5vZGUuY29tbWVudHNCZWZvcmUsIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmdldFByb3Aobm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9uLnNjb3BlLmZuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBpbmZlci5zZWFyY2hWaXNpdG9yLCBzY29wZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0TG9hZERlZihkYXRhKSB7XG4gICAgdmFyIGRlZnMgPSBkYXRhW1wiIXR5cGVkZWZcIl07XG4gICAgdmFyIGN4ID0gaW5mZXIuY3goKSwgb3JpZyA9IGRhdGFbXCIhbmFtZVwiXTtcbiAgICBpZiAoZGVmcykgZm9yICh2YXIgbmFtZSBpbiBkZWZzKVxuICAgICAgY3gucGFyZW50Lm1vZC5qc2RvY1R5cGVkZWZzW25hbWVdID1cbiAgICAgICAgbWF5YmVJbnN0YW5jZShpbmZlci5kZWYucGFyc2UoZGVmc1tuYW1lXSwgb3JpZywgbmFtZSksIG5hbWUpO1xuICB9XG5cbiAgLy8gQ09NTUVOVCBJTlRFUlBSRVRBVElPTlxuXG4gIGZ1bmN0aW9uIHN0cmlwTGVhZGluZ0NoYXJzKGxpbmVzKSB7XG4gICAgZm9yICh2YXIgaGVhZCwgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXSwgbGluZUhlYWQgPSBsaW5lLm1hdGNoKC9eW1xcc1xcKl0qLylbMF07XG4gICAgICBpZiAobGluZUhlYWQgIT0gbGluZSkge1xuICAgICAgICBpZiAoaGVhZCA9PSBudWxsKSB7XG4gICAgICAgICAgaGVhZCA9IGxpbmVIZWFkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzYW1lID0gMDtcbiAgICAgICAgICB3aGlsZSAoc2FtZSA8IGhlYWQubGVuZ3RoICYmIGhlYWQuY2hhckNvZGVBdChzYW1lKSA9PSBsaW5lSGVhZC5jaGFyQ29kZUF0KHNhbWUpKSArK3NhbWU7XG4gICAgICAgICAgaWYgKHNhbWUgPCBoZWFkLmxlbmd0aCkgaGVhZCA9IGhlYWQuc2xpY2UoMCwgc2FtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGluZXMgPSBsaW5lcy5tYXAoZnVuY3Rpb24obGluZSwgaSkge1xuICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgICAgIGlmIChpID09IDAgJiYgaGVhZCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGVhZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGxpbmUuaW5kZXhPZihoZWFkLnNsaWNlKGopKTtcbiAgICAgICAgICBpZiAoZm91bmQgPT0gMCkgcmV0dXJuIGxpbmUuc2xpY2UoaGVhZC5sZW5ndGggLSBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhlYWQgPT0gbnVsbCB8fCBpID09IDApIHJldHVybiBsaW5lLnJlcGxhY2UoL15bXFxzXFwqXSovLCBcIlwiKTtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGhlYWQubGVuZ3RoKSByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBsaW5lLnNsaWNlKGhlYWQubGVuZ3RoKTtcbiAgICB9KTtcbiAgICB3aGlsZSAobGluZXMubGVuZ3RoICYmICFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkgbGluZXMucG9wKCk7XG4gICAgd2hpbGUgKGxpbmVzLmxlbmd0aCAmJiAhbGluZXNbMF0pIGxpbmVzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwcmV0Q29tbWVudHMobm9kZSwgY29tbWVudHMsIHNjb3BlLCBhdmFsLCB0eXBlKSB7XG4gICAganNkb2NJbnRlcnByZXRDb21tZW50cyhub2RlLCBzY29wZSwgYXZhbCwgY29tbWVudHMpO1xuICAgIHZhciBjeCA9IGluZmVyLmN4KCk7XG5cbiAgICBpZiAoIXR5cGUgJiYgYXZhbCBpbnN0YW5jZW9mIGluZmVyLkFWYWwgJiYgYXZhbC50eXBlcy5sZW5ndGgpIHtcbiAgICAgIHR5cGUgPSBhdmFsLnR5cGVzW2F2YWwudHlwZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgaW5mZXIuT2JqKSB8fCB0eXBlLm9yaWdpbiAhPSBjeC5jdXJPcmlnaW4gfHwgdHlwZS5kb2MpXG4gICAgICAgIHR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBjb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHRleHQgPSBzdHJpcExlYWRpbmdDaGFycyhjb21tZW50c1tpXS5zcGxpdCgvXFxyXFxuP3xcXG4vKSkuam9pbihcIlxcblwiKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmIChhdmFsIGluc3RhbmNlb2YgaW5mZXIuQVZhbCkgYXZhbC5kb2MgPSB0ZXh0O1xuICAgICAgICBpZiAodHlwZSkgdHlwZS5kb2MgPSB0ZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZXMgYSBzdWJzZXQgb2YgSlNEb2Mtc3R5bGUgY29tbWVudHMgaW4gb3JkZXIgdG8gaW5jbHVkZSB0aGVcbiAgLy8gZXhwbGljaXRseSBkZWZpbmVkIHR5cGVzIGluIHRoZSBhbmFseXNpcy5cblxuICBmdW5jdGlvbiBza2lwU3BhY2Uoc3RyLCBwb3MpIHtcbiAgICB3aGlsZSAoL1xccy8udGVzdChzdHIuY2hhckF0KHBvcykpKSArK3BvcztcbiAgICByZXR1cm4gcG9zO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cmluZykge1xuICAgIGlmICghYWNvcm4uaXNJZGVudGlmaWVyU3RhcnQoc3RyaW5nLmNoYXJDb2RlQXQoMCkpKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoIWFjb3JuLmlzSWRlbnRpZmllckNoYXIoc3RyaW5nLmNoYXJDb2RlQXQoaSkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxhYmVsTGlzdChzY29wZSwgc3RyLCBwb3MsIGNsb3NlKSB7XG4gICAgdmFyIGxhYmVscyA9IFtdLCB0eXBlcyA9IFtdLCBtYWRlVXAgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7IDsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgcG9zKTtcbiAgICAgIGlmIChmaXJzdCAmJiBzdHIuY2hhckF0KHBvcykgPT0gY2xvc2UpIGJyZWFrO1xuICAgICAgdmFyIGNvbG9uID0gc3RyLmluZGV4T2YoXCI6XCIsIHBvcyk7XG4gICAgICBpZiAoY29sb24gPCAwKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBsYWJlbCA9IHN0ci5zbGljZShwb3MsIGNvbG9uKTtcbiAgICAgIGlmICghaXNJZGVudGlmaWVyKGxhYmVsKSkgcmV0dXJuIG51bGw7XG4gICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICBwb3MgPSBjb2xvbiArIDE7XG4gICAgICB2YXIgdHlwZSA9IHBhcnNlVHlwZShzY29wZSwgc3RyLCBwb3MpO1xuICAgICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIHBvcyA9IHR5cGUuZW5kO1xuICAgICAgbWFkZVVwID0gbWFkZVVwIHx8IHR5cGUubWFkZVVwO1xuICAgICAgdHlwZXMucHVzaCh0eXBlLnR5cGUpO1xuICAgICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgcG9zKTtcbiAgICAgIHZhciBuZXh0ID0gc3RyLmNoYXJBdChwb3MpO1xuICAgICAgKytwb3M7XG4gICAgICBpZiAobmV4dCA9PSBjbG9zZSkgYnJlYWs7XG4gICAgICBpZiAobmV4dCAhPSBcIixcIikgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7bGFiZWxzOiBsYWJlbHMsIHR5cGVzOiB0eXBlcywgZW5kOiBwb3MsIG1hZGVVcDogbWFkZVVwfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVHlwZUF0b20oc2NvcGUsIHN0ciwgcG9zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHBhcnNlVHlwZUlubmVyKHNjb3BlLCBzdHIsIHBvcyk7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiBudWxsO1xuICAgIGlmIChzdHIuc2xpY2UocmVzdWx0LmVuZCwgcmVzdWx0LmVuZCArIDIpID09IFwiW11cIilcbiAgICAgIHJldHVybiB7bWFkZVVwOiByZXN1bHQubWFkZVVwLCBlbmQ6IHJlc3VsdC5lbmQgKyAyLCB0eXBlOiBuZXcgaW5mZXIuQXJyKHJlc3VsdC50eXBlKX07XG4gICAgZWxzZSByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUeXBlKHNjb3BlLCBzdHIsIHBvcykge1xuICAgIHZhciB0eXBlLCB1bmlvbiA9IGZhbHNlLCBtYWRlVXAgPSBmYWxzZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgaW5uZXIgPSBwYXJzZVR5cGVBdG9tKHNjb3BlLCBzdHIsIHBvcyk7XG4gICAgICBpZiAoIWlubmVyKSByZXR1cm4gbnVsbDtcbiAgICAgIG1hZGVVcCA9IG1hZGVVcCB8fCBpbm5lci5tYWRlVXA7XG4gICAgICBpZiAodW5pb24pIGlubmVyLnR5cGUucHJvcGFnYXRlKHVuaW9uKTtcbiAgICAgIGVsc2UgdHlwZSA9IGlubmVyLnR5cGU7XG4gICAgICBwb3MgPSBza2lwU3BhY2Uoc3RyLCBpbm5lci5lbmQpO1xuICAgICAgaWYgKHN0ci5jaGFyQXQocG9zKSAhPSBcInxcIikgYnJlYWs7XG4gICAgICBwb3MrKztcbiAgICAgIGlmICghdW5pb24pIHtcbiAgICAgICAgdW5pb24gPSBuZXcgaW5mZXIuQVZhbDtcbiAgICAgICAgdHlwZS5wcm9wYWdhdGUodW5pb24pO1xuICAgICAgICB0eXBlID0gdW5pb247XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XG4gICAgaWYgKHN0ci5jaGFyQXQocG9zKSA9PSBcIj1cIikge1xuICAgICAgKytwb3M7XG4gICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHt0eXBlOiB0eXBlLCBlbmQ6IHBvcywgaXNPcHRpb25hbDogaXNPcHRpb25hbCwgbWFkZVVwOiBtYWRlVXB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUeXBlSW5uZXIoc2NvcGUsIHN0ciwgcG9zKSB7XG4gICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgcG9zKTtcbiAgICBpZiAoL1s/IV0vLnRlc3Qoc3RyLmNoYXJBdChwb3MpKSkgcG9zKys7XG4gICAgdmFyIHR5cGUsIG1hZGVVcCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0ci5pbmRleE9mKFwiZnVuY3Rpb24oXCIsIHBvcykgPT0gcG9zKSB7XG4gICAgICB2YXIgYXJncyA9IHBhcnNlTGFiZWxMaXN0KHNjb3BlLCBzdHIsIHBvcyArIDksIFwiKVwiKSwgcmV0ID0gaW5mZXIuQU51bGw7XG4gICAgICBpZiAoIWFyZ3MpIHJldHVybiBudWxsO1xuICAgICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgYXJncy5lbmQpO1xuICAgICAgaWYgKHN0ci5jaGFyQXQocG9zKSA9PSBcIjpcIikge1xuICAgICAgICArK3BvcztcbiAgICAgICAgdmFyIHJldFR5cGUgPSBwYXJzZVR5cGUoc2NvcGUsIHN0ciwgcG9zICsgMSk7XG4gICAgICAgIGlmICghcmV0VHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHBvcyA9IHJldFR5cGUuZW5kO1xuICAgICAgICByZXQgPSByZXRUeXBlLnR5cGU7XG4gICAgICAgIG1hZGVVcCA9IHJldFR5cGUubWFkZVVwO1xuICAgICAgfVxuICAgICAgdHlwZSA9IG5ldyBpbmZlci5GbihudWxsLCBpbmZlci5BTnVsbCwgYXJncy50eXBlcywgYXJncy5sYWJlbHMsIHJldCk7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KHBvcykgPT0gXCJbXCIpIHtcbiAgICAgIHZhciBpbm5lciA9IHBhcnNlVHlwZShzY29wZSwgc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmICghaW5uZXIpIHJldHVybiBudWxsO1xuICAgICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgaW5uZXIuZW5kKTtcbiAgICAgIG1hZGVVcCA9IGlubmVyLm1hZGVVcDtcbiAgICAgIGlmIChzdHIuY2hhckF0KHBvcykgIT0gXCJdXCIpIHJldHVybiBudWxsO1xuICAgICAgKytwb3M7XG4gICAgICB0eXBlID0gbmV3IGluZmVyLkFycihpbm5lci50eXBlKTtcbiAgICB9IGVsc2UgaWYgKHN0ci5jaGFyQXQocG9zKSA9PSBcIntcIikge1xuICAgICAgdmFyIGZpZWxkcyA9IHBhcnNlTGFiZWxMaXN0KHNjb3BlLCBzdHIsIHBvcyArIDEsIFwifVwiKTtcbiAgICAgIGlmICghZmllbGRzKSByZXR1cm4gbnVsbDtcbiAgICAgIHR5cGUgPSBuZXcgaW5mZXIuT2JqKHRydWUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMudHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdHlwZS5kZWZQcm9wKGZpZWxkcy5sYWJlbHNbaV0pO1xuICAgICAgICBmaWVsZC5pbml0aWFsaXplciA9IHRydWU7XG4gICAgICAgIGZpZWxkcy50eXBlc1tpXS5wcm9wYWdhdGUoZmllbGQpO1xuICAgICAgfVxuICAgICAgcG9zID0gZmllbGRzLmVuZDtcbiAgICAgIG1hZGVVcCA9IGZpZWxkcy5tYWRlVXA7XG4gICAgfSBlbHNlIGlmIChzdHIuY2hhckF0KHBvcykgPT0gXCIoXCIpIHtcbiAgICAgIHZhciBpbm5lciA9IHBhcnNlVHlwZShzY29wZSwgc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmICghaW5uZXIpIHJldHVybiBudWxsO1xuICAgICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgaW5uZXIuZW5kKTtcbiAgICAgIGlmIChzdHIuY2hhckF0KHBvcykgIT0gXCIpXCIpIHJldHVybiBudWxsO1xuICAgICAgKytwb3M7XG4gICAgICB0eXBlID0gaW5uZXIudHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gcG9zO1xuICAgICAgaWYgKCFhY29ybi5pc0lkZW50aWZpZXJTdGFydChzdHIuY2hhckNvZGVBdChwb3MpKSkgcmV0dXJuIG51bGw7XG4gICAgICB3aGlsZSAoYWNvcm4uaXNJZGVudGlmaWVyQ2hhcihzdHIuY2hhckNvZGVBdChwb3MpKSkgKytwb3M7XG4gICAgICBpZiAoc3RhcnQgPT0gcG9zKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB3b3JkID0gc3RyLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICAgICAgaWYgKC9eKG51bWJlcnxpbnRlZ2VyKSQvaS50ZXN0KHdvcmQpKSB0eXBlID0gaW5mZXIuY3goKS5udW07XG4gICAgICBlbHNlIGlmICgvXmJvb2woZWFuKT8kL2kudGVzdCh3b3JkKSkgdHlwZSA9IGluZmVyLmN4KCkuYm9vbDtcbiAgICAgIGVsc2UgaWYgKC9ec3RyaW5nJC9pLnRlc3Qod29yZCkpIHR5cGUgPSBpbmZlci5jeCgpLnN0cjtcbiAgICAgIGVsc2UgaWYgKC9eKG51bGx8dW5kZWZpbmVkKSQvaS50ZXN0KHdvcmQpKSB0eXBlID0gaW5mZXIuQU51bGw7XG4gICAgICBlbHNlIGlmICgvXmFycmF5JC9pLnRlc3Qod29yZCkpIHtcbiAgICAgICAgdmFyIGlubmVyID0gbnVsbDtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQocG9zKSA9PSBcIi5cIiAmJiBzdHIuY2hhckF0KHBvcyArIDEpID09IFwiPFwiKSB7XG4gICAgICAgICAgdmFyIGluQW5nbGVzID0gcGFyc2VUeXBlKHNjb3BlLCBzdHIsIHBvcyArIDIpO1xuICAgICAgICAgIGlmICghaW5BbmdsZXMpIHJldHVybiBudWxsO1xuICAgICAgICAgIHBvcyA9IHNraXBTcGFjZShzdHIsIGluQW5nbGVzLmVuZCk7XG4gICAgICAgICAgbWFkZVVwID0gaW5BbmdsZXMubWFkZVVwO1xuICAgICAgICAgIGlmIChzdHIuY2hhckF0KHBvcysrKSAhPSBcIj5cIikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaW5uZXIgPSBpbkFuZ2xlcy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBuZXcgaW5mZXIuQXJyKGlubmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoL15vYmplY3QkL2kudGVzdCh3b3JkKSkge1xuICAgICAgICB0eXBlID0gbmV3IGluZmVyLk9iaih0cnVlKTtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQocG9zKSA9PSBcIi5cIiAmJiBzdHIuY2hhckF0KHBvcyArIDEpID09IFwiPFwiKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHBhcnNlVHlwZShzY29wZSwgc3RyLCBwb3MgKyAyKTtcbiAgICAgICAgICBpZiAoIWtleSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcG9zID0gc2tpcFNwYWNlKHN0ciwga2V5LmVuZCk7XG4gICAgICAgICAgaWYgKHN0ci5jaGFyQXQocG9zKyspICE9IFwiLFwiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgdmFsID0gcGFyc2VUeXBlKHNjb3BlLCBzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKCF2YWwpIHJldHVybiBudWxsO1xuICAgICAgICAgIHBvcyA9IHNraXBTcGFjZShzdHIsIHZhbC5lbmQpO1xuICAgICAgICAgIG1hZGVVcCA9IGtleS5tYWRlVXAgfHwgdmFsLm1hZGVVcDtcbiAgICAgICAgICBpZiAoc3RyLmNoYXJBdChwb3MrKykgIT0gXCI+XCIpIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhbC50eXBlLnByb3BhZ2F0ZSh0eXBlLmRlZlByb3AoXCI8aT5cIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PSA0NiB8fFxuICAgICAgICAgICAgICAgYWNvcm4uaXNJZGVudGlmaWVyQ2hhcihzdHIuY2hhckNvZGVBdChwb3MpKSkgKytwb3M7XG4gICAgICAgIHZhciBwYXRoID0gc3RyLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICAgICAgICB2YXIgY3ggPSBpbmZlci5jeCgpLCBkZWZzID0gY3gucGFyZW50ICYmIGN4LnBhcmVudC5tb2QuanNkb2NUeXBlZGVmcywgZm91bmQ7XG4gICAgICAgIGlmIChkZWZzICYmIChwYXRoIGluIGRlZnMpKSB7XG4gICAgICAgICAgdHlwZSA9IGRlZnNbcGF0aF07XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQgPSBpbmZlci5kZWYucGFyc2VQYXRoKHBhdGgsIHNjb3BlKS5nZXRPYmpUeXBlKCkpIHtcbiAgICAgICAgICB0eXBlID0gbWF5YmVJbnN0YW5jZShmb3VuZCwgcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjeC5qc2RvY1BsYWNlaG9sZGVycykgY3guanNkb2NQbGFjZWhvbGRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGlmICghKHBhdGggaW4gY3guanNkb2NQbGFjZWhvbGRlcnMpKVxuICAgICAgICAgICAgdHlwZSA9IGN4LmpzZG9jUGxhY2Vob2xkZXJzW3BhdGhdID0gbmV3IGluZmVyLk9iaihudWxsLCBwYXRoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0eXBlID0gY3guanNkb2NQbGFjZWhvbGRlcnNbcGF0aF07XG4gICAgICAgICAgbWFkZVVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgZW5kOiBwb3MsIG1hZGVVcDogbWFkZVVwfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW5zdGFuY2UodHlwZSwgcGF0aCkge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgaW5mZXIuRm4gJiYgLyg/Ol58XFwuKVtBLVpdW15cXC5dKiQvLnRlc3QocGF0aCkpIHtcbiAgICAgIHZhciBwcm90byA9IHR5cGUuZ2V0UHJvcChcInByb3RvdHlwZVwiKS5nZXRPYmpUeXBlKCk7XG4gICAgICBpZiAocHJvdG8gaW5zdGFuY2VvZiBpbmZlci5PYmopIHJldHVybiBpbmZlci5nZXRJbnN0YW5jZShwcm90byk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUeXBlT3V0ZXIoc2NvcGUsIHN0ciwgcG9zKSB7XG4gICAgcG9zID0gc2tpcFNwYWNlKHN0ciwgcG9zIHx8IDApO1xuICAgIGlmIChzdHIuY2hhckF0KHBvcykgIT0gXCJ7XCIpIHJldHVybiBudWxsO1xuICAgIHZhciByZXN1bHQgPSBwYXJzZVR5cGUoc2NvcGUsIHN0ciwgcG9zICsgMSk7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiBudWxsO1xuICAgIHZhciBlbmQgPSBza2lwU3BhY2Uoc3RyLCByZXN1bHQuZW5kKTtcbiAgICBpZiAoc3RyLmNoYXJBdChlbmQpICE9IFwifVwiKSByZXR1cm4gbnVsbDtcbiAgICByZXN1bHQuZW5kID0gZW5kICsgMTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24ganNkb2NJbnRlcnByZXRDb21tZW50cyhub2RlLCBzY29wZSwgYXZhbCwgY29tbWVudHMpIHtcbiAgICB2YXIgdHlwZSwgYXJncywgcmV0LCBmb3VuZE9uZSwgc2VsZiwgcGFyc2VkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNvbW1lbnQgPSBjb21tZW50c1tpXTtcbiAgICAgIHZhciBkZWNsID0gLyg/OlxcbnxcXCopXFxzKkAodHlwZXxwYXJhbXxhcmcoPzp1bWVudCk/fHJldHVybnM/fHRoaXN8Y2xhc3N8Y29uc3RydWN0b3IpKD86XFxzKj9cXG58XFxzKyguKikpL2csIG07XG4gICAgICB3aGlsZSAobSA9IGRlY2wuZXhlYyhjb21tZW50KSkge1xuICAgICAgICBpZiAobVsxXSA9PSBcImNsYXNzXCIgfHwgbVsxXSA9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICBzZWxmID0gZm91bmRPbmUgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1bMl0gPT09IHVuZGVmaW5lZCkgY29udGludWU7IC8vIHRvIGF2b2lkIHRhZ3MgdGhhdCByZXF1aXJlIGEgdHlwZSBhcmd1bWVudC5cblxuICAgICAgICBpZiAobVsxXSA9PSBcInRoaXNcIiAmJiAocGFyc2VkID0gcGFyc2VUeXBlKHNjb3BlLCBtWzJdLCAwKSkpIHtcbiAgICAgICAgICBzZWxmID0gcGFyc2VkO1xuICAgICAgICAgIGZvdW5kT25lID0gdHJ1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHBhcnNlZCA9IHBhcnNlVHlwZU91dGVyKHNjb3BlLCBtWzJdKSkpIGNvbnRpbnVlO1xuICAgICAgICBmb3VuZE9uZSA9IHRydWU7XG5cbiAgICAgICAgc3dpdGNoKG1bMV0pIHtcbiAgICAgICAgY2FzZSBcInJldHVybnNcIjogY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgIHJldCA9IHBhcnNlZDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgdHlwZSA9IHBhcnNlZDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwYXJhbVwiOiBjYXNlIFwiYXJnXCI6IGNhc2UgXCJhcmd1bWVudFwiOlxuICAgICAgICAgICAgLy8gUG9zc2libGUganNkb2MgcGFyYW0gbmFtZSBzaXR1YXRpb25zOlxuICAgICAgICAgICAgLy8gZW1wbG95ZWVcbiAgICAgICAgICAgIC8vIFtlbXBsb3llZV1cbiAgICAgICAgICAgIC8vIFtlbXBsb3llZT1Kb2huIERvZV1cbiAgICAgICAgICAgIC8vIGVtcGxveWVlLm5hbWVcbiAgICAgICAgICAgIC8vIGVtcGxveWVlc1tdLm5hbWVcbiAgICAgICAgICAgIHZhciBuYW1lID0gbVsyXS5zbGljZShwYXJzZWQuZW5kKS5tYXRjaCgvXlxccyooXFxbPylcXHMqKFteXFxbXFxdXFxzPV0rKFxcW1xcXVteXFxbXFxdXFxzPV0rKT8pXFxzKig/Oj1bXlxcXV0rXFxzKik/KFxcXT8pLiovKTtcbiAgICAgICAgICAgIGlmICghbmFtZSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgYXJnbmFtZSA9IG5hbWVbMl0gKyAocGFyc2VkLmlzT3B0aW9uYWwgfHwgKG5hbWVbMV0gPT09ICdbJyAmJiBuYW1lWzRdID09PSAnXScpID8gXCI/XCIgOiBcIlwiKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBqc2RvYyBpcyBpbmRpY2F0aW5nIGEgcHJvcGVydHkgb2YgYSBwcmV2aW91c2x5IGRvY3VtZW50ZWQgcGFyYW1ldGVyXG4gICAgICAgICAgICB2YXIgaXNPYmpQcm9wID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBhcmduYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiAoYXJncyAmJiBwYXJ0cy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICB2YXIgb2JqbmFtZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICBhcmduYW1lID0gcGFydHNbMV07XG5cbiAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBwcmV2aW91c2x5IGZvdW5kIHBhcmFtZXRlciB0byBmaW5kIHRoZVxuICAgICAgICAgICAgICAvLyBvYmplY3Qgb3IgYXJyYXkgZm9yIHdoaWNoIHRoaXMgbmV3IHBhcmFtZXRlciBzaG91bGQgYmUgYSBwYXJ0XG4gICAgICAgICAgICAgIC8vIG9mXG4gICAgICAgICAgICAgIHZhciBrZXksIHZhbHVlO1xuICAgICAgICAgICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBvYmpuYW1lICYmIHZhbHVlLnR5cGUgaW5zdGFuY2VvZiBpbmZlci5PYmopIHtcbiAgICAgICAgICAgICAgICAgIGlzT2JqUHJvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBwYXJzZWQudHlwZS5wcm9wYWdhdGUodmFsdWUudHlwZS5kZWZQcm9wKGFyZ25hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICsgJ1tdJyA9PT0gb2JqbmFtZSAmJiB2YWx1ZS50eXBlIGluc3RhbmNlb2YgaW5mZXIuQXJyKSB7XG4gICAgICAgICAgICAgICAgICBpc09ialByb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcGFyc2VkLnR5cGUucHJvcGFnYXRlKHZhbHVlLnR5cGUuZ2V0UHJvcChcIjxpPlwiKS5nZXRUeXBlKCkuZGVmUHJvcChhcmduYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2JqUHJvcCkge1xuICAgICAgICAgICAgICAoYXJncyB8fCAoYXJncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVthcmduYW1lXSA9IHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3VuZE9uZSkgYXBwbHlUeXBlKHR5cGUsIHNlbGYsIGFyZ3MsIHJldCwgbm9kZSwgYXZhbCk7XG4gIH1cblxuICBmdW5jdGlvbiBqc2RvY1BhcnNlVHlwZWRlZnModGV4dCwgc2NvcGUpIHtcbiAgICB2YXIgY3ggPSBpbmZlci5jeCgpO1xuXG4gICAgdmFyIHJlID0gL1xcc0B0eXBlZGVmXFxzKyguKikvZywgbTtcbiAgICB3aGlsZSAobSA9IHJlLmV4ZWModGV4dCkpIHtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVR5cGVPdXRlcihzY29wZSwgbVsxXSk7XG4gICAgICB2YXIgbmFtZSA9IHBhcnNlZCAmJiBtWzFdLnNsaWNlKHBhcnNlZC5lbmQpLm1hdGNoKC9eXFxzKihcXFMrKS8pO1xuICAgICAgaWYgKG5hbWUgJiYgcGFyc2VkLnR5cGUgaW5zdGFuY2VvZiBpbmZlci5PYmopIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0ZXh0LnNsaWNlKG0uaW5kZXggKyBtWzBdLmxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChtID0gL1xccytAcHJvcCg/OmVydHkpP1xccysoLiopLy5leGVjKHJlc3QpKSB7XG4gICAgICAgICAgdmFyIHByb3BUeXBlID0gcGFyc2VUeXBlT3V0ZXIoc2NvcGUsIG1bMV0pLCBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAocHJvcFR5cGUgJiYgKHByb3BOYW1lID0gbVsxXS5zbGljZShwcm9wVHlwZS5lbmQpLm1hdGNoKC9eXFxzKihcXFMrKS8pKSlcbiAgICAgICAgICAgIHByb3BUeXBlLnR5cGUucHJvcGFnYXRlKHBhcnNlZC50eXBlLmRlZlByb3AocHJvcE5hbWVbMV0pKTtcbiAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShtWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY3gucGFyZW50Lm1vZC5qc2RvY1R5cGVkZWZzW25hbWVbMV1dID0gcGFyc2VkLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvcGFnYXRlV2l0aFdlaWdodCh0eXBlLCB0YXJnZXQpIHtcbiAgICB2YXIgd2VpZ2h0ID0gaW5mZXIuY3goKS5wYXJlbnQubW9kLmRvY0NvbW1lbnQud2VpZ2h0O1xuICAgIHR5cGUudHlwZS5wcm9wYWdhdGUodGFyZ2V0LCB3ZWlnaHQgfHwgKHR5cGUubWFkZVVwID8gV0dfTUFERVVQIDogdW5kZWZpbmVkKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bkV4cHIobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlID09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeXBlKHR5cGUsIHNlbGYsIGFyZ3MsIHJldCwgbm9kZSwgYXZhbCkge1xuICAgIHZhciBmbjtcbiAgICBpZiAobm9kZS50eXBlID09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgICB2YXIgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zWzBdO1xuICAgICAgaWYgKGRlY2wuaW5pdCAmJiBpc0Z1bkV4cHIoZGVjbC5pbml0KSkgZm4gPSBkZWNsLmluaXQuc2NvcGUuZm5UeXBlO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiKSB7XG4gICAgICBmbiA9IG5vZGUuc2NvcGUuZm5UeXBlO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgICAgaWYgKGlzRnVuRXhwcihub2RlLnJpZ2h0KSlcbiAgICAgICAgZm4gPSBub2RlLnJpZ2h0LnNjb3BlLmZuVHlwZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgIH0gZWxzZSB7IC8vIEFuIG9iamVjdCBwcm9wZXJ0eVxuICAgICAgaWYgKGlzRnVuRXhwcihub2RlLnZhbHVlKSkgZm4gPSBub2RlLnZhbHVlLnNjb3BlLmZuVHlwZTtcbiAgICB9XG5cbiAgICBpZiAoZm4gJiYgKGFyZ3MgfHwgcmV0IHx8IHNlbGYpKSB7XG4gICAgICBpZiAoYXJncykgZm9yICh2YXIgaSA9IDA7IGkgPCBmbi5hcmdOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbmFtZSA9IGZuLmFyZ05hbWVzW2ldLCBrbm93biA9IGFyZ3NbbmFtZV07XG4gICAgICAgIGlmICgha25vd24gJiYgKGtub3duID0gYXJnc1tuYW1lICsgXCI/XCJdKSlcbiAgICAgICAgICBmbi5hcmdOYW1lc1tpXSArPSBcIj9cIjtcbiAgICAgICAgaWYgKGtub3duKSBwcm9wYWdhdGVXaXRoV2VpZ2h0KGtub3duLCBmbi5hcmdzW2ldKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgaWYgKGZuLnJldHZhbCA9PSBpbmZlci5BTnVsbCkgZm4ucmV0dmFsID0gbmV3IGluZmVyLkFWYWw7XG4gICAgICAgIHByb3BhZ2F0ZVdpdGhXZWlnaHQocmV0LCBmbi5yZXR2YWwpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHByb3RvID0gZm4uZ2V0UHJvcChcInByb3RvdHlwZVwiKS5nZXRPYmpUeXBlKCk7XG4gICAgICAgIHNlbGYgPSBwcm90byAmJiB7dHlwZTogaW5mZXIuZ2V0SW5zdGFuY2UocHJvdG8sIGZuKX07XG4gICAgICB9XG4gICAgICBpZiAoc2VsZikgcHJvcGFnYXRlV2l0aFdlaWdodChzZWxmLCBmbi5zZWxmKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUpIHtcbiAgICAgIHByb3BhZ2F0ZVdpdGhXZWlnaHQodHlwZSwgYXZhbCk7XG4gICAgfVxuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tern/plugin/doc_comment.js\n");

/***/ }),

/***/ "./src/defs/jscodeshift.json":
/*!***********************************!*\
  !*** ./src/defs/jscodeshift.json ***!
  \***********************************/
/*! exports provided: !name, !define, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"!name\\\":\\\"jscodeshift\\\",\\\"!define\\\":{\\\"file\\\":{\\\"source\\\":{\\\"!type\\\":\\\"string\\\",\\\"!doc\\\":\\\"The source code of the current file.\\\"},\\\"path\\\":{\\\"!type\\\":\\\"string\\\",\\\"!doc\\\":\\\"The absolute path to the current file\\\"}},\\\"apiObject\\\":{\\\"stats\\\":{\\\"!type\\\":\\\"fn(value: string)\\\",\\\"!doc\\\":\\\"Helper function to collect data during --dry runs. This function keeps a counter for how often it was called with a specific argument. The result is shown in the console. Useful for finding out how many files match a criterion.\\\"},\\\"jscodeshift\\\":{\\\"!type\\\":\\\"fn(source: string|+NodePath) -> +Collection\\\",\\\"template\\\":{\\\"expression\\\":{\\\"!type\\\":\\\"fn(strings: [string], value: ?, value: ?) -> Expression\\\",\\\"!doc\\\":\\\"Tagged template function. Parses the string as source and returns an Expression AST node.\\\"},\\\"statement\\\":{\\\"!type\\\":\\\"fn(strings: [string], value: ?, value: ?) -> Statement\\\",\\\"!doc\\\":\\\"Tagged template function. Parses the string as source and returns an Statement AST node.\\\"},\\\"statements\\\":{\\\"!type\\\":\\\"fn(strings: [string], value: ?, value: ?) -> [Statement]\\\",\\\"!doc\\\":\\\"Tagged template function. Parses the string as source and returns an array of Statement AST nodes.\\\"}},\\\"match\\\":{\\\"!type\\\":\\\"fn(node: ASTNode, pattern: object) -> bool\\\",\\\"!doc\\\":\\\"Returns true if node matches the pattern, else false\\\"},\\\"ModuleSpecifier\\\":\\\"TypeDefinition\\\",\\\"ConditionalExpression\\\":\\\"TypeDefinition\\\",\\\"Node\\\":\\\"TypeDefinition\\\",\\\"MixedTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"XMLAttributeSelector\\\":\\\"TypeDefinition\\\",\\\"JSXNamespacedName\\\":\\\"TypeDefinition\\\",\\\"GenericTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"XMLFunctionQualifiedIdentifier\\\":\\\"TypeDefinition\\\",\\\"ClassPropertyDefinition\\\":\\\"TypeDefinition\\\",\\\"NullableTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"ForInStatement\\\":\\\"TypeDefinition\\\",\\\"YieldExpression\\\":\\\"TypeDefinition\\\",\\\"ClassProperty\\\":\\\"TypeDefinition\\\",\\\"XMLDefaultDeclaration\\\":\\\"TypeDefinition\\\",\\\"TemplateElement\\\":\\\"TypeDefinition\\\",\\\"ExportDefaultDeclaration\\\":\\\"TypeDefinition\\\",\\\"TupleTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"GraphExpression\\\":\\\"TypeDefinition\\\",\\\"MemberExpression\\\":\\\"TypeDefinition\\\",\\\"ImportDeclaration\\\":\\\"TypeDefinition\\\",\\\"File\\\":\\\"TypeDefinition\\\",\\\"JSXSpreadAttribute\\\":\\\"TypeDefinition\\\",\\\"XMLName\\\":\\\"TypeDefinition\\\",\\\"ClassExpression\\\":\\\"TypeDefinition\\\",\\\"TemplateLiteral\\\":\\\"TypeDefinition\\\",\\\"ClassImplements\\\":\\\"TypeDefinition\\\",\\\"TypeAlias\\\":\\\"TypeDefinition\\\",\\\"StringLiteralTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"TaggedTemplateExpression\\\":\\\"TypeDefinition\\\",\\\"Identifier\\\":\\\"TypeDefinition\\\",\\\"JSXElement\\\":\\\"TypeDefinition\\\",\\\"BooleanLiteralTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"MethodDefinition\\\":\\\"TypeDefinition\\\",\\\"Line\\\":\\\"TypeDefinition\\\",\\\"GeneratorExpression\\\":\\\"TypeDefinition\\\",\\\"LetStatement\\\":\\\"TypeDefinition\\\",\\\"Literal\\\":\\\"TypeDefinition\\\",\\\"BooleanTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"JSXAttribute\\\":\\\"TypeDefinition\\\",\\\"ExportNamespaceSpecifier\\\":\\\"TypeDefinition\\\",\\\"ArrayTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"BlockStatement\\\":\\\"TypeDefinition\\\",\\\"WithStatement\\\":\\\"TypeDefinition\\\",\\\"XMLProcessingInstruction\\\":\\\"TypeDefinition\\\",\\\"SpreadPropertyPattern\\\":\\\"TypeDefinition\\\",\\\"WhileStatement\\\":\\\"TypeDefinition\\\",\\\"ThrowStatement\\\":\\\"TypeDefinition\\\",\\\"InterfaceDeclaration\\\":\\\"TypeDefinition\\\",\\\"TypeofTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"LetExpression\\\":\\\"TypeDefinition\\\",\\\"ExportSpecifier\\\":\\\"TypeDefinition\\\",\\\"ContinueStatement\\\":\\\"TypeDefinition\\\",\\\"Printable\\\":\\\"TypeDefinition\\\",\\\"ThisExpression\\\":\\\"TypeDefinition\\\",\\\"IntersectionTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"JSXClosingElement\\\":\\\"TypeDefinition\\\",\\\"DeclareFunction\\\":\\\"TypeDefinition\\\",\\\"VariableDeclaration\\\":\\\"TypeDefinition\\\",\\\"BreakStatement\\\":\\\"TypeDefinition\\\",\\\"ImportSpecifier\\\":\\\"TypeDefinition\\\",\\\"ParenthesizedExpression\\\":\\\"TypeDefinition\\\",\\\"RestElement\\\":\\\"TypeDefinition\\\",\\\"Specifier\\\":\\\"TypeDefinition\\\",\\\"ArrayExpression\\\":\\\"TypeDefinition\\\",\\\"XMLAnyName\\\":\\\"TypeDefinition\\\",\\\"ExportDeclaration\\\":\\\"TypeDefinition\\\",\\\"ObjectTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"ExportAllDeclaration\\\":\\\"TypeDefinition\\\",\\\"SourceLocation\\\":\\\"TypeDefinition\\\",\\\"TypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"Statement\\\":\\\"TypeDefinition\\\",\\\"Position\\\":\\\"TypeDefinition\\\",\\\"ObjectExpression\\\":\\\"TypeDefinition\\\",\\\"Program\\\":\\\"TypeDefinition\\\",\\\"Comment\\\":\\\"TypeDefinition\\\",\\\"AssignmentPattern\\\":\\\"TypeDefinition\\\",\\\"ObjectTypeIndexer\\\":\\\"TypeDefinition\\\",\\\"ArrowFunctionExpression\\\":\\\"TypeDefinition\\\",\\\"XMLAttribute\\\":\\\"TypeDefinition\\\",\\\"Noop\\\":\\\"TypeDefinition\\\",\\\"DeclareClass\\\":\\\"TypeDefinition\\\",\\\"XMLEndTag\\\":\\\"TypeDefinition\\\",\\\"JSXIdentifier\\\":\\\"TypeDefinition\\\",\\\"VoidTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"ComprehensionBlock\\\":\\\"TypeDefinition\\\",\\\"FunctionTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"ComprehensionExpression\\\":\\\"TypeDefinition\\\",\\\"MetaProperty\\\":\\\"TypeDefinition\\\",\\\"XMLQualifiedIdentifier\\\":\\\"TypeDefinition\\\",\\\"DoWhileStatement\\\":\\\"TypeDefinition\\\",\\\"EmptyStatement\\\":\\\"TypeDefinition\\\",\\\"VariableDeclarator\\\":\\\"TypeDefinition\\\",\\\"ObjectPattern\\\":\\\"TypeDefinition\\\",\\\"AssignmentExpression\\\":\\\"TypeDefinition\\\",\\\"Declaration\\\":\\\"TypeDefinition\\\",\\\"DoExpression\\\":\\\"TypeDefinition\\\",\\\"GraphIndexExpression\\\":\\\"TypeDefinition\\\",\\\"DeclareVariable\\\":\\\"TypeDefinition\\\",\\\"ObjectTypeProperty\\\":\\\"TypeDefinition\\\",\\\"IfStatement\\\":\\\"TypeDefinition\\\",\\\"BindExpression\\\":\\\"TypeDefinition\\\",\\\"LogicalExpression\\\":\\\"TypeDefinition\\\",\\\"CommentLine\\\":\\\"TypeDefinition\\\",\\\"ObjectTypeCallProperty\\\":\\\"TypeDefinition\\\",\\\"FunctionDeclaration\\\":\\\"TypeDefinition\\\",\\\"NewExpression\\\":\\\"TypeDefinition\\\",\\\"TypeCastExpression\\\":\\\"TypeDefinition\\\",\\\"XMLStartTag\\\":\\\"TypeDefinition\\\",\\\"XMLPointTag\\\":\\\"TypeDefinition\\\",\\\"Pattern\\\":\\\"TypeDefinition\\\",\\\"ImportDefaultSpecifier\\\":\\\"TypeDefinition\\\",\\\"XMLFilterExpression\\\":\\\"TypeDefinition\\\",\\\"XMLEscape\\\":\\\"TypeDefinition\\\",\\\"JSXEmptyExpression\\\":\\\"TypeDefinition\\\",\\\"SequenceExpression\\\":\\\"TypeDefinition\\\",\\\"InterfaceExtends\\\":\\\"TypeDefinition\\\",\\\"PropertyPattern\\\":\\\"TypeDefinition\\\",\\\"CatchClause\\\":\\\"TypeDefinition\\\",\\\"SpreadElement\\\":\\\"TypeDefinition\\\",\\\"FunctionTypeParam\\\":\\\"TypeDefinition\\\",\\\"Property\\\":\\\"TypeDefinition\\\",\\\"JSXOpeningElement\\\":\\\"TypeDefinition\\\",\\\"StringTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"ForStatement\\\":\\\"TypeDefinition\\\",\\\"Decorator\\\":\\\"TypeDefinition\\\",\\\"SpreadElementPattern\\\":\\\"TypeDefinition\\\",\\\"JSXMemberExpression\\\":\\\"TypeDefinition\\\",\\\"FunctionExpression\\\":\\\"TypeDefinition\\\",\\\"BinaryExpression\\\":\\\"TypeDefinition\\\",\\\"TryStatement\\\":\\\"TypeDefinition\\\",\\\"Expression\\\":\\\"TypeDefinition\\\",\\\"ExportNamedDeclaration\\\":\\\"TypeDefinition\\\",\\\"SwitchStatement\\\":\\\"TypeDefinition\\\",\\\"Block\\\":\\\"TypeDefinition\\\",\\\"ExportBatchSpecifier\\\":\\\"TypeDefinition\\\",\\\"ExpressionStatement\\\":\\\"TypeDefinition\\\",\\\"ArrayPattern\\\":\\\"TypeDefinition\\\",\\\"XMLList\\\":\\\"TypeDefinition\\\",\\\"ReturnStatement\\\":\\\"TypeDefinition\\\",\\\"CallExpression\\\":\\\"TypeDefinition\\\",\\\"DeclareModule\\\":\\\"TypeDefinition\\\",\\\"NumberLiteralTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"Type\\\":\\\"TypeDefinition\\\",\\\"TypeParameterDeclaration\\\":\\\"TypeDefinition\\\",\\\"XMLText\\\":\\\"TypeDefinition\\\",\\\"Function\\\":\\\"TypeDefinition\\\",\\\"UnaryExpression\\\":\\\"TypeDefinition\\\",\\\"XML\\\":\\\"TypeDefinition\\\",\\\"Super\\\":\\\"TypeDefinition\\\",\\\"TypeParameterInstantiation\\\":\\\"TypeDefinition\\\",\\\"XMLComment\\\":\\\"TypeDefinition\\\",\\\"MemberTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"SwitchCase\\\":\\\"TypeDefinition\\\",\\\"AwaitExpression\\\":\\\"TypeDefinition\\\",\\\"ExportDefaultSpecifier\\\":\\\"TypeDefinition\\\",\\\"XMLElement\\\":\\\"TypeDefinition\\\",\\\"AnyTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"CommentBlock\\\":\\\"TypeDefinition\\\",\\\"ClassBody\\\":\\\"TypeDefinition\\\",\\\"ImportNamespaceSpecifier\\\":\\\"TypeDefinition\\\",\\\"JSXExpressionContainer\\\":\\\"TypeDefinition\\\",\\\"DeclareExportDeclaration\\\":\\\"TypeDefinition\\\",\\\"UnionTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"XMLCdata\\\":\\\"TypeDefinition\\\",\\\"JSXText\\\":\\\"TypeDefinition\\\",\\\"QualifiedTypeIdentifier\\\":\\\"TypeDefinition\\\",\\\"DebuggerStatement\\\":\\\"TypeDefinition\\\",\\\"ForOfStatement\\\":\\\"TypeDefinition\\\",\\\"LabeledStatement\\\":\\\"TypeDefinition\\\",\\\"SpreadProperty\\\":\\\"TypeDefinition\\\",\\\"UpdateExpression\\\":\\\"TypeDefinition\\\",\\\"ClassDeclaration\\\":\\\"TypeDefinition\\\",\\\"NumberTypeAnnotation\\\":\\\"TypeDefinition\\\",\\\"switchStatement\\\":{\\\"!type\\\":\\\"fn(discriminant: Expression, cases: [SwitchCase], lexical: boolean) -> SwitchStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SwitchStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"identifier\\\":{\\\"!type\\\":\\\"fn(name: string) -> Identifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Identifier'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"classPropertyDefinition\\\":{\\\"!type\\\":\\\"fn(definition: MethodDefinition|VariableDeclarator|ClassPropertyDefinition|ClassProperty) -> ClassPropertyDefinition\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ClassPropertyDefinition'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"jsxMemberExpression\\\":{\\\"!type\\\":\\\"fn(object: JSXIdentifier|JSXMemberExpression, property: JSXIdentifier) -> JSXMemberExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXMemberExpression'.\\\\nSuper types: MemberExpression, Expression, Pattern, Node, Printable\\\"},\\\"exportNamespaceSpecifier\\\":{\\\"!type\\\":\\\"fn(exported: Identifier) -> ExportNamespaceSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportNamespaceSpecifier'.\\\\nSuper types: Specifier, Node, Printable\\\"},\\\"conditionalExpression\\\":{\\\"!type\\\":\\\"fn(test: Expression, consequent: Expression, alternate: Expression) -> ConditionalExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ConditionalExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"parenthesizedExpression\\\":{\\\"!type\\\":\\\"fn(expression: Expression) -> ParenthesizedExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ParenthesizedExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"yieldExpression\\\":{\\\"!type\\\":\\\"fn(argument: Expression|null, delegate: boolean) -> YieldExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'YieldExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"typeParameterInstantiation\\\":{\\\"!type\\\":\\\"fn(params: [Type]) -> TypeParameterInstantiation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TypeParameterInstantiation'.\\\\nSuper types: Node, Printable\\\"},\\\"bindExpression\\\":{\\\"!type\\\":\\\"fn(object: Expression|null, callee: Expression) -> BindExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'BindExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"expressionStatement\\\":{\\\"!type\\\":\\\"fn(expression: Expression) -> ExpressionStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExpressionStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"spreadElement\\\":{\\\"!type\\\":\\\"fn(argument: Expression) -> SpreadElement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SpreadElement'.\\\\nSuper types: Node, Printable\\\"},\\\"program\\\":{\\\"!type\\\":\\\"fn(body: [Statement]) -> Program\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Program'.\\\\nSuper types: Node, Printable\\\"},\\\"jsxElement\\\":{\\\"!type\\\":\\\"fn(openingElement: JSXOpeningElement, closingElement: JSXClosingElement|null, children: [JSXElement|JSXExpressionContainer|JSXText|Literal]) -> JSXElement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXElement'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"memberTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(object: Identifier, property: MemberTypeAnnotation|GenericTypeAnnotation) -> MemberTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'MemberTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"importNamespaceSpecifier\\\":{\\\"!type\\\":\\\"fn(local: Identifier|null) -> ImportNamespaceSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ImportNamespaceSpecifier'.\\\\nSuper types: ModuleSpecifier, Specifier, Node, Printable\\\"},\\\"numberLiteralTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(value: number, raw: string) -> NumberLiteralTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'NumberLiteralTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"typeofTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(argument: Type) -> TypeofTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TypeofTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"declareClass\\\":{\\\"!type\\\":\\\"fn(id: Identifier) -> DeclareClass\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DeclareClass'.\\\\nSuper types: InterfaceDeclaration, Statement, Node, Printable\\\"},\\\"declareFunction\\\":{\\\"!type\\\":\\\"fn(id: Identifier) -> DeclareFunction\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DeclareFunction'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"logicalExpression\\\":{\\\"!type\\\":\\\"fn(operator: string, left: Expression, right: Expression) -> LogicalExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'LogicalExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n operator (string) one of: |||&&\\\\n\\\"},\\\"jsxNamespacedName\\\":{\\\"!type\\\":\\\"fn(namespace: JSXIdentifier, name: JSXIdentifier) -> JSXNamespacedName\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXNamespacedName'.\\\\nSuper types: Node, Printable\\\"},\\\"debuggerStatement\\\":{\\\"!type\\\":\\\"fn() -> DebuggerStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DebuggerStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"methodDefinition\\\":{\\\"!type\\\":\\\"fn(kind: string, key: Literal|Identifier|Expression, value: Function, static: boolean) -> MethodDefinition\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'MethodDefinition'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\\n\\\\n kind (string) one of: constructor|method|get|set\\\\n\\\"},\\\"functionTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(params: [FunctionTypeParam], returnType: Type, rest: FunctionTypeParam|null, typeParameters: TypeParameterDeclaration|null) -> FunctionTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'FunctionTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"objectPattern\\\":{\\\"!type\\\":\\\"fn(properties: [Property|PropertyPattern|SpreadPropertyPattern|SpreadProperty]) -> ObjectPattern\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ObjectPattern'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"unionTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(types: [Type]) -> UnionTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'UnionTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"ifStatement\\\":{\\\"!type\\\":\\\"fn(test: Expression, consequent: Statement, alternate: Statement|null) -> IfStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'IfStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"forInStatement\\\":{\\\"!type\\\":\\\"fn(left: VariableDeclaration|Expression, right: Expression, body: Statement, each: boolean) -> ForInStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ForInStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"letStatement\\\":{\\\"!type\\\":\\\"fn(head: [VariableDeclarator], body: Statement) -> LetStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'LetStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"jsxEmptyExpression\\\":{\\\"!type\\\":\\\"fn() -> JSXEmptyExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXEmptyExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"qualifiedTypeIdentifier\\\":{\\\"!type\\\":\\\"fn(qualification: Identifier|QualifiedTypeIdentifier, id: Identifier) -> QualifiedTypeIdentifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'QualifiedTypeIdentifier'.\\\\nSuper types: Node, Printable\\\"},\\\"metaProperty\\\":{\\\"!type\\\":\\\"fn(meta: Identifier, property: Identifier) -> MetaProperty\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'MetaProperty'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"tryStatement\\\":{\\\"!type\\\":\\\"fn(block: BlockStatement, handler: CatchClause|null, finalizer: BlockStatement|null) -> TryStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TryStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"arrayTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(elementType: Type) -> ArrayTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ArrayTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"taggedTemplateExpression\\\":{\\\"!type\\\":\\\"fn(tag: Expression, quasi: TemplateLiteral) -> TaggedTemplateExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TaggedTemplateExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"spreadPropertyPattern\\\":{\\\"!type\\\":\\\"fn(argument: Pattern) -> SpreadPropertyPattern\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SpreadPropertyPattern'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"stringTypeAnnotation\\\":{\\\"!type\\\":\\\"fn() -> StringTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'StringTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"objectTypeProperty\\\":{\\\"!type\\\":\\\"fn(key: Literal|Identifier, value: Type, optional: boolean) -> ObjectTypeProperty\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ObjectTypeProperty'.\\\\nSuper types: Node, Printable\\\"},\\\"labeledStatement\\\":{\\\"!type\\\":\\\"fn(label: Identifier, body: Statement) -> LabeledStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'LabeledStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"typeAlias\\\":{\\\"!type\\\":\\\"fn(id: Identifier, typeParameters: TypeParameterDeclaration|null, right: Type) -> TypeAlias\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TypeAlias'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"exportSpecifier\\\":{\\\"!type\\\":\\\"fn(local: Identifier|null, exported: Identifier) -> ExportSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportSpecifier'.\\\\nSuper types: ModuleSpecifier, Specifier, Node, Printable\\\"},\\\"whileStatement\\\":{\\\"!type\\\":\\\"fn(test: Expression, body: Statement) -> WhileStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'WhileStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"functionDeclaration\\\":{\\\"!type\\\":\\\"fn(id: Identifier, params: [Pattern], body: BlockStatement|Expression, generator: boolean, expression: boolean) -> FunctionDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'FunctionDeclaration'.\\\\nSuper types: Function, Declaration, Statement, Node, Printable\\\"},\\\"stringLiteralTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(value: string, raw: string) -> StringLiteralTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'StringLiteralTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"callExpression\\\":{\\\"!type\\\":\\\"fn(callee: Expression, arguments: [Expression|SpreadElement]) -> CallExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'CallExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"assignmentPattern\\\":{\\\"!type\\\":\\\"fn(left: Pattern, right: Expression) -> AssignmentPattern\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'AssignmentPattern'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"declareVariable\\\":{\\\"!type\\\":\\\"fn(id: Identifier) -> DeclareVariable\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DeclareVariable'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"assignmentExpression\\\":{\\\"!type\\\":\\\"fn(operator: string, left: Pattern, right: Expression) -> AssignmentExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'AssignmentExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n operator (string) one of: =|+=|-=|*=|/=|%=|<<=|>>=|>>>=||=|^=|&=\\\\n\\\"},\\\"arrayPattern\\\":{\\\"!type\\\":\\\"fn(elements: [Pattern|SpreadElement|null]) -> ArrayPattern\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ArrayPattern'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"generatorExpression\\\":{\\\"!type\\\":\\\"fn(body: Expression, blocks: [ComprehensionBlock], filter: Expression|null) -> GeneratorExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'GeneratorExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"forStatement\\\":{\\\"!type\\\":\\\"fn(init: VariableDeclaration|Expression|null, test: Expression|null, update: Expression|null, body: Statement) -> ForStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ForStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"graphExpression\\\":{\\\"!type\\\":\\\"fn(index: number, expression: Literal) -> GraphExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'GraphExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n ${name} (number) must be >= 0\\\"},\\\"commentLine\\\":{\\\"!type\\\":\\\"fn(value: string, leading: boolean, trailing: boolean) -> CommentLine\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'CommentLine'.\\\\nSuper types: Comment, Printable\\\"},\\\"functionExpression\\\":{\\\"!type\\\":\\\"fn(id: Identifier|null, params: [Pattern], body: BlockStatement|Expression, generator: boolean, expression: boolean) -> FunctionExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'FunctionExpression'.\\\\nSuper types: Function, Expression, Pattern, Node, Printable\\\"},\\\"thisExpression\\\":{\\\"!type\\\":\\\"fn() -> ThisExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ThisExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"jsxOpeningElement\\\":{\\\"!type\\\":\\\"fn(name: JSXIdentifier|JSXNamespacedName|JSXMemberExpression, attributes: [JSXAttribute|JSXSpreadAttribute], selfClosing: boolean) -> JSXOpeningElement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXOpeningElement'.\\\\nSuper types: Node, Printable\\\"},\\\"exportNamedDeclaration\\\":{\\\"!type\\\":\\\"fn(declaration: Declaration|null, specifiers: [ExportSpecifier], source: Literal|null) -> ExportNamedDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportNamedDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"mixedTypeAnnotation\\\":{\\\"!type\\\":\\\"fn() -> MixedTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'MixedTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"objectTypeCallProperty\\\":{\\\"!type\\\":\\\"fn(value: FunctionTypeAnnotation) -> ObjectTypeCallProperty\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ObjectTypeCallProperty'.\\\\nSuper types: Node, Printable\\\"},\\\"classBody\\\":{\\\"!type\\\":\\\"fn(body: [MethodDefinition|VariableDeclarator|ClassPropertyDefinition|ClassProperty]) -> ClassBody\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ClassBody'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"position\\\":{\\\"!type\\\":\\\"fn(line: number, column: number) -> Position\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Position'.\\\\n\\\\n ${name} (number) must be >= 1${name} (number) must be >= 0\\\"},\\\"importSpecifier\\\":{\\\"!type\\\":\\\"fn(imported: Identifier, local: Identifier|null) -> ImportSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ImportSpecifier'.\\\\nSuper types: ModuleSpecifier, Specifier, Node, Printable\\\"},\\\"jsxExpressionContainer\\\":{\\\"!type\\\":\\\"fn(expression: Expression) -> JSXExpressionContainer\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXExpressionContainer'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"booleanTypeAnnotation\\\":{\\\"!type\\\":\\\"fn() -> BooleanTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'BooleanTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"classProperty\\\":{\\\"!type\\\":\\\"fn(key: Literal|Identifier|Expression, value: Expression|null, typeAnnotation: TypeAnnotation|null, static: boolean) -> ClassProperty\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ClassProperty'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"withStatement\\\":{\\\"!type\\\":\\\"fn(object: Expression, body: Statement) -> WithStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'WithStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"typeAnnotation\\\":{\\\"!type\\\":\\\"fn(typeAnnotation: Type) -> TypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TypeAnnotation'.\\\\nSuper types: Node, Printable\\\"},\\\"variableDeclarator\\\":{\\\"!type\\\":\\\"fn(id: Pattern, init: Expression|null) -> VariableDeclarator\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'VariableDeclarator'.\\\\nSuper types: Node, Printable\\\"},\\\"exportDeclaration\\\":{\\\"!type\\\":\\\"fn(default: boolean, declaration: Declaration|Expression|null, specifiers: [ExportSpecifier|ExportBatchSpecifier], source: Literal|null) -> ExportDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"jsxAttribute\\\":{\\\"!type\\\":\\\"fn(name: JSXIdentifier|JSXNamespacedName, value: Literal|JSXExpressionContainer|null) -> JSXAttribute\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXAttribute'.\\\\nSuper types: Node, Printable\\\"},\\\"spreadElementPattern\\\":{\\\"!type\\\":\\\"fn(argument: Pattern) -> SpreadElementPattern\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SpreadElementPattern'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"jsxIdentifier\\\":{\\\"!type\\\":\\\"fn(name: string) -> JSXIdentifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXIdentifier'.\\\\nSuper types: Identifier, Expression, Pattern, Node, Printable\\\"},\\\"objectTypeIndexer\\\":{\\\"!type\\\":\\\"fn(id: Identifier, key: Type, value: Type) -> ObjectTypeIndexer\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ObjectTypeIndexer'.\\\\nSuper types: Node, Printable\\\"},\\\"block\\\":{\\\"!type\\\":\\\"fn(value: string, leading: boolean, trailing: boolean) -> Block\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Block'.\\\\nSuper types: Comment, Printable\\\"},\\\"declareModule\\\":{\\\"!type\\\":\\\"fn(id: Identifier|Literal, body: BlockStatement) -> DeclareModule\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DeclareModule'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"exportDefaultDeclaration\\\":{\\\"!type\\\":\\\"fn(declaration: Declaration|Expression) -> ExportDefaultDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportDefaultDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"emptyStatement\\\":{\\\"!type\\\":\\\"fn() -> EmptyStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'EmptyStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"sequenceExpression\\\":{\\\"!type\\\":\\\"fn(expressions: [Expression]) -> SequenceExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SequenceExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"spreadProperty\\\":{\\\"!type\\\":\\\"fn(argument: Expression) -> SpreadProperty\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SpreadProperty'.\\\\nSuper types: Node, Printable\\\"},\\\"awaitExpression\\\":{\\\"!type\\\":\\\"fn(argument: Expression|null, all: boolean) -> AwaitExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'AwaitExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"classDeclaration\\\":{\\\"!type\\\":\\\"fn(id: Identifier|null, body: ClassBody, superClass: Expression|null) -> ClassDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ClassDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"literal\\\":{\\\"!type\\\":\\\"fn(value: string|boolean|null|number|RegExp) -> Literal\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Literal'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"letExpression\\\":{\\\"!type\\\":\\\"fn(head: [VariableDeclarator], body: Expression) -> LetExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'LetExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"exportAllDeclaration\\\":{\\\"!type\\\":\\\"fn(exported: Identifier|null, source: Literal) -> ExportAllDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportAllDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"forOfStatement\\\":{\\\"!type\\\":\\\"fn(left: VariableDeclaration|Expression, right: Expression, body: Statement) -> ForOfStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ForOfStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"doWhileStatement\\\":{\\\"!type\\\":\\\"fn(body: Statement, test: Expression) -> DoWhileStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DoWhileStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"booleanLiteralTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(value: boolean, raw: string) -> BooleanLiteralTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'BooleanLiteralTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"genericTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(id: Identifier|QualifiedTypeIdentifier, typeParameters: TypeParameterInstantiation|null) -> GenericTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'GenericTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"declareExportDeclaration\\\":{\\\"!type\\\":\\\"fn(default: boolean, declaration: DeclareVariable|DeclareFunction|DeclareClass|Type|null, specifiers: [ExportSpecifier|ExportBatchSpecifier], source: Literal|null) -> DeclareExportDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DeclareExportDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"classExpression\\\":{\\\"!type\\\":\\\"fn(id: Identifier|null, body: ClassBody, superClass: Expression|null) -> ClassExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ClassExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"templateElement\\\":{\\\"!type\\\":\\\"fn(value: TemplateElementValue, tail: boolean) -> TemplateElement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TemplateElement'.\\\\nSuper types: Node, Printable\\\\n\\\\n value (object) has form {cooked: string, raw: string}\\\"},\\\"intersectionTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(types: [Type]) -> IntersectionTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'IntersectionTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"noop\\\":{\\\"!type\\\":\\\"fn() -> Noop\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Noop'.\\\\nSuper types: Node, Printable\\\"},\\\"jsxSpreadAttribute\\\":{\\\"!type\\\":\\\"fn(argument: Expression) -> JSXSpreadAttribute\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXSpreadAttribute'.\\\\nSuper types: Node, Printable\\\"},\\\"line\\\":{\\\"!type\\\":\\\"fn(value: string, leading: boolean, trailing: boolean) -> Line\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Line'.\\\\nSuper types: Comment, Printable\\\"},\\\"jsxText\\\":{\\\"!type\\\":\\\"fn(value: string) -> JSXText\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXText'.\\\\nSuper types: Literal, Expression, Pattern, Node, Printable\\\"},\\\"voidTypeAnnotation\\\":{\\\"!type\\\":\\\"fn() -> VoidTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'VoidTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"comprehensionExpression\\\":{\\\"!type\\\":\\\"fn(body: Expression, blocks: [ComprehensionBlock], filter: Expression|null) -> ComprehensionExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ComprehensionExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"jsxClosingElement\\\":{\\\"!type\\\":\\\"fn(name: JSXIdentifier|JSXNamespacedName|JSXMemberExpression) -> JSXClosingElement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'JSXClosingElement'.\\\\nSuper types: Node, Printable\\\"},\\\"typeParameterDeclaration\\\":{\\\"!type\\\":\\\"fn(params: [Identifier]) -> TypeParameterDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TypeParameterDeclaration'.\\\\nSuper types: Node, Printable\\\"},\\\"super\\\":{\\\"!type\\\":\\\"fn() -> Super\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Super'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"numberTypeAnnotation\\\":{\\\"!type\\\":\\\"fn() -> NumberTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'NumberTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"throwStatement\\\":{\\\"!type\\\":\\\"fn(argument: Expression) -> ThrowStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ThrowStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"catchClause\\\":{\\\"!type\\\":\\\"fn(param: Pattern, guard: Expression|null, body: BlockStatement) -> CatchClause\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'CatchClause'.\\\\nSuper types: Node, Printable\\\"},\\\"variableDeclaration\\\":{\\\"!type\\\":\\\"fn(kind: string, declarations: [VariableDeclarator|Identifier]) -> VariableDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'VariableDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\\n\\\\n kind (string) one of: var|let|const\\\\n\\\"},\\\"exportDefaultSpecifier\\\":{\\\"!type\\\":\\\"fn(exported: Identifier) -> ExportDefaultSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportDefaultSpecifier'.\\\\nSuper types: Specifier, Node, Printable\\\"},\\\"newExpression\\\":{\\\"!type\\\":\\\"fn(callee: Expression, arguments: [Expression|SpreadElement]) -> NewExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'NewExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"graphIndexExpression\\\":{\\\"!type\\\":\\\"fn(index: number) -> GraphIndexExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'GraphIndexExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n ${name} (number) must be >= 0\\\"},\\\"updateExpression\\\":{\\\"!type\\\":\\\"fn(operator: string, argument: Expression, prefix: boolean) -> UpdateExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'UpdateExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n operator (string) one of: ++|--\\\\n\\\"},\\\"commentBlock\\\":{\\\"!type\\\":\\\"fn(value: string, leading: boolean, trailing: boolean) -> CommentBlock\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'CommentBlock'.\\\\nSuper types: Comment, Printable\\\"},\\\"typeCastExpression\\\":{\\\"!type\\\":\\\"fn(expression: Expression, typeAnnotation: TypeAnnotation) -> TypeCastExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TypeCastExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"property\\\":{\\\"!type\\\":\\\"fn(kind: string, key: Literal|Identifier|Expression, value: Expression|Pattern) -> Property\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Property'.\\\\nSuper types: Node, Printable\\\\n\\\\n kind (string) one of: init|get|set\\\\n\\\"},\\\"interfaceDeclaration\\\":{\\\"!type\\\":\\\"fn(id: Identifier, body: ObjectTypeAnnotation, extends: [InterfaceExtends]) -> InterfaceDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'InterfaceDeclaration'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"functionTypeParam\\\":{\\\"!type\\\":\\\"fn(name: Identifier, typeAnnotation: Type, optional: boolean) -> FunctionTypeParam\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'FunctionTypeParam'.\\\\nSuper types: Node, Printable\\\"},\\\"returnStatement\\\":{\\\"!type\\\":\\\"fn(argument: Expression|null) -> ReturnStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ReturnStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"exportBatchSpecifier\\\":{\\\"!type\\\":\\\"fn() -> ExportBatchSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ExportBatchSpecifier'.\\\\nSuper types: Specifier, Node, Printable\\\"},\\\"decorator\\\":{\\\"!type\\\":\\\"fn(expression: Expression) -> Decorator\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'Decorator'.\\\\nSuper types: Node, Printable\\\"},\\\"sourceLocation\\\":{\\\"!type\\\":\\\"fn(start: Position, end: Position, source: string|null) -> SourceLocation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SourceLocation'.\\\"},\\\"file\\\":{\\\"!type\\\":\\\"fn(program: Program) -> File\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'File'.\\\\nSuper types: Node, Printable\\\"},\\\"binaryExpression\\\":{\\\"!type\\\":\\\"fn(operator: string, left: Expression, right: Expression) -> BinaryExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'BinaryExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n operator (string) one of: ==|!=|===|!==|<|<=|>|>=|<<|>>|>>>|+|-|*|/|%|&|||^|in|instanceof|..\\\\n\\\"},\\\"propertyPattern\\\":{\\\"!type\\\":\\\"fn(key: Literal|Identifier|Expression, pattern: Pattern) -> PropertyPattern\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'PropertyPattern'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"importDeclaration\\\":{\\\"!type\\\":\\\"fn(specifiers: [ImportSpecifier|ImportNamespaceSpecifier|ImportDefaultSpecifier], source: Literal) -> ImportDeclaration\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ImportDeclaration'.\\\\nSuper types: Declaration, Statement, Node, Printable\\\"},\\\"doExpression\\\":{\\\"!type\\\":\\\"fn(body: [Statement]) -> DoExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'DoExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"restElement\\\":{\\\"!type\\\":\\\"fn(argument: Pattern) -> RestElement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'RestElement'.\\\\nSuper types: Pattern, Node, Printable\\\"},\\\"anyTypeAnnotation\\\":{\\\"!type\\\":\\\"fn() -> AnyTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'AnyTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"templateLiteral\\\":{\\\"!type\\\":\\\"fn(quasis: [TemplateElement], expressions: [Expression]) -> TemplateLiteral\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TemplateLiteral'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"nullableTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(typeAnnotation: Type) -> NullableTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'NullableTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"continueStatement\\\":{\\\"!type\\\":\\\"fn(label: Identifier|null) -> ContinueStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ContinueStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"arrayExpression\\\":{\\\"!type\\\":\\\"fn(elements: [Expression|SpreadElement|RestElement|null]) -> ArrayExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ArrayExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"classImplements\\\":{\\\"!type\\\":\\\"fn(id: Identifier) -> ClassImplements\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ClassImplements'.\\\\nSuper types: Node, Printable\\\"},\\\"objectTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(properties: [ObjectTypeProperty]) -> ObjectTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ObjectTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"memberExpression\\\":{\\\"!type\\\":\\\"fn(object: Expression, property: Identifier|Expression, computed: boolean) -> MemberExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'MemberExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"comprehensionBlock\\\":{\\\"!type\\\":\\\"fn(left: Pattern, right: Expression, each: boolean) -> ComprehensionBlock\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ComprehensionBlock'.\\\\nSuper types: Node, Printable\\\"},\\\"breakStatement\\\":{\\\"!type\\\":\\\"fn(label: Identifier|null) -> BreakStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'BreakStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"arrowFunctionExpression\\\":{\\\"!type\\\":\\\"fn(params: [Pattern], body: BlockStatement|Expression, expression: boolean) -> ArrowFunctionExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ArrowFunctionExpression'.\\\\nSuper types: Function, Expression, Pattern, Node, Printable\\\"},\\\"switchCase\\\":{\\\"!type\\\":\\\"fn(test: Expression|null, consequent: [Statement]) -> SwitchCase\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'SwitchCase'.\\\\nSuper types: Node, Printable\\\"},\\\"blockStatement\\\":{\\\"!type\\\":\\\"fn(body: [Statement]) -> BlockStatement\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'BlockStatement'.\\\\nSuper types: Statement, Node, Printable\\\"},\\\"unaryExpression\\\":{\\\"!type\\\":\\\"fn(operator: string, argument: Expression, prefix: boolean) -> UnaryExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'UnaryExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\\n\\\\n operator (string) one of: -|+|!|~|typeof|void|delete\\\\n\\\"},\\\"objectExpression\\\":{\\\"!type\\\":\\\"fn(properties: [Property|SpreadProperty]) -> ObjectExpression\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ObjectExpression'.\\\\nSuper types: Expression, Pattern, Node, Printable\\\"},\\\"tupleTypeAnnotation\\\":{\\\"!type\\\":\\\"fn(types: [Type]) -> TupleTypeAnnotation\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'TupleTypeAnnotation'.\\\\nSuper types: Type, Node, Printable\\\"},\\\"interfaceExtends\\\":{\\\"!type\\\":\\\"fn(id: Identifier) -> InterfaceExtends\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'InterfaceExtends'.\\\\nSuper types: Node, Printable\\\"},\\\"importDefaultSpecifier\\\":{\\\"!type\\\":\\\"fn(local: Identifier|null) -> ImportDefaultSpecifier\\\",\\\"!doc\\\":\\\"Builds an AST node of type 'ImportDefaultSpecifier'.\\\\nSuper types: ModuleSpecifier, Specifier, Node, Printable\\\"}}},\\\"Collection\\\":{\\\"!type:\\\":\\\"fn(source: [+NodePath], parent: +Collection)\\\",\\\"prototype\\\":{\\\"filter\\\":{\\\"!type\\\":\\\"fn(callback: fn(path: +NodePath) -> bool) -> +Collection\\\",\\\"!doc\\\":\\\"Returns a new collection containing the nodes for which the callback returns true.\\\",\\\"!effects\\\":[\\\"call !0 this=+NodePath +NodePath\\\"]},\\\"forEach\\\":{\\\"!type\\\":\\\"fn(callback: fn(path: +NodePath)) -> !this\\\",\\\"!doc\\\":\\\"Executes callback for each NodePath in the collection.\\\",\\\"!effects\\\":[\\\"call !0 this=+NodePath +NodePath\\\"]},\\\"map\\\":{\\\"!type\\\":\\\"fn(callback: fn(path: +NodePath) -> +NodePath|[+NodePath]) -> +Collection\\\",\\\"!doc\\\":\\\"Executes the callback for every path in the collection and returns a\\\\nnew collection from the return values (which must be paths).\\\\n\\\\nThe callback can return null to remove the element from the new collection.\\\\n\\\\nIf an array is returned, it will be flattened into the result colletion.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=+NodePath +NodePath\\\"]},\\\"size\\\":{\\\"!type\\\":\\\"fn() -> number\\\",\\\"!doc\\\":\\\"Returns the number of elements in this collection.\\\"},\\\"nodes\\\":{\\\"!type\\\":\\\"fn() -> [ASTNode]\\\",\\\"!doc\\\":\\\"Returns an array of AST nodes in this collection.\\\"},\\\"paths\\\":{\\\"!type\\\":\\\"fn() -> [NodePath]\\\",\\\"!doc\\\":\\\"Returns an array of NodePaths in this this collection.\\\"},\\\"toSource\\\":{\\\"!type\\\":\\\"fn(options?: object) -> string\\\",\\\"!doc\\\":\\\"Converts the AST back to a string, using recast. The options are directly passed to recast's printer.\\\"},\\\"at\\\":{\\\"!type\\\":\\\"fn(index: number) -> +Collection\\\",\\\"!doc\\\":\\\"Returns a new collection containing only the element at the position\\\\n`index`. In case of a negative index, the element is taken from the end.\\\\n\\\"},\\\"get\\\":{\\\"!type\\\":\\\"fn(name: string|number) -> +NodePath\\\",\\\"!doc\\\":\\\"Calls \\\\\\\"get\\\\\\\" on the first path (same as \\\\\\\"collection.paths(0).get(...)\\\\\\\").\\\"},\\\"find\\\":{\\\"!type\\\":\\\"fn(type: TypeDefinition, filter?: object) -> +Collection\\\",\\\"!doc\\\":\\\"Finds descendants of a specific type within the Nodes of this collection.\\\"},\\\"closestScope\\\":{\\\"!type\\\":\\\"fn() -> +Collection\\\",\\\"!doc\\\":\\\"Returns a collection containing the Paths that create the scope which contains the selected Nodes.\\\"},\\\"closest\\\":{\\\"!type\\\":\\\"fn(type: TypeDefinition, filter?: object) -> +Collection\\\",\\\"!doc\\\":\\\"For each node in the collection, traverses the AST up and finds the closest node that matches the type and filter.\\\"},\\\"replaceWith\\\":{\\\"!type\\\":\\\"fn(nodes: ASTNode|fn(path: +NodePath, index: number) -> ASTNode|[ASTNode]) -> !this\\\",\\\"!doc\\\":\\\"Replaces the selected nodes with the provided node(s). If a function is\\\\nprovided, it is executed for every node and the node is replaced with\\\\nthe return value of the function.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=+NodePath +NodePath number\\\"]},\\\"insertBefore\\\":{\\\"!type\\\":\\\"fn(nodes: ASTNode|[ASTNode]|fn(path: +NodePath, index: number) -> ASTNode|[ASTNode]) -> !this\\\",\\\"!doc\\\":\\\"Inserts the new node(s) before each of the selected nodes. If a function\\\\nis provided, it is executed for every node and return value is inserted\\\\nbefore that node.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=+NodePath +NodePath\\\"]},\\\"insertAfter\\\":{\\\"!type\\\":\\\"fn(nodes: ASTNode|[ASTNode]|fn(path: +NodePath, index: number) -> ASTNode|[ASTNode]) -> !this\\\",\\\"!doc\\\":\\\"Inserts the new node(s) after each of the selected nodes. If a function\\\\nis provided, it is executed for every node and return value is inserted\\\\nafter that node.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=+NodePath +NodePath\\\"]},\\\"remove\\\":{\\\"!type\\\":\\\"fn() -> !this\\\",\\\"!doc\\\":\\\"Calls \\\\\\\"prune\\\\\\\" on every selected NodePath.\\\"}}},\\\"NodePath\\\":{\\\"!type\\\":\\\"fn(value: ASTNode|[ASTNode], parentPath: +NodePath, name: string)\\\",\\\"!effects\\\":[\\\"propagate !0 !this.value\\\"],\\\"prototype\\\":{\\\"parentPath\\\":\\\"+NodePath\\\",\\\"name\\\":\\\"string\\\",\\\"node\\\":{\\\"!type\\\":\\\"ASTNode\\\",\\\"!doc\\\":\\\"The value of the first ancestor NodePath whose value is a Node.\\\"},\\\"parent\\\":{\\\"!type\\\":\\\"+NodePath\\\",\\\"!doc\\\":\\\"The first ancestor Path whose value is a Node distinct from this.node.\\\"},\\\"scope\\\":{\\\"!type\\\":\\\"+Scope\\\",\\\"!doc\\\":\\\"The closest enclosing scope that governs this node.\\\"},\\\"replace\\\":{\\\"!type\\\":\\\"fn(newNode?: ASTNode|[ASTNode])\\\",\\\"!doc\\\":\\\"Replaces the Node(s) represented by this Path, or removes it if no argument is passed.\\\"},\\\"prune\\\":{\\\"!type\\\":\\\"fn()\\\",\\\"!doc\\\":\\\"Removes this Node and any ancestor that would become \\\\\\\"empty\\\\\\\".\\\"},\\\"getValueProperty\\\":{\\\"!type\\\":\\\"fn(name: string) -> ?\\\",\\\"!doc\\\":\\\"Returns the value of of that property. This is different from 'path.node.value' because\\\\nit will return the default value for that field as defined in the Node definition.\\\\n\\\"},\\\"each\\\":{\\\"!type\\\":\\\"fn(callback: fn(childPath: +NodePath), context?: ?)\\\",\\\"!doc\\\":\\\"If the Path represents an array of nodes, applies the provided function to each\\\\nNode in the array.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.value.<i> !this\\\"]},\\\"map\\\":{\\\"!type\\\":\\\"fn(callback: fn(childPath: +NodePath) -> ?, context?: ?) -> [?]\\\",\\\"!doc\\\":\\\"If the Path represents an array of nodes, applies the provided function to each\\\\nNode in the array and returns an array of the results.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.value.<i> !this\\\"]},\\\"filter\\\":{\\\"!type\\\":\\\"fn(callback: fn(childPath: +NodePath) -> bool, context?: ?) -> [+NodePath]\\\",\\\"!doc\\\":\\\"If the Path represents an array of nodes, applies the provided function to each\\\\nNode in the array and returns an array of Paths for which the callback returned true.\\\\n\\\",\\\"!effects\\\":[\\\"call !0 this=!1 !this.value.<i> !this\\\"]},\\\"shift\\\":{\\\"!type\\\":\\\"fn() -> +NodePath\\\",\\\"!doc\\\":\\\"If the Path represents an array of nodes, removes the first Node in that array and returns it.\\\\n\\\"},\\\"unshift\\\":{\\\"!type\\\":\\\"fn(newNode: ASTNode)\\\"},\\\"push\\\":{\\\"!type\\\":\\\"fn(newNode: ASTNode)\\\"},\\\"pop\\\":{\\\"!type\\\":\\\"fn() -> NodePath\\\"},\\\"insertAt\\\":{\\\"!type\\\":\\\"fn(index: number, node: ASTNode)\\\"},\\\"insertBefore\\\":{\\\"!type\\\":\\\"fn(node: ASTNode)\\\"},\\\"insertAfter\\\":{\\\"!type\\\":\\\"fn(node: ASTNode)\\\"}}},\\\"ASTNode\\\":{\\\"type\\\":{\\\"!type\\\":\\\"string\\\",\\\"!doc\\\":\\\"The type of this AST node.\\\"}},\\\"Scope\\\":{\\\"!type\\\":\\\"fn(path: +NodePath, parentScope: +Scope)\\\",\\\"isEstablishedBy\\\":\\\"fn(node: ASTNode) -> bool\\\",\\\"prototype\\\":{\\\"declares\\\":\\\"fn(name: string) -> bool\\\",\\\"declaresType\\\":\\\"fn(name: string) -> bool\\\",\\\"declareTemporary\\\":\\\"fn(prefix: string) -> Identifier\\\",\\\"injectTemporary\\\":\\\"fn(prefix: string, init?: ASTNode) -> Identifier\\\",\\\"getBindings\\\":\\\"fn() -> [ASTNode]\\\",\\\"getTypes\\\":\\\"fn() -> [ASTNode]\\\",\\\"lookup\\\":\\\"fn(name: string) -> +Scope\\\",\\\"lookupType\\\":\\\"fn(name: string) -> +Scope\\\"},\\\"getGlobalScope\\\":\\\"fn() -> +Scope\\\"},\\\"ModuleSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ConditionalExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Node\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"MixedTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLAttributeSelector\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXNamespacedName\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"GenericTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLFunctionQualifiedIdentifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ClassPropertyDefinition\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"NullableTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ForInStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"YieldExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ClassProperty\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLDefaultDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TemplateElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportDefaultDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TupleTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"GraphExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"MemberExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ImportDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"File\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXSpreadAttribute\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLName\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ClassExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TemplateLiteral\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ClassImplements\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TypeAlias\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"StringLiteralTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TaggedTemplateExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Identifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"BooleanLiteralTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"MethodDefinition\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Line\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"GeneratorExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"LetStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Literal\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"BooleanTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXAttribute\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportNamespaceSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ArrayTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"BlockStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"WithStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLProcessingInstruction\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SpreadPropertyPattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"WhileStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ThrowStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"InterfaceDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TypeofTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"LetExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ContinueStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Printable\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ThisExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"IntersectionTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXClosingElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DeclareFunction\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"VariableDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"BreakStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ImportSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ParenthesizedExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"RestElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Specifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ArrayExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLAnyName\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ObjectTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportAllDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SourceLocation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Statement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Position\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ObjectExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Program\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Comment\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"AssignmentPattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ObjectTypeIndexer\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ArrowFunctionExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLAttribute\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Noop\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DeclareClass\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLEndTag\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXIdentifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"VoidTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ComprehensionBlock\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"FunctionTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ComprehensionExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"MetaProperty\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLQualifiedIdentifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DoWhileStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"EmptyStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"VariableDeclarator\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ObjectPattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"AssignmentExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Declaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DoExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"GraphIndexExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DeclareVariable\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ObjectTypeProperty\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"IfStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"BindExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"LogicalExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"CommentLine\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ObjectTypeCallProperty\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"FunctionDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"NewExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TypeCastExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLStartTag\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLPointTag\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Pattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ImportDefaultSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLFilterExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLEscape\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXEmptyExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SequenceExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"InterfaceExtends\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"PropertyPattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"CatchClause\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SpreadElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"FunctionTypeParam\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Property\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXOpeningElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"StringTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ForStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Decorator\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SpreadElementPattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXMemberExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"FunctionExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"BinaryExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TryStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Expression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportNamedDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SwitchStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Block\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportBatchSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExpressionStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ArrayPattern\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLList\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ReturnStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"CallExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DeclareModule\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"NumberLiteralTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Type\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TypeParameterDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLText\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Function\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"UnaryExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XML\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"Super\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TypeParameterInstantiation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLComment\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"MemberTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SwitchCase\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"AwaitExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ExportDefaultSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLElement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"AnyTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"CommentBlock\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ClassBody\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ImportNamespaceSpecifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXExpressionContainer\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DeclareExportDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"UnionTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"XMLCdata\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"JSXText\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"QualifiedTypeIdentifier\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"DebuggerStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ForOfStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"LabeledStatement\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"SpreadProperty\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"UpdateExpression\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"ClassDeclaration\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"NumberTypeAnnotation\\\":{\\\"!proto\\\":\\\"ASTNode\\\"},\\\"TemplateElementValue\\\":{\\\"cooked\\\":\\\"string\\\",\\\"raw\\\":\\\"string\\\"},\\\"TypeDefinition\\\":{\\\"name\\\":\\\"string\\\",\\\"check\\\":\\\"fn(node: Node, deep: ?) -> bool\\\"}}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGVmcy9qc2NvZGVzaGlmdC5qc29uLmpzIiwic291cmNlcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/defs/jscodeshift.json\n");

/***/ })

}]);