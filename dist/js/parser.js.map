{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/syntax/head.ts","webpack:///./js/lexical/index.ts","webpack:///./js/syntax/index.ts","webpack:///./js/syntax/expression.ts","webpack:///./js/character.ts","webpack:///./js/tokenizer.ts","webpack:///./js/lexical/head.ts","webpack:///./js/syntax/declaration.ts","webpack:///(webpack)/buildin/module.js","webpack:///./js/parser.ts","webpack:///./js/syntax/pattern.ts","webpack:///./js/syntax/statement.ts","webpack:///./js/syntax/module_declaration.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","type_punctuator","TOKEN_TYPE_ENUMS","Punctuator","type_keyword","Keyword","type_identifier","Identifier","_Punctuator","values","unshift","_Or","_Keyword","_Identifier","_Pattern","args","OPERATOR_ID","_calc_nth","props","nth","Cover","length","Mark","prop","_key","undefined","data","origin","operands","sub_operators","pipe","this","_pipes","push","walk","walker","bind_env","_walker","_bind_env","_factors","operand","Operator","parts","replace","split","slice","map","parents","factor","pipes","result","concat","attach","type","prev_item","root","getNode","reduce","res","value_node","console","warn","parent","child","setWrap","records","getDeepNodes","children","factors","getNextNodes","Array","apply","context","index","MATCHED_RECORD","_get_wrapper_function","_Option","Option","some","Or","_Series","Series","_NonCapturing","NonCapturing","_NonCollecting","NonCollecting","_Loop","Loop","_Mark","NODES","Grouping","node","grouping","range","loc","Directive","expression","directive","Script","body","sourceType","Module","_get_adapt","eval","createMatchTree","block_list","prevent_update","item","wrapper","collectors","handlers","overload","precedences","filters","validators","indexOf","filter","handler","validator","collector","precedence","Number","_collector","nodes","operator","last_node","matched_record","_Context","parser","state_stack","wrap","unwrap","store","restore_point","arguments","restore","point","getToken","tokens","pop","FutureReservedWord","StrictModeReservedWord","RestrictedWord","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","_if_strict_throw_err","token","err","_if_reserved_throw_err","validateIdentifier","THROW_RESTRICT_WORDS_PATTERN","THROW_STRICT_RESERVED_WORDS_PATTERN","IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN","EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN","IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN","EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN","validateAssignment","validateBinding","binding_set","validateLineTerminator","collected","right","_next","next_token","start","line","end","join_content","success","content","TYPE_ALIAS","ASSIGNMENT_PUNCTUATORS_PATTERN","AWAIT_LIST","MODULE_ITEM_PATTERN","STATEMANT_LIST_ITEM_PATTERN","RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN","TOPLEVEL_ITEM_PATTERN","isAligned","left","attachLocation","source","reinterpretKeywordAsIdentifier","tokenizer","_bak","identifier","configurable","reinterpretIdentifierAsKeyword","_Validate","is_right_parentheses","is_right_brackets","is_right_braces","String","Boolean","Numeric","RegularExpression","Template","TemplateElement","Comments","Null","NUMERIC_KEYWORD_MAP","TOKEN_TYPE_MAPPERS","octal_escape","_state","_attach","scope","code","octalValue","input","charCodeAt","octal","len","fromCharCode","octal_escape_tree","strbase_match_tree","_str","scanHex","not_allow_octal_escape","_error","template_curly_stack","template_base","match_tree","_end","shift","scanner","escape_scan","PUNCTUATORS","bound","REGEXP_DESCRIPTOR","class_marker","regex","pattern","flags","inIdentifierPart","column","PUNCTUATORS_TREE","createSearchTree","PRIOR_REGEXP_PUNCTUATORS_TREE","EXPRESSION_TREE","EXPRESSION_ITEM_PATTERN","DECLARATION_ITEM_PATTERN","STATEMENT_ITEM_PATTERN","STATEMENT_LIST_ITEM_PATTERN","Expressions","descriptor","patterns","isStatementListItem","isExpression","isDeclaration","isStatement","isModuleItem","SYNTAX_TREE","extract_success","getLiteral","parse_value","raw","parse_next_statement","parseCustom","get_inner_group","parse_and_extract","getStringLiteral","getRegularLiteral","RegExp","e","token_hooks","context_stack","_scope","parseArrayPattern","parseObjectPattern","walk_primary_expression","parseRange","PRIMARY_EXPRESSION_TREE","ARGUMENTS_PATTERN","parseNode","ARGUMENTS_TREE","PARAMS_PATTERN","PARAMS_TREE","kind","params","params_count","splice","BODY_PATTERN","generator","async","body_context","block","BlockStatement","FUNCTION_BODY_PATTERN","PrimaryExpressions","PROPERTIES_TREE","_","expressions","quasis","tail","cooked","parseRangeAsExpression","__","parse_params","superClass","METHOD_DEFINITIONS_TREE","parseExpression","elements","ARRAY_ELEMENTS_TREE","properties","OBJECT_PROPERTIES_TREE","tag","quasi","computed","meta","callee","first_token","first_token_type","argument","prefix","createNode","test","delegate","expr","SequenceExpression","COMPUTED_PROPERTY_NAME_PATTERN","LITERAL_PROPERTY_NAME_PATTERN","PROPERTY_NAME_PATTERN","MethodDefinitions","MethodDefinition","_prev","static","_static","FunctionExpression","Arguments","Params","ArrayElements","Properties","method","shorthand","ObjectProperties","window","test1","UNIT_EXPRESSION_TREE","Patterns","type_name","IdentifierStart","IdentifierPart","testCodePoint","regexp","testUnicodeEscape","cp","hexValue","fromCodePoint","ch","decimalValue","binaryValue","isWhiteSpace","isLineTerminator","inIdentifierStart","log","options","save_comments","error_logs","init","line_number","line_start","terminator_stack","tokenize","nextToken","_nextToken","hook","createToken","match","prev_node","target","nextIdentifier","str","is_primary_expr_start","nextPunctuator","maybe_regex","nextNumeric","number","_get_token","_get_error","message","error","part","char","path","backslash_count","self","has_escape","_finally","get_variable_declarator","VARIABLE_DECLARATOR_TREE","VariableDeclarators","Success","reinterpreat_expression_as_declaration","Declarations","declarations","webpackPolyfill","deprecate","paths","time","cbfun","timeEnd","padding_token","parse","parseScript","parseModule","_parse","script","parseRangeAsNode","lexcal_terminator","environments","begin","extreme","state","cursor","backflow_tape","finallize","longest","longest_precedence","extreme_precedence","before_token","after_token","next","minimum","explore","matched","get_records","matched_node","has_backflow","type_node","alias","offset","restore_volatile","start_token","end_token","record","PETTERN_ELEMENTS_TREE","PATTERN_PROPERTIES_TREE","PatternElements","PatternProperties","ArrayPattern","is_binding","ObjectPattern","AssignmentPattern","Property","_value","VariableDeclaration","BLOCK_STATEMENT_PATTERN","GROUPING_EXPRESSION","Statements","label","keyword","iterator","FOR_ITERATOR_TREE","consequent","alternate","label_name","label_set","discriminant","cases","has_default","param","finalizer","ForIterator","ForStatement","update","declarator","STRING_LITERAL_PATTERN","ImportSpecifiers","ImportSpecifier","imported","local","IMPORT_SPECIFIERS_TREE","EXPORT_SPECIFIERS_TREE","ExportSpecifier","exported","ModuleDeclarations","specifiers","declaration"],"mappings":"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","file":"js/parser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","\r\n\r\n\r\nimport {\r\n    NodeProp,\r\n    Cover as CoverInterface,\r\n    Mark as MarkInterface,\r\n    Node, Pipe, Connector,\r\n    Matched, CONTEXT, Context, Token, SourceLocation,\r\n    MATCHED,\r\n    /*PRECEDENCE_FEATURES,*/ PRECEDENCE, Precedence as PrecedenceInterface, MATCHED_RECORDS, Validate,\r\n} from '../interfaces';\r\n\r\nimport Tokenizer from \"../tokenizer\"\r\nimport { TOKEN_TYPE_ENUMS } from '../lexical/index'\r\nlet type_punctuator = TOKEN_TYPE_ENUMS.Punctuator;\r\nlet type_keyword = TOKEN_TYPE_ENUMS.Keyword;\r\nlet type_identifier = TOKEN_TYPE_ENUMS.Identifier;\r\n\r\n\r\nfunction _Punctuator(...values: Array<string | number>) {\r\n    values.unshift(type_punctuator);\r\n    return _Or(values);\r\n}\r\nfunction _Keyword(...values: Array<string | number>) {\r\n    values.unshift(type_keyword);\r\n    return _Or(values);\r\n}\r\nfunction _Identifier(...values: Array<string | number>) {\r\n    values.unshift(type_identifier);\r\n    return _Or(values);\r\n}\r\nfunction _Pattern(...args: Array<string | number>) {\r\n    return _Or(args);\r\n}\r\n\r\nimport Parser from '../parser'\r\nconst enum MATCH_MARKS {\r\n    BOUNDARY = \"\",\r\n    DEEPTH = \" DEEP\",\r\n    IDENTIFIER = \" ID\",\r\n    MATCH_END = \" END\",\r\n    TYPE_ONLY = \" TYPE\",\r\n    WALKER = \" WAL\",\r\n    TERMINAL = \" TER\"\r\n    /*\r\n    FOLLOW = \" FOLLOW\",\r\n    NOT = \" NOT\",\r\n    OR = \" OR\",\r\n    AND = \" AND\",*/\r\n}\r\nlet OPERATOR_ID = 0;\r\n\r\nfunction _calc_nth(props: Array<NodeProp>, key: string | Mark | Cover) {\r\n    let nth = 0;\r\n    if (!(key instanceof Cover) && props.length) {\r\n        key instanceof Mark && (key = key.key);\r\n        for (let i = props.length - 1; i >= 0; i--) {\r\n            let prop = props[i], _key = prop[0];\r\n            if (\r\n                _key === key\r\n                || _key instanceof Mark\r\n                && _key.key === key\r\n                && (_key.value !== undefined || _key.data !== Mark.prototype.data)\r\n            ) {\r\n                if (prop[1] === 0) {\r\n                    prop = props[i] = [prop[0], 1, prop[2]];\r\n                }\r\n                nth = prop[1] + 1;\r\n            } else if (\r\n                !(_key instanceof Cover && _key.origin === key)\r\n            ) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return nth;\r\n}\r\n\r\nabstract class Operator {\r\n    private _factors: Array<[string | number, Array<string | number>] | Operator | Mark>;\r\n    private _pipes: Array<Pipe>;\r\n    private _walker: Connector;\r\n    private _bind_env: boolean;\r\n    public sub_operators = [];\r\n    public test: (token: Token, index?: number) => boolean;\r\n    constructor(public operands: Operands) { }\r\n    public pipe(pipe: Pipe) {\r\n        if (this._pipes) {\r\n            this._pipes.push(pipe);\r\n        } else {\r\n            this._pipes = [pipe];\r\n        }\r\n        return this;\r\n    }\r\n    public walk(walker: Connector, bind_env?: boolean) {\r\n        this._walker = walker;\r\n        this._bind_env = !!bind_env;\r\n        return this;\r\n    }\r\n    public get factors() {\r\n        if (!this._factors) {\r\n            this._factors = [];\r\n            for (const operand of this.operands) {\r\n                if (operand instanceof Operator || operand instanceof Mark) {\r\n                    this._factors.push(operand);\r\n                } else {\r\n\r\n                    let parts = typeof operand === \"string\" ?\r\n                        operand.replace(/^\\s+|\\s+$/g, \"\").split(/\\s+/) :\r\n                        operand;\r\n                    this._factors.push(\r\n                        [\r\n                            parts[0],\r\n                            parts.length > 1\r\n                                ? parts.slice(1)\r\n                                : [MATCH_MARKS.TYPE_ONLY]\r\n                        ]);\r\n                }\r\n            }\r\n        }\r\n        return this._factors;\r\n    }\r\n    abstract attach(parents: IterationRecord, key: string | Cover, pipes?: Array<Pipe>): IterationRecord;\r\n\r\n    protected map(\r\n        parents: IterationRecord,\r\n        factor: [string | number, Array<string | number>] | Operator | Mark,\r\n        key: string | Cover,\r\n        pipes?: Array<Pipe>\r\n    ) {\r\n        let result: IterationRecord = [];\r\n        let _pipes = pipes\r\n            ? this._pipes ?\r\n                this._pipes.concat(pipes)\r\n                : pipes\r\n            : this._pipes;\r\n        if (factor instanceof Operator || factor instanceof Mark) {\r\n            return factor.attach(parents, key, _pipes);\r\n        } else {\r\n            let type = factor[0], values = factor[1];\r\n            for (const prev_item of parents) {\r\n                let [root, props] = prev_item;\r\n                props = props.slice();\r\n                props.push([key, _calc_nth(props, key), _pipes]);\r\n                let parent = this.getNode(root, type);\r\n\r\n                let walker = this._walker;\r\n                if (walker && this._bind_env) {\r\n                    walker = walker.bind(\r\n                        props.reduce((res, prop) => {\r\n                            let key = prop[0];\r\n                            if (key instanceof Mark) {\r\n                                res[key.key] = key.value;\r\n                            } else {\r\n                                res[key instanceof Cover ? key.origin : key] = true;\r\n                            }\r\n                            return res;\r\n                        }, {})\r\n                    );\r\n                }\r\n\r\n                for (const value of values) {\r\n                    let value_node = this.getNode(parent, value, root);\r\n                    if (\r\n                        value_node[MATCH_MARKS.WALKER]\r\n                        && value_node[MATCH_MARKS.WALKER] !== walker\r\n                    ) {\r\n                        console.warn(\r\n                            \"conflict:\",\r\n                            value_node,\r\n                            value_node[MATCH_MARKS.WALKER],\r\n                            walker\r\n                        );\r\n                    }\r\n                    if (walker) {\r\n                        value_node[MATCH_MARKS.WALKER] = walker;\r\n                    }\r\n                    result.push(\r\n                        [\r\n                            value_node,\r\n                            props,\r\n                            null/*[root, factor[0], value, prev_item]//Loop*/\r\n                        ]\r\n                    );\r\n                }\r\n            }\r\n\r\n        }\r\n        return result;\r\n    }\r\n    private getNode(parent: any, key: string | number, root?: any) {\r\n        let child = parent[key];\r\n        if (child) {\r\n            if (child[MATCH_MARKS.IDENTIFIER] !== OPERATOR_ID) {\r\n                parent[key] = child = { ...child };\r\n                child[MATCH_MARKS.IDENTIFIER] = OPERATOR_ID;\r\n            }\r\n            return child;\r\n        }\r\n\r\n        child = parent[key] = {\r\n            [MATCH_MARKS.IDENTIFIER]: OPERATOR_ID\r\n        };\r\n        if (root) {\r\n            child[MATCH_MARKS.DEEPTH] = root[MATCH_MARKS.DEEPTH] + 1;\r\n            root[MATCH_MARKS.TERMINAL] = false;\r\n            child[MATCH_MARKS.TERMINAL] = true;\r\n            /*if (root[MATCH_MARKS.MATCH_END]) {\r\n                root[MATCH_MARKS.MATCH_END][MATCHED_RECORDS.precedence][PRECEDENCE.TERMINAL] = false;\r\n            }*/\r\n        }\r\n        return child;\r\n    }\r\n    protected setWrap(records: IterationRecord) {//Loop\r\n        throw 'not used';\r\n        for (const record of records) {\r\n            let prev_item = record, curr_item = prev_item;\r\n            while ((curr_item = prev_item[2] && prev_item[2][3]) && curr_item[2]) {\r\n                prev_item = curr_item;\r\n            }\r\n            if (prev_item[2]) {\r\n                let linked = prev_item[2];\r\n                let node = this.getNode(record[0], linked[1]);\r\n                if (node[linked[2]] && node[linked[2]] !== prev_item[0]) {\r\n                    throw node[linked[2]];\r\n                }\r\n                node[linked[2]] = prev_item[0];\r\n            }\r\n        }\r\n        return records;\r\n    }\r\n    protected getDeepNodes(parents: IterationRecord, key: string | Cover, pipes?: Array<Pipe>) {\r\n        let children = parents, factors = this.factors;\r\n        for (const factor of factors) {\r\n            children = this.map(children, factor, key, pipes);\r\n        }\r\n        return children;\r\n    }\r\n    protected getNextNodes(parents: IterationRecord, key: string | Cover, pipes?: Array<Pipe>) {\r\n        let children = [], factors = this.factors;\r\n        for (const factor of factors) {\r\n            Array.prototype.push.apply(children, this.map(parents, factor, key, pipes));\r\n        }\r\n        return children;\r\n    }\r\n}\r\n\r\ntype Operand = string | /*number |*/ Operator | Mark | Array<string | number>;\r\ntype Operands = Array<Operand>;\r\ntype IterationRecordItem = [\r\n    Record<string, any>,\r\n    Array<NodeProp>,\r\n    [Record<string, any>, string, string, IterationRecordItem] | null\r\n]\r\ntype IterationRecord = Array<IterationRecordItem>;\r\n\r\nclass Option extends Operator {\r\n    attach(parents: IterationRecord, key: string, pipes?: Array<Pipe>) {\r\n        let children = this.getNextNodes(parents, key, pipes).concat(parents);\r\n        return children;\r\n    }\r\n}\r\nclass Or extends Operator {\r\n    attach(parents: IterationRecord, key: string, pipes?: Array<Pipe>) {\r\n        return this.getNextNodes(parents, key, pipes);\r\n    }\r\n}\r\n\r\nclass Series extends Operator {\r\n    attach(parents: IterationRecord, key: string, pipes?: Array<Pipe>) {\r\n        return this.getDeepNodes(parents, key, pipes);\r\n    }\r\n}\r\n/*\r\nclass And extends Operator  {\r\n    attach(parents: IterationRecord, key: string) {\r\n        throw \"not used\";\r\n        return [];\r\n    }\r\n}\r\nclass Not extends Operator {\r\n    attach(parents: IterationRecord, key: string) {\r\n        throw \"not used\";\r\n        return [];\r\n        \r\n    }\r\n}*/\r\nclass Cover implements CoverInterface {\r\n    constructor(public origin: any, public value: any) {\r\n        if (origin instanceof Cover) {\r\n            this.origin = origin.origin;\r\n        }\r\n    }\r\n}\r\nclass NonCapturing extends Operator {\r\n    attach(parents: IterationRecord, key: string | Cover, pipes?: Array<Pipe>) {\r\n        return this.getNextNodes(parents, new Cover(key, null), pipes);\r\n    }\r\n}\r\n\r\nclass NonCollecting extends Operator {\r\n    attach(parents: IterationRecord, key: string | Cover, pipes?: Array<Pipe>) {\r\n        return this.getNextNodes(parents, new Cover(key, \"\"), pipes);\r\n    }\r\n}\r\n\r\nclass Loop extends Operator {\r\n    //Loop 内部的 Option 可能会导致 Loop 取值混乱(当前用不到这种情况，不处理这种情况能减少消耗)\r\n    attach(parents: IterationRecord, key: string) {\r\n        throw 'not used';\r\n        //有点耗费性能，不是很必要用这个，已在parser核心部分去除Loop的支持\r\n        let baks = [];\r\n        for (const parent of parents) {\r\n            baks.push(parent[2]);\r\n            parent[2] = null;\r\n        }\r\n        let res = this.setWrap(this.getNextNodes(parents, key));\r\n        for (const index in parents) {\r\n            parents[index][2] = baks[index];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\nclass Mark implements MarkInterface {\r\n    static MATCHED_RECORD: Matched;\r\n    public key: string;\r\n    public value: any;\r\n    constructor(value?: any) {\r\n        if (typeof value === \"function\") {\r\n            this.data = value;\r\n        } else {\r\n            this.value = value;\r\n        }\r\n    }\r\n    data(context: Context, index: number) {\r\n        return this.value;\r\n    }\r\n    attach(parents: IterationRecord, key: string | Cover, pipes?: Array<Pipe>) {\r\n        let value = this.value;\r\n        if (!(key instanceof Cover) && (value !== undefined || this.data !== Mark.prototype.data)) {\r\n            if (key === \"type\") {\r\n                Mark.MATCHED_RECORD[MATCHED.wrapper] = _get_wrapper_function(value);;\r\n            } else {\r\n                let result: IterationRecord = [];\r\n                this.key = key;\r\n                for (const parent of parents) {\r\n                    let props = parent[1].slice();\r\n                    props.push([this, _calc_nth(props, this), undefined]);\r\n                    result.push([parent[0], props, parent[2]]);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        return parents;\r\n    }\r\n}\r\n\r\nfunction _Option(...some: Operands) {\r\n    return new Option(some);\r\n}\r\n/*\r\nfunction _Not(...some: Operands) {\r\n    return new Not(some);\r\n}\r\nfunction _And(...some: Operands) {\r\n    return new And(some);\r\n}*/\r\nfunction _Or(...some: Operands) {\r\n    return new Or(some);\r\n}\r\nfunction _Series(...some: Operands) {\r\n    return new Series(some);\r\n}\r\nfunction _NonCapturing(...some: Operands) {\r\n    return new NonCapturing(some);\r\n}\r\nfunction _NonCollecting(...some: Operands) {\r\n    return new NonCollecting(some);\r\n}\r\n\r\n\r\nfunction _Loop(...some: Operands) {\r\n    return new Loop(some);\r\n}\r\nfunction _Mark(some?: any) {\r\n    return new Mark(some);\r\n}\r\nlet NODES: Record<string, (...args: any) => void> = {\r\n    Grouping(node?: Record<string, any>, grouping?: Token) {\r\n        this.type = \"Grouping\";\r\n        for (const key in node) {\r\n            this[key] = node[key];\r\n        }\r\n        if (grouping) {\r\n            this.range = grouping.range;\r\n            this.loc = grouping.loc;\r\n        }\r\n    },\r\n    Directive(\r\n        type: string,\r\n        expression: Node,\r\n        directive: string,\r\n        range: [number, number],\r\n        loc: SourceLocation\r\n    ) {\r\n        this.type = type;\r\n        this.expression = expression;\r\n        this.directive = directive;\r\n        this.range = range;\r\n        this.loc = loc;\r\n    },\r\n    Script(body: Array<Node>) {\r\n        this.type = \"Program\";\r\n        this.sourceType = \"script\";\r\n        this.body = body;\r\n    },\r\n    Module(body: Array<Node>) {\r\n        this.type = \"Program\";\r\n        this.sourceType = \"module\";\r\n        this.body = body;\r\n    }\r\n};\r\nfunction _get_adapt(data: any, index: number) {\r\n    return data instanceof Array ? index < data.length\r\n        ? data[index]\r\n        : data[data.length - 1] : data;\r\n}\r\nfunction _get_wrapper_function(type: string) {\r\n    return NODES[type]\r\n        || (\r\n            NODES[type]\r\n            = type ? eval(`(function ${type}(){this.type=\"${type}\"})`) : function () { }\r\n        );\r\n}\r\nfunction createMatchTree(\r\n    data: Record<string, any> | Array<Record<string, any>>,\r\n    root?: Record<string, any>,\r\n    block_list: Array<string> = [],\r\n    prevent_update = false\r\n) {\r\n    prevent_update || (OPERATOR_ID += 1);\r\n    root = root ? prevent_update ? root : { ...root } : { [MATCH_MARKS.DEEPTH]: -1 };\r\n\r\n    if (data instanceof Array) {\r\n        for (const item of data) {\r\n            root = createMatchTree(item, root, block_list, true);\r\n        }\r\n    } else {\r\n        for (const type in data) {\r\n            let wrapper = _get_wrapper_function(type);\r\n            for (let item of data[type] instanceof Array ? data[type] : [data[type]]) {\r\n                let {\r\n                    collector: collectors,\r\n                    handler: handlers,\r\n                    overload,\r\n                    precedence: precedences = true/*PRECEDENCE_FEATURES.IMMEDIATE*/,\r\n                    filter: filters,\r\n                    validator: validators\r\n                } = item;\r\n                if (!collectors || ~block_list.indexOf(type)) {\r\n                    continue;\r\n                }\r\n                typeof filters === \"string\" && (filters = data[filters].filter);\r\n                typeof handlers === \"string\" && (handlers = data[handlers].handler);\r\n                typeof validators === \"string\" && (validators = data[validators].validator);\r\n                collectors instanceof Array || (collectors = [collectors]);\r\n\r\n                for (let index = 0; index < collectors.length; index++) {\r\n                    let collector = collectors[index];\r\n\r\n                    let precedence: any = _get_adapt(precedences, index);\r\n                    let handler: Matched[MATCHED.handler] = _get_adapt(handlers, index);\r\n                    let filter: Matched[MATCHED.filter] = _get_adapt(filters, index);\r\n                    let validator: Matched[MATCHED.validator] = _get_adapt(validators, index);\r\n                    Mark.MATCHED_RECORD = [\r\n                        [precedence instanceof Number ? Number(precedence) : precedence, precedence],\r\n                        null,\r\n                        wrapper,\r\n                        handler,\r\n                        validator,\r\n                        filter\r\n                    ];\r\n                    if (collector instanceof Array) {\r\n                        let _collector = { ...collectors[index - 1] };\r\n                        collector[0] && !(collector[0] instanceof Array) && (collector = [collector]);\r\n                        for (const [key, value] of collector) {\r\n                            _collector[key] = value;\r\n                        }\r\n                        collectors[index] = collector = _collector;\r\n                    }\r\n\r\n                    let nodes: IterationRecord = [[root, [], null]];\r\n\r\n                    //保证所有 key 都是同类型字符开头(否则可能会出现遍历顺序与定义顺序不同)\r\n                    for (const key in collector) {\r\n                        let operator = collector[key];\r\n                        if (!(operator instanceof Operator || operator instanceof Mark)) {\r\n                            operator = _Or(operator);\r\n                        }\r\n                        nodes = operator.attach(nodes, key);\r\n                    }\r\n\r\n                    for (const [last_node, props] of nodes) {\r\n                        let matched_record = Mark.MATCHED_RECORD.slice();\r\n                        matched_record[MATCHED.props] = props;\r\n                        if (!overload && last_node[MATCH_MARKS.MATCH_END]) {\r\n                            console.warn(\r\n                                \"conflict:\",\r\n                                last_node,\r\n                                last_node[MATCH_MARKS.MATCH_END],\r\n                                matched_record\r\n                            );\r\n                        }\r\n                        last_node[MATCH_MARKS.MATCH_END] = matched_record\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    return root;\r\n\r\n}\r\n\r\nfunction _Context(parser: Parser): Context {\r\n    let state_stack = [];\r\n    let context: any = new Array(CONTEXT.length);\r\n    context[CONTEXT.parser] = parser;\r\n    context[CONTEXT.labelSet] = [];\r\n    //context[CONTEXT.tokens] = tokens;\r\n    context.wrap = wrap;\r\n    context.unwrap = unwrap;\r\n    context.store = store;\r\n    context.restore = restore;\r\n    context.getToken = getToken;\r\n    Object.defineProperty(context, \"tokens\", {\r\n        get() {\r\n            return this[CONTEXT.tokens] || this[CONTEXT.parser].tokens;\r\n        }\r\n    })\r\n    return context;\r\n\r\n    function getToken(index: number) {\r\n        let tokens = this[CONTEXT.tokens];\r\n        return !tokens ? this[CONTEXT.parser].getToken(index) : tokens[index];\r\n        //return context[CONTEXT.tokens][index];\r\n    }\r\n    function wrap(key: CONTEXT, value: any) {\r\n        state_stack.push(context[key], key);\r\n        context[key] = value;\r\n        return context;\r\n    };\r\n    function unwrap() {\r\n        context[state_stack.pop()] = state_stack.pop();\r\n        return context;\r\n    };\r\n    function store() {\r\n        let restore_point = state_stack.length;\r\n        for (let index = 0; index < arguments.length; index += 2) {\r\n            wrap(arguments[index], arguments[index + 1]);\r\n        }\r\n        return restore_point;\r\n    }\r\n    function restore(point: number) {\r\n        while (state_stack.length > point) {\r\n            unwrap();\r\n        }\r\n        return state_stack.length;\r\n    }\r\n}\r\nconst FutureReservedWord = [\"enum\", \"export\", \"import\", \"super\"];\r\nconst StrictModeReservedWord = [\r\n    \"implements\", \"interface\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"let\"\r\n];\r\nconst RestrictedWord = [\"eval\", \"arguments\"];\r\n\r\nfunction isFutureReservedWord(id: string) {\r\n    return FutureReservedWord.indexOf(id) >= 0;\r\n}\r\nfunction isStrictModeReservedWord(id: string) {\r\n    return StrictModeReservedWord.indexOf(id) >= 0;\r\n}\r\nfunction isRestrictedWord(id: string) {\r\n    return RestrictedWord.indexOf(id) >= 0;\r\n}\r\n\r\n\r\nfunction _if_strict_throw_err(context: Context, token: Token) {\r\n    if (context[CONTEXT.strict]) {\r\n        context[CONTEXT.parser].err(token);\r\n    }\r\n}\r\nfunction _if_reserved_throw_err(context: Context, token: Token) {\r\n    validateIdentifier(context, token);\r\n}\r\nconst THROW_RESTRICT_WORDS_PATTERN = _Or(\r\n    \"Identifier eval arguments\"\r\n).pipe(_if_strict_throw_err);\r\nconst THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\r\n    \"Identifier implements interface package private protected public static yield let\"\r\n).pipe(_if_strict_throw_err);\r\n\r\nconst IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier\", THROW_STRICT_RESERVED_WORDS_PATTERN);\r\nconst EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"[Expression]\", THROW_STRICT_RESERVED_WORDS_PATTERN);\r\n\r\nconst IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier\").pipe(_if_reserved_throw_err);\r\nconst EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = _Or(\r\n    \"[Expression]\",\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN\r\n);\r\n\r\n\r\n/*const STRICT_RESERVED_WORDS = _Or(\r\n    \"Identifier implements interface package private protected public static yield let\"\r\n);*/\r\nfunction validateIdentifier(context: Context, node: Node) {\r\n    if (\r\n        context[CONTEXT.strict]\r\n    ) {\r\n        if (!isStrictModeReservedWord(node.name)) {\r\n            return true;\r\n        }\r\n        context[CONTEXT.parser].err(node);\r\n        return false;\r\n    }\r\n}\r\nfunction validateAssignment(context: Context, node: Node) {\r\n    if (\r\n        context[CONTEXT.strict]\r\n    ) {\r\n        if (!(\r\n            isRestrictedWord(node.name)\r\n            || isStrictModeReservedWord(node.name)\r\n        )) {\r\n            return true;\r\n        }\r\n        context[CONTEXT.parser].err(node);\r\n        return false;\r\n    }\r\n}\r\nfunction validateBinding(context: Context, node: Node) {\r\n    if (validateAssignment(context, node) === true) {\r\n        let binding_set = context[CONTEXT.bindingSet];\r\n        if (binding_set) {\r\n            binding_set.push(node.name);\r\n            if (binding_set.indexOf(node.name) !== binding_set.length - 1) {\r\n                context[CONTEXT.parser].err(node);\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction validateLineTerminator(context: Context) {\r\n    let [collected, parser, , right] = context;\r\n    if (collected._next) {\r\n        delete collected._next;\r\n    } else {\r\n        let next_token = context.getToken(right + 1);\r\n        if (\r\n            next_token\r\n            && !(next_token.type === TOKEN_TYPE_ENUMS.Punctuator && next_token.value === \"}\")\r\n            && next_token.loc.start.line === collected.loc.end.line\r\n        ) {\r\n            parser.err(next_token);\r\n        }\r\n    }\r\n    return collected;\r\n}\r\n\r\nlet join_content = function ([collected]: Context) {\r\n    let { success, content } = collected;\r\n    if (success) {\r\n        success.content.push(content);\r\n        return success;\r\n    } else {\r\n        collected.content = [content];\r\n        return collected;\r\n    }\r\n};\r\n\r\nlet TYPE_ALIAS = {};\r\n\r\nconst ASSIGNMENT_PUNCTUATORS_PATTERN = _Or(\"Punctuator = += -= **= *= /= %= <<= >>= >>>= &= ^= |=\");\r\n\r\nlet AWAIT_LIST: Array<() => void> = [];\r\n\r\nconst MODULE_ITEM_PATTERN = _Or(\r\n    \"ImportDeclaration\",\r\n    \"ExportAllDeclaration\",\r\n    \"ExportNamedDeclaration\",\r\n    \"ExportDefaultDeclaration\"\r\n);\r\nconst STATEMANT_LIST_ITEM_PATTERN = _Or(\"[Declaration]\", \"[Statement]\");\r\n\r\nconst RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN = _Or(\r\n    \"SwitchCase\",\r\n    MODULE_ITEM_PATTERN,\r\n    STATEMANT_LIST_ITEM_PATTERN\r\n);\r\nconst TOPLEVEL_ITEM_PATTERN = _Or(\r\n    MATCH_MARKS.BOUNDARY,\r\n    \"SwitchCase\",\r\n    MODULE_ITEM_PATTERN,\r\n    STATEMANT_LIST_ITEM_PATTERN\r\n);\r\n\r\nfunction isAligned(context: Context, left: number, right: number) {\r\n    let tokens = context.tokens;\r\n    for (let index = left; index < right; index++) {\r\n        if (tokens[index].loc.end.line !== tokens[index + 1].loc.start.line) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction attachLocation(source: Node, start: Node, end: Node = start) {\r\n    source.range = [start.range[0], end.range[1]];\r\n    source.loc = {\r\n        start: start.loc.start,\r\n        end: end.loc.end\r\n    };\r\n}\r\n\r\n\r\nfunction reinterpretKeywordAsIdentifier({ value, range, loc }: Token, tokenizer?: Tokenizer): Node {\r\n    let name = tokenizer ? tokenizer._bak : value;\r\n    let identifier = {\r\n        type: \"Identifier\", name, range, loc\r\n    };\r\n    Object.defineProperty(identifier, \"value\", {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value: name\r\n    });\r\n    return identifier;\r\n}\r\nfunction reinterpretIdentifierAsKeyword({ value, range, loc }: Token): Node {\r\n    return {\r\n        type: \"Keyword\",\r\n        value,\r\n        range,\r\n        loc\r\n    };\r\n}\r\n\r\nfunction _Validate(type: string | number, value: string): Validate {\r\n    return function (token: Token) {\r\n        return token.type === type && token.value === value;\r\n    }\r\n}\r\n\r\n\r\nlet is_right_parentheses = _Validate(type_punctuator, \")\");\r\nlet is_right_brackets = _Validate(type_punctuator, \"]\");\r\nlet is_right_braces = _Validate(type_punctuator, \"}\");\r\nexport {\r\n    _Punctuator,\r\n    _Keyword,\r\n    _Identifier,\r\n    _Pattern,\r\n    is_right_parentheses,\r\n    is_right_brackets,\r\n    is_right_braces,\r\n    _Validate,\r\n    reinterpretIdentifierAsKeyword,\r\n    reinterpretKeywordAsIdentifier,\r\n    attachLocation,\r\n    Cover,\r\n    Mark, isAligned,\r\n    STATEMANT_LIST_ITEM_PATTERN,\r\n    RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    AWAIT_LIST,\r\n    join_content,\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    ASSIGNMENT_PUNCTUATORS_PATTERN,\r\n    validateBinding, validateLineTerminator,\r\n    NODES,\r\n    TYPE_ALIAS,\r\n    MATCH_MARKS,\r\n    createMatchTree,\r\n    isRestrictedWord,\r\n    isFutureReservedWord,\r\n    isStrictModeReservedWord,\r\n    validateIdentifier,\r\n    validateAssignment,\r\n    _Context,\r\n    _Option, _Or, _Series, _NonCapturing, _NonCollecting, _Mark, _Loop,\r\n}\r\n","import {\r\n    Token, NUMERIC_TYPE, MATCH_STATUS\r\n} from '../interfaces';\r\n\r\nimport Tokenizer from '../tokenizer'\r\nimport { escape_scan, createSearchTree, MARKS } from './head'\r\n\r\nlet TOKEN_TYPE_ENUMS: Record<string, string | number> = {\r\n    Identifier: \"Identifier\",\r\n    Keyword: \"Keyword\",\r\n    String: \"String\",\r\n    Boolean: \"Boolean\",\r\n    Numeric: \"Numeric\",\r\n    Punctuator: \"Punctuator\",\r\n    RegularExpression: \"RegularExpression\",\r\n    Template: \"Template\",\r\n    TemplateElement: \"TemplateElement\",\r\n    Comments: \"Comments\",\r\n    Null: \"Null\"\r\n};\r\n\r\n//const IS_RADIX = NUMERIC_TYPE.BINARY | NUMERIC_TYPE.OCTAL | NUMERIC_TYPE.HEX;\r\nconst NUMERIC_KEYWORD_MAP = {\r\n    \".\": NUMERIC_TYPE.FLOAT | NUMERIC_TYPE.DECIMAL,\r\n    \"x\": NUMERIC_TYPE.HEX,\r\n    \"b\": NUMERIC_TYPE.BINARY,\r\n    \"o\": NUMERIC_TYPE.OCTAL,\r\n\r\n    \"X\": NUMERIC_TYPE.HEX,\r\n    \"B\": NUMERIC_TYPE.BINARY,\r\n    \"O\": NUMERIC_TYPE.OCTAL,\r\n};\r\n\r\nlet TOKEN_TYPE_SET = [\r\n    [\r\n        \"Keyword\",\r\n        [\r\n            \"void\",\r\n            \"delete\",\r\n            \"new\",\r\n            \"class\", \"extends\",\r\n            \"function\",\r\n            \"throw\",\r\n            \"with\",\r\n            \"yield\",\r\n            \"in\", \"instanceof\", \"typeof\",\r\n            \"this\", \"super\",\r\n            \"var\", \"const\",// \"let\",\r\n            \"break\", \"continue\", \"return\",\r\n            \"if\", \"else\",\r\n            \"switch\", \"case\", \"default\",\r\n            \"try\", \"catch\", \"finally\",\r\n            \"do\", \"while\", \"for\",\r\n            \"await\",/*\"async\",*/\r\n            \"import\", \"export\",\r\n            \"debugger\",\r\n\r\n            \"enum\"//用于错误检测\r\n        ]\r\n    ],\r\n    [\"Identifier\", [\"let\", \"async\"]],//使 UnicodeEscape 的情况能被检测到报错\r\n    [\"Boolean\", [\"true\", \"false\"]],\r\n    [\"Null\", [\"null\"]]\r\n];\r\n\r\nconst TOKEN_TYPE_MAPPERS = TOKEN_TYPE_SET.reduce(\r\n    (map, [type, id_set]) => {\r\n        for (let id of id_set) {\r\n            map[\" \" + id] = type;\r\n        }\r\n        return map;\r\n    }, {}\r\n);\r\n\r\nlet octal_escape = {\r\n    _state: MATCH_STATUS.ATTACH,\r\n    _attach(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n        let code = tokenizer.octalValue(tokenizer.input.charCodeAt(tokenizer.index - 1));\r\n        let value = 0;\r\n        code && (scope.octal = true);\r\n        let len = code <= 3 ? 2 : 1;\r\n        while (true) {\r\n            value = value * 8 + code;\r\n            code = tokenizer.octalValue(tokenizer.input.charCodeAt(tokenizer.index));\r\n            if (code < 0 || --len < 0) {\r\n                break;\r\n            }\r\n            scope.octal = true;\r\n            tokenizer.index += 1;\r\n        }\r\n        return String.fromCharCode(value);\r\n    }\r\n};\r\nlet octal_escape_tree = {\r\n    \"\\\\0\": octal_escape,\r\n    \"\\\\1\": octal_escape,\r\n    \"\\\\2\": octal_escape,\r\n    \"\\\\3\": octal_escape,\r\n    \"\\\\4\": octal_escape,\r\n    \"\\\\5\": octal_escape,\r\n    \"\\\\6\": octal_escape,\r\n    \"\\\\7\": octal_escape,\r\n}\r\n\r\nlet strbase_match_tree = {\r\n    \"\\\\\\n\": { _str: \"\" },\r\n    \"\\\\n\": { _str: \"\\n\" },\r\n    \"\\\\r\": { _str: \"\\r\" },\r\n    \"\\\\t\": { _str: \"\\t\" },\r\n    \"\\\\b\": { _str: \"\\b\" },\r\n    \"\\\\f\": { _str: \"\\f\" },\r\n    \"\\\\v\": { _str: \"\\v\" },\r\n    \"\\\\u\": {\r\n        _state: MATCH_STATUS.ATTACH,\r\n        _attach(tokenizer: Tokenizer) {\r\n            if (tokenizer.input[tokenizer.index] === \"{\") {\r\n                tokenizer.index++;\r\n                let [code] = tokenizer.scanHex();\r\n                if (tokenizer.input[tokenizer.index] === \"}\") {\r\n                    tokenizer.index++;\r\n                    if (code <= 0x10ffff) {\r\n                        return String.fromCharCode(code);\r\n                    }\r\n                }\r\n            } else {\r\n                let [code, len] = tokenizer.scanHex(4);\r\n                if (len === 4) {\r\n                    return String.fromCharCode(code);\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    \"\\\\x\": {\r\n        _state: MATCH_STATUS.ATTACH,\r\n        _attach(tokenizer: Tokenizer) {\r\n            let [code, len] = tokenizer.scanHex(2);\r\n            if (len === 2) {\r\n                return String.fromCharCode(code);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n};\r\n\r\nlet not_allow_octal_escape = {\r\n    _state: MATCH_STATUS.ERROR,\r\n    _error: \"Octal escape sequences are not allowed in template strings\"\r\n}\r\n\r\nlet template_curly_stack = [];\r\nlet template_base = {\r\n    type: \"Template\",\r\n    match_tree: {\r\n        \"\\\\0\": { _str: \"\\0\" },\r\n        \"\\\\1\": not_allow_octal_escape,\r\n        \"\\\\2\": not_allow_octal_escape,\r\n        \"\\\\3\": not_allow_octal_escape,\r\n        \"\\\\4\": not_allow_octal_escape,\r\n        \"\\\\5\": not_allow_octal_escape,\r\n        \"\\\\6\": not_allow_octal_escape,\r\n        \"\\\\7\": not_allow_octal_escape,\r\n        \"`\": {\r\n            _state: MATCH_STATUS.END,\r\n            _end(tokenizer: Tokenizer) {\r\n                template_curly_stack.shift();\r\n                return true;\r\n            }\r\n        },\r\n        \"$\": {\r\n            \"{\": {\r\n                _state: MATCH_STATUS.END\r\n            }\r\n        },\r\n        ...strbase_match_tree\r\n    },\r\n    scanner: escape_scan\r\n}\r\nconst PUNCTUATORS = [\r\n    {\r\n        key: `\"`, type: \"String\",\r\n        match_tree: {\r\n            '\"': {\r\n                _state: MATCH_STATUS.END\r\n            },\r\n            \"\\n\": {\r\n                _state: MATCH_STATUS.ERROR\r\n            },\r\n            ...strbase_match_tree,\r\n            ...octal_escape_tree\r\n        },\r\n        escape_scan,\r\n        scanner(tokenizer: Tokenizer, start: number) {\r\n            return this.escape_scan(tokenizer, start, {});\r\n        }\r\n    },\r\n    {\r\n        key: `'`, type: \"String\",\r\n        match_tree: {\r\n            \"'\": {\r\n                _state: MATCH_STATUS.END\r\n            },\r\n            \"\\n\": {\r\n                _state: MATCH_STATUS.ERROR\r\n            },\r\n            ...strbase_match_tree,\r\n            ...octal_escape_tree\r\n        },\r\n        escape_scan,\r\n        scanner(tokenizer: Tokenizer, start: number) {\r\n            return this.escape_scan(tokenizer, start, {});\r\n        }\r\n    },\r\n    {\r\n        key: \"`\",\r\n        ...template_base,\r\n        escape_scan,\r\n        scanner(tokenizer: Tokenizer, start: number) {\r\n            template_curly_stack.unshift(\"`\");\r\n            return this.escape_scan(tokenizer, start);\r\n        }\r\n    },\r\n    {\r\n        key: \"}\",\r\n        ...template_base,\r\n        filter(tokenizer: Tokenizer) {\r\n            let env = template_curly_stack[0];\r\n            return env === \"`\";\r\n        }\r\n    },\r\n    {\r\n        key: '/*', bound: '*/', type: \"Comments\",\r\n        match_tree: {\r\n            \"*\": {\r\n                \"/\": {\r\n                    _state: MATCH_STATUS.END\r\n                }\r\n            },\r\n            \"\\\\*\": {\r\n                \"/\": {\r\n                    _state: MATCH_STATUS.END\r\n                }\r\n            },\r\n            [MARKS.EOF]: {\r\n                _state: MATCH_STATUS.END,\r\n                _error: \"Unexpected token\"\r\n            }\r\n        },\r\n        scanner: escape_scan\r\n    },\r\n    {\r\n        key: '//', bound: '\\n', type: \"Comments\",\r\n        match_tree: {\r\n            \"\\n\": {\r\n                _state: MATCH_STATUS.END\r\n            },\r\n            \"\\\\\\n\": {\r\n                _state: MATCH_STATUS.END\r\n            },\r\n            [MARKS.EOF]: {\r\n                _state: MATCH_STATUS.END\r\n            }\r\n        },\r\n        scanner: escape_scan\r\n    },\r\n\r\n    //[\"(\", \")\"], [\"[\", \"]\"], [\"{\", \"}\"],\r\n\r\n    \"(\", \")\", \"[\", \"]\", \"{\", \"}\",\r\n    ';', '.', '?.',\r\n    '++', '--', '~', '!',\r\n    '**', '*', '/', '%',\r\n    '+', '-',\r\n    '<<', '>>', '>>>',\r\n    '<', '>', '<=', '>=', '==', '!=', '===', '!==',\r\n    '&',\r\n    '^',\r\n    '|',\r\n    '&&',\r\n    '||',\r\n    '?', \":\",\r\n    '=', '+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '&=', '|=', '^=',\r\n    '...',\r\n    ',',\r\n    '=>'\r\n];\r\n\r\nconst REGEXP_DESCRIPTOR = {\r\n    key: '/', type: \"RegularExpression\",\r\n    match_tree: {\r\n        '/': {\r\n            _state: MATCH_STATUS.END,\r\n            _end(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n                return !scope.class_marker;\r\n            }\r\n        },\r\n        '[': {\r\n            _state: MATCH_STATUS.ATTACH,\r\n            _attach(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n                scope.class_marker = true;\r\n            }\r\n        },\r\n        ']': {\r\n            _state: MATCH_STATUS.ATTACH,\r\n            _attach(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n                scope.class_marker = false;\r\n            }\r\n        },\r\n        '\\n': {\r\n            _state: MATCH_STATUS.ERROR\r\n        },\r\n        '\\\\\\n': {\r\n            _state: MATCH_STATUS.ERROR\r\n        },\r\n        [MARKS.EOF]: {\r\n            _state: MATCH_STATUS.END,\r\n            _error: \"Invalid or unexpected token\"\r\n        }\r\n    },\r\n    overload: true,\r\n    escape_scan,\r\n    scanner(tokenizer: Tokenizer, start: number) {\r\n        let scope: Record<string, any> = {};\r\n        let token = this.escape_scan(tokenizer, start, scope);\r\n        if (token) {\r\n            token.regex = {\r\n                pattern: token.value.slice(\r\n                    1, token.value[token.value.length - 1] !== \"/\" ? undefined : -1\r\n                ),\r\n                flags: \"\"\r\n            };\r\n            let start = tokenizer.index;\r\n            let length = 0;\r\n            do {\r\n                tokenizer.index += length;\r\n                length = tokenizer.inIdentifierPart();\r\n            } while (length)\r\n            if (start !== tokenizer.index) {\r\n                token.regex.flags = tokenizer.input.slice(start, tokenizer.index)\r\n                token.value += token.regex.flags;\r\n                token.range[1] += tokenizer.index - start;\r\n                token.loc.end.column += tokenizer.index - start;\r\n            }\r\n            return token;\r\n        }\r\n    }\r\n};\r\nconst PUNCTUATORS_TREE = createSearchTree(PUNCTUATORS);\r\nconst PRIOR_REGEXP_PUNCTUATORS_TREE = createSearchTree(\r\n    [REGEXP_DESCRIPTOR],\r\n    createSearchTree(PUNCTUATORS, [\"/=\"]),\r\n);\r\n\r\n\r\nexport {\r\n    PRIOR_REGEXP_PUNCTUATORS_TREE,\r\n    PUNCTUATORS_TREE,\r\n    NUMERIC_KEYWORD_MAP,\r\n    TOKEN_TYPE_MAPPERS, TOKEN_TYPE_ENUMS\r\n}\r\n\r\n\r\n","\r\nimport {\r\n    Token, Node, Context, CONTEXT\r\n} from '../interfaces';\r\nimport {\r\n    MATCH_MARKS,\r\n    createMatchTree,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark,\r\n    reinterpretIdentifierAsKeyword,\r\n    reinterpretKeywordAsIdentifier,\r\n} from './head'\r\nimport Parser from '../parser'\r\nimport Tokenizer from \"../tokenizer\"\r\n\r\n\r\nimport {\r\n    Expressions,\r\n    EXPRESSION_TREE\r\n} from './expression'\r\nimport Declarations from './declaration'\r\nimport Statements from './statement'\r\nimport ModuleDeclarations from './module_declaration'\r\n\r\n\r\n\r\nlet EXPRESSION_ITEM_PATTERN = {};\r\nlet DECLARATION_ITEM_PATTERN = {};\r\nlet STATEMENT_ITEM_PATTERN = {};\r\nlet STATEMENT_LIST_ITEM_PATTERN = {};\r\nlet MODULE_ITEM_PATTERN = {};\r\nfor (\r\n    const [descriptor, patterns]\r\n    of\r\n    [\r\n        [\r\n            Expressions,\r\n            [EXPRESSION_ITEM_PATTERN]\r\n        ],\r\n        [\r\n            Declarations,\r\n            [DECLARATION_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\r\n        ],\r\n        [\r\n            Statements,\r\n            [STATEMENT_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\r\n        ],\r\n        [\r\n            ModuleDeclarations,\r\n            [MODULE_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\r\n        ],\r\n    ] as Array<[Record<string, any>, Array<Record<string, boolean>>]>\r\n) {\r\n    for (const key in descriptor) {\r\n        if (key) {\r\n            for (const pattern of patterns) {\r\n                pattern[key] = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction isExpression(node: Node) {\r\n    return EXPRESSION_ITEM_PATTERN[node.type];\r\n}\r\nfunction isDeclaration(node: Node) {\r\n    return DECLARATION_ITEM_PATTERN[node.type];\r\n}\r\nfunction isStatement(node: Node) {\r\n    return STATEMENT_ITEM_PATTERN[node.type];\r\n}\r\nfunction isStatementListItem(node: Node) {\r\n    return STATEMENT_LIST_ITEM_PATTERN[node.type];\r\n}\r\nfunction isModuleItem(node: Node) {\r\n    return MODULE_ITEM_PATTERN[node.type];\r\n}\r\n\r\n\r\nconst SYNTAX_TREE = createMatchTree([\r\n    Declarations,\r\n    ModuleDeclarations,\r\n    Statements\r\n], EXPRESSION_TREE);\r\n\r\n\r\nfunction parse_next_statement(context: Context, start = context[CONTEXT.right] + 1) {\r\n    let parser = context[CONTEXT.parser];\r\n    if (\r\n        parser.parseCustom(\r\n            parser.SYNTAX_TREE,\r\n            context,\r\n            start,\r\n            isStatementListItem\r\n        )\r\n    ) {\r\n        return 0;\r\n    }\r\n}\r\nfunction get_inner_group(token: Token) {\r\n    while (\r\n        token.content.length === 1\r\n        && token.content[0].value === \"()\"\r\n        && token.content[0].type === \"Punctuator\"\r\n    ) {\r\n        token = token.content[0];\r\n    }\r\n    return token;\r\n}\r\n\r\nfunction extract_success(parser: Parser, nodes: Array<Node>) {\r\n    let res: Array<Node> = nodes;\r\n    if (nodes.length) {\r\n        let index = 0;\r\n        if (nodes[0].type === \"Success\") {\r\n            index = 1;\r\n            res = nodes[0].content;\r\n        } else {\r\n            res = [];\r\n        }\r\n        if (nodes.length > index) {\r\n            parser.err(...nodes.slice(index));\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfunction parse_and_extract(match_tree: Record<string, any>, context: Context, node: Node) {\r\n    let [, parser] = context;\r\n    let tokens = node.content;\r\n    if (tokens.length) {\r\n        context.wrap(CONTEXT.tokens, tokens)\r\n        //context[CONTEXT.tokens] = tokens;\r\n        parser.parseCustom(match_tree, context);\r\n        tokens = extract_success(parser, tokens)\r\n        context.unwrap();\r\n    }\r\n    return tokens;\r\n}\r\n/*\r\nfunction isCommaSeparator(node) {\r\n    return node.type === \"Punctuator\" && node.value === \",\";\r\n}*/\r\n\r\n\r\nfunction getLiteral(parse_value: (token: Token, tokenizer: Tokenizer) => any, token: Token, tokenizer: Tokenizer) {\r\n    return {\r\n        type: \"Literal\",\r\n        value: parse_value(token, tokenizer),\r\n        raw: token.value,\r\n        range: token.range,\r\n        loc: token.loc\r\n    }\r\n}\r\n\r\nlet getStringLiteral = getLiteral.bind(null, (token: Token, tokenizer: Tokenizer) => tokenizer._bak);\r\nlet getRegularLiteral = getLiteral.bind(null, (token: Token, tokenizer: Tokenizer) => {\r\n    let regex = token.regex;\r\n    try {\r\n        return new RegExp(regex.pattern, regex.flags);\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n});\r\n\r\nlet token_hooks: Record<string, (token: Token, tokenizer?: Tokenizer | Parser) => Token> = {\r\n    Keyword(token: Token, parser: Parser) {\r\n        let context = parser.context_stack[0];\r\n        if (!context[CONTEXT.allowYield] && token.value === \"yield\") {\r\n            return reinterpretKeywordAsIdentifier(token);\r\n        }\r\n        return token;\r\n    },\r\n    Identifier: reinterpretKeywordAsIdentifier,\r\n    Numeric: getLiteral.bind(null, (token: Token) => Number(token.value)),\r\n    Boolean: getLiteral.bind(null, (token: Token) => token.value === \"true\"),\r\n    String(token: Token, parser: Parser) {\r\n        token = getStringLiteral(token, parser);\r\n        if (parser._scope.octal && parser.context_stack[0][CONTEXT.strict]) {\r\n            parser.err(token);\r\n        }\r\n        return token;\r\n    },\r\n    Null: getLiteral.bind(null, () => null),\r\n    RegularExpression(token: Token, tokenizer: Tokenizer) {\r\n        let res = getRegularLiteral(token, tokenizer);\r\n        res.regex = token.regex;\r\n        return res;\r\n    }\r\n};\r\nexport {\r\n    token_hooks,\r\n    parse_next_statement,\r\n    get_inner_group,\r\n    extract_success,\r\n    parse_and_extract,\r\n    MATCH_MARKS,\r\n    isExpression, isDeclaration, isStatement, isStatementListItem, isModuleItem,\r\n    SYNTAX_TREE, EXPRESSION_TREE\r\n}\r\n\r\n\r\n\r\n","import {\r\n    Node, Token, Context, CONTEXT, MATCHED\r\n} from '../interfaces';\r\nimport {\r\n    _Punctuator,\r\n    _Keyword,\r\n    _Identifier,\r\n    _Pattern,\r\n    _Validate,\r\n    is_right_parentheses,\r\n    is_right_brackets,\r\n    is_right_braces,\r\n    createMatchTree,\r\n    _Option, _Or, _Series, _NonCollecting, _NonCapturing, _Mark,\r\n    TYPE_ALIAS, _Context, _Loop, NODES, validateIdentifier, validateAssignment,\r\n    validateBinding, validateLineTerminator, ASSIGNMENT_PUNCTUATORS_PATTERN, join_content,\r\n\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    MATCH_MARKS,\r\n    isAligned,\r\n    attachLocation,\r\n\r\n    reinterpretIdentifierAsKeyword,\r\n    reinterpretKeywordAsIdentifier,\r\n} from './head'\r\nimport {\r\n\r\n    extract_success,\r\n    parse_and_extract,\r\n    isExpression\r\n} from './index';\r\n\r\n\r\nimport {\r\n    TOKEN_TYPE_ENUMS\r\n} from \"../lexical/index\";\r\n\r\nimport {\r\n    Patterns,\r\n    parseArrayPattern,\r\n    parseObjectPattern\r\n} from './pattern';\r\nconst Grouping = NODES.Grouping;\r\n\r\nfunction walk_primary_expression(context: Context, index: number) {\r\n    context[CONTEXT.parser].parseRange(PRIMARY_EXPRESSION_TREE, context, index, is_right_parentheses);\r\n}\r\n\r\n\r\nconst ARGUMENTS_PATTERN = _Or(\r\n    _Punctuator(\"(\").walk(\r\n        walk_primary_expression\r\n    ),\r\n    \"Punctuator ()\"\r\n).pipe(\r\n    function (context: Context, token: Token, index: number) {\r\n        let parser = context[CONTEXT.parser];\r\n        let store = context.store(\r\n            CONTEXT.bindingElement, false,\r\n            CONTEXT.spreadElement, true,\r\n            CONTEXT.tokens, token.content\r\n        );\r\n        let res = parser.parseNode(ARGUMENTS_TREE, context, function (node: Token) { return node.type === \"Success\"; })\r\n        context.restore(store);\r\n        return res ? res.content : [];\r\n    }\r\n);\r\n\r\n\r\nconst PARAMS_PATTERN = _Or(\r\n    _Punctuator(\"(\").walk(\r\n        function (context: Context, left: number) {\r\n            let parser = context[CONTEXT.parser];\r\n            let store = context.store(\r\n                CONTEXT.bindingElement, true,\r\n                CONTEXT.spreadElement, true,\r\n                CONTEXT.bindingSet, []\r\n            );\r\n            parser.parseRange(\r\n                PARAMS_TREE, context, left, is_right_parentheses,\r\n                function (node: Token) { return node.type === \"Success\"; }\r\n            ).type = \"Params\";\r\n            context.restore(store);\r\n        }\r\n    ), _Pattern(\"Params\")\r\n).pipe(\r\n    function (context: Context, token: Token, left: number) {\r\n        let [collected, parser] = context;\r\n        let kind = collected.kind;\r\n        let params = token.content ? token.content.content : [];\r\n        let params_count = kind === \"get\" ? 0 : kind === \"set\" ? 1 : false;\r\n        if (params_count !== false && params.length !== params_count) {\r\n            parser.err(...params.splice(params_count, params.length - params_count));\r\n        }\r\n        return params;\r\n    }\r\n);\r\nconst BODY_PATTERN = _Or(\r\n    _Punctuator(\"{\").walk(\r\n        function (context: Context, left: number) {\r\n            let generator = !!this.generator, async = !!this.async;\r\n            let parser = context[CONTEXT.parser];\r\n            let body_context = _Context(parser);\r\n            body_context[CONTEXT.inFunctionBody] = left + 1;\r\n            body_context[CONTEXT.strict] = context[CONTEXT.strict];\r\n            body_context[CONTEXT.allowYield] = generator;\r\n            body_context[CONTEXT.allowAwait] = async;\r\n\r\n            let node = parser.parseRange(\r\n                parser.SYNTAX_TREE, body_context, left, is_right_braces\r\n            );\r\n            node.type = \"Body\";\r\n            node.generator = generator;\r\n            node.async = async;\r\n            let block = new NODES.BlockStatement();\r\n            block.body = node.content;\r\n            attachLocation(block, node);\r\n            node.content = block;\r\n        },\r\n        true\r\n    ), \"Body\"\r\n);\r\nconst FUNCTION_BODY_PATTERN = _Or(\r\n    BODY_PATTERN\r\n).pipe(\r\n    function (context: Context, token: Token) {\r\n        return token.content;\r\n    }\r\n);\r\n\r\nconst PrimaryExpressions: Record<string, any> = {\r\n    \"\": [\r\n        {\r\n            collector: {\r\n                type: _Mark(\"Punctuator\"),\r\n                value: _Mark(\"{}\"),\r\n                content: _Punctuator(\"{\").pipe(\r\n                    function (context: Context, token: Token, left: number) {\r\n                        return context[CONTEXT.parser].parseRange(\r\n                            PROPERTIES_TREE, context, left, is_right_braces\r\n                        ).content || [];\r\n                    }\r\n                )\r\n            }\r\n        },\r\n        {\r\n            collector: {\r\n                type: _Mark(\"Punctuator\"),\r\n                value: _Mark(\"()\"),\r\n                content: _Punctuator(\"(\").walk(\r\n                    walk_primary_expression\r\n                ).pipe(\r\n                    function (context: Context, token: Token, index: number) {\r\n                        return token.content;\r\n                    }\r\n                )\r\n            }\r\n        },\r\n        {\r\n            collector: {\r\n                type: _Mark(\"Punctuator\"),\r\n                value: _Mark(\"[]\"),\r\n                content: _Punctuator(\"[\").pipe(\r\n                    function (context: Context, node: Node, index: number) {\r\n                        return context[CONTEXT.parser].parseRange(\r\n                            PRIMARY_EXPRESSION_TREE, context, index, is_right_brackets\r\n                        ).content;\r\n                    }\r\n                )\r\n            }\r\n        },\r\n    ],\r\n    \"Identifier\": [\r\n    ],\r\n    \"Literal\": [//已在 tokenizer => token_hooks 中处理\r\n    ],\r\n    \"ThisExpression\": {\r\n        collector: {\r\n            token: _NonCollecting(\"Keyword this\")\r\n        }\r\n    },\r\n    \"TemplateLiteral\": {\r\n        filter(context: Context, left: number, right: number) {\r\n            let value = context.getToken(right).value;\r\n            return value[0] === \"`\";\r\n        },\r\n        collector: [\r\n            {\r\n                _: _NonCapturing(_Option(\"[Expression]\")),\r\n                expressions: _Mark(() => []),\r\n                quasis: _Pattern(\"Template\").pipe(\r\n                    function (context: Context, token: Token, index: number) {\r\n                        let [collected, parser] = context;\r\n                        let value: string;\r\n                        let expressions = collected.expressions;\r\n                        let quasis = [];\r\n                        let tail: boolean = false;\r\n                        let end: number;\r\n                        while (true) {\r\n                            token = context.getToken(index);\r\n                            value = token.value;\r\n                            token.value = \"\";\r\n                            if (value[value.length - 1] === \"`\") {\r\n                                end = -1;\r\n                                tail = true;\r\n                            } else {\r\n                                end = -2;\r\n                                tail = false;\r\n                            }\r\n                            quasis.push(\r\n                                {\r\n                                    type: \"TemplateElement\",\r\n                                    value: {\r\n                                        raw: value.slice(1, end),\r\n                                        cooked: parser._bak\r\n                                    },\r\n                                    tail\r\n                                }\r\n                            );\r\n                            if (tail) {\r\n                                break;\r\n                            }\r\n                            expressions.push(\r\n                                parser.parseRangeAsExpression(context, index,\r\n                                    function (token: Token) {\r\n                                        return token.type === TOKEN_TYPE_ENUMS.Template\r\n                                            && token.value[0] === \"}\";\r\n                                    }\r\n                                )\r\n                            )\r\n                        }\r\n                        return quasis;\r\n                    }\r\n                ),\r\n            }\r\n        ]\r\n    },\r\n    \"FunctionExpression\": [\r\n\r\n        {\r\n            collector: [\r\n                {\r\n                    async: _Or(\r\n                        _Series(_Mark(true), _NonCollecting(\"Keyword async\")),\r\n                        _Mark(false)\r\n                    ),\r\n                    __: _NonCollecting(\"Keyword function\"),\r\n                    generator: _Or(\r\n                        _Series(_Mark(true), _NonCollecting(\"Punctuator *\")),\r\n                        _Mark(false)\r\n                    ),\r\n                    id: _Or(IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                    params: PARAMS_PATTERN,\r\n                    body: FUNCTION_BODY_PATTERN,\r\n                    expression: _Mark(false)\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, left] = context;\r\n                context[CONTEXT.start] = context[CONTEXT.end] = left;\r\n                return reinterpretIdentifierAsKeyword(context.getToken(left))\r\n                //return parser.parseKeyword(context.getToken(left));\r\n            },\r\n            filter: [\r\n                function () {\r\n                    return false;\r\n                },\r\n                isAligned\r\n            ],\r\n            collector: [\r\n                { _: _Series(\"Identifier async\", \"Identifier\") },\r\n                {\r\n                    async: \"Identifier async\",\r\n                    _next: _NonCapturing(\"Keyword function\"),\r\n                },\r\n                {\r\n                    async: \"Identifier async\",\r\n                    params: _NonCapturing(\r\n                        _Punctuator(\"(\").walk(\r\n                            walk_primary_expression\r\n                        ), \"Punctuator ()\", \"Identifier\"),\r\n                    token: _NonCapturing(\"Punctuator =>\"),\r\n                },\r\n            ]\r\n        }\r\n    ],\r\n    \"ArrowFunctionExpression\": {\r\n        handler: [\r\n            null,\r\n            function (context: Context) {\r\n                let [collected, parser, left, right] = context;\r\n                let token = context.getToken(right);\r\n                token.value = \"_=>\";\r\n                let body_context = _Context(parser);\r\n                body_context[CONTEXT.strict] = context[CONTEXT.strict];\r\n                body_context[CONTEXT.allowAwait] = collected.async;\r\n                if (\r\n                    parser.parseCustom(\r\n                        parser.EXPRESSION_TREE,\r\n                        body_context,\r\n                        left,\r\n                        (node: Node) => true\r\n                    )\r\n                ) {\r\n                    return null;\r\n                }\r\n            },\r\n            null\r\n        ],\r\n        precedence: [3, true, new Number(3)],\r\n        collector: [\r\n            {//占位使 () 不会被单独收集为表达式\r\n                async: _Or(\r\n                    _Series(_Mark(true), _NonCollecting(\"Keyword async\")),\r\n                    _Mark(false)\r\n                ),\r\n                generator: _Mark(false),\r\n                id: _Mark(null),\r\n                params: _Or(\r\n                    _Punctuator(\"()\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            context.wrap(CONTEXT.tokens, token.content);\r\n                            let res = parse_params(context, token.content);\r\n                            context.unwrap();\r\n                            return res;\r\n                        }\r\n                    ),\r\n                    _Pattern(\"Identifier\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            validateAssignment(context, token);\r\n                            return [token];\r\n                        }\r\n                    )\r\n                ),\r\n                token: _NonCollecting(\"Punctuator =>\"),\r\n                body: FUNCTION_BODY_PATTERN,\r\n                expression: _Mark(false)\r\n            },\r\n            [\"body\", _Mark()],\r\n            [\r\n                //_=>作用为隔断匹配，使后续的表达式使用当前方法声明的环境\r\n                [\"token\", _NonCollecting(\"Punctuator _=>\")],//\"Punctuator _=>\"\r\n                [\"body\", \"[Expression]\"],\r\n                [\"expression\", _Mark(true)]\r\n            ]\r\n        ]\r\n    },\r\n    \"ClassExpression\": {\r\n        collector: [\r\n            {\r\n                _: _NonCollecting(\"Keyword class\"),\r\n                id: _Or(IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                superClass: _Or(\r\n                    _Series(\r\n                        _NonCollecting(\"Keyword extends\"),\r\n                        IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN\r\n                    ),\r\n                    _Mark(null)\r\n                ),\r\n                body:\r\n                    _Punctuator(\"{\").pipe(\r\n                        function (context: Context, token: Token, left: number) {\r\n                            let parser = context[CONTEXT.parser];\r\n                            let res = parser.parseRange(\r\n                                METHOD_DEFINITIONS_TREE, context, left, is_right_braces,\r\n                                function (node: Token) { return node.type === \"Success\"; }\r\n                            );\r\n\r\n                            return {\r\n                                type: \"ClassBody\",\r\n                                body: res.content?.content || [],\r\n                                range: res.range,\r\n                                loc: res.loc\r\n                            };\r\n                        }\r\n                    )\r\n            }\r\n        ]\r\n    },\r\n    \"Super\": {\r\n        validator(context: Context) {\r\n            let [, parser, left, right] = context;\r\n            if (!context[CONTEXT.inFunctionBody] || right === left) {\r\n                parser.err(context.getToken(left));\r\n            }\r\n            return true;\r\n        },\r\n        collector: {\r\n            token: _NonCollecting(\"Keyword super\"),\r\n            _next: _NonCapturing(\"Punctuator ( . [\")\r\n        }\r\n    },\r\n}\r\n\r\nconst Expressions: Record<string, any> = {\r\n    ...PrimaryExpressions,\r\n    \"\": PrimaryExpressions[\"\"].concat(\r\n        {\r\n            validator(context: Context) {\r\n                let parser = context[CONTEXT.parser];\r\n                let left = context[CONTEXT.left];\r\n                let token = context.getToken(left);\r\n                let store = context.store(\r\n                    CONTEXT.bindingSet, null,\r\n                    CONTEXT.bindingElement, false,\r\n                    CONTEXT.tokens, token.content\r\n                );\r\n                let grouping = new Grouping(\r\n                    parser.parseExpression(context)\r\n                );\r\n                context.restore(store);\r\n                context[CONTEXT.start] = context[CONTEXT.end] = left;\r\n                return grouping;\r\n            },\r\n            collector: {\r\n                token: \"Punctuator ()\"\r\n            }\r\n        }\r\n    ),\r\n    \"ArrayExpression\": {\r\n        precedence: 20,\r\n        collector: {\r\n            elements: _Punctuator(\"[]\").pipe(\r\n                function (context: Context, node: Node, index: number) {\r\n                    let store = context.store(\r\n                        CONTEXT.spreadElement, true,\r\n                        CONTEXT.bindingElement, false\r\n                    );\r\n                    let res = parse_and_extract(ARRAY_ELEMENTS_TREE, context, node);\r\n                    context.restore(store);\r\n                    return res;\r\n                }\r\n            ),\r\n        }\r\n\r\n    },\r\n    \"ObjectExpression\": {\r\n        precedence: 20,\r\n        collector: {\r\n            properties: _Punctuator(\"{}\").pipe(\r\n                function (context: Context, node: Node, index: number) {\r\n                    return parse_and_extract(OBJECT_PROPERTIES_TREE, context, node);\r\n                    //return node.content || [];\r\n                }\r\n            ),\r\n        }\r\n\r\n    },\r\n    \"TaggedTemplateExpression\": {\r\n        collector: [\r\n            {\r\n                tag: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                quasi: \"TemplateLiteral\"\r\n            }\r\n        ]\r\n    },\r\n    \"MemberExpression\": [\r\n        {\r\n            precedence: 20,\r\n            collector: {\r\n                object: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                property: _Series(\r\n                    _NonCollecting(\"Punctuator .\"),\r\n                    _Or(\r\n                        \"Identifier\",\r\n                        _Pattern(\"Keyword\").pipe(\r\n                            function (context: Context, token: Token) {\r\n                                return reinterpretKeywordAsIdentifier(token);\r\n                                //return context[CONTEXT.parser].parseIdentifier(token);\r\n                            }\r\n                        )\r\n                    )\r\n                ),\r\n                computed: _Mark(false)\r\n            }\r\n        },\r\n        {\r\n            filter: \"CallExpression\",\r\n            precedence: 20,\r\n            collector: {\r\n                object: EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n                property: _Or(\r\n                    _Punctuator(\"[\").pipe(\r\n                        function (context: Context, token: Token, left: number) {\r\n                            let store = context.store(CONTEXT.bindingElement, false);\r\n                            let res = context[CONTEXT.parser].parseRangeAsExpression(context, left, is_right_brackets);\r\n                            context.restore(store);\r\n                            return res;\r\n                        }\r\n                    ),\r\n                    _Punctuator(\"[]\").pipe(\r\n                        function (context: Context, token: Token, left: number) {\r\n                            let store = context.store(CONTEXT.tokens, token.content, CONTEXT.bindingElement, false);\r\n                            let res = context[CONTEXT.parser].parseExpression(context);\r\n                            context.restore(store);\r\n                            return res;\r\n                        }\r\n                    )\r\n                ),\r\n                computed: _Mark(true)\r\n            }\r\n        }\r\n    ],\r\n\r\n    \"MetaProperty\": {\r\n        handler([collected]: Context) {\r\n            collected.meta.type = \"Identifier\";\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                meta: \"Keyword import\",\r\n                _: _NonCollecting(\"Punctuator .\"),\r\n                property: \"Identifier meta\"\r\n            },\r\n            {\r\n                meta: \"Keyword new\",\r\n                _: _NonCollecting(\"Punctuator .\"),\r\n                property: \"Identifier target\"\r\n            }\r\n        ]\r\n    },\r\n    \"NewExpression\": {\r\n        precedence: new Number(20)/*_Precedence(20, PRECEDENCE_FEATURES.RIGHT_TERMINAL)*/,//memberexpression new Number(20)\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword new\"),\r\n                callee: _Or(\r\n                    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    _Pattern(\"ArrowFunctionExpression\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            context[CONTEXT.parser].err(token);\r\n                        }\r\n                    )\r\n                ),\r\n                arguments: _Or(_Mark(() => []), ARGUMENTS_PATTERN)\r\n            }\r\n        ]\r\n    },\r\n    \"CallExpression\": {\r\n        precedence: 20/* _Precedence(20, PRECEDENCE_FEATURES.RIGHT_TERMINAL)*/,\r\n        filter(context: Context, left: number) {\r\n            let tokens = context.tokens;\r\n            let first_token = tokens[left], second_token = tokens[left + 1];\r\n            if (second_token === context[CONTEXT.rightAssociativeNode]) {\r\n                return false;\r\n            }\r\n            let first_token_type = first_token.type;\r\n            if (\r\n                first_token instanceof Grouping\r\n                || first_token_type !== \"ArrowFunctionExpression\"\r\n            ) {\r\n                return true;\r\n            }\r\n        },\r\n        collector: {\r\n            callee: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n            arguments: ARGUMENTS_PATTERN\r\n        }\r\n\r\n    },\r\n    \"UpdateExpression\": [\r\n        {\r\n            handler(context: Context) {\r\n                let [collected] = context;\r\n                collected.operator = collected.operator.value;\r\n                return collected;\r\n            },\r\n            precedence: 17,\r\n            collector: {\r\n                operator: \"Punctuator ++ --\",\r\n                argument: _Or(\"MemberExpression\", IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\r\n                prefix: _Mark(true),\r\n                /*_: _++a(b)*/\r\n            }\r\n        },\r\n        {\r\n            validator(context: Context) {\r\n                let collected = context[CONTEXT.parser].createNode(context);\r\n                collected.operator = collected.operator.value;\r\n                return collected;\r\n            },\r\n            filter(context: Context, left: number, right: number) {\r\n                return isAligned(context, left, left + 1);\r\n            },\r\n            precedence: 18,\r\n            collector: {\r\n                argument: _Or(\"MemberExpression\", IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\r\n                operator: \"Punctuator ++ --\",\r\n                prefix: _Mark(false),\r\n                _: _Option(\r\n                    _NonCapturing(\r\n                        _Punctuator(\"[\", \"(\").pipe(\r\n                            function (context: Context, token: Token) {\r\n                                context[CONTEXT.rightAssociativeNode] = token;\r\n                            }\r\n                        ),\r\n                        _Punctuator(\".\").pipe(\r\n                            function (context: Context, token: Token) {\r\n                                context[CONTEXT.parser].err(token);\r\n                            }\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n        }\r\n    ],\r\n    \"AwaitExpression\": [\r\n        {\r\n            precedence: 17,\r\n            filter(context: Context) {\r\n                return context[CONTEXT.allowAwait];\r\n            },\r\n            collector: {\r\n                token: _NonCollecting(\"Keyword await\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\r\n            }\r\n        },\r\n        {\r\n            handler([{ token }]: Context) {\r\n                return reinterpretKeywordAsIdentifier(token);\r\n                //return parser.parseIdentifier(collected.token);\r\n            },\r\n            filter(context: Context) {\r\n                return !context[CONTEXT.allowAwait];\r\n            },\r\n            collector: {\r\n                token: \"Keyword await\",\r\n            }\r\n        },\r\n    ],\r\n    \"UnaryExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.operator = collected.operator.value;\r\n            return collected;\r\n        },\r\n        precedence: 17,\r\n        collector: [\r\n            {\r\n                operator: _Or(\"Punctuator ~ ! + -\", \"Keyword delete void typeof\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                prefix: _Mark(true)\r\n            }\r\n        ]\r\n    },\r\n    \"BinaryExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.operator = collected.operator.value;\r\n            return collected;\r\n        },\r\n        validator(context: Context) {\r\n            return context[CONTEXT.right] - context[CONTEXT.left] >= 2\r\n        },\r\n        precedence: [16, 15, 14, 13, 12, 11, 10, 9, 8, 7],\r\n        collector: [\r\n            {\r\n                left: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                operator: `Punctuator **`,\r\n                right: _Option(EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN)\r\n            },\r\n            [\"operator\", `Punctuator * / %`],\r\n            [\"operator\", `Punctuator + -`],\r\n            [\"operator\", `Punctuator << >> >>>`],\r\n            [\"operator\", _Or(`Punctuator < <= > >=`, `Keyword in instanceof`)],\r\n            [\"operator\", `Punctuator == != === !==`],\r\n            [\"operator\", `Punctuator &`],\r\n            [\"operator\", `Punctuator ^`],\r\n            [\"operator\", `Punctuator |`],\r\n            [\"operator\", `Punctuator ??`]\r\n        ]\r\n    },\r\n    \"LogicalExpression\": {\r\n        validator(context: Context) {\r\n            if (context[CONTEXT.right] - context[CONTEXT.left] === 2) {\r\n                let collected = context[CONTEXT.parser].createNode(context);\r\n                collected.operator = collected.operator.value;\r\n                return collected;\r\n            }\r\n        },\r\n        precedence: [6, 5],\r\n        collector: [\r\n            {\r\n                left: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                operator: \"Punctuator &&\",\r\n                right: _Option(EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN)\r\n            },\r\n            [\"operator\", \"Punctuator ||\"]\r\n        ]\r\n    },\r\n    \"ConditionalExpression\": [\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, left, right] = context;\r\n                if (right - left >= 4) {\r\n                    return true;\r\n                }\r\n                if (!context[CONTEXT.isExpression] || context[CONTEXT.bindingElement]) {\r\n                    let store = context.store(CONTEXT.isExpression, true, CONTEXT.bindingElement, null);\r\n                    parser.parseCustom(\r\n                        parser.EXPRESSION_TREE,\r\n                        context,\r\n                        left,\r\n                        (node: Node) => node.type === \"ConditionalExpression\"\r\n                    );\r\n                    context.restore(store);\r\n                    return null;\r\n                }\r\n            },\r\n            precedence: new Number(3),//与 Assignment 为右优先\r\n            collector: [\r\n                {\r\n                    test: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,//EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS\r\n                    token: _NonCollecting(\"Punctuator ?\")\r\n                },\r\n                [\"consequent\", EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN],\r\n                [\"_\", _NonCollecting(\"Punctuator :\")],\r\n                [\"alternate\", EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN]\r\n            ]\r\n        },\r\n    ],\r\n    \"YieldExpression\": [\r\n        {\r\n            /*filter(context: Context) {\r\n                return context[CONTEXT.allowYield];\r\n            },*/\r\n            precedence: 2,\r\n            collector: [\r\n                {\r\n                    token: _NonCollecting(\"Keyword yield\"),\r\n                    _: _NonCollecting(\"Punctuator *\"),\r\n                    argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    delegate: _Mark(true)\r\n                },\r\n                {\r\n                    token: _NonCollecting(\"Keyword yield\"),\r\n                    argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    delegate: _Mark(false)\r\n                }\r\n            ]\r\n        },\r\n        /*{\r\n            handler([{ token }]: Context) {\r\n                return reinterpretKeywordAsIdentifier(token)\r\n                //return parser.parseIdentifier(collected.token);\r\n            },\r\n            filter(context: Context) {\r\n                return !context[CONTEXT.allowYield];\r\n            },\r\n            collector: {\r\n                token: \"Keyword yield\"\r\n            }\r\n        },*/\r\n    ],\r\n    \"AssignmentExpression\": {\r\n        validator: \"LogicalExpression\",\r\n        precedence: new Number(3),//Right-associative\r\n        collector: {\r\n            left: _Or(\r\n                _Or(\"[Expression]\").pipe(\r\n                    function (context: Context, expr: Node) {\r\n                        context[CONTEXT.parser].err(expr);\r\n                    }\r\n                ),\r\n                \"AssignmentExpression\",\r\n                \"MemberExpression\",\r\n                \"AssignmentPattern\",\r\n                \"ArrayPattern\",\r\n                \"ObjectPattern\",\r\n                IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\r\n            ),\r\n            operator: ASSIGNMENT_PUNCTUATORS_PATTERN,\r\n            right: _Option(\"[Expression]\")//占位避免错误断句\r\n        }\r\n    },\r\n    \"SequenceExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            let expressions: Array<Node> = collected.expressions;\r\n            if (expressions[0] instanceof NODES.SequenceExpression) {\r\n                expressions[0].expressions.push(expressions[1]);\r\n                collected.expressions = expressions[0].expressions\r\n            }\r\n            return collected\r\n        },\r\n        validator(context: Context) {\r\n            let [, , left, right] = context;\r\n            if (right - left === 2) {\r\n                return true;\r\n            }\r\n        },\r\n        precedence: 1,\r\n        collector: {\r\n            expressions: _Series(\r\n                EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _NonCollecting(\"Punctuator ,\"),\r\n                _Option(EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN)\r\n            )\r\n        }\r\n\r\n    }\r\n}\r\n\r\nconst COMPUTED_PROPERTY_NAME_PATTERN = _Punctuator(\"[]\").pipe(\r\n    function (context: Context, token: Token) {\r\n        let [collected, parser] = context;\r\n        collected.computed = true;\r\n        context.wrap(CONTEXT.tokens, token.content)\r\n        let res = parser.parseExpression(context);\r\n        context.unwrap();\r\n        return res;\r\n    }\r\n);\r\n\r\nconst LITERAL_PROPERTY_NAME_PATTERN = _Or(\"Identifier\", \"Keyword\", \"Literal\").pipe(\r\n    function (context: Context, key: Token) {\r\n        let [, parser] = context;\r\n        if (key instanceof Grouping) {\r\n            parser.err(key);\r\n        } else {\r\n            switch (key.type) {\r\n                case \"Keyword\":\r\n                    return reinterpretKeywordAsIdentifier(key);\r\n                //return parser.parseIdentifier(key);\r\n                case \"Literal\":\r\n                    if (key.regex) {\r\n                        parser.err(key);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n);\r\nconst PROPERTY_NAME_PATTERN = _Or(COMPUTED_PROPERTY_NAME_PATTERN, LITERAL_PROPERTY_NAME_PATTERN);\r\n\r\n\r\nconst MethodDefinitions = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: \"MethodDefinition\",\r\n            }\r\n        ]\r\n    },\r\n    \"\": {\r\n        validator(context: Context) {\r\n            context[CONTEXT.start] = context[CONTEXT.end] = context[CONTEXT.right];\r\n            return [];\r\n        },\r\n        collector: {\r\n            _: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n            __: \"Punctuator ;\"\r\n        }\r\n    },\r\n    MethodDefinition: {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            let { value } = collected;\r\n            collected.kind = value.kind;\r\n            delete value.kind;\r\n            collected.computed = value.computed;\r\n            delete value.computed;\r\n            collected.key = value.key;\r\n            delete value.key;\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                key: _Mark(\"\"),\r\n                static: _Mark(true),\r\n                computed: _Mark(false),\r\n                _static: _NonCollecting(\"Identifier static\"),\r\n                value: \"FunctionExpression\",\r\n                kind: _Mark(\"\"),\r\n            },\r\n            [\r\n                [\"static\", _Mark(false)],\r\n                [\"_static\", _Mark()]\r\n            ]\r\n        ]\r\n    },\r\n    FunctionExpression: {\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                static: _Option(_NonCapturing(\"Identifier static\")),\r\n                async: _Or(\r\n                    _Series(_Mark(true), _NonCollecting(\"Identifier async\")),\r\n                    _Mark(false)\r\n                ),\r\n                generator: _Or(\r\n                    _Series(_Mark(true), _NonCollecting(\"Punctuator *\")),\r\n                    _Mark(false)\r\n                ),\r\n                kind: _Mark(\"method\"),\r\n                computed: _Mark(false),\r\n                key: PROPERTY_NAME_PATTERN,\r\n                id: _Mark(null),\r\n                params: PARAMS_PATTERN,\r\n                expression: _Mark(false),\r\n                body: FUNCTION_BODY_PATTERN\r\n            },\r\n            [\r\n                [\"generator\", _Mark(false)],\r\n                [\r\n                    \"kind\", _Or(\"Identifier get set\").pipe(\r\n                        function (context: Context, token: Token, left: number) {\r\n                            return token.value;\r\n                        }\r\n                    )\r\n                ]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst Arguments = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        //precedence: 0,\r\n        collector: {\r\n            success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n            content: _Or(\"SpreadElement\", EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\r\n            _: _Or(_NonCollecting(\"Punctuator ,\"), MATCH_MARKS.BOUNDARY, _NonCapturing(\"Punctuator )\")),\r\n        }\r\n    }\r\n}\r\n\r\nconst Params = {\r\n    \"Success\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            if (collected.content instanceof Grouping) {\r\n                parser.err(collected.content);\r\n            }\r\n            return join_content(context);\r\n        },\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: \"AssignmentPattern\",\r\n                _: _Or(_NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY), _NonCapturing(\"Punctuator )\")),\r\n            },\r\n            [\r\n                \"content\", _Or(\"Identifier\").pipe(\r\n                    function (context: Context, token: Token) {\r\n                        validateBinding(context, token);\r\n                    }\r\n                )\r\n            ],\r\n            [\"content\", _Or(\"ArrayPattern\", \"ObjectPattern\")],\r\n            [\r\n                [\"content\", \"RestElement\"],\r\n                [\"_\", _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), _NonCapturing(\"Punctuator )\"))]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst ArrayElements = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: _Or(\"SpreadElement\", EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN),\r\n                _: _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY),\r\n            },\r\n            [\r\n                [\"content\", _Mark(null)],\r\n                [\"_\", _NonCollecting(\"Punctuator ,\")]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst Properties = {\r\n    \"Property\": {\r\n        handler(context: Context) {\r\n            let [collected, parser, left, right] = context;\r\n            let { value: [params, body] } = collected;\r\n            let expr = new NODES.FunctionExpression();\r\n            expr.id = null;\r\n            expr.params = params;\r\n            expr.body = body.content;\r\n            expr.generator = body.generator;\r\n            expr.expression = false;\r\n            expr.async = body.async;\r\n            attachLocation(expr, collected, context.getToken(right - 1));\r\n            collected.value = expr;\r\n            collected.type = \"ObjectProperty\"\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Punctuator ,\", \"ObjectProperty\"),\r\n                async: _Option(_NonCollecting(\"Identifier async\")),\r\n                generator: _Option(_NonCollecting(\"Punctuator *\")),\r\n                kind: _Mark(\"init\"),\r\n                computed: _Mark(false),\r\n                key: PROPERTY_NAME_PATTERN,\r\n                value: _Series(PARAMS_PATTERN, BODY_PATTERN),\r\n                _next: _Or(\r\n                    _NonCollecting(MATCH_MARKS.BOUNDARY, \"Punctuator ,\"),\r\n                    _NonCapturing(\"Punctuator }\")\r\n                ),\r\n                //_NonCapturing(MATCH_MARKS.BOUNDARY, \"Punctuator ,\", \"Punctuator }\"),\r\n                method: _Mark(true),\r\n                shorthand: _Mark(false)\r\n            },\r\n            [\r\n                [\"async\", _Mark()],\r\n                [\"generator\", _Mark()],\r\n                [\r\n                    \"kind\", _Or(\r\n                        _Series(_NonCollecting(\"Identifier get\"), _Mark(\"get\")),\r\n                        _Series(_NonCollecting(\"Identifier set\"), _Mark(\"set\"))\r\n                    )\r\n                ],//\"Identifier get set\"\r\n                [\"method\", _Mark(false)]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst ObjectProperties = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: _Or(\r\n                    \"Property\",\r\n                    _Or(\"ObjectProperty\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            token.type = \"Property\";\r\n                        }\r\n                    )\r\n                ),\r\n            }\r\n        ]\r\n    },\r\n    \"Property\": {\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                key: PROPERTY_NAME_PATTERN,//\"TemplateLiteral\"\r\n                value: _Series(\r\n                    _NonCollecting(\"Punctuator :\"),\r\n                    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN\r\n                ),\r\n                _next: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY, \"Punctuator ,\"), _NonCapturing(\"Punctuator }\")),\r\n                kind: _Mark(\"init\"),\r\n                computed: _Mark(false),\r\n                method: _Mark(false),\r\n                shorthand: _Mark(false),\r\n            },\r\n            [\r\n                [\"key\", \"Identifier\"],\r\n                [\"value\", (window as any).test1 = _Mark(function (context: Context) {\r\n                    return context[CONTEXT.collected].key;\r\n                })],\r\n                [\"shorthand\", _Mark(true)]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nlet PRIMARY_EXPRESSION_TREE = createMatchTree(\r\n    PrimaryExpressions\r\n)\r\n\r\nlet UNIT_EXPRESSION_TREE = createMatchTree(\r\n    [Expressions, Patterns],\r\n    undefined,\r\n    [\"SequenceExpression\"]\r\n);\r\nlet METHOD_DEFINITIONS_TREE = createMatchTree(\r\n    MethodDefinitions, PRIMARY_EXPRESSION_TREE\r\n);\r\nlet ARRAY_ELEMENTS_TREE = createMatchTree(ArrayElements, UNIT_EXPRESSION_TREE);\r\n\r\n\r\nlet PROPERTIES_TREE = createMatchTree(\r\n    Properties,\r\n    PRIMARY_EXPRESSION_TREE\r\n);\r\nlet OBJECT_PROPERTIES_TREE = createMatchTree(\r\n    ObjectProperties,\r\n    UNIT_EXPRESSION_TREE\r\n);\r\n\r\nconst PARAMS_TREE = createMatchTree(\r\n    Params,\r\n    UNIT_EXPRESSION_TREE\r\n);\r\nconst ARGUMENTS_TREE = createMatchTree(\r\n    Arguments,\r\n    UNIT_EXPRESSION_TREE\r\n);\r\n\r\nlet EXPRESSION_TREE = createMatchTree(\r\n    { SequenceExpression: Expressions.SequenceExpression }\r\n    , UNIT_EXPRESSION_TREE\r\n)\r\n\r\nfor (const type_name in Expressions) {\r\n    if (type_name) {\r\n        TYPE_ALIAS[type_name] = [type_name, \"[Expression]\"];\r\n    }\r\n}\r\nexport {\r\n    Expressions,\r\n    EXPRESSION_TREE,\r\n    UNIT_EXPRESSION_TREE,\r\n    parseArrayPattern,\r\n    parseObjectPattern,\r\n    parse_params\r\n};\r\nfunction parse_params(context: Context, tokens: Array<Token>) {//\r\n    if (tokens.length) {\r\n        let parser = context[CONTEXT.parser];\r\n        let restore = context.store(\r\n            CONTEXT.tokens, tokens,\r\n            CONTEXT.bindingElement, true\r\n        );\r\n        context[CONTEXT.strict] && context.wrap(CONTEXT.bindingSet, []);\r\n        parser.parseCustom(PARAMS_TREE, context);\r\n        context.restore(restore);\r\n        return extract_success(parser, tokens);\r\n    }\r\n    return [];\r\n}\r\n","//import { Token } from './interfaces'\r\nconst IdentifierStart = /[\\x24\\x5f\\x41-\\x5a\\x61-\\x7a]|[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\r\nconst IdentifierPart = /[\\x24\\x5f\\x41-\\x5a\\x61-\\x7a\\x30-\\x39]|[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD46\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E\\uDC5F\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\r\n\r\nexport default class {\r\n    public input: string;\r\n    public index: number;\r\n    public end: number;\r\n    public _bak: any;\r\n    public _scope: any;\r\n    private testCodePoint(regexp: RegExp) {\r\n        if (\r\n            (this.input.charCodeAt(this.index) & 0xfc00) === 0xd800\r\n            && (this.input.charCodeAt(this.index + 1) & 0xfc00) === 0xdc00\r\n        ) {\r\n            this._bak = this.input[this.index] + this.input[this.index + 1];\r\n            return regexp.test(this._bak) ? 2 : 0;\r\n        } else {\r\n            return regexp.test(this.input[this.index]) ? 1 : 0;\r\n        }\r\n    }\r\n    testUnicodeEscape(regexp: RegExp) {\r\n        let index = this.index + 1, code = 0;\r\n        if (this.input[index++] === \"u\") {\r\n            let cp = 0;\r\n            if (this.input[index] === \"{\") {\r\n                while (\r\n                    (code = this.hexValue(this.input.charCodeAt(++index))) >= 0\r\n                ) {\r\n                    cp = cp * 16 + code;\r\n                }\r\n                if (this.input[index++] !== \"}\") {/* || index < this.index + 5*/\r\n                    return 0;\r\n                }\r\n            } else {\r\n                let len = 4;\r\n                while (len--) {\r\n                    code = this.hexValue(this.input.charCodeAt(index++));\r\n                    if (code >= 0) {\r\n                        cp = cp * 16 + code;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                }\r\n            }\r\n            return regexp.test(this.fromCodePoint(cp))\r\n                ? index - this.index\r\n                : -(index - this.index);\r\n        }\r\n        return 0;\r\n    }\r\n    scanHex(length: number = this.end): [number, number] {\r\n        let value = 0, code = 0, len = length;\r\n        while (len) {\r\n            code = this.hexValue(this.input.charCodeAt(this.index));\r\n            if (code >= 0) {\r\n                len--;\r\n                value = value * 16 + code;\r\n            } else {\r\n                break;\r\n            }\r\n            this.index++;\r\n        }\r\n        return [value, length - len];\r\n    }\r\n    hexValue(ch: number) {\r\n        return ch >= 0x30 && ch <= 0x39 ? ch - 0x30 :\r\n            ch >= 0x41 && ch <= 0x46 ? ch - 0x41 + 10 :\r\n                ch >= 0x61 && ch <= 0x66 ? ch - 0x61 + 10 : -1;\r\n    }\r\n    decimalValue(ch: number) {\r\n        return ch >= 0x30 && ch <= 0x39 ? ch - 0x30 : -1;\r\n    }\r\n    octalValue(ch: number) {\r\n        return ch >= 0x30 && ch <= 0x37 ? ch - 0x30 : -1;\r\n    }\r\n    binaryValue(ch: number) {\r\n        return ch === 0x30 || ch == 0x31 ? ch - 0x30 : -1;\r\n    }\r\n    //https://github.com/jquery/esprima/blob/master/src/character.ts\r\n    isWhiteSpace(ch: number) {\r\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\r\n            (ch >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\r\n        /*return /^\\x20|\\x09|\\x0B|\\x0C|\\xA0|\\xfeff$/.test(char);*/\r\n    }\r\n    isLineTerminator(ch: number) {\r\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\r\n        /*return /^\\x0A|\\x0D|\\x2028|\\x2029$/.test(char);*/\r\n    }\r\n    fromCodePoint(cp: number) {\r\n        return this._bak = cp < 0x10000\r\n            ? String.fromCharCode(cp)\r\n            : String.fromCharCode(0xd800 + (cp - 0x10000) >> 10)\r\n            + String.fromCharCode(0xdc00 + (cp - 0x10000) & 1023);\r\n    }\r\n    inIdentifierStart() {\r\n        let ch = this.input.charCodeAt(this.index);\r\n        return (ch === 0x24) || (ch === 0x5F) ||\r\n            (ch >= 0x41 && ch <= 0x5A) ||\r\n            (ch >= 0x61 && ch <= 0x7A) ? 1 : (\r\n                ch >= 0x80\r\n                    ? this.testCodePoint(IdentifierStart)\r\n                    : (ch === 0x5c ? this.testUnicodeEscape(IdentifierStart) : 0)\r\n            );\r\n        /*return /^[_$a-zA-Z\\u0080-\\uffffff]$/.test(char);*/\r\n    }\r\n    inIdentifierPart() {\r\n        let ch = this.input.charCodeAt(this.index);\r\n        return (ch === 0x24) || (ch === 0x5F) ||\r\n            (ch >= 0x41 && ch <= 0x5A) ||\r\n            (ch >= 0x61 && ch <= 0x7A) ||\r\n            (ch >= 0x30 && ch <= 0x39) ? 1 : (\r\n                ch >= 0x80\r\n                    ? this.testCodePoint(IdentifierPart)\r\n                    : (ch === 0x5c ? this.testUnicodeEscape(IdentifierPart) : 0)\r\n            );\r\n        /*return /^[\\w$\\u0080-\\uffffff]$/.test(char);*/\r\n    }\r\n    /*isFollowingAnExpression(token?: Token) {\r\n        return token ? [\r\n            'in', 'typeof', 'instanceof', 'new',\r\n            'return', 'case', 'delete', 'throw', 'void',\r\n            // assignment operators\r\n            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',\r\n            '&=', '|=', '^=', ',',\r\n            // binary/unary operators\r\n            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\r\n            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\r\n            '<=', '<', '>', '!=', '!=='\r\n        ].indexOf(token.value) >= 0 : false;\r\n    }*/\r\n}","\r\n\r\nimport {\r\n    PRIOR_REGEXP_PUNCTUATORS_TREE,\r\n    PUNCTUATORS_TREE,\r\n    NUMERIC_KEYWORD_MAP,\r\n    TOKEN_TYPE_MAPPERS, TOKEN_TYPE_ENUMS\r\n} from \"./lexical/index\";\r\nimport Character from './character'\r\nimport {\r\n    Position, SourceLocation, Token, SearchTree, NUMERIC_TYPE, Validate\r\n} from \"./interfaces\";\r\n\r\nconsole.log(23, TOKEN_TYPE_ENUMS,TOKEN_TYPE_MAPPERS);\r\n\r\nexport default class extends Character {\r\n    constructor(options?: Record<string, any>) {\r\n        super()\r\n        for (const key in options) {\r\n            this[key] = options[key];\r\n        }\r\n        //console.log(333, TOKEN_TYPES,TOKEN_TYPE_MAP);\r\n    }\r\n    tokens: Array<Token>;\r\n    public token_hooks: Record<string, (token: Token, tokenizer: this) => Token> = {};\r\n    public line_number: number;\r\n    public line_start: number;\r\n    public save_comments: boolean = true;\r\n    public error_logs: Array<any>;\r\n    public terminator_stack: Array<Validate>;\r\n    err(...args: any) {\r\n        //debugger;\r\n        this.error_logs.push.apply(this.error_logs, arguments);\r\n    }\r\n    init(input: string) {\r\n        this.line_number = 0;\r\n        this.line_start = 0;\r\n        this.index = 0;\r\n        this.input = input;\r\n        this.end = this.input.length;\r\n        this.error_logs = [];\r\n        this.tokens = [];\r\n        this.terminator_stack = [];\r\n    }\r\n    tokenize(input: string): Array<Token> {\r\n        this.init(input);\r\n        while (this.nextToken());\r\n        return this.tokens;\r\n    }\r\n    nextToken() {\r\n        while (\r\n            this.index < this.end\r\n            && (\r\n                this.terminator_stack.length === 0\r\n                || this.tokens.length === 0\r\n                || !this.terminator_stack[0](this.tokens[this.tokens.length - 1])\r\n            )\r\n        ) {\r\n            let token = this._nextToken();\r\n            if (token) {\r\n                let hook = this.token_hooks[token.type];\r\n                hook && (token = hook(token, this));\r\n                if (this.save_comments || token.type !== TOKEN_TYPE_ENUMS.Comments) {\r\n                    this.tokens.push(token);\r\n                    return token;\r\n                }\r\n            } else if (this.index < this.end) {\r\n                this.err(this.createToken(\"error\", [this.index, ++this.index]))\r\n            }\r\n        }\r\n    }\r\n    createToken(\r\n        type: string | number,\r\n        range: [number, number],\r\n        value: any = this.input.slice(range[0], range[1]),\r\n        start: Position = {\r\n            line: this.line_number,\r\n            column: range[0] - this.line_start\r\n        },\r\n        end: Position = {\r\n            line: this.line_number,\r\n            column: range[1] - this.line_start\r\n        },\r\n    ): Token {\r\n        return {\r\n            type: type,\r\n            value,\r\n            range,\r\n            loc: {\r\n                start, end\r\n            }\r\n        };\r\n    }\r\n    private match(node: SearchTree) {\r\n        let start = this.index, end = this.index;\r\n        let prev_node: Token;\r\n        do {\r\n            prev_node = node;\r\n            node = prev_node[this.input[end++]];\r\n        } while (node)\r\n        let target: any = prev_node.__;\r\n        if (target && (target.type || (target = target(this)))) {\r\n            this.index = end - 1;\r\n            return target.scanner ?\r\n                target.scanner(this, start) :\r\n                this.createToken(\r\n                    TOKEN_TYPE_ENUMS[target.type],\r\n                    [start, this.index],\r\n                    target.key\r\n                );\r\n        }\r\n    }\r\n    private nextIdentifier(): Token | void {\r\n        let length = this.inIdentifierStart();\r\n        let token: Token;\r\n        if (length > 0) {\r\n            let start = this.index;\r\n            let str = \"\";\r\n            do {\r\n                str += length === 1 ? this.input[this.index] : this._bak;\r\n                this.index += length;\r\n                length = this.inIdentifierPart();\r\n            } while (length > 0)\r\n            let type = TOKEN_TYPE_MAPPERS[\" \" + str];\r\n            token = this.createToken(\r\n                TOKEN_TYPE_ENUMS[type || \"Identifier\"],\r\n                [start, this.index]\r\n            );\r\n            this._bak = str;\r\n            if (type && str.length !== this.index - start) {\r\n                this.err(token);\r\n            }\r\n        }\r\n        if (length < 0) {\r\n            this.err(this.createToken(\"error\", [this.index, this.index -= length]));\r\n        }\r\n        return token;\r\n    }\r\n    get maybe_regex() {\r\n        if (this.input[this.index] === \"/\") {\r\n            let is_primary_expr_start = (this as any).is_primary_expr_start;\r\n            return is_primary_expr_start !== undefined\r\n                ? is_primary_expr_start\r\n                : !this.tokens.length || this.tokens[this.tokens.length - 1].type === TOKEN_TYPE_ENUMS.Punctuator;\r\n        }\r\n    }\r\n    private nextPunctuator(): Token | void {\r\n        return this.match(!this.maybe_regex ? PUNCTUATORS_TREE : PRIOR_REGEXP_PUNCTUATORS_TREE);\r\n    }\r\n\r\n    private nextNumeric(): Token | void {\r\n        let start = this.index;\r\n        let ch = this.input.charCodeAt(this.index);\r\n        let number: number;\r\n        let flags = NUMERIC_TYPE.DECIMAL;\r\n        let _get_token = () => {\r\n            this._bak = flags & NUMERIC_TYPE.OCTAL ? (flags & ~NUMERIC_TYPE.DECIMAL) : flags;\r\n            return this.createToken(TOKEN_TYPE_ENUMS.Numeric, [start, this.index]);\r\n        }\r\n        let _get_error = (message: string = \"Invalid or unexpected token\") => {\r\n            let error = _get_token();\r\n            error.error = message;\r\n            error.input = this.input.slice(start, this.index + 1);\r\n            this.err(error);\r\n            return error;\r\n        }\r\n        let decimalValue = this.decimalValue;\r\n        switch (ch) {\r\n            case 0x2e://\".\"\r\n                if (decimalValue(this.input.charCodeAt(this.index + 1)) >= 0) {\r\n                    this.index += 1;\r\n                    flags |= NUMERIC_TYPE.FLOAT;\r\n                    break;\r\n                } else {\r\n                    return;\r\n                }\r\n            case 0x30://\"0\"\r\n                flags = NUMERIC_KEYWORD_MAP[this.input[++this.index]];\r\n                if (!flags) {\r\n                    number = decimalValue(this.input.charCodeAt(this.index));\r\n                    if (number >= 0) {\r\n                        flags = NUMERIC_TYPE.DECIMAL;\r\n                        number < 8 && (flags |= NUMERIC_TYPE.OCTAL);\r\n                    } else if (!this.inIdentifierStart()) {\r\n                        flags = NUMERIC_TYPE.DECIMAL;\r\n                        return _get_token();\r\n                    } else {\r\n                        return _get_error();\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                if (decimalValue(ch) < 0) {\r\n                    return;\r\n                }\r\n        }\r\n        if (flags & NUMERIC_TYPE.DECIMAL) {\r\n            while ((ch = this.input.charCodeAt(++this.index))) {\r\n                number = decimalValue(ch)\r\n                if (number >= 0) {\r\n                    number < 8 || (flags &= ~NUMERIC_TYPE.OCTAL);\r\n                    continue;\r\n                }\r\n                switch (ch) {\r\n                    case 0x65://\"e\"\r\n                    case 0x45://\"E\"\r\n                        if (!(flags & (NUMERIC_TYPE.E | NUMERIC_TYPE.OCTAL))) {\r\n                            flags |= NUMERIC_TYPE.E;\r\n                            ch = this.input.charCodeAt(this.index + 1);\r\n                            if (ch === 0x2b || ch === 0x2d) {//+ -\r\n                                this.index += 1;\r\n                            }\r\n                            continue;\r\n                        } else {\r\n                            return _get_error();\r\n                        }\r\n                    case 0x2e://\".\"\r\n                        if (!(flags & (NUMERIC_TYPE.FLOAT | NUMERIC_TYPE.E | NUMERIC_TYPE.OCTAL))) {\r\n                            flags |= NUMERIC_TYPE.FLOAT;\r\n                            continue;\r\n                        }\r\n                    default:\r\n                        return this.inIdentifierStart()\r\n                            ? _get_error()\r\n                            : _get_token();\r\n                }\r\n            }\r\n            return _get_token();\r\n        } else {\r\n            let test = flags & NUMERIC_TYPE.HEX\r\n                ? this.hexValue : (\r\n                    flags & NUMERIC_TYPE.BINARY\r\n                        ? this.binaryValue\r\n                        : this.octalValue\r\n                );\r\n            while (test(this.input.charCodeAt(++this.index)) >= 0);\r\n            return this.index > start + 3 && !this.inIdentifierStart()\r\n                ? _get_token()\r\n                : _get_error();\r\n        }\r\n    }\r\n    private _nextToken(): Token | void {\r\n        for (let cp: number; this.index < this.end; this.index++) {\r\n            cp = this.input.charCodeAt(this.index);\r\n            switch (true) {\r\n                case this.isWhiteSpace(cp):\r\n                    break;\r\n                case this.isLineTerminator(cp):\r\n                    this.line_number++;\r\n                    this.line_start = this.index + 1;\r\n                    break;\r\n                default:\r\n                    return this.nextIdentifier() ||\r\n                        this.nextNumeric() ||\r\n                        this.nextPunctuator();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n","\r\nimport {\r\n    Token, SearchTree, MATCH_STATUS\r\n} from '../interfaces';\r\n\r\nimport Tokenizer from '../tokenizer'\r\n\r\nfunction createSearchTree(\r\n    data: Array<string | string[] | Record<string, any>>,\r\n    root: Record<string, any> = {},\r\n    block_list: Array<string> = []\r\n): SearchTree {\r\n    for (let item of data as any) {\r\n        let node = root;\r\n        switch (true) {\r\n            case typeof item === \"string\":\r\n                item = {\r\n                    type: \"Punctuator\",\r\n                    key: item,\r\n                }\r\n                break;\r\n            default:\r\n                item.type === undefined && (item.type = \"Punctuator\");\r\n                break;\r\n        }\r\n        if (~block_list.indexOf(item.key)) {\r\n            continue;\r\n        }\r\n        for (const part of item.key) {\r\n            node = node[part] || (node[part] = {});\r\n        }\r\n        if (node.__ && !item.overload) {\r\n            let next_item = node.__;\r\n            let curr_item = item;\r\n            if (typeof next_item === \"function\") {\r\n                if (curr_item.filter) {\r\n                    node.__ = function (tokenizer: Tokenizer) {\r\n                        return curr_item.filter(tokenizer) ? curr_item : next_item(tokenizer);\r\n                    }\r\n                } else {\r\n                    node.__ = function (tokenizer: Tokenizer) {\r\n                        return next_item(tokenizer) || curr_item;\r\n                    }\r\n                }\r\n                continue;\r\n            } else if (curr_item.filter) {\r\n                node.__ = function (tokenizer: Tokenizer) {\r\n                    return curr_item.filter(tokenizer) ? curr_item : next_item;\r\n                }\r\n                continue;\r\n            } else {\r\n                console.warn(\"conflict:\", node, node.__, item);\r\n            }\r\n        }\r\n        node.__ = item.filter ?\r\n            function (tokenizer: Tokenizer) { return item.filter(tokenizer) && item; } :\r\n            item;\r\n    }\r\n    return root;\r\n}\r\n\r\n\r\nconst enum MARKS {\r\n    EOF = \"\",\r\n    ESCAPE = \"\\\\\"\r\n}\r\nfunction escape_scan(\r\n    tokenizer: Tokenizer,\r\n    start: number,\r\n    scope?: Record<string, any>,\r\n) {\r\n    let error: string;\r\n    let line_number = tokenizer.line_number;\r\n    let line_start = tokenizer.line_start;\r\n    let root = this.match_tree;\r\n    let node = root;\r\n    let path = \"\";\r\n    let str = \"\";\r\n    let char: string;\r\n    let backslash_count = 0;\r\n    let token: Token;\r\n    let self = this;\r\n\r\n    while (char = tokenizer.input[tokenizer.index++]) {\r\n        let has_escape = backslash_count % 2;\r\n        if (char === MARKS.ESCAPE) {\r\n            backslash_count += 1;\r\n            if (has_escape) {\r\n                path += char;\r\n                node = node[MARKS.ESCAPE]\r\n            }\r\n        } else {\r\n            path += char;\r\n            backslash_count = 0;\r\n            if (tokenizer.isLineTerminator(char.charCodeAt(0))) {\r\n                node = node[\r\n                    has_escape\r\n                        ? `${MARKS.ESCAPE}\\n`\r\n                        : \"\\n\"\r\n                ];\r\n                if (node && node._state === MATCH_STATUS.END) {\r\n                    tokenizer.index -= 1;\r\n                    if ((token = _next())) {\r\n                        return token;\r\n                    }\r\n                    tokenizer.index += 1;\r\n                }\r\n                tokenizer.line_number += 1;\r\n                tokenizer.line_start = tokenizer.index;\r\n            } else {\r\n                node = node[!has_escape ? char : MARKS.ESCAPE + char];\r\n            }\r\n        }\r\n        if (node && (token = _next())) {\r\n            return token;\r\n        }\r\n        if (!node) {\r\n            str += path;\r\n            node = root;\r\n            path = \"\";\r\n        }\r\n    }\r\n    if ((node = root[MARKS.EOF])) {\r\n        return _next();\r\n    } else {\r\n        tokenizer.err(_finally());\r\n    }\r\n    function _finally() {\r\n        tokenizer._scope = scope;\r\n        tokenizer._bak = str;\r\n        return tokenizer.createToken(\r\n            self.type,\r\n            [start, tokenizer.index],\r\n            undefined, { line: line_number, column: start - line_start }\r\n        );\r\n    }\r\n    function _next() {\r\n        node._error && (error = node._error);\r\n        switch (node._state) {\r\n            case MATCH_STATUS.END:\r\n                if (\r\n                    !node._end\r\n                    || node._end(tokenizer, scope, start, error)\r\n                ) {\r\n                    let token = _finally();\r\n                    if (node._error || error) {\r\n                        token.error = (node._error || error);\r\n                        tokenizer.err(token);\r\n                    }\r\n                    return token;\r\n                }\r\n                break;\r\n            case MATCH_STATUS.ATTACH:\r\n                let res = node._attach(tokenizer, scope, start, error);\r\n                res && (path = res);\r\n                break;\r\n            case MATCH_STATUS.ERROR:\r\n                error || (error = \"Invalid or unexpected token\");\r\n            case MATCH_STATUS.NEXT:\r\n                if (node._next) {\r\n                    tokenizer._bak = str;\r\n                    return node._next(tokenizer, scope, start, error);\r\n                }\r\n                break;\r\n            default:\r\n                if (node._str === undefined) {\r\n                    return;\r\n                } else {\r\n                    path = node._str;\r\n                }\r\n        }\r\n        node = null;\r\n    }\r\n}\r\n/*\r\nfunction search_scan(tokenizer: Tokenizer, start: number) {\r\n    let bound = this.bound;\r\n    let start_line = tokenizer.line_number;\r\n    let start_column = start - tokenizer.line_start;\r\n    let matched_count = 0;\r\n    for (\r\n        let char = tokenizer.input[tokenizer.index++];\r\n        char;\r\n        char = tokenizer.input[tokenizer.index++]\r\n    ) {\r\n        if (tokenizer.isLineTerminator(char.charCodeAt(0))) {\r\n            if (bound === \"\\n\") {\r\n                tokenizer.index -= 1;\r\n                break;\r\n            }\r\n            tokenizer.line_number += 1;\r\n            tokenizer.line_start = tokenizer.index;\r\n        } else if (char === bound[matched_count]) {\r\n            if (bound.length > ++matched_count) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        matched_count = 0;\r\n    }\r\n    let token = tokenizer.createToken(\r\n        this.type,\r\n        [start, tokenizer.index],\r\n        undefined,\r\n        { line: start_line, column: start_column }\r\n    );\r\n    if (matched_count !== bound.length && bound !== \"\\n\" && bound !== \"EOF\") {\r\n        token.error = \"Invalid or unexpected token\";\r\n        tokenizer.err(token);\r\n    }\r\n    return token;\r\n}*/\r\nexport {\r\n    createSearchTree, escape_scan, MARKS\r\n}","\r\n\r\nimport {\r\n    Context, CONTEXT, SourceLocation, Node, Token\r\n} from '../interfaces';\r\nimport {\r\n    _Punctuator,\r\n    _Keyword,\r\n    _Identifier,\r\n    _Pattern,\r\n    isRestrictedWord,\r\n    STATEMANT_LIST_ITEM_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark, NODES, TYPE_ALIAS,\r\n    validateBinding, validateLineTerminator, AWAIT_LIST, createMatchTree, join_content, _NonCapturing, MATCH_MARKS\r\n} from './head'\r\nimport { Expressions, UNIT_EXPRESSION_TREE } from './expression';\r\n\r\nlet Grouping = NODES.Grouping;\r\n\r\n\r\nfunction get_variable_declarator(context: Context, id: Node, init: Node, range: [number, number], loc: SourceLocation): Node {\r\n    let parser = context[CONTEXT.parser];\r\n    if (id instanceof Grouping) {\r\n        parser.err(id);\r\n    } else if (context[CONTEXT.strict]) {\r\n        init || validateBinding(context, id);\r\n    } if (id.name === \"let\") {\r\n        let kind = context.tokens[context[CONTEXT.begin] - 1];\r\n        if (kind.value === \"let\" || kind.value === \"const\") {\r\n            parser.err(id);\r\n        }\r\n    }\r\n    return {\r\n        type: \"VariableDeclarator\",\r\n        id, init, range, loc\r\n    };\r\n}\r\n\r\nlet VariableDeclarators = {\r\n    Success: {\r\n        handler: [\r\n            join_content,\r\n            function (context: Context) {\r\n                let [collected] = context;\r\n                validateLineTerminator(context);\r\n                collected.content = join_content(context).content;\r\n                return collected;\r\n            }\r\n        ],\r\n        precedence: [true, 0],\r\n        collector: [\r\n            {\r\n                success: _Or(\"Success\", MATCH_MARKS.BOUNDARY),\r\n                content: _Or(\r\n                    _Pattern(\"Identifier\").pipe(\r\n                        function (context: Context, identifier: Node) {\r\n                            return get_variable_declarator(\r\n                                context,\r\n                                identifier,\r\n                                null,\r\n                                identifier.range,\r\n                                identifier.loc\r\n                            );\r\n                        }\r\n                    ),\r\n                    _Pattern(\"AssignmentPattern\").pipe(\r\n                        function (context: Context, pattern: Node) {\r\n                            return get_variable_declarator(\r\n                                context,\r\n                                pattern.left,\r\n                                pattern.right,\r\n                                pattern.range,\r\n                                pattern.loc\r\n                            );\r\n                        }\r\n                    )\r\n                ),\r\n                _next: _NonCollecting(\"Punctuator ,\"),\r\n            },\r\n            [\r\n                [\"type\", _Mark(\"VariableDeclarators\")],\r\n                [\"_next\", _Option(\"Punctuator ;\")]\r\n            ]\r\n        ]\r\n    }\r\n}\r\nlet VARIABLE_DECLARATOR_TREE: Record<string, any>;\r\n\r\nAWAIT_LIST.push(function () {\r\n    VARIABLE_DECLARATOR_TREE = createMatchTree(VariableDeclarators, UNIT_EXPRESSION_TREE);\r\n});\r\n\r\nfunction reinterpreat_expression_as_declaration(context: Context, expr: Node) {\r\n    let [collected, parser] = context;\r\n    expr.type = collected.type;\r\n    if (expr.id) {\r\n        if (isRestrictedWord(expr.id.name)) {\r\n            parser.err(expr.id);\r\n        }\r\n    } else {\r\n        parser.err(expr);\r\n    }\r\n    for (let key in expr) {\r\n        collected[key] = expr[key];\r\n    }\r\n    return expr.id;\r\n}\r\n\r\nconst Declarations: Record<string, any> = {\r\n    \"ClassDeclaration\": { //<= ClassExpression\r\n        filter(context: Context, left: number, right: number) {\r\n            let tokens = context.tokens;\r\n            return !(tokens[right] instanceof Grouping);\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                id: _Pattern(\"ClassExpression\").pipe(reinterpreat_expression_as_declaration)\r\n            }\r\n        ]\r\n    },\r\n    \"FunctionDeclaration\": {\r\n        filter: \"ClassDeclaration\",\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                id: _Pattern(\"FunctionExpression\").pipe(reinterpreat_expression_as_declaration)\r\n            }\r\n        ]\r\n    },\r\n    \"VariableDeclaration\": [\r\n        {\r\n            validator: [\r\n                function (context: Context) {\r\n                    let [, parser, left] = context;\r\n                    context.wrap(CONTEXT.bindingElement, true);\r\n                    let res = parser.parseCustom(\r\n                        VARIABLE_DECLARATOR_TREE,\r\n                        context,\r\n                        left + 1,\r\n                        (node: Node) => node.type === \"VariableDeclarators\"\r\n                    );\r\n                    context.unwrap();\r\n                    return res && 0;\r\n                }, null\r\n            ],\r\n            collector: [\r\n                {\r\n                    //_: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                    kind: _Or(\"Keyword var const let\", \"Identifier let\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            return token.name === undefined ? token.value : token.name;\r\n                        }\r\n                    ),\r\n                    declarations: _Or(\r\n                        \"Identifier\",\r\n                        \"Punctuator [ {\"\r\n                    )\r\n                },\r\n                [\r\n                    [\"declarations\", _Pattern(\"VariableDeclarators\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            return token.content;\r\n                        }\r\n                    )],\r\n                ]\r\n            ]\r\n        }\r\n    ]\r\n\r\n};\r\nfor (const type_name in Declarations) {\r\n    type_name && (TYPE_ALIAS[type_name] = [type_name, \"[Declaration]\"]);\r\n}\r\n\r\nexport default Declarations;\r\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","console.time(\"init\");\r\nimport Tokenizer from \"./tokenizer\"\r\nimport {\r\n    NodeProp,\r\n    MATCHED,\r\n    Matched,\r\n    MATCHED_RECORDS,\r\n    MatchedRecords,\r\n    Token, Node, Pipe,\r\n    Mark as MarkInterface,\r\n    SearchTree, NUMERIC_TYPE, Context, CONTEXT,\r\n    SourceLocation,\r\n    PRECEDENCE, Precedence, Validate\r\n} from \"./interfaces\";\r\nimport {\r\n    SYNTAX_TREE,\r\n    MATCH_MARKS,\r\n    EXPRESSION_TREE,\r\n    isExpression, isStatementListItem,\r\n    token_hooks,\r\n} from \"./syntax/index\";\r\nimport { _Context, TYPE_ALIAS, NODES, AWAIT_LIST, Mark, Cover, attachLocation } from \"./syntax/head\";\r\n\r\n\r\nimport {\r\n    TOKEN_TYPE_ENUMS\r\n} from \"./lexical/index\";\r\ntype Extreme = MatchedRecords;\r\ntype Longest = MatchedRecords;\r\nfor (const cbfun of AWAIT_LIST) {\r\n    cbfun();\r\n}\r\nconsole.timeEnd(\"init\");\r\nconsole.log(SYNTAX_TREE);\r\n\r\nconst { Script, Module } = NODES;\r\n\r\n\r\nexport default class extends Tokenizer {\r\n    SYNTAX_TREE = SYNTAX_TREE;\r\n    EXPRESSION_TREE = EXPRESSION_TREE;\r\n    TYPE_ALIAS = TYPE_ALIAS;\r\n    padding_token: Token = {\r\n        type: MATCH_MARKS.BOUNDARY,\r\n        value: MATCH_MARKS.BOUNDARY\r\n    };\r\n    error_logs: Array<any>;\r\n    save_comments = false;\r\n    context_stack: Array<Context>;\r\n    get is_primary_expr_start() {\r\n        if (this.tokens.length) {\r\n            let last_node: any = this.tokens[this.tokens.length - 1];\r\n            return isStatementListItem(last_node)\r\n                || last_node.type === TOKEN_TYPE_ENUMS.Keyword\r\n                || (\r\n                    last_node.type === TOKEN_TYPE_ENUMS.Punctuator\r\n                    &&\r\n                    !last_node.hasOwnProperty(\"content\")\r\n                );\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    token_hooks: Record<string, (token: Token, tokenizer?: Tokenizer) => Token> = token_hooks;\r\n    err(...args: any) {\r\n        debugger;\r\n        this.error_logs.push.apply(this.error_logs, args);\r\n    }\r\n    constructor() {\r\n        super();\r\n    }\r\n    parse(input: string) {\r\n        return this.parseScript(input);\r\n    }\r\n    parseModule(input: string) {\r\n        let tokens = this._parse(input, CONTEXT.isModule, true, CONTEXT.strict, true);\r\n        let module = new Module(tokens);\r\n        if (tokens.length) {\r\n            attachLocation(module, tokens[0], tokens[tokens.length - 1]);\r\n        }\r\n        return module;\r\n    }\r\n    parseScript(input: string) {\r\n        let tokens = this._parse(input);\r\n        let script = new Script(tokens);\r\n        if (tokens.length) {\r\n            attachLocation(module, tokens[0], tokens[tokens.length - 1]);\r\n        }\r\n        return script;\r\n    }\r\n    parseExpression(context: Context): Node {\r\n        context.wrap(CONTEXT.isExpression, true);\r\n        let res = this.parseNode(EXPRESSION_TREE, context, isExpression);\r\n        context.unwrap();\r\n        return res;\r\n    }\r\n    parseNode(\r\n        match_tree: Record<string, any>,\r\n        context: Context,\r\n        test: (node: Node) => boolean\r\n    ): Node {\r\n        let tokens = context.tokens;\r\n        this.parseCustom(match_tree, context);\r\n        let res: Node;\r\n        if (tokens.length) {\r\n            let index = 0;\r\n            if (test(tokens[0])) {\r\n                index = 1;\r\n                res = tokens[0];\r\n            }\r\n            if (tokens.length > index) {\r\n                this.err(...tokens.slice(index));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    parseRangeAsNode(\r\n        match_tree: Record<string, any>,\r\n        context: Context,\r\n        left: number,\r\n        lexcal_terminator: Validate,\r\n        test: (node: Node) => boolean\r\n    ): Node {\r\n        let res = this.parseRange(match_tree, context, left, lexcal_terminator, test);\r\n        if (!res.content) {\r\n            this.err(res);\r\n        }\r\n        return res.content;\r\n    }\r\n    parseRangeAsExpression(\r\n        context: Context,\r\n        left: number,\r\n        lexcal_terminator: Validate,\r\n    ): Node {\r\n        context.wrap(CONTEXT.isExpression, true);\r\n        let res = this.parseRangeAsNode(EXPRESSION_TREE, context, left, lexcal_terminator, isExpression);\r\n        context.unwrap();\r\n        return res;\r\n    }\r\n    private _parse(input: string, ...environments: Array<number | any>) {\r\n        //this.logs = [];\r\n        this.context_stack = [];\r\n        this.init(input);\r\n        let context = _Context(this);\r\n        environments.length && context.store(...environments);\r\n        //this.parseBlock(context);\r\n        let tokens = context.tokens;\r\n        this.parseCustom(\r\n            SYNTAX_TREE,\r\n            context\r\n        );\r\n        if (tokens.length) {\r\n            if (!isStatementListItem(tokens[tokens.length - 1])) {\r\n                this.err(tokens.pop());\r\n            }\r\n        }\r\n        if (this.error_logs.length) {\r\n            console.warn(\"error:\", this.error_logs);\r\n        }\r\n        //console.log(\"logs:\", this.logs);\r\n        return this.tokens;\r\n    }\r\n    parseCustom(\r\n        root: Record<string, any>,\r\n        context: Context,\r\n        begin: number = 0,\r\n        test?: Function\r\n    ) {\r\n        let point = context.store(CONTEXT.begin, begin);\r\n        let cursor: number = begin - 1;\r\n        let backflow_tape: Array<number> = new Array(begin);\r\n        backflow_tape.push(cursor);\r\n        let extreme: Extreme;\r\n        let state: number;\r\n        this.context_stack.unshift(context);\r\n        while (true) {\r\n            if (cursor < begin || context.getToken(cursor)) {\r\n                if (\r\n                    !(\r\n                        extreme\r\n                        && (\r\n                            extreme[MATCHED_RECORDS.right] < cursor\r\n                            && backflow_tape.length <= 3 + extreme[MATCHED_RECORDS.right]\r\n                            //匹配边界断句\r\n                        )\r\n                        && (\r\n                            (state = this.finallize(context, extreme))\r\n                            || (extreme = undefined)\r\n                        )\r\n                    )\r\n                ) {\r\n                    let longest = this.walk(\r\n                        root,\r\n                        context,\r\n                        cursor,\r\n                        backflow_tape,\r\n                        extreme?.[MATCHED_RECORDS.right]\r\n                    );\r\n                    //longest && this.logs.push(\"walk\", longest[MATCHED_RECORDS.left], longest[MATCHED_RECORDS.right], longest[MATCHED_RECORDS.matched][MATCHED.wrapper].name);\r\n                    if (longest) {\r\n                        let longest_precedence = longest[MATCHED_RECORDS.precedence];\r\n                        let extreme_precedence = extreme && extreme[MATCHED_RECORDS.precedence];\r\n                        if (\r\n                            (//如果该记录优先级为true，则立即处理\r\n                                longest_precedence[PRECEDENCE.VALUE] !== true\r\n                                || (extreme = longest, false)\r\n                            ) && (\r\n                                !extreme_precedence\r\n                                || !(\r\n                                    extreme_precedence[PRECEDENCE.VALUE] > longest_precedence[PRECEDENCE.VALUE]\r\n                                    || extreme_precedence[PRECEDENCE.RIGHT_ASSOCIATIVE] === longest_precedence[PRECEDENCE.VALUE] //左结合\r\n                                )\r\n                            ) || !(state = this.finallize(context, extreme))\r\n                        ) {\r\n\r\n                            extreme = longest;\r\n                            //cursor += 1;\r\n                            //也可以单步步进，不过这样更效率一些也和当前收集器无冲突\r\n                            cursor += longest[MATCHED_RECORDS.right] - longest[MATCHED_RECORDS.left] || 1;\r\n                            continue;\r\n                        }\r\n                    } else {\r\n                        cursor += 1;\r\n                        continue;\r\n                    }\r\n                }\r\n            } else if (\r\n                !(\r\n                    extreme\r\n                    && (state = this.finallize(context, extreme))\r\n                )\r\n            ) {\r\n                break;\r\n            }\r\n            if (extreme) {\r\n                if (\r\n                    test\r\n                    && extreme[MATCHED_RECORDS.left] <= begin\r\n                    && test(context.getToken(begin))\r\n                ) {\r\n                    context.restore(point);\r\n                    this.context_stack.shift();\r\n                    return context.getToken(begin);\r\n                }\r\n                cursor = extreme[MATCHED_RECORDS.left];\r\n            }\r\n            cursor >= begin && state !== -1 && (cursor = backflow_tape[cursor]);\r\n            state = 0;\r\n            extreme = undefined;\r\n            backflow_tape.splice(cursor + 1, backflow_tape.length - (cursor + 1));\r\n        }\r\n        this.context_stack.shift();\r\n        context.restore(point);\r\n    }\r\n    parseRange(\r\n        match_tree: Record<string, any>,\r\n        context: Context,\r\n        left: number,\r\n        lexcal_terminator: Validate,\r\n        test?: (node: Node) => boolean,\r\n    ) {\r\n        let tokens = context.tokens;\r\n        this.terminator_stack.unshift(lexcal_terminator);\r\n        this.parseCustom(\r\n            match_tree,\r\n            context,\r\n            left + 1\r\n        );\r\n        this.terminator_stack.shift();\r\n        let before_token = tokens[left];\r\n        let after_token = tokens[tokens.length - 1];\r\n        let value = before_token.value;\r\n        let end = tokens.length - 1;\r\n        if (lexcal_terminator(after_token)) {\r\n            value += after_token.value;\r\n        } else {\r\n            end += 1;\r\n            this.err(before_token);\r\n        }\r\n        let content: any, next = left + 1;\r\n        if (test) {\r\n            if (test(tokens[next])) {\r\n                content = tokens[next];\r\n                next += 1;\r\n            }\r\n            if (next < end) {\r\n                this.err(...this.tokens.splice(next, end - next));\r\n            }\r\n        } else {\r\n            content = tokens.splice(next, end - next);\r\n        }\r\n        let res: Token = {\r\n            type: TOKEN_TYPE_ENUMS.Punctuator,\r\n            value,\r\n            content\r\n        };\r\n        attachLocation(res, before_token, after_token);\r\n        tokens.splice(left, tokens.length - left, res);\r\n        return res;\r\n    }\r\n    walk(\r\n        root: Record<string, any>,\r\n        context: Context,\r\n        start: number,\r\n        backflow_tape: Array<number>,\r\n        minimum: number\r\n    ): Longest {\r\n        let padding_token = this.padding_token;\r\n        let TYPE_ALIAS = this.TYPE_ALIAS;\r\n        let tokens = context.tokens;\r\n        let begin = context[CONTEXT.begin];\r\n        //let steps: Array<number> = [];\r\n        return explore(\r\n            root,\r\n            start\r\n        );\r\n        function get_records(matched: Matched, end: number): MatchedRecords {\r\n            if (\r\n                !matched[MATCHED.filter]\r\n                || matched[MATCHED.filter](context, start, end)\r\n            ) {\r\n                return [\r\n                    matched[MATCHED.precedence],\r\n                    start,\r\n                    end,\r\n                    matched\r\n                ];\r\n            }\r\n        }\r\n        function explore(parent: Record<string, any>, index: number): Longest {\r\n\r\n            let res: Longest;\r\n            let matched: Matched;\r\n            if (parent[MATCH_MARKS.WALKER]) {\r\n                parent[MATCH_MARKS.WALKER](context, index - 1);\r\n            }\r\n            if (parent[MATCH_MARKS.TERMINAL]) {\r\n                if (!(index - 1 <= minimum)) {\r\n                    matched = parent[MATCH_MARKS.MATCH_END];\r\n                    if (matched && (res = get_records(matched, index - 1))) {\r\n                        minimum = index - 1;\r\n                    }\r\n                }\r\n                return res;\r\n            }\r\n\r\n            let token = index >= begin\r\n                ? context.getToken(index) || (index <= tokens.length && padding_token)\r\n                : padding_token;\r\n            if (!token) {\r\n                return;\r\n            }\r\n            let has_backflow = false;\r\n            if (backflow_tape.length <= index + 1) {\r\n                has_backflow = true;\r\n                backflow_tape.push(start);\r\n            }\r\n            let matched_node: Record<string, any>;\r\n            let alias = TYPE_ALIAS[token.type];\r\n            let cursor = 0, length = 1, type: string | number;\r\n            let longest: Longest;\r\n            let node: Record<string, any>;\r\n            let value_node: Record<string, any>, type_node: Record<string, any>;\r\n            if (alias) {\r\n                length = alias.length;\r\n                type = alias[cursor];\r\n            } else {\r\n                type = token.type;\r\n            }\r\n            while (true) {\r\n                if (node = parent[type]) {\r\n                    res = undefined;\r\n                    if (\r\n                        !(\r\n                            (value_node = node[token.value])\r\n                            && (res = explore(value_node, index + 1))\r\n                        )\r\n                        && !(\r\n                            (type_node = node[MATCH_MARKS.TYPE_ONLY])\r\n                            && (res = explore(type_node, index + 1))\r\n                        )\r\n                        && !(index <= minimum)\r\n                    ) {\r\n                        if (\r\n                            matched = (matched_node = value_node) && matched_node[MATCH_MARKS.MATCH_END]\r\n                            || (matched_node = type_node) && matched_node[MATCH_MARKS.MATCH_END]\r\n                        ) {\r\n                            if (\r\n                                (res = get_records(matched, index))\r\n                            ) {\r\n                                minimum = index;\r\n                            } else if (has_backflow && index > start) {\r\n                                backflow_tape.splice(index + 1, backflow_tape.length - index - 1);\r\n                            }\r\n                        }\r\n                    }\r\n                    longest = res || longest;\r\n                }\r\n                if (++cursor >= length) {\r\n                    return longest;\r\n                } else {\r\n                    type = alias[cursor];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    createNode(context: Context) {\r\n        let left = context[CONTEXT.left];\r\n        let right = context[CONTEXT.right];\r\n        let matched = context[CONTEXT.matched];\r\n        let tokens = context.tokens;\r\n        let begin = context[CONTEXT.begin];\r\n        let node: any = new matched[MATCHED.wrapper]();\r\n        let length = tokens.length;\r\n        let start = left, end = right < length ? right : length - 1;\r\n        let offset = left, key: string | Cover | Mark, pipes: Array<Pipe>, nth: number;\r\n        let token: any, res: any;\r\n        context[CONTEXT.collected] = node;\r\n\r\n        function restore_volatile() {\r\n            context[CONTEXT.left] = left;\r\n            context[CONTEXT.right] = right;\r\n            context[CONTEXT.matched] = matched;\r\n            context[CONTEXT.collected] = node\r\n        }\r\n\r\n        for (const prop of matched[MATCHED.props]) {\r\n            [key, nth, pipes] = prop as any;\r\n            if (key instanceof Mark) {\r\n                token = key.data(context, offset);\r\n                restore_volatile();\r\n                if (token === undefined) {\r\n                    continue;\r\n                }\r\n                key = key.key;\r\n            } else {\r\n                token = offset >= begin && offset < length ? tokens[offset] : null;\r\n\r\n                for (let i in pipes) {\r\n                    res = pipes[i](context, token, offset);\r\n                    res === undefined || (token = res);\r\n                    restore_volatile();\r\n                }\r\n                if (key instanceof Cover) {\r\n                    if (key.value === null) {\r\n                        if (offset === start) {\r\n                            offset < end && (start = offset + 1);\r\n                        } else if (offset > begin && offset - 1 < end) {\r\n                            end = offset - 1;\r\n                        }\r\n                    } else if (offset < length && end < offset) {\r\n                        end = offset;\r\n                    }\r\n                    offset += 1;\r\n                    continue;\r\n                } else if (offset < length && end < offset) {\r\n                    end = offset;\r\n                }\r\n                offset += 1;\r\n            }\r\n            if (nth <= 1) {\r\n                node[key] = nth === 0 ? token : [token];\r\n            } else {\r\n                node[key].push(token);\r\n            }\r\n        }\r\n\r\n        start >= begin || (start = begin);\r\n\r\n        let start_token = tokens[start];\r\n        let end_token = tokens[end];\r\n        attachLocation(node, start_token, end_token);\r\n        context[CONTEXT.start] = start;\r\n        context[CONTEXT.end] = end;\r\n        return node;\r\n    }\r\n    getToken(index: number) {\r\n        return this.tokens.length > index ? this.tokens[index] : this.nextToken();\r\n    }\r\n    finallize(\r\n        context: Context,\r\n        record: Extreme\r\n    ) {\r\n        let [, left, right, matched/*, steps*/] = record;\r\n        let validator = matched[MATCHED.validator];\r\n        let collected: any;\r\n        let start: number, end: number;\r\n        context[CONTEXT.left] = left;\r\n        context[CONTEXT.right] = right;\r\n        context[CONTEXT.matched] = matched;\r\n        let tokens = context.tokens;\r\n        let handler = matched[MATCHED.handler];\r\n        //this.logs.push(\"finallize\", left, right, matched[MATCHED.wrapper].name);\r\n        if (!validator || (collected = validator(context)) === true) {\r\n            collected = this.createNode(context);\r\n            start = context[CONTEXT.start];\r\n            end = context[CONTEXT.end];\r\n            if (handler) {\r\n                collected = handler(context);\r\n            }\r\n        } else if (collected) {\r\n            start = context[CONTEXT.start];\r\n            end = context[CONTEXT.end];\r\n        }\r\n        if (!collected) {\r\n            return collected === undefined || collected === false\r\n                ? 0\r\n                : (collected === null ? 1 : -1);\r\n        }\r\n        //debugger;\r\n        //this.logs.push(\"finallize\", collected);\r\n        let length = end - start + 1;\r\n        if (collected instanceof Array) {\r\n            tokens.splice(start, length, ...collected);\r\n        } else {\r\n            tokens.splice(start, length, collected);\r\n        }\r\n        return length;\r\n    }\r\n}\r\n","\r\nimport {\r\n    Node, Token, Context, CONTEXT\r\n} from '../interfaces';\r\nimport {\r\n    attachLocation,\r\n    createMatchTree,\r\n    _Option, _Or, _Series, _NonCollecting, _NonCapturing, _Mark,\r\n    TYPE_ALIAS, _Context, _Loop, NODES, MATCH_MARKS,\r\n    validateBinding, validateLineTerminator, ASSIGNMENT_PUNCTUATORS_PATTERN, join_content, AWAIT_LIST, TOPLEVEL_ITEM_PATTERN\r\n} from './head'\r\nimport { isExpression, isStatementListItem, get_inner_group, parse_and_extract } from './index';\r\n\r\nimport { UNIT_EXPRESSION_TREE } from './expression';\r\nconst Grouping = NODES.Grouping;\r\n\r\nlet PETTERN_ELEMENTS_TREE: Record<string, any>;\r\nlet PATTERN_PROPERTIES_TREE: Record<string, any>;\r\n\r\nAWAIT_LIST.push(function () {\r\n    PETTERN_ELEMENTS_TREE = createMatchTree(\r\n        PatternElements,\r\n        UNIT_EXPRESSION_TREE\r\n    );\r\n    PATTERN_PROPERTIES_TREE = createMatchTree(\r\n        PatternProperties,\r\n        UNIT_EXPRESSION_TREE\r\n    );\r\n});\r\n\r\n\r\nconst Patterns: Record<string, any> = {\r\n    ArrayPattern: {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.is_binding || context.wrap(CONTEXT.bindingSet, null);\r\n            let res = parseArrayPattern(context, collected.elements);\r\n            collected.is_binding || context.unwrap();\r\n            return res;\r\n        },\r\n        precedence: 20,\r\n        filter: [\r\n            null,\r\n            function (context: Context) {\r\n                return context[CONTEXT.bindingElement]/* === context[CONTEXT.tokens]*/;\r\n            }\r\n        ],\r\n        collector: [\r\n            {\r\n                elements: _Or(\"Punctuator []\"),\r\n                _next: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN),//+=\r\n            },\r\n            {\r\n                _prev: _NonCapturing(\"Punctuator  ...\", MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                elements: _Or(\"Punctuator []\"),\r\n                is_binding: _Mark(true)\r\n            }\r\n        ]\r\n    },\r\n    ObjectPattern: {\r\n        handler: function (context: Context) {\r\n            let [collected] = context;\r\n            collected.is_binding || context.wrap(CONTEXT.bindingSet, null);\r\n            let res = parseObjectPattern(context, collected.properties);\r\n            collected.is_binding || context.unwrap();\r\n            return res;\r\n        },\r\n        precedence: 20,\r\n        filter: [\r\n            null, null,\r\n            function (context: Context, left: number, right: number) {\r\n                return context[CONTEXT.bindingElement]/* === tokens*/\r\n                    || context[CONTEXT.isExpression];\r\n            },\r\n            function (context: Context) {\r\n                return context[CONTEXT.bindingElement] /*=== context[CONTEXT.tokens]*/;\r\n            }\r\n        ],\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN),\r\n                properties: _Or(\"Punctuator {}\"),\r\n                _next: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN)\r\n            },\r\n            [\r\n                [\"_prev\", _NonCapturing(\"Punctuator  ,\")],\r\n                [\"is_binding\", _Mark(true)]\r\n            ],\r\n            [\"_prev\", _Mark()],\r\n            [\r\n                [\"_prev\", _NonCapturing(\"Punctuator ...\", MATCH_MARKS.BOUNDARY, \"Success\")],\r\n                [\"_next\", _Mark()],\r\n            ]\r\n        ]\r\n    },\r\n    AssignmentPattern: {\r\n        filter(context: Context) {\r\n            return context[CONTEXT.bindingElement]/* === context[CONTEXT.tokens]*/;\r\n        },\r\n        precedence: 1.5,\r\n        collector: {\r\n            _: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n            left: _Or(\r\n                \"ArrayPattern\", \"ObjectPattern\",\r\n                _Or(\"Identifier\").pipe(\r\n                    function (context: Context, identifier: Node) {\r\n                        if (identifier instanceof Grouping) {\r\n                            context[CONTEXT.parser].err(identifier);\r\n                        } else {\r\n                            validateBinding(context, identifier);\r\n                        }\r\n                    }\r\n                )\r\n            ),\r\n            __: _NonCollecting(\"Punctuator =\"),\r\n            right: \"[Expression]\"\r\n        }\r\n    },\r\n    \"\": [\r\n        {\r\n            handler(context: Context) {\r\n                let [{ token }, parser, left, right] = context;\r\n                token = get_inner_group(token);\r\n                let store = context.store(\r\n                    CONTEXT.tokens, token.content,\r\n                    CONTEXT.bindingElement, true,\r\n                    CONTEXT.bindingSet, null\r\n                );\r\n                let node = parser.parseNode(\r\n                    UNIT_EXPRESSION_TREE,\r\n                    context,\r\n                    node => isExpression(node)\r\n                        || node.type === \"ArrayPattern\"\r\n                        || node.type === \"ObjectPattern\"\r\n                        || node.type === \"AssignmentPattern\",\r\n                );\r\n                context.restore(store);\r\n                if (!node) {\r\n                    parser.err(token);\r\n                }\r\n                return new Grouping(node, token);\r\n            },\r\n            collector: [\r\n                {\r\n                    _prev: _NonCapturing(\r\n                        _Series(\"Keyword export\", \"Keyword default\"),\r\n                        \"Punctuator ,\", \"Success\", TOPLEVEL_ITEM_PATTERN, ASSIGNMENT_PUNCTUATORS_PATTERN\r\n                    ),\r\n                    token: _Or(\"Punctuator ()\"),\r\n                    _next: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN)\r\n                }\r\n            ]\r\n        },\r\n\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, , right] = context;\r\n                let argument = context.getToken(right);\r\n                argument instanceof Grouping && parser.err(argument);\r\n                return true;\r\n            },\r\n            filter(context: Context) {\r\n                return context[CONTEXT.spreadElement];\r\n            },\r\n            precedence: 1.5,\r\n            collector: {\r\n                type: _Mark(\"SpreadElement\"),\r\n                token: _NonCollecting(\"Punctuator ...\"),\r\n                argument: \"[Expression]\"\r\n            }\r\n        },\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, , right] = context;\r\n                let argument = context.getToken(right);\r\n                argument instanceof Grouping && parser.err(argument);\r\n                return true;\r\n            },\r\n            filter: function (context: Context) {\r\n                return context[CONTEXT.bindingElement];\r\n            },\r\n            precedence: 1.5,\r\n            collector: {\r\n                type: _Mark(\"RestElement\"),\r\n                token: _NonCollecting(\"Punctuator ...\"),\r\n                argument: _Or(_Or(\"Identifier\").pipe(\r\n                    function (context: Context, token: Token) {\r\n                        validateBinding(context, token)\r\n                    }\r\n                ), \"ArrayPattern\", \"ObjectPattern\")\r\n            }\r\n        }\r\n    ]\r\n};\r\nexport {\r\n    Patterns,\r\n    parseArrayPattern,\r\n    parseObjectPattern\r\n}\r\n\r\n\r\nfunction parseArrayPattern(context: Context, token: Token): Node {\r\n    let pattern = new NODES.ArrayPattern();\r\n    context.wrap(CONTEXT.bindingElement, true);\r\n    pattern.elements = parse_and_extract(PETTERN_ELEMENTS_TREE, context, token);\r\n    context.unwrap();\r\n    pattern.range = token.range;\r\n    pattern.loc = token.loc;\r\n    return pattern;\r\n}\r\nfunction parseObjectPattern(context: Context, token: Token): Node {\r\n    let pattern = new NODES.ObjectPattern();\r\n    context.wrap(CONTEXT.bindingElement, true);\r\n    pattern.properties = parse_and_extract(PATTERN_PROPERTIES_TREE, context, token);\r\n    context.unwrap();\r\n    pattern.range = token.range;\r\n    pattern.loc = token.loc;\r\n    return pattern;\r\n}\r\n\r\nlet PatternElements = {\r\n    Success: {\r\n        handler: join_content,\r\n        collector: [\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: _Or(\r\n                    _Or(\"Identifier\").pipe(\r\n                        function (context: Context, identifier: Token) {\r\n                            if (identifier instanceof Grouping) {\r\n                                context[CONTEXT.parser].err(identifier);\r\n                            } else {\r\n                                validateBinding(context, identifier);\r\n                            }\r\n                        }\r\n                    ),\r\n                    _Or(\"ArrayPattern\", \"ObjectPattern\", \"AssignmentPattern\")\r\n                ),\r\n                _next: _NonCollecting(_Or(\"Punctuator ,\", MATCH_MARKS.BOUNDARY))\r\n            },\r\n            [\r\n                [\"content\", \"RestElement\"],\r\n                [\"_next\", _NonCollecting(MATCH_MARKS.BOUNDARY)]\r\n            ],\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: _Mark(null),\r\n                _next: _NonCollecting(\"Punctuator ,\")\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n\r\nconst PatternProperties = {\r\n    Success: {\r\n        handler: join_content,\r\n        //precedence: 0,\r\n        collector: {\r\n            success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n            content: \"Property\",\r\n        }\r\n    },\r\n    Property: [\r\n        {\r\n            collector: [\r\n                {\r\n                    _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                    key: _Or(\"Punctuator []\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            context.wrap(CONTEXT.tokens, token.content);\r\n                            let res = context[CONTEXT.parser].parseExpression(context);\r\n                            context.unwrap();\r\n                            return res;\r\n                        }\r\n                    ),\r\n                    value: _Series(\r\n                        _NonCollecting(\"Punctuator :\"),\r\n                        _Or(\r\n                            _Or(\"Identifier\").pipe(function (context: Context, token: Token) {\r\n                                validateBinding(context, token);\r\n                            }),\r\n                            _Or(\"Punctuator []\").pipe(parseArrayPattern),\r\n                            _Or(\"Punctuator {}\").pipe(parseObjectPattern),\r\n                        ),\r\n                        _Option(_Series(_NonCollecting(\"Punctuator =\"), \"[Expression]\")),\r\n                        _Mark(\r\n                            function (context: Context) {\r\n                                let [collected] = context;\r\n                                let { value } = collected;\r\n                                if (value.length > 1) {\r\n                                    let _value = new NODES.AssignmentPattern();\r\n                                    _value.left = value[0];\r\n                                    _value.right = value[1];\r\n                                    attachLocation(_value, value[0], value[1]);\r\n                                    collected.value = _value;\r\n                                } else {\r\n                                    collected.value = value[0];\r\n                                }\r\n                                return undefined;\r\n                            }\r\n                        )\r\n                    ),\r\n                    _next: _NonCollecting(MATCH_MARKS.BOUNDARY, \"Punctuator ,\"),\r\n                    computed: _Mark(true),\r\n                    kind: _Mark(\"init\"),\r\n                    method: _Mark(false),\r\n                    shorthand: _Mark(false),\r\n                },\r\n                [\r\n                    [\r\n                        \"key\",\r\n                        _Or(\"Identifier\").pipe(\r\n                            function (context: Context, identifier: Node) {\r\n                                if (identifier instanceof Grouping) {\r\n                                    context[CONTEXT.parser].err(identifier);\r\n                                }\r\n                            }\r\n                        )\r\n                    ],\r\n                    [\"computed\", _Mark(false)]\r\n                ],\r\n                [\r\n                    [\r\n                        \"value\", _Or(\r\n                            _Series(_NonCollecting(\"Punctuator =\"), \"[Expression]\").pipe(\r\n                                function (context: Context, token: Token) {\r\n                                    let [collected] = context;\r\n                                    let left = collected.key;\r\n                                    let res = new NODES.AssignmentPattern();\r\n                                    res.left = left;\r\n                                    res.right = token;\r\n                                    attachLocation(res, left, token);\r\n                                    return res;\r\n                                }\r\n                            ),\r\n                            _Mark(\r\n                                function (context: Context) {\r\n                                    return context[CONTEXT.collected].key;\r\n                                }\r\n                            )\r\n                        )\r\n                    ],\r\n                    [\r\n                        \"shorthand\",\r\n                        _Mark(\r\n                            function (context: Context) {\r\n                                validateBinding(context, context[CONTEXT.collected].key);\r\n                                return true;\r\n                            }\r\n                        )\r\n                    ]\r\n                ]\r\n            ]\r\n        },\r\n        {\r\n            validator() {//匹配占位\r\n                return false;\r\n            },\r\n            precedence: new Number(3),\r\n            collector: {\r\n                __: _Series(\r\n                    _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                    _Or(\r\n                        \"Punctuator []\",\r\n                        \"Identifier\",\r\n                    ),\r\n                    \"Punctuator :\",\r\n                    _Or(\r\n                        \"Identifier\",\r\n                        \"Punctuator [] {}\",\r\n                    ),\r\n                    \"Punctuator =\"\r\n                )\r\n            }\r\n        }\r\n    ]\r\n}\r\n","\r\nimport {\r\n    Context, CONTEXT, Node, Token\r\n} from '../interfaces';\r\nimport {\r\n    isExpression, isStatement, isStatementListItem,\r\n    parse_next_statement, get_inner_group,\r\n} from './index'\r\nimport {\r\n\r\n    _Punctuator,\r\n    _Keyword,\r\n    _Identifier,\r\n    _Pattern,\r\n    is_right_parentheses,\r\n    is_right_brackets,\r\n    is_right_braces,\r\n    createMatchTree,\r\n    NODES, MATCH_MARKS,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark, _Loop, TYPE_ALIAS,\r\n    validateBinding, validateLineTerminator, _NonCapturing,\r\n    validateIdentifier, validateAssignment,\r\n    STATEMANT_LIST_ITEM_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN,\r\n    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    isAligned,\r\n    attachLocation,\r\n} from './head'\r\nimport {\r\n    EXPRESSION_TREE,\r\n    parseArrayPattern,\r\n    parseObjectPattern,\r\n    parse_params\r\n\r\n} from './expression';\r\nimport Declaration from './declaration';\r\nimport Parser from '../parser';\r\nconst Grouping = NODES.Grouping;\r\nlet { VariableDeclaration } = Declaration;\r\n\r\nlet BLOCK_STATEMENT_PATTERN = _Or(\r\n    \"Block\",\r\n    _Or(\"Punctuator {\").walk(\r\n        function (context: Context, left: number) {\r\n            let parser = context[CONTEXT.parser];\r\n            parser.parseRange(parser.SYNTAX_TREE, context, left, is_right_braces).type = \"Block\";\r\n        }\r\n    )\r\n).pipe(\r\n    function (context: Context, token: Token) {\r\n        let res = new NODES.BlockStatement();\r\n        res.body = token.content;\r\n        attachLocation(res, token);\r\n        return res;\r\n    }\r\n)\r\n\r\nlet GROUPING_EXPRESSION = _Or(\r\n    \"Punctuator ()\",\r\n    _Punctuator(\"(\").walk(\r\n        function (context: Context, index: number) {\r\n            let [, parser] = context;\r\n            let store = context.store(\r\n                CONTEXT.bindingSet, null,\r\n                CONTEXT.bindingElement, false\r\n            );\r\n            parser.parseRange(parser.EXPRESSION_TREE, context, index, is_right_parentheses, isExpression);\r\n            context.restore(store);\r\n        }\r\n    )\r\n).pipe(\r\n    function (context: Context, token: Token) {\r\n        if (token.content) {\r\n            return token.content;\r\n        } else {\r\n            context[CONTEXT.parser].err(token);\r\n            return null;\r\n        }\r\n    }\r\n)\r\n\r\nconst Statements: Record<string, any> = {\r\n    \"\": {\r\n        handler([collected, parser]: Context) {\r\n            parser.err(collected.error);\r\n            return [];\r\n        },\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                error: _Or(\"Punctuator\", \"Keyword\"),\r\n                _next: _NonCapturing(RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN, \"Punctuator }\"),\r\n            }\r\n        ]\r\n    },\r\n    \"BreakStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            let label = collected.label;\r\n            if (label) {\r\n                if (\r\n                    label instanceof Grouping\r\n                    || context[CONTEXT.labelSet].indexOf(label.name) < 0\r\n                ) {\r\n                    parser.err(label);\r\n                }\r\n            } else if (!context[CONTEXT.inIteration] && !context[CONTEXT.inSwitch]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        filter: [\r\n            function (context: Context, left: number) {\r\n                return isAligned(context, left, left + 1);\r\n            },\r\n            null,\r\n        ],\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword break\"),\r\n                label: IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            },\r\n            [\"label\", _Mark(null)]\r\n        ]\r\n    },\r\n    \"ContinueStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            let label = collected.label;\r\n            validateLineTerminator(context);\r\n            if (label) {\r\n                if (\r\n                    label instanceof Grouping\r\n                    || context[CONTEXT.labelSet].indexOf(label.name) < 0\r\n                ) {\r\n                    parser.err(label);\r\n                }\r\n            } else if (!context[CONTEXT.inIteration]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        filter: \"BreakStatement\",\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword continue\"),\r\n                label: IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            },\r\n            [\"label\", _Mark(null)],\r\n        ]\r\n    },\r\n    \"ReturnStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.inFunctionBody]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        validator(context: Context) {\r\n            let [, , left, right] = context;\r\n            if (left === right) {\r\n                let next_token = context.getToken(left + 1);\r\n                if (next_token && context.getToken(left).loc.end.line === next_token.loc.start.line) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        filter: \"BreakStatement\",\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword return\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            },\r\n            [\"argument\", _Mark(null)]\r\n        ]\r\n    },\r\n    \"BlockStatement\": {\r\n        overload: true,//和 ObjectPattern 收集器有重叠，在存在 BlockStatement 的环境， ObjectPattern 的 filter 不会返回 true，这里强制覆盖\r\n        //precedence: 0,\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                body: _Punctuator(\"{\").pipe(\r\n                    function (context: Context, token: Token, left: number) {\r\n                        let parser = context[CONTEXT.parser];\r\n                        return parser.parseRange(parser.SYNTAX_TREE, context, left, is_right_braces).content;\r\n                    }\r\n                )\r\n            }\r\n        ]\r\n    },\r\n    \"DoWhileStatement\": {\r\n        validator: \"ForStatement\",\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            //collected.test = parser.parseExpression(context, collected.test);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                keyword: _NonCollecting(\"Keyword do\"),\r\n            },\r\n            [\r\n                [\"body\", STATEMANT_LIST_ITEM_PATTERN],\r\n                [\"test\", _Series(\r\n                    _NonCollecting(\"Keyword while\"),\r\n                    GROUPING_EXPRESSION\r\n                )],\r\n                [\"_next\", _Option(\"Punctuator ;\")]\r\n            ]\r\n        ]\r\n    },\r\n    \"EmptyStatement\": [\r\n        {\r\n            collector: [\r\n                {\r\n                    _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                    _: _NonCollecting(\"Punctuator ;\")\r\n                }\r\n            ]\r\n        }\r\n    ],\r\n    \"ExpressionStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser, left] = context;\r\n            validateLineTerminator(context);\r\n            let begin = context[CONTEXT.begin];\r\n            if (\r\n                (\r\n                    !context[CONTEXT.tokens] ||\r\n                    context[CONTEXT.inFunctionBody] === begin\r\n                )\r\n                && (\r\n                    begin >= left ||\r\n                    context.getToken(left - 1).directive\r\n                )\r\n            ) {\r\n                let expression = collected.expression;\r\n                if (\r\n                    expression\r\n                    && expression.type === \"Literal\"\r\n                    && typeof expression.value === \"string\"\r\n                    && expression.raw.length > 2\r\n                ) {\r\n                    collected = new NODES.Directive(\r\n                        collected.type,\r\n                        expression,\r\n                        expression.raw.slice(1, -1),\r\n                        collected.range,\r\n                        collected.loc\r\n                    );\r\n                    if (collected.directive === \"use strict\") {\r\n                        context[CONTEXT.strict] = true;\r\n                    }\r\n                }\r\n            }\r\n            return collected;\r\n        },\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                expression: EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"ForStatement\": {\r\n        validator: [\r\n            function (context: Context) {\r\n                context.wrap(CONTEXT.inIteration, true);\r\n                let res = parse_next_statement(context);\r\n                context.unwrap();\r\n                return res;\r\n            },\r\n            null\r\n        ],\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            let { iterator, body, range, loc } = collected;\r\n            collected = iterator.content;\r\n            if (collected) {\r\n                collected.body = body;\r\n                collected.range = range;\r\n                collected.loc = loc;\r\n                return collected;\r\n            } else {\r\n                parser.err(iterator);\r\n                return [];\r\n            }\r\n        },\r\n        collector: [\r\n            {\r\n                keyword: _NonCollecting(\"Keyword for\"),\r\n                iterator: _Or(\r\n                    \"Punctuator ()\",\r\n                    _Punctuator(\"(\").walk(\r\n                        function (context: Context, left: number) {\r\n                            let parser = context[CONTEXT.parser];\r\n                            context.wrap(CONTEXT.isExpression, true);\r\n                            parser.parseRange(FOR_ITERATOR_TREE, context, left, is_right_parentheses, isStatement)\r\n                            context.unwrap();\r\n                        }\r\n                    )\r\n                )\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    },\r\n    \"ForInStatement\": {//ForStatement\r\n    },\r\n    \"ForOfStatement\": {//ForStatement\r\n    },\r\n    \"IfStatement\": {\r\n        validator(context: Context) {\r\n            let [, , left, right] = context;\r\n            if ((right - left) % 2 === 1) {\r\n                return parse_next_statement(context);\r\n            }\r\n            return true;\r\n        },\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword if\"),\r\n                test: GROUPING_EXPRESSION,\r\n                consequent: _Mark(null),\r\n                alternate: _Mark(null)\r\n            },\r\n            [\"consequent\", STATEMANT_LIST_ITEM_PATTERN],\r\n            [\r\n                \"alternate\", _Series(\r\n                    _NonCollecting(\"Keyword else\"),\r\n                    _Option(STATEMANT_LIST_ITEM_PATTERN)\r\n                )\r\n            ]\r\n        ]\r\n    },\r\n    \"LabeledStatement\": {\r\n        validator: [\r\n            function (context: Context) {\r\n                let [, parser, left] = context;\r\n                let label = context.getToken(left);\r\n                let label_name = label.name;\r\n                let label_set = context[CONTEXT.labelSet];\r\n                if (label_set.indexOf(label_name) >= 0) {\r\n                    parser.err(label);\r\n                }\r\n                label_set.unshift(label_name);\r\n                let res = parse_next_statement(context);\r\n                label_set.shift();\r\n                return res;\r\n            },\r\n            null\r\n        ],\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                label: _Series(\r\n                    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    _NonCollecting(\"Punctuator :\")\r\n                )\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    },\r\n    \"SwitchStatement\": [\r\n        {\r\n            collector: [\r\n                {\r\n                    token: _NonCollecting(\"Keyword switch\"),\r\n                    discriminant: GROUPING_EXPRESSION,\r\n                    cases: _Punctuator(\"{\").pipe(\r\n                        function (context: Context, token: Token, left: number) {\r\n                            let parser = context[CONTEXT.parser]\r\n                            context.wrap(CONTEXT.inSwitch, true);\r\n                            let cases = parser.parseRange(parser.SYNTAX_TREE, context, left, is_right_braces).content\r\n                            context.unwrap();\r\n\r\n                            let has_default = false;\r\n                            for (const item of cases) {\r\n                                if (item.type === \"SwitchCase\") {\r\n                                    if (item.test) {\r\n                                        continue;\r\n                                    }\r\n                                    if (!has_default) {\r\n                                        has_default = true;\r\n                                        continue;\r\n                                    }\r\n                                }\r\n                                parser.err(item);\r\n                            }\r\n                            return cases;\r\n                        }\r\n                    )\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            handler([collected]: Context) {\r\n                collected.consequent = [];\r\n                return collected;\r\n            },\r\n            precedence: 0,\r\n            filter(content: Context) {\r\n                return content[CONTEXT.inSwitch] /*=== content[CONTEXT.tokens]*/;\r\n            },\r\n            collector: [\r\n                {\r\n                    type: _Mark(\"SwitchCase\"),\r\n                    test: _Or(\r\n                        _Series(\r\n                            _NonCollecting(\"Keyword case\"),\r\n                            EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\r\n                        ),\r\n                        _Series(\r\n                            _NonCollecting(\"Keyword default\"),\r\n                            _Mark(null)\r\n                        )\r\n                    ),\r\n                    __: _NonCollecting(\"Punctuator :\")\r\n                },\r\n            ]\r\n        },\r\n        {\r\n            handler([collected]: Context) {\r\n                collected.token.consequent.push(collected.consequent)\r\n                return collected.token;\r\n            },\r\n            collector: {\r\n                token: \"SwitchCase\",\r\n                consequent: STATEMANT_LIST_ITEM_PATTERN\r\n            }\r\n        }\r\n    ],\r\n    \"ThrowStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (collected.loc.start.line !== collected.argument.loc.start.line) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword throw\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"TryStatement\": {\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword try\"),\r\n                block: BLOCK_STATEMENT_PATTERN/*\"Punctuator {}\"*/,\r\n                handler: _Series(\r\n                    _NonCollecting(\"Keyword catch\"), \"Punctuator ()\", BLOCK_STATEMENT_PATTERN,\r\n                    _Mark(\r\n                        function (context: Context) {\r\n                            let [collected, parser] = context;\r\n                            let [param, body] = collected.handler;\r\n                            let params = parse_params(context, param.content);\r\n                            if (params.length !== 1) {\r\n                                parser.err(param);\r\n                            }\r\n                            collected.handler = {\r\n                                type: \"CatchClause\",\r\n                                param: params[0],\r\n                                body\r\n                            };\r\n                        }\r\n                    )\r\n                ),\r\n                finalizer: _Mark(null)\r\n            },\r\n            [\"finalizer\", _Series(_NonCollecting(\"Keyword finally\"), BLOCK_STATEMENT_PATTERN)],\r\n            [\"handler\", _Mark(null)],\r\n        ]\r\n    },\r\n    \"WhileStatement\": {\r\n        validator: \"ForStatement\",\r\n        /*handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            //collected.test = parser.parseExpression(context, collected.test);\r\n            return collected;\r\n        },*/\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword while\"),\r\n                test: GROUPING_EXPRESSION\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    },\r\n    \"WithStatement\": {\r\n        validator: [\r\n            parse_next_statement,\r\n            null\r\n        ],\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            if (context[CONTEXT.strict]) {\r\n                parser.err(collected);\r\n            }\r\n            //collected.object = parser.parseExpression(context, collected.object);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: \"Keyword with\",\r\n                object: \"Punctuator ()\"\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    }\r\n};\r\n\r\nfor (const type_name in Statements) {\r\n    if (type_name) {\r\n        type_name && (TYPE_ALIAS[type_name] = [type_name, \"[Statement]\"]);\r\n    }\r\n}\r\nexport default Statements;\r\n\r\nlet ForIterator = {\r\n    VariableDeclaration,\r\n    ForStatement: [\r\n        {\r\n            collector: [\r\n                {\r\n                    init: _Or(\r\n                        \"VariableDeclaration\",\r\n                        _Series(\r\n                            _NonCollecting(MATCH_MARKS.BOUNDARY),\r\n                            _Or(EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),//EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS\r\n                            _NonCollecting(\"Punctuator ;\")\r\n                        )\r\n                    ),\r\n                    test: _Series(\r\n                        _Or(EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                        _NonCollecting(\"Punctuator ;\")\r\n                    ),\r\n                    update: _Series(\r\n                        _Or(EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                        _NonCapturing(\"Punctuator )\")\r\n                    ),\r\n                    body: _Mark(null)\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            handler(context: Context) {\r\n                let [collected, parser] = context;\r\n                let { left } = collected;\r\n                let kind: Node, declarator: Node;\r\n                if (left instanceof Array) {\r\n                    [kind, declarator] = left;\r\n                } else {\r\n                    declarator = left;\r\n                }\r\n                if (declarator.value === \"()\" && declarator.type === \"Punctuator\") {\r\n                    let wrapper = declarator;\r\n                    declarator = get_inner_group(declarator);\r\n                    if (declarator.content.length > 0) {\r\n                        if (kind) {\r\n                            parser.err(declarator);\r\n                        } else if (declarator.content.length > 1) {\r\n                            parser.err(...declarator.content.slice(1));\r\n                        }\r\n                        declarator = new Grouping(declarator.content[0], wrapper);\r\n                    }\r\n                }\r\n                if (declarator.type === \"Punctuator\") {\r\n                    switch (declarator.value) {\r\n                        case \"{}\":\r\n                            declarator = parseObjectPattern(context, declarator);\r\n                            break;\r\n                        case \"[]\":\r\n                            declarator = parseArrayPattern(context, declarator);\r\n                            break;\r\n                        default:\r\n                            parser.err(declarator);\r\n                            declarator = null;\r\n                    }\r\n                } else if (declarator.type !== \"Identifier\") {\r\n                    parser.err(declarator);\r\n                    declarator = null;\r\n                } else {\r\n                    validateAssignment(context, declarator);\r\n                }\r\n                if (kind) {\r\n                    left = new NODES.VariableDeclaration();\r\n                    left.declarations = [\r\n                        {\r\n                            type: \"VariableDeclarator\",\r\n                            id: declarator,\r\n                            init: null\r\n                        }\r\n                    ];\r\n                    left.kind = kind.value;\r\n                    left.range = [kind.range[0], declarator.range[1]];\r\n                    left.loc = {\r\n                        start: kind.loc.start,\r\n                        end: declarator.loc.end\r\n                    };\r\n                    collected.left = left;\r\n                } else {\r\n                    collected.left = declarator;\r\n                }\r\n                return collected;\r\n            },\r\n            validator(context: Context) {\r\n                return context[CONTEXT.right] >= context.tokens.length - 1;\r\n            },\r\n            filter: [function () { return false }, null],\r\n            precedence: 1.5,\r\n            collector: [\r\n                {\r\n                    _: _Series(//和 VariableDeclaration 不冲突的占位 \r\n                        MATCH_MARKS.BOUNDARY,\r\n                        _Or(\r\n                            _Series(\r\n                                _Or(\"Keyword var const let\"),\r\n                                _Or(\"Identifier\", \"Punctuator {} [] ()\")\r\n                            ),\r\n                            _Series(\r\n                                \"Identifier let\",\r\n                                _Or(\"Identifier\", \"Punctuator {} ()\")\r\n                            )\r\n                        )\r\n\r\n                    )\r\n                },\r\n                {\r\n                    type: _Mark(\"ForOfStatement\"),\r\n                    _prev: _NonCollecting(MATCH_MARKS.BOUNDARY),\r\n                    left: _Series(\r\n                        _Option(_Or(\"Identifier let\", \"Keyword var const let\")),\r\n                        _Or(\"Identifier\", \"Punctuator {} [] ()\")\r\n                    ),\r\n                    token: _NonCollecting(\"Identifier of\"),\r\n                    right: _Option(\r\n                        _Series(\r\n                            EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n                            _Option(_NonCapturing(\"Punctuator )\"))\r\n                        )\r\n                    ),\r\n                    body: _Mark(null),\r\n                },\r\n                [\r\n                    [\"type\", _Mark(\"ForInStatement\")],\r\n                    [\"token\", _NonCollecting(\"Keyword in\")],\r\n                    [\"each\", _Mark(false)]\r\n                ]\r\n            ]\r\n\r\n        }\r\n    ]\r\n};\r\nlet FOR_ITERATOR_TREE = createMatchTree(ForIterator, EXPRESSION_TREE);\r\n","import {\r\n    Context, CONTEXT, Token, Node\r\n} from '../interfaces';\r\nimport {\r\n    _Punctuator,\r\n    _Keyword,\r\n    _Identifier,\r\n    _Pattern,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark, TYPE_ALIAS, MATCH_MARKS,\r\n    validateLineTerminator, NODES, _NonCapturing, join_content, createMatchTree\r\n} from './head'\r\nimport { parse_and_extract, parse_next_statement } from './index';\r\nlet Grouping = NODES.Grouping;\r\n\r\nconst STRING_LITERAL_PATTERN = _Or(\"Literal\").pipe(\r\n    function (context: Context, token: Token) {\r\n        if (token instanceof Grouping || typeof token.value !== \"string\") {\r\n            context[CONTEXT.parser].err(token);\r\n        }\r\n    }\r\n)\r\n\r\nlet ImportSpecifiers = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: \"ImportSpecifier\",\r\n            }\r\n        ]\r\n    },\r\n    ImportSpecifier: {\r\n        collector: {\r\n            _prev: _NonCapturing(\"Success\", MATCH_MARKS.BOUNDARY),\r\n            imported: \"Identifier\",\r\n            local: _Or(\r\n                _Series(\r\n                    _NonCollecting(\"Identifier as\"),\r\n                    \"Identifier\",\r\n                    _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY)\r\n                ),\r\n                _Or(\"Punctuator ,\", MATCH_MARKS.BOUNDARY).pipe(\r\n                    function (context: Context) {\r\n                        let [collected] = context;\r\n                        return collected.imported;\r\n                    }\r\n                )\r\n            )\r\n        }\r\n\r\n    }\r\n}\r\n\r\nconst IMPORT_SPECIFIERS_TREE = createMatchTree(ImportSpecifiers);\r\nconst EXPORT_SPECIFIERS_TREE = createMatchTree({\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: \"ExportSpecifier\",\r\n            }\r\n        ]\r\n    },\r\n    ExportSpecifier: {\r\n        collector: {\r\n            _prev: _NonCapturing(\"Success\", MATCH_MARKS.BOUNDARY),\r\n            local: \"Identifier\",\r\n            exported: _Or(\r\n                _Series(\r\n                    _NonCollecting(\"Identifier as\"),\r\n                    \"Identifier\",\r\n                    _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY)\r\n                ),\r\n                _Or(\"Punctuator ,\", MATCH_MARKS.BOUNDARY).pipe(\r\n                    function (context: Context) {\r\n                        let [collected] = context;\r\n                        return collected.local;\r\n                    }\r\n                )\r\n            )\r\n        }\r\n    }\r\n});\r\n\r\nconst ModuleDeclarations: Record<string, any> = {\r\n    \"ImportDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.isModule]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword import\"),\r\n                specifiers: _Or(\r\n                    _Punctuator(\"{}\").pipe(\r\n                        function (context: Context, token: Token) {\r\n                            return parse_and_extract(IMPORT_SPECIFIERS_TREE, context, token);\r\n                        }\r\n                    ),\r\n                    _Series(\r\n                        _NonCollecting(\"Punctuator *\"),\r\n                        _NonCollecting(\"Identifier as\"),\r\n                        _Identifier().pipe(\r\n                            function (context: Context, token: Token) {\r\n                                return [\r\n                                    {\r\n                                        type: \"ImportNamespaceSpecifier\",\r\n                                        local: token\r\n                                    }\r\n                                ]\r\n                            }\r\n                        )\r\n                    ),\r\n                    _Series(\r\n                        _Identifier().pipe(\r\n                            function (context: Context, Identifier: Token) {\r\n                                return {\r\n                                    type: \"ImportDefaultSpecifier\",\r\n                                    local: Identifier\r\n                                }\r\n                            }\r\n                        ),\r\n                        _Option(\r\n                            _Series(\r\n                                _NonCollecting(\"Punctuator ,\"),\r\n                                _Or(\r\n                                    _Series(\r\n                                        _Punctuator(\"{}\").pipe(\r\n                                            function (context: Context, token: Token) {\r\n                                                return parse_and_extract(IMPORT_SPECIFIERS_TREE, context, token);\r\n                                            }\r\n                                        ),\r\n                                        _Mark(\r\n                                            function (context: Context) {\r\n                                                let [collected] = context;\r\n                                                let specifiers = collected.specifiers;\r\n                                                specifiers.splice(1, 1, ...specifiers[1]);\r\n                                            }\r\n                                        )\r\n                                    ),\r\n                                    _Series(\r\n                                        _NonCollecting(\"Punctuator *\"),\r\n                                        _NonCollecting(\"Identifier as\"),\r\n                                        _Identifier().pipe(\r\n                                            function (context: Context, token: Token) {\r\n                                                return {\r\n                                                    type: \"ImportNamespaceSpecifier\",\r\n                                                    local: token\r\n                                                }\r\n                                            }\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        ),\r\n                        _Mark(function () { })//使结果收集为数组\r\n                    )\r\n                ),\r\n                _: _NonCollecting(\"Identifier from\"),\r\n                source: STRING_LITERAL_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"ExportAllDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.isModule]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        collector: {\r\n            _: _NonCollecting(_Series(\"Keyword export\", \"Punctuator *\", \"Identifier from\")),\r\n            source: STRING_LITERAL_PATTERN,\r\n            _next: _Option(\"Punctuator ;\"),\r\n        },\r\n    },\r\n    \"ExportNamedDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            collected.declaration || validateLineTerminator(context);\r\n            if (!context[CONTEXT.isModule]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                _: _NonCollecting(\"Keyword export\"),\r\n                declaration: \"VariableDeclaration\",\r\n                specifiers: _Mark(() => []),\r\n                source: _Mark(null)\r\n            },\r\n            {\r\n                _: _NonCollecting(\"Keyword export\"),\r\n                declaration: _Mark(null),\r\n                specifiers: _Punctuator(\"{}\").pipe(\r\n                    function (context: Context, token: Token) {\r\n                        return parse_and_extract(EXPORT_SPECIFIERS_TREE, context, token);\r\n                    }\r\n                ),\r\n                source: _Mark(null),\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"ExportDefaultDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.isModule]) {\r\n                context[CONTEXT.parser].err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        precedence: 1.5,\r\n        collector: [\r\n            {\r\n                type: _Mark(\"ExportDefaultDeclaration\"),\r\n                _: _NonCollecting(\"Keyword export\"),\r\n                __: _NonCollecting(\"Keyword default\"),\r\n                declaration: \"[Expression]\",\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    }\r\n}\r\nexport default ModuleDeclarations;"],"sourceRoot":""}