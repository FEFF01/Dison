{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/syntax/head.ts","webpack:///./js/syntax/index.ts","webpack:///./js/syntax/expression.ts","webpack:///./js/character.ts","webpack:///./js/tokenizer.ts","webpack:///./js/lexical/index.ts","webpack:///./js/lexical/head.ts","webpack:///./js/syntax/declaration.ts","webpack:///./js/parser.ts","webpack:///./js/syntax/pattern.ts","webpack:///./js/syntax/statement.ts","webpack:///./js/syntax/module_declaration.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","OPERATOR_ID","operands","sub_operators","watch","watcher","this","_watcher","push","_factors","operand","Operator","Mark","parts","replace","split","length","slice","map","parents","factor","watchers","result","concat","attach","prev_item","root","keys","getNode","parent","child","setWrap","records","getDeepNodes","children","factors","getNextNodes","Array","apply","configurable","undefined","MATCHED_RECORD","_get_wrapper_function","_Option","Option","some","_Or","Or","_Series","Series","_NonCapturing","NonCapturing","_NonCollecting","NonCollecting","_Loop","Loop","_Mark","NODES","Grouping","node","grouping","range","loc","Directive","type","expression","directive","Script","body","sourceType","Module","_get_adapt","data","index","eval","createMatchTree","block_list","prevent_update","item","wrapper","collectors","handlers","overload","precedences","filters","validators","indexOf","filter","handler","validator","collector","precedence","_collector","nodes","operator","last_node","props","matched_record","console","warn","_Context","parser","tokens","state_stack","context","wrap","unwrap","store","restore_point","arguments","restore","point","pop","FutureReservedWord","StrictModeReservedWord","RestrictedWord","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","_if_strict_throw_err","token","err","THROW_RESTRICT_WORDS_PATTERN","THROW_STRICT_RESERVED_WORDS_PATTERN","IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN","EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN","IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN","validateIdentifier","EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN","validateAssignment","validateBinding","binding_set","validateLineTerminator","collected","right","_next","next_token","start","line","end","join_content","success","content","TYPE_ALIAS","ASSIGNMENT_PUNCTUATORS_PATTERN","AWAIT_LIST","MODULE_ITEM_PATTERN","STATEMANT_LIST_ITEM_PATTERN","RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN","TOPLEVEL_ITEM_PATTERN","isAligned","left","EXPRESSION_TREE","EXPRESSION_ITEM_PATTERN","DECLARATION_ITEM_PATTERN","STATEMENT_ITEM_PATTERN","STATEMENT_LIST_ITEM_PATTERN","Expressions","descriptor","patterns","isStatementListItem","isExpression","isDeclaration","isStatement","isModuleItem","SYNTAX_TREE","extract_success","res","parse_next_statement","parseCustom","get_inner_group","parse_and_extract","match_tree","parseArrayPattern","parseObjectPattern","ARGUMENTS_PATTERN","parse_arguments","parseExpression","argument","octal","raw","quasis","expressions","_","__","elements","ARRAY_ELEMENTS_TREE","properties","OBJECT_PROPERTIES_TREE","parse_function_expression","async","generator","params","parseKeyword","body_context","parse_params","parseBlock","Number","superClass","METHOD_DEFINITIONS_TREE","tag","quasi","parseIdentifier","computed","meta","callee","first_token","second_token","prefix","createNode","test","delegate","expr","SequenceExpression","COMPUTED_PROPERTY_NAME_PATTERN","PRIMARY_EXPRESSION_TREE","PROPERTY_NAME_PATTERN","regex","MethodDefinitions","MethodDefinition","kind","_prev","static","_static","FunctionExpression","param_count","Arguments","Params","ArrayElements","ObjectProperties","method","shorthand","Patterns","PARAMS_TREE","ARGUMENTS_TREE","type_name","IdentifierStart","IdentifierPart","testCodePoint","regexp","input","charCodeAt","_bak","testUnicodeEscape","code","cp","hexValue","len","fromCodePoint","scanHex","ch","decimalValue","octalValue","binaryValue","isWhiteSpace","isLineTerminator","String","fromCharCode","inIdentifierStart","inIdentifierPart","isFollowingAnExpression","options","token_types","TOKEN_TYPES","token_hooks","save_comments","error_logs","tokenize","line_number","line_start","scan","getToken","column","match","prev_node","target","scanner","bound","error","nextIdentifier","str","TOKEN_TYPE_MAP","nextRegexp","prev_token","PRIOR_REGEXP_PUNCTUATORS_TREE","Punctuator","PUNCTUATORS_TREE","keyword_token","target_token","check","parent_token","Keyword","nextPunctuator","nextNumeric","number","flags","_get_token","Numeric","_get_error","message","NUMERIC_KEYWORD_MAP","nextToken","full_match","parent_token_bak","proxy_hook","Comments","Identifier","Boolean","RegularExpression","Template","TemplateElement","Null","reduce","octal_escape","_state","_attach","tokenizer","scope","octal_escape_tree","strbase_match_tree","_str","not_allow_octal_escape","_message","PUNCTUATORS","escape_scan","appendTemplateElement","tail","cooked","prev_line","prev_solumn","start_line","start_column","prev_column","search_scan","REGEXP_DESCRIPTOR","_end","class_marker","_error","pattern","createSearchTree","join","part","_scope","char","backslash_count","has_escape","EOF","matched_count","get_variable_declarator","init","VARIABLE_DECLARATOR_TREE","VariableDeclarators","Success","identifier","reinterpreat_expression_as_declaration","Declarations","___","declarations","cbfun","getLiteral","parse_value","RegExp","e","padding_token","args","parse","parseScript","parseModule","_parse","parseNode","environments","begin","hook","extreme","state","cursor","backflow_tape","finallize","longest","walk","splice","parseDirective","minimum","next","has_backflow","alias","explore","matched","matched_node","value_node","type_node","offset","prop","start_token","end_token","record","PETTERN_ELEMENTS_TREE","PATTERN_PROPERTIES_TREE","PatternElements","PatternProperties","ArrayPattern","is_binding","ObjectPattern","AssignmentPattern","Property","VariableDeclaration","Statements","label","keyword","iterator","iterator_tokens","FOR_ITERATOR_TREE","consequent","alternate","label_name","label_set","discriminant","cases","has_default","block","finalizer","param","ForIterator","ForStatement","update","declarator","STRING_LITERAL_PATTERN","ImportSpecifiers","ImportSpecifier","imported","local","IMPORT_SPECIFIERS_TREE","EXPORT_SPECIFIERS_TREE","ExportSpecifier","exported","ModuleDeclarations","specifiers","source","check_line_terminator","declaration"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,8jDC1DrD,IAAIC,YAAc,EAClB,oBAKI,WAAmBC,GAAA,KAAAA,WAFZ,KAAAC,cAAgB,GAoH3B,OAjHW,YAAAC,MAAP,SAAaC,GAMT,OALIC,KAAKC,SACLD,KAAKC,SAASC,KAAKH,GAEnBC,KAAKC,SAAW,CAACF,GAEdC,MAEX,sBAAW,sBAAO,C,IAAlB,WACI,IAAKA,KAAKG,SAAU,CAChBH,KAAKG,SAAW,GAChB,IAAsB,UAAAH,KAAKJ,SAAL,eAAe,CAAhC,IAAMQ,EAAO,KACd,GAAIA,aAAmBC,GAAYD,aAAmBE,KAClDN,KAAKG,SAASD,KAAKE,OAChB,CACH,IAAIG,EAA2B,iBAAZH,EACfA,EAAQI,QAAQ,aAAc,IAAIC,MAAM,OACxC,CAACL,GACLJ,KAAKG,SAASD,KACV,CACIK,EAAM,GACNA,EAAMG,OAAS,EACTH,EAAMI,MAAM,GACZ,CAAC,aAK3B,OAAOX,KAAKG,U,gCAGN,YAAAS,IAAV,SACIC,EACAC,EACA5B,EAEA6B,GAEA,IAAIC,EAA0B,GAC1Bf,EAAWc,EACTf,KAAKC,SACHD,KAAKC,SAASgB,OAAOF,GACnBA,EACJf,KAAKC,SACX,GAAIa,aAAkBT,GAAYS,aAAkBR,KAChD,OAAOQ,EAAOI,OAAOL,EAAS3B,EAAKe,GAEnC,IAAwB,UAAAY,EAAA,eAAS,CAA5B,IAAMM,EAAS,KACXC,EAAcD,EAAS,GAAjBE,EAAQF,EAAS,IAC3BE,EAAOA,EAAKV,SAAST,KAAK,CAAChB,EAAKe,IAEjC,IADA,IAAI,EAASD,KAAKsB,QAAQF,EAAMN,EAAO,IACnB,MAAAA,EAAO,GAAP,eAAW,CAA1B,IAAMlC,EAAK,KACZoC,EAAOd,KACH,CACIF,KAAKsB,QAAQ,EAAQ1C,EAAOwC,GAC5BC,EACA,QAOpB,OAAOL,GAEH,YAAAM,QAAR,SAAgBC,EAAarC,EAAsBkC,G,MAC3CI,EAAQD,EAAOrC,GACnB,OAAIsC,GACIA,EAAM,SAA4B7B,cAClC4B,EAAOrC,GAAOsC,EAAQ,SAAH,GAAQA,GAC3BA,EAAM,OAA0B7B,aAE7B6B,IAGXA,EAAQD,EAAOrC,KAAI,MACf,OAA0BS,Y,GAE9ByB,IAASI,EAAM,SAAsBJ,EAAK,SAAsB,GACzDI,IAED,YAAAC,QAAV,SAAkBC,GACd,KAAM,YAiBA,YAAAC,aAAV,SAAuBd,EAA0B3B,EAAoB6B,GAEjE,IADA,IAAIa,EAAWf,EACM,MADab,KAAK6B,QAClB,eAAS,CAAzB,IAAMf,EAAM,KACbc,EAAW5B,KAAKY,IAAIgB,EAAUd,EAAQ5B,EAAK6B,GAE/C,OAAOa,GAED,YAAAE,aAAV,SAAuBjB,EAA0B3B,EAAoB6B,GAEjE,IADA,IAAIa,EAAW,GACM,MADQ5B,KAAK6B,QACb,eAAS,CAAzB,IAAMf,EAAM,KACbiB,MAAMxC,UAAUW,KAAK8B,MAAMJ,EAAU5B,KAAKY,IAAIC,EAASC,EAAQ5B,EAAK6B,IAExE,OAAOa,GAEf,EAvHA,GAkIA,gC,+CAKA,OALqB,eACjB,YAAAV,OAAA,SAAOL,EAA0B3B,EAAa6B,GAE1C,OADef,KAAK8B,aAAajB,EAAS3B,EAAK6B,GAAUE,OAAOJ,IAGxE,EALA,CAAqBR,UAMrB,4B,+CAIA,OAJiB,eACb,YAAAa,OAAA,SAAOL,EAA0B3B,EAAa6B,GAC1C,OAAOf,KAAK8B,aAAajB,EAAS3B,EAAK6B,IAE/C,EAJA,CAAiBV,UAMjB,gC,+CAIA,OAJqB,eACjB,YAAAa,OAAA,SAAOL,EAA0B3B,EAAa6B,GAC1C,OAAOf,KAAK2B,aAAad,EAAS3B,EAAK6B,IAE/C,EAJA,CAAqBV,UAmBrB,sC,+CAIA,OAJ2B,eACvB,YAAAa,OAAA,SAAOL,EAA0B3B,EAAa6B,GAC1C,OAAOf,KAAK8B,aAAajB,EAAS,KAAME,IAEhD,EAJA,CAA2BV,UAM3B,uC,+CAIA,OAJ4B,eACxB,YAAAa,OAAA,SAAOL,EAA0B3B,EAAa6B,GAC1C,OAAOf,KAAK8B,aAAajB,EAAS,GAAIE,IAE9C,EAJA,CAA4BV,UAM5B,8B,+CAgBA,OAhBmB,eAEf,YAAAa,OAAA,SAAOL,EAA0B3B,GAC7B,KAAM,YAad,EAhBA,CAAmBmB,UAkBnB,gBAII,WAAYzB,GACa,mBAAVA,EACPP,OAAOC,eAAe0B,KAAM,QAAS,CACjCiC,cAAc,EACd1D,YAAY,EACZC,IAAKI,IAGToB,KAAKpB,MAAQA,EAiBzB,OAdI,YAAAsC,OAAA,SAAOL,EAA0B3B,EAAa6B,GAC1C,IAAInC,EAAQoB,KAAKpB,MACjB,GAAIM,QAAiBgD,IAAVtD,EACP,GAAY,SAARM,EACAoB,EAAK6B,eAAe,GAAmBC,sBAAsBxD,OAC1D,CACHoB,KAAKd,IAAMA,EACX,IAAqB,UAAA2B,EAAA,eAAS,CAAzB,IAAM,EAAM,KACb,EAAO,GAAK,EAAO,GAAGI,OAAOjB,OAIzC,OAAOa,GAEf,EA7BA,GA+BA,SAASwB,U,IAAQ,sDACb,OAAO,IAAIC,OAAOC,GAStB,SAASC,M,IAAI,sDACT,OAAO,IAAIC,GAAGF,GAElB,SAASG,U,IAAQ,sDACb,OAAO,IAAIC,OAAOJ,GAEtB,SAASK,gB,IAAc,sDACnB,OAAO,IAAIC,aAAaN,GAE5B,SAASO,iB,IAAe,sDACpB,OAAO,IAAIC,cAAcR,GAI7B,SAASS,Q,IAAM,sDACX,OAAO,IAAIC,KAAKV,GAEpB,SAASW,MAAMX,GACX,OAAO,IAAIjC,KAAKiC,GA+ThB,QAAAjC,UAsBA,QAAA+B,gBAAS,QAAAG,QAAK,QAAAE,gBAAS,QAAAE,4BAAe,QAAAE,8BAAuB,QAAAE,YAAP,QAAAE,YAnV1D,IAAIC,MAAgD,CAChDC,SAAA,SAASC,EAA4BC,GACjC,IAAK,IAAMpE,KAAOmE,EACdrD,KAAKd,GAAOmE,EAAKnE,GAEjBoE,IACAtD,KAAKuD,MAAQD,EAASC,MACtBvD,KAAKwD,IAAMF,EAASE,MAG5BC,UAAA,SACIC,EACAC,EACAC,EACAL,EACAC,GAEAxD,KAAK0D,KAAOA,EACZ1D,KAAK2D,WAAaA,EAClB3D,KAAK4D,UAAYA,EACjB5D,KAAKuD,MAAQA,EACbvD,KAAKwD,IAAMA,GAEfK,OAAA,SAAOC,EAAmBP,EAAyBC,GAC/CxD,KAAK0D,KAAO,UACZ1D,KAAK+D,WAAa,SAClB/D,KAAK8D,KAAOA,EACZ9D,KAAKuD,MAAQA,EACbvD,KAAKwD,IAAMA,GAEfQ,OAAA,SAAOF,EAAmBP,EAAyBC,GAC/CxD,KAAK0D,KAAO,UACZ1D,KAAK+D,WAAa,SAClB/D,KAAK8D,KAAOA,EACZ9D,KAAKuD,MAAQA,EACbvD,KAAKwD,IAAMA,IAGnB,SAASS,WAAWC,EAAWC,GAC3B,OAAOD,aAAgBnC,MAAQoC,EAAQD,EAAKxD,OACtCwD,EAAKC,GACLD,EAAKA,EAAKxD,OAAS,GAAKwD,EAElC,SAAS9B,sBAAsBsB,MAC3B,OAAOP,MAAMO,QAELP,MAAMO,MACJU,KAAK,aAAaV,KAAI,iBAAiBA,KAAI,QAGzD,SAASW,gBACLH,EACA9C,EACAkD,EACAC,G,MAKA,QANA,IAAAD,MAAA,SACA,IAAAC,OAAA,GAEAA,IAAmB5E,aAAe,GAClCyB,EAAOA,EAAOmD,EAAiBnD,EAAO,SAAD,GAAMA,KAAQ,MAAG,UAAuB,EAAC,GAE1E8C,aAAgBnC,MAChB,IAAmB,UAAAmC,EAAA,eAAM,CACrB9C,EAAOiD,gBADAG,EAAI,KACkBpD,EAAMkD,GAAY,QAGnD,IAAK,IAAMZ,KAAQQ,EAEf,IADA,IAAIO,EAAUrC,sBAAsBsB,GACnB,MAAAQ,EAAKR,aAAiB3B,MAAQmC,EAAKR,GAAQ,CAACQ,EAAKR,IAAjD,eAAyD,CAArE,IAAIc,EAEUE,GAFVF,EAAI,MAQD,UALKG,EAKTH,EAAI,QAJJI,EAIAJ,EAAI,SAHJ,EAGAA,EAAI,WAHQK,OAAW,IAAG,MAAG,EACrBC,EAERN,EAAI,OADOO,EACXP,EAAI,UACR,GAAKE,KAAeJ,EAAWU,QAAQtB,GAAvC,CAGmB,iBAAZoB,IAAyBA,EAAUZ,EAAKY,GAASG,QACpC,iBAAbN,IAA0BA,EAAWT,EAAKS,GAAUO,SACrC,iBAAfH,IAA4BA,EAAab,EAAKa,GAAYI,WACjET,aAAsB3C,QAAU2C,EAAa,CAACA,IAE9C,IAAK,IAAIP,EAAQ,EAAGA,EAAQO,EAAWhE,OAAQyD,IAAS,CACpD,IAAIiB,EAAYV,EAAWP,GAEvBkB,EAA0CpB,WAAWY,EAAaV,GAClEe,EAAoCjB,WAAWU,EAAUR,GACzDc,EAAkChB,WAAWa,EAASX,GACtDgB,EAAwClB,WAAWc,EAAYZ,GAInE,GAHA7D,KAAK6B,eAAiB,CAClBkD,EAAY,KAAMZ,EAASS,EAASC,EAAWF,GAE/CG,aAAqBrD,MAAO,CAC5B,IAAIuD,EAAa,SAAH,GAAQZ,EAAWP,EAAQ,IACzCiB,EAAU,MAAQA,EAAU,aAAcrD,SAAWqD,EAAY,CAACA,IAClE,IAA2B,UAAAA,EAAA,eAAW,CAA3B,WAAClG,EAAG,KAAEN,EAAK,KAClB0G,EAAWpG,GAAON,EAEtB8F,EAAWP,GAASiB,EAAYE,EAGpC,IAAIC,EAAyB,CAAC,CAACnE,EAAM,GAAI,OAGzC,IAAK,IAAMlC,KAAOkG,EAAW,CACzB,IAAII,EAAWJ,EAAUlG,GACnBsG,aAAoBnF,UAAYmF,aAAoBlF,OACtDkF,EAAWhD,IAAIgD,IAEnBD,EAAQC,EAAStE,OAAOqE,EAAOrG,GAGnC,IAAiC,UAAAqG,EAAA,eAAO,CAA7B,WAACE,EAAS,KAAEC,EAAK,KACpBC,EAAiBrF,KAAK6B,eAAexB,QACzCgF,EAAe,GAAiBD,GAC3Bd,GAAYa,EAAU,SACvBG,QAAQC,KACJ,YACAJ,EACAA,EAAU,QACVE,GAGRF,EAAU,QAAyBE,KAOvD,OAAOvE,EAOX,SAAS0E,SAASC,EAAgBC,GAC9B,IAAIC,EAAc,GACdC,EAAe,IAAInE,MAAM,IAS7B,OARAmE,EAAQ,GAAkBH,EAC1BG,EAAQ,GAAkBF,EAC1BE,EAAQ,IAAoB,GAC5BA,EAAQC,KAAOA,EACfD,EAAQE,OAASA,EACjBF,EAAQG,MAiBR,WAEI,IADA,IAAIC,EAAgBL,EAAYvF,OACvByD,EAAQ,EAAGA,EAAQoC,UAAU7F,OAAQyD,GAAS,EACnDgC,EAAKI,UAAUpC,GAAQoC,UAAUpC,EAAQ,IAE7C,OAAOmC,GArBXJ,EAAQM,QAuBR,SAAiBC,GACb,KAAOR,EAAYvF,OAAS+F,GACxBL,IAEJ,OAAOH,EAAYvF,QAzBhBwF,EAKP,SAASC,EAAKjH,EAAcN,GAGxB,OAFAqH,EAAY/F,KAAKgG,EAAQhH,GAAMA,GAC/BgH,EAAQhH,GAAON,EACRsH,EAEX,SAASE,IAEL,OADAF,EAAQD,EAAYS,OAAST,EAAYS,MAClCR,GAwKX,QAAA/C,YAGA,QAAAkB,gCAMA,QAAAyB,kBAjKJ,IAAMa,mBAAqB,CAAC,OAAQ,SAAU,SAAU,SAClDC,uBAAyB,CAC3B,aAAc,YAAa,UAAW,UAAW,YAAa,SAAU,SAAU,QAAS,OAEzFC,eAAiB,CAAC,OAAQ,aAEhC,SAASC,qBAAqBC,GAC1B,OAAOJ,mBAAmB3B,QAAQ+B,IAAO,EAE7C,SAASC,yBAAyBD,GAC9B,OAAOH,uBAAuB5B,QAAQ+B,IAAO,EAEjD,SAASE,iBAAiBF,GACtB,OAAOF,eAAe7B,QAAQ+B,IAAO,EAIzC,SAASG,qBAAqBhB,EAAkBiB,GACxCjB,EAAQ,KACRA,EAAQ,GAAgBkB,IAAID,GA0IhC,QAAAL,0CACA,QAAAE,kDAFA,QAAAC,kCAtIJ,IAAMI,6BAA+B7E,IACjC,6BACF1C,MAAMoH,sBACFI,oCAAsC9E,IACxC,qFACF1C,MAAMoH,sBAEFK,kDAAoD/E,IAAI,aAAc8E,qCAuHxE,QAAAC,oGAtHJ,IAAMC,kDAAoDhF,IAAI,eAAgB8E,qCAuH1E,QAAAE,oGArHJ,IAAMC,qDAAuDjF,IAAI,cAAc1C,MAAM4H,oBAkHjF,QAAAD,0GAjHJ,IAAME,qDAAuDnF,IACzD,eACAiF,sDAOJ,SAASC,mBAAmBxB,EAAkB7C,GAC1C,GACI6C,EAAQ,IAER,OAAKc,yBAAyB3D,EAAKnF,QAGnCgI,EAAQ,GAAgBkB,IAAI/D,IACrB,GAGf,SAASuE,mBAAmB1B,EAAkB7C,GAC1C,GACI6C,EAAQ,IAER,OACIe,iBAAiB5D,EAAKnF,QACnB8I,yBAAyB3D,EAAKnF,QAIrCgI,EAAQ,GAAgBkB,IAAI/D,IACrB,GAGf,SAASwE,gBAAgB3B,EAAkB7C,GACvC,IAA0C,IAAtCuE,mBAAmB1B,EAAS7C,GAAgB,CAC5C,IAAIyE,EAAc5B,EAAQ,IAC1B,OAAI4B,IACAA,EAAY5H,KAAKmD,EAAKnF,MAClB4J,EAAY9C,QAAQ3B,EAAKnF,QAAU4J,EAAYpH,OAAS,KACxDwF,EAAQ,GAAgBkB,IAAI/D,IACrB,IAOvB,SAAS0E,uBAAuB,G,IAACC,EAAS,KAAEjC,EAAM,KAAEC,EAAM,KAAIiC,EAAK,KAC/D,GAAID,EAAUE,aACHF,EAAUE,UACd,CACH,IAAIC,EAAanC,EAAOiC,EAAQ,GAC5BE,GAAcA,EAAW3E,IAAI4E,MAAMC,OAASL,EAAUxE,IAAI8E,IAAID,MAC9DtC,EAAOqB,IAAIe,GAGnB,OAAOH,EAyDP,QAAAL,0GAYA,QAAAD,sCACA,QAAAE,sCATA,QAAAC,gCAAiB,QAAAE,8CA1DrB,IAAIQ,aAAe,SAAU,G,IAACP,EAAS,KAC7BQ,EAAqBR,EAAS,QAArBS,EAAYT,EAAS,QACpC,OAAIQ,GACAA,EAAQC,QAAQvI,KAAKuI,GACdD,IAEPR,EAAUS,QAAU,CAACA,GACdT,IA6CX,QAAAO,0BAzCJ,IAAIG,WAAa,GAiDb,QAAAA,sBA/CJ,IAAMC,+BAAiCnG,IAAI,yDA4CvC,QAAAmG,8DA1CJ,IAAIC,WAAgC,GAoChC,QAAAA,sBAlCJ,IAAMC,oBAAsBrG,IACxB,oBACA,uBACA,yBACA,4BAEEsG,4BAA8BtG,IAAI,gBAAiB,eAyBrD,QAAAsG,wDAvBJ,IAAMC,iCAAmCvG,IACrC,aACAqG,oBACAC,6BAqBA,QAAAC,kEAnBJ,IAAMC,sBAAwBxG,IAAI,GAE9B,aACAqG,oBACAC,6BAGJ,SAASG,UAAU/C,EAAkBgD,EAAcjB,GAE/C,IADA,IAAIjC,EAASE,EAAQ,GACZ/B,EAAQ+E,EAAM/E,EAAQ8D,EAAO9D,IAClC,GAAI6B,EAAO7B,GAAOX,IAAI8E,IAAID,OAASrC,EAAO7B,EAAQ,GAAGX,IAAI4E,MAAMC,KAC3D,OAAO,EAGf,OAAO,EAMP,QAAAW,4CAHM,QAAAC,qB,sRC9kBV,WAQA,OAmIiB,+EAjIb,EAAAE,mBAaJ,IAXA,WACA,QACA,QAIIC,EAA0B,GAC1BC,EAA2B,GAC3BC,EAAyB,GACzBC,EAA8B,GAC9BV,EAAsB,GAItB,OACI,CACI,EAAAW,YACA,CAACJ,IAEL,CACI,UACA,CAACC,EAA0BE,IAE/B,CACI,UACA,CAACD,EAAwBC,IAE7B,CACI,UACA,CAACV,EAAqBU,KAf9B,eAkBF,CApBQ,WAACE,EAAU,KAAEC,EAAQ,KAqB3B,IAAK,IAAMxK,KAAOuK,EACd,GAAIvK,EACA,IAAsB,UAAAwK,EAAA,eAAU,CAAd,KACNxK,IAAO,GAe/B,SAASyK,EAAoBtG,GACzB,OAAOkG,EAA4BlG,EAAKK,MA0ExC,EAAAkG,aApFJ,SAAsBvG,GAClB,OAAO+F,EAAwB/F,EAAKK,OAmFtB,EAAAmG,cAjFlB,SAAuBxG,GACnB,OAAOgG,EAAyBhG,EAAKK,OAgFR,EAAAoG,YA9EjC,SAAqBzG,GACjB,OAAOiG,EAAuBjG,EAAKK,OA6EO,EAAAiG,sBAAqB,EAAAI,aAxEnE,SAAsB1G,GAClB,OAAOwF,EAAoBxF,EAAKK,OAIpC,IAAMsG,EAAc,EAAA3F,gBAAgB,CAChC,UACA,UACA,WACD,EAAA8E,iBA2BH,SAASc,EAAgBlE,EAAgBR,GACrC,IAAI2E,EAAmB3E,EAUvB,OATIA,EAAM7E,SACgB,YAAlB6E,EAAM,GAAG7B,MACTwG,EAAM3E,EAAM,GAAGkD,QACflD,EAAM7E,OAAS,GAAKqF,EAAOqB,IAAG,MAAVrB,EAAcR,EAAM5E,MAAM,MAE9CuJ,EAAM,GACNnE,EAAOqB,IAAG,MAAVrB,EAAcR,KAGf2E,EA0BP,EAAAF,cANA,EAAAG,qBAvDJ,SAA8BjE,EAAkBkC,QAAA,IAAAA,MAAQlC,EAAQ,GAAiB,GAC7E,IAAIH,EAASG,EAAQ,GACrB,GACIH,EAAOqE,YACHrE,EAAOiE,YACP9D,EACAkC,EACAuB,GAGJ,OAAO,GA8CX,EAAAU,gBA3CJ,SAAyBlD,GACrB,KAC6B,IAAzBA,EAAMsB,QAAQ/H,QACgB,OAA3ByG,EAAMsB,QAAQ,GAAG7J,OACS,eAA1BuI,EAAMsB,QAAQ,GAAG/E,MAEpByD,EAAQA,EAAMsB,QAAQ,GAE1B,OAAOtB,GAoCP,EAAA8C,kBACA,EAAAK,kBApBJ,SAA2BC,EAAiCrE,EAAkB7C,GACnE,IAAA0C,EAAUG,EAAO,GACpBF,EAAS3C,EAAKoF,QAMlB,OALIzC,EAAOtF,SACPwF,EAAQ,GAAkBF,EAC1BD,EAAOqE,YAAYG,EAAYrE,GAC/BF,EAASiE,EAAgBlE,EAAQC,IAE9BA,I,yNC7HX,WAcA,OAEA,OA45BI,iFA15BA,EAAAwE,qBA25BA,kFA15BA,EAAAC,sBAEJ,IAAMrH,EAAW,EAAAD,MAAMC,SAGjBsH,EAAoB,EAAAlI,IAAI,iBAAiB1C,OAC3C,SAAUoG,EAAkBiB,GACNjB,EAAO,GACfK,UAAYoE,EAAgBzE,EAASiB,EAAMsB,YAKvDe,EAAmC,CACrC,GAAI,CACA,CACItE,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GACjCA,EAAQC,KAAK,GAAoB,MACjC,IAAI9C,EAAO0C,EAAO6E,gBAAgB1E,EAAS8B,EAAUb,OAErD,OADAjB,EAAQE,SACD/C,EAAO,IAAID,EAASC,EAAM2E,EAAUb,OAAS,IAExD9B,WAAY,GACZD,UAAW,CACP1B,KAAM,EAAAR,MAAM,YACZiE,MAAO,kBAGf,CACIhC,UAAA,SAAUe,GACC,IAAAH,EAA2BG,EAAO,GAA1BF,EAAmBE,EAAO,GAAhB+B,EAAS/B,EAAO,GAEzC,OADAF,EAAOiC,aAAkB7E,GAAY2C,EAAOqB,IAAIpB,EAAOiC,KAChD,GAEXhD,OAAA,SAAOiB,GACH,OAAOA,EAAQ,MAA2BA,EAAQ,IAEtDb,WAAY,IACZD,UAAW,CACP1B,KAAM,EAAAR,MAAM,iBACZiE,MAAO,EAAArE,eAAe,kBACtB+H,SAAU,iBAGlB,CACI1F,UAAA,SAAUe,GACC,IAAAH,EAA2BG,EAAO,GACrC2E,EAD8B3E,EAAO,GAAPA,EAAO,IAGzC,OADA2E,aAAoBzH,GAAY2C,EAAOqB,IAAIyD,IACpC,GAEX5F,OAAQ,SAAUiB,GACd,OAAOA,EAAQ,MAA4BA,EAAQ,IAEvDb,WAAY,IACZD,UAAW,CACP1B,KAAM,EAAAR,MAAM,eACZiE,MAAO,EAAArE,eAAe,kBACtB+H,SAAU,EAAArI,IAAI,EAAAA,IAAI,cAAc1C,MAAM,EAAA+H,iBAAkB,eAAgB,oBAIpF,WAAc,GAEd,QAAW,CACP,CACI3C,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC7B,EAAoC8B,EAAUpJ,MAAvCA,EAAK,MAAEkM,EAAK,QAASC,EAAG,QAMnC,OALA/C,EAAUpJ,MAAQA,EAClBoJ,EAAU+C,IAAMA,EACZD,GAAS5E,EAAQ,KACjBH,EAAOqB,IAAIY,GAERA,GAEX5C,UAAW,CACPxG,MAAO,SACPmM,IAAK,EAAA7H,MAAM,SAIvB,eAAkB,CACdkC,UAAW,CACP+B,MAAO,EAAArE,eAAe,kBAG9B,gBAAmB,CACfoC,QAAA,SAAQgB,GAGJ,IAFK,IAAA8B,EAAsC9B,EAAO,GAAlCH,EAA2BG,EAAO,GAE/B,MAFwBA,EAAO,GAAPA,EAAO,IACtBuC,QACT,eAAS,CAAvB,IAAMjE,EAAI,KACO,oBAAdA,EAAKd,KACLsE,EAAUgD,OAAO9K,KAAKsE,GAEtBwD,EAAUiD,YAAY/K,KAAK6F,EAAO6E,gBAAgB1E,EAAS1B,IAGnE,OAAOwD,GAEX5C,UAAW,CACP,CACI8F,EAAG,EAAAtI,cAAc,EAAAP,QAAQ,iBACzB8I,GAAI,EAAArI,eAAe,eACnBkI,OAAQ,EAAA9H,MAAMnB,OACdkJ,YAAa,EAAA/H,MAAMnB,UAI/B,gBAAmB,CACfsD,WAAY,GACZD,UAAW,CACPgG,SAAU,EAAA5I,IAAI,iBAAiB1C,OAC3B,SAAUoG,EAAkB7C,GACnB,IAAA2E,EAAa9B,EAAO,GACzBA,EAAQC,KAAK,GAAuB9C,EAAKoF,SACzCT,EAAUoD,SAAW,EAAAd,kBAAkBe,EAAqBnF,EAAS7C,GACrE6C,EAAQE,cAMxB,iBAAoB,CAChBlB,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GAEzB,OADA8B,EAAUsD,WAAa,EAAAhB,kBAAkBiB,EAAwBrF,EAAS8B,EAAUsD,YAC7EtD,GAEX3C,WAAY,GACZD,UAAW,CACPkG,WAAY,kBAIpB,mBAAsB,CAClB,CACIpG,QAASsG,EACTpG,UAAW,CACP,CACIqG,MAAO,EAAAjJ,IACH,EAAAE,QAAQ,EAAAQ,OAAM,GAAO,EAAAJ,eAAe,kBACpC,EAAAI,OAAM,IAEViI,GAAI,EAAArI,eAAe,oBACnB4I,UAAW,EAAAlJ,IACP,EAAAE,QAAQ,EAAAQ,OAAM,GAAO,EAAAJ,eAAe,iBACpC,EAAAI,OAAM,IAEV6D,GAAI,EAAAvE,IAAI,EAAA+E,kDAAmD,EAAArE,MAAM,OACjEyI,OAAQ,gBACR7H,KAAM,gBACNH,WAAY,EAAAT,OAAM,MAI9B,CACIgC,QAAA,SAAQ,G,IAAC8C,EAAS,KACd,OADsB,KACR4D,aAAa5D,EAAUyD,QAEzCxG,OAAQ,CACJ,WACI,OAAO,GAEX,EAAAgE,WAEJ7D,UAAW,CACP,CAAE8F,EAAG,EAAAxI,QAAQ,mBAAoB,eACjC,CACI+I,MAAO,mBACPvD,MAAO,EAAAtF,cAAc,qBAEzB,CACI6I,MAAO,mBACPE,OAAQ,EAAA/I,cAAc,gBAAiB,cACvCuE,MAAO,EAAAvE,cAAc,qBAKrC,wBAA2B,CACvBsC,QAAA,SAAQgB,GACC,IAAA8B,EAAmC9B,EAAO,GAA/BH,EAAwBG,EAAO,GAAvBF,EAAgBE,EAAO,GAAfgD,EAAQhD,EAAO,GACzCuF,EAA2CzD,EAAS,MAA7Cb,EAAoCa,EAAS,MAAtC2D,EAA6B3D,EAAS,OAA9BlE,EAAqBkE,EAAS,KAAxBrE,EAAeqE,EAAS,WAC1D,GAAIlE,EAAM,CAQF,IAAI+H,EADR,GANoB,eAAhBF,EAAOjI,MACP,EAAAkE,mBAAmB1B,EAASyF,GAC5B3D,EAAU2D,OAAS,CAACA,IAEpB3D,EAAU2D,OAASG,EAAa5F,EAASyF,IAExChI,GACGkI,EAAe,EAAA/F,SAASC,EAAQjC,EAAK2E,UAC5B,IAA0B3E,EAAK2E,QAC5CoD,EAAa,IAAsBJ,EACnCzD,EAAUlE,KAAO,CACbJ,KAAM,iBACNI,KAAMiC,EAAOgG,WAAWF,IAGhC,OAAO7D,EACT,GAAIb,IACFA,EAAMvI,MAAQ,OACViN,EAAe,EAAA/F,SAASC,EAAQC,IACvB,IAAkBE,EAAQ,IACvC2F,EAAa,MAAwBJ,EAEjC1F,EAAOqE,YACHrE,EAAOoD,gBACP0C,EACA3C,GACA,SAAC7F,GAAe,aAGpB,OAAO,MAInBgC,WAAY,IAAI2G,OAAO,GACvB5G,UAAW,CACP,CACIqG,MAAO,EAAAjJ,IACH,EAAAE,QAAQ,EAAAQ,OAAM,GAAO,EAAAJ,eAAe,kBACpC,EAAAI,OAAM,IAEVwI,UAAW,EAAAxI,OAAM,GACjB6D,GAAI,EAAA7D,MAAM,MACVyI,OAAQ,EAAAnJ,IAAI,gBAAiB,cAC7B2E,MAAO,EAAArE,eAAe,iBACtBgB,KAAM,gBACNH,WAAY,EAAAT,OAAM,IAEtB,CACI,CAAC,QAAS,iBACV,CAAC,OAAQ,EAAAA,UAEb,CAEI,CAAC,QAAS,EAAAJ,eAAe,mBACzB,CAAC,OAAQ,EAAAT,QAAQ,iBACjB,CAAC,aAAc,EAAAa,OAAM,OAIjC,gBAAmB,CACfkC,UAAW,CACP,CACI8F,EAAG,EAAApI,eAAe,iBAClBiE,GAAI,EAAAvE,IAAI,EAAAiF,qDAAsD,EAAAvE,MAAM,OACpE+I,WAAY,EAAAzJ,IACR,EAAAE,QACI,EAAAI,eAAe,mBACf,EAAA2E,sDAEJ,EAAAvE,MAAM,OAEVY,KAAM,EAAAtB,IAAI,iBAAiB1C,OACvB,SAAUoG,EAAkBpC,GACNoC,EAAO,GACfpC,KAAO,CACbJ,KAAM,YACNI,KAAM,EAAAwG,kBAAkB4B,EAAyBhG,EAASpC,GAC1DP,MAAOO,EAAKP,MACZC,IAAKM,EAAKN,WAOlC,yBAA4B,CACxB4B,UAAW,CACP,CACI+G,IAAK,EAAA3E,kDACL4E,MAAO,qBAInB,iBAAoB,CAChB,CACI/G,WAAY,GACZD,UAAW,CACP/F,OAAQ,EAAAmI,kDACRlI,SAAU,EAAAoD,QACN,EAAAI,eAAe,gBACf,EAAAN,IACI,aACA,EAAAA,IAAI,WAAW1C,OACX,SAAUoG,EAAkBiB,GACnB,IAAAa,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GACjC8B,EAAU1I,SAAWyG,EAAOsG,gBAAgBlF,QAK5DmF,SAAU,EAAApJ,OAAM,KAGxB,CACI+B,OAAQ,iBACRI,WAAY,GACZD,UAAW,CACP/F,OAAQ,EAAAmI,kDACRlI,SAAU,EAAAkD,IAAI,iBAAiB1C,OAC3B,SAAUoG,EAAkBiB,GACnB,IAAAa,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GACjC8B,EAAU1I,SAAWyG,EAAO6E,gBAAgB1E,EAASiB,MAG7DmF,SAAU,EAAApJ,OAAM,MAI5B,MAAS,CACLgC,QAAA,SAAQgB,GAC2CA,EAAO,GAAjD,IAAWH,EAA+BG,EAAO,GAA9BF,EAAuBE,EAAO,GAAtBgD,EAAehD,EAAO,GAAhB+B,EAAS/B,EAAO,GAQtD,OAPIA,EAAQ,IACJ+B,IAAUiB,GACVnD,EAAOqB,IAAIpB,EAAOkD,IAGtBnD,EAAOqB,IAAIpB,EAAOkD,IAEfhD,EAAQ,IAEnBd,UAAW,CACP+B,MAAO,EAAArE,eAAe,iBACtBoF,MAAO,EAAAtF,cAAc,wBAG7B,aAAgB,CACZsC,QAAA,SAAQ,G,IAAC8C,EAAS,KAEd,OADAA,EAAUuE,KAAK7I,KAAO,aACfsE,GAEX5C,UAAW,CACP,CACImH,KAAM,iBACNrB,EAAG,EAAApI,eAAe,gBAClBxD,SAAU,mBAEd,CACIiN,KAAM,cACNrB,EAAG,EAAApI,eAAe,gBAClBxD,SAAU,uBAItB,cAAiB,CACb+F,WAAY,IAAI2G,OAAO,IACvB5G,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,eACtBoI,EAAG,EAAA7I,QAAQ,EAAAS,eAAe,oBAAoBhD,OAC1C,SAAUoG,EAAkBiB,GACxBjB,EAAQ,GAAgBkB,IAAID,OAGpCqF,OAAQ,EAAAhF,kDACRjB,UAAW,EAAA/D,IAAI,EAAAU,MAAMnB,OAAQ2I,MAIzC,eAAkB,CACdrF,WAAY,GACZJ,OAAA,SAAOiB,EAAkBgD,GACrB,IAAIlD,EAASE,EAAQ,GACjBuG,EAAczG,EAAOkD,GAAOwD,EAAe1G,EAAOkD,EAAO,GAC7D,OAAIwD,IAAiBxG,EAAQ,QAIJ,qBAArBuG,EAAY/I,MACT+I,aAAuBrJ,GACvB,EAAA6F,UAAU/C,EAASgD,EAAMA,EAAO,UAIvChD,EAAQ,GAAgCwG,KAE5CtH,UAAW,CACPoH,OAAQ,EAAAhF,kDACRjB,UAAWmE,IAInB,iBAAoB,CAChB,CACIxF,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GAEzB,OADA8B,EAAUxC,SAAWwC,EAAUxC,SAAS5G,MACjCoJ,GAEX3C,WAAY,GACZD,UAAW,CACPI,SAAU,mBACVqF,SAAU,EAAArI,IAAI,mBAAoB,EAAA+E,mDAClCoF,OAAQ,EAAAzJ,OAAM,KAGtB,CACIiC,UAAA,SAAUe,GACN,IAAI8B,EAAY9B,EAAQ,GAAgB0G,WAAW1G,GAEnD,OADA8B,EAAUxC,SAAWwC,EAAUxC,SAAS5G,MACjCoJ,GAEX/C,OAAQ,CACJ,SAAUiB,EAAkBgD,EAAcjB,GACtC,OAAO,EAAAgB,UAAU/C,EAASgD,EAAMA,EAAO,IAE3C,EAAAD,WAEJ5D,WAAY,GACZD,UAAW,CACP,CACIyF,SAAU,EAAArI,IAAI,mBAAoB,EAAA+E,mDAClC/B,SAAU,mBACV0F,EAAG,EAAAtI,cAAc,EAAAP,QAAQ,gBAAgBvC,OACrC,SAAUoG,EAAkBiB,GACxBjB,EAAQ,GAAgBkB,IAAID,OAGpCwF,OAAQ,EAAAzJ,OAAM,IAElB,CAAC,IAAK,EAAAN,cAAc,oBAAoB9C,OACpC,SAAUoG,EAAkBiB,GACxBjB,EAAQ,GAAgBkB,IAAID,UAMhD,gBAAmB,CACf,CACI9B,WAAY,GACZJ,OAAA,SAAOiB,GACH,OAAOA,EAAQ,KAEnBd,UAAW,CACP+B,MAAO,EAAArE,eAAe,iBACtB+H,SAAU,EAAArD,oDAGlB,CACItC,QAAA,SAAQ,G,IAAC8C,EAAS,KACd,OADsB,KACRqE,gBAAgBrE,EAAUb,QAE5ClC,OAAA,SAAOiB,GACH,OAAQA,EAAQ,KAEpBd,UAAW,CACP+B,MAAO,mBAInB,gBAAmB,CACfjC,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GAEzB,OADA8B,EAAUxC,SAAWwC,EAAUxC,SAAS5G,MACjCoJ,GAEX3C,WAAY,GACZD,UAAW,CACP,CACII,SAAU,EAAAhD,IAAI,qBAAsB,8BACpCqI,SAAU,EAAArD,kDACVmF,OAAQ,EAAAzJ,OAAM,MAI1B,iBAAoB,CAChBgC,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GAEzB,OADA8B,EAAUxC,SAAWwC,EAAUxC,SAAS5G,MACjCoJ,GAEX7C,UAAA,SAAUe,GACN,OAAOA,EAAQ,GAAiBA,EAAQ,IAAiB,GAE7Db,WAAY,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAC/CD,UAAW,CACP,CACI8D,KAAM,EAAA1B,kDACNhC,SAAU,gBACVyC,MAAO,EAAA5F,QAAQ,EAAAsF,uDAEnB,CAAC,WAAY,oBACb,CAAC,WAAY,kBACb,CAAC,WAAY,wBACb,CAAC,WAAY,EAAAnF,IAAI,uBAAwB,0BACzC,CAAC,WAAY,4BACb,CAAC,WAAY,gBACb,CAAC,WAAY,gBACb,CAAC,WAAY,gBACb,CAAC,WAAY,mBAGrB,kBAAqB,CACjB2C,UAAA,SAAUe,GACN,GAAIA,EAAQ,GAAiBA,EAAQ,IAAkB,EAAG,CACtD,IAAI8B,EAAY9B,EAAQ,GAAgB0G,WAAW1G,GAEnD,OADA8B,EAAUxC,SAAWwC,EAAUxC,SAAS5G,MACjCoJ,IAGf3C,WAAY,CAAC,EAAG,GAChBD,UAAW,CACP,CACI8D,KAAM,EAAA1B,kDACNhC,SAAU,gBACVyC,MAAO,EAAA5F,QAAQ,EAAAmF,oDAEnB,CAAC,WAAY,mBAGrB,sBAAyB,CACrB,CACIrC,UAAA,SAAUe,GACC,IAAAH,EAA+BG,EAAO,GAA9BF,EAAuBE,EAAO,GAAtBgD,EAAehD,EAAO,GAC7C,GADsCA,EAAO,GACjCgD,GAAQ,EAChB,OAAO,EAEX,IAAKhD,EAAQ,KAAyBA,EAAQ,MAA4BF,EAAQ,CAC9E,IAAIK,EAAQH,EAAQG,MAAM,IAAsB,EAAM,GAAwB,MAQ9E,OAPAN,EAAOqE,YACHrE,EAAOoD,gBACPjD,EACAgD,GACA,SAAC7F,GAAe,MAAc,0BAAdA,EAAKK,QAEzBwC,EAAQM,QAAQH,GACT,OAGfhB,WAAY,IAAI2G,OAAO,GACvB5G,UAAW,CACP,CACIyH,KAAM,EAAArF,kDACNL,MAAO,EAAArE,eAAe,iBAE1B,CAAC,aAAc,EAAA6E,sDACf,CAAC,IAAK,EAAA7E,eAAe,iBACrB,CAAC,YAAa,EAAA6E,yDAI1B,gBAAmB,CACf,CACI1C,OAAA,SAAOiB,GACH,OAAOA,EAAQ,KAEnBb,WAAY,EACZD,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,iBACtBoI,EAAG,EAAApI,eAAe,gBAClB+H,SAAU,EAAArD,kDACVsF,SAAU,EAAA5J,OAAM,IAEpB,CACIiE,MAAO,EAAArE,eAAe,iBACtB+H,SAAU,EAAArD,kDACVsF,SAAU,EAAA5J,OAAM,MAI5B,CACIgC,QAAA,SAAQ,G,IAAC8C,EAAS,KACd,OADsB,KACRqE,gBAAgBrE,EAAUb,QAE5ClC,OAAA,SAAOiB,GACH,OAAQA,EAAQ,KAEpBd,UAAW,CACP+B,MAAO,mBAInB,qBAAwB,CACpBhC,UAAW,oBACXE,WAAY,IAAI2G,OAAO,GACvB5G,UAAW,CACP8D,KAAM,EAAA1G,IACF,EAAAA,IAAI,gBAAgB1C,OAChB,SAAUoG,EAAkB6G,GACxB7G,EAAQ,GAAgBkB,IAAI2F,MAGpC,uBACA,mBACA,oBACA,eACA,gBACA,EAAAxF,mDAEJ/B,SAAU,EAAAmD,+BACVV,MAAO,EAAA5F,QAAQ,kBAGvB,mBAAsB,CAClB6C,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GACrB+E,EAA2BjD,EAAUiD,YAKzC,OAJIA,EAAY,aAAc,EAAA9H,MAAM6J,qBAChC/B,EAAY,GAAGA,YAAY/K,KAAK+K,EAAY,IAC5CjD,EAAUiD,YAAcA,EAAY,GAAGA,aAEpCjD,GAEX7C,UAAA,SAAUe,GACK,IAAAgD,EAAehD,EAAO,GACjC,GAD0BA,EAAO,GACrBgD,GAAS,EACjB,OAAO,GAGf7D,WAAY,EACZD,UAAW,CACP6F,YAAa,EAAAvI,QACT,EAAA8E,kDACA,EAAA1E,eAAe,gBACf,EAAAT,QAAQ,EAAAmF,uDAySpB,EAAAgC,cAlSJ,IAAMyD,EAAiC,EAAAzK,IAAI,iBAAiB1C,OACxD,SAAUoG,EAAkBiB,GACnB,IAAAa,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GACjC8B,EAAUsE,UAAW,EACrBtE,EAAU9I,IAAM6G,EAAO6E,gBAAgB1E,EAASiB,EAAO+F,MAIzDC,EAAwB,EAAA3K,IAC1B,EAAAA,IACI,EAAAA,IAAI,aAAc,UAAW,WAAW1C,OACpC,SAAUoG,EAAkBiB,GACpBA,aAAiB/D,GACjB8C,EAAQ,GAAgBkB,IAAID,MAIxC8F,GACFnN,OACE,SAAUoG,GACD,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3BhH,EAAQ8I,EAAS,IACvB,OAAQ9I,EAAIwE,MACR,IAAK,UACDsE,EAAU9I,IAAM6G,EAAOsG,gBAAgBnN,GACvC,MACJ,IAAK,UACGA,EAAIkO,OACJrH,EAAOqB,IAAIlI,QAS7BmO,EAAoB,CACtB,QAAW,CACPnI,QAAS,EAAAqD,aACTlD,WAAY,EACZD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,EAAAM,eAAe,IAAuB,WACnD2F,QAAS,sBAIrB,GAAI,CACAtD,UAAA,SAAUe,GAEN,OADAA,EAAQ,GAAiBA,EAAQ,GAAeA,EAAQ,GACjD,IAEXd,UAAW,CACP8F,EAAG,EAAAtI,cAAc,GAAsB,WACvCuI,GAAI,iBAGZmC,iBAAkB,CACdpI,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GACnBtH,EAAUoJ,EAAS,MAOzB,OANAA,EAAUuF,KAAO3O,EAAM2O,YAChB3O,EAAM2O,KACbvF,EAAUsE,SAAW1N,EAAM0N,gBACpB1N,EAAM0N,SACbtE,EAAU9I,IAAMN,EAAMM,WACfN,EAAMM,IACN8I,GAEX5C,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,GAAsB,WAC3C1D,IAAK,EAAAgE,MAAM,IACXuK,OAAQ,EAAAvK,OAAM,GACdoJ,SAAU,EAAApJ,OAAM,GAChBwK,QAAS,EAAA5K,eAAe,qBACxBlE,MAAO,qBACP2O,KAAM,EAAArK,MAAM,KAEhB,CACI,CAAC,SAAU,EAAAA,OAAM,IACjB,CAAC,UAAW,EAAAA,YAIxByK,mBAAoB,CAChBzI,QAAA,SAAQgB,GACC,IAED0H,EAFC5F,EAAa9B,EAAO,GACrBqH,EAAOvF,EAAUuF,KAOrB,MALoB,iBAATA,IACPvF,EAAUuF,KAAOA,EAAKrP,KACtB0P,EAAiC,QAAnB5F,EAAUuF,KAAiB,EAAI,GAEjD/B,EAA0BtF,EAAS0H,GAC5B5F,GAEX5C,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,GAAsB,WAC3C6K,OAAQ,EAAApL,QAAQ,EAAAO,cAAc,sBAC9B6I,MAAO,EAAAjJ,IACH,EAAAE,QAAQ,EAAAQ,OAAM,GAAO,EAAAJ,eAAe,qBACpC,EAAAI,OAAM,IAEVwI,UAAW,EAAAlJ,IACP,EAAAE,QAAQ,EAAAQ,OAAM,GAAO,EAAAJ,eAAe,iBACpC,EAAAI,OAAM,IAEVqK,KAAM,EAAArK,MAAM,UACZoJ,SAAU,EAAApJ,OAAM,GAChBhE,IAAKiO,EACLpG,GAAI,EAAA7D,MAAM,MACVyI,OAAQ,gBACRhI,WAAY,EAAAT,OAAM,GAClBY,KAAM,iBAEV,CACI,CAAC,YAAa,EAAAZ,OAAM,IACpB,CAAC,OAAQ,0BAMnB2K,EAAY,CACd,QAAW,CACP3I,QAAS,EAAAqD,aAETnD,UAAW,CACPoD,QAAS,EAAAhG,IAAI,EAAAM,eAAe,IAAuB,WACnD2F,QAAS,EAAAjG,IAAI,gBAAiB,EAAAgF,mDAC9B0D,EAAG,EAAApI,eAAe,eAAgB,OAKxCgL,EAAS,CACX,QAAW,CACP5I,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAIjC,OAHI8B,EAAUS,mBAAmBrF,GAC7B2C,EAAOqB,IAAIY,EAAUS,SAElB,EAAAF,aAAarC,IAExBd,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,EAAAM,eAAe,IAAuB,WACnD2F,QAAS,oBACTyC,EAAG,EAAApI,eAAe,eAAgB,KAEtC,CAAC,UAAW,EAAAN,IAAI,cAAc1C,MAAM,EAAA+H,kBACpC,CAAC,UAAW,EAAArF,IAAI,eAAgB,kBAChC,CACI,CAAC,UAAW,eACZ,CAAC,IAAK,EAAAM,eAAe,SAM/BiL,EAAgB,CAClB,QAAW,CACP7I,QAAS,EAAAqD,aACTlD,WAAY,EACZD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,EAAAM,eAAe,IAAuB,WACnD2F,QAAS,EAAAjG,IAAI,gBAAiB,EAAAmF,sDAC9BuD,EAAG,EAAApI,eAAe,eAAgB,KAEtC,CACI,CAAC,UAAW,EAAAI,MAAM,OAClB,CAAC,IAAK,EAAAJ,eAAe,qBAM/BkL,EAAmB,CACrB,QAAW,CACP9I,QAAS,EAAAqD,aACTlD,WAAY,EACZD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,EAAAM,eAAe,IAAuB,WACnD2F,QAAS,cAIrB,SAAY,CACRvD,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GACnBxC,EAAoEsE,EAAS,KAAvE9I,EAA8D8I,EAAS,IAAlEpJ,EAAyDoJ,EAAS,MAA3DuF,EAAkDvF,EAAS,KAArDsE,EAA4CtE,EAAS,SAA3CiG,EAAkCjG,EAAS,OAAnCkG,EAA0BlG,EAAS,UAAxBzE,EAAeyE,EAAS,MAAjBxE,EAAQwE,EAAS,IAC/E4F,OAAc1L,EAClB,QAAQ,GACJ,IAAqB,iBAATqL,EAERK,EAAuB,SADvBL,EAAOA,EAAKrP,MACmB,EAAI,EACvC,KAAK+P,GACDrP,EAAQsH,EAAQ,GAAqB,IAAI,EAAA/C,MAAMwK,oBACzClC,QAAUzD,EAAUyD,MAC1B7M,EAAM8M,YAAc1D,EAAU0D,UAC9B9M,EAAMmI,GAAK,KACXnI,EAAM+M,OAAS3D,EAAU2D,OACzB/M,EAAMkF,KAAOkE,EAAUlE,KACvBlF,EAAM+E,YAAa,EACnB/E,EAAM2E,MAAQA,EACd3E,EAAM4E,IAAMA,EACZ5E,EAAQ4M,EAA0BtF,EAAS0H,GAGnD,MAAO,CAAElK,KAAI,EAAExE,IAAG,EAAEN,MAAOA,GAASM,EAAKqO,KAAI,EAAEjB,SAAQ,EAAE2B,OAAM,EAAEC,UAAS,EAAE3K,MAAK,EAAEC,IAAG,IAE1F4B,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,GAAsB,WAC3C1D,IAAKiO,EACLvO,MAAO,EAAA8D,QAAQ,EAAAI,eAAe,gBAAiB,EAAA6E,sDAC/CO,MAAO,EAAApF,eAAe,EAAAN,IAAI,GAAsB,iBAChD+K,KAAM,EAAArK,MAAM,QACZoJ,SAAU,EAAApJ,OAAM,GAChB+K,OAAQ,EAAA/K,OAAM,GACdgL,UAAW,EAAAhL,OAAM,IAErB,CACI,CAAC,MAAO,cACR,CAAC,QAAS,EAAAA,MAAM,OAChB,CAAC,YAAa,EAAAA,OAAM,KAExB,CACIsK,MAAO,EAAA5K,cAAc,GAAsB,WAC3C6I,MAAO,EAAApJ,QAAQ,oBACfqJ,UAAW,EAAArJ,QAAQ,gBACnBkL,KAAM,EAAArK,MAAM,QACZhE,IAAKiO,EACLxB,OAAQ,gBACR7H,KAAM,gBACNoE,MAAO,EAAApF,eAAe,EAAAN,IAAI,GAAsB,iBAChD8J,SAAU,EAAApJ,OAAM,GAChB+K,OAAQ,EAAA/K,OAAM,GACdgL,UAAW,EAAAhL,OAAM,IAErB,CACI,CAAC,QAAS,EAAAA,OAAM,IAChB,CAAC,YAAa,EAAAA,OAAM,IACpB,CAAC,OAAQ,sBACT,CAAC,SAAU,EAAAA,OAAM,QAO7BgK,EAA0B,EAAA7I,gBAC1B,CAACmF,EAAa,EAAA2E,eACdjM,EACA,CAAC,uBAiCD,EAAAgL,0BA/BJ,IAAIhB,EAA0B,EAAA7H,gBAC1BgJ,EAAmBH,GAEnB7B,EAAsB,EAAAhH,gBAAgB0J,EAAeb,GACrD3B,EAAyB,EAAAlH,gBACzB2J,EACAd,GAGEkB,EAAc,EAAA/J,gBAChByJ,EACAZ,GAEEmB,EAAiB,EAAAhK,gBACnBwJ,EACAX,GAGA/D,EAAkB,EAAA9E,gBAClB,CAAE2I,mBAAoBxD,EAAYwD,oBAChCE,GAGN,IAAK,IAAMoB,KAOP,EAAAnF,kBAPoBK,EAChB8E,IACA,EAAA5F,WAAW4F,GAAa,CAACA,EAAW,iBAa5C,SAAS9C,EAA0BtF,EAAkB0H,GAC5C,IAAA5F,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3BuF,EAAmCzD,EAAS,MAArC0D,EAA4B1D,EAAS,UAA1B2D,EAAiB3D,EAAS,OAAlBlE,EAASkE,EAAS,KAClDA,EAAU2D,OAASG,EAAa5F,EAASyF,EAAOlD,cAC5BvG,IAAhB0L,GAA6B5F,EAAU2D,OAAOjL,SAAWkN,GACzD7H,EAAOqB,IAAIuE,GAEf,IAAIE,EAAe,EAAA/F,SAASC,EAAQjC,EAAK2E,SASzC,OARAoD,EAAa,IAA0B/H,EAAK2E,QAC5CoD,EAAa,IAAkB3F,EAAQ,IACvC2F,EAAa,IAAsBH,EACnCG,EAAa,IAAsBJ,EAC/BC,GAAaD,GACb1F,EAAOqB,IAAIY,GAEfA,EAAUlE,KAAO,CAAEJ,KAAM,iBAAkBI,KAAMiC,EAAOgG,WAAWF,IAC5D7D,EAEX,SAAS2C,EAAgBzE,EAAkBF,GACvC,GAAIA,EAAOtF,OAAQ,CACf,IAAIqF,EAASG,EAAQ,GACjBM,EAAUN,EAAQG,MAAM,EACRL,EAAM,GACCA,GAI3B,OAFAD,EAAOqE,YAAYiE,EAAgBnI,GACnCA,EAAQM,QAAQA,GACT,EAAAyD,gBAAgBlE,EAAQC,GAEnC,MAAO,GAEX,SAAS8F,EAAa5F,EAAkBF,GACpC,GAAIA,EAAOtF,OAAQ,CACf,IAAIqF,EAASG,EAAQ,GACjBM,EAAUN,EAAQG,MAAM,EACRL,EAAM,GACEA,GAK5B,OAHAE,EAAQ,KAAmBA,EAAQC,KAAK,GAAoB,IAC5DJ,EAAOqE,YAAYgE,EAAalI,GAChCA,EAAQM,QAAQA,GACT,EAAAyD,gBAAgBlE,EAAQC,GAEnC,MAAO,GA9CP,EAAA2E,kBADA,EAAAmB,gB,8ECh7BJ,IAAMyC,EAAkB,4rOAClBC,EAAiB,2qRAEvB,2BA+HA,OAzHY,YAAAC,cAAR,SAAsBC,GAClB,OACqD,QAAZ,MAApC1O,KAAK2O,MAAMC,WAAW5O,KAAKmE,SAC4B,QAAZ,MAAxCnE,KAAK2O,MAAMC,WAAW5O,KAAKmE,MAAQ,KAEvCnE,KAAK6O,KAAO7O,KAAK2O,MAAM3O,KAAKmE,OAASnE,KAAK2O,MAAM3O,KAAKmE,MAAQ,GACtDuK,EAAO7B,KAAK7M,KAAK6O,MAAQ,EAAI,GAE7BH,EAAO7B,KAAK7M,KAAK2O,MAAM3O,KAAKmE,QAAU,EAAI,GAGzD,YAAA2K,kBAAA,SAAkBJ,GACd,IAAIvK,EAAQnE,KAAKmE,MAAQ,EAAG4K,EAAO,EACnC,GAA4B,MAAxB/O,KAAK2O,MAAMxK,KAAkB,CAC7B,IAAI6K,EAAK,EACT,GAA0B,MAAtBhP,KAAK2O,MAAMxK,GAAgB,CAC3B,MACK4K,EAAO/O,KAAKiP,SAASjP,KAAK2O,MAAMC,aAAazK,MAAY,GAE1D6K,EAAU,GAALA,EAAUD,EAEnB,GAA4B,MAAxB/O,KAAK2O,MAAMxK,KACX,OAAO,OAIX,IADA,IAAI+K,EAAM,EACHA,KAAO,CAEV,MADAH,EAAO/O,KAAKiP,SAASjP,KAAK2O,MAAMC,WAAWzK,QAC/B,GAGR,OAAO,EAFP6K,EAAU,GAALA,EAAUD,EAM3B,OAAOL,EAAO7B,KAAK7M,KAAKmP,cAAcH,IAChC7K,EAAQnE,KAAKmE,QACXA,EAAQnE,KAAKmE,OAEzB,OAAO,GAEX,YAAAiL,QAAA,SAAQ1O,QAAA,IAAAA,MAAiBV,KAAKsI,KAE1B,IADA,IAAI1J,EAAQ,EAAGmQ,EAAO,EAAGG,EAAMxO,EACxBwO,IACHH,EAAO/O,KAAKiP,SAASjP,KAAK2O,MAAMC,WAAW5O,KAAKmE,UACpC,GACR+K,IACAtQ,EAAgB,GAARA,EAAamQ,EAIzB/O,KAAKmE,QAET,MAAO,CAACvF,EAAO8B,EAASwO,IAE5B,YAAAD,SAAA,SAASI,GACL,OAAOA,GAAM,IAAQA,GAAM,GAAOA,EAAK,GACnCA,GAAM,IAAQA,GAAM,GAAOA,EAAK,GAAO,GACnCA,GAAM,IAAQA,GAAM,IAAOA,EAAK,GAAO,IAAM,GAEzD,YAAAC,aAAA,SAAaD,GACT,OAAOA,GAAM,IAAQA,GAAM,GAAOA,EAAK,IAAQ,GAEnD,YAAAE,WAAA,SAAWF,GACP,OAAOA,GAAM,IAAQA,GAAM,GAAOA,EAAK,IAAQ,GAEnD,YAAAG,YAAA,SAAYH,GACR,OAAc,KAAPA,GAAqB,IAANA,EAAaA,EAAK,IAAQ,GAGpD,YAAAI,aAAA,SAAaJ,GACT,OAAe,KAAPA,GAAwB,IAAPA,GAAwB,KAAPA,GAAwB,KAAPA,GAAwB,MAAPA,GACvEA,GAAM,MAAU,CAAC,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,KAAQ,MAAQ,OAAQrK,QAAQqK,IAAO,GAGzK,YAAAK,iBAAA,SAAiBL,GACb,OAAe,KAAPA,GAAwB,KAAPA,GAAwB,OAAPA,GAA0B,OAAPA,GAGjE,YAAAF,cAAA,SAAcH,GACV,OAAOhP,KAAK6O,KAAOG,EAAK,MAClBW,OAAOC,aAAaZ,GACpBW,OAAOC,aAAuBZ,EAAK,MAAf,OAA2B,IAC/CW,OAAOC,aAAuBZ,EAAK,MAAf,MAA0B,OAExD,YAAAa,kBAAA,WACI,IAAIR,EAAKrP,KAAK2O,MAAMC,WAAW5O,KAAKmE,OACpC,OAAe,KAAPkL,GAAwB,KAAPA,GACpBA,GAAM,IAAQA,GAAM,IACpBA,GAAM,IAAQA,GAAM,IAAQ,EACzBA,GAAM,IACArP,KAAKyO,cAAcF,GACX,KAAPc,EAAcrP,KAAK8O,kBAAkBP,GAAmB,GAI3E,YAAAuB,iBAAA,WACI,IAAIT,EAAKrP,KAAK2O,MAAMC,WAAW5O,KAAKmE,OACpC,OAAe,KAAPkL,GAAwB,KAAPA,GACpBA,GAAM,IAAQA,GAAM,IACpBA,GAAM,IAAQA,GAAM,KACpBA,GAAM,IAAQA,GAAM,GAAQ,EACzBA,GAAM,IACArP,KAAKyO,cAAcD,GACX,KAAPa,EAAcrP,KAAK8O,kBAAkBN,GAAkB,GAI1E,YAAAuB,wBAAA,SAAwB5I,GACpB,QAAOA,GAAQ,CACX,KAAM,SAAU,aAAc,MAC9B,SAAU,OAAQ,SAAU,QAAS,OAErC,IAAK,KAAM,KAAM,KAAM,MAAO,KAAM,KAAM,MAAO,MAAO,OACxD,KAAM,KAAM,KAAM,IAElB,IAAK,IAAK,IAAK,KAAM,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,MAAO,IAC9D,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,IAAK,IAAK,MAAO,KAAM,KACvD,KAAM,IAAK,IAAK,KAAM,OACxBnC,QAAQmC,EAAMvI,QAAU,GAElC,EA/HA,G,2aCFA,WAYA,cACI,WAAYoR,GAAZ,MACI,cAAO,KACP,IAAK,IAAM9Q,KAIR,EAAA+Q,YAAc,EAAAC,YACd,EAAAC,YAAuD,GAGvD,EAAAC,eAAyB,EARVJ,EACd,EAAK9Q,GAAO8Q,EAAQ9Q,G,SA6UhC,OAjV6B,OAczB,YAAAkI,IAAA,W,IAAI,sDAEApH,KAAKqQ,WAAWnQ,KAAK8B,MAAMhC,KAAKqQ,WAAY9J,YAEhD,YAAA+J,SAAA,SAAS3B,GAOL,OANA3O,KAAKuQ,YAAc,EACnBvQ,KAAKwQ,WAAa,EAClBxQ,KAAKmE,MAAQ,EACbnE,KAAK2O,MAAQA,EACb3O,KAAKsI,IAAMtI,KAAK2O,MAAMjO,OACtBV,KAAKqQ,WAAa,GACXrQ,KAAKyQ,KAAK,MAAM,IAE3B,YAAAC,SAAA,SACIhN,EACAH,EACA3E,EACAwJ,EAIAE,GAKA,YAVA,IAAA1J,MAAaoB,KAAK2O,MAAMhO,MAAM4C,EAAM,GAAIA,EAAM,UAC9C,IAAA6E,MAAA,CACIC,KAAMrI,KAAKuQ,YACXI,OAAQpN,EAAM,GAAKvD,KAAKwQ,kBAE5B,IAAAlI,MAAA,CACID,KAAMrI,KAAKuQ,YACXI,OAAQpN,EAAM,GAAKvD,KAAKwQ,aAGrB,CACH9M,KAAMA,EACN9E,MAAK,EACL2E,MAAK,EACLC,IAAK,CACD4E,MAAK,EAAEE,IAAG,KAKd,YAAAsI,MAAR,SAAcvN,GACV,IACIwN,EADAzI,EAAQpI,KAAKmE,MAAOmE,EAAMtI,KAAKmE,MAEnC,GAEId,GADAwN,EAAYxN,GACKrD,KAAK2O,MAAMrG,YACvBjF,GACT,GAAIwN,EAAU1F,GAAI,CACd,IAAI2F,EAASD,EAAU1F,GAEvB,GADAnL,KAAKmE,MAAQmE,EAAM,EACfwI,EAAOC,QACP,OAAOD,EAAOC,QAAQ/Q,MAEtB,IAAImH,EAAQnH,KAAK0Q,SACb1Q,KAAKiQ,YAAYa,EAAOpN,MACxB,CAAC0E,EAAOE,EAAM,GACdwI,EAAOlS,OAEPoS,EAAQF,EAAOzP,KAAK,GAaxB,OAZI2P,IACA7J,EAAMsB,QAAUzI,KAAKyQ,KAAKtJ,GACtBnH,KAAK2O,MAAMhO,MAAMX,KAAKmE,MAAOnE,KAAKmE,MAAQ6M,EAAMtQ,UAAYsQ,EAC5DhR,KAAKmE,OAAS6M,EAAMtQ,QAEpBV,KAAKoH,IAAID,GACTA,EAAM8J,MAAQ,SAElB9J,EAAM5D,MAAM,GAAKvD,KAAKmE,MACtBgD,EAAM3D,IAAI8E,IAAID,KAAOrI,KAAKuQ,YAC1BpJ,EAAM3D,IAAI8E,IAAIqI,OAAS3Q,KAAKmE,MAAQnE,KAAKwQ,YAEtCrJ,IAIX,YAAA+J,eAAR,SAAuBlL,GACnB,IACImB,EADAzG,EAASV,KAAK6P,oBAElB,GAAInP,EAAS,EAAG,CACZ,IAAI0H,EAAQpI,KAAKmE,MACbgN,EAAM,GACV,GACIA,GAAkB,IAAXzQ,EAAeV,KAAK2O,MAAM3O,KAAKmE,OAASnE,KAAK6O,KACpD7O,KAAKmE,OAASzD,EACdA,EAASV,KAAK8P,yBACTpP,EAAS,GAClB,IAAIgD,EAAO,EAAA0N,eAAe,IAAMD,GAChChK,EAAQnH,KAAK0Q,SACT1Q,KAAKiQ,YAAYvM,GAAQ,cACzB,CAAC0E,EAAOpI,KAAKmE,QAEjBnE,KAAK6O,KAAOsC,EACRzN,GAAQyN,EAAIzQ,SAAWV,KAAKmE,MAAQiE,GACpCpI,KAAKoH,IAAID,GAMjB,OAHIzG,EAAS,GACTV,KAAKoH,IAAIpH,KAAK0Q,SAAS,QAAS,CAAC1Q,KAAKmE,MAAOnE,KAAKmE,OAASzD,KAExDyG,GAEH,YAAAkK,WAAR,SAAmBrL,GACf,IAAIsL,EAAatL,EAAOA,EAAOtF,OAAS,GACpC6J,EAAa,EAAAgH,8BACjB,GAAID,EACA,GAAIA,EAAW5N,OAAS1D,KAAKiQ,YAAYuB,WAErC,OAAQF,EAAW1S,OACf,IAAK,KACD2L,EAAa,EAAAkH,iBACb,MACJ,IAAK,KACD,IAAIC,EAAgB1L,EAAOA,EAAOtF,OAAS,KAEtCgR,GACE,CAAC,KAAM,QAAS,MAAO,QAAQ1M,QAAQ0M,EAAc9S,OAAS,KAEjE2L,EAAa,EAAAkH,kBAEjB,MACJ,IAAK,KAED,IADA,IAAI,EAASzL,EAAOtF,OAEF,OACV,CACI,CAAC,EAAG,YACJ,CACI,EACA,QACA,WACI,OAAOsF,EAAO,EAAS,GAAGxC,IAAI4E,MAAMC,OAC5BrC,EAAO,EAAS,GAAGxC,IAAI8E,IAAID,QAI/C,CACI,CAAC,EAAG,YACJ,CACI,EACA,QACA,WACI,OAAOrC,EAAO,EAAS,GAAGxC,IAAI4E,MAAMC,OAC5BrC,EAAO,EAAS,GAAGxC,IAAI8E,IAAID,QAI/C,CAAC,CAAC,EAAG,UACL,CAAC,CAAC,EAAG,UACL,CAAC,CAAC,EAAG,WAzBK,eA2BhB,CAGE,IA9BA,IA4BIlE,OAAK,EACLwN,OAAY,EACE,MA9BR,KA8BQ,eAAQ,CAArB,IAAIC,EAAK,KAEV,KADAD,EAAe3L,EAAO,EAAS4L,EAAM,MAG9BD,EAAa/S,QAAUgT,EAAM,IAC3BA,EAAM,KAAMA,EAAM,KAIvB,MAFAzN,EAAQyN,EAAM,GAKtB,QAAc1P,IAAViC,EAAqB,EAEjBnE,KAAK6R,cACF,CAAC,KAAM,KAAM,OAAO7M,QAAQhF,KAAK6R,aAAajT,QAAU,GACxDoB,KAAK+P,wBAAwB/J,EAAO,EAAS7B,EAAQ,OAExDoG,EAAa,EAAAkH,kBAEjB,aAOhBH,EAAW5N,OAAS1D,KAAKiQ,YAAY6B,UAErCvH,EAAa,EAAAkH,kBAGrB,OAAOzR,KAAK4Q,MAAMrG,IAEd,YAAAwH,eAAR,SAAuB/L,GACnB,MAAkC,MAA3BhG,KAAK2O,MAAM3O,KAAKmE,OACjBnE,KAAK4Q,MAAM,EAAAa,kBACXzR,KAAKqR,WAAWrL,IAGlB,YAAAgM,YAAR,SAAoBhM,GAApB,IAGQiM,EAHR,OACQ7J,EAAQpI,KAAKmE,MACbkL,EAAKrP,KAAK2O,MAAMC,WAAW5O,KAAKmE,OAEhC+N,EAAQ,EACRC,EAAa,WAEb,OADA,EAAKtD,KAAe,EAARqD,GAAsC,EAARA,EAAiCA,EACpE,EAAKxB,SAAS,EAAKT,YAAYmC,QAAS,CAAChK,EAAO,EAAKjE,SAE5DkO,EAAa,SAACC,QAAA,IAAAA,MAAA,+BACd,IAAIrB,EAAQkB,IAIZ,OAHAlB,EAAMA,MAAQqB,EACdrB,EAAMtC,MAAQ,EAAKA,MAAMhO,MAAMyH,EAAO,EAAKjE,MAAQ,GACnD,EAAKiD,IAAI6J,GACFA,GAEP3B,EAAetP,KAAKsP,aACxB,OAAQD,GACJ,KAAK,GACD,GAAIC,EAAatP,KAAK2O,MAAMC,WAAW5O,KAAKmE,MAAQ,KAAO,EAAG,CAC1DnE,KAAKmE,OAAS,EACd+N,GAAS,GACT,MAEA,OAER,KAAK,GAED,KADAA,EAAQ,EAAAK,oBAAoBvS,KAAK2O,QAAQ3O,KAAKmE,SAClC,CAER,MADA8N,EAAS3C,EAAatP,KAAK2O,MAAMC,WAAW5O,KAAKmE,UACnC,GAGP,OAAKnE,KAAK6P,oBAINwC,KAHPH,EAAQ,EACDC,KAJPD,EAAQ,EACRD,EAAS,IAAMC,GAAS,GAQhC,MACJ,QACI,GAAI5C,EAAaD,GAAM,EACnB,OAGZ,GAAY,EAAR6C,EAA8B,CAC9B,KAAQ7C,EAAKrP,KAAK2O,MAAMC,aAAa5O,KAAKmE,QAEtC,IADA8N,EAAS3C,EAAaD,KACR,EACV4C,EAAS,IAAMC,IAAS,QAG5B,OAAQ7C,GACJ,KAAK,IACL,KAAK,GACD,GAAc,GAAR6C,EAQF,OAAOG,IAPPH,GAAS,GAEE,MADX7C,EAAKrP,KAAK2O,MAAMC,WAAW5O,KAAKmE,MAAQ,KACd,KAAPkL,IACfrP,KAAKmE,OAAS,GAElB,SAIR,KAAK,GACD,KAAc,GAAR+N,GAAqE,CACvEA,GAAS,GACT,SAER,QACI,OAAOlS,KAAK6P,oBACNwC,IACAF,IAGlB,OAAOA,IAQP,IANA,IAAItF,EAAe,EAARqF,EACLlS,KAAKiP,SACK,EAARiD,EACMlS,KAAKwP,YACLxP,KAAKuP,WAEZ1C,EAAK7M,KAAK2O,MAAMC,aAAa5O,KAAKmE,SAAW,IACpD,OAAOnE,KAAKmE,MAAQiE,EAAQ,IAAMpI,KAAK6P,oBACjCsC,IACAE,KAGN,YAAAG,UAAR,SAAkBxM,GACd,IAAK,IAAIgJ,OAAE,EAAUhP,KAAKmE,MAAQnE,KAAKsI,IAAKtI,KAAKmE,QAE7C,OADA6K,EAAKhP,KAAK2O,MAAMC,WAAW5O,KAAKmE,QACxB,GACJ,KAAKnE,KAAKyP,aAAaT,GACnB,MACJ,KAAKhP,KAAK0P,iBAAiBV,GACvBhP,KAAKuQ,cACLvQ,KAAKwQ,WAAaxQ,KAAKmE,MAAQ,EAC/B,MACJ,QACI,OAAOnE,KAAKkR,eAAelL,IACvBhG,KAAKgS,YAAYhM,IACjBhG,KAAK+R,eAAe/L,KAIxC,YAAAyK,KAAA,SAAKoB,EAAqBY,QAAA,IAAAA,OAAA,GACtB,IAAIC,EAAmB1S,KAAK6R,aAC5B7R,KAAK6R,aAAeA,EAIpB,IAHA,IACIc,EACAxL,EAFAsB,EAAU,GAGPzI,KAAKmE,MAAQnE,KAAKsI,KAErB,GADAnB,EAAQnH,KAAKwS,UAAU/J,IAEnBkK,EAAa3S,KAAKmQ,YAAYhJ,EAAMzD,SACrByD,EAAQwL,EAAWxL,EAAOnH,QACrCmH,EAAMzD,OAAS1D,KAAKiQ,YAAY2C,UAGhC5S,KAAKoQ,gBAFL3H,EAAQvI,KAAKiH,OAId,KAAKsL,EACR,MACOzS,KAAKmE,MAAQnE,KAAKsI,KAEzBtI,KAAKoH,IAAIpH,KAAK0Q,SAAS,QAAS,CAAC1Q,KAAKmE,QAASnE,KAAKmE,SAI5D,OADAnE,KAAK6R,aAAea,EACbjK,GAEf,EAjVA,CANA,KAM6B,S,kbCT7B,WA0XoB,EAAAyH,YAxX+B,CAC/C2C,WAAY,aACZf,QAAS,UACTnC,OAAQ,SACRmD,QAAS,UACTV,QAAS,UACTZ,WAAY,aACZuB,kBAAmB,oBACnBC,SAAU,WACVC,gBAAiB,kBACjBL,SAAU,WACVM,KAAM,QA4WN,EAAAX,oBAxWwB,CACxB,IAAK,GACL,EAAK,EACL,EAAK,EACL,EAAK,EAEL,EAAK,EACL,EAAK,EACL,EAAK,GAGT,IAgCMnB,EAhCe,CACjB,CACI,UACA,CACI,OACA,SACA,MACA,QAAS,UACT,WACA,QACA,OACA,QACA,KAAM,aAAc,SACpB,OAAQ,QACR,MAAO,QACP,QAAS,WAAY,SACrB,KAAM,OACN,SAAU,OAAQ,UAClB,MAAO,QAAS,UAChB,KAAM,QAAS,MACf,QACA,SAAU,SACV,WAEA,SAGR,CAAC,aAAc,CAAC,MAAO,UACvB,CAAC,UAAW,CAAC,OAAQ,UACrB,CAAC,OAAQ,CAAC,UAGwB+B,QAClC,SAACvS,EAAK,GACF,I,IADG8C,EAAI,KACQ,MADA,KACA,eAAQ,CACnB9C,EAAI,IADG,MACS8C,EAEpB,OAAO9C,IACR,IAwTH,EAAAwQ,iBArTJ,IAAIgC,EAAe,CACfC,OAAQ,EACRC,QAAA,SAAQC,EAAsBC,GAC1B,IAAIzE,EAAOwE,EAAUhE,WAAWgE,EAAU5E,MAAMC,WAAW2E,EAAUpP,MAAQ,IACzEvF,EAAQ,EACZmQ,IAASyE,EAAM1I,OAAQ,GAEvB,IADA,IAAIoE,EAAMH,GAAQ,EAAI,EAAI,EAEtBnQ,EAAgB,EAARA,EAAYmQ,KACpBA,EAAOwE,EAAUhE,WAAWgE,EAAU5E,MAAMC,WAAW2E,EAAUpP,SACtD,KAAO+K,EAAM,IAGxBsE,EAAM1I,OAAQ,EACdyI,EAAUpP,OAAS,EAEvB,OAAOwL,OAAOC,aAAahR,KAG/B6U,EAAoB,CACpB,MAAOL,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,GAGPM,EAAqB,CACrB,OAAQ,CAAEC,KAAM,IAChB,MAAO,CAAEA,KAAM,MACf,MAAO,CAAEA,KAAM,MACf,MAAO,CAAEA,KAAM,MACf,MAAO,CAAEA,KAAM,MACf,MAAO,CAAEA,KAAM,MACf,MAAO,CAAEA,KAAM,MACf,MAAO,CACHN,OAAQ,EACRC,QAAA,SAAQC,GACJ,GAAyC,MAArCA,EAAU5E,MAAM4E,EAAUpP,OAAgB,CAC1CoP,EAAUpP,QACL,IAAA4K,EAAQwE,EAAUnE,UAAS,GAChC,GAAyC,MAArCmE,EAAU5E,MAAM4E,EAAUpP,SAC1BoP,EAAUpP,QACN4K,GAAQ,SACR,OAAOY,OAAOC,aAAab,OAGhC,CACC,MAAcwE,EAAUnE,QAAQ,GAA/BL,EAAI,KACT,GAAY,IADE,KAEV,OAAOY,OAAOC,aAAab,GAGnC,OAAO,IAGf,MAAO,CACHsE,OAAQ,EACRC,QAAA,SAAQC,GACA,MAAcA,EAAUnE,QAAQ,GAA/BL,EAAI,KACT,OAAY,IADE,MAEHY,OAAOC,aAAab,MAOvC6E,EAAyB,CACzBP,QAAM,EACNQ,SAAU,8DAGRC,EAAc,CAChB,CACIzS,KAAM,CAAC,IAAK,KAAMqC,KAAM,SACxB6G,WAAY,EAAF,GACN,IAAK,CACD8I,OAAQ,GAEZ,KAAM,CACFA,QAAM,EACNQ,SAAU,KAEXH,GACAD,GAGPM,YAAW,cACXhD,QAAA,SAAQwC,GACJ,OAAOvT,KAAK+T,YAAYR,EAAW,MAG3C,CACIlS,KAAM,CAAC,IAAK,KAAMqC,KAAM,SACxB6G,WAAY,EAAF,GACN,IAAK,CACD8I,OAAQ,GAEZ,KAAM,CACFA,QAAM,EACNQ,SAAU,KAEXH,GACAD,GAGPM,YAAW,cACXhD,QAAA,SAAQwC,GACJ,OAAOvT,KAAK+T,YAAYR,EAAW,MAG3C,CACIlS,KAAM,CAAC,IAAK,KAAMqC,KAAM,WACxBsQ,sBAAA,SACIT,EACAC,EACAjQ,EACA0Q,QAAA,IAAAA,OAAA,GAEA,IAAI9M,EAAQoM,EAAU7C,SAClB,kBACAnN,EACA,CACIwH,IAAKwI,EAAU5E,MAAMhO,MAAM4C,EAAM,GAAIA,EAAM,IAC3C2Q,OAAQX,EAAU1E,MAEtB,CACIxG,KAAMmL,EAAMW,UACZxD,OAAQ6C,EAAMY,cAGtBjN,EAAM8M,KAAOA,EACbT,EAAM/K,QAAQvI,KAAKiH,IAEvBoD,WAAY,EAAF,CACN,MAAO,CAAEoJ,KAAM,MACf,MAAOC,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,MAAOA,EACP,IAAK,CACDP,OAAQ,EACRnL,MAAA,SAAMqL,EAAsBC,EAA4BpL,EAAe6I,GACnEjR,KAAKgU,sBAAsBT,EAAWC,EAAO,CAACpL,EAAOmL,EAAUpP,QAAQ,GACvE,IAAIgD,EAAQoM,EAAU7C,SAClB1Q,KAAK0D,KACL,CAAC8P,EAAMpL,MAAOmL,EAAUpP,OACxBnE,KAAKpB,MACL,CACIyJ,KAAMmL,EAAMa,WACZ1D,OAAQ6C,EAAMc,eAItB,OADAnN,EAAMsB,QAAU+K,EAAM/K,QACftB,IAGf,EAAK,CACD,IAAK,CACDkM,OAAQ,EACRnL,MAAA,SAAMqL,EAAsBC,EAA4BpL,EAAe6I,GAC/D7I,EAAQmL,EAAUpP,MAAQ,GAC1BnE,KAAKgU,sBAAsBT,EAAWC,EAAO,CAACpL,EAAOmL,EAAUpP,MAAQ,IAE3EiE,EAAQmL,EAAUpP,MAAQ,EAC1B,IAAIgD,EAAQoM,EAAU7C,SAClB6C,EAAUtD,YAAYuB,WACtB,CAACpJ,EAAOmL,EAAUpP,OAClB,MACA,CACIkE,KAAMkL,EAAUhD,YAChBI,OAAQvI,EAAQmL,EAAU/C,aAG9B/H,EAAU8K,EAAU9C,KAAKtJ,GAC7B,GAAyC,MAArCoM,EAAU5E,MAAM4E,EAAUpP,OAS1B,OARAoP,EAAUpP,OAAS,EACnBqP,EAAMW,UAAYZ,EAAUhD,YAC5BiD,EAAMe,YAAchB,EAAUpP,MAAQoP,EAAU/C,WAChDrJ,EAAM5D,MAAM,GAAKgQ,EAAUpP,MAC3BgD,EAAM3D,IAAI8E,IAAID,KAAOmL,EAAMW,UAC3BhN,EAAM3D,IAAI8E,IAAIqI,OAAS6C,EAAMe,YAC7BpN,EAAMsB,QAAUA,EAChB+K,EAAM/K,QAAQvI,KAAKiH,GACZnH,KAAK+T,YAAYR,EAAWC,EAAOD,EAAUpP,WAKjEuP,GAEPK,YAAW,cACXhD,QAAA,SAAQwC,GACJ,IAAInL,EAAQmL,EAAUpP,MAAQ,EAC1BkQ,EAAad,EAAUhD,YACvB+D,EAAelM,EAAQmL,EAAU/C,WACrC,OAAOxQ,KAAK+T,YACRR,EACA,CACI9K,QAAS,GACTL,MAAK,EACLiM,WAAU,EACVC,aAAY,EACZH,UAAWE,EACXE,YAAaD,MAK7B,CAAEjT,KAAM,CAAC,KAAM,MAAOqC,KAAM,WAAYqN,QAAS,EAAAyD,aACjD,CAAEnT,KAAM,CAAC,KAAM,MAAOqC,KAAM,WAAYqN,QAAS,EAAAyD,aAEjD,CAAC,IAAK,KAAM,CAAC,IAAK,KAAM,CAAC,IAAK,KAC9B,IAAK,IAAK,KACV,KAAM,KAAM,IAAK,IACjB,KAAM,IAAK,IAAK,IAChB,IAAK,IACL,KAAM,KAAM,MACZ,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,MAAO,MACzC,IACA,IACA,IACA,KACA,KACA,IAAK,IACL,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,MAAO,OAAQ,KAAM,KAAM,KAC5E,MACA,IACA,MAGEC,EAAoB,CACtBpT,KAAM,CAAC,IAAK,KAAMqC,KAAM,oBACxB6G,WAAY,CACR,IAAK,CACD8I,OAAQ,EACRqB,KAAA,SAAKnB,EAAsBC,GACvB,OAAQA,EAAMmB,eAGtB,IAAK,CACDtB,OAAQ,EACRC,QAAA,SAAQC,EAAsBC,GAC1BA,EAAMmB,cAAe,IAG7B,IAAK,CACDtB,OAAQ,EACRC,QAAA,SAAQC,EAAsBC,GAC1BA,EAAMmB,cAAe,IAG7B,KAAM,CACFtB,QAAM,GAEV,OAAQ,CACJA,QAAM,GAEV,IAAO,CACHA,OAAQ,EACRuB,OAAQ,gCAGhBhQ,UAAU,EACVmP,YAAW,cACXhD,QAAA,SAAQwC,EAAsBjC,GAC1B,IACInK,EAAQnH,KAAK+T,YAAYR,EADI,IAEjC,GAAIpM,EAAO,CACPA,EAAMiG,MAAQ,CACVyH,QAAS1N,EAAMvI,MAAM+B,MACjB,EAA2C,MAAxCwG,EAAMvI,MAAMuI,EAAMvI,MAAM8B,OAAS,QAAawB,GAAa,GAElEgQ,MAAO,IAEX,IAAI9J,EAAQmL,EAAUpP,MAClB,EAAS,EACb,GACIoP,EAAUpP,OAAS,EACnB,EAASoP,EAAUzD,yBACd,GAOT,OANI1H,IAAUmL,EAAUpP,QACpBgD,EAAMiG,MAAM8E,MAAQqB,EAAU5E,MAAMhO,MAAMyH,EAAOmL,EAAUpP,OAC3DgD,EAAMvI,OAASuI,EAAMiG,MAAM8E,MAC3B/K,EAAM5D,MAAM,IAAMgQ,EAAUpP,MAAQiE,EACpCjB,EAAM3D,IAAI8E,IAAIqI,QAAU4C,EAAUpP,MAAQiE,GAEvCjB,KAIbsK,EAAmB,EAAAqD,iBAAiBhB,GAStC,EAAArC,mBARJ,IAAMF,EAAgC,EAAAuD,iBAClC,CAACL,GACD,EAAAK,iBAAiBhB,EAAa,CAAC,QAK/B,EAAAvC,iC,oIC5MA,EAAAuD,iBAzKJ,SACI5Q,EACA9C,EACAkD,QADA,IAAAlD,MAAA,SACA,IAAAkD,MAAA,IAEA,IAAiB,UAAAJ,EAAA,eAAa,CAAzB,IAAIM,EAAI,KACLnB,EAAOjC,EACX,QAAQ,GACJ,IAAqB,iBAAToD,EACRA,EAAO,CAACA,GACZ,KAAKA,aAAgBzC,MACjByC,EAAO,CACHd,KAAM,aACNrC,KAAMmD,EACN5F,MAAO4F,EAAKuQ,KAAK,KAErB,MACJ,aACkB7S,IAAdsC,EAAKd,OAAuBc,EAAKd,KAAO,mBACzBxB,IAAfsC,EAAK5F,QAAwB4F,EAAK5F,MAAQ4F,EAAKnD,KAAK0T,KAAK,KAGjE,KAAKzQ,EAAWU,QAAQR,EAAKnD,KAAK,IAAlC,CAGA,IAAmB,UAAAmD,EAAKnD,KAAK,GAAV,eAAc,CAA5B,IAAM2T,EAAI,KACX3R,EAAOA,EAAK2R,KAAU3R,EAAK2R,GAAQ,IAEnC3R,EAAK8H,KAAO3G,EAAKI,UACjBgB,QAAQC,KAAK,YAAaxC,EAAMA,EAAK8H,GAAI3G,GAE7CnB,EAAK8H,GAAK3G,GAEd,OAAOpD,GAwIW,EAAA2S,YArItB,SACIR,EACAC,EACApL,GAHJ,IAKQ6I,EALR,YAGI,IAAA7I,MAAgBmL,EAAUpP,MAAQnE,KAAKqB,KAAK,GAAGX,QAoD/C,IAjDA,IAAI6P,EAAcgD,EAAUhD,YACxBC,EAAa+C,EAAU/C,WACvBW,EAAM,GACN/P,EAAOpB,KAAKuK,WACZlH,EAAOjC,EACP8G,EAAQ,WACR,IAAIf,EACA+C,EACJ,OAAQ7G,EAAKgQ,QACT,KAAK,EACD,IAAKhQ,EAAKqR,OAAyE,KAAhExK,EAAM7G,EAAKqR,KAAK5W,KAAK,EAAMyV,EAAWC,EAAOpL,EAAO6I,IAYnE,OAXA9J,EAAQoM,EAAU7C,SACd,EAAKhN,KACL,CAAC0E,EAAOmL,EAAUpP,YAClBjC,EAAW,CAAEmG,KAAMkI,EAAaI,OAAQvI,EAAQoI,IAEpD+C,EAAU0B,OAASzB,EACnBD,EAAU1E,KAAOsC,GACb9N,EAAKuR,QAAU3D,KACf9J,EAAM8J,MAAS5N,EAAKuR,QAAU3D,EAC9BsC,EAAUnM,IAAID,IAEXA,EACe,iBAAR+C,IACdiH,GAAOjH,GAEX,MACJ,KAAK,EAED,IAAY,KADZA,EAAM7G,EAAKiQ,QAAQxV,KAAK,EAAMyV,EAAWC,EAAOpL,EAAO6I,IACpC,CACf/G,IAAQiH,GAAOjH,GACf,MAER,OACI+G,EAAQ5N,EAAKwQ,UAAY,8BAC7B,KAAK,EACD,GAAIxQ,EAAK6E,MAEL,OADAqL,EAAU1E,KAAOsC,EACV9N,EAAK6E,MAAMpK,KAAK,EAAMyV,EAAWC,EAAOpL,EAAO6I,GAE1D,MACJ,QACI,QAAkB/O,IAAdmB,EAAKsQ,KACL,OAEJxC,GAAO9N,EAAKsQ,KAEpBtQ,EAAOjC,GAGH8T,EAAO3B,EAAU5E,MAAM4E,EAAUpP,SACrCgR,EAAkB,EAClBhO,OAAK,EACL+N,EACAA,EAAO3B,EAAU5E,MAAM4E,EAAUpP,SACnC,CACE,IAAIiR,EAAaD,EAAkB,EAmBnC,GAlBa,OAATD,GACAC,GAAmB,EACnBC,IAAe/R,EAAOA,EAAK,SAE3B8R,EAAkB,EACd5B,EAAU7D,iBAAiBwF,EAAKtG,WAAW,KAC3C2E,EAAUhD,aAAe,EACzBgD,EAAU/C,WAAa+C,EAAUpP,MACjCd,EAAOA,EACH+R,EACM,OACA,OAGV/R,EAAOA,EAAM+R,EAAoB,KAAOF,EAAdA,IAI7B7R,GAGE,GAAK8D,EAAQe,IAChB,OAAOf,OAHPgK,GAAO+D,EACP7R,EAAOjC,EAKf,GAAIA,EAAKiU,IAEL,OADAhS,EAAOjC,EAAKiU,IACLnN,KA2CoB,EAAAsM,YAxCnC,SAAqBjB,GAMjB,IALA,IAAInL,EAAQmL,EAAUpP,MAAQnE,KAAKqB,KAAK,GAAGX,OACvCsQ,EAAQhR,KAAKqB,KAAK,GAClBgT,EAAad,EAAUhD,YACvB+D,EAAelM,EAAQmL,EAAU/C,WACjC8E,EAAgB,EAEZJ,EAAO3B,EAAU5E,MAAM4E,EAAUpP,SACrC+Q,EACAA,EAAO3B,EAAU5E,MAAM4E,EAAUpP,SACnC,CACE,GAAIoP,EAAU7D,iBAAiBwF,EAAKtG,WAAW,IAAK,CAChD,GAAc,OAAVoC,EAAgB,CAChBuC,EAAUpP,OAAS,EACnB,MAEJoP,EAAUhD,aAAe,EACzBgD,EAAU/C,WAAa+C,EAAUpP,WAC9B,GAAI+Q,IAASlE,EAAMsE,GAAgB,CACtC,GAAItE,EAAMtQ,SAAW4U,EACjB,SAEA,MAGRA,EAAgB,EAEpB,IAAInO,EAAQoM,EAAU7C,SAClB1Q,KAAK0D,KACL,CAAC0E,EAAOmL,EAAUpP,YAClBjC,EACA,CAAEmG,KAAMgM,EAAY1D,OAAQ2D,IAMhC,OAJIgB,IAAkBtE,EAAMtQ,QAAoB,OAAVsQ,GAA4B,QAAVA,IACpD7J,EAAM8J,MAAQ,8BACdsC,EAAUnM,IAAID,IAEXA,I,8ECxKX,WAOA,OAEI/D,EAAW,EAAAD,MAAMC,SAGrB,SAASmS,EAAwBrP,EAAkBa,EAAUyO,EAAYjS,EAAyBC,GAK5F,GAJEuD,aAAc3D,EACd8C,EAAQ,GAAgBkB,IAAIL,GACrBb,EAAQ,MACfsP,GAAQ,EAAA3N,gBAAgB3B,EAASa,IACnB,QAAZA,EAAG7I,KAAgB,CACrB,IAAIqP,EAAOrH,EAAQ,GAAgBA,EAAQ,GAAiB,GACzC,QAAfqH,EAAK3O,OAAkC,UAAf2O,EAAK3O,OAC7BsH,EAAQ,GAAgBkB,IAAIL,GAGpC,MAAO,CACHrD,KAAM,qBACNqD,GAAE,EAAEyO,KAAI,EAAEjS,MAAK,EAAEC,IAAG,GAI5B,IAgDIiS,EAhDAC,EAAsB,CACtBC,QAAS,CACLzQ,QAAS,CACL,EAAAqD,aACA,SAAUrC,GACD,IAAA8B,EAAa9B,EAAO,GAGzB,OAFA,EAAA6B,uBAAuB7B,GACvB8B,EAAUS,QAAU,EAAAF,aAAarC,GAASuC,QACnCT,IAGf3C,WAAY,CAAC,IAAK,GAClBD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,UAAW,IACxBiG,QAAS,EAAAjG,IACL,EAAAA,IAAI,cAAc1C,OACd,SAAUoG,EAAkB0P,GACxB1P,EAAQ,GAAmBuC,QAAU8M,EACjCrP,EACA0P,EACA,KACAA,EAAWrS,MACXqS,EAAWpS,QAIvB,EAAAhB,IAAI,qBAAqB1C,OACrB,SAAUoG,EAAkB2O,GACxB3O,EAAQ,GAAmBuC,QAAU8M,EACjCrP,EACA2O,EAAQ3L,KACR2L,EAAQ5M,MACR4M,EAAQtR,MACRsR,EAAQrR,SAKxB0E,MAAO,EAAApF,eAAe,iBAE1B,CACI,CAAC,OAAQ,EAAAI,MAAM,wBACf,CAAC,QAAS,EAAAb,QAAQ,qBAWlC,SAASwT,EAAuC3P,EAAkB6G,GACzD,IAAA/E,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GASjC,IAAK,IAAIhH,KART6N,EAAKrJ,KAAOsE,EAAUtE,KAClBqJ,EAAKhG,GACD,EAAAE,iBAAiB8F,EAAKhG,GAAG7I,OACzB6H,EAAOqB,IAAI2F,EAAKhG,IAGpBhB,EAAOqB,IAAI2F,GAECA,EACZ/E,EAAU9I,GAAO6N,EAAK7N,GAf9B,EAAA0J,WAAW1I,MAAK,WACZuV,EAA2B,EAAApR,gBAAgBqR,EAAqB,EAAAxI,4BAiBpE,IAAM4I,EAAoC,CACtC,iBAAoB,CAChB7Q,OAAA,SAAOiB,EAAkBgD,EAAcjB,GAEnC,QADa/B,EAAQ,GACL+B,aAAkB7E,IAEtCgC,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,EAAAoG,uBACrBjC,GAAI,EAAAvE,IAAI,mBAAmB1C,MAAM+V,MAI7C,oBAAuB,CACnB5Q,OAAQ,mBACRG,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,EAAAoG,uBACrBjC,GAAI,EAAAvE,IAAI,sBAAsB1C,MAAM+V,MAIhD,oBAAuB,CACnB,CACI1Q,UAAA,SAAUe,GACC,IAAAH,EAAwBG,EAAO,GAAvBF,EAAgBE,EAAO,GAAfgD,EAAQhD,EAAO,GAEtC,OADAA,EAAQ,GAAiBA,EAAQ,GAAegD,EAAO,EAChDnD,EAAO6F,aAAa5F,EAAOkD,EAAO,KAE7C9D,UAAW,CACP8F,EAAG,EAAAlC,sBACHmC,GAAI,iBACJ4K,IAAK,kBAGb,CACI5Q,UAAW,CACP,SAAUe,GACC,IAAAH,EAAwBG,EAAO,GAAvBF,EAAgBE,EAAO,GAAfgD,EAAQhD,EAAO,GACtCA,EAAQC,KAAK,GAAwBH,GACrC,IAAIkE,EAAMnE,EAAOqE,YACbqL,EACAvP,EACAgD,EAAO,GACP,SAAC7F,GAAe,MAAc,wBAAdA,EAAKK,QAGzB,OADAwC,EAAQE,SACD8D,GAAO,GACf,MAEPhF,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GACnB8P,EAAuBhO,EAAS,aAAlBuF,EAASvF,EAAS,KAGtC,OAFAA,EAAUgO,aAAeA,EAAavN,QACtCT,EAAUuF,KAAOA,EAAK3O,OAAS2O,EAAKrP,KAC7B8J,GAEX5C,UAAW,CACP,CAEImI,KAAM,EAAA/K,IAAI,wBAAyB,kBACnCwT,aAAc,EAAAxT,IACV,aACA,EAAAE,QAAQ,mBAAoB,kBAGpC,CACI,CAAC,eAAgB,4BAOrC,IAAK,IAAM4L,KAAawH,EACpBxH,IAAc,EAAA5F,WAAW4F,GAAa,CAACA,EAAW,kBAGtD,UAAewH,G,qSChKf,IApBA,WAWA,OAMA,OAGoB,QAAAlN,WAAA,eAAY,EAC5BqN,EADY,QAIR,IAAApS,EAA8B,EAAAV,MAAK,OAA3Ba,EAAsB,EAAAb,MAAK,OAAnBM,EAAc,EAAAN,MAAK,UAC3C,SAASkJ,EAAgB,EAA8BkH,G,IAA5B3U,EAAK,QAAE2E,EAAK,QAAEC,EAAG,MACpCtF,EAAOqV,EAAYA,EAAU1E,KAAOjQ,EACpCgX,EAAa,CACblS,KAAM,aAAcxF,KAAI,EAAEqF,MAAK,EAAEC,IAAG,GAOxC,OALAnF,OAAOC,eAAesX,EAAY,QAAS,CACvC3T,cAAc,EACd1D,YAAY,EACZK,MAAOV,IAEJ0X,EAIX,SAASM,EAAWC,EAA0DhP,EAAcoM,GACxF,MAAO,CACH7P,KAAM,UACN9E,MAAOuX,EAAYhP,EAAOoM,GAC1BxI,IAAK5D,EAAMvI,MACX2E,MAAO4D,EAAM5D,MACbC,IAAK2D,EAAM3D,KAInB,IAAI+P,EAAY,IAAI,UAAU,CAC1BnD,eAAe,EAAOD,YAAa,CAC/B0C,WAAYxG,EACZ+F,QAAS8D,EAAW/W,KAAK,MAAM,SAACgI,GAAiB,OAAA6E,OAAO7E,EAAMvI,UAC9DkU,QAASoD,EAAW/W,KAAK,MAAM,SAACgI,GAAiB,MAAgB,SAAhBA,EAAMvI,SACvD+Q,OAAA,SAAOxI,EAAcoM,GACjB,OAAKA,EAAU0B,OAAOnK,OAStB3D,EAAMgK,IAAMoC,EAAU1E,KACtB1H,EAAM2D,MAAQyI,EAAU0B,OAAOnK,MACxB3D,GAVI,CACHzD,KAAM,UACN9E,MAAO2U,EAAU1E,KACjB9D,IAAK5D,EAAMvI,MACX2E,MAAO4D,EAAM5D,MACbC,IAAK2D,EAAM3D,MAOvB0P,KAAMgD,EAAW/W,KAAK,MAAM,WAAM,eAClC4T,kBAAA,SAAkB5L,EAAcoM,GAC5B,IAAInG,EAAQjG,EAAMiG,MACdL,EAAO,CACPrJ,KAAM,UACN9E,MAAO,KACPmM,IAAK5D,EAAMvI,MACXwO,MAAK,EACL7J,MAAO4D,EAAM5D,MACbC,IAAK2D,EAAM3D,KAEf,IACIuJ,EAAKnO,MAAQ,IAAIwX,OAAOhJ,EAAMyH,QAASzH,EAAM8E,OAC/C,MAAOmE,IACT,OAAOtJ,MAKnB,aAeI,aAbA,KAAA/C,YAAc,EAAAA,YACd,KAAAb,gBAAkB,EAAAA,gBAClB,KAAAoK,UAAYA,EACZ,KAAA7K,WAAa,EAAAA,WACb,KAAA4N,cAAuB,CACnB5S,KAAM,GACN9E,MAAO,IAqKX,KAAAyN,gBAAkBA,EA0NtB,OA5XI,YAAAjF,IAAA,W,IAAI,sDAEApH,KAAKqQ,WAAWnQ,KAAK8B,MAAMhC,KAAKqQ,WAAYkG,IAIhD,YAAAC,MAAA,SAAM7H,GACF,OAAO3O,KAAKyW,YAAY9H,IAE5B,YAAA+H,YAAA,SAAY/H,GACR,OAAO,IAAI3K,EAAOhE,KAAK2W,OAAOhI,EAAO,IAAkB,EAAM,IAAgB,GAAO3O,KAAKuD,MAAOvD,KAAKwD,MAEzG,YAAAiT,YAAA,SAAY9H,GACR,OAAO,IAAI9K,EAAO7D,KAAK2W,OAAOhI,GAAQ3O,KAAKuD,MAAOvD,KAAKwD,MAE3D,YAAAuI,WAAA,SAAW7F,EAAkBiB,GACzBA,IAAUjB,EAAQ,GAAkBiB,EAAMsB,SAC1C,IAAIzC,EAASE,EAAQ,GACrBlG,KAAKoK,YACD,EAAAJ,YACA9D,GAEJ,IAAIT,EAAYO,EAAOA,EAAOtF,OAAS,GAIvC,OAHI+E,IAAc,EAAAkE,oBAAoBlE,IAClCzF,KAAKoH,IAAIpB,EAAOU,OAEbV,GAEX,YAAA4E,gBAAA,SACI1E,EACAiB,EACAoD,GAEA,YAFA,IAAAA,MAAkC,EAAApB,iBAE3BnJ,KAAK4W,UAAUrM,EAAY,EAAAX,aAAc1D,EAASiB,IAIrD,YAAAwP,OAAR,SAAehI,G,IAAe,wDAC1B3O,KAAKgG,OAAShG,KAAKuT,UAAUjD,SAAS3B,GACtC3O,KAAKuD,MAAQ,CAAC,EAAGvD,KAAKuT,UAAUpP,OAChCnE,KAAKwD,IAAM,CACP4E,MAAO,CACHC,KAAM,EACNsI,OAAQ,GAEZrI,IAAK,CACDD,KAAMrI,KAAKuT,UAAUhD,YACrBI,OAAQ3Q,KAAKuT,UAAUpP,MAAQnE,KAAKuT,UAAU/C,aAGtDxQ,KAAKqQ,WAAarQ,KAAKuT,UAAUlD,WACjC,IAAInK,EAAU,EAAAJ,SAAS9F,KAAMA,KAAKgG,QAMlC,OALA6Q,EAAanW,QAAUwF,EAAQG,MAAK,MAAbH,EAAiB2Q,GACxC7W,KAAK+L,WAAW7F,GACZlG,KAAKqQ,WAAW3P,QAChBkF,QAAQC,KAAK,SAAU7F,KAAKqQ,YAEzBrQ,KAAKgG,QAEhB,YAAAoE,YAAA,SACIhJ,EACA8E,EACA4Q,EACAC,QADA,IAAAD,MAAA,GAGA,IAKIE,EACAC,EANAxQ,EAAQP,EAAQG,MAAM,EAAeyQ,GACrCI,EAAiBJ,EAAQ,EACzB9Q,EAASE,EAAQ,GACjBiR,EAA+B,IAAIpV,MAAM+U,GAI7C,IAHAK,EAAcjX,KAAKgX,KAGN,CACT,GAAIA,EAASlR,EAAOtF,QAEhB,KAEQsW,GAEIA,EAAQ,GAAyBE,GAC9BC,EAAczW,QAAU,EAAIsW,EAAQ,MAItCC,EAAQjX,KAAKoX,UAAUlR,EAAS8Q,MAC7BA,OAAU9U,KAGxB,CACE,IAAImV,EAAUrX,KAAKsX,KACflW,EACA8E,EACAgR,EACAC,EACAH,aAAO,EAAPA,EAAO,IAEX,IAAIK,EAcG,CACHH,GAAU,EACV,SAfA,IACKF,KAEGA,EAAQ,GAA8BK,EAAQ,IAC3CL,EAAQ,KAAgChL,OAAOqL,EAAQ,QACvDJ,EAAQjX,KAAKoX,UAAUlR,EAAS8Q,IACzC,CACEA,EAAUK,EAGVH,GAAUG,EAAQ,GAAyBA,EAAQ,IAAyB,EAC5E,gBAOT,IAECL,KACIC,EAAQjX,KAAKoX,UAAUlR,EAAS8Q,IAGxC,MAEJ,GAAIA,EAAS,CACT,GAAID,GAAQC,EAAQ,IAAyBF,GAASC,EAAK/Q,EAAO8Q,IAE9D,OADA5Q,EAAQM,QAAQC,GACTT,EAAO8Q,GAElBI,EAASF,EAAQ,GAErBE,GAAUJ,IAAoB,IAAXG,IAAiBC,EAASC,EAAcD,IAC3DD,EAAQ,EACRD,OAAU9U,EACViV,EAAcI,OAAOL,EAAS,EAAGC,EAAczW,QAAUwW,EAAS,IAEtEhR,EAAQM,QAAQC,IAEpB,YAAAmQ,UAAA,SACIrM,EACAsC,EACA3G,EACAiB,GAEA,IAAInB,EAASmB,EACNjB,EAAQ,GAAkBiB,EAAMsB,QACjCvC,EAAQ,GAOd,GANAA,EAAQC,KAAK,IAAsB,GACnCnG,KAAKoK,YACDG,EACArE,GAEJA,EAAQE,SACJJ,EAAOtF,OAAQ,CACf,GAAImM,EAAK7G,EAAO,IAEZ,OADAA,EAAOtF,OAAS,GAAKV,KAAKoH,IAAG,MAARpH,KAAYgG,EAAOrF,MAAM,IACvCqF,EAAO,GAElBhG,KAAKoH,IAAG,MAARpH,KAAYgG,QACLmB,GACPnH,KAAKoH,IAAID,IAIjB,YAAAyE,aAAA,SAAa,GACT,MAAO,CACHlI,KAAM,UACN9E,MAHY,QAIZ2E,MAJmB,QAKnBC,IALwB,QAQhC,YAAAgU,eAAA,SAAenU,GACX,IAAIM,EAAaN,EAAKM,WACtB,OACIA,GACuB,YAApBA,EAAWD,MACiB,iBAArBC,EAAW/E,OAClB+E,EAAWoH,IAAIrK,OAAS,EAEpB,IAAI+C,EACPJ,EAAKK,KACLL,EAAKM,WACLA,EAAWoH,IAAIpK,MAAM,GAAI,GACzB0C,EAAKE,MACLF,EAAKG,KAGNH,GAGX,YAAAiU,KAAA,SACIlW,EACA8E,EACA/B,EACAgT,EACAM,GAEA,IAAInB,EAAgBtW,KAAKsW,cACrB5N,EAAa1I,KAAK0I,WAClB1C,EAASE,EAAQ,GAErB,OAOA,SAASwR,EAAKnW,EAA6B4F,EAAciB,EAAeE,GACpE,IAAIqP,GAAe,EACfR,EAAczW,QAAU4H,EAAM,IAC9BqP,GAAe,EACfR,EAAcjX,KAAKkI,IAEvB,IAAIwP,EAAQlP,EAAWvB,EAAMzD,MAC7B,GAAKkU,EAEE,CAEH,IADA,IAAI,EAAQ,EAAGP,OAAO,EACf,EAAQO,EAAMlX,QACjB2W,EAAUQ,EAAQD,EAAM,OAAaP,EAEzC,OAAOA,EANP,OAAOQ,EAAQ1Q,EAAMzD,MASzB,SAASmU,EAAQnU,GACb,IAAIL,EAA2B8E,EAC3B+B,EAAc4N,EAAkBC,EAChCC,EAAiCC,EACrC,GAAM5U,EAAO9B,EAAOmC,GAuCpB,OApCAyE,EAAanC,EAAOsC,EAAM,IAAOA,EAAMtC,EAAOtF,QAAU4V,EACxD0B,EAAa3U,EAAK8D,EAAMvI,OAEpBuJ,GAAc6P,IACV9N,EAAMwN,EAAKM,EAAY7P,EAAYC,EAAOE,EAAM,MAEpD2P,EAAY5U,EAAK,SAEb8E,GAAc8P,IACV/N,EAAMwN,EAAKO,EAAW9P,EAAYC,EAAOE,EAAM,KAG7CA,GAAOmP,KAELK,GACCC,EAAeC,IAAeD,EAAa,UACxCA,EAAeE,IAAcF,EAAa,YAI7CD,EAAQ,IACNA,EAAQ,GAAgB5R,EAASkC,EAAOE,IAE3CmP,EAAUnP,EACV4B,EAAM,CACF4N,EAAQ,GACR1P,EACAE,EACAwP,IAEGH,GAAgBrP,EAAMF,GAC7B+O,EAAcI,OAAOjP,EAAM,EAAG6O,EAAczW,OAAS4H,EAAM,KAKpE4B,GAnERwN,CACHtW,EACA+C,GAAS+B,EAAQ,GAAiBF,EAAO7B,GAASmS,EAClDnS,EACAA,IAmER,YAAAyI,WAAA,SAAW1G,G,MASYhH,EAAa6B,EAR5BmI,EAAOhD,EAAQ,GACf+B,EAAQ/B,EAAQ,GAChB4R,EAAU5R,EAAQ,GAClBF,EAASE,EAAQ,GACjB4Q,EAAQ5Q,EAAQ,GAChB7C,EAAY,IAAIyU,EAAQ,GACxBpX,EAASsF,EAAOtF,OAChB0H,EAAQc,EAAMZ,EAAML,EAAQvH,EAASuH,EAAQvH,EAAS,EACtDwX,EAAShP,EAEbhD,EAAQ,GAAqB7C,EAC7B,IAAmB,UAAAyU,EAAQ,GAAR,eAAwB,CAAtC,IAAMK,EAAI,KACX,GAAMA,aAAgB,EAAA7X,KAmClB+C,EAAK8U,EAAKjZ,KAAOiZ,EAAKvZ,UAnCG,CACxBM,GAAD,EAAmBiZ,GAAf,GAAEpX,EAAQ,KACd,IAAIoG,EAAe+Q,GAAUpB,GAASoB,EAASxX,EAASsF,EAAOkS,GAAU,KAuBzE,IAAK,IAAIva,KAtBLuB,GACIiI,GAASmB,EAAM4P,IACf5P,EAAM4P,QAEQhW,IAAdmB,EAAKnE,GACLmE,EAAKnE,GAAOiI,EAER9D,EAAKnE,aAAgB6C,MACrBsB,EAAKnE,GAAKgB,KAAKiH,GAEf9D,EAAKnE,GAAO,CAACmE,EAAKnE,GAAMiI,IAGjB,OAARjI,EACHgZ,IAAW9P,EACX8P,EAAS5P,IAAQF,EAAQ8P,EAAS,GAC3BA,EAASpB,GAASoB,EAAS,EAAI5P,IACtCA,EAAM4P,EAAS,GAEZ/Q,GAASmB,EAAM4P,IACtB5P,EAAM4P,GAEInX,EACVA,EAASpD,GAAGuI,EAASiB,GACrBjB,EAAQ,GAAgBgD,EACxBhD,EAAQ,GAAiB+B,EACzB/B,EAAQ,GAAmB4R,EAC3B5R,EAAQ,GAAkBF,EAC1BE,EAAQ,GAAqB7C,EAEjC6U,GAAU,GAMlB9P,GAAS0O,IAAU1O,EAAQ0O,GAE3B,IAAIsB,EAAcpS,EAAOoC,GACrBiQ,EAAYrS,EAAOsC,GAQvB,OAPAjF,EAAKE,MAAQ,CAAC6U,EAAY7U,MAAM,GAAI8U,EAAU9U,MAAM,IACpDF,EAAKG,IAAM,CACP4E,MAAOgQ,EAAY5U,IAAI4E,MACvBE,IAAK+P,EAAU7U,IAAI8E,KAEvBpC,EAAQ,GAAiBkC,EACzBlC,EAAQ,GAAeoC,EAChBjF,GAEX,YAAA+T,UAAA,SACIlR,EACAoS,GAE2CA,EAAM,GAA5C,IAEDtQ,EACAI,EAAeE,EAHXY,EAAmCoP,EAAM,GAAnCrQ,EAA6BqQ,EAAM,GAA5BR,EAAsBQ,EAAM,GAC7CnT,EAAY2S,EAAQ,GAGxB5R,EAAQ,GAAgBgD,EACxBhD,EAAQ,GAAiB+B,EACzB/B,EAAQ,GAAmB4R,EAC3B,IAAI9R,EAASE,EAAQ,GACjBhB,EAAU4S,EAAQ,GAatB,GAZK3S,IAAkD,KAApC6C,EAAY7C,EAAUe,IAO9B8B,IACPI,EAAQlC,EAAQ,GAChBoC,EAAMpC,EAAQ,KARd8B,EAAYhI,KAAK4M,WAAW1G,GAC5BkC,EAAQlC,EAAQ,GAChBoC,EAAMpC,EAAQ,GACVhB,IACA8C,EAAY9C,EAAQgB,KAM5BA,EAAQ,GAAkBF,GACrBgC,EACD,YAAqB9F,IAAd8F,IAAyC,IAAdA,EAC5B,EACe,OAAdA,EAAqB,GAAK,EAOrC,IAAItH,EAAS4H,EAAMF,EAAQ,EAM3B,OALIJ,aAAqBjG,MACrBiE,EAAOuR,OAAM,MAAbvR,EAAM,GAAQoC,EAAO1H,GAAWsH,IAEhChC,EAAOuR,OAAOnP,EAAO1H,EAAQsH,GAE1BtH,GAEf,EAvYA,G,sJCnFA,IAYI6X,EACAC,EAbJ,OAMA,OAEA,OAEMpV,EAAW,EAAAD,MAAMC,SAKvB,EAAAwF,WAAW1I,MAAK,WAEZqY,EAAwB,EAAAlU,gBACpBoU,EACA,EAAAvL,yBAEJsL,EAA0B,EAAAnU,gBACtBqU,EACA,EAAAxL,4BAKR,IAAMiB,EAAgC,CAClCwK,aAAc,CACVzT,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GACzB8B,EAAU4Q,YAAc1S,EAAQC,KAAK,GAAoB,MACzD,IAAI+D,EAAMM,EAAkBtE,EAAS8B,EAAUoD,UAE/C,OADApD,EAAU4Q,YAAc1S,EAAQE,SACzB8D,GAEX7E,WAAY,GACZJ,OAAQ,CACJ,KACA,SAAUiB,GACN,OAAOA,EAAQ,MAA4BA,EAAQ,KAG3Dd,UAAW,CACP,CACIgG,SAAU,EAAA5I,IAAI,iBACd0F,MAAO,EAAAtF,cAAc,EAAA+F,iCAEzB,CACI6E,MAAO,EAAA5K,cAAc,kBAAmB,GAAsB,WAC9DwI,SAAU,EAAA5I,IAAI,iBACdoW,WAAY,EAAA1V,OAAM,MAI9B2V,cAAe,CACX3T,QAAS,SAAUgB,GACV,IAAA8B,EAAa9B,EAAO,GACzB8B,EAAU4Q,YAAc1S,EAAQC,KAAK,GAAoB,MACzD,IAAI+D,EAAMO,EAAmBvE,EAAS8B,EAAUsD,YAEhD,OADAtD,EAAU4Q,YAAc1S,EAAQE,SACzB8D,GAEX7E,WAAY,GACZJ,OAAQ,CACJ,KAAM,KACN,SAAUiB,EAAkBgD,EAAcjB,GACtC,IAAIjC,EAASE,EAAQ,GACrB,OAAOA,EAAQ,MAA4BF,GACpCE,EAAQ,KAEnB,SAAUA,GACN,OAAOA,EAAQ,MAA4BA,EAAQ,KAG3Dd,UAAW,CACP,CACI1B,KAAM,EAAAR,MAAM,iBACZsK,MAAO,EAAA5K,cAAc,EAAA+F,gCACrB2C,WAAY,EAAA9I,IAAI,iBAChB0F,MAAO,EAAAtF,cAAc,EAAA+F,iCAEzB,CACI,CAAC,QAAS,EAAA/F,cAAc,kBACxB,CAAC,aAAc,EAAAM,OAAM,KAEzB,CAAC,QAAS,EAAAA,SACV,CACIQ,KAAM,EAAAR,MAAM,iBACZsK,MAAO,EAAA5K,cAAc,iBAAkB,GAAsB,WAC7D0I,WAAY,EAAA9I,IAAI,iBAChBoW,WAAY,EAAA1V,OAAM,MAI9B4V,kBAAmB,CACf7T,OAAA,SAAOiB,GACH,OAAOA,EAAQ,MAA4BA,EAAQ,IAEvDb,WAAY,IACZD,UAAW,CACP8F,EAAG,EAAAtI,cAAc,GAAsB,WACvCsG,KAAM,EAAA1G,IACF,eAAgB,gBAChB,EAAAA,IAAI,cAAc1C,OACd,SAAUoG,EAAkB0P,GACpBA,aAAsBxS,EACtB8C,EAAQ,GAAgBkB,IAAIwO,GAE5B,EAAA/N,gBAAgB3B,EAAS0P,OAKzCzK,GAAI,EAAArI,eAAe,gBACnBmF,MAAO,iBAGf,GAAI,CACA/C,QAAA,SAAQgB,GACG,IAAAiB,EAAwCjB,EAAO,SAAtCH,EAA+BG,EAAO,GAA9BF,EAAuBE,EAAO,GAAtBgD,EAAehD,EAAO,GAAPA,EAAO,GAC1CgD,GAAQ,GAAKhD,EAAQ,MAA4BF,GACzDD,EAAOqB,IAAID,GAEfA,EAAQ,EAAAkD,gBAAgBlD,GACxB,IAAId,EAAQH,EAAQG,MAAM,GAAwBc,EAAMsB,QAAS,GAAoB,MACjFpF,EAAO0C,EAAO6Q,UACd,EAAA1J,yBACA,SAAA7J,GAAQ,SAAAuG,aAAavG,IACA,iBAAdA,EAAKK,MACS,kBAAdL,EAAKK,MACS,sBAAdL,EAAKK,OACZwC,EACAiB,GAGJ,OADAjB,EAAQM,QAAQH,GACT,IAAIjD,EAASC,EAAM8D,IAE9B9B,WAAY,CAAC,IAAK,IAAI2G,OAAO,IAC7B5G,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,eAAgB,GAAsB,WAC3DuE,MAAO,EAAA3E,IAAI,iBACX0F,MAAO,EAAAtF,cAAc,EAAA+F,iCAEzB,CACI,CAAC,QAAS,EAAAzF,SACV,CAAC,kBAAmB,EAAAA,OAAM,QAY1C,SAASsH,EAAkBtE,EAAkBiB,GACzC,IAAI0N,EAAU,IAAI,EAAA1R,MAAMwV,aAMxB,OALAzS,EAAQC,KAAK,GAAwBgB,EAAMsB,SAC3CoM,EAAQzJ,SAAW,EAAAd,kBAAkBiO,EAAuBrS,EAASiB,GACrEjB,EAAQE,SACRyO,EAAQtR,MAAQ4D,EAAM5D,MACtBsR,EAAQrR,IAAM2D,EAAM3D,IACbqR,EAEX,SAASpK,EAAmBvE,EAAkBiB,GAC1C,IAAI0N,EAAU,IAAI,EAAA1R,MAAM0V,cAMxB,OALA3S,EAAQC,KAAK,GAAwBgB,EAAMsB,SAC3CoM,EAAQvJ,WAAa,EAAAhB,kBAAkBkO,EAAyBtS,EAASiB,GACzEjB,EAAQE,SACRyO,EAAQtR,MAAQ4D,EAAM5D,MACtBsR,EAAQrR,IAAM2D,EAAM3D,IACbqR,EAtBP,EAAA1G,WACA,EAAA3D,oBACA,EAAAC,qBAuBJ,IAAIgO,EAAkB,CAClB9C,QAAS,CACLzQ,QAAS,EAAAqD,aACTnD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,GAAsB,WACnCiG,QAAS,EAAAjG,IACL,EAAAA,IAAI,cAAc1C,OACd,SAAUoG,EAAkB0P,GACpBA,aAAsBxS,EACtB8C,EAAQ,GAAgBkB,IAAIwO,GAE5B,EAAA/N,gBAAgB3B,EAAS0P,MAIrC,EAAApT,IAAI,eAAgB,gBAAiB,sBAEzC0F,MAAO,EAAApF,eAAe,EAAAN,IAAI,eAAgB,MAE9C,CACI,CAAC,UAAW,eACZ,CAAC,QAAS,EAAAM,eAAe,MAE7B,CACI0F,QAAS,EAAAhG,IAAI,GAAsB,WACnCiG,QAAS,EAAAvF,MAAM,MACfgF,MAAO,EAAApF,eAAe,oBAMhC4V,EAAoB,CACtB/C,QAAS,CACLzQ,QAAS,EAAAqD,aACTlD,WAAY,EACZD,UAAW,CACPoD,QAAS,EAAAhG,IAAI,EAAAM,eAAe,IAAuB,WACnD2F,QAAS,aAIjBsQ,SAAU,CACN,CACI7T,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3BhH,EAAe8I,EAAS,IAAnBpJ,EAAUoJ,EAAS,MAI9B,GAHiB,eAAb9I,EAAIwE,OACJsE,EAAU9I,IAAM6G,EAAO6E,gBAAgB1E,EAAShH,IAE/CN,EAGE,CACH,IAAI4W,OAAI,EACJxN,EAAUkG,WACVsH,EAAO5W,EACPA,EAAQM,EACR,EAAA2I,gBAAgB3B,EAAStH,KAErBA,aAAiBmD,QACjByT,EAAO5W,EAAM,GACbA,EAAQA,EAAM,IAEC,eAAfA,EAAM8E,KACN,EAAAmE,gBAAgB3B,EAAStH,GAEzBA,GACoB,OAAhBA,EAAMA,MACA4L,EACAC,GACRvE,EAAStH,IAGnBoJ,EAAUpJ,MAAQ4W,EAAO,CACrB9R,KAAM,oBACNwF,KAAMtK,EACNqJ,MAAOuN,GACP5W,OA3BJoJ,EAAUpJ,MAAQM,EAClB,EAAA2I,gBAAgB3B,EAAShH,GA4B7B,OAAO8I,GAEX5C,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,GAAsB,YAC3C1D,IAAK,gBACLN,MAAO,EAAA8D,QACH,EAAAI,eAAe,gBACf,EAAAN,IAAI,aAAc,oBAClB,EAAAH,QAAQ,EAAAK,QAAQ,EAAAI,eAAe,gBAAiB,kBAEpDoF,MAAO,EAAApF,eAAe,GAAsB,gBAC5CwJ,SAAU,EAAApJ,OAAM,GAChBqK,KAAM,EAAArK,MAAM,QACZ+K,OAAQ,EAAA/K,OAAM,GACdgL,UAAW,EAAAhL,OAAM,IAErB,CACI,CACI,MACA,EAAAV,IAAI,cAAc1C,OACd,SAAUoG,EAAkB0P,GACpBA,aAAsBxS,GACtB8C,EAAQ,GAAgBkB,IAAIwO,OAK5C,CAAC,WAAY,EAAA1S,OAAM,KAEvB,CACI,CAAC,QAAS,EAAAb,QAAQ,EAAAK,QAAQ,EAAAI,eAAe,gBAAiB,kBAC1D,CAAC,YAAa,EAAAI,OAAM,OAIhC,CACIiC,UAAS,WACL,OAAO,GAEXE,WAAY,IAAI2G,OAAO,GACvB5G,UAAW,CACP+F,GAAI,EAAAzI,QACA,EAAAF,IAAI,GAAsB,YAC1B,EAAAA,IACI,gBACA,cAEJ,eACA,EAAAA,IACI,aACA,oBAEJ,qB,8ECzTpB,WAIA,OAeA,OAOA,OACMY,EAAW,EAAAD,MAAMC,SACjB4V,EAAwB,UAAW,oBAEnCC,EAAkC,CACpC,GAAI,CACA/T,QAAA,SAAQ,G,IAAC8C,EAAS,KAEd,OAFsB,KACfZ,IAAIY,EAAUiJ,OACd,IAEX5L,YAAa,EACbD,UAAW,CACP,CACI6L,MAAO,EAAAzO,IAAI,aAAc,WACzB0F,MAAO,EAAAtF,cAAc,EAAAmG,qCAIjC,eAAkB,CACd7D,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GACjC,EAAA6B,uBAAuB7B,GACvB,IAAIgT,EAAQlR,EAAUkR,MAWtB,OAVIA,GAEIA,aAAiB9V,GACd8C,EAAQ,IAAkBlB,QAAQkU,EAAMhb,MAAQ,IAEnD6H,EAAOqB,IAAI8R,GAEPhT,EAAQ,KAAyBA,EAAQ,KACjDH,EAAOqB,IAAIY,GAERA,GAEX/C,OAAQ,CACJ,SAAUiB,EAAkBgD,GACxB,OAAO,EAAAD,UAAU/C,EAASgD,EAAMA,EAAO,IAE3C,MAEJ9D,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,iBACtBoW,MAAO,EAAA3R,kDACPW,MAAO,EAAA7F,QAAQ,iBAEnB,CAAC,QAAS,EAAAa,MAAM,SAGxB,kBAAqB,CACjBgC,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC7BgT,EAAQlR,EAAUkR,MAYtB,OAXA,EAAAnR,uBAAuB7B,GACnBgT,GAEIA,aAAiB9V,GACd8C,EAAQ,IAAkBlB,QAAQkU,EAAMhb,MAAQ,IAEnD6H,EAAOqB,IAAI8R,GAEPhT,EAAQ,KAChBH,EAAOqB,IAAIY,GAERA,GAEX/C,OAAQ,iBACRG,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,oBACtBoW,MAAO,EAAA3R,kDACPW,MAAO,EAAA7F,QAAQ,iBAEnB,CAAC,QAAS,EAAAa,MAAM,SAGxB,gBAAmB,CACfgC,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAKjC,OAJA,EAAA6B,uBAAuB7B,GAClBA,EAAQ,KACTH,EAAOqB,IAAIY,GAERA,GAEX7C,UAAA,SAAUe,GACG,IAAAF,EAAuBE,EAAO,GAAtBgD,EAAehD,EAAO,GACvC,GAAIgD,IAD4BhD,EAAO,GACnB,CAChB,IAAIiC,EAAanC,EAAOkD,EAAO,GAC/B,GAAIf,GAAcnC,EAAOkD,GAAM1F,IAAI8E,IAAID,OAASF,EAAW3E,IAAI4E,MAAMC,KACjE,OAAO,EAGf,OAAO,GAEXpD,OAAQ,iBACRI,WAAY,EACZD,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,kBACtB+H,SAAU,EAAArD,kDACVU,MAAO,EAAA7F,QAAQ,iBAEnB,CAAC,WAAY,EAAAa,MAAM,SAG3B,eAAkB,CACdgC,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAEjC,OADA8B,EAAUlE,KAAOiC,EAAOgG,WAAW7F,EAAS8B,EAAUlE,MAC/CkE,GAEXpD,UAAU,EACVS,WAAY,EACZD,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,EAAAoG,uBACrBlF,KAAM,mBAIlB,iBAAoB,CAChBqB,UAAW,eACXD,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAGjC,OAFA,EAAA6B,uBAAuB7B,GACvB8B,EAAU6E,KAAO9G,EAAO6E,gBAAgB1E,EAAS8B,EAAU6E,MACpD7E,GAEX5C,UAAW,CACP,CACI+T,QAAS,EAAArW,eAAe,eAE5B,CACI,CAAC,OAAQ,EAAAgG,6BACT,CAAC,OAAQ,EAAApG,QAAQ,EAAAI,eAAe,iBAAkB,kBAClD,CAAC,QAAS,EAAAT,QAAQ,oBAI9B,eAAkB,CACd,CACIgD,WAAY,IACZD,UAAW,CACP,CACIoI,MAAO,EAAA5K,cAAc,EAAAoG,uBACrBkC,EAAG,EAAApI,eAAe,oBAKlC,oBAAuB,CACnBoC,QAAA,SAAQgB,GACC,IAAA8B,EAAmC9B,EAAO,GAA/BH,EAAwBG,EAAO,GAAvBF,EAAgBE,EAAO,GAAfgD,EAAQhD,EAAO,GAC/C,EAAA6B,uBAAuB7B,GACvB,IAAI2K,EAAY7K,EAAOkD,EAAO,GAC9B,KACM2H,GAAaA,EAAUjN,aAErBoC,IAAWD,EAAOC,QACfA,IAAWE,EAAQ,KAI1B,QADA8B,EAAYjC,EAAOyR,eAAexP,IAChBpE,WACd,IAAK,aACDsC,EAAQ,KAAkB,EAItC,OAAO8B,GAEX3C,WAAY,EACZD,UAAW,CACP,CACIzB,WAAY,EAAAgE,qDACZO,MAAO,EAAA7F,QAAQ,mBAI3B,aAAgB,CACZ8C,UAAW,CACP,SAAUe,GACNA,EAAQC,KAAK,IAAqB,GAClC,IAAI+D,EAAM,EAAAC,qBAAqBjE,GAE/B,OADAA,EAAQE,SACD8D,GAEX,MAEJhF,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3BkT,EAA+BpR,EAAS,SAA9BlE,EAAqBkE,EAAS,KAAxBzE,EAAeyE,EAAS,MAAjBxE,EAAQwE,EAAS,IAC1CqR,EAAkBD,EAAS3Q,QAK/B,GAJAvC,EAAQC,KAAK,IAAsB,GACnCD,EAAQ,GAAkBmT,EAC1BtT,EAAOqE,YAAYkP,EAAmBpT,GACtCA,EAAQE,SACJiT,EAAgB3Y,OAAS,EAAG,CAC5B,IAAIyD,EAAQ,EACR,EAAA2F,YAAYuP,EAAgB,OAC5BrR,EAAYqR,EAAgB,IAClBvV,KAAOA,EACjBkE,EAAUzE,MAAQA,EAClByE,EAAUxE,IAAMA,EAChBW,EAAQ,GAERkV,EAAgB3Y,OAASyD,GACzB4B,EAAOqB,IAAG,MAAVrB,EAAcsT,EAAgB1Y,MAAMwD,IAG5C,OAAO6D,GAEX5C,UAAW,CACP,CACI+T,QAAS,EAAArW,eAAe,eACxBsW,SAAU,iBAEd,CAAC,OAAQ,EAAAtQ,+BAGjB,eAAkB,GAElB,eAAkB,GAElB,YAAe,CACX3D,UAAA,SAAUe,GACK,IAAAgD,EAAehD,EAAO,GACjC,OAD0BA,EAAO,GACpBgD,GAAQ,GAAM,GAChB,EAAAiB,qBAAqBjE,IAIpChB,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAEjC,OADA8B,EAAU6E,KAAO9G,EAAO6E,gBAAgB1E,EAAS8B,EAAU6E,MACpD7E,GAEX5C,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,cACtB+J,KAAM,gBACN0M,WAAY,EAAArW,MAAM,MAClBsW,UAAW,EAAAtW,MAAM,OAErB,CAAC,aAAc,EAAA4F,6BACf,CACI,YAAa,EAAApG,QACT,EAAAI,eAAe,gBACf,EAAAT,QAAQ,EAAAyG,iCAKxB,iBAAoB,CAChB3D,UAAW,CACP,SAAUe,GACC,IAAAH,EAAwBG,EAAO,GAClCgT,EAD2BhT,EAAO,GAAPA,EAAO,IAElCuT,EAAaP,EAAMhb,KACnBwb,EAAYxT,EAAQ,IACpBwT,EAAU1U,QAAQyU,IAAe,GACjC1T,EAAOqB,IAAI8R,GAEf,IAAI/U,EAAQuV,EAAUxZ,KAAKuZ,GAAc,EACrCvP,EAAM,EAAAC,qBAAqBjE,GAE/B,OADAwT,EAAUnC,OAAOpT,EAAO,GACjB+F,GAEX,MAEJ7E,WAAY,EACZD,UAAW,CACP,CACI8T,MAAO,EAAAxW,QACH,EAAA6E,kDACA,EAAAzE,eAAe,kBAGvB,CAAC,OAAQ,EAAAgG,+BAGjB,gBAAmB,CACf,CACI5D,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3ByT,EAAiB3R,EAAS,aAChCA,EAAU2R,aAAe5T,EAAO6E,gBAAgB1E,EAASyT,GACzD3R,EAAU2R,cAAgB5T,EAAOqB,IAAIuS,GACrC3R,EAAU4R,MAAQ1T,EAAQ,GAAkB8B,EAAU4R,MAAMnR,QAC5DvC,EAAQC,KAAK,GAAkBD,EAAQ,IACvCH,EAAOqE,YAAYrE,EAAOiE,YAAa9D,GACvCA,EAAQE,SAER,IADA,IAAIyT,GAAc,EACC,MAAA7R,EAAU4R,MAAV,eAAiB,CAA/B,IAAMpV,EAAI,KACX,GAAkB,eAAdA,EAAKd,KAAuB,CAC5B,GAAIc,EAAKqI,KACL,SAEJ,IAAKgN,EAAa,CACdA,GAAc,EACd,UAGR9T,EAAOqB,IAAI5C,GAEf,OAAOwD,GAEX5C,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,kBACtB6W,aAAc,gBACdC,MAAO,mBAInB,CACI1U,QAAA,SAAQ,G,IAAC8C,EAAS,KAEd,OADAA,EAAUuR,WAAa,GAChBvR,GAEX3C,WAAY,EACZJ,OAAA,SAAOwD,GACH,OAAOA,EAAQ,MAAsBA,EAAQ,IAEjDrD,UAAW,CACP,CACI1B,KAAM,EAAAR,MAAM,cACZ2J,KAAM,EAAArK,IACF,EAAAE,QACI,EAAAI,eAAe,gBACf,EAAA0E,mDAEJ,EAAA9E,QACI,EAAAI,eAAe,mBACf,EAAAI,MAAM,QAGdiI,GAAI,EAAArI,eAAe,mBAI/B,CACIoC,QAAA,SAAQ,G,IAAC8C,EAAS,KAEd,OADAA,EAAUb,MAAMoS,WAAWrZ,KAAK8H,EAAUuR,YACnCvR,EAAUb,OAErB/B,UAAW,CACP+B,MAAO,aACPoS,WAAY,EAAAzQ,+BAIxB,eAAkB,CACd5D,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAKjC,OAJA,EAAA6B,uBAAuB7B,GACnB8B,EAAUxE,IAAI4E,MAAMC,OAASL,EAAU6C,SAASrH,IAAI4E,MAAMC,MAC1DtC,EAAOqB,IAAIY,GAERA,GAEX3C,WAAY,EACZD,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,iBACtB+H,SAAU,EAAArD,kDACVU,MAAO,EAAA7F,QAAQ,mBAI3B,aAAgB,CACZ6C,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3B4T,EAA8B9R,EAAS,MAAhC9C,EAAuB8C,EAAS,QAAvB+R,EAAc/R,EAAS,UAE7C,GADAA,EAAU8R,MAAQ,CAAEpW,KAAM,iBAAkBI,KAAMiC,EAAOgG,WAAW7F,EAAS4T,IACzE5U,EAAS,CACJ,IAAA8U,EAAe9U,EAAO,GAAfpB,EAAQoB,EAAO,GACvByG,EAAS,EAAAG,aAAa5F,EAAS8T,EAAMvR,SACnB,IAAlBkD,EAAOjL,QACPqF,EAAOqB,IAAI4S,GAEfhS,EAAU9C,QAAU,CAChBxB,KAAM,cACNsW,MAAOrO,EAAO,GACd7H,KAAM,CAAEJ,KAAM,iBAAkBI,KAAMiC,EAAOgG,WAAW7F,EAASpC,KAMzE,OAHIiW,IACA/R,EAAU+R,UAAY,CAAErW,KAAM,iBAAkBI,KAAMiC,EAAOgG,WAAW7F,EAAS6T,KAE9E/R,GAEX5C,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,eACtBgX,MAAO,gBACP5U,QAAS,EAAAxC,QAAQ,EAAAI,eAAe,iBAAkB,gBAAiB,iBACnEiX,UAAW,EAAA7W,MAAM,OAErB,CAAC,YAAa,EAAAR,QAAQ,EAAAI,eAAe,mBAAoB,kBACzD,CAAC,UAAW,EAAAI,MAAM,SAG1B,eAAkB,CACdiC,UAAW,eACXD,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAEjC,OADA8B,EAAU6E,KAAO9G,EAAO6E,gBAAgB1E,EAAS8B,EAAU6E,MACpD7E,GAEX5C,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,iBACtB+J,KAAM,iBAEV,CAAC,OAAQ,EAAA/D,+BAGjB,cAAiB,CACb3D,UAAW,CACP,EAAAgF,qBACA,MAEJjF,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAKjC,OAJIA,EAAQ,KACRH,EAAOqB,IAAIY,GAEfA,EAAU3I,OAAS0G,EAAO6E,gBAAgB1E,EAAS8B,EAAU3I,QACtD2I,GAEX5C,UAAW,CACP,CACI+B,MAAO,eACP9H,OAAQ,iBAEZ,CAAC,OAAQ,EAAAyJ,gCAKrB,IAAK,IAAMwF,KAAa2K,EAChB3K,GACAA,IAAc,EAAA5F,WAAW4F,GAAa,CAACA,EAAW,gBAG1D,UAAe2K,EAEf,IAAIgB,EAAc,CACdjB,oBAAmB,EACnBkB,aAAc,CACV,CACI9U,UAAW,CACP,CACIoQ,KAAM,EAAAhT,IACF,sBACA,EAAAE,QACI,EAAAI,eAAe,IACf,EAAAN,IAAI,EAAAgF,kDAAmD,EAAAtE,MAAM,OAC7D,EAAAJ,eAAe,kBAGvB+J,KAAM,EAAAnK,QACF,EAAAF,IAAI,EAAAmF,qDAAsD,EAAAzE,MAAM,OAChE,EAAAJ,eAAe,iBAEnBqX,OAAQ,EAAAzX,QACJ,EAAAF,IAAI,EAAAmF,qDAAsD,EAAAzE,MAAM,OAChE,EAAAJ,eAAe,KAEnBgB,KAAM,EAAAZ,MAAM,SAIxB,CACIgC,QAAA,SAAQgB,GACC,IAEDqH,EAAY6M,EAFXpS,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAC3BgD,EAASlB,EAAS,KAOxB,GALIkB,aAAgBnH,OACfwL,EAAoBrE,EAAI,GAAlBkR,EAAclR,EAAI,IAEzBkR,EAAalR,EAEQ,OAArBkR,EAAWxb,OAAsC,eAApBwb,EAAW1W,KAAuB,CAC/D,IAAIe,EAAU2V,GACdA,EAAa,EAAA/P,gBAAgB+P,IACd3R,QAAQ/H,OAAS,IACxB6M,EACAxH,EAAOqB,IAAIgT,GACJA,EAAW3R,QAAQ/H,OAAS,GACnCqF,EAAOqB,IAAG,MAAVrB,EAAcqU,EAAW3R,QAAQ9H,MAAM,IAE3CyZ,EAAa,IAAIhX,EAASgX,EAAW3R,QAAQ,GAAIhE,IAGzD,GAAwB,eAApB2V,EAAW1W,KACX,OAAQ0W,EAAWxb,OACf,IAAK,KACDwb,EAAa,EAAA3P,mBAAmBvE,EAASkU,GACzC,MACJ,IAAK,KACDA,EAAa,EAAA5P,kBAAkBtE,EAASkU,GACxC,MACJ,QACIrU,EAAOqB,IAAIgT,GACXA,EAAa,SAEM,eAApBA,EAAW1W,MAClBqC,EAAOqB,IAAIgT,GACXA,EAAa,MAEb,EAAAxS,mBAAmB1B,EAASkU,GAqBhC,OAnBI7M,IACArE,EAAO,IAAI,EAAA/F,MAAM6V,qBACZhD,aAAe,CAChB,CACItS,KAAM,qBACNqD,GAAIqT,EACJ5E,KAAM,OAGdtM,EAAKqE,KAAOA,EAAK3O,MACjBsK,EAAK3F,MAAQ,CAACgK,EAAKhK,MAAM,GAAI6W,EAAW7W,MAAM,IAC9C2F,EAAK1F,IAAM,CACP4E,MAAOmF,EAAK/J,IAAI4E,MAChBE,IAAK8R,EAAW5W,IAAI8E,KAExBN,EAAUkB,KAAOA,GAEjBlB,EAAUkB,KAAOkR,EAEdpS,GAEX7C,UAAA,SAAUe,GACN,OAAOA,EAAQ,IAAkBA,EAAQ,GAAgBxF,QAE7DuE,OAAQ,CAAC,WAAc,OAAO,GAAS,MACvCI,WAAY,IACZD,UAAW,CACP,CACI8F,EAAG,EAAAxI,Q,GAEC,EAAAF,IACI,EAAAE,QACI,EAAAF,IAAI,yBACJ,EAAAA,IAAI,aAAc,wBAEtB,EAAAE,QACI,iBACA,EAAAF,IAAI,aAAc,wBAMlC,CACIkB,KAAM,EAAAR,MAAM,kBACZsK,MAAO,EAAA1K,eAAe,IACtBoG,KAAM,EAAAxG,QACF,EAAAL,QAAQ,EAAAG,IAAI,iBAAkB,0BAC9B,EAAAA,IAAI,aAAc,wBAEtB2E,MAAO,EAAArE,eAAe,iBACtBmF,MAAO,EAAA5F,QACH,EAAAK,QACI,EAAAiF,qDACA,EAAAtF,QAAQ,EAAAS,eAAe,OAG/BgB,KAAM,EAAAZ,MAAM,OAEhB,CACI,CAAC,OAAQ,EAAAA,MAAM,mBACf,CAAC,QAAS,EAAAJ,eAAe,eACzB,CAAC,OAAQ,EAAAI,OAAM,SAO/BoW,EAAoB,EAAAjV,gBAAgB4V,EAAa,EAAA9Q,kB,8ECpmBrD,WAIA,OACI/F,EAAW,EAAAD,MAAMC,SAEfiX,EAAyB,EAAA7X,IAAI,WAAW1C,OAC1C,SAAUoG,EAAkBiB,IACpBA,aAAiB/D,GAAmC,iBAAhB+D,EAAMvI,QAC1CsH,EAAQ,GAAgBkB,IAAID,MAKpCmT,EAAmB,CACnB,QAAW,CACPpV,QAAS,EAAAqD,aACTlD,WAAY,EACZD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,GAAsB,WACnCiG,QAAS,qBAIrB8R,gBAAiB,CACbnV,UAAW,CACPoI,MAAO,EAAA5K,cAAc,UAAW,IAChC4X,SAAU,aACVC,MAAO,EAAAjY,IACH,EAAAE,QACI,EAAAI,eAAe,iBACf,aACA,EAAAA,eAAe,eAAgB,KAEnC,EAAAN,IAAI,eAAgB,IAAsB1C,OACtC,SAAUoG,GACD,IAAA8B,EAAa9B,EAAO,GACzB8B,EAAUyS,MAAQzS,EAAUwS,gBAS9CE,EAAyB,EAAArW,gBAAgBiW,GACzCK,EAAyB,EAAAtW,gBAAgB,CAC3C,QAAW,CACPa,QAAS,EAAAqD,aACTlD,WAAY,EACZD,UAAW,CACP,CACIoD,QAAS,EAAAhG,IAAI,GAAsB,WACnCiG,QAAS,qBAIrBmS,gBAAiB,CACbxV,UAAW,CACPoI,MAAO,EAAA5K,cAAc,UAAW,IAChC6X,MAAO,aACPI,SAAU,EAAArY,IACN,EAAAE,QACI,EAAAI,eAAe,iBACf,aACA,EAAAA,eAAe,eAAgB,KAEnC,EAAAN,IAAI,eAAgB,IAAsB1C,OACtC,SAAUoG,GACD,IAAA8B,EAAa9B,EAAO,GACzB8B,EAAU6S,SAAW7S,EAAUyS,cAQjDK,EAA0C,CAC5C,kBAAqB,CACjB5V,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAKjC,OAJA,EAAA6B,uBAAuB7B,GAClBA,EAAQ,KACTH,EAAOqB,IAAIY,GAERA,GAEX5C,UAAW,CACP,CACI+B,MAAO,EAAArE,eAAe,kBACtBiY,WAAY,EAAAvY,IACR,EAAAA,IAAI,iBAAiB1C,OACjB,SAAUoG,EAAkBiB,GACNjB,EAAO,GACf6U,WAAa,EAAAzQ,kBAAkBoQ,EAAwBxU,EAASiB,MAGlF,EAAA3E,IAAI,cAAc1C,OACd,SAAUoG,EAAkB2M,GACxB3M,EAAQ,GAAmB6U,WAAa,CACpC,CACIrX,KAAM,yBACN+W,MAAO5H,QAM3B3H,EAAG,EAAApI,eAAe,mBAClBkY,OAAQX,EACRnS,MAAO,EAAA7F,QAAQ,mBAI3B,qBAAwB,CACpB6C,QAAA,SAAQgB,GACC,IAAA8B,EAAqB9B,EAAO,GAAjBH,EAAUG,EAAO,GAQjC,OAPI8B,EAAUiT,+BACHjT,EAAUiT,sBACjB,EAAAlT,uBAAuB7B,IAEtBA,EAAQ,KACTH,EAAOqB,IAAIY,GAERA,GAEX5C,UAAW,CACP8F,EAAG,EAAApI,eAAe,EAAAJ,QAAQ,iBAAkB,eAAgB,oBAC5DsY,OAAQX,EACRnS,MAAO,EAAA7F,QAAQ,gBACf4Y,sBAAuB,EAAA/X,OAAM,KAGrC,uBAA0B,CACtBgC,QAAS,uBACTE,UAAW,CACP,CACI8F,EAAG,EAAApI,eAAe,kBAClBoY,YAAa,sBACbH,WAAY,EAAA7X,MAAMnB,OAClBiZ,OAAQ,EAAA9X,MAAM,OAElB,CACIgI,EAAG,EAAApI,eAAe,kBAClBoY,YAAa,EAAAhY,MAAM,MACnB6X,WAAY,EAAAvY,IAAI,iBAAiB1C,OAC7B,SAAUoG,EAAkBiB,GACNjB,EAAO,GACf6U,WAAa,EAAAzQ,kBAAkBqQ,EAAwBzU,EAASiB,MAGlF6T,OAAQ,EAAA9X,MAAM,MACdgF,MAAO,EAAA7F,QAAQ,gBACf4Y,sBAAuB,EAAA/X,OAAM,MAIzC,yBAA4B,CACxBgC,QAAA,SAAQgB,GACC,IAAA8B,EAAa9B,EAAO,GAKzB,OAJA,EAAA6B,uBAAuB7B,GAClBA,EAAQ,KACTA,EAAQ,GAAgBkB,IAAIY,GAEzBA,GAEX3C,WAAY,IACZD,UAAW,CACP,CACI1B,KAAM,EAAAR,MAAM,4BACZgI,EAAG,EAAApI,eAAe,kBAClBqI,GAAI,EAAArI,eAAe,mBACnBoY,YAAa,eACbhT,MAAO,EAAA7F,QAAQ,oBAK/B,UAAeyY","file":"js/parser.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","\r\n\r\n\r\nimport {\r\n    NodeProp,\r\n    Mark as MarkInterfact,\r\n    Node, Watcher,\r\n    Matched, CONTEXT, Context, Token, SourceLocation,\r\n    MATCHED\r\n} from '../interfaces';\r\n\r\nimport Parser from '../parser'\r\nconst enum MATCH_MARKS {\r\n    BOUNDARY = \"\",\r\n    DEEPTH = \" DEEP\",\r\n    IDENTIFIER = \" ID\",\r\n    MATCH_END = \" END\",\r\n    TYPE_ONLY = \" TYPE\"\r\n    /*\r\n    FOLLOW = \" FOLLOW\",\r\n    NOT = \" NOT\",\r\n    OR = \" OR\",\r\n    AND = \" AND\",*/\r\n}\r\nlet OPERATOR_ID = 0;\r\nabstract class Operator {\r\n    private _factors: Array<[string | number, Array<string | number>] | Operator | Mark>;\r\n    private _watcher: Array<Watcher>;\r\n    public sub_operators = [];\r\n    public test: (token: Token, index?: number) => boolean;\r\n    constructor(public operands: Operands) { }\r\n    public watch(watcher: Watcher) {\r\n        if (this._watcher) {\r\n            this._watcher.push(watcher);\r\n        } else {\r\n            this._watcher = [watcher];\r\n        }\r\n        return this;\r\n    }\r\n    public get factors() {\r\n        if (!this._factors) {\r\n            this._factors = [];\r\n            for (const operand of this.operands) {\r\n                if (operand instanceof Operator || operand instanceof Mark) {\r\n                    this._factors.push(operand);\r\n                } else {\r\n                    let parts = typeof operand === \"string\" ?\r\n                        operand.replace(/^\\s+|\\s+$/g, \"\").split(/\\s+/) :\r\n                        [operand];\r\n                    this._factors.push(\r\n                        [\r\n                            parts[0],\r\n                            parts.length > 1\r\n                                ? parts.slice(1)\r\n                                : [MATCH_MARKS.TYPE_ONLY]\r\n                        ]);\r\n                }\r\n            }\r\n        }\r\n        return this._factors;\r\n    }\r\n    abstract attach(parents: IterationRecord, key: string | null, watchers?: Array<Watcher>): IterationRecord;\r\n    protected map(\r\n        parents: IterationRecord,\r\n        factor: [string | number, Array<string | number>] | Operator | Mark,\r\n        key: string | null,\r\n\r\n        watchers?: Array<Watcher>\r\n    ) {\r\n        let result: IterationRecord = [];\r\n        let _watcher = watchers\r\n            ? this._watcher ?\r\n                this._watcher.concat(watchers)\r\n                : watchers\r\n            : this._watcher;\r\n        if (factor instanceof Operator || factor instanceof Mark) {\r\n            return factor.attach(parents, key, _watcher);\r\n        } else {\r\n            for (const prev_item of parents) {\r\n                let [root, keys] = prev_item;\r\n                (keys = keys.slice()).push([key, _watcher]);\r\n                let parent = this.getNode(root, factor[0]);\r\n                for (const value of factor[1]) {\r\n                    result.push(\r\n                        [\r\n                            this.getNode(parent, value, root),\r\n                            keys,\r\n                            null/*[root, factor[0], value, prev_item]//Loop*/\r\n                        ]\r\n                    );\r\n                }\r\n            }\r\n\r\n        }\r\n        return result;\r\n    }\r\n    private getNode(parent: any, key: string | number, root?: any) {\r\n        let child = parent[key];\r\n        if (child) {\r\n            if (child[MATCH_MARKS.IDENTIFIER] !== OPERATOR_ID) {\r\n                parent[key] = child = { ...child };\r\n                child[MATCH_MARKS.IDENTIFIER] = OPERATOR_ID;\r\n            }\r\n            return child;\r\n        }\r\n\r\n        child = parent[key] = {\r\n            [MATCH_MARKS.IDENTIFIER]: OPERATOR_ID\r\n        };\r\n        root && (child[MATCH_MARKS.DEEPTH] = root[MATCH_MARKS.DEEPTH] + 1);\r\n        return child;\r\n    }\r\n    protected setWrap(records: IterationRecord) {//Loop\r\n        throw 'not used';\r\n        for (const record of records) {\r\n            let prev_item = record, curr_item = prev_item;\r\n            while ((curr_item = prev_item[2] && prev_item[2][3]) && curr_item[2]) {\r\n                prev_item = curr_item;\r\n            }\r\n            if (prev_item[2]) {\r\n                let linked = prev_item[2];\r\n                let node = this.getNode(record[0], linked[1]);\r\n                if (node[linked[2]] && node[linked[2]] !== prev_item[0]) {\r\n                    throw node[linked[2]];\r\n                }\r\n                node[linked[2]] = prev_item[0];\r\n            }\r\n        }\r\n        return records;\r\n    }\r\n    protected getDeepNodes(parents: IterationRecord, key: string | null, watchers?: Array<Watcher>) {\r\n        let children = parents, factors = this.factors;\r\n        for (const factor of factors) {\r\n            children = this.map(children, factor, key, watchers);\r\n        }\r\n        return children;\r\n    }\r\n    protected getNextNodes(parents: IterationRecord, key: string | null, watchers?: Array<Watcher>) {\r\n        let children = [], factors = this.factors;\r\n        for (const factor of factors) {\r\n            Array.prototype.push.apply(children, this.map(parents, factor, key, watchers));\r\n        }\r\n        return children;\r\n    }\r\n}\r\n\r\ntype Operand = string | number | Operator | Mark;\r\ntype Operands = Array<Operand>;\r\ntype IterationRecordItem = [\r\n    Record<string, any>,\r\n    Array<NodeProp>,\r\n    [Record<string, any>, string, string, IterationRecordItem] | null\r\n]\r\ntype IterationRecord = Array<IterationRecordItem>;\r\n\r\nclass Option extends Operator {\r\n    attach(parents: IterationRecord, key: string, watchers?: Array<Watcher>) {\r\n        let children = this.getNextNodes(parents, key, watchers).concat(parents);\r\n        return children;\r\n    }\r\n}\r\nclass Or extends Operator {\r\n    attach(parents: IterationRecord, key: string, watchers?: Array<Watcher>) {\r\n        return this.getNextNodes(parents, key, watchers);\r\n    }\r\n}\r\n\r\nclass Series extends Operator {\r\n    attach(parents: IterationRecord, key: string, watchers?: Array<Watcher>) {\r\n        return this.getDeepNodes(parents, key, watchers);\r\n    }\r\n}\r\n/*\r\nclass And extends Operator  {\r\n    attach(parents: IterationRecord, key: string) {\r\n        throw \"not used\";\r\n        return [];\r\n    }\r\n}\r\nclass Not extends Operator {\r\n    attach(parents: IterationRecord, key: string) {\r\n        throw \"not used\";\r\n        return [];\r\n        \r\n    }\r\n}*/\r\nclass NonCapturing extends Operator {\r\n    attach(parents: IterationRecord, key: string, watchers?: Array<Watcher>) {\r\n        return this.getNextNodes(parents, null, watchers);\r\n    }\r\n}\r\n\r\nclass NonCollecting extends Operator {\r\n    attach(parents: IterationRecord, key: string, watchers?: Array<Watcher>) {\r\n        return this.getNextNodes(parents, \"\", watchers);\r\n    }\r\n}\r\n\r\nclass Loop extends Operator {\r\n    //Loop 内部的 Option 可能会导致 Loop 取值混乱(当前用不到这种情况，不处理这种情况能减少消耗)\r\n    attach(parents: IterationRecord, key: string) {\r\n        throw 'not used';\r\n        //有点耗费性能，不是很必要用这个，已在parser核心部分去除Loop的支持\r\n        let baks = [];\r\n        for (const parent of parents) {\r\n            baks.push(parent[2]);\r\n            parent[2] = null;\r\n        }\r\n        let res = this.setWrap(this.getNextNodes(parents, key));\r\n        for (const index in parents) {\r\n            parents[index][2] = baks[index];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\nclass Mark implements MarkInterfact {\r\n    static MATCHED_RECORD: Matched;\r\n    public key: string;\r\n    public value: any;\r\n    constructor(value?: any) {\r\n        if (typeof value === \"function\") {\r\n            Object.defineProperty(this, \"value\", {\r\n                configurable: true,\r\n                enumerable: true,\r\n                get: value\r\n            });\r\n        } else {\r\n            this.value = value;\r\n        }\r\n    }\r\n    attach(parents: IterationRecord, key: string, watchers?: Array<Watcher>) {\r\n        let value = this.value;\r\n        if (key && value !== undefined) {\r\n            if (key === \"type\") {\r\n                Mark.MATCHED_RECORD[MATCHED.wrapper] = _get_wrapper_function(value);;\r\n            } else {\r\n                this.key = key;\r\n                for (const parent of parents) {\r\n                    parent[1] = parent[1].concat(this);\r\n                }\r\n            }\r\n        }\r\n        return parents;\r\n    }\r\n}\r\n\r\nfunction _Option(...some: Operands) {\r\n    return new Option(some);\r\n}\r\n/*\r\nfunction _Not(...some: Operands) {\r\n    return new Not(some);\r\n}\r\nfunction _And(...some: Operands) {\r\n    return new And(some);\r\n}*/\r\nfunction _Or(...some: Operands) {\r\n    return new Or(some);\r\n}\r\nfunction _Series(...some: Operands) {\r\n    return new Series(some);\r\n}\r\nfunction _NonCapturing(...some: Operands) {\r\n    return new NonCapturing(some);\r\n}\r\nfunction _NonCollecting(...some: Operands) {\r\n    return new NonCollecting(some);\r\n}\r\n\r\n\r\nfunction _Loop(...some: Operands) {\r\n    return new Loop(some);\r\n}\r\nfunction _Mark(some?: any) {\r\n    return new Mark(some);\r\n}\r\nlet NODES: Record<string, (...args: any) => void> = {\r\n    Grouping(node?: Record<string, any>, grouping?: Token) {\r\n        for (const key in node) {\r\n            this[key] = node[key];\r\n        }\r\n        if (grouping) {\r\n            this.range = grouping.range;\r\n            this.loc = grouping.loc;\r\n        }\r\n    },\r\n    Directive(\r\n        type: string,\r\n        expression: Node,\r\n        directive: string,\r\n        range: [number, number],\r\n        loc: SourceLocation\r\n    ) {\r\n        this.type = type;\r\n        this.expression = expression;\r\n        this.directive = directive;\r\n        this.range = range;\r\n        this.loc = loc;\r\n    },\r\n    Script(body: Array<Node>, range: [number, number], loc: SourceLocation) {\r\n        this.type = \"Program\";\r\n        this.sourceType = \"script\";\r\n        this.body = body;\r\n        this.range = range;\r\n        this.loc = loc;\r\n    },\r\n    Module(body: Array<Node>, range: [number, number], loc: SourceLocation) {\r\n        this.type = \"Program\";\r\n        this.sourceType = \"module\";\r\n        this.body = body;\r\n        this.range = range;\r\n        this.loc = loc;\r\n    }\r\n};\r\nfunction _get_adapt(data: any, index: number) {\r\n    return data instanceof Array ? index < data.length\r\n        ? data[index]\r\n        : data[data.length - 1] : data;\r\n}\r\nfunction _get_wrapper_function(type: string) {\r\n    return NODES[type]\r\n        || (\r\n            NODES[type]\r\n            = eval(`(function ${type}(){this.type=\"${type}\"})`)\r\n        );\r\n}\r\nfunction createMatchTree(\r\n    data: Record<string, any> | Array<Record<string, any>>,\r\n    root?: Record<string, any>,\r\n    block_list: Array<string> = [],\r\n    prevent_update = false\r\n) {\r\n    prevent_update || (OPERATOR_ID += 1);\r\n    root = root ? prevent_update ? root : { ...root } : { [MATCH_MARKS.DEEPTH]: -1 };\r\n\r\n    if (data instanceof Array) {\r\n        for (const item of data) {\r\n            root = createMatchTree(item, root, block_list, true);\r\n        }\r\n    } else {\r\n        for (const type in data) {\r\n            let wrapper = _get_wrapper_function(type);\r\n            for (let item of data[type] instanceof Array ? data[type] : [data[type]]) {\r\n                let {\r\n                    collector: collectors,\r\n                    handler: handlers,\r\n                    overload,\r\n                    precedence: precedences = 100,\r\n                    filter: filters,\r\n                    validator: validators\r\n                } = item;\r\n                if (!collectors || ~block_list.indexOf(type)) {\r\n                    continue;\r\n                }\r\n                typeof filters === \"string\" && (filters = data[filters].filter);\r\n                typeof handlers === \"string\" && (handlers = data[handlers].handler);\r\n                typeof validators === \"string\" && (validators = data[validators].validator);\r\n                collectors instanceof Array || (collectors = [collectors]);\r\n\r\n                for (let index = 0; index < collectors.length; index++) {\r\n                    let collector = collectors[index];\r\n\r\n                    let precedence: Matched[MATCHED.precedence] = _get_adapt(precedences, index);\r\n                    let handler: Matched[MATCHED.handler] = _get_adapt(handlers, index);\r\n                    let filter: Matched[MATCHED.filter] = _get_adapt(filters, index);\r\n                    let validator: Matched[MATCHED.validator] = _get_adapt(validators, index);\r\n                    Mark.MATCHED_RECORD = [\r\n                        precedence, null, wrapper, handler, validator, filter\r\n                    ];\r\n                    if (collector instanceof Array) {\r\n                        let _collector = { ...collectors[index - 1] };\r\n                        collector[0] && !(collector[0] instanceof Array) && (collector = [collector]);\r\n                        for (const [key, value] of collector) {\r\n                            _collector[key] = value;\r\n                        }\r\n                        collectors[index] = collector = _collector;\r\n                    }\r\n\r\n                    let nodes: IterationRecord = [[root, [], null]];\r\n\r\n                    //保证所有 key 都是同类型字符开头(否则可能会出现遍历顺序与定义顺序不同)\r\n                    for (const key in collector) {\r\n                        let operator = collector[key];\r\n                        if (!(operator instanceof Operator || operator instanceof Mark)) {\r\n                            operator = _Or(operator);\r\n                        }\r\n                        nodes = operator.attach(nodes, key);\r\n                    }\r\n\r\n                    for (const [last_node, props] of nodes) {\r\n                        let matched_record = Mark.MATCHED_RECORD.slice();\r\n                        matched_record[MATCHED.props] = props;\r\n                        if (!overload && last_node[MATCH_MARKS.MATCH_END]) {\r\n                            console.warn(\r\n                                \"conflict:\",\r\n                                last_node,\r\n                                last_node[MATCH_MARKS.MATCH_END],\r\n                                matched_record\r\n                            );\r\n                        }\r\n                        last_node[MATCH_MARKS.MATCH_END] = matched_record\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    return root;\r\n\r\n}\r\n\r\n\r\n\r\n\r\nfunction _Context(parser: Parser, tokens: Array<Node>): Context {\r\n    let state_stack = [];\r\n    let context: any = new Array(CONTEXT.length);\r\n    context[CONTEXT.parser] = parser;\r\n    context[CONTEXT.tokens] = tokens;\r\n    context[CONTEXT.labelSet] = [];\r\n    context.wrap = wrap;\r\n    context.unwrap = unwrap;\r\n    context.store = store;\r\n    context.restore = restore;\r\n    //context.getToken = getToken;\r\n    return context;\r\n\r\n    /*function getToken(index: number) {\r\n        return context[CONTEXT.tokens][index];\r\n    }*/\r\n    function wrap(key: CONTEXT, value: any) {\r\n        state_stack.push(context[key], key);\r\n        context[key] = value;\r\n        return context;\r\n    };\r\n    function unwrap() {\r\n        context[state_stack.pop()] = state_stack.pop();\r\n        return context;\r\n    };\r\n    function store() {\r\n        let restore_point = state_stack.length;\r\n        for (let index = 0; index < arguments.length; index += 2) {\r\n            wrap(arguments[index], arguments[index + 1]);\r\n        }\r\n        return restore_point;\r\n    }\r\n    function restore(point: number) {\r\n        while (state_stack.length > point) {\r\n            unwrap();\r\n        }\r\n        return state_stack.length;\r\n    }\r\n}\r\nconst FutureReservedWord = [\"enum\", \"export\", \"import\", \"super\"];\r\nconst StrictModeReservedWord = [\r\n    \"implements\", \"interface\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"let\"\r\n];\r\nconst RestrictedWord = [\"eval\", \"arguments\"];\r\n\r\nfunction isFutureReservedWord(id: string) {\r\n    return FutureReservedWord.indexOf(id) >= 0;\r\n}\r\nfunction isStrictModeReservedWord(id: string) {\r\n    return StrictModeReservedWord.indexOf(id) >= 0;\r\n}\r\nfunction isRestrictedWord(id: string) {\r\n    return RestrictedWord.indexOf(id) >= 0;\r\n}\r\n\r\n\r\nfunction _if_strict_throw_err(context: Context, token: Token) {\r\n    if (context[CONTEXT.strict]) {\r\n        context[CONTEXT.parser].err(token);\r\n    }\r\n}\r\nconst THROW_RESTRICT_WORDS_PATTERN = _Or(\r\n    \"Identifier eval arguments\"\r\n).watch(_if_strict_throw_err);\r\nconst THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\r\n    \"Identifier implements interface package private protected public static yield let\"\r\n).watch(_if_strict_throw_err);\r\n\r\nconst IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier\", THROW_STRICT_RESERVED_WORDS_PATTERN);\r\nconst EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"[Expression]\", THROW_STRICT_RESERVED_WORDS_PATTERN);\r\n\r\nconst IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier\").watch(validateIdentifier);\r\nconst EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = _Or(\r\n    \"[Expression]\",\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN\r\n);\r\n\r\n\r\n/*const STRICT_RESERVED_WORDS = _Or(\r\n    \"Identifier implements interface package private protected public static yield let\"\r\n);*/\r\nfunction validateIdentifier(context: Context, node: Node) {\r\n    if (\r\n        context[CONTEXT.strict]\r\n    ) {\r\n        if (!isStrictModeReservedWord(node.name)) {\r\n            return true;\r\n        }\r\n        context[CONTEXT.parser].err(node);\r\n        return false;\r\n    }\r\n}\r\nfunction validateAssignment(context: Context, node: Node) {\r\n    if (\r\n        context[CONTEXT.strict]\r\n    ) {\r\n        if (!(\r\n            isRestrictedWord(node.name)\r\n            || isStrictModeReservedWord(node.name)\r\n        )) {\r\n            return true;\r\n        }\r\n        context[CONTEXT.parser].err(node);\r\n        return false;\r\n    }\r\n}\r\nfunction validateBinding(context: Context, node: Node) {\r\n    if (validateAssignment(context, node) === true) {\r\n        let binding_set = context[CONTEXT.bindingSet];\r\n        if (binding_set) {\r\n            binding_set.push(node.name);\r\n            if (binding_set.indexOf(node.name) !== binding_set.length - 1) {\r\n                context[CONTEXT.parser].err(node);\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction validateLineTerminator([collected, parser, tokens, , right]: Context) {\r\n    if (collected._next) {\r\n        delete collected._next;\r\n    } else {\r\n        let next_token = tokens[right + 1];\r\n        if (next_token && next_token.loc.start.line === collected.loc.end.line) {\r\n            parser.err(next_token);\r\n        }\r\n    }\r\n    return collected;\r\n}\r\n\r\nlet join_content = function ([collected]: Context) {\r\n    let { success, content } = collected;\r\n    if (success) {\r\n        success.content.push(content);\r\n        return success;\r\n    } else {\r\n        collected.content = [content];\r\n        return collected;\r\n    }\r\n};\r\n\r\nlet TYPE_ALIAS = {};\r\n\r\nconst ASSIGNMENT_PUNCTUATORS_PATTERN = _Or(\"Punctuator = += -= **= *= /= %= <<= >>= >>>= &= ^= |=\");\r\n\r\nlet AWAIT_LIST: Array<() => void> = [];\r\n\r\nconst MODULE_ITEM_PATTERN = _Or(\r\n    \"ImportDeclaration\",\r\n    \"ExportAllDeclaration\",\r\n    \"ExportNamedDeclaration\",\r\n    \"ExportDefaultDeclaration\"\r\n);\r\nconst STATEMANT_LIST_ITEM_PATTERN = _Or(\"[Declaration]\", \"[Statement]\");\r\n\r\nconst RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN = _Or(\r\n    \"SwitchCase\",\r\n    MODULE_ITEM_PATTERN,\r\n    STATEMANT_LIST_ITEM_PATTERN\r\n);\r\nconst TOPLEVEL_ITEM_PATTERN = _Or(\r\n    MATCH_MARKS.BOUNDARY,\r\n    \"SwitchCase\",\r\n    MODULE_ITEM_PATTERN,\r\n    STATEMANT_LIST_ITEM_PATTERN\r\n);\r\n\r\nfunction isAligned(context: Context, left: number, right: number) {\r\n    let tokens = context[CONTEXT.tokens];\r\n    for (let index = left; index < right; index++) {\r\n        if (tokens[index].loc.end.line !== tokens[index + 1].loc.start.line) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport {\r\n    Mark, isAligned,\r\n    STATEMANT_LIST_ITEM_PATTERN,\r\n    RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    AWAIT_LIST,\r\n    join_content,\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    ASSIGNMENT_PUNCTUATORS_PATTERN,\r\n    validateBinding, validateLineTerminator,\r\n    NODES,\r\n    TYPE_ALIAS,\r\n    MATCH_MARKS,\r\n    createMatchTree,\r\n    isRestrictedWord,\r\n    isFutureReservedWord,\r\n    isStrictModeReservedWord,\r\n    validateIdentifier,\r\n    validateAssignment,\r\n    _Context,\r\n    _Option, _Or, _Series, _NonCapturing, _NonCollecting, _Mark, _Loop,\r\n}\r\n","\r\nimport {\r\n    Token, Node, Context, CONTEXT\r\n} from '../interfaces';\r\nimport {\r\n    MATCH_MARKS,\r\n    createMatchTree,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark\r\n} from './head'\r\nimport Parser from '../parser'\r\n\r\n\r\nimport {\r\n    Expressions,\r\n    EXPRESSION_TREE\r\n} from './expression'\r\nimport Declarations from './declaration'\r\nimport Statements from './statement'\r\nimport ModuleDeclarations from './module_declaration'\r\n\r\n\r\n\r\nlet EXPRESSION_ITEM_PATTERN = {};\r\nlet DECLARATION_ITEM_PATTERN = {};\r\nlet STATEMENT_ITEM_PATTERN = {};\r\nlet STATEMENT_LIST_ITEM_PATTERN = {};\r\nlet MODULE_ITEM_PATTERN = {};\r\nfor (\r\n    const [descriptor, patterns]\r\n    of\r\n    [\r\n        [\r\n            Expressions,\r\n            [EXPRESSION_ITEM_PATTERN]\r\n        ],\r\n        [\r\n            Declarations,\r\n            [DECLARATION_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\r\n        ],\r\n        [\r\n            Statements,\r\n            [STATEMENT_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\r\n        ],\r\n        [\r\n            ModuleDeclarations,\r\n            [MODULE_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\r\n        ],\r\n    ] as Array<[Record<string, any>, Array<Record<string, boolean>>]>\r\n) {\r\n    for (const key in descriptor) {\r\n        if (key) {\r\n            for (const pattern of patterns) {\r\n                pattern[key] = true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction isExpression(node: Node) {\r\n    return EXPRESSION_ITEM_PATTERN[node.type];\r\n}\r\nfunction isDeclaration(node: Node) {\r\n    return DECLARATION_ITEM_PATTERN[node.type];\r\n}\r\nfunction isStatement(node: Node) {\r\n    return STATEMENT_ITEM_PATTERN[node.type];\r\n}\r\nfunction isStatementListItem(node: Node) {\r\n    return STATEMENT_LIST_ITEM_PATTERN[node.type];\r\n}\r\nfunction isModuleItem(node: Node) {\r\n    return MODULE_ITEM_PATTERN[node.type];\r\n}\r\n\r\n\r\nconst SYNTAX_TREE = createMatchTree([\r\n    Declarations,\r\n    ModuleDeclarations,\r\n    Statements\r\n], EXPRESSION_TREE);\r\n\r\n\r\nfunction parse_next_statement(context: Context, start = context[CONTEXT.right] + 1) {\r\n    let parser = context[CONTEXT.parser];\r\n    if (\r\n        parser.parseCustom(\r\n            parser.SYNTAX_TREE,\r\n            context,\r\n            start,\r\n            isStatementListItem\r\n        )\r\n    ) {\r\n        return 0;\r\n    }\r\n}\r\nfunction get_inner_group(token: Token) {\r\n    while (\r\n        token.content.length === 1\r\n        && token.content[0].value === \"()\"\r\n        && token.content[0].type === \"Punctuator\"\r\n    ) {\r\n        token = token.content[0];\r\n    }\r\n    return token;\r\n}\r\n\r\nfunction extract_success(parser: Parser, nodes: Array<Node>) {\r\n    let res: Array<Node> = nodes;\r\n    if (nodes.length) {\r\n        if (nodes[0].type === \"Success\") {\r\n            res = nodes[0].content;\r\n            nodes.length > 1 && parser.err(...nodes.slice(1));\r\n        } else {\r\n            res = [];\r\n            parser.err(...nodes);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfunction parse_and_extract(match_tree: Record<string, any>, context: Context, node: Node) {\r\n    let [, parser] = context;\r\n    let tokens = node.content;\r\n    if (tokens.length) {\r\n        context[CONTEXT.tokens] = tokens;\r\n        parser.parseCustom(match_tree, context);\r\n        tokens = extract_success(parser, tokens)\r\n    }\r\n    return tokens;\r\n}\r\n/*\r\nfunction isCommaSeparator(node) {\r\n    return node.type === \"Punctuator\" && node.value === \",\";\r\n}*/\r\n\r\n\r\nexport {\r\n    parse_next_statement,\r\n    get_inner_group,\r\n    extract_success,\r\n    parse_and_extract,\r\n    MATCH_MARKS,\r\n    isExpression, isDeclaration, isStatement, isStatementListItem, isModuleItem,\r\n    SYNTAX_TREE, EXPRESSION_TREE\r\n}\r\n\r\n\r\n\r\n","import {\r\n    Node, Token, Context, CONTEXT, MATCHED\r\n} from '../interfaces';\r\nimport {\r\n    createMatchTree,\r\n    _Option, _Or, _Series, _NonCollecting, _NonCapturing, _Mark,\r\n    TYPE_ALIAS, _Context, _Loop, NODES, validateIdentifier, validateAssignment,\r\n    validateBinding, validateLineTerminator, ASSIGNMENT_PUNCTUATORS_PATTERN, join_content,\r\n\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    MATCH_MARKS,\r\n    isAligned\r\n} from './head'\r\nimport { extract_success, parse_and_extract } from './index';\r\n\r\nimport {\r\n    Patterns,\r\n    parseArrayPattern,\r\n    parseObjectPattern\r\n} from './pattern';\r\nconst Grouping = NODES.Grouping;\r\n\r\n\r\nconst ARGUMENTS_PATTERN = _Or(\"Punctuator ()\").watch(\r\n    function (context: Context, token: Token) {\r\n        let [collected] = context;\r\n        collected.arguments = parse_arguments(context, token.content);\r\n    }\r\n);\r\n\r\n\r\nconst Expressions: Record<string, any> = {\r\n    \"\": [\r\n        {\r\n            handler(context: Context) {\r\n                let [collected, parser] = context;\r\n                context.wrap(CONTEXT.bindingSet, null);\r\n                let node = parser.parseExpression(context, collected.token);\r\n                context.unwrap();\r\n                return node ? new Grouping(node, collected.token) : [];\r\n            },\r\n            precedence: 20,\r\n            collector: {\r\n                type: _Mark(\"Grouping\"),\r\n                token: \"Punctuator ()\"\r\n            }\r\n        },\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, tokens, , right] = context;\r\n                tokens[right] instanceof Grouping && parser.err(tokens[right]);\r\n                return true;\r\n            },\r\n            filter(context: Context) {\r\n                return context[CONTEXT.spreadElement] === context[CONTEXT.tokens];\r\n            },\r\n            precedence: 1.5,\r\n            collector: {\r\n                type: _Mark(\"SpreadElement\"),\r\n                token: _NonCollecting(\"Punctuator ...\"),\r\n                argument: \"[Expression]\"\r\n            }\r\n        },\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, tokens, , right] = context;\r\n                let argument = tokens[right];\r\n                argument instanceof Grouping && parser.err(argument);\r\n                return true;\r\n            },\r\n            filter: function (context: Context) {\r\n                return context[CONTEXT.bindingElement] === context[CONTEXT.tokens];\r\n            },\r\n            precedence: 1.5,\r\n            collector: {\r\n                type: _Mark(\"RestElement\"),\r\n                token: _NonCollecting(\"Punctuator ...\"),\r\n                argument: _Or(_Or(\"Identifier\").watch(validateBinding), \"ArrayPattern\", \"ObjectPattern\")\r\n            }\r\n        }\r\n    ],\r\n    \"Identifier\": [\r\n    ],\r\n    \"Literal\": [//已在 tokenizer => token_hooks 中处理\r\n        {\r\n            handler(context: Context) {\r\n                let [collected, parser] = context;\r\n                let { str: value, octal, value: raw } = collected.value;\r\n                collected.value = value;\r\n                collected.raw = raw;\r\n                if (octal && context[CONTEXT.strict]) {\r\n                    parser.err(collected);\r\n                }\r\n                return collected;\r\n            },\r\n            collector: {\r\n                value: \"String\",\r\n                raw: _Mark(null)\r\n            }\r\n        }\r\n    ],\r\n    \"ThisExpression\": {\r\n        collector: {\r\n            token: _NonCollecting(\"Keyword this\")\r\n        }\r\n    },\r\n    \"TemplateLiteral\": {\r\n        handler(context: Context) {\r\n            let [collected, parser, tokens, , right] = context;\r\n            let content = tokens[right].content;\r\n            for (const item of content) {\r\n                if (item.type === \"TemplateElement\") {\r\n                    collected.quasis.push(item);\r\n                } else {\r\n                    collected.expressions.push(parser.parseExpression(context, item));\r\n                }\r\n            }\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                _: _NonCapturing(_Option(\"[Expression]\")),\r\n                __: _NonCollecting(\"Template ``\"),\r\n                quasis: _Mark(Array),\r\n                expressions: _Mark(Array)\r\n            }\r\n        ]\r\n    },\r\n    \"ArrayExpression\": {\r\n        precedence: 20,\r\n        collector: {\r\n            elements: _Or(\"Punctuator []\").watch(\r\n                function (context: Context, node: Node) {\r\n                    let [collected] = context;\r\n                    context.wrap(CONTEXT.spreadElement, node.content);\r\n                    collected.elements = parse_and_extract(ARRAY_ELEMENTS_TREE, context, node);\r\n                    context.unwrap();\r\n                }\r\n            ),\r\n        }\r\n\r\n    },\r\n    \"ObjectExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.properties = parse_and_extract(OBJECT_PROPERTIES_TREE, context, collected.properties);\r\n            return collected;\r\n        },\r\n        precedence: 20,\r\n        collector: {\r\n            properties: \"Punctuator {}\",\r\n        }\r\n\r\n    },\r\n    \"FunctionExpression\": [\r\n        {\r\n            handler: parse_function_expression,\r\n            collector: [\r\n                {\r\n                    async: _Or(\r\n                        _Series(_Mark(true), _NonCollecting(\"Keyword async\")),\r\n                        _Mark(false)\r\n                    ),\r\n                    __: _NonCollecting(\"Keyword function\"),\r\n                    generator: _Or(\r\n                        _Series(_Mark(true), _NonCollecting(\"Punctuator *\")),\r\n                        _Mark(false)\r\n                    ),\r\n                    id: _Or(IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                    params: \"Punctuator ()\",\r\n                    body: \"Punctuator {}\",\r\n                    expression: _Mark(false)\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            handler([collected, parser]: Context) {\r\n                return parser.parseKeyword(collected.async);\r\n            },\r\n            filter: [\r\n                function () {\r\n                    return false;\r\n                },\r\n                isAligned\r\n            ],\r\n            collector: [\r\n                { _: _Series(\"Identifier async\", \"Identifier\") },\r\n                {\r\n                    async: \"Identifier async\",\r\n                    _next: _NonCapturing(\"Keyword function\"),\r\n                },\r\n                {\r\n                    async: \"Identifier async\",\r\n                    params: _NonCapturing(\"Punctuator ()\", \"Identifier\"),\r\n                    token: _NonCapturing(\"Punctuator =>\"),\r\n                },\r\n            ]\r\n        }\r\n    ],\r\n    \"ArrowFunctionExpression\": {\r\n        handler(context: Context) {\r\n            let [collected, parser, tokens, left] = context;\r\n            let { async, token, params, body, expression } = collected;\r\n            if (body) {\r\n                if (params.type === \"Identifier\") {\r\n                    validateAssignment(context, params);\r\n                    collected.params = [params];\r\n                } else {\r\n                    collected.params = parse_params(context, params)\r\n                }\r\n                if (!expression) {\r\n                    let body_context = _Context(parser, body.content);\r\n                    body_context[CONTEXT.inFunctionBody] = body.content;\r\n                    body_context[CONTEXT.allowAwait] = async;\r\n                    collected.body = {\r\n                        type: \"BlockStatement\",\r\n                        body: parser.parseBlock(body_context)\r\n                    };\r\n                }\r\n                return collected;\r\n            } if (token) {\r\n                token.value = \"_=>\";\r\n                let body_context = _Context(parser, tokens);\r\n                body_context[CONTEXT.strict] = context[CONTEXT.strict];\r\n                body_context[CONTEXT.allowAwait] = !!async;\r\n                if (\r\n                    parser.parseCustom(\r\n                        parser.EXPRESSION_TREE,\r\n                        body_context,\r\n                        left,\r\n                        (node: Node) => true/*node.type === \"ArrowFunctionExpression\"*/\r\n                    )\r\n                ) {\r\n                    return null;\r\n                }\r\n            }\r\n        },\r\n        precedence: new Number(3),\r\n        collector: [\r\n            {//占位使 () 不会被单独收集为表达式\r\n                async: _Or(\r\n                    _Series(_Mark(true), _NonCollecting(\"Keyword async\")),\r\n                    _Mark(false)\r\n                ),\r\n                generator: _Mark(false),\r\n                id: _Mark(null),\r\n                params: _Or(\"Punctuator ()\", \"Identifier\"),\r\n                token: _NonCollecting(\"Punctuator =>\"),\r\n                body: \"Punctuator {}\",\r\n                expression: _Mark(false)\r\n            },\r\n            [\r\n                [\"token\", \"Punctuator =>\"],\r\n                [\"body\", _Mark()]\r\n            ],\r\n            [\r\n                //_=>作用为隔断匹配，使后续的表达式使用当前方法声明的环境\r\n                [\"token\", _NonCollecting(\"Punctuator _=>\")],\r\n                [\"body\", _Option(\"[Expression]\")],\r\n                [\"expression\", _Mark(true)]\r\n            ]\r\n        ]\r\n    },\r\n    \"ClassExpression\": {\r\n        collector: [\r\n            {\r\n                _: _NonCollecting(\"Keyword class\"),\r\n                id: _Or(IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                superClass: _Or(\r\n                    _Series(\r\n                        _NonCollecting(\"Keyword extends\"),\r\n                        IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN\r\n                    ),\r\n                    _Mark(null)\r\n                ),\r\n                body: _Or(\"Punctuator {}\").watch(\r\n                    function (context: Context, body: Token) {\r\n                        let [collected] = context;\r\n                        collected.body = {\r\n                            type: \"ClassBody\",\r\n                            body: parse_and_extract(METHOD_DEFINITIONS_TREE, context, body),\r\n                            range: body.range,\r\n                            loc: body.loc\r\n                        };\r\n                    }\r\n                )\r\n            }\r\n        ]\r\n    },\r\n    \"TaggedTemplateExpression\": {\r\n        collector: [\r\n            {\r\n                tag: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                quasi: \"TemplateLiteral\"\r\n            }\r\n        ]\r\n    },\r\n    \"MemberExpression\": [\r\n        {\r\n            precedence: 20,\r\n            collector: {\r\n                object: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                property: _Series(\r\n                    _NonCollecting(\"Punctuator .\"),\r\n                    _Or(\r\n                        \"Identifier\",\r\n                        _Or(\"Keyword\").watch(\r\n                            function (context: Context, token: Token) {\r\n                                let [collected, parser] = context;\r\n                                collected.property = parser.parseIdentifier(token);\r\n                            }\r\n                        )\r\n                    )\r\n                ),\r\n                computed: _Mark(false)\r\n            }\r\n        },\r\n        {\r\n            filter: \"CallExpression\",\r\n            precedence: 20,\r\n            collector: {\r\n                object: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                property: _Or(\"Punctuator []\").watch(\r\n                    function (context: Context, token: Token) {\r\n                        let [collected, parser] = context;\r\n                        collected.property = parser.parseExpression(context, token);\r\n                    }\r\n                ),\r\n                computed: _Mark(true)\r\n            }\r\n        }\r\n    ],\r\n    \"Super\": {\r\n        handler(context: Context) {\r\n            let [collected, parser, tokens, left, right] = context;\r\n            if (context[CONTEXT.inFunctionBody]) {\r\n                if (right === left) {\r\n                    parser.err(tokens[left]);\r\n                }\r\n            } else {\r\n                parser.err(tokens[left]);\r\n            }\r\n            return context[CONTEXT.collected];\r\n        },\r\n        collector: {\r\n            token: _NonCollecting(\"Keyword super\"),\r\n            _next: _NonCapturing(\"Punctuator () . []\")\r\n        }\r\n    },\r\n    \"MetaProperty\": {\r\n        handler([collected]: Context) {\r\n            collected.meta.type = \"Identifier\";\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                meta: \"Keyword import\",\r\n                _: _NonCollecting(\"Punctuator .\"),\r\n                property: \"Identifier meta\"\r\n            },\r\n            {\r\n                meta: \"Keyword new\",\r\n                _: _NonCollecting(\"Punctuator .\"),\r\n                property: \"Identifier target\"\r\n            }\r\n        ]\r\n    },\r\n    \"NewExpression\": {\r\n        precedence: new Number(20),//memberexpression\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword new\"),\r\n                _: _Option(_NonCollecting(\"Punctuator ++ --\").watch(\r\n                    function (context: Context, token: Token) {\r\n                        context[CONTEXT.parser].err(token);\r\n                    }\r\n                )),\r\n                callee: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                arguments: _Or(_Mark(Array), ARGUMENTS_PATTERN)\r\n            }\r\n        ]\r\n    },\r\n    \"CallExpression\": {\r\n        precedence: 20,\r\n        filter(context: Context, left: number) {\r\n            let tokens = context[CONTEXT.tokens];\r\n            let first_token = tokens[left], second_token = tokens[left + 1];\r\n            if (second_token === context[CONTEXT.rightAssociativeNode]) {\r\n                return false;\r\n            }\r\n            if (\r\n                first_token.type !== \"UpdateExpression\"\r\n                || first_token instanceof Grouping\r\n                || isAligned(context, left, left + 1)\r\n            ) {\r\n                return true;\r\n            }\r\n            context[CONTEXT.rightAssociativeNode] = second_token;\r\n        },\r\n        collector: {\r\n            callee: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n            arguments: ARGUMENTS_PATTERN\r\n        }\r\n\r\n    },\r\n    \"UpdateExpression\": [\r\n        {\r\n            handler(context: Context) {\r\n                let [collected] = context;\r\n                collected.operator = collected.operator.value;\r\n                return collected;\r\n            },\r\n            precedence: 17,\r\n            collector: {\r\n                operator: \"Punctuator ++ --\",\r\n                argument: _Or(\"MemberExpression\", IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\r\n                prefix: _Mark(true)\r\n            }\r\n        },\r\n        {\r\n            validator(context: Context) {\r\n                let collected = context[CONTEXT.parser].createNode(context);\r\n                collected.operator = collected.operator.value;\r\n                return collected;\r\n            },\r\n            filter: [\r\n                function (context: Context, left: number, right: number) {\r\n                    return isAligned(context, left, left + 1);\r\n                },\r\n                isAligned,\r\n            ],\r\n            precedence: 18,\r\n            collector: [\r\n                {\r\n                    argument: _Or(\"MemberExpression\", IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\r\n                    operator: \"Punctuator ++ --\",\r\n                    _: _NonCapturing(_Option(\"Punctuator .\").watch(\r\n                        function (context: Context, token: Token) {\r\n                            context[CONTEXT.parser].err(token);\r\n                        }\r\n                    )),\r\n                    prefix: _Mark(false)\r\n                },\r\n                [\"_\", _NonCapturing(\"Punctuator [] ()\").watch(\r\n                    function (context: Context, token: Token) {\r\n                        context[CONTEXT.parser].err(token);\r\n                    }\r\n                )]\r\n            ]\r\n        }\r\n    ],\r\n    \"AwaitExpression\": [\r\n        {\r\n            precedence: 17,\r\n            filter(context: Context) {\r\n                return context[CONTEXT.allowAwait];\r\n            },\r\n            collector: {\r\n                token: _NonCollecting(\"Keyword await\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\r\n            }\r\n        },\r\n        {\r\n            handler([collected, parser]: Context) {\r\n                return parser.parseIdentifier(collected.token);\r\n            },\r\n            filter(context: Context) {\r\n                return !context[CONTEXT.allowAwait];\r\n            },\r\n            collector: {\r\n                token: \"Keyword await\",\r\n            }\r\n        },\r\n    ],\r\n    \"UnaryExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.operator = collected.operator.value;\r\n            return collected;\r\n        },\r\n        precedence: 17,\r\n        collector: [\r\n            {\r\n                operator: _Or(\"Punctuator ~ ! + -\", \"Keyword delete void typeof\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                prefix: _Mark(true)\r\n            }\r\n        ]\r\n    },\r\n    \"BinaryExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.operator = collected.operator.value;\r\n            return collected;\r\n        },\r\n        validator(context: Context) {\r\n            return context[CONTEXT.right] - context[CONTEXT.left] >= 2\r\n        },\r\n        precedence: [16, 15, 14, 13, 12, 11, 10, 9, 8, 7],\r\n        collector: [\r\n            {\r\n                left: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                operator: `Punctuator **`,\r\n                right: _Option(EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN)\r\n            },\r\n            [\"operator\", `Punctuator * / %`],\r\n            [\"operator\", `Punctuator + -`],\r\n            [\"operator\", `Punctuator << >> >>>`],\r\n            [\"operator\", _Or(`Punctuator < <= > >=`, `Keyword in instanceof`)],\r\n            [\"operator\", `Punctuator == != === !==`],\r\n            [\"operator\", `Punctuator &`],\r\n            [\"operator\", `Punctuator ^`],\r\n            [\"operator\", `Punctuator |`],\r\n            [\"operator\", `Punctuator ??`]\r\n        ]\r\n    },\r\n    \"LogicalExpression\": {\r\n        validator(context: Context) {\r\n            if (context[CONTEXT.right] - context[CONTEXT.left] === 2) {\r\n                let collected = context[CONTEXT.parser].createNode(context);\r\n                collected.operator = collected.operator.value;\r\n                return collected;\r\n            }\r\n        },\r\n        precedence: [6, 5],\r\n        collector: [\r\n            {\r\n                left: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                operator: \"Punctuator &&\",\r\n                right: _Option(EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN)\r\n            },\r\n            [\"operator\", \"Punctuator ||\"]\r\n        ]\r\n    },\r\n    \"ConditionalExpression\": [\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, tokens, left, right] = context;\r\n                if (right - left >= 4) {\r\n                    return true;\r\n                }\r\n                if (!context[CONTEXT.isExpression] || context[CONTEXT.bindingElement] === tokens) {\r\n                    let store = context.store(CONTEXT.isExpression, true, CONTEXT.bindingElement, null);\r\n                    parser.parseCustom(\r\n                        parser.EXPRESSION_TREE,\r\n                        context,\r\n                        left,\r\n                        (node: Node) => node.type === \"ConditionalExpression\"\r\n                    );\r\n                    context.restore(store);\r\n                    return null;\r\n                }\r\n            },\r\n            precedence: new Number(3),//与 Assignment 为右优先\r\n            collector: [\r\n                {\r\n                    test: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,//EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS\r\n                    token: _NonCollecting(\"Punctuator ?\")\r\n                },\r\n                [\"consequent\", EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN],\r\n                [\"_\", _NonCollecting(\"Punctuator :\")],\r\n                [\"alternate\", EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN]\r\n            ]\r\n        },\r\n    ],\r\n    \"YieldExpression\": [\r\n        {\r\n            filter(context: Context) {\r\n                return context[CONTEXT.allowYield];\r\n            },\r\n            precedence: 2,\r\n            collector: [\r\n                {\r\n                    token: _NonCollecting(\"Keyword yield\"),\r\n                    _: _NonCollecting(\"Punctuator *\"),\r\n                    argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    delegate: _Mark(true)\r\n                },\r\n                {\r\n                    token: _NonCollecting(\"Keyword yield\"),\r\n                    argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    delegate: _Mark(false)\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            handler([collected, parser]: Context) {\r\n                return parser.parseIdentifier(collected.token);\r\n            },\r\n            filter(context: Context) {\r\n                return !context[CONTEXT.allowYield];\r\n            },\r\n            collector: {\r\n                token: \"Keyword yield\"\r\n            }\r\n        },\r\n    ],\r\n    \"AssignmentExpression\": {\r\n        validator: \"LogicalExpression\",\r\n        precedence: new Number(3),//Right-associative\r\n        collector: {\r\n            left: _Or(\r\n                _Or(\"[Expression]\").watch(\r\n                    function (context: Context, expr: Node) {\r\n                        context[CONTEXT.parser].err(expr);\r\n                    }\r\n                ),\r\n                \"AssignmentExpression\",\r\n                \"MemberExpression\",\r\n                \"AssignmentPattern\",\r\n                \"ArrayPattern\",\r\n                \"ObjectPattern\",\r\n                IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\r\n            ),\r\n            operator: ASSIGNMENT_PUNCTUATORS_PATTERN,\r\n            right: _Option(\"[Expression]\")//占位避免错误断句\r\n        }\r\n    },\r\n    \"SequenceExpression\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            let expressions: Array<Node> = collected.expressions;\r\n            if (expressions[0] instanceof NODES.SequenceExpression) {\r\n                expressions[0].expressions.push(expressions[1]);\r\n                collected.expressions = expressions[0].expressions\r\n            }\r\n            return collected\r\n        },\r\n        validator(context: Context) {\r\n            let [, , , left, right] = context;\r\n            if (right - left === 2) {\r\n                return true;\r\n            }\r\n        },\r\n        precedence: 1,\r\n        collector: {\r\n            expressions: _Series(\r\n                EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _NonCollecting(\"Punctuator ,\"),\r\n                _Option(EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN)\r\n            )\r\n        }\r\n\r\n    }\r\n}\r\n\r\nconst COMPUTED_PROPERTY_NAME_PATTERN = _Or(\"Punctuator []\").watch(\r\n    function (context: Context, token: Token) {\r\n        let [collected, parser] = context;\r\n        collected.computed = true;\r\n        collected.key = parser.parseExpression(context, token, PRIMARY_EXPRESSION_TREE);\r\n    }\r\n);\r\n\r\nconst PROPERTY_NAME_PATTERN = _Or(\r\n    _Or(\r\n        _Or(\"Identifier\", \"Keyword\", \"Literal\").watch(\r\n            function (context: Context, token: Token) {\r\n                if (token instanceof Grouping) {\r\n                    context[CONTEXT.parser].err(token);\r\n                }\r\n            }\r\n        ),\r\n        COMPUTED_PROPERTY_NAME_PATTERN\r\n    ).watch(\r\n        function (context: Context) {\r\n            let [collected, parser] = context;\r\n            let { key } = collected;\r\n            switch (key.type) {\r\n                case \"Keyword\":\r\n                    collected.key = parser.parseIdentifier(key);\r\n                    break;\r\n                case \"Literal\":\r\n                    if (key.regex) {\r\n                        parser.err(key);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    )\r\n);\r\n\r\n\r\nconst MethodDefinitions = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: \"MethodDefinition\",\r\n            }\r\n        ]\r\n    },\r\n    \"\": {\r\n        validator(context: Context) {\r\n            context[CONTEXT.start] = context[CONTEXT.end] = context[CONTEXT.right];\r\n            return [];\r\n        },\r\n        collector: {\r\n            _: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n            __: \"Punctuator ;\"\r\n        }\r\n    },\r\n    MethodDefinition: {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            let { value } = collected;\r\n            collected.kind = value.kind;\r\n            delete value.kind;\r\n            collected.computed = value.computed;\r\n            delete value.computed;\r\n            collected.key = value.key;\r\n            delete value.key;\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                key: _Mark(\"\"),\r\n                static: _Mark(true),\r\n                computed: _Mark(false),\r\n                _static: _NonCollecting(\"Identifier static\"),\r\n                value: \"FunctionExpression\",\r\n                kind: _Mark(\"\"),\r\n            },\r\n            [\r\n                [\"static\", _Mark(false)],\r\n                [\"_static\", _Mark()]\r\n            ]\r\n        ]\r\n    },\r\n    FunctionExpression: {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            let kind = collected.kind;\r\n            let param_count: number;\r\n            if (typeof kind === \"object\") {\r\n                collected.kind = kind.name;\r\n                param_count = collected.kind === \"get\" ? 0 : 1;\r\n            }\r\n            parse_function_expression(context, param_count);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                static: _Option(_NonCapturing(\"Identifier static\")),\r\n                async: _Or(\r\n                    _Series(_Mark(true), _NonCollecting(\"Identifier async\")),\r\n                    _Mark(false)\r\n                ),\r\n                generator: _Or(\r\n                    _Series(_Mark(true), _NonCollecting(\"Punctuator *\")),\r\n                    _Mark(false)\r\n                ),\r\n                kind: _Mark(\"method\"),\r\n                computed: _Mark(false),\r\n                key: PROPERTY_NAME_PATTERN,\r\n                id: _Mark(null),\r\n                params: \"Punctuator ()\",\r\n                expression: _Mark(false),\r\n                body: \"Punctuator {}\"\r\n            },\r\n            [\r\n                [\"generator\", _Mark(false)],\r\n                [\"kind\", \"Identifier get set\"]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst Arguments = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        //precedence: 0,\r\n        collector: {\r\n            success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n            content: _Or(\"SpreadElement\", EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\r\n            _: _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY),\r\n        }\r\n    }\r\n}\r\n\r\nconst Params = {\r\n    \"Success\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            if (collected.content instanceof Grouping) {\r\n                parser.err(collected.content);\r\n            }\r\n            return join_content(context);\r\n        },\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: \"AssignmentPattern\",\r\n                _: _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY),\r\n            },\r\n            [\"content\", _Or(\"Identifier\").watch(validateBinding)],\r\n            [\"content\", _Or(\"ArrayPattern\", \"ObjectPattern\")],\r\n            [\r\n                [\"content\", \"RestElement\"],\r\n                [\"_\", _NonCollecting(MATCH_MARKS.BOUNDARY)]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst ArrayElements = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: _Or(\"SpreadElement\", EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN),\r\n                _: _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY),\r\n            },\r\n            [\r\n                [\"content\", _Mark(null)],\r\n                [\"_\", _NonCollecting(\"Punctuator ,\")]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\nconst ObjectProperties = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n                content: \"Property\",\r\n            }\r\n        ]\r\n    },\r\n    \"Property\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            let { type, key, value, kind, computed, method, shorthand, range, loc } = collected;\r\n            let param_count = undefined;\r\n            switch (true) {\r\n                case typeof kind === \"object\":\r\n                    kind = kind.name;\r\n                    param_count = kind === \"get\" ? 0 : 1;\r\n                case method:\r\n                    value = context[CONTEXT.collected] = new NODES.FunctionExpression();\r\n                    value.async = !!collected.async;\r\n                    value.generator = !!collected.generator;\r\n                    value.id = null;\r\n                    value.params = collected.params;\r\n                    value.body = collected.body;\r\n                    value.expression = false;\r\n                    value.range = range;\r\n                    value.loc = loc;\r\n                    value = parse_function_expression(context, param_count);\r\n                    break;\r\n            }\r\n            return { type, key, value: value || key, kind, computed, method, shorthand, range, loc };\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                key: PROPERTY_NAME_PATTERN,//\"TemplateLiteral\"\r\n                value: _Series(_NonCollecting(\"Punctuator :\"), EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN),\r\n                _next: _NonCollecting(_Or(MATCH_MARKS.BOUNDARY, \"Punctuator ,\")),\r\n                kind: _Mark(\"init\"),\r\n                computed: _Mark(false),\r\n                method: _Mark(false),\r\n                shorthand: _Mark(false),\r\n            },\r\n            [\r\n                [\"key\", \"Identifier\"],\r\n                [\"value\", _Mark(null)],\r\n                [\"shorthand\", _Mark(true)]\r\n            ],\r\n            {\r\n                _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                async: _Option(\"Identifier async\"),\r\n                generator: _Option(\"Punctuator *\"),\r\n                kind: _Mark(\"init\"),\r\n                key: PROPERTY_NAME_PATTERN,\r\n                params: \"Punctuator ()\",\r\n                body: \"Punctuator {}\",\r\n                _next: _NonCollecting(_Or(MATCH_MARKS.BOUNDARY, \"Punctuator ,\")),\r\n                computed: _Mark(false),\r\n                method: _Mark(true),\r\n                shorthand: _Mark(false),\r\n            },\r\n            [\r\n                [\"async\", _Mark(false)],\r\n                [\"generator\", _Mark(false)],\r\n                [\"kind\", \"Identifier get set\"],\r\n                [\"method\", _Mark(false)]\r\n            ]\r\n        ]\r\n    }\r\n}\r\n\r\n\r\nlet PRIMARY_EXPRESSION_TREE = createMatchTree(\r\n    [Expressions, Patterns],\r\n    undefined,\r\n    [\"SequenceExpression\"]\r\n);\r\nlet METHOD_DEFINITIONS_TREE = createMatchTree(\r\n    MethodDefinitions, PRIMARY_EXPRESSION_TREE\r\n);\r\nlet ARRAY_ELEMENTS_TREE = createMatchTree(ArrayElements, PRIMARY_EXPRESSION_TREE);\r\nlet OBJECT_PROPERTIES_TREE = createMatchTree(\r\n    ObjectProperties,\r\n    PRIMARY_EXPRESSION_TREE\r\n);\r\n\r\nconst PARAMS_TREE = createMatchTree(\r\n    Params,\r\n    PRIMARY_EXPRESSION_TREE\r\n);\r\nconst ARGUMENTS_TREE = createMatchTree(\r\n    Arguments,\r\n    PRIMARY_EXPRESSION_TREE\r\n);\r\n\r\nlet EXPRESSION_TREE = createMatchTree(\r\n    { SequenceExpression: Expressions.SequenceExpression }\r\n    , PRIMARY_EXPRESSION_TREE\r\n)\r\n\r\nfor (const type_name in Expressions) {\r\n    if (type_name) {\r\n        TYPE_ALIAS[type_name] = [type_name, \"[Expression]\"];\r\n    }\r\n}\r\nexport {\r\n    Expressions,\r\n    EXPRESSION_TREE,\r\n    PRIMARY_EXPRESSION_TREE,\r\n    parseArrayPattern,\r\n    parseObjectPattern,\r\n    parse_params,\r\n    parse_arguments,\r\n};\r\n\r\nfunction parse_function_expression(context: Context, param_count?: number) {\r\n    let [collected, parser] = context;\r\n    let { async, generator, params, body } = collected;\r\n    collected.params = parse_params(context, params.content);\r\n    if (param_count !== undefined && collected.params.length !== param_count) {\r\n        parser.err(params);\r\n    }\r\n    let body_context = _Context(parser, body.content);\r\n    body_context[CONTEXT.inFunctionBody] = body.content;\r\n    body_context[CONTEXT.strict] = context[CONTEXT.strict];\r\n    body_context[CONTEXT.allowYield] = generator;\r\n    body_context[CONTEXT.allowAwait] = async;\r\n    if (generator && async) {\r\n        parser.err(collected);\r\n    }\r\n    collected.body = { type: \"BlockStatement\", body: parser.parseBlock(body_context) };\r\n    return collected;\r\n}\r\nfunction parse_arguments(context: Context, tokens: Array<Token>) {\r\n    if (tokens.length) {\r\n        let parser = context[CONTEXT.parser];\r\n        let restore = context.store(\r\n            CONTEXT.tokens, tokens,\r\n            CONTEXT.spreadElement, tokens\r\n        );\r\n        parser.parseCustom(ARGUMENTS_TREE, context);\r\n        context.restore(restore);\r\n        return extract_success(parser, tokens);\r\n    }\r\n    return [];\r\n}\r\nfunction parse_params(context: Context, tokens: Array<Token>) {//\r\n    if (tokens.length) {\r\n        let parser = context[CONTEXT.parser];\r\n        let restore = context.store(\r\n            CONTEXT.tokens, tokens,\r\n            CONTEXT.bindingElement, tokens\r\n        );\r\n        context[CONTEXT.strict] && context.wrap(CONTEXT.bindingSet, []);\r\n        parser.parseCustom(PARAMS_TREE, context);\r\n        context.restore(restore);\r\n        return extract_success(parser, tokens);\r\n    }\r\n    return [];\r\n}\r\n","import { Token } from './interfaces'\r\nconst IdentifierStart = /[\\x24\\x5f\\x41-\\x5a\\x61-\\x7a]|[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\r\nconst IdentifierPart = /[\\x24\\x5f\\x41-\\x5a\\x61-\\x7a\\x30-\\x39]|[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD46\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E\\uDC5F\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\r\n\r\nexport default class {\r\n    public input: string;\r\n    public index: number;\r\n    public end: number;\r\n    public _bak: any;\r\n    public _scope: any;\r\n    private testCodePoint(regexp: RegExp) {\r\n        if (\r\n            (this.input.charCodeAt(this.index) & 0xfc00) === 0xd800\r\n            && (this.input.charCodeAt(this.index + 1) & 0xfc00) === 0xdc00\r\n        ) {\r\n            this._bak = this.input[this.index] + this.input[this.index + 1];\r\n            return regexp.test(this._bak) ? 2 : 0;\r\n        } else {\r\n            return regexp.test(this.input[this.index]) ? 1 : 0;\r\n        }\r\n    }\r\n    testUnicodeEscape(regexp: RegExp) {\r\n        let index = this.index + 1, code = 0;\r\n        if (this.input[index++] === \"u\") {\r\n            let cp = 0;\r\n            if (this.input[index] === \"{\") {\r\n                while (\r\n                    (code = this.hexValue(this.input.charCodeAt(++index))) >= 0\r\n                ) {\r\n                    cp = cp * 16 + code;\r\n                }\r\n                if (this.input[index++] !== \"}\") {/* || index < this.index + 5*/\r\n                    return 0;\r\n                }\r\n            } else {\r\n                let len = 4;\r\n                while (len--) {\r\n                    code = this.hexValue(this.input.charCodeAt(index++));\r\n                    if (code >= 0) {\r\n                        cp = cp * 16 + code;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                }\r\n            }\r\n            return regexp.test(this.fromCodePoint(cp))\r\n                ? index - this.index\r\n                : -(index - this.index);\r\n        }\r\n        return 0;\r\n    }\r\n    scanHex(length: number = this.end): [number, number] {\r\n        let value = 0, code = 0, len = length;\r\n        while (len) {\r\n            code = this.hexValue(this.input.charCodeAt(this.index));\r\n            if (code >= 0) {\r\n                len--;\r\n                value = value * 16 + code;\r\n            } else {\r\n                break;\r\n            }\r\n            this.index++;\r\n        }\r\n        return [value, length - len];\r\n    }\r\n    hexValue(ch: number) {\r\n        return ch >= 0x30 && ch <= 0x39 ? ch - 0x30 :\r\n            ch >= 0x41 && ch <= 0x46 ? ch - 0x41 + 10 :\r\n                ch >= 0x61 && ch <= 0x66 ? ch - 0x61 + 10 : -1;\r\n    }\r\n    decimalValue(ch: number) {\r\n        return ch >= 0x30 && ch <= 0x39 ? ch - 0x30 : -1;\r\n    }\r\n    octalValue(ch: number) {\r\n        return ch >= 0x30 && ch <= 0x37 ? ch - 0x30 : -1;\r\n    }\r\n    binaryValue(ch: number) {\r\n        return ch === 0x30 || ch == 0x31 ? ch - 0x30 : -1;\r\n    }\r\n    //https://github.com/jquery/esprima/blob/master/src/character.ts\r\n    isWhiteSpace(ch: number) {\r\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\r\n            (ch >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\r\n        /*return /^\\x20|\\x09|\\x0B|\\x0C|\\xA0|\\xfeff$/.test(char);*/\r\n    }\r\n    isLineTerminator(ch: number) {\r\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\r\n        /*return /^\\x0A|\\x0D|\\x2028|\\x2029$/.test(char);*/\r\n    }\r\n    fromCodePoint(cp: number) {\r\n        return this._bak = cp < 0x10000\r\n            ? String.fromCharCode(cp)\r\n            : String.fromCharCode(0xd800 + (cp - 0x10000) >> 10)\r\n            + String.fromCharCode(0xdc00 + (cp - 0x10000) & 1023);\r\n    }\r\n    inIdentifierStart() {\r\n        let ch = this.input.charCodeAt(this.index);\r\n        return (ch === 0x24) || (ch === 0x5F) ||\r\n            (ch >= 0x41 && ch <= 0x5A) ||\r\n            (ch >= 0x61 && ch <= 0x7A) ? 1 : (\r\n                ch >= 0x80\r\n                    ? this.testCodePoint(IdentifierStart)\r\n                    : (ch === 0x5c ? this.testUnicodeEscape(IdentifierStart) : 0)\r\n            );\r\n        /*return /^[_$a-zA-Z\\u0080-\\uffffff]$/.test(char);*/\r\n    }\r\n    inIdentifierPart() {\r\n        let ch = this.input.charCodeAt(this.index);\r\n        return (ch === 0x24) || (ch === 0x5F) ||\r\n            (ch >= 0x41 && ch <= 0x5A) ||\r\n            (ch >= 0x61 && ch <= 0x7A) ||\r\n            (ch >= 0x30 && ch <= 0x39) ? 1 : (\r\n                ch >= 0x80\r\n                    ? this.testCodePoint(IdentifierPart)\r\n                    : (ch === 0x5c ? this.testUnicodeEscape(IdentifierPart) : 0)\r\n            );\r\n        /*return /^[\\w$\\u0080-\\uffffff]$/.test(char);*/\r\n    }\r\n    isFollowingAnExpression(token?: Token) {\r\n        return token ? [\r\n            'in', 'typeof', 'instanceof', 'new',\r\n            'return', 'case', 'delete', 'throw', 'void',\r\n            // assignment operators\r\n            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',\r\n            '&=', '|=', '^=', ',',\r\n            // binary/unary operators\r\n            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\r\n            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\r\n            '<=', '<', '>', '!=', '!=='\r\n        ].indexOf(token.value) >= 0 : false;\r\n    }\r\n}","\r\n\r\nimport {\r\n    PRIOR_REGEXP_PUNCTUATORS_TREE,\r\n    PUNCTUATORS_TREE,\r\n    NUMERIC_KEYWORD_MAP,\r\n    TOKEN_TYPE_MAP, TOKEN_TYPES\r\n} from \"./lexical/index\";\r\nimport Character from './character'\r\nimport {\r\n    Position, SourceLocation, Token, SearchTree, NUMERIC_TYPE\r\n} from \"./interfaces\";\r\n\r\n\r\nexport default class extends Character {\r\n    constructor(options?: Record<string, any>) {\r\n        super()\r\n        for (const key in options) {\r\n            this[key] = options[key];\r\n        }\r\n    }\r\n    public token_types = TOKEN_TYPES;\r\n    public token_hooks: Record<string, (token: Token) => Token> = {};\r\n    public line_number: number;\r\n    public line_start: number;\r\n    public save_comments: boolean = true;\r\n    public parent_token: Token;\r\n    public error_logs: Array<any>;\r\n    err(...args: any) {\r\n        //debugger;\r\n        this.error_logs.push.apply(this.error_logs, arguments);\r\n    }\r\n    tokenize(input: string): Array<Token> {\r\n        this.line_number = 0;\r\n        this.line_start = 0;\r\n        this.index = 0;\r\n        this.input = input;\r\n        this.end = this.input.length;\r\n        this.error_logs = [];\r\n        return this.scan(null, true);\r\n    }\r\n    getToken(\r\n        type: string | number,\r\n        range: [number, number],\r\n        value: any = this.input.slice(range[0], range[1]),\r\n        start: Position = {\r\n            line: this.line_number,\r\n            column: range[0] - this.line_start\r\n        },\r\n        end: Position = {\r\n            line: this.line_number,\r\n            column: range[1] - this.line_start\r\n        },\r\n    ): Token {\r\n        return {\r\n            type: type,\r\n            value,\r\n            range,\r\n            loc: {\r\n                start, end\r\n            }\r\n        };\r\n\r\n    }\r\n    private match(node: SearchTree) {\r\n        let start = this.index, end = this.index;\r\n        let prev_node: Token;\r\n        do {\r\n            prev_node = node;\r\n            node = prev_node[this.input[end++]];\r\n        } while (node)\r\n        if (prev_node.__) {\r\n            let target = prev_node.__;\r\n            this.index = end - 1;\r\n            if (target.scanner) {\r\n                return target.scanner(this);\r\n            } else {\r\n                let token = this.getToken(\r\n                    this.token_types[target.type],\r\n                    [start, end - 1],\r\n                    target.value\r\n                );\r\n                let bound = target.keys[1];\r\n                if (bound) {\r\n                    token.content = this.scan(token/*target.type*/);\r\n                    if (this.input.slice(this.index, this.index + bound.length) === bound) {\r\n                        this.index += bound.length;\r\n                    } else {\r\n                        this.err(token);\r\n                        token.error = \"error\";\r\n                    }\r\n                    token.range[1] = this.index;\r\n                    token.loc.end.line = this.line_number;\r\n                    token.loc.end.column = this.index - this.line_start;\r\n                }\r\n                return token;\r\n            }\r\n        }\r\n    }\r\n    private nextIdentifier(tokens: Array<Token>): Token | void {\r\n        let length = this.inIdentifierStart();\r\n        let token: Token;\r\n        if (length > 0) {\r\n            let start = this.index;\r\n            let str = \"\";\r\n            do {\r\n                str += length === 1 ? this.input[this.index] : this._bak;\r\n                this.index += length;\r\n                length = this.inIdentifierPart();\r\n            } while (length > 0)\r\n            let type = TOKEN_TYPE_MAP[\" \" + str];\r\n            token = this.getToken(\r\n                this.token_types[type || \"Identifier\"],\r\n                [start, this.index]\r\n            );\r\n            this._bak = str;\r\n            if (type && str.length !== this.index - start) {\r\n                this.err(token);\r\n            }\r\n        }\r\n        if (length < 0) {\r\n            this.err(this.getToken(\"error\", [this.index, this.index -= length]));\r\n        }\r\n        return token;\r\n    }\r\n    private nextRegexp(tokens: Array<Token>) {\r\n        let prev_token = tokens[tokens.length - 1];\r\n        let match_tree = PRIOR_REGEXP_PUNCTUATORS_TREE;\r\n        if (prev_token) {\r\n            if (prev_token.type === this.token_types.Punctuator) {\r\n                //https://github.com/jquery/esprima/blob/master/src/tokenizer.ts\r\n                switch (prev_token.value) {\r\n                    case \"[]\":\r\n                        match_tree = PUNCTUATORS_TREE;\r\n                        break;\r\n                    case \"()\":\r\n                        let keyword_token = tokens[tokens.length - 2];\r\n                        if (\r\n                            !keyword_token\r\n                            || [\"if\", \"while\", \"for\", \"with\"].indexOf(keyword_token.value) < 0\r\n                        ) {\r\n                            match_tree = PUNCTUATORS_TREE;\r\n                        }\r\n                        break;\r\n                    case \"{}\":\r\n                        let length = tokens.length;\r\n                        for (\r\n                            let checks of [\r\n                                [\r\n                                    [4, \"function\"],\r\n                                    [\r\n                                        5,\r\n                                        \"async\",\r\n                                        function () {\r\n                                            return tokens[length - 4].loc.start.line\r\n                                                === tokens[length - 5].loc.end.line;\r\n                                        }\r\n                                    ]\r\n                                ],\r\n                                [\r\n                                    [5, \"function\"],\r\n                                    [\r\n                                        6,\r\n                                        \"async\",\r\n                                        function () {\r\n                                            return tokens[length - 5].loc.start.line\r\n                                                === tokens[length - 6].loc.end.line;\r\n                                        }\r\n                                    ]\r\n                                ],\r\n                                [[2, \"class\"]],\r\n                                [[3, \"class\"]],\r\n                                [[5, \"class\"]],\r\n                            ] as Array<Array<[number, string, () => boolean | undefined]>>\r\n                        ) {\r\n                            let index: number;\r\n                            let target_token: Token;\r\n                            for (let check of checks) {\r\n                                target_token = tokens[length - check[0]];\r\n                                if (\r\n                                    target_token\r\n                                    && target_token.value === check[1]\r\n                                    && (!check[2] || check[2]())\r\n                                ) {\r\n                                    index = check[0];\r\n                                } else {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (index !== undefined) {\r\n                                if (\r\n                                    this.parent_token\r\n                                    && [\"()\", \"[]\", \"${}\"].indexOf(this.parent_token.value) >= 0\r\n                                    || this.isFollowingAnExpression(tokens[length - index - 1])\r\n                                ) {\r\n                                    match_tree = PUNCTUATORS_TREE\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                }\r\n            } else if (\r\n                prev_token.type !== this.token_types.Keyword//&& prev_token.value !== \"let\"\r\n            ) {\r\n                match_tree = PUNCTUATORS_TREE;\r\n            }\r\n        }\r\n        return this.match(match_tree);\r\n    }\r\n    private nextPunctuator(tokens: Array<Token>): Token | void {\r\n        return this.input[this.index] !== \"/\"\r\n            ? this.match(PUNCTUATORS_TREE)\r\n            : this.nextRegexp(tokens);\r\n    }\r\n\r\n    private nextNumeric(tokens: Array<Token>): Token | void {\r\n        let start = this.index;\r\n        let ch = this.input.charCodeAt(this.index);\r\n        let number: number;\r\n        let flags = NUMERIC_TYPE.DECIMAL;\r\n        let _get_token = () => {\r\n            this._bak = flags & NUMERIC_TYPE.OCTAL ? (flags & ~NUMERIC_TYPE.DECIMAL) : flags;\r\n            return this.getToken(this.token_types.Numeric, [start, this.index]);\r\n        }\r\n        let _get_error = (message: string = \"Invalid or unexpected token\") => {\r\n            let error = _get_token();\r\n            error.error = message;\r\n            error.input = this.input.slice(start, this.index + 1);\r\n            this.err(error);\r\n            return error;\r\n        }\r\n        let decimalValue = this.decimalValue;\r\n        switch (ch) {\r\n            case 0x2e://\".\"\r\n                if (decimalValue(this.input.charCodeAt(this.index + 1)) >= 0) {\r\n                    this.index += 1;\r\n                    flags |= NUMERIC_TYPE.FLOAT;\r\n                    break;\r\n                } else {\r\n                    return;\r\n                }\r\n            case 0x30://\"0\"\r\n                flags = NUMERIC_KEYWORD_MAP[this.input[++this.index]];\r\n                if (!flags) {\r\n                    number = decimalValue(this.input.charCodeAt(this.index));\r\n                    if (number >= 0) {\r\n                        flags = NUMERIC_TYPE.DECIMAL;\r\n                        number < 8 && (flags |= NUMERIC_TYPE.OCTAL);\r\n                    } else if (!this.inIdentifierStart()) {\r\n                        flags = NUMERIC_TYPE.DECIMAL;\r\n                        return _get_token();\r\n                    } else {\r\n                        return _get_error();\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                if (decimalValue(ch) < 0) {\r\n                    return;\r\n                }\r\n        }\r\n        if (flags & NUMERIC_TYPE.DECIMAL) {\r\n            while ((ch = this.input.charCodeAt(++this.index))) {\r\n                number = decimalValue(ch)\r\n                if (number >= 0) {\r\n                    number < 8 || (flags &= ~NUMERIC_TYPE.OCTAL);\r\n                    continue;\r\n                }\r\n                switch (ch) {\r\n                    case 0x65://\"e\"\r\n                    case 0x45://\"E\"\r\n                        if (!(flags & (NUMERIC_TYPE.E | NUMERIC_TYPE.OCTAL))) {\r\n                            flags |= NUMERIC_TYPE.E;\r\n                            ch = this.input.charCodeAt(this.index + 1);\r\n                            if (ch === 0x2b || ch === 0x2d) {//+ -\r\n                                this.index += 1;\r\n                            }\r\n                            continue;\r\n                        } else {\r\n                            return _get_error();\r\n                        }\r\n                    case 0x2e://\".\"\r\n                        if (!(flags & (NUMERIC_TYPE.FLOAT | NUMERIC_TYPE.E | NUMERIC_TYPE.OCTAL))) {\r\n                            flags |= NUMERIC_TYPE.FLOAT;\r\n                            continue;\r\n                        }\r\n                    default:\r\n                        return this.inIdentifierStart()\r\n                            ? _get_error()\r\n                            : _get_token();\r\n                }\r\n            }\r\n            return _get_token();\r\n        } else {\r\n            let test = flags & NUMERIC_TYPE.HEX\r\n                ? this.hexValue : (\r\n                    flags & NUMERIC_TYPE.BINARY\r\n                        ? this.binaryValue\r\n                        : this.octalValue\r\n                );\r\n            while (test(this.input.charCodeAt(++this.index)) >= 0);\r\n            return this.index > start + 3 && !this.inIdentifierStart()\r\n                ? _get_token()\r\n                : _get_error();\r\n        }\r\n    }\r\n    private nextToken(tokens: Array<Token>): Token | void {\r\n        for (let cp: number; this.index < this.end; this.index++) {\r\n            cp = this.input.charCodeAt(this.index);\r\n            switch (true) {\r\n                case this.isWhiteSpace(cp):\r\n                    break;\r\n                case this.isLineTerminator(cp):\r\n                    this.line_number++;\r\n                    this.line_start = this.index + 1;\r\n                    break;\r\n                default:\r\n                    return this.nextIdentifier(tokens) ||\r\n                        this.nextNumeric(tokens) ||\r\n                        this.nextPunctuator(tokens);\r\n            }\r\n        }\r\n    }\r\n    scan(parent_token: Token, full_match = false) {\r\n        let parent_token_bak = this.parent_token;\r\n        this.parent_token = parent_token;\r\n        let content = [];\r\n        let proxy_hook: (token: Token, tokenizer: this) => Token;\r\n        let token: Token | void;\r\n        while (this.index < this.end) {\r\n            token = this.nextToken(content);\r\n            if (token) {\r\n                proxy_hook = this.token_hooks[token.type];\r\n                proxy_hook && (token = proxy_hook(token, this));\r\n                if (token.type !== this.token_types.Comments) {\r\n                    content.push(token);\r\n                } else {\r\n                    this.save_comments && content.push(token);\r\n                }\r\n            } else if (!full_match) {\r\n                break;\r\n            } else if (this.index < this.end) {\r\n                //debugger;\r\n                this.err(this.getToken(\"error\", [this.index, ++this.index]))\r\n            }\r\n        }\r\n        this.parent_token = parent_token_bak;\r\n        return content;\r\n    }\r\n}\r\n\r\n\r\n\r\n","import {\r\n    Token, NUMERIC_TYPE, MATCH_STATUS\r\n} from '../interfaces';\r\n\r\nimport Tokenizer from '../tokenizer'\r\nimport { search_scan, escape_scan, createSearchTree } from './head'\r\n\r\nlet TOKEN_TYPES: Record<string, string | number> = {\r\n    Identifier: \"Identifier\",\r\n    Keyword: \"Keyword\",\r\n    String: \"String\",\r\n    Boolean: \"Boolean\",\r\n    Numeric: \"Numeric\",\r\n    Punctuator: \"Punctuator\",\r\n    RegularExpression: \"RegularExpression\",\r\n    Template: \"Template\",\r\n    TemplateElement: \"TemplateElement\",\r\n    Comments: \"Comments\",\r\n    Null: \"Null\"\r\n};\r\n\r\n//const IS_RADIX = NUMERIC_TYPE.BINARY | NUMERIC_TYPE.OCTAL | NUMERIC_TYPE.HEX;\r\nconst NUMERIC_KEYWORD_MAP = {\r\n    \".\": NUMERIC_TYPE.FLOAT | NUMERIC_TYPE.DECIMAL,\r\n    \"x\": NUMERIC_TYPE.HEX,\r\n    \"b\": NUMERIC_TYPE.BINARY,\r\n    \"o\": NUMERIC_TYPE.OCTAL,\r\n\r\n    \"X\": NUMERIC_TYPE.HEX,\r\n    \"B\": NUMERIC_TYPE.BINARY,\r\n    \"O\": NUMERIC_TYPE.OCTAL,\r\n};\r\n\r\nlet TOKEN_TYPE_SET = [\r\n    [\r\n        \"Keyword\",\r\n        [\r\n            \"void\",\r\n            \"delete\",\r\n            \"new\",\r\n            \"class\", \"extends\",\r\n            \"function\",\r\n            \"throw\",\r\n            \"with\",\r\n            \"yield\",\r\n            \"in\", \"instanceof\", \"typeof\",\r\n            \"this\", \"super\",\r\n            \"var\", \"const\",// \"let\",\r\n            \"break\", \"continue\", \"return\",\r\n            \"if\", \"else\",\r\n            \"switch\", \"case\", \"default\",\r\n            \"try\", \"catch\", \"finally\",\r\n            \"do\", \"while\", \"for\",\r\n            \"await\",/*\"async\",*/\r\n            \"import\", \"export\",\r\n            \"debugger\",\r\n\r\n            \"enum\"//用于错误检测\r\n        ]\r\n    ],\r\n    [\"Identifier\", [\"let\", \"async\"]],//使 UnicodeEscape 的情况能被检测到报错\r\n    [\"Boolean\", [\"true\", \"false\"]],\r\n    [\"Null\", [\"null\"]]\r\n];\r\n\r\nconst TOKEN_TYPE_MAP = TOKEN_TYPE_SET.reduce(\r\n    (map, [type, id_set]) => {\r\n        for (let id of id_set) {\r\n            map[\" \" + id] = type;\r\n        }\r\n        return map;\r\n    }, {}\r\n);\r\n\r\nlet octal_escape = {\r\n    _state: MATCH_STATUS.ATTACH,\r\n    _attach(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n        let code = tokenizer.octalValue(tokenizer.input.charCodeAt(tokenizer.index - 1));\r\n        let value = 0;\r\n        code && (scope.octal = true);\r\n        let len = code <= 3 ? 2 : 1;\r\n        while (true) {\r\n            value = value * 8 + code;\r\n            code = tokenizer.octalValue(tokenizer.input.charCodeAt(tokenizer.index));\r\n            if (code < 0 || --len < 0) {\r\n                break;\r\n            }\r\n            scope.octal = true;\r\n            tokenizer.index += 1;\r\n        }\r\n        return String.fromCharCode(value);\r\n    }\r\n};\r\nlet octal_escape_tree = {\r\n    \"\\\\0\": octal_escape,\r\n    \"\\\\1\": octal_escape,\r\n    \"\\\\2\": octal_escape,\r\n    \"\\\\3\": octal_escape,\r\n    \"\\\\4\": octal_escape,\r\n    \"\\\\5\": octal_escape,\r\n    \"\\\\6\": octal_escape,\r\n    \"\\\\7\": octal_escape,\r\n}\r\n\r\nlet strbase_match_tree = {\r\n    \"\\\\\\n\": { _str: \"\" },\r\n    \"\\\\n\": { _str: \"\\n\" },\r\n    \"\\\\r\": { _str: \"\\r\" },\r\n    \"\\\\t\": { _str: \"\\t\" },\r\n    \"\\\\b\": { _str: \"\\b\" },\r\n    \"\\\\f\": { _str: \"\\f\" },\r\n    \"\\\\v\": { _str: \"\\v\" },\r\n    \"\\\\u\": {\r\n        _state: MATCH_STATUS.ATTACH,\r\n        _attach(tokenizer: Tokenizer) {\r\n            if (tokenizer.input[tokenizer.index] === \"{\") {\r\n                tokenizer.index++;\r\n                let [code] = tokenizer.scanHex();\r\n                if (tokenizer.input[tokenizer.index] === \"}\") {\r\n                    tokenizer.index++;\r\n                    if (code <= 0x10ffff) {\r\n                        return String.fromCharCode(code);\r\n                    }\r\n                }\r\n            } else {\r\n                let [code, len] = tokenizer.scanHex(4);\r\n                if (len === 4) {\r\n                    return String.fromCharCode(code);\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    \"\\\\x\": {\r\n        _state: MATCH_STATUS.ATTACH,\r\n        _attach(tokenizer: Tokenizer) {\r\n            let [code, len] = tokenizer.scanHex(2);\r\n            if (len === 2) {\r\n                return String.fromCharCode(code);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n};\r\n\r\nlet not_allow_octal_escape = {\r\n    _state: MATCH_STATUS.ERROR,\r\n    _message: \"Octal escape sequences are not allowed in template strings\"\r\n}\r\n\r\nconst PUNCTUATORS = [\r\n    {\r\n        keys: [`\"`, `\"`], type: \"String\",\r\n        match_tree: {\r\n            '\"': {\r\n                _state: MATCH_STATUS.END\r\n            },\r\n            \"\\n\": {\r\n                _state: MATCH_STATUS.ERROR,\r\n                _message: \"\"\r\n            },\r\n            ...strbase_match_tree,\r\n            ...octal_escape_tree\r\n        },\r\n        //scanner:escape_scan\r\n        escape_scan,\r\n        scanner(tokenizer: Tokenizer) {\r\n            return this.escape_scan(tokenizer, {});\r\n        }\r\n    },\r\n    {\r\n        keys: [`'`, `'`], type: \"String\",\r\n        match_tree: {\r\n            \"'\": {\r\n                _state: MATCH_STATUS.END\r\n            },\r\n            \"\\n\": {\r\n                _state: MATCH_STATUS.ERROR,\r\n                _message: \"\"\r\n            },\r\n            ...strbase_match_tree,\r\n            ...octal_escape_tree\r\n        },\r\n        //scanner:escape_scan\r\n        escape_scan,\r\n        scanner(tokenizer: Tokenizer) {\r\n            return this.escape_scan(tokenizer, {});\r\n        }\r\n    },\r\n    {\r\n        keys: [\"`\", \"`\"], type: \"Template\",\r\n        appendTemplateElement(\r\n            tokenizer: Tokenizer,\r\n            scope: Record<string, any>,\r\n            range: [number, number],\r\n            tail = false\r\n        ) {\r\n            let token = tokenizer.getToken(\r\n                \"TemplateElement\",\r\n                range,\r\n                {\r\n                    raw: tokenizer.input.slice(range[0], range[1]),\r\n                    cooked: tokenizer._bak\r\n                },\r\n                {\r\n                    line: scope.prev_line,\r\n                    column: scope.prev_solumn\r\n                }\r\n            );\r\n            token.tail = tail;\r\n            scope.content.push(token);\r\n        },\r\n        match_tree: {\r\n            \"\\\\0\": { _str: \"\\0\" },\r\n            \"\\\\1\": not_allow_octal_escape,\r\n            \"\\\\2\": not_allow_octal_escape,\r\n            \"\\\\3\": not_allow_octal_escape,\r\n            \"\\\\4\": not_allow_octal_escape,\r\n            \"\\\\5\": not_allow_octal_escape,\r\n            \"\\\\6\": not_allow_octal_escape,\r\n            \"\\\\7\": not_allow_octal_escape,\r\n            \"`\": {\r\n                _state: MATCH_STATUS.NEXT,\r\n                _next(tokenizer: Tokenizer, scope: Record<string, any>, start: number, error?: string) {\r\n                    this.appendTemplateElement(tokenizer, scope, [start, tokenizer.index], true);\r\n                    let token = tokenizer.getToken(\r\n                        this.type,\r\n                        [scope.start, tokenizer.index],\r\n                        this.value,\r\n                        {\r\n                            line: scope.start_line,\r\n                            column: scope.start_column\r\n                        }\r\n                    );\r\n                    token.content = scope.content;\r\n                    return token;\r\n                }\r\n            },\r\n            \"$\": {\r\n                \"{\": {\r\n                    _state: MATCH_STATUS.NEXT,\r\n                    _next(tokenizer: Tokenizer, scope: Record<string, any>, start: number, error) {\r\n                        if (start < tokenizer.index - 2) {\r\n                            this.appendTemplateElement(tokenizer, scope, [start, tokenizer.index - 2]);\r\n                        }\r\n                        start = tokenizer.index - 2;\r\n                        let token = tokenizer.getToken(\r\n                            tokenizer.token_types.Punctuator,\r\n                            [start, tokenizer.index],\r\n                            \"${}\",\r\n                            {\r\n                                line: tokenizer.line_number,\r\n                                column: start - tokenizer.line_start\r\n                            }\r\n                        );\r\n                        let content = tokenizer.scan(token);\r\n                        if (tokenizer.input[tokenizer.index] === \"}\") {\r\n                            tokenizer.index += 1;\r\n                            scope.prev_line = tokenizer.line_number;\r\n                            scope.prev_column = tokenizer.index - tokenizer.line_start;\r\n                            token.range[1] = tokenizer.index;\r\n                            token.loc.end.line = scope.prev_line;\r\n                            token.loc.end.column = scope.prev_column;\r\n                            token.content = content;\r\n                            scope.content.push(token);\r\n                            return this.escape_scan(tokenizer, scope, tokenizer.index);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            ...strbase_match_tree\r\n        },\r\n        escape_scan,\r\n        scanner(tokenizer: Tokenizer) {\r\n            let start = tokenizer.index - 1;\r\n            let start_line = tokenizer.line_number;\r\n            let start_column = start - tokenizer.line_start;\r\n            return this.escape_scan(\r\n                tokenizer,\r\n                {\r\n                    content: [],\r\n                    start,\r\n                    start_line,\r\n                    start_column,\r\n                    prev_line: start_line,\r\n                    prev_column: start_column\r\n                }\r\n            );\r\n        }\r\n    },\r\n    { keys: ['/*', '*/'], type: \"Comments\", scanner: search_scan },\r\n    { keys: ['//', '\\n'], type: \"Comments\", scanner: search_scan },\r\n\r\n    [\"(\", \")\"], [\"[\", \"]\"], [\"{\", \"}\"],\r\n    ';', '.', '?.',\r\n    '++', '--', '~', '!',\r\n    '**', '*', '/', '%',\r\n    '+', '-',\r\n    '<<', '>>', '>>>',\r\n    '<', '>', '<=', '>=', '==', '!=', '===', '!==',\r\n    '&',\r\n    '^',\r\n    '|',\r\n    '&&',\r\n    '||',\r\n    '?', \":\",\r\n    '=', '+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '&=', '|=', '^=',\r\n    '...',\r\n    ',',\r\n    '=>'\r\n];\r\n\r\nconst REGEXP_DESCRIPTOR = {\r\n    keys: ['/', '/'], type: \"RegularExpression\",\r\n    match_tree: {\r\n        '/': {\r\n            _state: MATCH_STATUS.END,\r\n            _end(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n                return !scope.class_marker;\r\n            }\r\n        },\r\n        '[': {\r\n            _state: MATCH_STATUS.ATTACH,\r\n            _attach(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n                scope.class_marker = true;\r\n            }\r\n        },\r\n        ']': {\r\n            _state: MATCH_STATUS.ATTACH,\r\n            _attach(tokenizer: Tokenizer, scope: Record<string, any>) {\r\n                scope.class_marker = false;\r\n            }\r\n        },\r\n        '\\n': {\r\n            _state: MATCH_STATUS.ERROR\r\n        },\r\n        '\\\\\\n': {\r\n            _state: MATCH_STATUS.ERROR\r\n        },\r\n        'EOF': {\r\n            _state: MATCH_STATUS.END,\r\n            _error: \"Invalid or unexpected token\"\r\n        }\r\n    },\r\n    overload: true,\r\n    escape_scan,\r\n    scanner(tokenizer: Tokenizer, prev_token: Token) {\r\n        let scope: Record<string, any> = {};\r\n        let token = this.escape_scan(tokenizer, scope);\r\n        if (token) {\r\n            token.regex = {\r\n                pattern: token.value.slice(\r\n                    1, token.value[token.value.length - 1] !== \"/\" ? undefined : -1\r\n                ),\r\n                flags: \"\"\r\n            };\r\n            let start = tokenizer.index;\r\n            let length = 0;\r\n            do {\r\n                tokenizer.index += length;\r\n                length = tokenizer.inIdentifierPart();\r\n            } while (length)\r\n            if (start !== tokenizer.index) {\r\n                token.regex.flags = tokenizer.input.slice(start, tokenizer.index)\r\n                token.value += token.regex.flags;\r\n                token.range[1] += tokenizer.index - start;\r\n                token.loc.end.column += tokenizer.index - start;\r\n            }\r\n            return token;\r\n        }\r\n    }\r\n};\r\nconst PUNCTUATORS_TREE = createSearchTree(PUNCTUATORS);\r\nconst PRIOR_REGEXP_PUNCTUATORS_TREE = createSearchTree(\r\n    [REGEXP_DESCRIPTOR],\r\n    createSearchTree(PUNCTUATORS, [\"/=\"]),\r\n);\r\n\r\n\r\nexport {\r\n    PRIOR_REGEXP_PUNCTUATORS_TREE,\r\n    PUNCTUATORS_TREE,\r\n    NUMERIC_KEYWORD_MAP,\r\n    TOKEN_TYPE_MAP, TOKEN_TYPES\r\n}\r\n\r\n\r\n","\r\nimport {\r\n    Token, SearchTree, MATCH_STATUS\r\n} from '../interfaces';\r\n\r\nimport Tokenizer from '../tokenizer'\r\n\r\nfunction createSearchTree(\r\n    data: Array<string | string[] | Record<string, any>>,\r\n    root: Record<string, any> = {},\r\n    block_list: Array<string> = []\r\n): SearchTree {\r\n    for (let item of data as any) {\r\n        let node = root;\r\n        switch (true) {\r\n            case typeof item === \"string\":\r\n                item = [item];\r\n            case item instanceof Array:\r\n                item = {\r\n                    type: \"Punctuator\",\r\n                    keys: item,\r\n                    value: item.join(\"\")\r\n                }\r\n                break;\r\n            default:\r\n                item.type === undefined && (item.type = \"Punctuator\");\r\n                item.value === undefined && (item.value = item.keys.join(\"\"));\r\n                break;\r\n        }\r\n        if (~block_list.indexOf(item.keys[0])) {\r\n            continue;\r\n        }\r\n        for (const part of item.keys[0]) {\r\n            node = node[part] || (node[part] = {});\r\n        }\r\n        if (node.__ && !item.overload) {\r\n            console.warn(\"conflict:\", node, node.__, item);\r\n        }\r\n        node.__ = item;\r\n    }\r\n    return root;\r\n}\r\n\r\nfunction escape_scan(\r\n    tokenizer: Tokenizer,\r\n    scope?: Record<string, any>,\r\n    start: number = tokenizer.index - this.keys[0].length\r\n) {\r\n    let error: string;\r\n    let line_number = tokenizer.line_number;\r\n    let line_start = tokenizer.line_start;\r\n    let str = \"\";\r\n    let root = this.match_tree;\r\n    let node = root;\r\n    let _next = () => {\r\n        let token: Token;\r\n        let res: string | boolean;\r\n        switch (node._state) {\r\n            case MATCH_STATUS.END:\r\n                if (!node._end || (res = node._end.call(this, tokenizer, scope, start, error)) === true) {\r\n                    token = tokenizer.getToken(\r\n                        this.type,\r\n                        [start, tokenizer.index],\r\n                        undefined, { line: line_number, column: start - line_start }\r\n                    );\r\n                    tokenizer._scope = scope;\r\n                    tokenizer._bak = str;\r\n                    if (node._error || error) {\r\n                        token.error = (node._error || error);\r\n                        tokenizer.err(token);\r\n                    }\r\n                    return token;\r\n                } else if (typeof res === \"string\") {\r\n                    str += res;\r\n                }\r\n                break;\r\n            case MATCH_STATUS.ATTACH:\r\n                res = node._attach.call(this, tokenizer, scope, start, error);\r\n                if (res !== false) {\r\n                    res && (str += res);\r\n                    break;\r\n                }\r\n            case MATCH_STATUS.ERROR:\r\n                error = node._message || \"Invalid or unexpected token\";\r\n            case MATCH_STATUS.NEXT:\r\n                if (node._next) {\r\n                    tokenizer._bak = str;\r\n                    return node._next.call(this, tokenizer, scope, start, error);\r\n                }\r\n                break;\r\n            default:\r\n                if (node._str === undefined) {\r\n                    return;\r\n                }\r\n                str += node._str;\r\n        }\r\n        node = root;\r\n    }\r\n    for (\r\n        let char = tokenizer.input[tokenizer.index++],\r\n        backslash_count = 0,\r\n        token: Token;\r\n        char;\r\n        char = tokenizer.input[tokenizer.index++]\r\n    ) {\r\n        let has_escape = backslash_count % 2;\r\n        if (char === \"\\\\\") {\r\n            backslash_count += 1;\r\n            has_escape && (node = node[\"\\\\\"]);\r\n        } else {\r\n            backslash_count = 0;\r\n            if (tokenizer.isLineTerminator(char.charCodeAt(0))) {\r\n                tokenizer.line_number += 1;\r\n                tokenizer.line_start = tokenizer.index;\r\n                node = node[\r\n                    has_escape\r\n                        ? \"\\\\\\n\"\r\n                        : \"\\n\"\r\n                ];\r\n            } else {\r\n                node = node[!has_escape ? char : \"\\\\\" + char];\r\n            }\r\n        }\r\n\r\n        if (!node) {\r\n            str += char;\r\n            node = root;\r\n        } else if ((token = _next())) {\r\n            return token;\r\n        }\r\n    }\r\n    if (root.EOF) {\r\n        node = root.EOF;\r\n        return _next();\r\n    }\r\n}\r\nfunction search_scan(tokenizer: Tokenizer) {\r\n    let start = tokenizer.index - this.keys[0].length;\r\n    let bound = this.keys[1];\r\n    let start_line = tokenizer.line_number;\r\n    let start_column = start - tokenizer.line_start;\r\n    let matched_count = 0;\r\n    for (\r\n        let char = tokenizer.input[tokenizer.index++];\r\n        char;\r\n        char = tokenizer.input[tokenizer.index++]\r\n    ) {\r\n        if (tokenizer.isLineTerminator(char.charCodeAt(0))) {\r\n            if (bound === \"\\n\") {\r\n                tokenizer.index -= 1;\r\n                break;\r\n            }\r\n            tokenizer.line_number += 1;\r\n            tokenizer.line_start = tokenizer.index;\r\n        } else if (char === bound[matched_count]) {\r\n            if (bound.length > ++matched_count) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        matched_count = 0;\r\n    }\r\n    let token = tokenizer.getToken(\r\n        this.type,\r\n        [start, tokenizer.index],\r\n        undefined,\r\n        { line: start_line, column: start_column }\r\n    );\r\n    if (matched_count !== bound.length && bound !== \"\\n\" && bound !== \"EOF\") {\r\n        token.error = \"Invalid or unexpected token\";\r\n        tokenizer.err(token);\r\n    }\r\n    return token;\r\n}\r\nexport {\r\n    createSearchTree, escape_scan, search_scan\r\n}","\r\n\r\nimport {\r\n    Context, CONTEXT, SourceLocation, Node\r\n} from '../interfaces';\r\nimport {\r\n    isRestrictedWord,\r\n    STATEMANT_LIST_ITEM_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark, NODES, TYPE_ALIAS,\r\n    validateBinding, validateLineTerminator, AWAIT_LIST, createMatchTree, join_content, _NonCapturing, MATCH_MARKS\r\n} from './head'\r\nimport { Expressions, PRIMARY_EXPRESSION_TREE } from './expression';\r\n\r\nlet Grouping = NODES.Grouping;\r\n\r\n\r\nfunction get_variable_declarator(context: Context, id: Node, init: Node, range: [number, number], loc: SourceLocation): Node {\r\n    if (id instanceof Grouping) {\r\n        context[CONTEXT.parser].err(id);\r\n    } else if (context[CONTEXT.strict]) {\r\n        init || validateBinding(context, id);\r\n    } if (id.name === \"let\") {\r\n        let kind = context[CONTEXT.tokens][context[CONTEXT.begin] - 1];\r\n        if (kind.value === \"let\" || kind.value === \"const\") {\r\n            context[CONTEXT.parser].err(id);\r\n        }\r\n    }\r\n    return {\r\n        type: \"VariableDeclarator\",\r\n        id, init, range, loc\r\n    };\r\n}\r\n\r\nlet VariableDeclarators = {\r\n    Success: {\r\n        handler: [\r\n            join_content,\r\n            function (context: Context) {\r\n                let [collected] = context;\r\n                validateLineTerminator(context);\r\n                collected.content = join_content(context).content;\r\n                return collected;\r\n            }\r\n        ],\r\n        precedence: [100, 0],\r\n        collector: [\r\n            {\r\n                success: _Or(\"Success\", MATCH_MARKS.BOUNDARY),\r\n                content: _Or(\r\n                    _Or(\"Identifier\").watch(\r\n                        function (context: Context, identifier: Node) {\r\n                            context[CONTEXT.collected].content = get_variable_declarator(\r\n                                context,\r\n                                identifier,\r\n                                null,\r\n                                identifier.range,\r\n                                identifier.loc\r\n                            );\r\n                        }\r\n                    ),\r\n                    _Or(\"AssignmentPattern\").watch(\r\n                        function (context: Context, pattern: Node) {\r\n                            context[CONTEXT.collected].content = get_variable_declarator(\r\n                                context,\r\n                                pattern.left,\r\n                                pattern.right,\r\n                                pattern.range,\r\n                                pattern.loc\r\n                            );\r\n                        }\r\n                    )\r\n                ),\r\n                _next: _NonCollecting(\"Punctuator ,\"),\r\n            },\r\n            [\r\n                [\"type\", _Mark(\"VariableDeclarators\")],\r\n                [\"_next\", _Option(\"Punctuator ;\")]\r\n            ]\r\n        ]\r\n    }\r\n}\r\nlet VARIABLE_DECLARATOR_TREE: Record<string, any>;\r\n\r\nAWAIT_LIST.push(function () {\r\n    VARIABLE_DECLARATOR_TREE = createMatchTree(VariableDeclarators, PRIMARY_EXPRESSION_TREE);\r\n});\r\n\r\nfunction reinterpreat_expression_as_declaration(context: Context, expr: Node) {\r\n    let [collected, parser] = context;\r\n    expr.type = collected.type;\r\n    if (expr.id) {\r\n        if (isRestrictedWord(expr.id.name)) {\r\n            parser.err(expr.id);\r\n        }\r\n    } else {\r\n        parser.err(expr);\r\n    }\r\n    for (let key in expr) {\r\n        collected[key] = expr[key];\r\n    }\r\n}\r\nconst Declarations: Record<string, any> = {\r\n    \"ClassDeclaration\": { //<= ClassExpression\r\n        filter(context: Context, left: number, right: number) {\r\n            let tokens = context[CONTEXT.tokens];\r\n            return !(tokens[right] instanceof Grouping);\r\n        },\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                id: _Or(\"ClassExpression\").watch(reinterpreat_expression_as_declaration)\r\n            }\r\n        ]\r\n    },\r\n    \"FunctionDeclaration\": {\r\n        filter: \"ClassDeclaration\",\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                id: _Or(\"FunctionExpression\").watch(reinterpreat_expression_as_declaration)\r\n            }\r\n        ]\r\n    },\r\n    \"VariableDeclaration\": [\r\n        {\r\n            validator(context: Context) {\r\n                let [, parser, tokens, left] = context;\r\n                context[CONTEXT.start] = context[CONTEXT.end] = left + 1;\r\n                return parser.parseKeyword(tokens[left + 1]);\r\n            },\r\n            collector: {\r\n                _: TOPLEVEL_ITEM_PATTERN,\r\n                __: \"Identifier let\",\r\n                ___: \"Punctuator []\"\r\n            }\r\n        },\r\n        {\r\n            validator: [\r\n                function (context: Context) {\r\n                    let [, parser, tokens, left] = context;\r\n                    context.wrap(CONTEXT.bindingElement, tokens);\r\n                    let res = parser.parseCustom(\r\n                        VARIABLE_DECLARATOR_TREE,\r\n                        context,\r\n                        left + 1,\r\n                        (node: Node) => node.type === \"VariableDeclarators\"\r\n                    );\r\n                    context.unwrap();\r\n                    return res && 0;\r\n                }, null\r\n            ],\r\n            handler(context: Context) {\r\n                let [collected] = context;\r\n                let { declarations, kind } = collected;\r\n                collected.declarations = declarations.content;\r\n                collected.kind = kind.value || kind.name;\r\n                return collected;\r\n            },\r\n            collector: [\r\n                {\r\n                    //_: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                    kind: _Or(\"Keyword var const let\", \"Identifier let\"),\r\n                    declarations: _Or(\r\n                        \"Identifier\",\r\n                        _Series(\"Punctuator [] {}\", \"Punctuator =\")\r\n                    )\r\n                },\r\n                [\r\n                    [\"declarations\", \"VariableDeclarators\"],\r\n                ]\r\n            ]\r\n        }\r\n    ]\r\n\r\n};\r\nfor (const type_name in Declarations) {\r\n    type_name && (TYPE_ALIAS[type_name] = [type_name, \"[Declaration]\"]);\r\n}\r\n\r\nexport default Declarations;\r\n","import Tokenizer from \"./tokenizer\"\r\nimport {\r\n    NodeProp,\r\n    MATCHED,\r\n    Matched,\r\n    MATCHED_RECORDS,\r\n    MatchedRecords,\r\n    Token, Node, Watcher,\r\n    SearchTree, NUMERIC_TYPE, Context, CONTEXT,\r\n    SourceLocation\r\n} from \"./interfaces\";\r\nimport {\r\n    SYNTAX_TREE,\r\n    MATCH_MARKS,\r\n    EXPRESSION_TREE,\r\n    isExpression, isStatementListItem\r\n} from \"./syntax/index\";\r\nimport { _Context, TYPE_ALIAS, NODES, AWAIT_LIST, Mark } from \"./syntax/head\";\r\ntype Extreme = MatchedRecords;\r\ntype Longest = MatchedRecords;\r\nfor (const cbfun of AWAIT_LIST) {\r\n    cbfun();\r\n}\r\n\r\nconst { Script, Module, Directive } = NODES;\r\nfunction parseIdentifier({ value, range, loc }: Token, tokenizer?: Tokenizer): Node {\r\n    let name = tokenizer ? tokenizer._bak : value;\r\n    let identifier = {\r\n        type: \"Identifier\", name, range, loc\r\n    };\r\n    Object.defineProperty(identifier, \"value\", {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value: name\r\n    });\r\n    return identifier;\r\n\r\n}\r\n\r\nfunction getLiteral(parse_value: (token: Token, tokenizer: Tokenizer) => any, token: Token, tokenizer: Tokenizer) {\r\n    return {\r\n        type: \"Literal\",\r\n        value: parse_value(token, tokenizer),\r\n        raw: token.value,\r\n        range: token.range,\r\n        loc: token.loc\r\n    }\r\n}\r\n\r\nlet tokenizer = new Tokenizer({\r\n    save_comments: false, token_hooks: {\r\n        Identifier: parseIdentifier,\r\n        Numeric: getLiteral.bind(null, (token: Token) => Number(token.value)),\r\n        Boolean: getLiteral.bind(null, (token: Token) => token.value === \"true\"),\r\n        String(token: Token, tokenizer: Tokenizer) {\r\n            if (!tokenizer._scope.octal) {\r\n                return {\r\n                    type: \"Literal\",\r\n                    value: tokenizer._bak,\r\n                    raw: token.value,\r\n                    range: token.range,\r\n                    loc: token.loc\r\n                };\r\n            }\r\n            token.str = tokenizer._bak;\r\n            token.octal = tokenizer._scope.octal;\r\n            return token;\r\n        },\r\n        Null: getLiteral.bind(null, () => null),\r\n        RegularExpression(token: Token, tokenizer: Tokenizer) {\r\n            let regex = token.regex;\r\n            let expr = {\r\n                type: \"Literal\",\r\n                value: null,\r\n                raw: token.value,\r\n                regex,\r\n                range: token.range,\r\n                loc: token.loc\r\n            }\r\n            try {\r\n                expr.value = new RegExp(regex.pattern, regex.flags);\r\n            } catch (e) { }\r\n            return expr;\r\n        }\r\n    }\r\n});\r\n\r\nexport default class {\r\n    tokens: Array<Token>;\r\n    SYNTAX_TREE = SYNTAX_TREE;\r\n    EXPRESSION_TREE = EXPRESSION_TREE;\r\n    tokenizer = tokenizer;\r\n    TYPE_ALIAS = TYPE_ALIAS;\r\n    padding_token: Token = {\r\n        type: MATCH_MARKS.BOUNDARY,\r\n        value: MATCH_MARKS.BOUNDARY\r\n    };\r\n    error_logs: Array<any>;\r\n    err(...args: any) {\r\n        //debugger;\r\n        this.error_logs.push.apply(this.error_logs, args);\r\n    }\r\n    constructor() {\r\n    }\r\n    parse(input: string) {\r\n        return this.parseScript(input);\r\n    }\r\n    parseModule(input: string) {\r\n        return new Module(this._parse(input, CONTEXT.isModule, true, CONTEXT.strict, true), this.range, this.loc);\r\n    }\r\n    parseScript(input: string) {\r\n        return new Script(this._parse(input), this.range, this.loc);\r\n    }\r\n    parseBlock(context: Context, token?: Token) {\r\n        token && (context[CONTEXT.tokens] = token.content);\r\n        let tokens = context[CONTEXT.tokens];\r\n        this.parseCustom(\r\n            SYNTAX_TREE,\r\n            context\r\n        );\r\n        let last_node = tokens[tokens.length - 1];\r\n        if (last_node && !isStatementListItem(last_node)) {\r\n            this.err(tokens.pop());\r\n        }\r\n        return tokens;\r\n    }\r\n    parseExpression(\r\n        context: Context,\r\n        token?: Token,\r\n        match_tree: Record<string, any> = EXPRESSION_TREE\r\n    ) {\r\n        return this.parseNode(match_tree, isExpression, context, token);\r\n    }\r\n    private range: [number, number];\r\n    private loc: SourceLocation;\r\n    private _parse(input: string, ...environments: Array<number | any>) {\r\n        this.tokens = this.tokenizer.tokenize(input);\r\n        this.range = [0, this.tokenizer.index];\r\n        this.loc = {\r\n            start: {\r\n                line: 0,\r\n                column: 0\r\n            },\r\n            end: {\r\n                line: this.tokenizer.line_number,\r\n                column: this.tokenizer.index - this.tokenizer.line_start\r\n            }\r\n        };\r\n        this.error_logs = this.tokenizer.error_logs;\r\n        let context = _Context(this, this.tokens);\r\n        environments.length && context.store(...environments);\r\n        this.parseBlock(context);\r\n        if (this.error_logs.length) {\r\n            console.warn(\"error:\", this.error_logs);\r\n        }\r\n        return this.tokens;\r\n    }\r\n    parseCustom(\r\n        root: Record<string, any>,\r\n        context: Context,\r\n        begin: number = 0,\r\n        hook?: Function\r\n    ) {\r\n        let point = context.store(CONTEXT.begin, begin);\r\n        let cursor: number = begin - 1;\r\n        let tokens = context[CONTEXT.tokens];\r\n        let backflow_tape: Array<number> = new Array(begin);\r\n        backflow_tape.push(cursor);\r\n        let extreme: Extreme;\r\n        let state: number;\r\n        while (true) {\r\n            if (cursor < tokens.length) {\r\n                //debugger;\r\n                if (\r\n                    !(\r\n                        extreme\r\n                        && (\r\n                            extreme[MATCHED_RECORDS.right] < cursor\r\n                            && backflow_tape.length <= 3 + extreme[MATCHED_RECORDS.right]\r\n                            //匹配边界断句\r\n                        )\r\n                        && (\r\n                            (state = this.finallize(context, extreme))\r\n                            || (extreme = undefined)\r\n                        )\r\n                    )\r\n                ) {\r\n                    let longest = this.walk(\r\n                        root,\r\n                        context,\r\n                        cursor,\r\n                        backflow_tape,\r\n                        extreme?.[MATCHED_RECORDS.right]\r\n                    );\r\n                    if (longest) {\r\n                        if (\r\n                            !extreme\r\n                            || !(\r\n                                extreme[MATCHED_RECORDS.precedence] > longest[MATCHED_RECORDS.precedence]\r\n                                || extreme[MATCHED_RECORDS.precedence] === Number(longest[MATCHED_RECORDS.precedence]) //左结合\r\n                            ) || !(state = this.finallize(context, extreme))\r\n                        ) {\r\n                            extreme = longest;\r\n                            //cursor += 1;\r\n                            //也可以单步步进，不过这样更效率一些也和当前收集器无冲突\r\n                            cursor += longest[MATCHED_RECORDS.right] - longest[MATCHED_RECORDS.left] || 1;\r\n                            continue;\r\n                        }\r\n                    } else {\r\n                        cursor += 1;\r\n                        continue;\r\n                    }\r\n                }\r\n            } else if (\r\n                !(\r\n                    extreme\r\n                    && (state = this.finallize(context, extreme))\r\n                )\r\n            ) {\r\n                break;\r\n            }\r\n            if (extreme) {\r\n                if (hook && extreme[MATCHED_RECORDS.left] <= begin && hook(tokens[begin])) {\r\n                    context.restore(point);\r\n                    return tokens[begin];\r\n                }\r\n                cursor = extreme[MATCHED_RECORDS.left];\r\n            }\r\n            cursor >= begin && state !== -1 && (cursor = backflow_tape[cursor]);\r\n            state = 0;\r\n            extreme = undefined;\r\n            backflow_tape.splice(cursor + 1, backflow_tape.length - (cursor + 1));\r\n        }\r\n        context.restore(point);\r\n    }\r\n    parseNode(\r\n        match_tree: Record<string, any>,\r\n        test: (node: Node) => boolean,\r\n        context: Context,\r\n        token?: Token\r\n    ) {\r\n        let tokens = token\r\n            ? (context[CONTEXT.tokens] = token.content)\r\n            : context[CONTEXT.tokens];\r\n        context.wrap(CONTEXT.isExpression, true);\r\n        this.parseCustom(\r\n            match_tree,\r\n            context\r\n        );\r\n        context.unwrap();\r\n        if (tokens.length) {\r\n            if (test(tokens[0])) {\r\n                tokens.length > 1 && this.err(...tokens.slice(1));\r\n                return tokens[0];\r\n            }\r\n            this.err(...tokens);\r\n        } else if (token) {\r\n            this.err(token);\r\n        }\r\n    }\r\n    parseIdentifier = parseIdentifier;\r\n    parseKeyword({ value, range, loc }: Token): Node {\r\n        return {\r\n            type: \"Keyword\",\r\n            value,\r\n            range,\r\n            loc\r\n        };\r\n    }\r\n    parseDirective(node: Node) {\r\n        let expression = node.expression;\r\n        if (\r\n            expression\r\n            && expression.type === \"Literal\"\r\n            && typeof expression.value === \"string\"\r\n            && expression.raw.length > 2\r\n        ) {\r\n            return new Directive(\r\n                node.type,\r\n                node.expression,\r\n                expression.raw.slice(1, -1),\r\n                node.range,\r\n                node.loc\r\n            );\r\n        }\r\n        return node;\r\n    }\r\n\r\n    walk(\r\n        root: Record<string, any>,\r\n        context: Context,\r\n        index: number,\r\n        backflow_tape: Array<number>,\r\n        minimum: number\r\n    ): Longest {\r\n        let padding_token = this.padding_token;\r\n        let TYPE_ALIAS = this.TYPE_ALIAS;\r\n        let tokens = context[CONTEXT.tokens];\r\n        //let steps: Array<number> = [];\r\n        return next(\r\n            root,\r\n            index >= context[CONTEXT.begin] ? tokens[index] : padding_token,\r\n            index,\r\n            index\r\n        );\r\n\r\n        function next(parent: Record<string, any>, token: Token, start: number, end: number): Longest {\r\n            let has_backflow = false;\r\n            if (backflow_tape.length <= end + 1) {\r\n                has_backflow = true;\r\n                backflow_tape.push(start);\r\n            }\r\n            let alias = TYPE_ALIAS[token.type];\r\n            if (!alias) {\r\n                return explore(token.type);\r\n            } else {\r\n                let index = 0, longest: Extreme;\r\n                while (index < alias.length) {\r\n                    longest = explore(alias[index++]) || longest;\r\n                }\r\n                return longest;\r\n            }\r\n\r\n            function explore(type: string | number): Longest {\r\n                let node: Record<string, any>, next_token: Record<string, any>;\r\n                let res: Longest, matched: Matched, matched_node: Record<string, any>;\r\n                let value_node: Record<string, any>, type_node: Record<string, any>;\r\n                if (!(node = parent[type])) {\r\n                    return;\r\n                }\r\n                next_token = tokens[end + 1] || (end < tokens.length && padding_token);//末尾溢出一个填充节点\r\n                value_node = node[token.value];\r\n                if (!(\r\n                    next_token && value_node\r\n                    && (res = next(value_node, next_token, start, end + 1))\r\n                )) {\r\n                    type_node = node[MATCH_MARKS.TYPE_ONLY];\r\n                    if (!(\r\n                        next_token && type_node\r\n                        && (res = next(type_node, next_token, start, end + 1))\r\n                    )) {\r\n                        if (\r\n                            !(end <= minimum)\r\n                            && (\r\n                                matched =\r\n                                (matched_node = value_node) && matched_node[MATCH_MARKS.MATCH_END]\r\n                                || (matched_node = type_node) && matched_node[MATCH_MARKS.MATCH_END]\r\n                            )\r\n                        ) {\r\n                            if (\r\n                                !matched[MATCHED.filter]\r\n                                || matched[MATCHED.filter](context, start, end)\r\n                            ) {\r\n                                minimum = end;\r\n                                res = [\r\n                                    matched[MATCHED.precedence],\r\n                                    start,\r\n                                    end,\r\n                                    matched\r\n                                ];\r\n                            } else if (has_backflow && end > start) {\r\n                                backflow_tape.splice(end + 1, backflow_tape.length - end - 1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return res;\r\n            }\r\n        }\r\n    }\r\n    createNode(context: Context) {\r\n        let left = context[CONTEXT.left];\r\n        let right = context[CONTEXT.right];\r\n        let matched = context[CONTEXT.matched];\r\n        let tokens = context[CONTEXT.tokens];\r\n        let begin = context[CONTEXT.begin];\r\n        let node: any = new matched[MATCHED.wrapper]();\r\n        let length = tokens.length;\r\n        let start = left, end = right < length ? right : length - 1;\r\n        let offset = left, key: string, watchers: Array<Watcher>;\r\n\r\n        context[CONTEXT.collected] = node;\r\n        for (const prop of matched[MATCHED.props]) {\r\n            if (!(prop instanceof Mark)) {\r\n                [key, watchers] = (prop as any);\r\n                let token: Token = offset >= begin && offset < length ? tokens[offset] : null;\r\n                if (key) {\r\n                    if (token && end < offset) {\r\n                        end = offset;\r\n                    }\r\n                    if (node[key] === undefined) {\r\n                        node[key] = token;\r\n                    } else {\r\n                        if (node[key] instanceof Array) {\r\n                            node[key].push(token)\r\n                        } else {\r\n                            node[key] = [node[key], token];\r\n                        }\r\n                    }\r\n                } else if (key === null) {\r\n                    if (offset === start) {\r\n                        offset < end && (start = offset + 1);\r\n                    } else if (offset > begin && offset - 1 < end) {\r\n                        end = offset - 1;\r\n                    }\r\n                } else if (token && end < offset) {\r\n                    end = offset;\r\n                }\r\n                for (let i in watchers) {\r\n                    watchers[i](context, token);\r\n                    context[CONTEXT.left] = left;\r\n                    context[CONTEXT.right] = right;\r\n                    context[CONTEXT.matched] = matched;\r\n                    context[CONTEXT.tokens] = tokens;\r\n                    context[CONTEXT.collected] = node\r\n                }\r\n                offset += 1;\r\n            } else {\r\n                node[prop.key] = prop.value;\r\n            }\r\n        }\r\n\r\n        start >= begin || (start = begin);\r\n\r\n        let start_token = tokens[start];\r\n        let end_token = tokens[end];\r\n        node.range = [start_token.range[0], end_token.range[1]];\r\n        node.loc = {\r\n            start: start_token.loc.start,\r\n            end: end_token.loc.end\r\n        }\r\n        context[CONTEXT.start] = start;\r\n        context[CONTEXT.end] = end;\r\n        return node;\r\n    }\r\n    finallize(\r\n        context: Context,\r\n        record: Extreme\r\n    ) {\r\n        let [_, left, right, matched/*, steps*/] = record;\r\n        let validator = matched[MATCHED.validator];\r\n        let collected: any;\r\n        let start: number, end: number;\r\n        context[CONTEXT.left] = left;\r\n        context[CONTEXT.right] = right;\r\n        context[CONTEXT.matched] = matched;\r\n        let tokens = context[CONTEXT.tokens];\r\n        let handler = matched[MATCHED.handler];\r\n        if (!validator || (collected = validator(context)) === true) {\r\n            collected = this.createNode(context);\r\n            start = context[CONTEXT.start];\r\n            end = context[CONTEXT.end];\r\n            if (handler) {\r\n                collected = handler(context);\r\n            }\r\n        } else if (collected) {\r\n            start = context[CONTEXT.start];\r\n            end = context[CONTEXT.end];\r\n        }\r\n        context[CONTEXT.tokens] = tokens;\r\n        if (!collected) {\r\n            return collected === undefined || collected === false\r\n                ? 0\r\n                : (collected === null ? 1 : -1);\r\n        }\r\n        //debugger;\r\n        /*if (tokens === this.tokens) {\r\n            debugger;\r\n        }*/\r\n\r\n        let length = end - start + 1;\r\n        if (collected instanceof Array) {\r\n            tokens.splice(start, length, ...collected);\r\n        } else {\r\n            tokens.splice(start, length, collected);\r\n        }\r\n        return length;\r\n    }\r\n}\r\n","\r\nimport {\r\n    Node, Token, Context, CONTEXT\r\n} from '../interfaces';\r\nimport {\r\n    createMatchTree,\r\n    _Option, _Or, _Series, _NonCollecting, _NonCapturing, _Mark,\r\n    TYPE_ALIAS, _Context, _Loop, NODES, MATCH_MARKS,\r\n    validateBinding, validateLineTerminator, ASSIGNMENT_PUNCTUATORS_PATTERN, join_content, AWAIT_LIST\r\n} from './head'\r\nimport { isExpression, isStatementListItem, get_inner_group, parse_and_extract } from './index';\r\n\r\nimport { PRIMARY_EXPRESSION_TREE } from './expression';\r\n//import { MEMBER_EXPRESSION_TREE } from './expression';\r\nconst Grouping = NODES.Grouping;\r\n\r\nlet PETTERN_ELEMENTS_TREE: Record<string, any>;\r\nlet PATTERN_PROPERTIES_TREE: Record<string, any>;\r\n\r\nAWAIT_LIST.push(function () {\r\n    //({ MEMBER_EXPRESSION_TREE } = await require('./expression'));\r\n    PETTERN_ELEMENTS_TREE = createMatchTree(\r\n        PatternElements,\r\n        PRIMARY_EXPRESSION_TREE\r\n    );\r\n    PATTERN_PROPERTIES_TREE = createMatchTree(\r\n        PatternProperties,\r\n        PRIMARY_EXPRESSION_TREE\r\n    );\r\n});\r\n\r\n\r\nconst Patterns: Record<string, any> = {\r\n    ArrayPattern: {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            collected.is_binding || context.wrap(CONTEXT.bindingSet, null);\r\n            let res = parseArrayPattern(context, collected.elements);\r\n            collected.is_binding || context.unwrap();\r\n            return res;\r\n        },\r\n        precedence: 20,\r\n        filter: [\r\n            null,\r\n            function (context: Context) {\r\n                return context[CONTEXT.bindingElement] === context[CONTEXT.tokens];\r\n            }\r\n        ],\r\n        collector: [\r\n            {\r\n                elements: _Or(\"Punctuator []\"),\r\n                _next: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN),//+=\r\n            },\r\n            {\r\n                _prev: _NonCapturing(\"Punctuator  ...\", MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                elements: _Or(\"Punctuator []\"),\r\n                is_binding: _Mark(true)\r\n            }\r\n        ]\r\n    },\r\n    ObjectPattern: {\r\n        handler: function (context: Context) {\r\n            let [collected] = context;\r\n            collected.is_binding || context.wrap(CONTEXT.bindingSet, null);\r\n            let res = parseObjectPattern(context, collected.properties);\r\n            collected.is_binding || context.unwrap();\r\n            return res;\r\n        },\r\n        precedence: 20,\r\n        filter: [\r\n            null, null,\r\n            function (context: Context, left: number, right: number) {\r\n                let tokens = context[CONTEXT.tokens];\r\n                return context[CONTEXT.bindingElement] === tokens\r\n                    || context[CONTEXT.isExpression];\r\n            },\r\n            function (context: Context) {\r\n                return context[CONTEXT.bindingElement] === context[CONTEXT.tokens];\r\n            }\r\n        ],\r\n        collector: [\r\n            {\r\n                type: _Mark(\"ObjectPattern\"),\r\n                _prev: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN),\r\n                properties: _Or(\"Punctuator {}\"),\r\n                _next: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN)\r\n            },\r\n            [\r\n                [\"_prev\", _NonCapturing(\"Punctuator  ,\")],\r\n                [\"is_binding\", _Mark(true)]\r\n            ],\r\n            [\"_prev\", _Mark()],\r\n            {\r\n                type: _Mark(\"ObjectPattern\"),\r\n                _prev: _NonCapturing(\"Punctuator ...\", MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                properties: _Or(\"Punctuator {}\"),\r\n                is_binding: _Mark(true)\r\n            }\r\n        ]\r\n    },\r\n    AssignmentPattern: {\r\n        filter(context: Context) {\r\n            return context[CONTEXT.bindingElement] === context[CONTEXT.tokens];\r\n        },\r\n        precedence: 1.5,\r\n        collector: {\r\n            _: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n            left: _Or(\r\n                \"ArrayPattern\", \"ObjectPattern\",\r\n                _Or(\"Identifier\").watch(\r\n                    function (context: Context, identifier: Node) {\r\n                        if (identifier instanceof Grouping) {\r\n                            context[CONTEXT.parser].err(identifier);\r\n                        } else {\r\n                            validateBinding(context, identifier);\r\n                        }\r\n                    }\r\n                )\r\n            ),\r\n            __: _NonCollecting(\"Punctuator =\"),\r\n            right: \"[Expression]\"\r\n        }\r\n    },\r\n    \"\": {\r\n        handler(context: Context) {\r\n            let [{ token }, parser, tokens, left, right] = context;\r\n            if (right - left >= 2 && context[CONTEXT.bindingElement] === tokens) {\r\n                parser.err(token);\r\n            }\r\n            token = get_inner_group(token);\r\n            let store = context.store(CONTEXT.bindingElement, token.content, CONTEXT.bindingSet, null);\r\n            let node = parser.parseNode(\r\n                PRIMARY_EXPRESSION_TREE,\r\n                node => isExpression(node)\r\n                    || node.type === \"ArrayPattern\"\r\n                    || node.type === \"ObjectPattern\"\r\n                    || node.type === \"AssignmentPattern\",\r\n                context,\r\n                token\r\n            );\r\n            context.restore(store);\r\n            return new Grouping(node, token);\r\n        },\r\n        precedence: [100, new Number(3)],\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(\"Punctuator ,\", MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                token: _Or(\"Punctuator ()\"),\r\n                _next: _NonCapturing(ASSIGNMENT_PUNCTUATORS_PATTERN)\r\n            },\r\n            [\r\n                [\"_prev\", _Mark()],\r\n                [\"prevent_binding\", _Mark(true)]\r\n            ]\r\n        ]\r\n    }\r\n};\r\nexport {\r\n    Patterns,\r\n    parseArrayPattern,\r\n    parseObjectPattern\r\n}\r\n\r\n\r\nfunction parseArrayPattern(context: Context, token: Token): Node {\r\n    let pattern = new NODES.ArrayPattern();\r\n    context.wrap(CONTEXT.bindingElement, token.content);\r\n    pattern.elements = parse_and_extract(PETTERN_ELEMENTS_TREE, context, token);\r\n    context.unwrap();\r\n    pattern.range = token.range;\r\n    pattern.loc = token.loc;\r\n    return pattern;\r\n}\r\nfunction parseObjectPattern(context: Context, token: Token): Node {\r\n    let pattern = new NODES.ObjectPattern();\r\n    context.wrap(CONTEXT.bindingElement, token.content);\r\n    pattern.properties = parse_and_extract(PATTERN_PROPERTIES_TREE, context, token);\r\n    context.unwrap();\r\n    pattern.range = token.range;\r\n    pattern.loc = token.loc;\r\n    return pattern;\r\n}\r\n\r\nlet PatternElements = {\r\n    Success: {\r\n        handler: join_content,\r\n        collector: [\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: _Or(\r\n                    _Or(\"Identifier\").watch(\r\n                        function (context: Context, identifier: Token) {\r\n                            if (identifier instanceof Grouping) {\r\n                                context[CONTEXT.parser].err(identifier);\r\n                            } else {\r\n                                validateBinding(context, identifier);\r\n                            }\r\n                        }\r\n                    ),\r\n                    _Or(\"ArrayPattern\", \"ObjectPattern\", \"AssignmentPattern\")\r\n                ),\r\n                _next: _NonCollecting(_Or(\"Punctuator ,\", MATCH_MARKS.BOUNDARY))\r\n            },\r\n            [\r\n                [\"content\", \"RestElement\"],\r\n                [\"_next\", _NonCollecting(MATCH_MARKS.BOUNDARY)]\r\n            ],\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: _Mark(null),\r\n                _next: _NonCollecting(\"Punctuator ,\")\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\nconst PatternProperties = {\r\n    Success: {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: {\r\n            success: _Or(_NonCollecting(MATCH_MARKS.BOUNDARY), \"Success\"),\r\n            content: \"Property\",\r\n        }\r\n\r\n    },\r\n    Property: [\r\n        {\r\n            handler(context: Context) {\r\n                let [collected, parser] = context;\r\n                let { key, value } = collected;\r\n                if (key.type === \"Punctuator\") {\r\n                    collected.key = parser.parseExpression(context, key);//SequenceExpression\r\n                }\r\n                if (!value) {\r\n                    collected.value = key;\r\n                    validateBinding(context, key);\r\n                } else {\r\n                    let init: Node;\r\n                    if (collected.shorthand) {\r\n                        init = value;\r\n                        value = key;\r\n                        validateBinding(context, value);\r\n                    } else {\r\n                        if (value instanceof Array) {\r\n                            init = value[1];\r\n                            value = value[0];\r\n                        }\r\n                        if (value.type === \"Identifier\") {\r\n                            validateBinding(context, value);\r\n                        } else {\r\n                            value = (\r\n                                value.value === \"[]\"\r\n                                    ? parseArrayPattern\r\n                                    : parseObjectPattern\r\n                            )(context, value);\r\n                        }\r\n                    }\r\n                    collected.value = init ? {\r\n                        type: \"AssignmentPattern\",\r\n                        left: value,\r\n                        right: init\r\n                    } : value;\r\n                }\r\n                return collected;\r\n            },\r\n            collector: [\r\n                {\r\n                    _prev: _NonCapturing(MATCH_MARKS.BOUNDARY, \"Property\"),\r\n                    key: \"Punctuator []\",\r\n                    value: _Series(\r\n                        _NonCollecting(\"Punctuator :\"),\r\n                        _Or(\"Identifier\", \"Punctuator [] {}\"),\r\n                        _Option(_Series(_NonCollecting(\"Punctuator =\"), \"[Expression]\"))\r\n                    ),\r\n                    _next: _NonCollecting(MATCH_MARKS.BOUNDARY, \"Punctuator ,\"),\r\n                    computed: _Mark(true),\r\n                    kind: _Mark(\"init\"),\r\n                    method: _Mark(false),\r\n                    shorthand: _Mark(false),\r\n                },\r\n                [\r\n                    [\r\n                        \"key\",\r\n                        _Or(\"Identifier\").watch(\r\n                            function (context: Context, identifier: Node) {\r\n                                if (identifier instanceof Grouping) {\r\n                                    context[CONTEXT.parser].err(identifier);\r\n                                }\r\n                            }\r\n                        )\r\n                    ],\r\n                    [\"computed\", _Mark(false)]\r\n                ],\r\n                [\r\n                    [\"value\", _Option(_Series(_NonCollecting(\"Punctuator =\"), \"[Expression]\"))],\r\n                    [\"shorthand\", _Mark(true)]\r\n                ]\r\n            ]\r\n        },\r\n        {\r\n            validator() {//匹配占位\r\n                return false;\r\n            },\r\n            precedence: new Number(3),\r\n            collector: {\r\n                __: _Series(\r\n                    _Or(MATCH_MARKS.BOUNDARY, \"Property\"),\r\n                    _Or(\r\n                        \"Punctuator []\",\r\n                        \"Identifier\",\r\n                    ),\r\n                    \"Punctuator :\",\r\n                    _Or(\r\n                        \"Identifier\",\r\n                        \"Punctuator [] {}\",\r\n                    ),\r\n                    \"Punctuator =\"\r\n                )\r\n            }\r\n        }\r\n    ]\r\n}\r\n","\r\nimport {\r\n    Context, CONTEXT, Node, Token\r\n} from '../interfaces';\r\nimport {\r\n    isExpression, isStatement, isStatementListItem,\r\n    parse_next_statement, get_inner_group,\r\n} from './index'\r\nimport {\r\n    createMatchTree,\r\n    NODES, MATCH_MARKS,\r\n    _Option, _Or, _Series, _NonCollecting, _Mark, _Loop, TYPE_ALIAS,\r\n    validateBinding, validateLineTerminator, _NonCapturing,\r\n    validateIdentifier, validateAssignment,\r\n    STATEMANT_LIST_ITEM_PATTERN,\r\n    TOPLEVEL_ITEM_PATTERN,\r\n    RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN,\r\n    EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n    isAligned,\r\n} from './head'\r\nimport {\r\n    EXPRESSION_TREE,\r\n    parseArrayPattern,\r\n    parseObjectPattern,\r\n    parse_params\r\n\r\n} from './expression';\r\nimport Declaration from './declaration';\r\nconst Grouping = NODES.Grouping;\r\nlet { VariableDeclaration } = Declaration;\r\n\r\nconst Statements: Record<string, any> = {\r\n    \"\": {\r\n        handler([collected, parser]: Context) {\r\n            parser.err(collected.error);\r\n            return [];\r\n        },\r\n        precedence: -1,\r\n        collector: [\r\n            {\r\n                error: _Or(\"Punctuator\", \"Keyword\"),\r\n                _next: _NonCapturing(RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN),\r\n            }\r\n        ]\r\n    },\r\n    \"BreakStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            let label = collected.label;\r\n            if (label) {\r\n                if (\r\n                    label instanceof Grouping\r\n                    || context[CONTEXT.labelSet].indexOf(label.name) < 0\r\n                ) {\r\n                    parser.err(label);\r\n                }\r\n            } else if (!context[CONTEXT.inIteration] && !context[CONTEXT.inSwitch]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        filter: [\r\n            function (context: Context, left: number) {\r\n                return isAligned(context, left, left + 1);\r\n            },\r\n            null,\r\n        ],\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword break\"),\r\n                label: IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            },\r\n            [\"label\", _Mark(null)]\r\n        ]\r\n    },\r\n    \"ContinueStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            let label = collected.label;\r\n            validateLineTerminator(context);\r\n            if (label) {\r\n                if (\r\n                    label instanceof Grouping\r\n                    || context[CONTEXT.labelSet].indexOf(label.name) < 0\r\n                ) {\r\n                    parser.err(label);\r\n                }\r\n            } else if (!context[CONTEXT.inIteration]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        filter: \"BreakStatement\",\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword continue\"),\r\n                label: IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            },\r\n            [\"label\", _Mark(null)],\r\n        ]\r\n    },\r\n    \"ReturnStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.inFunctionBody]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        validator(context: Context) {\r\n            let [, , tokens, left, right] = context;\r\n            if (left === right) {\r\n                let next_token = tokens[left + 1];\r\n                if (next_token && tokens[left].loc.end.line === next_token.loc.start.line) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        filter: \"BreakStatement\",\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword return\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            },\r\n            [\"argument\", _Mark(null)]\r\n        ]\r\n    },\r\n    \"BlockStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            collected.body = parser.parseBlock(context, collected.body);\r\n            return collected;\r\n        },\r\n        overload: true,//和 ObjectPattern 收集器有重叠，在存在 BlockStatement 的环境， ObjectPattern 的 filter 不会返回 true，这里强制覆盖\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                body: \"Punctuator {}\"\r\n            }\r\n        ]\r\n    },\r\n    \"DoWhileStatement\": {\r\n        validator: \"ForStatement\",\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            collected.test = parser.parseExpression(context, collected.test);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                keyword: _NonCollecting(\"Keyword do\"),\r\n            },\r\n            [\r\n                [\"body\", STATEMANT_LIST_ITEM_PATTERN],\r\n                [\"test\", _Series(_NonCollecting(\"Keyword while\"), \"Punctuator ()\")],\r\n                [\"_next\", _Option(\"Punctuator ;\")]\r\n            ]\r\n        ]\r\n    },\r\n    \"EmptyStatement\": [\r\n        {\r\n            precedence: 100,\r\n            collector: [\r\n                {\r\n                    _prev: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\r\n                    _: _NonCollecting(\"Punctuator ;\")\r\n                }\r\n            ]\r\n        }\r\n    ],\r\n    \"ExpressionStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser, tokens, left] = context;\r\n            validateLineTerminator(context);\r\n            let prev_node = tokens[left - 1];\r\n            if (\r\n                (!prev_node || prev_node.directive)\r\n                && (\r\n                    tokens === parser.tokens\r\n                    || tokens === context[CONTEXT.inFunctionBody]\r\n                )\r\n            ) {\r\n                collected = parser.parseDirective(collected);\r\n                switch (collected.directive) {\r\n                    case \"use strict\":\r\n                        context[CONTEXT.strict] = true;\r\n                        break;\r\n                }\r\n            }\r\n            return collected;\r\n        },\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                expression: EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"ForStatement\": {\r\n        validator: [\r\n            function (context: Context) {\r\n                context.wrap(CONTEXT.inIteration, true);\r\n                let res = parse_next_statement(context);\r\n                context.unwrap();\r\n                return res;\r\n            },\r\n            null\r\n        ],\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            let { iterator, body, range, loc } = collected;\r\n            let iterator_tokens = iterator.content;\r\n            context.wrap(CONTEXT.isExpression, true);\r\n            context[CONTEXT.tokens] = iterator_tokens;\r\n            parser.parseCustom(FOR_ITERATOR_TREE, context);\r\n            context.unwrap();\r\n            if (iterator_tokens.length > 0) {\r\n                let index = 0;\r\n                if (isStatement(iterator_tokens[0])) {\r\n                    collected = iterator_tokens[0];\r\n                    collected.body = body;\r\n                    collected.range = range;\r\n                    collected.loc = loc;\r\n                    index = 1;\r\n                }\r\n                if (iterator_tokens.length > index) {\r\n                    parser.err(...iterator_tokens.slice(index));\r\n                }\r\n            }\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                keyword: _NonCollecting(\"Keyword for\"),\r\n                iterator: \"Punctuator ()\"\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    },\r\n    \"ForInStatement\": {//ForStatement\r\n    },\r\n    \"ForOfStatement\": {//ForStatement\r\n    },\r\n    \"IfStatement\": {\r\n        validator(context: Context) {\r\n            let [, , , left, right] = context;\r\n            if ((right - left) % 2 === 1) {\r\n                return parse_next_statement(context);\r\n            }\r\n            return true;\r\n        },\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            collected.test = parser.parseExpression(context, collected.test);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword if\"),\r\n                test: \"Punctuator ()\",\r\n                consequent: _Mark(null),\r\n                alternate: _Mark(null)\r\n            },\r\n            [\"consequent\", STATEMANT_LIST_ITEM_PATTERN],\r\n            [\r\n                \"alternate\", _Series(\r\n                    _NonCollecting(\"Keyword else\"),\r\n                    _Option(STATEMANT_LIST_ITEM_PATTERN)\r\n                )\r\n            ]\r\n        ]\r\n    },\r\n    \"LabeledStatement\": {\r\n        validator: [\r\n            function (context: Context) {\r\n                let [, parser, tokens, left] = context;\r\n                let label = tokens[left];\r\n                let label_name = label.name;\r\n                let label_set = context[CONTEXT.labelSet];\r\n                if (label_set.indexOf(label_name) >= 0) {\r\n                    parser.err(label);\r\n                }\r\n                let index = label_set.push(label_name) - 1;\r\n                let res = parse_next_statement(context);\r\n                label_set.splice(index, 1);\r\n                return res;\r\n            },\r\n            null\r\n        ],\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                label: _Series(\r\n                    IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                    _NonCollecting(\"Punctuator :\")\r\n                )\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    },\r\n    \"SwitchStatement\": [\r\n        {\r\n            handler(context: Context) {\r\n                let [collected, parser] = context;\r\n                let { discriminant } = collected;\r\n                collected.discriminant = parser.parseExpression(context, discriminant);\r\n                collected.discriminant || parser.err(discriminant);\r\n                collected.cases = context[CONTEXT.tokens] = collected.cases.content;\r\n                context.wrap(CONTEXT.inSwitch, context[CONTEXT.tokens]);\r\n                parser.parseCustom(parser.SYNTAX_TREE, context);\r\n                context.unwrap();\r\n                let has_default = false;\r\n                for (const item of collected.cases) {\r\n                    if (item.type === \"SwitchCase\") {\r\n                        if (item.test) {\r\n                            continue;\r\n                        }\r\n                        if (!has_default) {\r\n                            has_default = true;\r\n                            continue;\r\n                        }\r\n                    }\r\n                    parser.err(item);\r\n                }\r\n                return collected;\r\n            },\r\n            collector: [\r\n                {\r\n                    token: _NonCollecting(\"Keyword switch\"),\r\n                    discriminant: \"Punctuator ()\",\r\n                    cases: \"Punctuator {}\"\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            handler([collected]: Context) {\r\n                collected.consequent = [];\r\n                return collected;\r\n            },\r\n            precedence: 0,\r\n            filter(content: Context) {\r\n                return content[CONTEXT.inSwitch] === content[CONTEXT.tokens];\r\n            },\r\n            collector: [\r\n                {\r\n                    type: _Mark(\"SwitchCase\"),\r\n                    test: _Or(\r\n                        _Series(\r\n                            _NonCollecting(\"Keyword case\"),\r\n                            EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\r\n                        ),\r\n                        _Series(\r\n                            _NonCollecting(\"Keyword default\"),\r\n                            _Mark(null)\r\n                        )\r\n                    ),\r\n                    __: _NonCollecting(\"Punctuator :\")\r\n                },\r\n            ]\r\n        },\r\n        {\r\n            handler([collected]: Context) {\r\n                collected.token.consequent.push(collected.consequent)\r\n                return collected.token;\r\n            },\r\n            collector: {\r\n                token: \"SwitchCase\",\r\n                consequent: STATEMANT_LIST_ITEM_PATTERN\r\n            }\r\n        }\r\n    ],\r\n    \"ThrowStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (collected.loc.start.line !== collected.argument.loc.start.line) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword throw\"),\r\n                argument: EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"TryStatement\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            let { block, handler, finalizer } = collected;\r\n            collected.block = { type: \"BlockStatement\", body: parser.parseBlock(context, block) }\r\n            if (handler) {\r\n                let [param, body] = handler;\r\n                let params = parse_params(context, param.content);\r\n                if (params.length !== 1) {\r\n                    parser.err(param);\r\n                }\r\n                collected.handler = {\r\n                    type: \"CatchClause\",\r\n                    param: params[0],\r\n                    body: { type: \"BlockStatement\", body: parser.parseBlock(context, body) }\r\n                };\r\n            }\r\n            if (finalizer) {\r\n                collected.finalizer = { type: \"BlockStatement\", body: parser.parseBlock(context, finalizer) };\r\n            }\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword try\"),\r\n                block: \"Punctuator {}\",\r\n                handler: _Series(_NonCollecting(\"Keyword catch\"), \"Punctuator ()\", \"Punctuator {}\"),\r\n                finalizer: _Mark(null)\r\n            },\r\n            [\"finalizer\", _Series(_NonCollecting(\"Keyword finally\"), \"Punctuator {}\")],\r\n            [\"handler\", _Mark(null)],\r\n        ]\r\n    },\r\n    \"WhileStatement\": {\r\n        validator: \"ForStatement\",\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            collected.test = parser.parseExpression(context, collected.test);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword while\"),\r\n                test: \"Punctuator ()\"\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    },\r\n    \"WithStatement\": {\r\n        validator: [\r\n            parse_next_statement,\r\n            null\r\n        ],\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            if (context[CONTEXT.strict]) {\r\n                parser.err(collected);\r\n            }\r\n            collected.object = parser.parseExpression(context, collected.object);\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: \"Keyword with\",\r\n                object: \"Punctuator ()\"\r\n            },\r\n            [\"body\", STATEMANT_LIST_ITEM_PATTERN]\r\n        ]\r\n    }\r\n};\r\n\r\nfor (const type_name in Statements) {\r\n    if (type_name) {\r\n        type_name && (TYPE_ALIAS[type_name] = [type_name, \"[Statement]\"]);\r\n    }\r\n}\r\nexport default Statements;\r\n\r\nlet ForIterator = {\r\n    VariableDeclaration,\r\n    ForStatement: [\r\n        {\r\n            collector: [\r\n                {\r\n                    init: _Or(\r\n                        \"VariableDeclaration\",\r\n                        _Series(\r\n                            _NonCollecting(MATCH_MARKS.BOUNDARY),\r\n                            _Or(EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),//EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS\r\n                            _NonCollecting(\"Punctuator ;\")\r\n                        )\r\n                    ),\r\n                    test: _Series(\r\n                        _Or(EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                        _NonCollecting(\"Punctuator ;\")\r\n                    ),\r\n                    update: _Series(\r\n                        _Or(EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, _Mark(null)),\r\n                        _NonCollecting(MATCH_MARKS.BOUNDARY)\r\n                    ),\r\n                    body: _Mark(null)\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            handler(context: Context) {\r\n                let [collected, parser] = context;\r\n                let { left } = collected;\r\n                let kind: Node, declarator: Node;\r\n                if (left instanceof Array) {\r\n                    [kind, declarator] = left;\r\n                } else {\r\n                    declarator = left;\r\n                }\r\n                if (declarator.value === \"()\" && declarator.type === \"Punctuator\") {\r\n                    let wrapper = declarator;\r\n                    declarator = get_inner_group(declarator);\r\n                    if (declarator.content.length > 0) {\r\n                        if (kind) {\r\n                            parser.err(declarator);\r\n                        } else if (declarator.content.length > 1) {\r\n                            parser.err(...declarator.content.slice(1));\r\n                        }\r\n                        declarator = new Grouping(declarator.content[0], wrapper);\r\n                    }\r\n                }\r\n                if (declarator.type === \"Punctuator\") {\r\n                    switch (declarator.value) {\r\n                        case \"{}\":\r\n                            declarator = parseObjectPattern(context, declarator);\r\n                            break;\r\n                        case \"[]\":\r\n                            declarator = parseArrayPattern(context, declarator);\r\n                            break;\r\n                        default:\r\n                            parser.err(declarator);\r\n                            declarator = null;\r\n                    }\r\n                } else if (declarator.type !== \"Identifier\") {\r\n                    parser.err(declarator);\r\n                    declarator = null;\r\n                } else {\r\n                    validateAssignment(context, declarator);\r\n                }\r\n                if (kind) {\r\n                    left = new NODES.VariableDeclaration();\r\n                    left.declarations = [\r\n                        {\r\n                            type: \"VariableDeclarator\",\r\n                            id: declarator,\r\n                            init: null\r\n                        }\r\n                    ];\r\n                    left.kind = kind.value;\r\n                    left.range = [kind.range[0], declarator.range[1]];\r\n                    left.loc = {\r\n                        start: kind.loc.start,\r\n                        end: declarator.loc.end\r\n                    };\r\n                    collected.left = left;\r\n                } else {\r\n                    collected.left = declarator;\r\n                }\r\n                return collected;\r\n            },\r\n            validator(context: Context) {\r\n                return context[CONTEXT.right] >= context[CONTEXT.tokens].length;\r\n            },\r\n            filter: [function () { return false }, null],\r\n            precedence: 1.5,\r\n            collector: [\r\n                {\r\n                    _: _Series(//和 VariableDeclaration 不冲突的占位 \r\n                        MATCH_MARKS.BOUNDARY,\r\n                        _Or(\r\n                            _Series(\r\n                                _Or(\"Keyword var const let\"),\r\n                                _Or(\"Identifier\", \"Punctuator {} [] ()\")\r\n                            ),\r\n                            _Series(\r\n                                \"Identifier let\",\r\n                                _Or(\"Identifier\", \"Punctuator {} ()\")\r\n                            )\r\n                        )\r\n\r\n                    )\r\n                },\r\n                {\r\n                    type: _Mark(\"ForOfStatement\"),\r\n                    _prev: _NonCollecting(MATCH_MARKS.BOUNDARY),\r\n                    left: _Series(\r\n                        _Option(_Or(\"Identifier let\", \"Keyword var const let\")),\r\n                        _Or(\"Identifier\", \"Punctuator {} [] ()\")\r\n                    ),\r\n                    token: _NonCollecting(\"Identifier of\"),\r\n                    right: _Option(\r\n                        _Series(\r\n                            EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\r\n                            _Option(_NonCollecting(MATCH_MARKS.BOUNDARY))\r\n                        )\r\n                    ),\r\n                    body: _Mark(null),\r\n                },\r\n                [\r\n                    [\"type\", _Mark(\"ForInStatement\")],\r\n                    [\"token\", _NonCollecting(\"Keyword in\")],\r\n                    [\"each\", _Mark(false)]\r\n                ]\r\n            ]\r\n\r\n        }\r\n    ]\r\n};\r\nlet FOR_ITERATOR_TREE = createMatchTree(ForIterator, EXPRESSION_TREE);\r\n","import {\r\n    Context, CONTEXT, Token, Node\r\n} from '../interfaces';\r\nimport {\r\n    _Option, _Or, _Series, _NonCollecting, _Mark, TYPE_ALIAS, MATCH_MARKS,\r\n    validateLineTerminator, NODES, _NonCapturing, join_content, createMatchTree\r\n} from './head'\r\nimport { parse_and_extract } from './index';\r\nlet Grouping = NODES.Grouping;\r\n\r\nconst STRING_LITERAL_PATTERN = _Or(\"Literal\").watch(\r\n    function (context: Context, token: Token) {\r\n        if (token instanceof Grouping || typeof token.value !== \"string\") {\r\n            context[CONTEXT.parser].err(token);\r\n        }\r\n    }\r\n)\r\n\r\nlet ImportSpecifiers = {\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: \"ImportSpecifier\",\r\n            }\r\n        ]\r\n    },\r\n    ImportSpecifier: {\r\n        collector: {\r\n            _prev: _NonCapturing(\"Success\", MATCH_MARKS.BOUNDARY),\r\n            imported: \"Identifier\",\r\n            local: _Or(\r\n                _Series(\r\n                    _NonCollecting(\"Identifier as\"),\r\n                    \"Identifier\",\r\n                    _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY)\r\n                ),\r\n                _Or(\"Punctuator ,\", MATCH_MARKS.BOUNDARY).watch(\r\n                    function (context: Context) {\r\n                        let [collected] = context;\r\n                        collected.local = collected.imported;\r\n                    }\r\n                )\r\n            )\r\n        }\r\n\r\n    }\r\n}\r\n\r\nconst IMPORT_SPECIFIERS_TREE = createMatchTree(ImportSpecifiers);\r\nconst EXPORT_SPECIFIERS_TREE = createMatchTree({\r\n    \"Success\": {\r\n        handler: join_content,\r\n        precedence: 0,\r\n        collector: [\r\n            {\r\n                success: _Or(MATCH_MARKS.BOUNDARY, \"Success\"),\r\n                content: \"ExportSpecifier\",\r\n            }\r\n        ]\r\n    },\r\n    ExportSpecifier: {\r\n        collector: {\r\n            _prev: _NonCapturing(\"Success\", MATCH_MARKS.BOUNDARY),\r\n            local: \"Identifier\",\r\n            exported: _Or(\r\n                _Series(\r\n                    _NonCollecting(\"Identifier as\"),\r\n                    \"Identifier\",\r\n                    _NonCollecting(\"Punctuator ,\", MATCH_MARKS.BOUNDARY)\r\n                ),\r\n                _Or(\"Punctuator ,\", MATCH_MARKS.BOUNDARY).watch(\r\n                    function (context: Context) {\r\n                        let [collected] = context;\r\n                        collected.exported = collected.local;\r\n                    }\r\n                )\r\n            )\r\n        }\r\n    }\r\n});\r\n\r\nconst ModuleDeclarations: Record<string, any> = {\r\n    \"ImportDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.isModule]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        collector: [\r\n            {\r\n                token: _NonCollecting(\"Keyword import\"),\r\n                specifiers: _Or(\r\n                    _Or(\"Punctuator {}\").watch(\r\n                        function (context: Context, token: Token) {\r\n                            let [collected] = context;\r\n                            collected.specifiers = parse_and_extract(IMPORT_SPECIFIERS_TREE, context, token);\r\n                        }\r\n                    ),\r\n                    _Or(\"Identifier\").watch(\r\n                        function (context: Context, Identifier: Token) {\r\n                            context[CONTEXT.collected].specifiers = [\r\n                                {\r\n                                    type: \"ImportDefaultSpecifier\",\r\n                                    local: Identifier\r\n                                }\r\n                            ]\r\n                        }\r\n                    )\r\n                ),\r\n                _: _NonCollecting(\"Identifier from\"),\r\n                source: STRING_LITERAL_PATTERN,\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    },\r\n    \"ExportAllDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected, parser] = context;\r\n            if (collected.check_line_terminator) {\r\n                delete collected.check_line_terminator;\r\n                validateLineTerminator(context);\r\n            }\r\n            if (!context[CONTEXT.isModule]) {\r\n                parser.err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        collector: {\r\n            _: _NonCollecting(_Series(\"Keyword export\", \"Punctuator *\", \"Identifier from\")),\r\n            source: STRING_LITERAL_PATTERN,\r\n            _next: _Option(\"Punctuator ;\"),\r\n            check_line_terminator: _Mark(true)\r\n        },\r\n    },\r\n    \"ExportNamedDeclaration\": {\r\n        handler: \"ExportAllDeclaration\",\r\n        collector: [\r\n            {\r\n                _: _NonCollecting(\"Keyword export\"),\r\n                declaration: \"VariableDeclaration\",\r\n                specifiers: _Mark(Array),\r\n                source: _Mark(null)\r\n            },\r\n            {\r\n                _: _NonCollecting(\"Keyword export\"),\r\n                declaration: _Mark(null),\r\n                specifiers: _Or(\"Punctuator {}\").watch(\r\n                    function (context: Context, token: Token) {\r\n                        let [collected] = context;\r\n                        collected.specifiers = parse_and_extract(EXPORT_SPECIFIERS_TREE, context, token);\r\n                    }\r\n                ),\r\n                source: _Mark(null),\r\n                _next: _Option(\"Punctuator ;\"),\r\n                check_line_terminator: _Mark(true)\r\n            }\r\n        ]\r\n    },\r\n    \"ExportDefaultDeclaration\": {\r\n        handler(context: Context) {\r\n            let [collected] = context;\r\n            validateLineTerminator(context);\r\n            if (!context[CONTEXT.isModule]) {\r\n                context[CONTEXT.parser].err(collected);\r\n            }\r\n            return collected;\r\n        },\r\n        precedence: 1.5,\r\n        collector: [\r\n            {\r\n                type: _Mark(\"ExportDefaultDeclaration\"),\r\n                _: _NonCollecting(\"Keyword export\"),\r\n                __: _NonCollecting(\"Keyword default\"),\r\n                declaration: \"[Expression]\",\r\n                _next: _Option(\"Punctuator ;\")\r\n            }\r\n        ]\r\n    }\r\n}\r\nexport default ModuleDeclarations;"],"sourceRoot":""}